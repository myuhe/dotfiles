Info file: cl-j,    -*-Text-*-
produced by `texinfo-format-buffer'
from filebuffer `*--cl-j.texi--temporary-buffer*'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* CL: (cl-j).           Emacs Lispのための部分的なCommon Lispサポート
END-INFO-DIR-ENTRY



このファイルはGNU Emacs Common Lispエミュレーションパッケージを文書化す
る。

Copyright (C) 1993 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.

このファイルは、emacs-21.2/man/cl.texiの日本語訳です。




File: cl-j, Node: Top, Next: 概観, Prev: (dir), Up: (dir)

Common Lisp拡張
***************






この文書はCommon Lispから借りたEmacs Lisp機能の集合を記述する。それらの
機能のすべてはここに詳細に記述される。この文書はいかなるCommon Lispの事
前知識も仮定しないが、Emacs Lispの基本知識は仮定する。

* Menu:

* 概観::                        インストール、使用法、その他
* プログラム構造::              引数リスト、`eval-when'、`defalias'
* 述語::
* 制御構造::
* マクロ::                      分配、`define-compiler-macro'
* 宣言::
* シンボル::                    属性リスト、`gensym'
* 数::                          述語、関数、乱数
* 列::                          マッピング関数、検索、ソート
* リスト::
* ハッシュ表::
* 構造体::
* アサーション::
* 効率の配慮::                  ヒントとテクニック
* Common Lispとの互換性::       すべての既知のSteeleとの相違
* 古いCLとの互換性::            すべての既知の古いcl.elとの相違
* Common Lispの移植::           Common Lispコード移植のためのヒント

* Function Index::
* Variable Index::

 -- The Detailed Node Listing ---

概観

* 使用法::                      CLパッケージの使い方
* 構成::                        パッケージの5つの構成ファイル
* インストール::                CLのコンパイルとインストール
* 命名規約::                    CL関数名に関する記録

プログラム構造

* 引数リスト::
* 評価の時間::
* 関数別名::

述語

* データ型の述語::
* 等値の述語::

制御構造

* 代入::
* 汎変数::
* 変数束縛::
* 条件付き実行::
* ブロックと脱出::
* 繰り返し::
* ループ機能::                  Common Lisp `loop'マクロ
* 多値::

汎変数

* 基本的setf::
* 修正マクロ::
* setf独自化::

変数束縛

* 動的束縛::
* レキシカルな束縛::
* 関数束縛::
* マクロ束縛::

ループ機能

* ループの基本::
* ループの例::
* For節::
* 繰り返し節::
* 蓄積節::
* その他の節::

シンボル

* 属性リスト::
* シンボル生成::

数

* 数の述語::
* 数の関数::
* 乱数::
* 処理系パラメータ::

列

* 列の基本::                    すべての列関数で共有される引数
* 列上のマッピング::
* 列関数::
* 列の検索::
* 列のソート::

リスト

* リスト関数::
* 式の置き換え::
* 集合としてのリスト::
* 連想リスト::




File: cl-j, Node: 概観, Next: プログラム構造, Prev: Top, Up: Top

概観
****

Common Lispは巨大な言語であり、Common Lispシステムは大規模できわめて複
雑になりがちである。Emacs Lispは対照的に、プログラマに提供するLisp機能
の選択に関してはむしろ最小主義者である。

Emacs Lispプログラマの数が増えるにつれ、そして彼らの書くアプリケーショ
ンがさらに野心的になるにつれ、Emacs LispはCommon Lispの多くの便利な機能
から利益を得られることが明らかになってきた。

"CL"パッケージはかなりの数のCommon Lisp関数と制御構造をEmacs Lispに加え
る。100%完全なCommon Lisp処理系ではないが、"CL"はEmacs Lispプログラミン
グをかなり便利にするために十分な機能を加える。

いくつかのCommon Lisp機能はさまざまな理由でこのパッケージから省略された:

   * いくつかの機能はEmacs Lispプログラマにとって、その利益に比べてあま
     りに複雑または大き過ぎる。CLOSとCommon Lispストリームはこのグルー
     プの好例である。

   * 他の機能はEmacs Lispインタプリタ自身の変更なしには実装できない;多
     値戻し、レキシカルスコープ、大文字小文字の区別のないシンボル、そし
     て複素数。

     "CL"パッケージは一般的にこれらの機能をエミュレートしようとしない。

   * いくつかの機能はEmacs Lispに存在するものと衝突する。例えば、Emacs
     の`assoc'関数はCommon Lispの`assoc'と非互換である。このような場合、
     このパッケージは通常、Common Lisp版の関数名に接尾辞`*'を加える(例
     えば、`assoc*')。

ここで記述されているパッケージはDave Gillespie, `daveg@synaptics.com'に
よって書かれた。それはCesar Quirozによるオリジナルの1986 `cl.el'パッケー
ジの完全な書き直しである。

Quirozパッケージの多くの機能は保たれている; すべての非互換は下文の記述
に注釈されている。この版では各関数は効率的に、簡潔に、そしてEmacs環境の
残りの部分への影響を最小にするよう注意が払われている。

* Menu:

* 使用法::                      CLパッケージの使い方
* 構成::                        パッケージの5つの構成ファイル
* インストール::                CLのコンパイルとインストール
* 命名規約::                    CL関数名に関する記録



File: cl-j, Node: 使用法, Next: 構成, Prev: 概観, Up: 概観

使用法
======

"CL"パッケージの機能を使うLispコードは先頭に下記を含める:

     (require 'cl)

"CL"の新しい(Gillespieの)版が今あるものであることを確実にしたいのなら、
付加的に`(require 'cl-19)'の呼び出しを追加する:

     (require 'cl)
     (require 'cl-19)

古い`cl.el'パッケージを使用中なら、2番目の呼び出しは("`cl-19.el' not
found"となって)失敗する。

"CL"をロードするように準備することはいつでも安全である、たとえばあなた
の`.emacs'ファイルに。しかしそうしているとしても、コードに`(require
'cl)'を可搬性のために入れるのはよい考えである。



File: cl-j, Node: 構成, Next: インストール, Prev: 使用法, Up: 概観

構成
====

Common Lispパッケージは4つのファイルで構成されている:

`cl.el'
     これは"主要な"ファイルであり、基本的関数とパッケージについての情報
     を含む。このファイルは比較的コンパクト--約700行である。

`cl-extra.el'
     このファイルはより大きく、より複雑または通常ではない関数を含む。
     `cadr'関数のようなCommon Lispの基礎だけを使いたいパッケージがより
     高度な関数のロードのオーバーヘッドを払わなくてよいように切り離され
     ている。

`cl-seq.el'
     このファイルは、`delete-if'や`assoc*'のように列やリストに作用する
     高度な関数の多くを含む。

`cl-macs.el'
     このファイルは関数ではなくマクロに関するパッケージの機能を含む。マ
     クロは実行時ではなく呼び出される側がコンパイルされるときに展開する
     ので、マクロは一般的にバイトコンパイラ実行時(または`.emacs'ファイ
     ルのようにコンパイルされていないコード中で使われるとき)のみ必要で
     ある。このパッケージのマクロの多くは、コンパイルしない限りメモリを
     使わないように`cl-macs.el'に分離されている。

`cl.el'ファイルはその他の3つのファイルの関数とマクロに必要なすべての
`autoload'コマンドを含む。やらなければいけないことは、`(require 'cl)'と
書き、`cl.el'が必要なときにその他のファイルを引っ張れるようにすることだ
けである。

別のファイル`cl-compat.el'があり、それは新しいパッケージにはもうない古
い`cl.el'のいくつかのルーチンを定義している。これは`setelt'や
`zip-lists'のような内部ルーチン、`defkeyword' のような非難された機能、
そして古いスタイルの多値機能のエミュレーションを含む。*Note 古いCLとの
互換性::.



File: cl-j, Node: インストール, Next: 命名規約, Prev: 構成, Up: 概観

インストール
============

"CL"パッケージのインストールは単純である: 単に
バイトコンパイルされたファイル`cl.elc'、`cl-extra.elc'、
`cl-seq.elc'、`cl-macs.elc'、そして `cl-compat.elc'を
`load-path'上のディレクトリに置くだけである。

このパッケージをコンパイルするための特殊な必要条件はない: ファイルはコ
ンパイルされる前にロードされる必要はなく、ある特別の順序でコンパイルさ
れる必要もない。

あなたの主要な`lisp/'ディレクトリにそのファイルを置いて、そこにあるオリ
ジナルの`cl.el'を置き換えてもよいし、古い`cl.el'が実質的に隠されるよう
に、`load-path'の`lisp/'の前に来るディレクトリにファイルを置いてもよい。

また`cl.texinfo'ファイルをフォーマットして、生じたInfoファイルを
`info/'ディレクトリか別の適切な場所に置いてもよい。

その代わりに専用のディレクトリにこのパッケージの構成要素をすべて置いて、
そのディレクトリを`load-path'と(Emacs 19以降のみ)
`Info-directory-list'に加えてもよい。古い"CL"パッケージとその文書が隠さ
れるように、そのディレクトリをリストの先頭に加えること。



File: cl-j, Node: 命名規約, Prev: インストール, Up: 概観

命名規約
========

注釈がある場合を除いて、このパッケージが定義するすべての関数はCommon
Lispの相対物と同じ名前と呼び出し規約を持つ。

下記は、通常はEmacsとの衝突を避けるためCommon Lispから名前を変えた関数
の完全なリストである。それぞれ、Emacs名を得るためにCommon Lisp名に
`*'を付加している。

     defun*        defsubst*     defmacro*     function*
     member*       assoc*        rassoc*       get*
     remove*       delete*       mapcar*       sort*
     floor*        ceiling*      truncate*     round*
     mod*          rem*          random*       last*

パッケージの内部関数と変数名は接頭辞`cl-'がついている。Common Lispから
とられていない、接頭辞`cl-'が*ついていない*関数の完全なリストは以下の通
り:

     member        delete        remove        remq
     rassoc        floatp-safe   lexical-let   lexical-let*
     callf         callf2        letf          letf*
     defsubst*     defalias      add-hook      eval-when-compile

(これらの多くはEmacs 18ユーザへ提供されるEmacs 19機能か、`remq'のように
類似の機能との対称の理由で導入されるものである)

下記の単純関数とマクロは`cl.el'に定義されている; これらは
`cl-extra'のような他の構成要素のロードを引き起こさない。

     eql           floatp-safe   abs           endp
     evenp         oddp          plusp         minusp
     butlast       nbutlast                    caar .. cddddr
     list*         ldiff         rest          first .. tenth
     member [1]    copy-list     subst         mapcar* [2]
     adjoin [3]    acons         pairlis       when
     unless        pop [4]       push [4]      pushnew [3,4]
     incf [4]      decf [4]      proclaim      declaim
     add-hook

[1] これはEmacs 19互換関数であり、`member*'ではない。

[2] 1個の列引数か2個のリスト引数のみ。

[3] `:test'が`eq'、`equal'、または指定されていない場合で、`:key'が使わ
れていない場合のみ。

[4] PLACEが単に変数名である場合のみ。




File: cl-j, Node: プログラム構造, Next: 述語, Prev: 概観, Up: Top

プログラム構造
**************

この節は、プログラム全体に関係する"CL"パッケージの機能を記述する:関数の
高度な引数リスト、そして`eval-when'構文要素。

* Menu:

* 引数リスト::
* 評価の時間::
* 関数別名::




File: cl-j, Node: 引数リスト, Next: 評価の時間, Prev: プログラム構造, Up: プログラム構造

引数リスト
==========

Emacs Lispの関数の引数リストの表記法はCommon Lisp表記法のサブセットであ
る。よく知られた`&optional'と`&rest'マーカと同様に、Common Lispは付加引
数に既定値を指定でき、追加のマーカ`&key'と`&aux'を提供する。

引数の構文解析はEmacsに組み込まれているため、このパッケージがCommon
Lispの引数リストをシームレスに実装する方法はない。その代わりに、このパッ
ケージはCommon Lisp引数リストが必要なら使わなければならないいくつかの
Lispフォームの代替を定義する。

 -- Special form: defun* NAME ARGLIST BODY...
     このフォームは、ARGLISTが完全なCommon Lisp引数リストであることを
     許されていることを除いて正規の`defun'フォームと同一である。また、
     関数本体はNAMEと呼ばれる暗黙のブロックに囲まれている;
     *Note ブロックと脱出::

 -- Special form: defsubst* NAME ARGLIST BODY...
     これは定義される関数が自動的に`inline'とグローバルに宣言されること
     を除いて、ちょうど`defun*'と似ている、すなわちそれへの呼び出しはバ
     イトコンパイラでインラインコードへ展開されるかもしれない。これは
     Emacs 19の`defsubst'フォームと似ている; `defsubst*'はすべての
     Emacsの版で動作し、幾分効率的なインライン展開を生成する別の方法(コ
     ンパイラマクロ)を使う。特に、`defsubst*'は可能ならばいつでもコンパ
     イル時にキーワード引数、既定値、その他を処理できるように準備する。

 -- Special form: defmacro* NAME ARGLIST BODY...
     これは、ARGLISTが完全な Common Lisp引数リストであることを
     許されていることを除いて正規の`defmacro'フォームと同一である。
     `&environment'キーワードはSteeleに記述されているように
     サポートされている。`&whole'キーワードは分配リスト内のみで
     サポートされている(下記参照); トップレベルの`&whole'は現在の
     Emacs Lispインタプリタでは実装できない。マクロエクスパンダ本体は
     NAMEと呼ばれる暗黙のブロックに囲まれている。

 -- Special form: function* SYMBOL-OR-LAMBDA
     これは、引数が`lambda'フォームならそのフォームは完全なCommon Lisp
     引数リストを使ってよいことを除いて正規の`function'フォームと同一で
     ある。

また、ARGLISTをその文法に含むこのパッケージで定義された(`defsetf'や
`flet'のような)すべてのフォームは完全なCommon Lisp引数リストを許す。

あなたの関数から多くの"CL"機能にアクセスするために`defun*'を使う必要は
*ない*ことに注意せよ。これらの機能は常に存在する; `defun*'と`defun'の相
違は単により柔軟な引数リストとその暗黙のブロックである。

Common Lisp引数リストの完全なフォームは

     (VAR...
      &optional (VAR INITFORM SVAR)...
      &rest VAR
      &key ((KEYWORD VAR) INITFORM SVAR)...
      &aux (VAR INITFORM)...)

5つの引数リスト節はそれぞれ付加的である。SVAR、INITFORM、
そしてKEYWORD部分は付加的である; 省略するなら、
`(VAR)'は単に`VAR'と書いてもよい。

第1節は0個かそれ以上の"必須"引数から成る。これらの引数は関数呼び出し時
には常に指定しなければならない; 必須引数に関する限り、Emacs Lispと
Common Lispに相違はない。

第2節は"付加"引数から成る。これらの引数は関数呼び出し時に指定してもよい;
指定されない場合、INITFORMは引数として使われる既定値を指定する。
(INITFORMがない場合は既定値として`nil'を使うことを意味する) INITFORMは
先立つ引数がすでに確立した束縛とともに評価される; `(a &optional (b (1+
a)))'は1個または2個の引数とマッチし、2番目の引数は1番目の引数に1を加え
た値を既定値とする。SVARが指定されると、付加引数が指定された場合は`t'に、
引数が省略された場合は`nil'に束縛される補助変数になる。SVARを使わない場
合、引数なしで呼び出されたのか、引数として既定値を明示的に渡されたのか
を知る方法はない。

第3節は1個の"rest"引数から成る。必須引数と付加引数が占めるより多くの引
数が関数へ渡された場合、それらの余分な引数は1個のリストに集積され
rest"引数変数に束縛される。Common Lispの`&rest'はEmacs Lispのそれと同等
である。Common Lispはマクロコンテキストで`&rest'の同義語として`&body'を
受け入れる;このパッケージはいつでもそれを受け入れる。

第4節は"キーワード"引数から成る。これらは引数リスト中の位置ではなく名前
で指定される付加引数である。たとえば、

     (defun* foo (a &optional b &key c d (e 17)))

は1個、2個、またはそれ以上の引数で呼び出してもよい関数を定義する。
最初の2個の引数は通常の方法で`a'と`b'に束縛される。残りの
引数は`:c'、`:d'、または`:e'に続いてその対応する
引数変数に束縛される値であるようなフォームの対でなければならない。
(その名前がコロンで始まるシンボルは"キーワード"と呼ばれ、
`nil'や`t'同様に自己引用的である)

たとえば、呼び出し`(foo 1 2 :d 3 :c 4)'は5個の引数をそれぞれ1、
2、4、3、そして17にセットする。同じキーワードが1度以上関数呼び出しに
現れる場合、第1の出現が後の出現より優先する。付加引数`b'を
指定することなくキーワード引数を指定することはできないことに注意せよ、
なぜなら`(foo 1 :c 2)'は`b'をキーワード`:c'に束縛し、
`2'は有効なキーワードではないためエラーを通知するからである。

KEYWORDシンボルが上のように引数リストに明示的に指定される場合、そのキー
ワードは1個のコロンを接頭辞とする単なる変数名の代わりに使われる。まった
くコロンで始まらないKEYWORDシンボルを指定できるが、そのようなシンボルは
自己引用的ではない; 関数呼び出し中で明示的にアポストロフィで引用しなけ
ればいけない。

通常、たとえば`(foo 1 2 :c 3 :goober 4)'のように、認められていないキー
ワードを関数に渡すことはエラーである。引数リストのキーワード節の後にマー
カ`&allow-other-keys'を加えるか、呼び出し時に`nil'ではない値の
`:allow-other-keys'引数を指定することで、認められていないキーワードを無
視するようLispに求めることができる。関数が`&rest'と`&key'を同時に両方使
うと、"rest"引数は呼び出し時に現れるキーワードリストに束縛される。たと
えば:

     (defun* find-thing (thing &rest rest &key need &allow-other-keys)
       (or (apply 'member* thing thing-list :allow-other-keys t rest)
           (if need (error "Thing not found"))))

この関数はキーワード引数`:need'をとるが、関数`member*'へ渡される他のキー
ワード引数も受け入れる。`allow-other-keys'は`find-thing'と`member*'が互
いのキーワード引数に不平を言わないようにするのに使われる。

(かなりの)性能最適化のために、このパッケージは"rest"引数中のキーワード
検索に`memq'を呼び出すことでキーワード引数の走査を実装する。技術的には、
`memq'は奇数個の値を偶数個のキーワードと同様に見るのでこれは正しくない。
キーワードシンボルが同じ関数の有効なキーワード引数の名前と偶然同じ場合、
キーワードシンボルを別のキーワード引数の*値*として偶然渡すと、キーワー
ド構文解析部は混乱することになる。このあまり重要でないバグは、プログラ
ム中でキーワードシンボルを一般用途のデータとして使うときにのみ影響があ
る場合がある; この習慣はEmacs Lispでは強く反対される。

引数リストの第5節は"補助変数"から成る。これらは実際にはまったく引数では
なく、関数実行時`nil'または指定されたINITFORMSに束縛される単なる変数で
ある。スタイル上の好みの問題を除いて、下記の2個の関数間に相違はない:

     (defun* foo (a b &aux (c (+ a b)) d)
       BODY)

     (defun* foo (a b)
       (let ((c (+ a b)) d)
         BODY))

引数リストは"分配"をサポートする。Common Lispでは、分配は`defmacro'での
み許される;このパッケージは`defun*'や他の引数リストでも同様に許す。分配
では、全引数変数(上のVAR)は変数のリストか、より一般的には再帰引数リスト
で置き換えることができる。対応する引数値は、その要素が再帰引数リストに
マッチするリストでなければならない。たとえば:

     (defmacro* dolist ((var listform &optional resultform)
                        &rest body)
       ...)

これは、`dolist'の第1引数は2個または3個の項目のリストでなければならない
ことを示す。このリスト同様に他の引数があれば、`body' に格納される。正規
の引数リストで許されるすべての機能はこれらの再帰引数リストで許される。
さらに、`&whole VAR'節は再帰引数リストの先頭で許される。それはVARをマッ
チしたリスト全体に束縛する; したがって、`(&whole all a b)'は2つのものの
リストにマッチし、`a'は1番目のものに束縛され、`b'は2番目のものに束縛さ
れ、`all'はそのリスト自身に束縛される。(Common Lispはトップレベルの
`defmacro'引数リストでも同様に`&whole'を許すが、Emacs Lispはこの使用法
をサポートしない)

分配の最後の機能は、引数リストはドットでもよいということである、だから
引数リスト`(a b . c)'は機能的には`(a b &rest c)'と同等である。

最適化品質`safety'に0が設定されると(*Note 宣言::)、不正な引数の数や無効
なキーワード引数のエラーチェックは無効である。既定では、引数リストは厳
しくチェックされる。



File: cl-j, Node: 評価の時間, Next: 関数別名, Prev: 引数リスト, Up: プログラム構造

評価の時間
==========

通常、バイトコンパイラはコンパイルするファイルのフォームを実際には
実行しない。たとえば、ファイルが`(setq foo t)'を含む場合、
コンパイルすることは実際には`t'を`foo'に設定しない。
`setq'がトップレベルフォーム(すなわち`defun'または他の
フォームに囲まれていない)だったとしてもそれは真である。しかし、ある
トップレベルフォームをコンパイル時に評価させたい場合がある。たとえば、
ファイルの残りの部分が定義されたマクロを参照できるように、コンパイラは
`defmacro'フォームをコンパイル時に実際に評価する。

 -- Special form: eval-when (SITUATIONS...) FORMS...
     このフォームは本体FORMSがいつ評価されるかを制御する。SITUATIONSリ
     ストはシンボル`compile'、`load'、そして`eval'(または長いANSIの同等
     物、`:compile-toplevel'、`:load-toplevel'、そして`:execute')のいず
     れの集合を含んでもよい。

     `eval-when'フォームは、トップレベルフォームとしてコンパイルされて
     いるかどうかによって異なって扱われる。つまり、`byte-compile-file'
     のようにファイルやコードのバッファをコンパイルするコマンドによって
     コンパイルされているときに特別に扱われ、文字通りファイルのトップレ
     ベルか`progn'の内部のトップレベルに現れる。

     コンパイルされたトップレベルの`eval-when'には、`compile'が
     SITUATIONSリストにある場合には、FORMS本体はコンパイル時に
     実行され、`load'がSITUATIONSリストにある場合には、
     FORMSは(ロード時に実行されるように)ファイルに書かれる。

     コンパイルされていないトップレベルフォームには、状況`eval'のみが関
     係する。(これはインタプリタが実行するフォーム、
     `byte-compile-file'ではなく`byte-compile'でコンパイルされたフォー
     ム、トップレベルではないフォームを含む。 ) `eval'が指定された場合、
     `eval-when'は`progn'のように振る舞い、そうでない場合は`nil'(FORMS
     本体を無視する)のように振る舞う。

     `eval-when'が入れ子の場合、規則はさらに微妙になる;ぞっとするような
     詳細(そしてぞっとするような例)はSteele(第2版)を調べること。

     単純な例:

          ;; top-level forms in foo.el:
          (eval-when (compile)           (setq foo1 'bar))
          (eval-when (load)              (setq foo2 'bar))
          (eval-when (compile load)      (setq foo3 'bar))
          (eval-when (eval)              (setq foo4 'bar))
          (eval-when (eval compile)      (setq foo5 'bar))
          (eval-when (eval load)         (setq foo6 'bar))
          (eval-when (eval compile load) (setq foo7 'bar))

     `foo.el'がコンパイルされると、これらの変数がコンパイル自身の間に設定される:

          foo1  foo3  foo5  foo7      ; `compile'

     `foo.elc'がロードされると、これらの変数が設定される:

          foo2  foo3  foo6  foo7      ; `load'

     ロードされた`foo.el'がコンパイルされていないと、これらの変数が設定
     される:

          foo4  foo5  foo6  foo7      ; `eval'

     仮にこれら7個の`eval-when'が`defun'内部にあれば、最初の3個は
     `nil'と同等であり、最後の4個は対応する`setq'と同等である。

     `(eval-when (load eval) ...)'はあらゆるコンテキストで
     `(progn ...)'と同等であることに注意せよ。コンパイラは`defmacro'(多
     少)や`require'のようないくつかのトップレベルフォームを`(eval-when
     (compile load eval) ...)'で包まれているかのように扱う。

Emacs 19は`eval-when'と関係がある2個の特殊形式を含む。そのうちの1個であ
る`eval-when-compile'は、どの`eval-when'構文要素と完全に同等ではなく以
下に記述される。このパッケージはEmacs 18ユーザのために
`eval-when-compile'の1個の版を定義する。

他方のフォーム`(eval-and-compile ...)'は`(eval-when (compile load
eval) ...)'と正確に同等なので、それ自身はこのパッケージで定義されていな
い。

 -- Special form: eval-when-compile FORMS...
     FORMSはコンパイル時に評価される;実行時、このフォームは結果として生
     じる値の引用された定数のように振る舞う。トップレベルで使われると、
     `eval-when-compile'はちょうど`eval-when (compile eval)'のようであ
     る。他のコンテキストでは、`eval-when-compile'は効率その他の理由で
     コードがコンパイル時に1度だけ評価されることを許す。

     このフォームは真のCommon Lispの`#.'文法に類似している。

 -- Special form: load-time-value FORM
     FORMはロード時に評価される; 実行時、このフォームは結果として生じる
     値の引用された定数のように振る舞う。

     初期のCommon Lispはこれに類似した`#,'文法を持っていたが、ANSI
     Common Lispは`load-time-value'で置き換えてよりよく定義された意味論
     を与えた。

     コンパイルされたファイルでは、`load-time-value'はFORMが`.elc'ファ
     イルがロードされたときに評価され引用された定数だったかのように使わ
     れるように準備する。`byte-compile-file'ではなく`byte-compile'でコ
     ンパイルされたコードでは、効果は`eval-when-compile'と同一である。
     コンパイルされていないコードでは、`eval-when-compile'と
     `load-time-value'は正確に`progn'のように振る舞う。

          (defun report ()
            (insert "This function was executed on: "
                    (current-time-string)
                    ", compiled on: "
                    (eval-when-compile (current-time-string))
                    ;; or '#.(current-time-string) in real Common Lisp
                    ", and loaded on: "
                    (load-time-value (current-time-string))))

     バイトコンパイルされると、上のdefunの例は下記のコード(またはもちろ
     んそのコンパイルされた同等のもの)を`.elc'ファイルに生じる:

          (setq --temp-- (current-time-string))
          (defun report ()
            (insert "This function was executed on: "
                    (current-time-string)
                    ", compiled on: "
                    '"Wed Jun 23 18:33:43 1993"
                    ", and loaded on: "
                    --temp--))



File: cl-j, Node: 関数別名, Prev: 評価の時間, Up: プログラム構造

関数別名
========

この節は、このパッケージがEmacsのGNU Emacs 19以外の版で利用できるように
するGNU Emacs 19からの機能を記述する。

 -- Function: defalias SYMBOL FUNCTION
     この関数はFUNCTIONをSYMBOLの関数セルに設定する。それは、
     GNU Emacs 19では後に`unload-feature'で元に戻せるように
     `load-history'に設定を記録することを除いて`fset'と同等である。

     Emacsの他の版では、`defalias'は`fset'の同義語である。



File: cl-j, Node: 述語, Next: 制御構造, Prev: プログラム構造, Up: Top

述語
****

この節はさまざまな事実が真か偽かをテストするための関数を記述する。

* Menu:

* データ型の述語::
* 等値の述語::



File: cl-j, Node: データ型の述語, Next: 等値の述語, Prev: 述語, Up: 述語

データ型の述語
==============

"CL"パッケージはCommon Lispの`typep'述語のある版を定義する。

 -- Function: typep OBJECT TYPE
     OBJECTが型TYPEかチェックする。TYPEはCommon Lisp
     によって使われる(引用された)型名である。たとえば、
     `(typep foo 'integer)'は`(integerp foo)'と同等である。

上の関数への引数TYPEはシンボルまたはシンボルで始まるリストである。

   * 型名がシンボルの場合、Emacsはその型をテストするための述語関数の名前を
     形成するために`-p'をシンボル名に付加する。(適切な場合はその名前が
     `-p'でなく`p'で終わる組み込み述語が使われる)

   * 型シンボル`t'はすべての型の和を表わす。`(typep OBJECT t)'は常に真
     である。同様に、型シンボル`nil'はまったくの空を表わし、 `(typep
     OBJECT nil)'は常に偽である。

   * 型シンボル`null'はシンボル`nil'を表わす。したがって、`(typep
     OBJECT 'null)'は`(null OBJECT)'と同等である。

   * 型シンボル`real'は`number'の同義語であり、`fixnum'は
     `integer'の同義語である。

   * 型シンボル`character'と`string-char'は0から255までの範囲の整数とマッ
     チする。

   * 型シンボル`float'は`floatp'ではなくこのパッケージで定義された述語
     `floatp-safe'を使うので、浮動小数点サポートがない版のEmacsでも正し
     く動作する。

   * 型リスト`(integer LOW HIGH)'はLOW以上HIGH以下の全整数を表現する。
     どちらの範囲も、その値を含まない境界を指定する単精度整数のリストか、
     無境界を指定する`*'でもよい。型`(integer * *)'はしたがって
     `integer'と同等である。

   * 同様に、`float'、`real'、または`number'で始まるリストは特別の範囲
     に入る型の数を表現する。

   * `and'、`or'、そして`not'で始まるリストは型の結合を形成する。たとえ
     ば、`(or integer (float 0 *))'は整数または非負浮動小数点数であるす
     べてのオブジェクトを表現する。

   * `member'または`member*'で始まるリストは続く値のいずれかに
     `eql'であるオブジェクトを表現する。たとえば、
     `(member 1 2 3 4)'は`(integer 1 4)'と同等であり、
     `(member nil)'は`null'と同等である。

   * フォーム`(satisfies PREDICATE)'のリストは引数としてそのオブジェク
     トとともに呼び出されたときPREDICATEが真を返すすべてのオブジェクト
     を表現する。

下記の関数とマクロ(技術的には述語ではない)は`typep'と関係がある。

 -- Function: coerce OBJECT TYPE
     この関数はOBJECTを指定されたTYPEへ変換を試みる。OBJECTがすでに
     `typep'で決定されるその型の場合、それは単純に戻る。そうでなければ、
     ある変換型が作られる: TYPEがいずれかの列型(`string'、`list'、その
     他)の場合、OBJECTは可能ならその型に変換される。TYPEが`character'の
     場合、長さ1の文字列や1文字の名前のシンボルは強制型変換できる。
     TYPEが`float'の場合、浮動小数点をサポートする版のEmacsでは整数は強
     制型変換できる。その他すべての環境では、`coerce'はエラーを通知する。

 -- Special form: deftype NAME ARGLIST FORMS...
     このマクロはNAMEと呼ばれる新しい型を定義する。それは多くの点で
     `defmacro'と類似している; NAMEに型名として出会うと、本体FORMSは評
     価され、その型と同等の型指定子を戻す。ARGLISTは`defmacro*'によって
     受け入れられる種類のCommon Lisp引数リストである。型指定子`(NAME
     ARGS...)'はこれらの引数とともにエクスパンダを呼び出すことで展開さ
     れる; 型シンボル`NAME'は無引数でエクスパンダを呼び出すことで展開さ
     れる。明示的既定値のない付加引数は"default"既定値として`nil'の代わ
     りに`*'を使うことを除いて、ARGLISTは`defmacro*'と同様に処理される。
     いくつかの例:

          (deftype null () '(satisfies null))    ; predefined
          (deftype list () '(or null cons))      ; predefined
          (deftype unsigned-byte (&optional bits)
            (list 'integer 0 (if (eq bits '*) bits (1- (lsh 1 bits)))))
          (unsigned-byte 8)  ==  (integer 0 255)
          (unsigned-byte)  ==  (integer 0 *)
          unsigned-byte  ==  (integer 0 *)

     最後の例は望むならどのようにCommon Lisp `unsigned-byte'型指定子を
     実装できるかを示す; このパッケージは既定では`unsigned-byte'を実装
     しない。

`typecase'や`check-type'マクロも型名を使う。*Note 条件付き実行::.*Note
アサーション::.`map'、`concatenate'、そして`merge'関数は戻す列型を指定
するために型名引数をとる。*Note 列::.



File: cl-j, Node: 等値の述語, Prev: データ型の述語, Up: 述語

等値の述語
==========

このパッケージは2個のCommon Lisp述語、`eql'と`equalp'を定義する。

 -- Function: eql A B
     この関数はほとんど`eq'と同じだが、AとBが同じ型の数なら数の等値性を
     比較する(`eq'ではなく`equal'のように)点が異なる。これはEmacs 19の
     ような浮動小数点数サポートとともにコンパイルされた版のEmacsでのみ
     相違が生じる。Emacsの浮動小数点数は単なるコンスセルのように割り当
     てられたオブジェクトであり、それは`(eq 3.0 3.0)'は真である必要がな
     いことを意味する--2個の`3.0'が別々に割り当てられたら、数は同じだが
     ポインタは異なる。しかし`(eql 3.0 3.0)'は常に真である。

     引数の型はマッチしなければならないので、`(eql 3 3.0)'はなお偽であ
     る。

     Emacs整数は割り当てられているのではなく"ダイレクト"であり、それは
     基本的に`(eq 3 3)'は常に真になることを意味することに注意せよ。した
     がって`eq'と`eql'は浮動小数点に関係のある場合のみ異なって振る舞い、
     浮動小数点数をサポートしない版のEmacsでは区別がつかない。

     正と負の0の扱いにCommon Lispとわずかな不一致がある。いくつかのマシ
     ンは、特にIEEE標準算術のものは、`+0'と`-0'を別の値として表現する。
     標準は`(= 0.0 -0.0)'は常に真だと指定しており、これはまったくEmacs
     LispとCommon Lispが行なうことなので、通常これは問題にならない。し
     かしCommon Lisp標準は`(eql 0.0 -0.0)'や`(equal 0.0 -0.0)'はIEEE的
     マシンでは偽になるべきだと述べている; Emacs Lispはこれを行なわず、
     事実Emacs Lispで2種類の0を区別する既知の方法は`format'して負号を
     チェックすることだけである。

 -- Function: equalp A B
     この関数は`equal'のより柔軟な版である。特に、それは文字列を大文字
     小文字を区別せずに比較し、数を型を考慮せずに比較する(そのため
     `(equalp 3 3.0)'は真である)。ベクタとコンスは再帰的に比較される。
     他の全オブジェクトは`equal'と同様に比較される。

     この関数はいくつかの点でCommon Lispの`equalp'と異なる。第1に、
     Common Lispの`equalp'は*文字*も大文字小文字を区別せずに比較するが、
     Emacsは整数と文字を区別しないのでこのパッケージには非実用的である。
     Emacs Lispでは文字列はあまりベクタ的ではないという考え方を保ち、こ
     のパッケージの`equalp'は文字列と整数のベクタも比較しない。最後に、
     Common Lispの`equalp'はハッシュ表を順序を考慮せずに比較するが、こ
     のパッケージはハッシュ表を単純にその下にある構造に関して(このこと
     はLucid Emacs 19のハッシュ表はベクタであり、他のハッシュ表はリスト
     であることを意味する)比較する。

Common Lispの関数`member'と`assoc'は要素の比較に`eql'を使っているが、
Emacs LispはMacLispの伝統に従いこれらの2個の関数に`equal'を使っているこ
とにも注意せよ。Emacsでは比較に`eql'を使う関数を得るには`member*'や
`assoc*'を使うこと。



File: cl-j, Node: 制御構造, Next: マクロ, Prev: 述語, Up: Top

制御構造
********

下節に記述された機能は、強力な`setf'機能やかなりの数のループと条件付き
実行構文要素を含むさまざまな高度な制御構造を実装する。

* Menu:

* 代入::
* 汎変数::
* 変数束縛::
* 条件付き実行::
* ブロックと脱出::
* 繰り返し::
* ループ機能::                  Common Lisp `loop'マクロ
* 多値::



File: cl-j, Node: 代入, Next: 汎変数, Prev: 制御構造, Up: 制御構造

代入
====

`psetq'フォームは`setq'に似ているが、多重代入が順次ではなく並列になされ
る点が異なる。

 -- Special form: psetq [SYMBOL FORM]...
     この特殊形式(実際はマクロ)は同時にいくつかの変数に代入するために使
     われる。1個だけのSYMBOLとFORMを与えられると、`setq'と同じ効果を持
     つ。いくつかのSYMBOLとFORMの対を与えられると、すべてのFORMをあらか
     じめ評価し、その後対応する変数へ格納する。

          (setq x 2 y 3)
          (setq x (+ x y)  y (* x y))
          x
               => 5
          y                     ; `y'は`x'が設定された後に計算された。
               => 15
          (setq x 2 y 3)
          (psetq x (+ x y)  y (* x y))
          x
               => 5
          y                     ; `y'は`x'が設定される前に計算された。
               => 6

     最も単純な`psetq'の使用法は`(psetq x y y x)'であり、2個の変数の値
     を交換する。(`rotatef'フォームは2個の変数の交換により便利な方法を
     提供する; *Note 修正マクロ::)

     `psetq'は常に`nil'を返す。



File: cl-j, Node: 汎変数, Next: 変数束縛, Prev: 代入, Up: 制御構造

汎変数
======

"汎変数"または"placeフォーム"は値を格納できるLispメモリ中の多くの場所の
一つである。最も単純なplaceフォームは通常のLisp変数である。しかしリスト
のcarやcdr、配列の要素、シンボルの属性、そして多くの他の場所もLispの値
が格納される場所である。

`setf'フォームは`setq'に似ているが、単なるシンボルではなく左辺に任意の
placeフォームを受け入れる点が異なる。たとえば、`(setf (car a) b)'は`a'
のcarを`b'に設定する。これは`(setcar a b)'と同じ作用だが、すべての場所
型の設定とアクセスのために2個の別の関数を憶える必要がない。

汎変数はC言語の"左辺値"と類似しており、同じ表記法を使って`x = a[i]'は配
列から要素を取得し`a[i] = x'は要素を格納する。Cでは`a[i]'のようなある種
のフォームだけが左辺値になり得るが、Lispには汎変数になり得るフォームの
集合がある。

* Menu:

* 基本的setf::
* 修正マクロ::
* setf独自化::



File: cl-j, Node: 基本的setf, Next: 修正マクロ, Prev: 汎変数, Up: 汎変数

基本的setf
----------

`setf'マクロは汎変数に作用する最も基本的な方法である。

 -- Special form: setf [PLACE FORM]...
     このマクロはFORMを評価し、それをPLACEに格納する。PLACEは有効な汎変
     数フォームでなければならない。いくつかのPLACEとFORMの対がある場合、
     代入はちょうど`setq'のように順に行なわれる。`setf'は最後のFORMの値
     を戻す。

     下記のLispフォームは汎変数として働くので、`setf'のPLACE引数に正し
     く現れてもよい:

        * 変数を命名するシンボル。言い換えれば、`(setf x y)'は`(setq x
          y)'と正確に同等であり、`setq'自身は`setf'が存在する現在では厳
          密には冗長である。しかし、多くのプログラマは純粋にスタイルま
          たは歴史的な理由で、単純変数の設定のためには`setq'を好み続け
          ている。マクロ`(setf x y)'は実際には`(setq x y)'へ展開するの
          で、コンパイルされたコードで使う場合に性能上の不利益はない。

        * 下記のLisp関数のいずれかの呼び出し:

               car                 cdr                 caar .. cddddr
               nth                 rest                first .. tenth
               aref                elt                 nthcdr
               symbol-function     symbol-value        symbol-plist
               get                 get*                getf
               gethash             subseq

          `nthcdr'と`getf'のためには、関数のリスト引数はそれ自身有効な
          PLACEフォームでなければならないことに注意せよ。たとえば、
          `(setf (nthcdr 0 foo) 7)'は`foo'自身に7を設定する。`nthcdr'を
          場所とする`push'や`pop'はリストのどの位置にも挿入や削除するた
          めに使うことができることに注意せよ。PLACEフォームとして
          `nthcdr'を使うことは標準Common Lispへの拡張である。

        * 下記のEmacs特有関数も`setf'可能である(これらのいくつかは
          Emacs 19またはLucid Emacsだけで定義されている)。

               buffer-file-name                  marker-position
               buffer-modified-p                 match-data
               buffer-name                       mouse-position
               buffer-string                     overlay-end
               buffer-substring                  overlay-get
               current-buffer                    overlay-start
               current-case-table                point
               current-column                    point-marker
               current-global-map                point-max
               current-input-mode                point-min
               current-local-map                 process-buffer
               current-window-configuration      process-filter
               default-file-modes                process-sentinel
               default-value                     read-mouse-position
               documentation-property            screen-height
               extent-data                       screen-menubar
               extent-end-position               screen-width
               extent-start-position             selected-window
               face-background                   selected-screen
               face-background-pixmap            selected-frame
               face-font                         standard-case-table
               face-foreground                   syntax-table
               face-underline-p                  window-buffer
               file-modes                        window-dedicated-p
               frame-height                      window-display-table
               frame-parameters                  window-height
               frame-visible-p                   window-hscroll
               frame-width                       window-point
               get-register                      window-start
               getenv                            window-width
               global-key-binding                x-get-cut-buffer
               keymap-parent                     x-get-cutbuffer
               local-key-binding                 x-get-secondary-selection
               mark                              x-get-selection
               mark-marker

          これらの多くは、`current-local-map'用の`use-local-map'や
          `point'用の`goto-char'のように、ダイレクトに対応する"設定"
          関数を持つ。`point-min'のようないくつかは、`setf'
          されるとより長いコード列(この場合は
          `(narrow-to-region x (point-max))')に展開する。

        * フォーム`(substring SUBPLACE N [M])'の呼び出しは、SUBPLACE自
          身が現在の値が文字列である正しい汎変数であり、格納される値も
          文字列である。新たな文字列は宛先文字列の指定された部分につな
          がれる。たとえば:

               (setq a (list "hello" "world"))
                    => ("hello" "world")
               (cadr a)
                    => "world"
               (substring (cadr a) 2 4)
                    => "rl"
               (setf (substring (cadr a) 2 4) "o")
                    => "o"
               (cadr a)
                    => "wood"
               a
                    => ("hello" "wood")

          上のリストの汎変数`buffer-substring'も、現バッファの一部を置
          き換えることでこのように動作する。

        * FUNCがその格納関数がSteeleの本に記述された意味で"適切な"場合、
          フォーム`(apply 'FUNC ...)'または`(apply (function
          FUNC) ...)'の呼び出し; 標準Emacsのplace 関数はどれもこの意味
          で適切ではないので、この機能は`define-setf-method'か
          `defsetf'の長いフォームで自身が定義するplaceで使われる場合の
          み興味あるものである。

        * マクロ呼び出しであり、そのマクロが展開されて`setf'が結果とし
          て生じるフォームに適用される場合。

        * `defsetf'または`define-setf-method'がそのために作られたすべて
          のフォーム。

     `setf'へのPLACE引数にこれら以外のあらゆるフォームを使うとエラーを
     通知する。

     `setf'マクロは適正な左から右への順序ですべての部分フォームを評価す
     るように注意する; たとえば、

          (setf (aref vec (incf i)) i)

     は`(incf i)'を正確に一度、続く`i'へのアクセスの前に評価するように
     見える; `setf'エクスパンダは`aref'のためにどんなsetfメソッドが定義
     されても実際にこのように動作することを確実にするために、必要な一時
     的変数を挿入する(この場合`aset'が使われるだろうが、`aset'は便利な
     順序でその引数をとるのでそのような手段は必要ないだろう)。

     しかし、PLACEフォームが通常ではない順序でその引数を明示的に評価す
     るマクロの場合、この通常ではない順序は保存される。Steeleからの例を
     改作して、以下があるとすれば

          (defmacro wrong-order (x y) (list 'aref y x))

     フォーム`(setf (wrong-order A B) 17)'は、ちょうど`wrong-order'への
     実際の呼び出しのように、Bを最初に評価しそれからAを評価する。



File: cl-j, Node: 修正マクロ, Next: setf独自化, Prev: 基本的setf, Up: 汎変数

修正マクロ
----------

このパッケージは`setf'の他にも、汎変数に作用する多くのマクロを定義する。
PLACEが単に変数名である場合でも、多くは興味深く有用である。

 -- Special form: psetf [PLACE FORM]...
     `psetq'が`setq'に対応するように、このマクロは`setf'に対応する: い
     くつかのPLACEとFORMを含むとき、代入は順次にではなく並列に起こる。
     つまり、すべての部分フォームは左から右へ評価され、それからすべての
     代入が(未定義の順序で)行なわれる。

 -- Special form: incf PLACE &optional X
     このマクロはPLACEに格納されている数を1だけ、または指定されている
     場合はXだけ増やす。増やされた値が戻される。たとえば、
     `(incf i)'は`(setq i (1+ i))'と同等であり、
     `(incf (car x) 2)'は`(setcar x (+ (car x) 2))'と同等である。

     もう一度、評価の"明白な"順序を保存するために注意が払われる。たとえ
     ば、

          (incf (aref vec (incf i)))

     は`i'を一度増やし、それから`i'でアドレスされる`vec'の要素を増やす
     ように現れる; これは実に正確にそれが行なうことであり、上のフォーム
     は"明らかな"展開と同等では*ない*ことを意味し、

          (setf (aref vec (incf i)) (1+ (aref vec (incf i))))   ; 間違い!

     ではなく、むしろ何かより以下に似ているようなものである。

          (let ((temp (incf i)))
            (setf (aref vec temp) (1+ (aref vec temp))))

     もう一度、これらすべては`incf'や他の汎変数マクロによって自動的に注
     意が払われる。

     `incf'のよりEmacs特有の例として、式`(incf (point) N)'は
     `(forward-char N)'と本質的に同等である。

 -- Special form: decf PLACE &optional X
     このマクロはPLACEに格納されている数を1だけ、または指定されている場
     合はXだけ減らす。

 -- Special form: pop PLACE
     このマクロはPLACEに格納されているリストの最初の要素を取り除いて戻
     す。それは`(prog1 (car PLACE) (setf PLACE (cdr PLACE)))'に類似して
     いるが、すべての部分フォームを一度だけ評価するように注意する点が異
     なる。

 -- Special form: push X PLACE
     このマクロはPLACEに格納されるリストの先頭にXを挿入する。それは
     `(setf PLACE (cons(コンス) X PLACE))'に類似しているが、部分フォー
     ムの評価が異なる。

 -- Special form: pushnew X PLACE &key :TEST :TEST-NOT :KEY
     このマクロはPLACEに格納されているリストの先頭にXを挿入するが、Xが
     リストの存在するどの要素にも`eql'でない場合に限られる。

     付加キーワード引数は`adjoin'と同様に解釈される。
     *Note 集合としてのリスト::.

 -- Special form: shiftf PLACE... NEWVALUE

     このマクロは左へ1つPLACEをシフトし、NEWVALUEの値(それは
     単なる汎変数ではなく、どんなLisp式でもよい)をシフトして入れ、最初の
     PLACEからシフトして出された値を戻す。したがって、
     `(shiftf A B C D)'は以下と同等だが

          (prog1
              A
            (psetf A B
                   B C
                   C D))

     A、B、そしてCの部分フォームは明白な順序でそれぞれ一度だけ実際には
     評価される点が異なる。

 -- Special form: rotatef PLACE...
     このマクロは循環的にPLACEを左へ一つ回転する。したがって、
     `(rotatef A B C D)'は以下と同等だが

          (psetf A B
                 B C
                 C D
                 D A)

     部分フォームの評価が異なる。`rotatef'は常に`nil'を戻す。`(rotatef
     A B)'はAとBを便利に交換することに注意せよ。

下記のマクロはこのパッケージのために発明された; これらはCommon Lispに類
似するものはない。

 -- Special form: letf (BINDINGS...) FORMS...
     このマクロは`let'に類似しているが、単なるシンボルではなく
     汎変数用である。それぞれのBINDINGはフォーム
     `(PLACE VALUE)'であるべきである; PLACEの
     オリジナルの内容はセーブされ、VALUEがそれらに格納され、それから
     本体FORMが実行される。その後、PLACESはオリジナルの
     セーブされた内容へ設定し戻される。この大掃除は、FORMが
     `throw'またはエラーのために正規でない脱出をした場合ですら起こる。

     たとえば、

          (letf (((point) (point-min))
                 (a 17))
            ...)

     はバッファの先頭へ現バッファの"ポイント"を動かし、17へ`a'を束縛す
     る(通常の`let'と同様だが、`a'が単なる通常の変数だからである)。本体
     が脱出した後、`a'はそのオリジナルの値に設定し戻され、ポイントはそ
     のオリジナルの位置へ戻る。

     `(point)'の`letf'は`save-excursion'とはあまり似ていないことに注意
     せよ。なぜなら後者はバッファ内の挿入と削除を追跡するマーカを効果的
     にセーブするからである。実際は、`(point-marker)'の`letf'はこの振る
     舞いにずっと近い(`point'と`point-marker'は`setf'場所としては同等で
     ある; どちらも格納値として整数かマーカを受け入れる)。

     汎変数はリストのように見えるため、BINDINGとして`(foo nil)'のために
     `foo'を使用する`let'の簡略表記法は`letf'ではあいまいになるので許さ
     れていない。

     しかし、BINDING指定子は1要素のリスト`(PLACE)'でもよく、それは
     `(PLACE PLACE)'に類似している。言い換えれば、PLACEは本体へ入ること
     で乱されず、`letf'の効果はその後PLACEのオリジナルの値を戻すことだ
     けである(`(PLACE PLACE)'の例により示唆された冗長なアクセスと格納は
     実際には起こらない)。

     多くの場合、PLACEは`letf'フォームに入るときによく定義された値を持
     たなければならない。例外は単純変数と`symbol-value'や
     `symbol-function'への呼び出しだけである。入るときにシンボルが束縛
     されていない場合、脱出時に`makunbound'または`fmakunbound'で単に未
     束縛にされる。

 -- Special form: letf* (BINDINGS...) FORMS...
     `let*'が`let'に対応するように、このマクロは`letf'に対応する: それ
     は並列の順序ではなく順次に束縛を行なう。

 -- Special form: callf FUNCTION PLACE ARGS...
     これは"汎用"修正マクロである。FUNCTIONを呼び出す。FUNCTIONは引用符
     のない関数名、マクロ名、またはラムダでなければならない。引数として
     PLACEとARGSを渡し、PLACEへ結果を代入し戻す。たとえば、`(incf
     PLACE N)'は`(callf + PLACE N)'と同じである。さらにいくつかの例:

          (callf abs my-number)
          (callf concat (buffer-name) "<" (int-to-string n) ">")
          (callf union happy-people (list joe bob) :test 'same-person)

     *Note setf独自化::, `define-modify-macro'、修正マクロのための幾分
     簡潔な表記法を作るための方法。`callf'は標準Common Lispへの拡張であ
     ることに再度注意せよ。

 -- Special form: callf2 FUNCTION ARG1 PLACE ARGS...
     このマクロは`callf'に似ているが、PLACEが関数の第1ではなく
     *第2*引数である点が異なる。たとえば、
     `(push X PLACE)'は
     `(callf2 cons X PLACE)'と同等である。

`callf'や`callf2'マクロは、`incf'、`pushnew'、そして
`define-modify-macro'のような他のマクロのためのビルディングブロックとし
て役に立つ。`letf'や`letf*'マクロはシンボルマクロの処理に使われる;
*Note マクロ束縛::.



File: cl-j, Node: setf独自化, Prev: 修正マクロ, Up: 汎変数

setf独自化
----------

Common Lispは、さまざまな方法で汎変数を拡張することをユーザに許す3個の
マクロ、`define-modify-macro'、`defsetf'、そして
`define-setf-method'を定義する。

 -- Special form: define-modify-macro NAME ARGLIST FUNCTION [DOC-STRING]
     このマクロは`incf'や`decf'に類似する"read-modify-write"マクロを定
     義する。マクロNAMEはARGLISTによって記述される追加の引数が続く
     PLACE引数をとるために定義される。呼び出し

          (NAME PLACE ARGS...)

     は下記に展開されるが

          (callf FUNC PLACE ARGS...)

     これは順に大まかに以下と同等である。

          (setf PLACE (FUNC PLACE ARGS...))

     たとえば:

          (define-modify-macro incf (&optional (n 1)) +)
          (define-modify-macro concatf (&rest args) concat)

     `&key'はARGLISTの中には許されないが、`&rest'は関数へキーワードを渡
     すためには十分なことに注意せよ。

     Common Lispで定義される修正マクロのほとんどは
     `define-modify-macro'のパターンに正確には従っていない。たとえば、
     `push'はよくない順序で引数をとり、`pop'は完全に変則である。
     `get-setf-method'を使って"手で"これらのマクロを定義できるし、内部
     の`setf'ビルディングブロックをどのように使うかを見るためにソースファ
     イル`cl-macs.el'を調べることもできる。

 -- Special form: defsetf ACCESS-FN UPDATE-FN

     これは2個の`defsetf'フォームのより単純な方である。ACCESS-FN
     が場所をアクセスする関数の名前である場合、これは対応する格納関数として
     UPDATE-FNを宣言する。その後、

          (setf (ACCESS-FN ARG1 ARG2 ARG3) VALUE)

     は以下に展開される。

          (UPDATE-FN ARG1 ARG2 ARG3 VALUE)

     UPDATE-FNは真の関数か、関数のような方法でその引数を評価するマクロ
     であることが必須である。また、UPDATE-FNはその結果としてVALUEを戻す
     ことを期待される。さもなければ、上の展開は`setf'が振る舞うことになっ
     ていることのための規則に従わないだろう。

     特殊な(非Common Lisp)拡張として、`defsetf'への`t'の第3引数は
     `update-fn'の戻り値は適切でないと言っているので、上の`setf'はより
     以下に似たようなものへ展開されるべきである。

          (let ((temp VALUE))
            (UPDATE-FN ARG1 ARG2 ARG3 temp)
            temp)

     setfメソッドの標準一式から引かれた、`defsetf'の使用のいくつかの例
     は:

          (defsetf car setcar)
          (defsetf symbol-value set)
          (defsetf buffer-name rename-buffer t)

 -- Special form: defsetf ACCESS-FN ARGLIST (STORE-VAR) FORMS...
     これは2番目の、より複雑な`defsetf'のフォームである。それは追加の
     STORE-VAR引数を除いてむしろ`defmacro'と似ている。FORMSは、ARGLIST
     によって記述された引数をともにするACCESS-FNへの呼び出しによって形
     成された汎変数にSTORE-VARの値を格納するLispフォームを戻すべきであ
     る。FORMSは`setf'メソッドを文書化する文字列で始まってもよい(関数の
     先頭に現れる文書文字列と類似している)。

     たとえば、`defsetf'の単純なフォームは以下の簡略表記法である。

          (defsetf ACCESS-FN (&rest args) (store)
            (append '(UPDATE-FN) args (list store)))

     戻されるLispフォームは制限されていない仕方でARGLISTやSTORE-VARから
     の引数へアクセスできる; このsetf-methodを起動する`setf'や`incf'の
     ようなマクロは、評価の明白な順序が保存されることを確実にするために
     必要な一時的変数を挿入する。

     標準パッケージから引かれた別の例:

          (defsetf nth (n x) (store)
            (list 'setcar (list 'nthcdr n x) store))

 -- Special form: define-setf-method ACCESS-FN ARGLIST FORMS...
     これは新しいplaceフォームを作るための最も一般的な方法である。
     ARGLISTに記述された引数と一緒にACCESS-FNへの`setf'が展開されると、
     FORMSは評価されて5項目のリストを戻さなければならない:

       1. "一時変数"のリスト。

       2. 上の一時変数に対応する"値フォーム"のリスト。一時変数は汎変数
          上のどんな作用の第1ステップとしてもこれらの値フォームへ束縛さ
          れる。

       3. 正確に1個の"格納変数"のリスト(一般的に`gensym'への呼び出しか
          ら得られる)。

       4. 格納変数の内容を汎変数に格納するLispフォーム。一時変数は上述
          したように束縛されていると仮定する。

       5. 汎変数の内容にアクセスするLispフォーム。一時変数は束縛されて
     いると仮定する。これは同じ名前のCommon Lispマクロとほとんど同じだ
     が、メソッドは5個の値自身ではなく5個の値のリストを戻す点は異なる。
     それはEmacs Lispは多重戻り値のCommon Lispの記法をサポートしていな
     いからである。

     もう一度、FORMSは文書文字列で始まってもよい。

     setfメソッドは一時変数に関して最大限に保守的であるべきである。
     `defsetf'によって生成されるsetfメソッドの中で、第2戻り値は単に
     placeフォーム中の引数リストであり、第1戻り値は`gensym'によって生成
     される対応する一時変数の数のリストである。`setf'や`incf'のようにこ
     のsetfメソッドを使うマクロは不要とわかった多くの一時変数を最適化す
     るので、setfメソッド自身を最適化する理由はほとんどない。

 -- Function: get-setf-method PLACE(場所) &optional ENV
     この関数は、`defsetf'や`define-setf-method'によって以前に記録され
     た定義を呼び出すことで、PLACEのためのsetfメソッドを戻す。結果は上
     述した5個の値のリストである。あなた自身の`incf'に似た修正マクロを
     作るためにこの関数を使える(実際は内部関数`cl-setf-do-modify'や
     `cl-setf-do-store'を使う方がよい。少しだけ使いやすく、かなりの最適
     化も行なう; 単純な例として`incf'関数のソースコードを調べよ)。

     引数ENVは、`get-setf-method'がPLACEのマクロを展開する必要がある場
     合に`macroexpand'へ渡される"環境"を指定する。それはマクロへの
     `&environment'か、`get-setf-method'を呼んだsetfメソッドから来るべ
     きである。

     `apply'や`substring'のためのsetfメソッドのソースコードも参照のこと。
     それぞれはより単純な場合に`get-setf-method'を呼び出すことによって
     動作し、それからさまざまな方法で結果をマッサージする。

現代のCommon Lispは関数の`setf'の振る舞いを指定するための第2の、独立し
た方法を定義する。すなわち、その名前がシンボルではなくリスト`(setf
NAME)'である"`setf'関数"である。たとえば、`(defun (setf foo) ...)'は、
`setf'が`foo'に適用する際に使われる関数を定義する。このパッケージは、現
在は`setf'関数をサポートしない。まだ`defsetf'されていないか宣言されてい
ないフォームで`setf'を使うことはコンパイル時エラーである; より新しい
Common Lispでは、関数`(setf FUNC)'は後で定義されるかもしれないのでこれ
はエラーではないだろう。




File: cl-j, Node: 変数束縛, Next: 条件付き実行, Prev: 汎変数, Up: 制御構造

変数束縛
========

これらのLispフォームは変数や関数の名前との束縛を作る。Lispの組み込み
`let'フォームと類似している。

同じく変数束縛に関係する`letf'や`letf*'フォームは
*Note 修正マクロ::.

* Menu:

* 動的束縛::
* レキシカルな束縛::
* 関数束縛::
* マクロ束縛::



File: cl-j, Node: 動的束縛, Next: レキシカルな束縛, Prev: 変数束縛, Up: 変数束縛

動的束縛
--------

標準`let'フォームは、コンパイル時にその名前が既知である変数を束縛する。
`progv'フォームはその名前が実行時に計算される変数を束縛する容易な方法を
提供する。

 -- Special form: progv SYMBOLS VALUES FORMS...
     このフォームは実行時に計算された変数の集合に、`let'スタイルの
     変数束縛を確立する。式のSYMBOLSとVALUESは評価され、
     それぞれシンボルと値のリストを戻さなければならない。シンボルは本体
     FORMが続く限り、対応する値に束縛される。VALUESが
     SYMBOLSより短い場合、終わりのいくつかのシンボルは本体内では
     未束縛にされる(`makunbound'によってのように)。SYMBOLSが
     VALUESより短い場合、余分の値は無視される。



File: cl-j, Node: レキシカルな束縛, Next: 関数束縛, Prev: 動的束縛, Up: 変数束縛

レキシカルな束縛
----------------

"CL"パッケージは、Common Lispの`let'フォームにより厳密に従う下記のマク
ロを定義する:

 -- Special form: lexical-let (BINDINGS...) FORMS...
     このフォームは、確立する束縛が純粋にレキシカルである点以外は`let'
     とほぼ似ている。レキシカルな束縛はCのような言語の局所変数と類似し
     ている: 物理的に`lexical-let'(マクロ展開後)の本体内のコードだけが
     束縛変数を参照してよい。

          (setq a 5)
          (defun foo (b) (+ a b))
          (let ((a 2)) (foo a))
               => 4
          (lexical-let ((a 2)) (foo a))
               => 7

     この例では、`a'の正規の`let'束縛は実際グローバル変数`a'を一時的に
     変更するので、`foo'は2への`a'の束縛を見ることができる。しかし
     `lexical-let'は実際本体内で使うために別の局所変数`a'を作り、同名の
     グローバル変数にどんな影響もない。

     レキシカルな束縛の最も重要な使用法は"クロージャ"を作ることである。
     クロージャは外のレキシカル変数を参照する関数オブジェクトである。た
     とえば:

          (defun make-adder (n)
            (lexical-let ((n n))
              (function (lambda (m) (+ n m)))))
          (setq add17 (make-adder 17))
          (funcall add17 4)
               => 21

     呼び出し`(make-adder 17)'は引数に17を加える関数オブジェクトを戻す。
     `let'が`lexical-let'の代わりに使われる場合、関数オブジェクトは
     `make-adder'自身の呼び出しの間だけ17へ束縛されているグローバルの
     `n'を参照するだろう。

          (defun make-counter ()
            (lexical-let ((n 0))
              (function* (lambda (&optional (m 1)) (incf n m)))))
          (setq count-1 (make-counter))
          (funcall count-1 3)
               => 3
          (funcall count-1 14)
               => 17
          (setq count-2 (make-counter))
          (funcall count-2 5)
               => 5
          (funcall count-1 2)
               => 19
          (funcall count-2)
               => 6

     ここで`make-counter'への各呼び出しは別の局所変数`n'を作る。それは
     戻される関数オブジェクト用の私的なカウンターとして働く。

     その上で閉じられたレキシカル変数は、ちょうど他のLispオブジェクトと
     同様にそれへの最後の参照がなくなるまで存続する。たとえば、
     `count-2'は変数`n'のインスタンスを参照する関数オブジェクトを参照す
     る; これはその変数への唯一の参照なので、`(setq count-2 nil)'の後に
     はガベジコレクタは`n'のこのインスタンスを削除できるだろう。もちろ
     ん、`lexical-let'が実際にはクロージャをまったく作らない場合、レキ
     シカル変数は`lexical-let'が戻るとすぐに自由である。

     多くのクロージャはそれらが参照する束縛のエクステントの間だけ使われる;
     これらはLisp語法では"downward funargs"として知られている。クロージャ
     がこのように使われる場合、正規のEmacs Lisp動的束縛で十分であり、
     `lexical-let'クロージャより効率的だろう。

          (defun add-to-list (x list)
            (mapcar (function (lambda (y) (+ x y))) list))
          (add-to-list 7 '(1 2 5))
               => (8 9 12)

     このラムダは`x'がまだ束縛されているときにのみ使われているので、そ
     のために真のクロージャを作ることは必要ではない。

     名前付きクロージャを作るために`lexical-let'の内部で`defun'や
     `flet'を使うことができる。いくつかのクロージャが1個の
     `lexical-let'の本体で作られる場合、それらはすべてレキシカル変数の
     同じインスタンスの上で閉じている。

     `lexical-let'フォームはCommon Lispへの拡張である。真のCommon Lisp
     では、すべての束縛はそうではないと宣言されない限りレキシカルである。

 -- Special form: lexical-let* (BINDINGS...) FORMS...
     このフォームはちょうど`lexical-let'と似ているが、束縛は
     `let*'の方法のように順次に作られる点が異なる。



File: cl-j, Node: 関数束縛, Next: マクロ束縛, Prev: レキシカルな束縛, Up: 変数束縛

関数束縛
--------

これらのフォームは変数の代わりに関数に`let'に似た束縛を作る。

 -- Special form: flet (BINDINGS...) FORMS...
     このフォームは値セルではなくシンボルの関数セルに`let'スタイルの束
     縛を確立する。それぞれのBINDINGはフォーム`(NAME ARGLIST
     FORMS...)'のリストでなければならない。それは正確に`defun*'フォーム
     であるかのように関数を定義する。関数NAMEは`flet'の本体の間だけそれ
     に応じて定義される; それから古い関数定義や関数定義がないことが戻さ
     れる。

     Common Lispの`flet'はNAMEのレキシカルな束縛を確立するが、Emacs
     Lispの`flet'は動的束縛を作る。その結果、`flet'は`flet'フォーム自身
     の内部での直接的な呼び出しと同様に間接的な関数への呼び出しに影響す
     る。

     一時的な仕方で関数の振る舞いを無効にしたり修正したりするために
     `flet'を使うことができる。これはEmacsプリミティブ上でも動作するが、
     Emacs内部のプリミティブ関数へのいくつかの呼び出しはシンボルの関数
     セルを通さずに行なわれるので、`flet'によって影響されないことに注意
     せよ。たとえば、

          (flet ((message (&rest args) (push args saved-msgs)))
            (do-something))

     このコードはメッセージを表示するのではなく、単にリストにセーブする
     関数で組み込み関数`message'を置き換えようと試みる。`message'のオリ
     ジナルの定義は`do-something'の脱出の後に戻される。このコードは他の
     Lispコードによって生成されるメッセージにはうまく働くが、Emacs内部
     で直接生成されるメッセージはLispの`message'関数を通じてではなくメッ
     セージルーチンへの直接のC言語呼び出しを行なうので、それらは捉えら
     れない。

     `flet'で定義された関数は`defun*'によってサポートされている
     完全なCommon Lisp引数表記法を使ってもよい; また、関数本体は
     `defun*'のように暗黙のブロックに囲まれる。*Note プログラム構造::.

 -- Special form: labels (BINDINGS...) FORMS...
     `labels'フォームは`flet'と似ているが、動的束縛ではなく関数名のレキ
     シカルな束縛を作る点が異なる。(真のCommon Lispでは、`flet'と
     `labels'のどちらもわずかに異なる種類のレキシカルな束縛を作る;
     Emacs Lispは既定では動的束縛なので、`flet'のためにも動的束縛を使う
     ことはより適切に見える。`labels'フォームはレキシカルな束縛を持って
     おり、Common Lispと完全に互換である。)

     レキシカルスコープは、名付けられた関数へのすべての参照は物理的に
     `labels'フォームの本体内に現れなくてはならないことを意味する。参照
     は`labels'自身の本体FORMSの中にも関数自身の本体の中にも現れてよい。
     したがって、`labels'は局所再帰関数や相互再帰関数の集合を定義できる。

     関数名への"参照"はその関数への呼び出しか、たとえば`mapcar'へ渡され
     るために`quote'や`function'に引用されたその名前の使用である。



File: cl-j, Node: マクロ束縛, Prev: 関数束縛, Up: 変数束縛

マクロ束縛
----------

これらのフォームは局所マクロや"シンボルマクロ"を作る。

 -- Special form: macrolet (BINDINGS...) FORMS...
     このフォームは`flet'と類似しているが、関数の代わりにマクロ用である。
     各BINDINGは`defmacro*'への引数と同じフォームのリストである(すなわ
     ち、マクロ名、引数リスト、そしてマクロエクスパンダフォーム)。マク
     ロは`macrolet'の本体内の使用に応じて定義される。

     マクロの性質のために、`macrolet'はEmacs Lisp内でさえもレキシカルス
     コープである: `macrolet'束縛は、おそらく本体の他のマクロの展開後、
     物理的に本体FORMS内に現れる呼び出しにのみ影響する。

 -- Special form: symbol-macrolet (BINDINGS...) FORMS...
     このフォームは"シンボルマクロ"を作る。それは関数呼び出しよりも
     変数参照のように見えるマクロである。各BINDINGはリスト
     `(VAR EXPANSION)'である; 本体FORMS内の
     VARへのすべての参照はEXPANSIONによって置き換えられる。

          (setq bar '(5 . 9))
          (symbol-macrolet ((foo (car bar)))
            (incf foo))
          bar
               => (6 . 9)

     シンボルマクロの`setq'は`setf'と同様に扱われる。すなわち、
     上の`(setq foo 4)'は`(setf foo 4)'と同等であり、今度は
     `(setf (car bar) 4)'へ展開する。

     同様に、シンボルマクロを束縛する`let'や`let*'は`letf'や`letf*'のよ
     うに扱われる。これは、レキシカルスコープのルールは`let'の束縛が
     `symbol-macrolet'の束縛をシャドウすることを引き起こすような真の
     Common Lispとは異なる。このパッケージでは、`lexical-let'や
     `lexical-let*'だけがシンボルマクロをシャドウする。

     シンボルマクロには`defmacro'に似たものはない; すべてのシンボルマク
     ロは局所的である。`symbol-macrolet'の典型的な使用は他のマクロの展
     開内である:

          (defmacro* my-dolist ((x list) &rest body)
            (let ((var (gensym)))
              (list 'loop 'for var 'on list 'do
                    (list* 'symbol-macrolet (list (list x (list 'car var)))
                           body))))

          (setq mylist '(1 2 3 4))
          (my-dolist (x mylist) (incf x))
          mylist
               => (2 3 4 5)

     この例では、`my-dolist'マクロは変数`x'はリストの要素上の真の参照に
     なる点を除いて`dolist'(*Note 繰り返し::)に類似している。ここで示さ
     れた`my-dolist'呼び出しは下記に展開する。

          (loop for G1234 on mylist do
                (symbol-macrolet ((x (car G1234)))
                  (incf x)))

     これは今度は下記に展開する。

          (loop for G1234 on mylist do (incf (car G1234)))

     `loop'マクロの記述は*Note ループ機能::. このパッケージは
     `my-dolist'とたいへん似た働きをする非標準`in-ref'ループ節を定義す
     る。



File: cl-j, Node: 条件付き実行, Next: ブロックと脱出, Prev: 変数束縛, Up: 制御構造

条件付き実行
============

これらの条件付実行フォームはEmacs Lispの単純な`if'、`and'、
`or'、そして`cond'フォームを増加させる。

 -- Special form: when TEST FORMS...
     これは"else"フォームがなく、ことによるといくつかの"then"フォームが
     ある`if'の別の形である。特に、

          (when TEST A B C)

     は完全に下記と同等である。

          (if TEST (progn A B C) nil)

 -- Special form: unless TEST FORMS...
     これは"then"フォームがなく、ことによるといくつかの"else"フォームが
     ある`if'の別の形である:

          (unless TEST A B C)

     は完全に下記と同等である。

          (when (not TEST) A B C)

 -- Special form: case KEYFORM CLAUSE...
     このマクロはKEYFORMを評価し、それからさまざまなCLAUSEの中にリスト
     されたのキーの値と比較する。キーにマッチする節はどれでも実行される;
     比較は`eql'によってなされる。どの節もマッチしない場合、`case'フォー
     ムは`nil'を戻す。節は下記のフォームである。

          (KEYLIST BODY-FORMS...)

     ここでKEYLISTはキーの値のリストである。正確に1個の値がある場合、か
     つコンスセルやシンボル`nil'または`t'ではない場合、リスト内に囲まず
     にそれ自身をKEYLISTとして使うことができる。`case'フォーム内のすべ
     てのキーの値は別でなくてはならない。最後の節は他の節がマッチしない
     場合にとられる既定節を示すためにKEYLISTの場所に`t'を使ってもよい。
     (シンボル`otherwise'も`t'の場所に認められる。実際のシンボル`t'、
     `nil'、または`otherwise'とマッチする節を作るためには、リストの中に
     シンボルを囲むこと。)

     たとえば、この式はキーストロークを読み、それが`a'、`b'、RETまたは
     `C-j'、またはそれ以外のどれであるかによって4個の事の内の1個を行な
     う。

          (case (read-char)
            (?a (do-a-thing))
            (?b (do-b-thing))
            ((?\r ?\n) (do-ret-thing))
            (t (do-other-thing)))

 -- Special form: ecase KEYFORM CLAUSE...
     このマクロはちょうど`case'に似ているが、キーが節のどれにもマッチし
     ない場合は単に`nil'を戻すのではなくエラーを通知する点が異なる。

 -- Special form: typecase KEYFORM CLAUSE...
     このマクロは値ではなく型をチェックする`case'の版である。各CLAUSEは
     フォーム`(TYPE BODY...)'である。型指定子の記述は*Note データ型の述
     語::. たとえば、

          (typecase x
            (integer (munch-integer x))
            (float (munch-float x))
            (string (munch-integer (string-to-int x)))
            (t (munch-anything x)))

     型指定子`t'はオブジェクトのすべての型にマッチする; 語`otherwise'も
     許される。いくつかの型のどれかにマッチする1個の節を作るには、
     `(or ...)'型指定子を使うこと。

 -- Special form: etypecase KEYFORM CLAUSE...
     このマクロはちょうど`typecase'に似ているが、キーが節のどれにもマッ
     チしない場合は単に`nil'を戻すのではなくエラーを通知する点が異なる。



File: cl-j, Node: ブロックと脱出, Next: 繰り返し, Prev: 条件付き実行, Up: 制御構造

ブロックと脱出
==============

Common Lisp"ブロック"は`catch'と`throw'にとても類似している非局所脱出メ
カニズムを適用するが、それは動的スコープではなくレキシカルスコープであ
る。このパッケージは実際には`catch'で`block'を実装する; しかし、ブロッ
ク本体が実際にはブロックから`return-from'しない場合、レキシカルスコープ
は最適化バイトコンパイラが高価な`catch'を省略することを許す。

 -- Special form: block NAME FORMS...
     FORMSは`progn'によるかのように評価される。しかし、FORMSのいずれか
     が`(return-from NAME)'を実行する場合、それらは飛び出して
     `block'フォームからダイレクトに戻る。`block'は、`return-from'が起
     こらないと最後のFORMの結果を戻す。

     `block'/`return-from'メカニズムは`catch'/`throw'メカニズムと非常に
     類似している。主要な相違は、ブロックNAMEは評価されないシンボルであ
     り、実行時にタグへと評価するフォーム(引用符のついたシンボルのよう
     に)ではない点である; そしてまた、ブロックは`catch'/`throw'では動的
     スコープであるのにレキシカルスコープである。これは、`catch'の本体
     から呼び出された関数も`catch'へ`throw'できるが、ブロック名を参照す
     る`return-from'は物理的にブロックの本体を作るFORMSの中に現れなけれ
     ばならないことを意味する。それらは他の呼び出された関数中に現れては
     ならないが、マクロ展開の中や本体の`lambda'に現れてもよい。ブロック
     名や`catch'名は独立した名前空間を形成する。

     真のCommon Lispでは、`defun'や`defmacro'は関数やマクロと同じ
     名前を持つ暗黙のブロックで関数やエクスパンダ本体を囲む。これはEmacs
     Lispでは起こらないが、このパッケージは暗黙のブロックを作る
     `defun*'や`defmacro*'フォームを提供する。

     このパッケージによって定義される、`loop'や`dolist'のようなCommon
     Lispループ構文要素も、Common Lispとちょうど同様の暗黙のブロックを
     作る。

     それらはEmacs Lispの`catch'や`throw'で実装されているので、ブロック
     は実際の`catch'構文要素と同じオーバーヘッド(大まかに2度の関数呼び
     出し)を持つ。しかし、ZawinskiとFurusethの最適化バイトコンパイラ
     (Emacs 19の標準)は、ブロックが事実まったくそれへ飛び出す`return'や
     `return-from'呼び出しを含まない場合、`catch'を最適化し去る。これは、
     `return'を使わない`do'ループや`defun*'関数はそれをサポートするため
     にオーバーヘッドを払わないことを意味する。

 -- Special form: return-from NAME [RESULT]
     このマクロはNAMEという名前のブロックから戻る。NAMEは(評価されない)シ
     ンボルでなければならない。RESULTフォームが指定される場合、`block'
     から戻される結果を作るために評価される。そうでなければ、`nil'が戻
     される。

 -- Special form: return [RESULT]
     このマクロは`(return-from nil RESULT)'と正確に同等である。`do'や
     `dolist'のようなCommon Lispループは暗黙に`nil'ブロックに自身を囲む。



File: cl-j, Node: 繰り返し, Next: ループ機能, Prev: ブロックと脱出, Up: 制御構造

繰り返し
========

ここで記述されるマクロは、Emacs Lispの基本的な`while'ループを補うために、
より洗練された高水準のループ構文要素を提供する。

 -- Special form: loop FORMS...

     "CL"パッケージは、`loop'の単純で古いスタイルの意味と、
     "ループマクロ"の"ループ機能"として知られるきわめて強力で柔軟な
     機能をどちらもサポートする。このより高度な機能は下記の節で論じられる;
     *Note ループ機能::. `loop'の単純なフォームはここで記述される。

     `loop'に0個またはそれ以上のLisp式が続く場合、`(loop EXPRS...)'は単
     純にその式を何度も何度も実行する無限ループを作る。ループは暗黙の
     `nil'ブロックに囲まれている。したがって、

          (loop (foo) (if (no-more) (return 72)) (bar))

     は正確に下記と同等である。

          (block nil (while t (foo) (if (no-more) (return 72)) (bar)))

     式のどれもが単なるシンボルの場合、loopはその代わりに後に記述される
     ループマクロ仕様と解釈される。(これは実際は制限ではない。上記の表
     記法での単なるシンボルは単純に変数の値にアクセスして捨て去るからで
     ある。)

 -- Special form: do (SPEC...) (END-TEST [RESULT...]) FORMS...
     このマクロは一般的な繰り返しループを作る。それぞれのSPECは下記の
     フォームである:

          (VAR [INIT [STEP]])

     ループは下記のように働く: 最初に、それぞれのVARは`let'フォームによ
     るかのように関連づけられたINITの値に束縛される。それから、ループの
     それぞれの繰り返しではEND-TESTが評価される;真の場合、ループは終了
     する。そうでなければ、本体FORMSが評価され、それぞれのVARは関連づけ
     られたSTEP式に(`psetq'フォームによるかのように)設定され、次の繰り
     返しが始まる。一度END-TESTが真になると、RESULTフォームは`do'により
     戻される結果を生成するために(VARはまだその値に束縛している状態で)
     評価される。

     `do'ループ全体は暗黙の`nil'ブロックに囲まれているので、どんなとき
     もループを中断して出るために`(return)'を使える。

     RESULTフォームがない場合、ループは`nil'を戻す。与えられた
     VARがSTEPフォームを持たない場合、INITの値に
     束縛されるが、その他の点では`do'ループの間(コードが明示的に
     修正しない限り)修正されない; この場合はループの周りに
     `(let ((VAR INIT)) ...)'を置くことの単なる
     簡略表記法である。INITも省略される場合その既定値は`nil'
     であり、この場合は再び`let'との類似にしたがって単なる
     `VAR'が`(VAR)'の場所に使うことができる。

     この例(Steeleから)は、リスト`foo'と`bar'からの連続する値の対に関数
     `f'を適用するループを説明する; それは呼び出し`(mapcar* 'f foo
     bar)'と同等である。ループは本体FORMSをまったく持たず、ループの残り
     の副作用としてすべての仕事をすることに注意せよ。

          (do ((x foo (cdr x))
               (y bar (cdr y))
               (z nil (cons (f (car x) (car y)) z)))
            ((or (null x) (null y))
             (nreverse z)))

 -- Special form: do* (SPEC...) (END-TEST [RESULT...]) FORMS...
     `let*'が`let'に対応するように、これは`do'に対応する。
     特に、初期値は`let'によってのようにではなく`let*'
     によってのように束縛され、stepは`psetq'によってのようにではなく
     `setq'によってのように代入される。

     上記のループを格別の方法は以下の通り:

          (do* ((xp foo (cdr xp))
                (yp bar (cdr yp))
                (x (car xp) (car xp))
                (y (car yp) (car yp))
                z)
            ((or (null xp) (null yp))
             (nreverse z))
            (push (f x y) z))

 -- Special form: dolist (VAR LIST [RESULT]) FORMS...
     これはリストの要素を横切って繰り返す、より特殊化されたループである。
     LISTはリストへ評価されなければならない; 本体FORMSはVARがそれぞれの
     リストの要素に順に束縛された状態で実行される。最後に、RESULTフォー
     ム(または`nil')がループから戻される結果を生じるために、VARが`nil'
     に束縛された状態で評価される。ループは暗黙の`nil'ブロックで囲まれ
     る。

 -- Special form: dotimes (VAR COUNT [RESULT]) FORMS...
     これは指定された回数繰り返す、より特殊化されたループである。本体は
     VARがゼロ(を含む)からCOUNT(を含まない)までの整数に順に束縛された状
     態で実行される。それから`result'フォームがループフォームの戻り値を
     得るために、VARが繰り返しの総回数に束縛された状態(すなわち、`(max
     0 COUNT)')で評価される。ループは暗黙の`nil'ブロックで囲まれる。

 -- Special form: do-symbols (VAR [OBARRAY [RESULT]]) FORMS...
     このループはすべてのinternされたシンボル上を繰り返す。OBARRAYが指
     定され`nil'でない場合、そのobarray中のすべてのシンボル上をループす
     る。それぞれのシンボルに対して、本体FORMSはVARがそのシンボルに束縛
     された状態で評価される。シンボルは不定の順序で訪問される。その後、
     RESULTフォームがあれば戻り値を得るために(VARが`nil'に束縛された状
     態で)評価される。ループは暗黙の`nil'ブロックで囲まれる。

 -- Special form: do-all-symbols (VAR [RESULT]) FORMS...
     これはOBARRAY引数が省略されている点を除いて`do-symbols'と同一であ
     る; 常に既定のobarrayの上で繰り返す。

ベクタやリスト上の繰り返し用のいくつかの他の関数は*Note 列上のマッピン
グ::.



File: cl-j, Node: ループ機能, Next: 多値, Prev: 繰り返し, Up: 制御構造

ループ機能
==========

Lispの伝統的なループ構文への共通の不平は、Common Lispの`dotimes'や
Emacs Lispの`while'のようにあまりに単純または制限されているか、Common
Lispの`do'ループのようにあまりに読みづらく不明瞭だということである。

これを治すために、Common Lispの最近の版は、使いやすいがとても強力で表現
力に富む文法を持つ"ループ機能"または"`loop'マクロ"と呼ばれる新しい構文
要素を加えた。

* Menu:

* ループの基本::
* ループの例::
* For節::
* 繰り返し節::
* 蓄積節::
* その他の節::



File: cl-j, Node: ループの基本, Next: ループの例, Prev: ループ機能, Up: ループ機能

ループの基本
------------

`loop'マクロは本質的に、Lisp内にループを記述するために特別に仕立てられ
たミニ言語を作る。この言語は正規のLispの標準からは少し奇妙に見えるが、
とても学びやすく、その目的によく適していることがわかる。

`loop'はマクロなので、ループ言語のすべての構文解析はバイトコンパイル時
に行なわれる; コンパイルされた`loop'は、手書きの同等の`while'ループとちょ
うど同じ効率である。

 -- Special form: loop CLAUSES...
     ループ構文要素はCLAUSEの連続から成り、それぞれは`for'や`do'のよう
     なシンボルによって導入される。節は単純に、最小の余分な括弧とともに
     `loop'の引数リストに一列に一緒に並べられる。さまざまな節の型は、一
     時変数の束縛のような初期化や、ループ内で行なわれる実行、ステップ実
     行、最後の大掃除を指定する。

     Common Lispはある一般的な節の順序をループ中に指定する:

          (loop NAME-CLAUSE
                VAR-CLAUSES...
                ACTION-CLAUSES...)

     NAME-CLAUSEは付加的にループを囲む暗黙のブロックに名前を与える。既
     定では、暗黙のブロックは`nil'と名付けられる。VAR-CLAUSESはループ中
     にどの変数が束縛されるかや、どのようにループの進行の間に修正された
     り繰り返されるかを指定する。ACTION-CLAUSESは、計算や集積、値の戻し
     など、ループの間になされることである。

     `loop'マクロのEmacs版は節の順序について制限はより弱いが、実行節の
     前に`with'や`for'、`repeat'のような変数束縛節を置く場合、
     物事はほぼ予想されるように振る舞う。Common Lispと同様に、
     `initially'と`finally'はどこにでも置ける。

     ループは一般に既定では`nil'を戻すが、`collect'のような
     蓄積節を使ったり、`always'のような終了テスト節を使ったり、暗黙の
     ブロックから飛び出すための明示的な`return'節を持ったりすることで
     値を戻すようにすることができる。(ループ本体は暗黙のブロックに
     囲まれているから、ループから脱出するために正規Lispの`return'や
     `return-from'を使うこともできる。)

下記の節は動作するループマクロのいくつかの例を与え、特別のループ節を
非常に詳細に記述する。追加の議論や`loop'マクロの例はSteeleの
"Common Lisp, the Language"第2版を調べること。



File: cl-j, Node: ループの例, Next: For節, Prev: ループの基本, Up: ループ機能

ループの例
----------

許されている節のすべての集合をリストする前に、単に`loop'言語の感じを掴
むためにいくつかのループの例を見てみよう。

     (loop for buf in (buffer-list)
           collect (buffer-file-name buf))

このループは、`buffer-list'によって戻されたリストを使いながら、
すべてのEmacsバッファ上を繰り返す。それぞれのバッファ`buf'に
対して、`buffer-file-name'を呼び出して結果をリストに集積する。
リストはその後`loop'構文要素から戻される。結果はEmacsの
メモリにあるすべてのバッファのファイル名のリストである。語`for'や
`in'、`collect'は`loop'言語の中で予約語である。

     (loop repeat 20 do (insert "Yowsa\n"))

このループは現バッファに句"Yowsa"を20回挿入する。

     (loop until (eobp) do (munch-line) (forward-line 1))

このループは、バッファの終わりまでのすべての行で`munch-line'を呼び出す。
ポイントがすでにバッファの終わりにある場合、ループはすぐに脱出する。

     (loop do (munch-line) until (eobp) do (forward-line 1))

このループは上述のものと類似しているが、`munch-line'は常に最低1度は呼び
出される。

     (loop for x from 1 to 100
           for y = (* x x)
           until (>= y 729)
           finally return (list x (= y 729)))

より複雑なこのループは、その2乗が729である数`x'を検索する。安全のために
100までの`x'値だけを調べる; 句`to 100'を省略することは、ループが上方へ
無制限に数えることを引き起こすだろう。2番目の`for'節はループの中で`x'の
2乗になるように`y'を定義する; `='記号の後の式はループを通して毎回再評価
される。`until'節はループの終了用の条件を与え、`finally'節はループが終
わったとき何をするかを言う。(この特別の例は、単に説明のために、可能なも
のよりも簡潔ではなく書かれた。)

このループは、それ自身でループを定義するのに十分な3個の節(2個は`for'で
1個は`until')を含んでいるが、それでも3重の入れ子のループの一種ではなく
1個のループをつくる。入れ子のループがほしい場合、明示的に`loop'構文要素
を入れ子にしなければならない。



File: cl-j, Node: For節, Next: 繰り返し節, Prev: ループの例, Up: ループ機能

For節
-----

ほとんどのループは1個かそれ以上の`for'節に支配される。`for'節は束縛され
る変数を記述すると当時に、これらの変数がループ中にどのようにステップさ
れるか、また通常はこれらの変数に基づいた終了条件を記述する。

語`as'は語`for'の同義語である。この語の後には変数名が続き、望む繰り返し
の種類を記述する`from'や`across'のような語が続く。Common Lispでは、句
`being the'がときどき繰り返しの型の前に来る; このパッケージでは`being'
と`the'はともに付加的である。語`each'は`the'の同義語であり、それに続く
語は単数でも複数でもよい: `for x being the elements of y'や`for x
being each element of y'のように。どちらのフォームを使うかは純粋にスタ
イルの問題である。

変数は`let'によるかにようにループの周りで束縛される:

     (setq i 'happy)
     (loop for i from 1 to 10 do (do-something-with i))
     i
          => happy

`for VAR from EXPR1 to EXPR2 by EXPR3'
     この`for'節の型は数え上げのループを作る。3個の副項のそれぞれは付加
     的だが、節が数え上げの節だとマークされるように少なくても1個の項が
     なければならない。

     3個の式はそれぞれ変数の開始値、終了値、ステップ値である。ループは、
     EXPR1からEXPR2(を含む)までを既定では上方に(EXPR3は正数でなければな
     らない)数える。`from'項を省略した場合、ループは0から数える; `to'項
     を省略した場合、ループは止まらずに永久に数える(もちろん、他のルー
     プ節によって止まらない限り); `by'項を省略した場合、ループは1のステッ
     プで数える。

     ループの方向を示すために、語`from'を`upfrom'または
     `downfrom'に置き換えることができる。同様に、`to'を
     `upto'または`downto'に置き換えることができる。たとえば、
     `for x from 5 downto 1'は`x'が順に5から1までの整数を
     持ちながら5回実行する。また、`to'を`below'または`above'
     に置き換えることもできる。これは制限を含むのではないことを除いて
     `upto'や`downto'にそれぞれ似ている:

          (loop for x to 10 collect x)
               => (0 1 2 3 4 5 6 7 8 9 10)
          (loop for x below 10 collect x)
               => (0 1 2 3 4 5 6 7 8 9)

     数え下げのループのためであっても、`by'は常に正数である。
     なんらかの種類の`from'値が数え下げのループのためには必須である;
     `for x downto 5'はそれ自身まったく正しいループ節ではない。

`for VAR in LIST by FUNCTION'
     この節は、順にLISTのすべての要素でVARを繰り返す。`by'項を指定した
     場合、FUNCTIONが`cdr'の代わりにリストを横切るために使われる; それ
     は1個の引数をとる関数でなければならない。たとえば:

          (loop for x in '(1 2 3 4 5 6) collect (* x x))
               => (1 4 9 16 25 36)
          (loop for x in '(1 2 3 4 5 6) by 'cddr collect (* x x))
               => (1 9 25)

`for VAR on LIST by FUNCTION'
     この節はLISTのすべてのコンスセルでVARを繰り返す。

          (loop for x on '(1 2 3 4) collect x)
               => ((1 2 3 4) (2 3 4) (3 4) (4))

     `by'がある場合、`on'式がリストでなければならないという理由はない。
     たとえば:

          (loop for x on first-animal by 'next-animal collect x)

     ここでは`(next-animal x)'は"動物"Xをとり、動物の列(と仮定されたも
     の)の中の次のものを戻すか、Xが列の最後の動物の場合は`nil'を戻す。

`for VAR in-ref LIST by FUNCTION'
     これは普通の`in'節と似ているが、VARは単に一時変数ではなく、リスト
     の要素上の`setf'可能な"参照"になる。たとえば:

          (loop for x in-ref my-list do (incf x))

     は正しく`my-list'のそれぞれの要素の値を1つ増やす。この節は標準
     Common Lispへの拡張である。

`for VAR across ARRAY'
     この節はARRAYのすべての要素でVARを繰り返す。ARRAYはベクタまたは文
     字列でなければならない。

          (loop for x across "aeiou"
                do (use-vowel (char-to-string x)))

`for VAR across-ref ARRAY'
     この節は、VARを要素上の`setf'可能な参照として配列上を繰り返す; 上
     記の`in-ref'を参照のこと。

`for VAR being the elements of SEQUENCE'
     この節はSEQUENCEの要素上で繰り返す。SEQUENCEはリストか
     ベクタ、文字列でなければならない。型は実行時に
     決定されなければならないので、これは`in'または`across'
     よりもいくぶん効率が悪い。節には、VAR2が要素の連続する
     インデックスに束縛されるようにするために、追加の項
     `using (index VAR2)'が続いてもよい。

     この節の型は`loop'マクロの古い版からとられており、最新のCommon
     Lispにはない。より古いマクロの`using (sequence ...)'項はサポートさ
     れていない。

`for VAR being the elements of-ref SEQUENCE'
     この節は、VARを要素上の`setf'可能な参照として列上を繰り返す;上記の
     `in-ref'を参照のこと。

`for VAR being the symbols [of OBARRAY]'
     この節は、すべてのinternされたシンボルまたはOBARRAY中のすべてのシ
     ンボル上を繰り返す。ループは、VARを順にそれぞれのシンボルに束縛し
     て実行される。シンボルは不定の順序で訪問される。

     一例として、

          (loop for sym being the symbols
                when (fboundp sym)
                when (string-match "^map" (symbol-name sym))
                collect sym)

     は、`map'で始まる名前を持つすべての関数のリストを戻す。

     Common Lispの語`external-symbols'や`present-symbols'も認められるが、
     Emacs Lispでは`symbols'と同等である。

     重要でない実装の制限のために、一つの`loop'の中にシンボル、
     ハッシュ表、キーマップ、オーバレイ、インターバル上で繰り返す、
     1つ以上の`for'節を持つと正しく動作しない。幸いにも、
     そうすることが有用なことはきわめてまれだろう。`for ... to'や
     `while'のような他の節とこれらの節の型の一つを混ぜることは正しい
     *ことである*。

`for VAR being the hash-keys of HASH-TABLE'
     この節はHASH-TABLEのエントリ上で繰り返す。それぞれのハッシュ表エン
     トリに対して、VARはそのエントリのキーに束縛される。`the
     hash-values'をその代わりに書いた場合、VARはエントリの値に束縛され
     る。VARやVAR2がハッシュ表エントリの2つのそれぞれの部分に束縛される
     ように、その節に追加の項`using (hash-values VAR2)'(`hash-values'は
     `the'に続く語の反対の語である)が続いてもよい。

`for VAR being the key-codes of KEYMAP'
     この節はKEYMAPのエントリ上で繰り返す。GNU Emacs 18と19では、キーマッ
     プは連想リストまたはベクタであり、キーコードは整数またはシンボルで
     ある。Lucid Emacs 19ではキーマップは特殊な新しいデータ型であり、キー
     コードはシンボルまたはシンボルのリストである。繰り返しは入れ子になっ
     たキーマップや受け継いだ親のキーマップには入らない。キーコードでは
     なくキーに束縛されたコマンドにアクセスするために`the
     key-bindings'を使うことができる。コードと束縛の両方にアクセスする
     ために`using'節を加えることができる。

`for VAR being the key-seqs of KEYMAP'
     この節はKEYMAPとその入れ子になったキーマップで定義されるすべての
     キー列上で繰り返す。VARはEmacs 18では文字列の値を、Emacs 19では
     ベクタの値をとる。文字列やベクタはそれぞれの繰り返しで
     再利用されるので、それらをいつまでも保ちたいならば
     コピーしなければならない。同様にコマンド束縛を得るために
     `using (key-bindings ...)'節を加えることができる。

`for VAR being the overlays [of BUFFER] ...'
     この節はEmacs 19の"オーバレイ"またはLucid Emacsのバッファの"エクス
     テント"上で繰り返す(節`extents'は`overlays'の同義語である)。Emacs
     18の元では、この節は1度も繰り返さない。`of'項が省略された場合、現
     バッファが使われる。この節は、付加的な`from POS'や`to POS'項も受け
     入れるが、指定したリージョンを重ねるオーバレイへの節に制限する。

`for VAR being the intervals [of BUFFER] ...'
     この節は不変のテキスト属性を持つバッファのすべてのインターバル上で
     繰り返す。変数VARは開始位置と終了位置のコンスに束縛され、そこでは
     ある開始位置は常に前の終了位置と等しい。この節は`of'や`from'、
     `to'、`property'項を許す。そこでは後の項は指定された属性のみに検索
     を制限する。`of'項はバッファか文字列を指定できる。この節はGNU
     Emacs 19のみで有用である; 他の版では、すべてのバッファや文字列は1
     つのインターバルから成る。

`for VAR being the frames'
     この節はすべてのフレーム上、すなわちEmacsファイル上で開いている
     Xウィンドウシステムのウィンドウで繰り返す。この節はEmacs 19の元でのみ
     動作する。節`screens'は`frames'の同義語である。フレームは、
     `selected-frame'から始まる`next-frame'の順序で訪問される。

`for VAR being the windows [of FRAME]'
     この節は現フレームか指定されたFRAMEの(Emacsの意味での)ウィンドウ上
     で繰り返す(Emacs 18では常に1つのフレームだけがあり、`of'項はそこで
     は許されない)。

`for VAR being the buffers'
     この節はEmacsのすべてのバッファ上で繰り返す。それは
     `for VAR in (buffer-list)'と同等である。

`for VAR = EXPR1 then EXPR2'
     この節は一般の繰り返しを行なう。ループを最初に通るとき、VARは
     EXPR1に束縛される。2回目やそれに続く繰り返しでは、それはEXPR2(VAR
     の古い値を参照してもよい)を評価した値に設定される。たとえば、これ
     らの2つのループは実際に同じである:

          (loop for x on my-list by 'cddr do ...)
          (loop for x = my-list then (cddr x) while x do ...)

     この`for'の型はどんな種類の終端条件も含まないことに注意せよ;上記の
     例は、いつループが終わるかを言うためにそれと`while'節を結合する。

     `then'項を省略した場合、EXPR1は初期設定とそれに続く設定の両方に使
     われる:

          (loop for x = (random) when (> x 0) return x)

     このループは、正数を得るまで`(random)'関数から乱数を取得し続けて、
     その後戻る。

1つの列にいくつかの`for'節を含む場合、それらは(`let*'や`setq'のように)
順次に扱われる。節を結合するために代わりに語`and'を使うことができ、その
場合は(`let'や`psetq'のように)並列に処理される。

     (loop for x below 5 for y = nil then x collect (list x y))
          => ((0 nil) (1 1) (2 2) (3 3) (4 4))
     (loop for x below 5 and y = nil then x collect (list x y))
          => ((0 nil) (1 0) (2 1) (3 2) (4 3))

第1のループでは、`y'は前の節で設定されたばかりの`x'の値に基づいて設定さ
れる; 第2のループでは、`x'と`y'は同時に設定されるので、`y'はループを通
して前回から残された`x'の値に基づいて設定される。

`loop'マクロの他の機能として"分配"があり、それは`defmacro'によって提供
される分配と概念として類似している。すべての`for'節のVAR部分は、単なる
変数の代わりに変数のリストとして与えることができる。ループ実行中に生成
される値はリストでなければならない; リスト中の値は対応する変数に格納さ
れる。

     (loop for (x y) in '((2 3) (4 5) (6 7)) collect (+ x y))
          => (5 9 13)

ループ分配では、変数よりも多くの値がある場合は残りの値は無視され、値よ
りも多くの変数がある場合は残りの変数は値`nil'を取得する。`nil'が変数名
として使われた場合、対応する値は無視される。分配は入れ子になってもよい
し、`(x . y)'のような変数のドットリストも許される。



File: cl-j, Node: 繰り返し節, Next: 蓄積節, Prev: For節, Up: ループ機能

繰り返し節
----------

`for'節は別にして、ループが作用する仕方を制御するいくつか他のループ節が
ある。それらはそれら自身だけで使われてもよいし、1つまたはそれ以上の
`for'節と結合してもよい。

`repeat INTEGER'
     この節は内部の一時変数を使って単純に指定された数まで数える。このルー
     プは、

          (loop repeat n do ...)
          (loop for temp to n do ...)

     2番目は実際には使わない変数のための名前を選ぶように強いることを除
     いて同一である。

`while CONDITION'
     この節は、指定した条件(任意のLisp式)が`nil'になったらループを止め
     る。たとえば、下記の2つのループは同等だが、2つ目のループを囲む暗黙
     の`nil'ブロックは異なる。

          (while COND FORMS...)
          (loop while COND do FORMS...)

`until CONDITION'
     この節は指定された条件が真、すなわち非`nil'のときにループを止める。

`always CONDITION'

     この節は指定された条件が`nil'のときにループを止める。`while'とは違
     い、`return nil'を使ってループを止めるので`finally'節は実行されな
     い。すべての条件が非`nil'の場合、ループは`t'を戻す:

          (if (loop for size in size-list always (> size 10))
              (some-big-sizes)
            (no-big-sizes))

`never CONDITION'
     この節は`always'と似ているが、ループはすべての条件が偽なら
     `t'を戻し、そうでなければ`nil'を戻す点が異なる。

`thereis CONDITION'
     この節は指定されたフォームが非`nil'のときにループを止める; この
     場合、非`nil'の値を戻す。すべての値が`nil'の場合、ループは
     `nil'を戻す。



File: cl-j, Node: 蓄積節, Next: その他の節, Prev: 繰り返し節, Up: ループ機能

蓄積節
------

これらの節は、ループが指定されたLispのFORMに関する情報を蓄積するように
する。蓄積された結果は、たとえば`return'節によって無効にされない限りルー
プから戻される。

`collect FORM'
     この節はFORMの値をリストに集積する。`collect'のいくつかの例がこの
     マニュアルの他のところで現れる。

     語`collecting'は`collect'の同義語であり、同様に他の蓄積節の同義語
     でもある。

`append FORM'
     この節は、`append'を使って値のリストを結果のリストへ集積する。

`nconc FORM'
     この節は、リストをコピーするのではなく破壊的に修正することで値のリ
     ストを結果のリストへ集積する。

`concat FORM'
     この節は指定されたFORMの値を文字列へ連結する。(これや下記の節は標
     準Common Lispへの拡張である。)

`vconcat FORM'
     この節は指定されたFORMの値をベクタへ連結する。

`count FORM'
     この節は、指定されたFORMが非`nil'値へ評価される回数を数える。

`sum FORM'
     この節は指定されたFORMの値の合計を蓄積する。FORMは評価されて数にな
     らなければならない。

`maximize FORM'
     この節は指定されたFORMの値の最大値を蓄積する。FORMは評価されて数に
     ならなければならない。`maximize'が1度も実行されなかった場合、戻り
     値は未定義である。

`minimize FORM'
     この節は指定されたFORMの最小値を蓄積する。

蓄積節は、無名の一時変数ではなく変数VAR(これはループ中に自動的に`let'束
縛される)にデータを集積するようにするために、`into VAR'を続けることがで
きる。また`into'蓄積は、自動的には戻り値を含まない。蓄積された結果を戻
すためには、ループは`finally return'のようななんらかの明示的なメカニズ
ムを使わなければならない。

同じ型のいくつかの蓄積節が同じ場所に蓄積することは正しい。Steeleから:

     (loop for name in '(fred sue alice joe june)
           for kids in '((bob ken) () () (kris sunshine) ())
           collect name
           append kids)
          => (fred bob ken sue alice joe kris sunshine june)



File: cl-j, Node: その他の節, Prev: 蓄積節, Up: ループ機能

その他の節
----------

この節は残りのループ節を記述する。

`with VAR = VALUE'
     この節はループの周りである値をある変数に束縛するが、その他の点では
     ループ中にその変数を孤立させる。下記のループは基本的に同等である:

          (loop with x = 17 do ...)
          (let ((x 17)) (loop do ...))
          (loop for x = 17 then x do ...)

     当然、変数VARはループの残りでなんらかの用途に使われるかもしれない。
     たとえば:

          (loop for x in my-list  with res = nil  do (push x res)
                finally return res)

     このループは、`res'に蓄積されている新しいリストの先頭に`my-list'の
     要素を挿入し、それからループの終わりにリスト`res'を戻す。その効果
     は`collect'節の効果と類似しているが、要素は末尾にではなく`res'の先
     頭に置かれていくという事実のために逆順になる。

     `='項を省略した場合、その変数は`nil'に初期化される(したがって上記
     の例の`= nil'は不要である)。

     `with'によって作られる束縛は、`let*'によってのように、既定では順次
     である。ちょうど`for'節のように、`with'節はその代わりに束縛が
     `let'によって作られるようにするために`and'と結合されえる。

`if CONDITION CLAUSE'
     この節は、指定された条件が真の場合だけ、それに続くループを実行する。
     下記のCLAUSEは蓄積であるべきである; `do'や`return'、`if'、
     `unless'節。いくつかの節は、それらを`and'で切り離して結合されても
     よい。

     これらの節には、`else'と、条件が偽の場合に実行される1つまたは複数
     の節が続いてもよい。すべての構文要素には、付加的に語`end' (それは
     入れ子の`if'の中で`else'や`and'をあいまいでなくするために使われて
     もよい)が続いてもよい。

     実際の条件式の非`nil'の値は、"then"部の中で名前`it'として利用でき
     る。たとえば:

          (setq funny-numbers '(6 13 -1))
               => (6 13 -1)
          (loop for x below 10
                if (oddp x)
                  collect x into odds
                  and if (memq x funny-numbers) return (cdr it) end
                else
                  collect x into evens
                finally return (vector odds evens))
               => [(1 3 5 7 9) (0 2 4 6 8)]
          (setq funny-numbers '(6 7 13 -1))
               => (6 7 13 -1)
          (loop <same thing again>)
               => (13 -1)

     2つの節を"then"部に置くための`and'の使用に注意せよ。その
     1つはそれ自身`if'節である。`end'は、通常は付加的であるが、
     `else'が最も外側の`if'節を参照することを
     明らかにするためにここでは必要だったことにも注意せよ。第1の場合、
     ループはXの奇数と偶数のリストのベクタを戻す。第2の場合、奇数7は
     `funny-numbers'の一つなのでループは早く戻る; 実際の戻り値は、
     `memq'呼び出しの結果に基づく。

`when CONDITION CLAUSE'
     この節は単に`if'の同義語である。

`unless CONDITION CLAUSE'
     `unless'節は、条件の意味が逆であることを除いてちょうど`if'に似てい
     る。

`named NAME'
     この節は、ループを囲む暗黙のブロックに`nil'以外の名前を与える。
     NAMEはブロック名として使われるシンボルである。

`initially [do] FORMS...'
     このキーワードはループ自身が始まる前(しかし`for'や`with'に要求され
     るすべての変数がその初期値に束縛された後)に実行される1つかそれ以上
     のLispフォームを導入する。`initially'節はどこにでも現れることがで
     きる; いくつかある場合、それらはループに現れる順に実行される。キー
     ワード`do'は付加的である。

`finally [do] FORMS...'
     これはループが終わった後(たとえば、`for'や`while'の要求で)に実行さ
     れるLispフォームを導入する。`initially'や`finally'節はループ構文要
     素のどこに現れてもよいが、それらはループのそれぞれ始まりや終わりに
     (指定された順序で)実行される。

`finally return FORM'
     これは、戻り値を得るためにループ終了後に実行されるべきFORMについて
     述べる(これや`collect'や`return'のようないくつか他の節がないと、ルー
     プは単に`nil'を戻すだろう)。`for'や`with'、`into'によって束縛され
     た変数は、FORMが実行されるときにその最後の値をまだ含んでいる。

`do FORMS...'
     語`do'には、ループ本体で暗黙の`progn'として実行される任意の数の
     Lisp式が続いてもよい。この節の例の多くは`do'の使用法を説明する。

`return FORM'
     この節は、ループが直ちに戻るようにする。それに続くLispフォームは評
     価され、`loop'フォームの戻り値を与える。`finally'節は、もしあった
     としても実行されない。もちろん、`return'は一般に`if'や`unless'の内
     部で使われるが、それはトップレベルのループ節での使用は、そのループ
     は決して1度以上"ループ"に到達しないことを意味するからである。

     節`return FORM'は`do (return FORM)'(あるいはループが名付けられてい
     る場合は`return-from')と同等である。しかし、`return'節は若干効率的
     に実装されている。

`loop'へユーザ拡張を加える(たとえば`setf'に対する`defsetf'に比較できる
ような)高水準の方法はないが、このパッケージは、与えられたシンボルがトッ
プレベルループ節や`for'節に出会ったときにそれぞれ呼び出される関数である
`cl-loop-handler'や`cl-loop-for-handler'と呼ばれる2つの属性を提供する。
詳細はファイル`cl-macs.el'のソースコードを調べよ。

このパッケージの`loop'マクロはCommon Lispのそれと互換だが、
`loop-finish'やデータ型指定子のようないくつかの機能は実装されていない。
当然、キーマップやオーバレイ、インターバル、フレーム、ウィンドウ、バッ
ファ上で繰り返す`for'節はEmacs特有の拡張である。



File: cl-j, Node: 多値, Prev: ループ機能, Up: 制御構造

多値
====

Common Lisp関数は0個またはそれ以上の結果を戻すことができる。Emacs Lisp
関数は、対称的に常に正確に1つの結果を戻す。このパッケージはCommon Lisp
多重戻り値のエミュレートを試みない; 1つ以上の値を戻すCommon Lisp関数の
Emacs版は、(`compiler-macroexpand'でのように)単に最初の値を
戻すか、(`get-setf-method'でのように)値のリストを戻す。この
パッケージは、多値とともに動作するCommon Lisp関数のための場所確保を
定義*する*が、Emacs Lispでは、それらの関数はその代わりに単に
リスト上で作用する。たとえば、`values'フォームはEmacsでは
`list'の同義語である。

 -- Special form: multiple-value-bind (VAR...) VALUES-FORM FORMS...
     このフォームはVALUES-FORMを評価する。VALUES-FORMは値のリストを戻さ
     なければならない。それからVAR達を`let'でのようにそれぞれの値で束縛
     し、本体FORMSを実行する。値より多くのVAR達がある場合、余分のVAR達
     は`nil'に束縛される。VAR達が値より少ない場合、余分の値は無視される。

 -- Special form: multiple-value-setq (VAR...) FORM
     このフォームはFORMを評価する。FORMは値のリストを
     戻さなければならない。それからVAR達に`setq'
     でのようにそれぞれの値を設定する。余分のVAR達や値は
     `multiple-value-bind'と同様に扱われる。

より古いQuirozのパッケージは、Common Lisp多値のより忠実な(しかしなお不
完全な)エミュレーションを試みた。古い方法は"通常は"真の多値をきわめてう
まくシミュレートしたが、ある条件下では、メモリ中に後に無関係な
`multiple-value-bind'フォームが見るような偽の戻り値を残す。

Emacs Lispでは完全なエミュレーションは実現不可能なので、このパッケージ
は可能な限り単純に、そして予測可能なようにすることを選んだ。



File: cl-j, Node: マクロ, Next: 宣言, Prev: 制御構造, Up: Top

マクロ
******

このパッケージは、分配や`&environment'、`&body'のような`defmacro'のさま
ざまなCommon Lisp機能を実装する。トップレベルの`&whole'は、技術的困難の
ために`defmacro'のためには実装されない。*Note 引数リスト::.

分配は、下記のマクロを通してユーザに利用可能になっている:

 -- Special form: destructuring-bind ARGLIST EXPR FORMS...
     このマクロは、ARGLISTの中の変数がEXPRによって戻される値のリストに
     束縛されている状態で、FORMSを実行するコードに展開する。ARGLISTは、
     分配を含む`defmacro'引数リストのために許されるすべての機能を含むこ
     とができる(`&environment'キーワードは許されない)。マクロ展開は、
     EXPRが不正な引数の個数のリストを戻したり、不正なキーワード引数があ
     る場合はエラーを通知するだろう。

このパッケージは、Common Lispの`define-compiler-macro'機能も含んでおり、
コンパイル時展開の定義や関数の最適化を許す。

 -- Special form: define-compiler-macro NAME(名前) ARGLIST FORMS...
     このフォームは`defmacro'と似ているが、コンパイル時にだけNAMEへの呼
     び出しへ展開される点が異なる; Lispインタプリタで処理される呼び出し
     は展開されず、`macroexpand'関数によっても展開されない。

     引数リストは`&whole'キーワードと変数で始まってもよい。この変数はマ
     クロ呼び出しフォーム自身に、すなわちフォーム`(NAME ARGS...)'のリス
     トに束縛される。マクロエクスパンダがこのフォームを変えずに戻す場合、
     コンパイラは通常の関数呼び出しとして扱う。このことは、コンパイラマ
     クロが、複雑な場合はそのままにしながら、関数の特殊な場合のためのオ
     ブティマイザとして働くことを許す。

     たとえば、これはこのパッケージの標準部分として現れる単純化された定
     義の版である:

          (define-compiler-macro member* (&whole form a list &rest keys)
            (if (and (null keys)
                     (eq (car-safe a) 'quote)
                     (not (floatp-safe (cadr a))))
                (list 'memq a list)
              form))

     @noindent

     この定義は、Aが浮動小数点定数ではないような普通の場合に、
     `(member* A LIST)'をより速い`memq'の呼び出しへ変えることを引き起こ
     す; Aがその他の場合か、呼び出しにキーワード引数がある場合、オリジ
     ナルの`member*'呼び出しはそのまま残る(実際の`member*'のためのコン
     パイラマクロは、共通の`:test'述語を含むその他のかなりのものを最適
     化する)。

 -- Function: compiler-macroexpand FORM
     この関数は`macroexpand'に似ているが、通常のマクロではなくコンパイ
     ラマクロを展開する点が異なる。コンパイラマクロがそのために定義され
     た関数の呼び出しではない場合、またはコンパイラマクロがその
     `&whole'引数を戻すことでパントすることを決定した場合、FORMを変えず
     に戻す。`macroexpand'のように、それ以上の展開が不可能なフォームに
     達するまで繰り返し展開する。

`macrolet'の記述と"局所"マクロ定義作成のための
`symbol-macrolet'フォームについては、*Note マクロ束縛::.



File: cl-j, Node: 宣言, Next: シンボル, Prev: マクロ, Up: Top

宣言
****

Common Lispは、特別の変数に格納されるデータの型や、それらの変数や関数が
どのように使われるかについて特殊なヒントをコンパイラに与えることを許す、
複雑で強力な"宣言"メカニズムを含む。このパッケージは、`declare' や
`locally'、`proclaim'、`declaim'、`the'といったすべてのCommon Lisp宣言
フォームの版を定義する。

Common Lisp宣言のほとんどは、現在はEmacs Lispでは有用ではない。バイトコー
ドシステムは型情報から利益を得る機会をほとんど提供していないし、
`special'宣言は完全に動的スコープのLispでは冗長だからである。しかし、い
くつかの宣言はEmacs 19の最適化バイトコンパイラが使われるときに意味があ
る。以前の非最適化コンパイラでは、これらの宣言は実際には無視される。

 -- Function: proclaim DECL-SPEC
     この関数は、DECL-SPECによって指定された"グローバル"宣言を記録する。
     `proclaim'は関数なので、DECL-SPECは評価され、したがって通常は引用
     符をつけるべきである。

 -- Special form: declaim DECL-SPECS...
     このマクロは`proclaim'に似ているが、DECL-SPEC引数を任意個数取るこ
     とと、引数は評価されず引用符はつけない点が異なる。`declaim'マクロ
     はまた、実行時と同様にコンパイル時にも登録されるように、宣言の周り
     に`(eval-when (compile load eval) ...)'を置く(このことはきわめて重
     要である。宣言は通常、`declaim'フォームを含むファイルの残りをコン
     パイラが扱う方法に影響するように意図しているからである)。

 -- Special form: declare DECL-SPECS...
     このマクロは、関数や他のコード内で宣言するために使われる。Common Lisp
     はさまざまな場所で、一般にLisp文法を通じて、関数本体や`let'本体、
     その他のような多くの"暗黙の`progn'"の始まりで宣言を許す。現在
     `declare'によって理解される唯一の宣言は`special'である。

 -- Special form: locally DECLARATIONS... FORMS...
     このパッケージでは、`locally'は`progn'と相違はない。

 -- Special form: the TYPE FORM
     `the'によって提供される型情報はこのパッケージでは無視される;言い替
     えれば、`(the TYPE FORM)'はFORMと同等である。最適化バイトコンパイ
     ラの将来の版はこの情報を利用するかもしれない。

     たとえば、`mapcar'はリストと配列の両方にマップできる。列がリストか
     配列か前もってわからない限り、コンパイラがコンパイラが`mapcar'をイ
     ンラインループへ展開することは難しい。

     `(mapcar 'car (the vector foo))'に対して、将来のコンパイラは、ルー
     プをインラインに展開するための十分な情報を持つかもしれない。今のと
     ころ、Emacs Lispは上記のコードを`(mapcar 'car foo)'と正確に同等に
     扱う。

`proclaim'や`declaim'、`declare'のそれぞれのDECL-SPECは、どんな種類の宣
言かを言うシンボルで始まるリストであるべきである。このパッケージは、現
在は`special'や`inline'、`notinline'、`optimize'、`warn'宣言を理解する
(`warn'宣言は標準Common Lispへの拡張である)。`type'や`ftype'のような他
のCommon Lisp宣言は無言で無視される。

`special'
     Emacs Lispのすべての変数は(Common Lispの意味で)"スペシャル"である
     ので、`special'宣言は単なる助言である。それらは単に、指定された変
     数は意図的に関数本体で束縛されずに参照されることを最適化バイトコン
     パイラに告げる。コンパイラは通常、そのような参照に警告を発するが、
     それは局所変数への参照の誤記である可能性があるためである。

     宣言`(declare (special VAR1 VAR2))'は最適化コンパイラでは`(defvar
     VAR1) (defvar VAR2)'と同等であり、より古いコンパイラ(非局所参照を
     警告しない)ではまったく何とも同等ではない。

     トップレベルコンテキストでは、`(declaim (special VAR))'よりも
     `(defvar VAR)'と書く方が一般に優れている。`defvar'はあなたの意図を
     より明らかにするからである。しかし古いバイトコンパイラは、関数の内
     部に現れる`defvar'を扱えないが、`(declare (special VAR))'はすべて
     のコンパイラで正しく働くよう注意が払われる。

`inline'
     `inline' DECL-SPECは、コンパイラが準備できるときはいつでも、その本
     体を呼び出す関数に"インライン"に展開すべき1つまたはそれ以上の関数
     をリストする。たとえば、Common Lisp関数`cadr'は、1回の(比較的高価
     な)関数呼び出しを省くために、フォーム`(cadr X)'はユーザ関数で呼び
     出される際に直接`(car (cdr X))'に展開されるように、このパッケージ
     によって`inline'と宣言される。

     下記の宣言はすべて同等である。`defsubst'フォームは関数を定義してそ
     れをインラインにするのをすべて1度に行なう便利な方法だが、Emacs 19
     でしか利用できないことに注意せよ。

          (declaim (inline foo bar))
          (eval-when (compile load eval) (proclaim '(inline foo bar)))
          (proclaim-inline foo bar)      ; Lucid Emacs only
          (defsubst foo (...) ...)       ; instead of defun; Emacs 19 only

     *注意せよ:* この宣言は、含んでいるソースファイルが終わった後も効果
     を残す。あなたが定義した関数がインラインになるべきと要求するために
     使うことは正しいが、外部関数のインライン化を要求するために使うこと
     は無作法である。

     Common Lispでは、ある関数への特別な呼び出しが単にその呼び出しをイ
     ンラインにする前に、`(declare (inline ...))'を使うことが可能である;
     現在のバイトコンパイラは、これを実装する方法を提供していないので、
     `(declare (inline ...))'は現在はこのパッケージによって無視される。

`notinline'
     `notinline'宣言は、結局インラインにすべきでない関数をリストする;そ
     れは以前の`inline'宣言を取り消す。

`optimize'
     この宣言は、どのくらいの最適化がコンパイラによってなされるかを制御
     する。当然、それは初期の非最適化コンパイラでは無視される。

     語`optimize'には、`(speed 3)'や`(safety 2)'のように任意の数のリス
     トが続く。Commons Lispは、いつくかの最適化"品質"を定義する; このパッ
     ケージは、`speed'と`safety'以外はすべて無視する。品質の値は0から3
     までの整数であるべきである。0は"重要でない"を、3は"とても重要であ
     る"を意味する。両者の品質の既定レベルは1である。

     このパッケージ中では、Emacs 19の最適化コンパイラの場合、`speed'品
     質は`byte-compile-optimize'フラグに結びつけられ、`(speed 0)'の場合
     は`nil'が、より高い設定の場合は`t'が設定される; また、`safety'品質
     は`byte-compile-delete-errors'フラグに結びつけられ、`(safety 3)'の
     場合は`t'が、より低いすべての設定の場合は`nil'が設定される(後者の
     フラグは、その副作用のみがエラーを通知する可能性があるようなコード
     を最適化し去るかどうか(たとえば`foo'が実行時に束縛されるかどうかが
     未知の場合に`(progn foo bar)'を`bar'に書き直す)を制御する)。

     `(safety 0)'でコンパイルしてさえ、Emacsのバイトコードシステムは、
     真に害になることが起こらないようにするための十分なチェックを提供す
     ることに注意せよ。たとえば、Emacs自身に重大なバグがなければ、
     Emacsは単に完全に最適化されたLispプログラム中のエラーのためにセグ
     メント違反でクラッシュすることはない。

     `optimize'宣言は、通常はファイルのトップレベルの`proclaim'や
     `declaim'で使われる; Common Lispは、与えられたフォームに局所的な最
     適化のレベルを設定するために、`declare'と一緒に使われることを許す
     が、これは最適化コンパイラの現在の版では正しく動作しないだろう
     (`declare'は新たな最適化レベルを設定するだろうが、そのレベルは、囲
     むフォームが終わった後に自動的には設定解除されないだろう)。

`warn'
     この宣言は、どんな種類の警告がバイトコンパイラによって生成されるか
     を制御する。再度言うと、最適化コンパイラだけが警告を生成する。語
     `warn'には、最適化品質に似た形式の任意個数の"警告品質"が続く。現在
     サポートされている警告の型は、`redefine'や`callargs'、
     `unresolved'、`free-vars'である; 現在のシステムでは、0の値はそれら
     の警告を無効にし、それ以上のすべての値は有効にする。詳細は最適化バ
     イトコンパイラの文書を見よ。



File: cl-j, Node: シンボル, Next: 数, Prev: 宣言, Up: Top

シンボル
********

このパッケージは、Emacs Lispに無いいくつかのシンボル関連の機能を定義す
る。

* Menu:

* 属性リスト::
* シンボル生成::



File: cl-j, Node: 属性リスト, Next: シンボル生成, Prev: シンボル, Up: シンボル

属性リスト
==========

これらの関数は、シンボルに付けられた属性に作用するように、標準Emacs
Lisp関数`get'や`put'を増加させる。特定のシンボルに付けられていない、
ファーストクラスデータ構造としての属性リストに作用する関数もある。

 -- Function: get* SYMBOL PROPERTY &optional DEFAULT
     この関数は`get'に似ているが、属性がみつからない場合、DEFAULT引数が
     戻り値を提供する点が異なる(Emacs Lispの`get'は常に`nil'を既定とし
     て使う; このパッケージの`get*'はCommon Lispの`get'と同等である)。

     `get*'関数は`setf'可能である; このように使われる場合、
     DEFAULT引数は許されるが無視される。

 -- Function: remprop SYMBOL PROPERTY
     この関数は、SYMBOLの属性リストから、PROPERTYのための
     エントリを取り除く。属性が実際に見つかって取り除かれた場合は真の値を
     戻し、そのような属性がない場合は`nil'を戻す(この関数は、
     `get'はDEFAULTを許さなかったので、属性が
     見つからないこととその値が`nil'である属性を区別することが
     難しかったために、おそらく元のEmacsから省略されたのだろう;
     したがって、属性を`nil'へ設定することは、ほとんどの用途で
     `remprop'と十分に近かった)。

 -- Function: getf PLACE PROPERTY &optional DEFAULT
     この関数は、リストPLACEを属性リスト、すなわち属性名と値の交替する
     リストであるかのように走査する。PROPERTYと`eq'であるPLACEの偶数番
     目の要素が見つかった場合、続く奇数番目の要素が戻される。さもなけれ
     ば、DEFAULT(既定が与えられていない場合は`nil')が戻される。

     特に、

          (get sym prop)  ==  (getf (symbol-plist sym) prop)

     `getf'を`setf'場所として使うことは正しい。その場合、PLACE引数はそ
     れ自身正しい`setf'場所でなければならない。DEFAULT引数は、もしあれ
     ば、このコンテキストでは無視される。その効果は、PROPERTYに対応する
     リスト中の値セルを(`setcar'によって)変えるか、属性がまだ存在しない
     場合は、新しい属性と値の対をリスト上にコンスする。

          (put sym prop val)  ==  (setf (getf (symbol-plist sym) prop) val)

     `get'や`get*'関数もまた`setf'可能である。`default'が無視されるとい
     う事実はときには有用になり得る:

          (incf (get* 'foo 'usage-count 0))

     ここでは、シンボル`foo'の`usage-count'属性が、存在する場合は1だけ
     増やされ、そうでなければ1(1だけ増やされた0)が設定される。

     `setf'フォームとして使われない場合、`getf'は単に正規の関数であり、
     そのPLACE引数は実際にどんなLisp式であってもよい。

 -- Special form: remf PLACE PROPERTY
     このマクロは、PLACEに格納された属性リストから、PROPERTYの
     属性と値の対を取り除く。PLACEは任意の`setf'可能な場所の
     式である。属性が見つかった場合は真を戻す。PROPERTYがたまたま
     リストの先頭の場合、実際に`(setf PLACE (cddr PLACE))'
     を行なうが、もっと後で生じた場合は、属性と値のセルをつなぐために単に
     `setcdr'を使うことに注意せよ。




File: cl-j, Node: シンボル生成, Prev: 属性リスト, Up: シンボル

シンボル生成
============

これらの関数は、典型的には一時変数として使われる、ユニークなシンボルを
作成する。

 -- Function: gensym &optional X
     この関数は、新しい、ユニークな名前を持つinternされていないシンボル
     を(`make-symbol'を使って)作る(internされていないシンボルの名前は、
     そのシンボルが印字されるときだけ関係がある)。既定では、名前は
     `G1000'、`G1001'、`G1002'のように、増加する数列から生成される。付
     加引数Xが文字列の場合、その文字列は`G'の代わりに接頭辞として使われ
     る。internされていないシンボルは、それらの名前がユーザコード中の"
     本当の"変数と衝突しないことを確実にするために、マクロ展開中に一時
     変数として使われる。

 -- Variable: *gensym-counter*
     この変数は、`gensym'名を生成するために使われるカウンターを保持する。
     各`gensym'の使用後に1つ増やされる。Common Lispではこれは0に初期化
     されるが、このパッケージは、そのコンパイル中にそれぞれ`gensym'を使
     う2つのファイルが一緒にロードされたときにトラブルを避けるため、ラ
     ンダムな(時刻依存の)値で初期化する(internされていないシンボルは、
     コンパイラがそれらをファイルへ書き出してEmacsローダがロードすると
     きにinternされるので、その名前は、internされていないシンボルはロー
     ド後もinternされないままであるCommon Lispよりも少しだけ、より注意
     深く扱われなければならない)。

 -- Function: gentemp &optional X
     この関数は`gensym'に似ているが、新しい*internされた*シンボルを生成
     する点が異なる。生成されたシンボルがすでに存在する場合、この関数は
     カウンタを1つずつ増やして、新たなシンボルが生成されるまで再試行し
     続ける。

Quirozの`cl.el'パッケージも、自己引用キーワードシンボル作成用に
`defkeyword'フォームを定義した。このパッケージは、`&key'
引数指定子によって呼び出されるすべてのキーワードを自動的に作り、
キーワード引数に無関係なデータとしてのキーワードの使用に反対するので、
`defkeyword'フォームは中止した。




File: cl-j, Node: 数, Next: 列, Prev: シンボル, Up: Top

数
**

この節は、Emacs Lispでは省かれた、数へのいくつかの単純なCommon Lisp演算
を定義する。

* Menu:

* 数の述語::
* 数の関数::
* 乱数::
* 処理系パラメータ::




File: cl-j, Node: 数の述語, Next: 数の関数, Prev: 数, Up: 数

数の述語
========

これらの関数は、指定された条件が数の引数で真の場合に`t'を戻し、さもなけ
れば`nil'を戻す。

 -- Function: plusp NUMBER
     この述語は、NUMBERが正かどうかをテストする。引数が数でない場合はエ
     ラーである。

 -- Function: minusp NUMBER
     この述語は、NUMBERが負かどうかをテストする。引数が数でない場合はエ
     ラーである。

 -- Function: oddp INTEGER
     この述語は、INTEGERが奇数かどうかをテストする。引数が整数でない場
     合はエラーである。

 -- Function: evenp INTEGER
     この述語は、INTEGERが偶数かどうかをテストする。引数が整数でない場
     合はエラーである。

 -- Function: floatp-safe OBJECT
     この述語は、OBJECTが浮動小数点数かどうかをテストする。浮動小数点数
     をサポートするシステムでは、これは`floatp'と同等である。他のシステ
     ムでは、これは常に`nil'を戻す。




File: cl-j, Node: 数の関数, Next: 乱数, Prev: 数の述語, Up: 数

数の関数
========

これらの関数は、さまざまな数の算術演算を行なう。

 -- Function: abs NUMBER(数)
     この関数は、NUMBERの絶対値を戻す(より新しいEmacsの版は、これを組み
     込み関数として提供する; このパッケージは、プリミティブとして提供し
     ないEmacs 18版用にだけ`abs'を定義する)。

 -- Function: expt BASE POWER
     この関数は、NUMBER乗したBASEを戻す(より新しいEmacsの版は、これを組
     み込み関数として提供する; このパッケージは、プリミティブとして提供
     しないEmacs 18版用にだけ`expt'を定義する)。

 -- Function: gcd &rest INTEGERS
     この関数は、引数の最大公約数を戻す。引数が1つの場合、その引数の絶
     対値を戻す。引数がない場合は0を戻す。

 -- Function: lcm &rest INTEGERS
     この関数は、引数の最小公倍数を戻す。引数が1つの場合、その引数の絶
     対値を戻す。引数がない場合は1を戻す。

 -- Function: isqrt INTEGER
     この関数は、その整数引数の"整数平方根"、すなわち、引数の真の平方根
     より小さいか等しい最大の整数を計算する。

 -- Function: floor* NUMBER &optional DIVISOR
     この関数は、Common Lispの`floor'関数を実装する。Emacs 19に
     組み込みの単純な`floor'関数との名前の衝突を避けるため、
     `floor*'と呼ばれる。

     引数が1つの場合、`floor*'は2つの数のリストを戻す: 2つの数は、整数
     へ(負の無限大方向へ)丸められた引数と、引数を再び生み出すために第1
     の戻り値に加え戻す必要があるような"余り"である。引数が整数Xの場合、
     結果は常にリスト`(X 0)'である。引数がEmacs19の浮動小数点数の場合、
     第1の結果はLisp整数であり、第2は0(含む)から1(含まない)の間のLisp浮
     動小数点数である。

     引数が2つの場合、`floor*'はDIVISORでNUMBERを割り、商のfloorと、対
     応する余りを2つの数のリストとして戻す。`(floor* X Y)'が`(Q R)'を戻
     す場合、Rを0(含む) からR(含まない)までとして、`Q*Y + R = X'である。
     `(floor* X)'は、正確に`(floor* X 1)'と同等であることにも注意せよ。

     この関数は、Common Lispの`floor'と完全に互換だが、Emacs Lispは多値
     関数をサポートしていないので、リストに入った2つの結果を戻す点が異
     なる。

 -- Function: ceiling* NUMBER &optional DIVISOR
     この関数は、Common Lispの`ceiling'関数を実装する。`ceiling'は、正
     の無限大方向へ引数または引数の商を丸める点を除いて、`floor'と類似
     している。余りは0から負のRまでである。

 -- Function: truncate* NUMBER &optional DIVISOR
     この関数は、Common Lispの`truncate'関数を実装する。
     `truncate'は、0の方向へ引数または引数の商を丸める点を除いて、
     `floor'と類似している。したがって、引数または商が正の場合は
     `floor*'と、さもなければ`ceiling*'と同等である。余りは
     NUMBERと同じ符号を持つ。

 -- Function: round* NUMBER &optional DIVISOR
     この関数は、Common Lispの`round'関数を実装する。`round'は、最も近
     い整数へ引数または引数の商を丸める点を除いて、`floor'と類似してい
     る。タイ(引数または引数の商が正確に2つの整数の中間)の場合、偶数へ
     丸める。

 -- Function: mod* NUMBER DIVISOR
     この関数は、`floor'の2つ目の戻り値と同じ値を戻す。

 -- Function: rem* NUMBER DIVISOR
     この関数は、`truncate'の2つ目の戻り値と同じ値を戻す。

これらの定義は、Quirozの`cl.el'パッケージと互換だが、このパッケージは、
既存のEmacs Lisp関数との衝突を避けるために、ある種の関数名に`*'を付加し
ている点と、多値戻しのメカニズムが異なる。




File: cl-j, Node: 乱数, Next: 処理系パラメータ, Prev: 数の関数, Up: 数

乱数
====

このパッケージは、Common Lisp乱数ジェネレータの実装も提供する。独自の付
加適合的アルゴリズムを使っており、多くのオペレーティングシステムによっ
て提供される単純なジェネレータよりも、ずっと統計的にきれいな乱数をおそ
らく与える。

 -- Function: random* NUMBER &optional STATE
     この関数は、NUMBERより小さく同じ型(整数か浮動小数点数のどちらか)の、
     負でない乱数を戻す。STATE引数は乱数ジェネレータの状態を保持する
     `random-state'オブジェクトでなければならない。この関数は副作用とし
     て、この状態オブジェクトを修正する。STATEが省略された場合、変数
     `*random-state*'を既定とする。`*random-state*'は、あらかじめ初期化
     された`random-state'オブジェクトを含む。

 -- Variable: *random-state*
     この変数は、システム"既定"の`random-state'オブジェクトを含み、代替
     の状態オブジェクトを指定しない`random*'への呼び出しのために使われ
     る。Emacsプロセス内の任意の数のプログラムは、さしはさむような仕方
     で`*random-state*'にアクセスしてもよいので、この変数から生成される
     列は、意図や用途にかかわらず再現不能になるだろう。

 -- Function: make-random-state &optional STATE
     この関数は、`random-state'オブジェクトを作成またはコピーする。
     STATEが省略されるか`nil'の場合、新しい`*random-state*'のコピーを戻
     す。これは、`(random* N)'と`(random* N S)'(Sは新しいランダムステー
     トオブジェクト)の呼び出しの将来の列は同一の乱数列を戻すという意味
     でコピーである。

     STATEが`random-state'オブジェクトの場合、この関数はそのオブジェク
     トのコピーを戻す。STATEが`t'の場合、この関数は日時を種とする新しい
     `random-state'オブジェクトを戻す。Common Lispへの拡張として、
     STATEは整数であってもよく、その場合は新しいオブジェクトはその整数
     を種とする; それぞれ異なる整数の種は、完全に異なる乱数列を生じるだ
     ろう。

     `random-state'オブジェクトをバッファまたはファイルに印字して、後に
     `read'で読み戻すことは正しい。プログラムが、デバッグ用に後に再現さ
     せられるような疑似乱数の列を使いたい場合、新しい列を取得するために
     `(make-random-state t)'を呼び出して、後にこの列をファイルへ印字す
     ることができる。プログラムが後で再実行される場合、ファイルからオリ
     ジナルな実行のランダムステートを読むことができる。

 -- Function: random-state-p OBJECT
     この述語は、OBJECTが`random-state'オブジェクトの場合に
     `t'を、さもなければ`nil'を戻す。



File: cl-j, Node: 処理系パラメータ, Prev: 乱数, Up: 数

処理系パラメータ
================

このパッケージは、数に関するいくつかの有用な定数を定義する。

 -- Variable: most-positive-fixnum
     この定数は、Lisp整数が保持できる最大値と等しい。典型的には
     `2^23-1'または`2^25-1'である。

 -- Variable: most-negative-fixnum
     この定数は、Lisp整数が保持できる最小値(最も負の値)と等しい。

下記のパラメータは浮動小数点数と関係がある。このパッケージは、さまざま
な方法で計算機の浮動小数点算術を用いてこれらの値を決定する。これらの演
算は遅いかもしれないので、それらの初期化用のコードは、パラメータが使わ
れる可能性がある前に呼び出されなければならない切り離された関数に保たれ
ている。

 -- Function: cl-float-limits
     この関数は、`most-positive-float'のようなCommon Lisp浮動小数点パラ
     メータが初期化されていることを確実にする。この関数が呼び出されるま
     で、これらのパラメータは`nil'だろう。このEmacsの版が(たとえば
     Emacs 18のほとんどの版のように)浮動小数点数をサポートしない場合、
     それらのパラメータは`nil'のままだろう。パラメータがすでに初期化さ
     れている場合、この関数は直ちに戻る。

     そのアルゴリズムはほとんどの現代のマシンに有効な仮定を置いているが、
     マシンの算術が、たとえば10進法のようにきわめて普通でない場合は失敗
     するだろう。

真のCommon Lispは、4つまでの異なる浮動小数点精度を持つので、
`most-positive-single-float'や`most-positive-double-float'、
`most-positive-long-float'などのような定数の一群を持つ。Emacsは1つの浮
動小数点精度のみを持つので、このパッケージは定数名から精度の語を省略す
る。

 -- Variable: most-positive-float
     この定数は、Lisp浮動小数点数が保持できる最大値と等しい。算術が無限
     をサポートするようなシステムでは、これは最大の*有限の*値である。
     IEEEマシンでは、その値はおおよそ`1.79e+308'である。

 -- Variable: most-negative-float
     この定数は、Lisp浮動小数点数が保持できる最も負の数と等しい(`(-
     most-positive-float)'と等しいと仮定される)。

 -- Variable: least-positive-float
     この定数は、0より大きい最小のLisp浮動小数点値と等しい。IEEEマシン
     では、非正規がサポートされている場合は約`4.94e-324'、そうでなけれ
     ば約`2.22e-308'である。

 -- Variable: least-positive-normalized-float
     この定数は、0より大きい最小の正規化されたLisp浮動小数点(すなわち、IEEE
     非正規化が精度の損失を生じない最小の値)と等しい。IEEEマシンでは、この
     値は約`2.22e-308'である。非正規化の概念や段階的なアンダーフローを
     サポートしていないマシンでは、この定数は常に
     `least-positive-float'と等しい。

 -- Variable: least-negative-float
     この定数は、`least-positive-float'

 -- Variable: least-negative-normalized-float
     この定数は、`least-positive-normalized-float'の負の相対物である。

 -- Variable: float-epsilon
     この定数は、別の値を生み出すために1.0に加えることができる、最小の
     正のLisp浮動小数点値である。より小さな数を1.0に加えても、丸めのた
     めに再び1.0を生じる。IEEEマシンでは、epsilonは約`2.22e-16'である。

 -- Variable: float-negative-epsilon
     この定数は、別の値を生み出すために1.0から減じることができる、最小
     の正の値である。IEEEマシンでは約`1.11e-16'である。




File: cl-j, Node: 列, Next: リスト, Prev: 数, Up: Top

列
**

Common Lispは、"列"に作用するかなりの数の関数を定義している。列はリスト
や文字列、ベクタのいずれかである。Emacs Lispはそれらのいくつか、特に
`elt'や`length'を含む; このパッケージは、残りのほとんどを定義する。

* Menu:

* 列の基本::                    すべての列関数で共有される引数
* 列上のマッピング::
* 列関数::
* 列の検索::
* 列のソート::



File: cl-j, Node: 列の基本, Next: 列上のマッピング, Prev: 列, Up: 列

列の基本
========

列関数の多くはキーワード引数をとる; *Note 引数リスト::. すべてのキーワー
ド引数は付加的であり、指定される場合は任意の順序に現れてよい。

`:key'引数は、`nil'あるいは1引数の関数を渡されなければならない。このキー
関数は、それを通して列の要素が見えるようなフィルタとして使われる; たと
えば、`(find x y :key 'car)'は`(assoc* x y)'と似ている: `x'自身に等しい
要素ではなく、その`car'が`x'に等しいリストの要素を検索する。`:key'が省
略されるか`nil'の場合、フィルタは実際には恒等関数である。

`:test'と`:test-not'引数は、`nil'あるいは2引数の関数でなければならない。
テスト関数は、2つの列要素を比較するために、あるいは検索値と列要素を比較
するために使われる(2つの値は、それから派生したオリジナルの列関数の引数
と同じ順序で、両方が同じ列からくる場合は列に現れるのと同じ順序で、テス
ト関数に渡される)。`:test'引数は、マッチを示すために真(非`nil')を戻す関
数を指定しなければならない; そのかわりに、マッチを示すために*偽*を戻す
関数を与えるために`:test-not'を使ってもよい。既定のテスト関数は`:test
'eql'である。

ITEMと`:test'または`:test-not'をとる関数の多くには、変種`-if'や
`-if-not'もある。そこでは、PREDICATE関数がITEMの代わりに渡され、その述
語が真(あるいは`-if-not'の場合は偽)を戻す場合、列の要素はマッチする。た
とえば:

     (remove* 0 seq :test '=)  ==  (remove-if 'zerop seq)

は、列`seq'からすべての0を取り除く。

いくつかの演算は、引数列の部分列に働くことができる; これらの関数は、
既定がそれぞれ0と列の長さである`:start'と`:end'引数をとる。
START(含む)とEND(含まない)の間の要素だけが、その演算に
影響される。END引数は、列の長さを表わすために`nil'を
渡されてもよい; さもなければ、STARTとENDはともに整数で、
`0 <= START <= END <= (length SEQ)'
でなければならない。関数が2つの列引数をとる場合、制限は、第1の列は
キーワード`:start1'と`:end1'で、第2の列はキーワード
`:start2'と`:end2'で定義される。

いくつかの関数は、`:from-end'引数と`:count'引数を受け入れる。
`:from-end'が非`nil'の場合、演算が左から右へではなく右から左へ列を通っ
ていくことを引き起こし、`:count'は、取り除かれるか処理されるかする要素
の最大数の整数を指定する。

列関数は、`:test'や`:test-not'、`:key'関数がさまざまな要素上で呼び出さ
れる順序を保証しない。したがって、これらの関数の副作用に依存するのは悪
い考えである。たとえば、`:from-end'は列が実際に逆順で走査されることを引
き起こすかもしれないし、正順で走査して、しかし後ろから走査されたように
結果を計算してもよい(`mapcar*'や`every'のようないくつかの関数は、副作用
がこれらの場合は完全に受け入れられるように、関数が呼び出される順序を正
確に指定*する*)。

GNU Emacs 19の文字列は、文字データと同様に"テキスト属性"を含んでもよい。
注がある場合を除いて、列関数によってテキスト属性が保存されるかどうかは
未定義である。たとえば`(remove* ?A STR)'は、STRからコピーされて結果とし
て生じた文字の属性を保存するかもしれないし、保存しないかもしれない。



File: cl-j, Node: 列上のマッピング, Next: 列関数, Prev: 列の基本, Up: 列

列上のマッピング
================

これらの関数は、リストまたは配列の要素上に、指定した関数を"マップ"する。
それらはすべて、組み込み関数`mapcar'のテーマの変奏である。

 -- Function: mapcar* FUNCTION SEQ &rest MORE-SEQS
     この関数は、その引数列に連続する並列の要素の集合上でFUNCTIONを呼び
     出す。1つのSEQ引数の場合、`mapcar'と同等である; N列の場合、結果の
     リストの第1要素を生み出すために、それぞれの列の第1要素をN引数とし
     て関数を呼び出す。それから第2要素以降にも同様に呼び出す。マップは、
     最も短い列が尽きたらすぐに止まる。引数列は、リストや文字列、ベクタ
     のいずれの混合でもよい; 戻される列は常にリストである。

     Common Lispの`mapcar'は多重引数を受け入れるが、リスト上でのみ動作
     する; Emacs Lispの`mapcar'は1つの列引数を受け入れる。このパッケー
     ジの`mapcar*'は、両方に互換なスーパーセットとして動作する。

 -- Function: map RESULT-TYPE FUNCTION SEQ &rest MORE-SEQS
     この関数は、ちょうど`mapcar*'のように、引数列の上にFUNCTION
     をマップするが、リストではなく型RESULT-TYPEの列を戻す。
     RESULT-TYPEは下記のシンボルの1つでなければならない:
     `vector'、`string'、`list'(この場合、効果は
     `mapcar*'と同じ)、または`nil'(この場合、結果は捨て去られ、
     `map'は`nil'を戻す)。

 -- Function: maplist FUNCTION LIST &rest MORE-LISTS
     この関数は、その引数リストのそれぞれの上でFUNCTIONを呼び出して、そ
     れらのリストの`cdr'の上で呼び出して、というように最短のリストが尽
     きるまで続く。結果はリストのフォーム中に戻される。したがって
     `maplist'は、前進するポインタの`car'ではなく、リストのポインタ自身
     を通っていく点を除いて、`mapcar*'と似ている。

 -- Function: mapc FUNCTION SEQ &rest MORE-SEQS
     この関数は`mapcar*'と似ているが、FUNCTIONによって戻される
     値はリストに集積されるのではなく、無視され捨て去られる点が異なる。
     `mapc'の戻り値は、第1の列SEQである。

 -- Function: mapl FUNCTION LIST &rest MORE-LISTS
     この関数は`maplist'に似ているが、FUNCTIONによって戻される値を捨て
     去る点が異なる。

 -- Function: mapcan FUNCTION SEQ &rest MORE-SEQS
     この関数は`mapcar*'に似ているが、単に戻り値(リストでなければならな
     い)を集積するのではなく、`nconc'を使って連結する点が異なる。

 -- Function: mapcon FUNCTION LIST &rest MORE-LISTS
     この関数は`maplist'に似ているが、`nconc'を使って戻り値を連結する点
     が異なる。

 -- Function: some PREDICATE SEQ &rest MORE-SEQS
     この関数は、順にSEQの各要素にPREDICATEを呼び出す; PREDICATEが非
     `nil'を戻す場合、`some'はその値を戻し、そうでなければ`nil'を戻す。
     いくつかの列引数が与えられる場合、ちょうど`mapcar*'のように、最短
     の列が尽きるまで並列に列を通る。左から右への順序で要素が訪問される
     ことや、PREDICATEが非`nil'を戻すとすぐにマッピングが止まるという事
     実に依存できる。

 -- Function: every PREDICATE SEQ &rest MORE-SEQS
     この関数は、順に列の各要素にPREDICATEを呼び出す; PREDICATEがいずれ
     かの要素で`nil'を戻すとすぐに`nil'を、述語がすべての要素で真の場合
     に`t'を戻す。

 -- Function: notany PREDICATE SEQ &rest MORE-SEQS
     この関数は、順に列の各要素にPREDICATEを呼び出す; PREDICATEがいずれ
     かの要素で非`nil'を戻すとすぐに`nil'を、述語がすべての要素で`nil'
     の場合に`t'を戻す。

 -- Function: notevery PREDICATE SEQ &rest MORE-SEQS
     この関数は、順に列の各要素にPREDICATEを呼び出す; PREDICATEがいずれ
     かの要素で`nil'を戻すとすぐに非`nil'を、述語がすべての要素で真の場
     合に`t'を戻す。

 -- Function: reduce FUNCTION SEQ &key :FROM-END :START :END :INITIAL-VALUE :KEY
     この関数は、結合二項演算を使ってSEQの要素を結合する。FUNCTIONが
     `*'でSEQがリスト`(2 3 4 5)'だと仮定する。最初のリストの2つの要素は
     `(* 2 3) = 6'と結合される;これは次の要素`(* 6 4) = 24'と結合され、
     最後の要素`(* 24 5) = 120'と結合される。`*'関数はたまたま自己縮約
     的なので、`(* 2 3 4 5)'は`reduce'への明示的な呼び出しと同じ効果を
     持つことに注意せよ。

     `:from-end'が真の場合、縮約は左結合の代わりに右結合である:

          (reduce '- '(1 2 3 4))
               == (- (- (- 1 2) 3) 4) => -8
          (reduce '- '(1 2 3 4) :from-end t)
               == (- 1 (- 2 (- 3 4))) => -2

     `:key'が指定された場合、それは順に列の各要素上で呼び出される、1引
     数の関数である。

     `:initial-value'が指定された場合、それは実際に列の先頭に
     (`:from-end'の場合は末尾に)加えられる。`:key'関数は初期値には適用
     され*ない*。

     列が、初期値を含めて正確に1つの要素を持つ場合、その要素は決して
     FUNCTIONを呼び出すことなしに戻される。列が空の(そして初期値がない)場
     合、FUNCTIONは戻り値を得るために、引数なしで呼び出される。

これらのマッピング演算はすべて、`loop'マクロで便利に表現することができ
る。コンパイルされたコードでは、関数呼び出しのないインラインコードとし
てループを生成するので、`loop'の方が速いだろう。



File: cl-j, Node: 列関数, Next: 列の検索, Prev: 列上のマッピング, Up: 列

列関数
======

この節は、列に作用するかなりの数のCommon Lisp関数を記述する。

 -- Function: subseq SEQUENCE START &optional END
     この関数は、引数SEQUENCEの与えられた部分列を戻す。SEQUENCEはリスト
     や、文字列、ベクタでもよい。インデックスSTARTとENDは範囲内でなけれ
     ばならず、STARTはENDより大きくてはならない。ENDが省略された場合、
     列の長さを既定とする。戻り値は常にコピーである; SEQUENCEと構造を共
     有しない。

     Common Lispへの拡張として、STARTおよび/またはENDは負数でも
     よい。その場合、それらは列の終わりからの距離を表現する。これは、Emacs
     の`substring'関数と互換である。`subseq'は、負のSTARTや
     ENDを許す*唯一の*列関数であることに注意せよ。

     要素の指定した範囲を別の列の要素で置き換えるために、`subseq'
     フォーム上で`setf'を使うことができる。置き換えは、以下に記述する
     `replace'によってのように行なわれる。

 -- Function: concatenate RESULT-TYPE &rest SEQS
     この関数は、型RESULT-TYPEの結果の列を形成するために、引数列を一緒
     に連結する。RESULT-TYPEはシンボル`vector'または`string'、`list'の
     いずれかである。引数は、結果が引数と同一である`(concatenate 'list
     '(1 2 3))'のような場合ですら常にコピーされる。

 -- Function: fill SEQ ITEM &key :START :END
     この関数は、値ITEMで列の要素(あるいは列の指定された部分)を満たす。

 -- Function: replace SEQ1 SEQ2 &key :START1 :END1 :START2 :END2
     この関数は、SEQ2の一部をSEQ1の一部にコピーする。列SEQ1は伸びたり縮
     んだりしない; コピーされるデータの量は、単に元と先の(副)列の短い方
     である。この関数はSEQ1を戻す。

     SEQ1とSEQ2が`eq'の場合、開始と終了引数で示される範囲が重なっていて
     も正しく動作する。しかし、SEQ1とSEQ2が、記憶域を共有するが`eq'では
     ないリストであり、開始と終了引数が重なる範囲を指定する場合、その効
     果は未定義である。

 -- Function: remove* ITEM SEQ &key :TEST :TEST-NOT :KEY :COUNT :START :END :FROM-END
     これは、ITEMにマッチするすべての要素を取り除いたSEQのコピーを戻す。
     結果は、ある状況ではSEQと記憶域を共有するか`eq'であってもよいが、
     オリジナルのSEQは修正されない。`:test'や`:test-not'、`:key'引数は
     使われるマッチテストを定義する; 既定では、ITEMと`eql'の要素が取り
     除かれる。`:count'引数は、取り除かれてよいマッチする要素の最大数を
     指定する(一番左のCOUNTマッチだけが取り除かれる)。`:start'と`:end'
     引数は、要素が取り除かれるSEQの領域を指定する; 領域の外の要素は、
     マッチしないか取り除かれない。`:from-end'引数が真の場合、要素は先
     頭からではなく列の終わりから削除されるべきだということを表わす(こ
     れはCOUNTも指定された場合にだけ問題となる)。

 -- Function: delete* ITEM SEQ &key :TEST :TEST-NOT :KEY :COUNT :START :END :FROM-END
     これは、ITEMにマッチするSEQのすべての要素を削除する。それは破壊的
     な作用である。Emacs Lispは、伸縮可能な文字列やベクタをサポートしな
     いので、これはそれらの列型には`remove*'と同じである。リストに対し
     ては、`remove*'はオリジナルのリストを保存するために必要な場合はリ
     ストをコピーするが、`delete*'は引数リストの部分をつなぐ。`append'
     と`nconc'を比較せよ。これらは、Emacs Lisp中にある類似の非破壊的/破
     壊的リスト演算である。

述語起源の関数`remove-if'や`remove-if-not'、`delete-if'、
`delete-if-not'は同様に定義される。

 -- Function: delete ITEM LIST
     このMacLisp互換の関数は、ITEMと`equal'なすべての要素をLISTから削除
     する。`delete'関数は、Emacs 19へは組み込まれている; このパッケージ
     は、Emacs 18にそれを同等に定義する。

 -- Function: remove ITEM LIST
     この関数は、ITEMと`equal'なすべての要素をLISTから取り除く。
     `remove'はEmacs 19へは組み込まれていないが、このパッケージは
     `delete'との対称のためにそれを定義する。

 -- Function: remq ITEM LIST
     この関数は、ITEMと`eq'なすべての要素をLISTから取り除く。`remq'は
     Emacs 19へは組み込まれていないが、このパッケージは`delq'との対称の
     ためにそれを定義する。

 -- Function: remove-duplicates SEQ &key :TEST :TEST-NOT :KEY :START :END :FROM-END
     この関数は、重複要素を取り除いたSEQのコピーを戻す。つまり、列から
     の2つの要素が`:test'や`:test-not'、`:key'引数に従ってマッチする場
     合、一番右のものだけが保たれる。`:from-end'が真の場合、一番左のも
     のがその代わりに保たれる。`:start'または`:end'が指定された場合、そ
     の部分列の要素だけが調べられるか取り除かれる。

 -- Function: delete-duplicates SEQ &key :TEST :TEST-NOT :KEY :START :END :FROM-END
     この関数は、SEQから重複要素を削除する。それは
     `remove-duplicates'の破壊的版である。

 -- Function: substitute NEW OLD SEQ &key :TEST :TEST-NOT :KEY :COUNT :START :END :FROM-END
     この関数は、OLDとマッチするすべての要素をNEWと置き換えたSEQのコピー
     を戻す。`:count'や`:start'、`:end'、`:from-end'引数は、置き換えが
     行なわれる数を制限するために使われてもよい。

 -- Function: nsubstitute NEW OLD SEQ &key :TEST :TEST-NOT :KEY :COUNT :START :END :FROM-END
     これは、`substitute'の破壊的版である; それは、列の変更されたコピー
     を戻すのではなく、`setcar'や`aset'を使って置き換えを行なう。

`substitute-if'や`substitute-if-not'、`nsubstitute-if'、
`nsubstitute-if-not'関数は同様に定義される。これらのために、
PREDICATEがOLD引数の場所に与えられる。



File: cl-j, Node: 列の検索, Next: 列のソート, Prev: 列関数, Up: 列

列の検索
========

これらの関数は、列の中で要素や部分列を検索する(`member*'や
`assoc*'も参照; *Note リスト::)。

 -- Function: find ITEM SEQ &key :TEST :TEST-NOT :KEY :START :END :FROM-END
     この関数は、ITEMとマッチする要素を見つけるためにSEQを検索
     する。マッチが見つかった場合、マッチした要素を戻す。そうでなければ、
     `nil'を戻す。`:from-end'が真でない場合、一番左のマッチを戻す。
     `:from-end'が真の場合、一番右のマッチを戻す。`:start'や
     `:end'引数は、検索される要素の範囲を制限するために使用してもよい。

 -- Function: position ITEM SEQ &key :TEST :TEST-NOT :KEY :START :END :FROM-END
     この関数は`find'と似ているが、項目自身ではなく、マッチする項目の列
     の中の位置を示す整数を戻す点が異なる。`:start'が0でない場合でさえ、
     位置は全体として列の開始から相対である。マッチする要素が見つからな
     い場合、この関数は`nil'を返す。

 -- Function: count ITEM SEQ &key :TEST :TEST-NOT :KEY :START :END
     この関数は、ITEMとマッチするSEQの要素の数を戻す。結果は常に負では
     ない整数である。

`find-if'や`find-if-not'、`position-if'、`position-if-not'、`count-if'、
`count-if-not'は同様に定義される。

 -- Function: mismatch SEQ1 SEQ2 &key :TEST :TEST-NOT :KEY :START1 :END1 :START2 :END2 :FROM-END
     この関数は、SEQ1とSEQ2の指定された部分を比較する。それらが同じ長さ
     で、対応する要素が(`:test'や`:test-not'、`:key'に従って)マッチする
     場合、この関数は`nil'を戻す。ミスマッチがある場合、この関数は第1の
     ミスマッチ要素の(SEQ1に相対な)インデクスを戻す。これは、マッチしな
     い一番左の要素のペアか、2つの非マッチ列の短い方が尽きた場所である。

     `:from-end'が真の場合、要素は`(1- END1)'と`(1- END2)'から始まり右
     から左へ比較される。列が異なる場合、一番右の(SEQ1に相対な)相違のイ
     ンデクスに1を加えた値が戻される。

     興味深い例は`(mismatch str1 str2 :key 'upcase)'であり、これは大文
     字小文字を区別せずに2つの文字列を比較する。

 -- Function: search SEQ1 SEQ2 &key :TEST :TEST-NOT :KEY :FROM-END :START1 :END1 :START2 :END2
     この関数は、SEQ1(あるいは`:start1'や`:end1'で
     指定された部分)とマッチする部分列を見つけるためにSEQ2を
     検索する。`:start2'や`:end2'で定義される領域内に完全に入る
     マッチのみが考慮される。戻り値は、SEQ2の開始に相対な一番左
     マッチの一番左の要素のインデクスか、マッチが見つからない場合は
     `nil'である。`:from-end'が真の場合、この関数は
     *一番右の*マッチする部分列を見つける。



File: cl-j, Node: 列のソート, Prev: 列の検索, Up: 列

列のソート
==========

 -- Function: sort* SEQ PREDICATE &key :KEY
     この関数は、要素の対を比較するためにPREDICATEを使って決定される昇
     順にSEQをソートする。PREDICATEは、その第1引数がその第2引数より小さ
     い場合にのみ真(非`nil')を戻さなければならない。たとえば`<'や
     `string-lessp'は、それぞれ数や文字列をソートするのに適切な述語関数
     である; `>'は昇順ではなく降順で数をソートするだろう。

     この関数は、単なるリストにではなく、列のすべての型に作用できる点で、
     Emacs組み込みの`sort'と異なる。また、PREDICATE関数へ与えられるデー
     タを前処理するのに使われる、`:key'引数を受け入れる。たとえば、

          (setq data (sort data 'string-lessp :key 'downcase))

     は、大文字小文字を考慮せずにアルファベットの昇順に文字列の列DATAを
     ソートする。`car'の`:key'関数は、連想リストのソートに有用だろう。

     `sort*'関数は破壊的である; 適切な仕方で`cdr'ポインタを実際に再配列
     することで、リストをソートする。

 -- Function: stable-sort SEQ PREDICATE &key :KEY
     この関数は、SEQを"安定して"ソートする。"安定して"とは、PREDICATEに
     関して等値な2つの要素は、ソートによってその元の順序から再配列され
     ないことが保証されているという意味である。

     実際、`sort*'と`stable-sort'は、その下にある`sort'関数が既定では安
     定なので、Emacs Lispでは同等である。しかしこのパッケージは、将来
     `sort*'のために非安定な方法を使う権利を予約する。

 -- Function: merge TYPE SEQ1 SEQ2 PREDICATE &key :KEY
     この関数は、それらの要素を差しはさむことで、2つの列SEQ1とSEQ2をマー
     ジする。結果の列は、(`concatenate'の意味で) TYPEの型を持ち、2つの
     入力列の長さの和と等しい長さを持つ。列は破壊的に修正されるかもしれ
     ない。SEQ1とSEQ2内の要素の順序は、差しはさみで保存される; 2つの列
     の要素は、(`sort'の意味で) PREDICATEで比較され、より小さい要素が結
     果の先に行く。要素が等値の場合、結果ではSEQ1がSEQ2からの要素よりも
     先にくる。従って、SEQ1とSEQ2がともにPREDICATEに従ってソートされる
     場合、結果はPREDICATEに従って(安定に)ソートされたマージ列だろう。



File: cl-j, Node: リスト, Next: ハッシュ表, Prev: 列, Up: Top

リスト
******

ここに記述される関数はリストに作用する。

* Menu:

* リスト関数::
* 式の置き換え::
* 集合としてのリスト::
* 連想リスト::



File: cl-j, Node: リスト関数, Next: 式の置き換え, Prev: リスト, Up: リスト

リスト関数
==========

この節は、リスト上、すなわちコンスセルの連鎖上のかなりの数の単純な演算
を記述する。

 -- Function: caddr X
     この関数は、`(car (cdr (cdr X)))'と同等である。同様にこのパッケー
     ジは、XXXが4つまでの`a'および/または`d'である、28個の`cXXXr'関数す
     べてを定義する。これらの関数はすべて`setf'可能であり、それらへの呼
     び出しは、最大の効率のためにバイトコンパイラでインラインに展開され
     る。

 -- Function: first X
     この関数は、`(car X)'の同義語である。同様に、関数`second'、
     `third'、...、`tenth'はリストXの与えられた要素を戻す。

 -- Function: rest X
     この関数は、`(cdr X)'の同義語である。

 -- Function: endp X
     Common Lispは、この関数は`null'と同様に動作するが、`x'が`nil'でも
     コンスセルでもない場合はエラーを通知するように定義する。このパッケー
     ジは、単に`null'の同義語として`endp'を定義する。

 -- Function: list-length X
     この関数は、`(length X)'と正確に同じようにリストXの長さを戻すが、
     Xが循環リスト(cdr連鎖が`nil'で終端するのではなくループを形成する)
     の場合、この関数は`nil'を戻す(正規の`length'関数は、循環リストを与
     えられた場合、はまりこんで動けなくなるだろう)。

 -- Function: last* X &option(付加)al N
     この関数は、リストXの最後のコンスか、最後からN番目のコンス
     を戻す。Nが省略された場合、1を既定とする。"最後のコンス"は、
     その`cdr'が別のコンスセルではない、リストの最初のコンスセルを
     意味する(通常のリストでは、最後のコンスの`cdr'は`nil'
     である)。Xが`nil'またはNよりも短い場合、この関数は
     `nil'を戻す。リストの最後の*要素*は、
     `(car (last X))'であることに注意せよ。

     Emacs関数`last'は、付加引数Nを扱わないことを除いて同じことをする。

 -- Function: butlast X &optional N
     この関数は、最後の要素、または最後のN個の要素を取り除いたリスト
     Xを戻す。Nが0より大きい場合、オリジナルのリストに損害を
     与えないように、リストのコピーを作る。一般に、
     `(append (butlast X N) (last X N))'は、
     Xと等値なリストを戻す。

 -- Function: nbutlast X &optional N
     これは、リストのコピーを作るのではなく、適切な要素の`cdr'を破壊的
     に修正することで動作する`butlast'の版である。

 -- Function: list* ARG &rest OTHERS
     この関数は、その引数のリストを構成する。最後の引数は、構成される最
     後のセルの`cdr'になる。従って、`(list* A B C)'は`(cons A (cons B
     C))'と同等であり、`(list* A B nil)'は`(list A B)'と同等である。

     (この関数は、Common Lispで実際に`list*'と呼ばれることに注意せよ;
     `member*'や`defun*'のように、このパッケージのために発明された名前
     ではない)

 -- Function: ldiff LIST SUBLIST
     SUBLISTがLISTの副リストの場合、すなわち、LISTの
     コンスセルの1つと`eq'の場合、この関数は、SUBLISTまでで
     SUBLISTは含まないLISTの部分のコピーを戻す。たとえば、
     `(ldiff x (cddr x))'はリスト`x'の最初の2つの要素を戻す。結果
     はコピーである; オリジナルのLISTは修正されない。SUBLISTが
     LISTの副リストでない場合、LIST全体のコピーが戻される。

 -- Function: copy-list LIST
     この関数は、リストLISTのコピーを戻す。それは、`(1 2 . 3)'のような
     ドットリストを正しくコピーする。

 -- Function: copy-tree X &optional VECP
     この関数は、コンスセルXの木のコピーを戻す。`cdr'方向沿いにだけコピー
     する`copy-sequence'(やその別名である`copy-list')とは異なり、この関
     数は`car'と`cdr'の両方の方向に沿って(再帰的に)コピーする。Xがコン
     スセルではない場合、単にXを変えずに戻す。付加的なVECP引数が真の場
     合、この関数はコンスセルと同じように(再帰的に)ベクタをコピーする。

 -- Function: tree-equal X Y &key :TEST :TEST-NOT :KEY
     この関数は、コンスセルの2つの木を比較する。XとYがともにコンスセル
     の場合、それらの`car'と`cdr'が再帰的に比較される。XもYもコンスセル
     ではない場合、`eql'か指定されたテストに従って比較される。`:key'関
     数が指定された場合、両方の木の要素に適用される。*Note 列::.




File: cl-j, Node: 式の置き換え, Next: 集合としてのリスト, Prev: リスト関数, Up: リスト

式の置き換え
============

これらの関数は、コンスセルの木全体で要素を置き換える。(リストの
トップレベルの要素だけに作用する`substitute'関数に関しては、
*Note 列関数::.)

 -- Function: subst NEW OLD TREE &key :TEST :TEST-NOT :KEY
     この関数は、コンスセルの木であるTREEの中の、OLDの出現をNEWで置き換
     える。置き換えられた木を戻す。木は、置き換えが起こらなかった部分は
     引数TREEと記憶域を共有するかもしれない点は除いて、コピーである。オ
     リジナルのTREEは修正されない。この関数は、構成要素のコンスセルの
     `car'と`cdr'両方に再帰し、OLDに対して比較する。OLD自身がコンスセル
     の場合、木の中のマッチするセルは、そのセル中は再帰的に置き換えられ
     ることなしに、通常通り置き換えられる。OLDとの比較は、指定されたテ
     スト(既定では`eql')に従ってなされる。`:key'関数は、木の要素に適用
     されるが、OLDには適用されない。

 -- Function: nsubst NEW OLD TREE &key :TEST :TEST-NOT :KEY
     この関数は`subst'と似ているが、コピーするのではなく(`setcar'または
     `setcdr'で)破壊的に修正することで動作する点が異なる。

`subst-if'や`subst-if-not'、`nsubst-if'、
`nsubst-if-not'関数は同様に定義される。

 -- Function: sublis ALIST TREE &key :TEST :TEST-NOT :KEY
     この関数は`subst'と似ているが、OLDとNEWの対の連想リストを取る点が
     異なる。木の各要素は、(`:key'関数がある場合はそれを適用後)ALISTの
     `car'と比較される; マッチする場合、対応する`cdr'で置き換えられる。

 -- Function: nsublis ALIST TREE &key :TEST :TEST-NOT :KEY
     これは`sublis'の破壊版である。



File: cl-j, Node: 集合としてのリスト, Next: 連想リスト, Prev: 式の置き換え, Up: リスト

集合としてのリスト
==================

これらの関数は、要素の集合を表現するリストに作用する。

 -- Function: member ITEM LIST
     このMacLisp互換の関数は、ITEMと`equal'である要素を見つけるために
     LISTを検索する。`member'関数はEmacs 19へ組み込まれている; このパッ
     ケージは、Emacs 18に同等にそれを定義する。Common Lisp互換版の下記
     の関数を参照せよ。

 -- Function: member* ITEM LIST &key :TEST :TEST-NOT :KEY
     この関数は、ITEMとマッチする要素を見つけるためにLISTを
     検索する。マッチが見つかった場合、その`car'がマッチする要素である
     コンスセルを戻す。さもなければ`nil'を戻す。要素は、既定では
     `eql'で比較される; この振る舞いを修正するために、`:test'や
     `:test-not'、`:key'引数を使ってもよい。*Note 列::.

     この関数の名前は、Emacs 19に定義されている非互換な`member'関数を
     避けるために、`*'で接尾辞づけられていることに注意せよ(その関数は
     比較に`equal'を使う; それは
     `(member* ITEM LIST :test 'equal)'と同等である)。

`member-if'と`member-if-not'関数は同様に、与えられた述語を満たす要素を
検索する。

 -- Function: tailp SUBLIST LIST
     この関数は、SUBLISTがLISTの副リスト、すなわちSUBLIST
     がLISTまたはその`cdr'のいずれかと`eql'である場合に、
     `t'を戻す。

 -- Function: adjoin ITEM LIST &key :TEST :TEST-NOT :KEY
     この関数は、ITEMがそのリストにまだ存在しない場合(`member*'によって
     決定される)にだけ、`(cons ITEM LIST)'のように、LISTの先頭にITEMを
     コンスする。`:key'引数が指定された場合、ITEMがリストの一部に"なろ
     うとしている"のを推理するために、検索の間にLISTの要素と同様にITEM
     に適用される。

 -- Function: union LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     この関数は、項目の集合を表現する2つのリストを結合し、それらの2つの
     集合の和集合を表現するリストを戻す。結果のリストは、LIST1または
     LIST2に現れるすべての項目を含み、それ以外は含まない。要素がLIST1と
     LIST2にともに現れる場合、それは1度だけコピーされる。項目がLIST1ま
     たはLIST2中で重複している場合、その重複が結果のリストに生き残るか
     どうかは未定義である。結果のリスト中の要素の順序も未定義である。

 -- Function: nunion LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     これは`union'の破壊版である; コピーするのではなく、可能ならば引数
     リストの記憶域を再利用しようと試みる。

 -- Function: intersection LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     この関数は、LIST1とLIST2で表現される集合の積集合を計算する。それは、
     LIST1とLIST2にともに現れる項目のリストを戻す。

 -- Function: nintersection LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     これは`intersection'の破壊版である。コピーするのではなく、LIST1の
     記憶域を再利用しようと試みる。LIST2の記憶域は再利用し*ない*。

 -- Function: set-difference LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     この関数は、LIST1とLIST2の"差集合"、すなわちLIST1に現れるがLIST2に
     は現れ*ない*要素の集合を計算する。

 -- Function: nset-difference LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     これは破壊的な`set-difference'であり、可能ならLIST1を再利用しよう
     とする。

 -- Function: set-exclusive-or LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     この関数は、LIST1とLIST2の"排他的論理和集合"、すなわち
     LIST1とLIST2の正確に1つだけ現れる要素の集合を計算する。

 -- Function: nset-exclusive-or LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     これは破壊的な`set-exclusive-or'であり、可能ならLIST1と
     LIST2を再利用しようとする。

 -- Function: subsetp LIST1 LIST2 &key :TEST :TEST-NOT :KEY
     この関数は、LIST1がLIST2の部分集合を表現しているかどうか、すなわち
     LIST1の各要素がLIST2にも現れるかどうかをチェックする。



File: cl-j, Node: 連想リスト, Prev: 集合としてのリスト, Up: リスト

連想リスト
==========

"連想リスト"は、値の1つの集合から他の集合への写像を表現するリストである;
その要素がコンスセルであるすべてのリストは連想リストである。

 -- Function: assoc* ITEM A-LIST &key :TEST :TEST-NOT :KEY
     この関数は、その`car'が与えられたITEMと(`:test'や`:test-not'、
     `:key'の意味で、または`eql'での比較で)マッチする要素を見つけるため
     に、連想リストA-LISTを検索する。マッチする要素がある場合はそれを、
     さもなければ`nil'を戻す。コンスセルではないA-LISTの要素は無視する
     (これは、Emacs Lispでの`assq'や`assoc'の振る舞いに対応する;
     Common Lispの`assoc'は`nil'を無視するが、A-LISTのそれ以外の非コン
     ス要素はエラーとみなす)。

 -- Function: rassoc* ITEM A-LIST &key :TEST :TEST-NOT :KEY
     この関数は、その`cdr'がITEMとマッチする要素を検索する。
     A-LISTが写像を表現する場合、これはITEMへ逆写像を適用する。

 -- Function: rassoc ITEM A-LIST
     この関数は、`equal'の`:test'引数を持つ`rassoc*'のように検索する。
     それは、Emacs Lispの標準の`assoc'関数と類似している。Emacs Lisp標
     準`assoc'関数はCommon Lispの伝統よりもMacLispに由来する。

`assoc-if'や`assoc-if-not'、`rassoc-if'、
`rassoc-if-not'関数は同様に定義される。

連想リストを構築する2つの単純な関数は:

 -- Function: acons KEY VALUE ALIST
     これは`(cons (cons KEY VALUE) ALIST)'と同等である。

 -- Function: pairlis KEYS VALUES &optional ALIST
     これは`(nconc (mapcar* 'cons KEYS VALUES) ALIST)'と同等である。



File: cl-j, Node: ハッシュ表, Next: 構造体, Prev: リスト, Up: Top

ハッシュ表
**********

"ハッシュ表"は、"値"に"キー"をマップするデータ構造である。キーと値は任
意のLispデータオブジェクトであってよい。ハッシュ表は、与えられたキーを
検索する時間がほぼ一定だという特性を持つ; より単純な連想リストのような
データ構造は、リスト中のエントリ数に比例する時間がかかる。

 -- Function: make-hash-table &key :TEST :SIZE
     この関数は、その要素比較用の関数が`:test'(既定では`eql')であり、お
     よそ`:size'の要素に合うように割り当てられたハッシュ表オブジェクト
     を作成して戻す。`:size'引数は、単に助言を与えるものである; より多
     くの要素を格納する場合、表は自動的に大きくなる。`:size'が省略され
     た場合、手頃な既定値が使われる。

     Common Lispは、`eq'と`eql'、`equal'、`equalp'だけを`:test'引数の正
     しい値として許す。このパッケージでは、すべての適当な述語関数が動作
     するが、何か他のものを使う場合、あなたの述語に適切なことを確実にす
     るために、以下に記述するハッシュ関数の詳細をチェックすべきである。

     (Lucid Emacs 19のような)Emacsのある版は、組み込みのハッシュ表型を
     含む; これらの版では、`eq'のテストを伴う`make-hash-table'がこれら
     の組み込みのハッシュ表を使う。他のすべての場合では、先頭に識別用の
     タグ"シンボルを伴うリストのフォームを取るハッシュテーブルオブジェ
     クトを戻す。このパッケージのすべてのハッシュ表関数は、両方のハッシュ
     表の型に作用できる; 通常は、どちらの型が使われているかを知ることは
     決してないだろう。

     この関数は、付加的なCommon Lispキーワード`:rehash-size'と
     `:rehash-threshold'を受け入れるが、その値は無視する。

 -- Function: gethash KEY TABLE &optional DEFAULT
     この関数は、TABLEの中でKEYを調べる。もし、表のテスト関数に
     従って、存在するキーのいずれかにマッチするという意味で、KEYが
     表に存在する場合、関連づけられた値が戻される。そうでなければ、
     DEFAULT(または`nil')が戻される。

     ハッシュ表に新しいデータを格納するためには、`gethash'への
     呼び出しに`setf'を使う。KEYがすでに表に存在する場合、
     対応する値は格納する値へ変更される。KEYがまだ存在しない場合、
     新たなエントリが表へ加えられ、必要ならば表はより大きなサイズへ
     再割り当てされる。DEFAULT引数は許されるが、この場合は
     無視される。この状況は、`get*'のそれと正確に同じである;
     *Note 属性リスト::.

 -- Function: remhash KEY TABLE
     この関数は、TABLEからKEYのためのエントリを取り除く。エントリが取り
     除かれた場合、`t'を戻す。KEYがテーブルに現れない場合、何も行なわず
     `nil'を戻す。

 -- Function: clrhash TABLE
     この関数は、TABLEからすべてのエントリを取り除き、空のハッシュ表の
     ままにしておく。

 -- Function: maphash FUNCTION TABLE
     この関数は、TABLEの各エントリに対してFUNCTIONを呼び出す。それは
     FUNCTIONへ2つの引数、与えられたエントリのキーと値を渡す。FUNCTION
     の戻り値は無視される; MAPHASH自身は`nil'を戻す。ハッシュ表上で繰り
     返す代替の方法は、*Note ループ機能::.

 -- Function: hash-table-count TABLE
     この関数は、TABLE内のエントリ数を戻す。*警告:* Lucid
     Emacs 19のハッシュ表の現在の実装は、`remhash'がエントリを
     取り除いたときに、格納された`count'を減らさない。従ってこの関数の
     戻り値は、表で`remhash'を使い、かつ表のテストが`eq'の場合、
     信頼できない。エントリを数えるためのより遅いけれども信頼できる方法は、
     `(loop for x being the hash-keys of TABLE count t)'である。

 -- Function: hash-table-p OBJECT
     この関数は、OBJECTがハッシュ表の場合に`t'を、さもなければ`nil'を戻
     す。これはハッシュ表の両方の型(Lucid Emacs組み込みの表と特殊なリス
     トで実装された表の両方)を認識する。

ハッシュ表を扱うときには、使われる"ハッシュ関数"を正確に知ることが有用
である場合がある。このパッケージは、Emacs Lispの"obarray"を使ってハッシュ
表を実装する。"obarray"は、Emacs Lispがシンボルの後をたどるために使うの
と同じデータ構造である。それぞれのハッシュ表は、埋め込まれたobarrayを含
む。`gethash'へ与えられるキーの値は、さまざまな手段で文字列へ変換され、
それから`intern'や`intern-soft'を使ってobarrayの中を調べられる。与えら
れたキー文字列に対応するシンボルまたは"bucket"は、その`symbol-value'と
して、その文字列へハッシュしたすべてのキーと値の対の連想リストを含む。
テスト関数によっては、多くのエントリを同じbucketへハッシュすることも可
能である。たとえばテストが`eql'の場合、シンボル`foo'と2つの別々に組み立
てられた文字列`"foo"'は、同じbucketに3つのエントリを作るだろう。検索時
間はbucket内で線形なので、あまりに多くのものを同じハッシュに格納しない
ように準備する場合に、ハッシュ表は最も効果的だろう。

下記のアルゴリズムが、Lispオブジェクトをハッシュ文字列へ変換するために
使われる:

   * 文字列は、直接ハッシュ文字列として使われる(しかしテスト関数が
     `equalp'の場合、文字列はまず`downcase'される)。

   * シンボルは、その`symbol-name'にしたがってハッシュされる。

   * 整数は、その値を16で割った余りによって、16のbucketの1つにハッシュ
     される。浮動小数点数は、整数に切り捨てられて、16で割った余りによっ
     てハッシュされる。

   * コンスセルは、その`car'にしたがってハッシュされる; 空ではないベク
     タは、その第1要素にしたがってハッシュされる。

   * すべての他のオブジェクトの型は、`"*"'と名付けられた1つのbucketへハッ
     シュする。

したがって、たとえばハッシュ表の中の多くのバッファオブジェクトを検索す
ることは、1つのbucketを通した(なおかなり速い)線形時間の検索へ帰するだろ
う。ところが、異なったシンボルを検索することは、各シンボルは一般にはそ
れ自身のbucketへハッシュするので、とても速いだろう。

ハッシュテーブルの中のobarrayの大きさは、要素の数が増えるにつれて自動的
に調節される。

特別な場合として、0または1の`:size'引数を伴う`make-hash-table'は、多く
のリストのobarrayではなく、1つの連想リストを使うハッシュ表オブジェクト
を作る。とても小さい表のためには、調査がキーから文字列への変換または
obarrayの中の調査を必要としないので、この構造はより効率的である。しかし
このような表は、検索をするためにはその大きさに比例する時間がかかること
が保証される。




File: cl-j, Node: 構造体, Next: アサーション, Prev: ハッシュ表, Up: Top

構造体
******

Common Lispの"構造体"メカニズムは、Cの`struct'型に類似するデータ型を定
義する一般的な方法を提供する。構造体は、いくつかの数の"スロット"を含む
Lispオブジェクトであり、スロットのそれぞれは任意のLispデータオブジェク
トを保持できる。スロットのアクセスや設定、構造体オブジェクトの作成やコ
ピー、ある特定の構造体の型のオブジェクトを認識する関数が提供される。

真のCommon Lispでは、それぞれの構造体型は、すべての存在するLisp型とは別
の新しい型である。下にあるEmacs Lispシステムは、新しい別の型を作る方法
を提供しないので、このパッケージは、識別するための特殊な"タグ"シンボル
を伴うベクタ(要求によってはリスト)として構造体を実装する。

 -- Special form: defstruct NAME SLOTS...
     `defstruct'フォームは、NAMEと呼ばれる、指定されたSLOTSを持つ新しい
     構造体型を定義する(SLOTSは構造体型を記述する文字列で始まってもよ
     い)。単純な場合、NAMEやSLOTSのそれぞれはシンボルである。たとえば、

          (defstruct person name age sex)

     は、3つのスロットを含む、`person'と呼ばれる構造体型を定義する。
     `person'オブジェクトPが与えられると、`(person-name P)'や
     `(person-age P)'、`(person-sex P)'を呼ぶことでそれらのスロットにア
     クセスできる。これらのすべてのplaceフォームで`setf'を使うことで、
     これらのスロットを変更することもできる:

          (incf (person-age birthday-boy))

     `make-person'を呼び出すことで、新しい`person'を作ることができる。
     `make-person'は、新しいオブジェクトのスロットの初期値を指定するた
     めに、キーワード引数`:name'と`:age'、`:sex'を取る(これらの引数のい
     ずれかを省略すると、Common Lisp標準によれば、対応するスロットは"未
     定義"のままである; Emacs Lispでは、このような初期化されていないス
     ロットは`nil'で埋められる)。

     `person'が与えられると、`(copy-person P)'は、そのスロットがPのそれ
     と`eq'である同じ型の新しいオブジェクトを作る。

     任意のLispオブジェクトXが与えられると、`(person-p X)'はXが
     `person'のように見える場合は真を、さもなければ偽を戻す(再び、
     Common Lispではこの述語は正確だろう; Emacs Lispでできる最善のこと
     は、Xが正しいタグシンボルで始まる正しい長さのベクタであることを確
     かめることである)。

     `person-name'のようなアクセサは、通常は(実際に`person-p'を
     使って)それらの引数をチェックし、引数が不正な型の場合はエラーを
     通知する。このチェックは、`(optimize (safety ...))'
     宣言によって影響される。既定のSafetyレベル1は、すべての不正な引数を
     見つける、いくぶん最適化されたチェックを使うが、無益な
     エラーメッセージを使うかもしれない(たとえば、
     "expected a `person'"ではなく"expected a vector"のように)。
     Safetyレベル0は、下にある`aref'呼び出しによって提供されるものを
     除いて、すべてのチェックを省略する; Safetyレベル2と3は、不正な入力に
     対して常に記述的なエラーメッセージを印字する、厳しいチェックを行なう。
     *Note 宣言::.

          (setq dave (make-person :name "Dave" :sex 'male))
               => [cl-struct-person "Dave" nil male]
          (setq other (copy-person dave))
               => [cl-struct-person "Dave" nil male]
          (eq dave other)
               => nil
          (eq (person-name dave) (person-name other))
               => t
          (person-p dave)
               => t
          (person-p [1 2 3 4])
               => nil
          (person-p "Bogus")
               => nil
          (person-p '[cl-struct-person counterfeit person object])
               => t

     一般に、NAMEは名前のシンボルか、名前のシンボルの後に任意の数の"構
     造体オプション"が続くリストである; それぞれのSLOTは、スロットシン
     ボルか、フォーム`(SLOT-NAME DEFAULT-VALUE SLOT-OPTIONS...)' のリス
     トである。DEFAULT-VALUEは、スロットの値を指定せずに構造体型のイン
     スタンスが作られるすべてのときに評価されるLispフォームである。

     Common Lispは、いくつかのスロットオプションを定義しているが、この
     パッケージで実装されている唯一のものは`:read-only'である。このオプ
     ションに対する非`nil'の値は、そのスロットは`setf'可能であってはな
     らないということを意味する; スロットの値は、オブジェクトが作られた
     ときに決定され、その後は変わらない。

          (defstruct person
            (name nil :read-only t)
            age
            (sex 'unknown))

     `:read-only'以外のすべてのスロットオプションは無視される。

     不明瞭な歴史的な理由のため、構造体オプションはスロットオプションと
     異なるフォームを取る。構造体オプションは、キーワードシンボルか、キー
     ワードシンボルで始まり、ことによると引数が続くリストである(対称的
     に、スロットオプションはリストで囲まれないキーと値の対である)。

          (defstruct (person (:constructor create-person)
                             (:type list)
                             :named)
            name age sex)

     下記の構造体オプションが認められる。

     `:conc-name'
          引数は、その印字名がスロットアクセサ関数の名前のために接頭辞
          として使われるシンボルである。既定は、構造体型の名前にハイフ
          ンが続いたものである。オプション`(:conc-name p-)'は、この接頭
          辞を`p-'に変える。引数として`nil'を指定することは接頭辞なしを
          意味するので、スロット名自身がアクセサ関数を名付けるために使
          われる。

     `:constructor'
          単純な場合、このオプションは、コンストラクタ関数のために使わ
          れる代替の名前である1つの引数を取る。既定は、たとえば
          `make-person'のように`make-NAME'である。上記の例は、これを
          `create-person'に変える。引数として`nil'を指定することは、標
          準のコンストラクタはまったく生成されないことを意味する。

          このオプションの完全なフォームでは、コンストラクタ名には任意
          の引数リストが続く。Common Lisp引数リストのフォーマットの記述
          は、*Note プログラム構造::.  `&rest'や`&key'のようなすべての
          オプションがサポートされる。引数名はスロット名とマッチすべき
          である;それぞれのスロットは、対応する引数で初期化される。その
          名前が引数リストに現れないスロットは、スロット記述子の
          DEFAULT-VALUEに基づいて初期化される。また、既定を指定しない
          `&optional'と`&key'引数は、スロット記述子からその既定を取る。
          スロット名に対応しない引数を含むことは正しい; スロットに対応
          *する*付加引数やキーワード引数、`&aux'引数のための既定で参照
          される場合、それらは有用である。

          1つの構造体に、完全なフォーマットの`:constructor'オプションを
          いくつでも指定できる。単純フォーマットの`:constructor'オプショ
          ンで無効にしない限り、既定のコンストラクタも同様に生成される。

               (defstruct
                (person
                 (:constructor nil)   ; no default constructor
                 (:constructor new-person (name sex &optional (age 0)))
                 (:constructor new-hound (&key (name "Rover")
                                               (dog-years 0)
                                          &aux (age (* 7 dog-years))
                                               (sex 'canine))))
                name age sex)

          ここでの第1のコンストラクタは、キーワードによってではなく、位置でその
          引数を取る(公式なCommon Lispの用語では、キーワードの代わりに引数の順序
          によって働くコンストラクタは、"BOAコンストラクタ"と呼ばれる。いや、
          私がこれをでっちあげているのではない)。たとえば、
          `(new-person "Jane" 'female)'は、そのスロットがそれぞれ
          `"Jane"'と0、`female'であるpersonを生成する。

          第2のコンストラクタは、2つのキーワード引数を取る。`:name'は、
          `name'スロットを初期化し、`"Rover"'を既定とする。
          `:dog-years'は、それ自身があるスロットに対応するのではないが、
          `age'スロットを初期化するために使われる。`sex'スロットは、強
          制的にシンボル`canine'になり、それを無効にする文法を持たない。

     `:copier'
          引数は、この方のコピー関数の代替名である。既定は`copy-NAME'で
          ある。`nil'はコピー関数を生成しないことを意味する(この実装で
          は、すべてのコピー関数は、単に`copy-sequence'の同義語である)。

     `:predicate'
          引数は、この型のオブジェクトを認識する述語の代替名である。既
          定は`NAME-p'である。`nil'は述語関数を生成しないことを意味する
          (`:type'オプションが、`:named'オプションなしで使われる場合、
          述語は決して生成されない)。

          真のCommon Lispでは、`:predicate'が使われても、`typep'は常に
          構造体オブジェクトを認識できる。このパッケージでは、`typep'は
          単に`TYPENAME-p'と呼ばれる関数を探すので、既定の述語名を使う
          場合だけ構造体型に対して動作するだろう。

     `:include'
          このオプションは、とても制限されたC++スタイルの継承の形式を実
          装する。引数は、前もって`defstruct'で作られた別の構造体型の名
          前である。その効果は、新しい構造体型が、含められた構造体型の
          すべてのスロット(加えて、もちろんこの構造体のスロット記述子で
          記述されたすべての新しいスロットも)を受け継ぐようにすることで
          ある。新しい構造体は、含められた構造体の"特殊化"と考えられる。
          事実、含められた型の述語やスロットアクセサは、新しい型のオブ
          ジェクトも受け入れる。

          含められた構造体名の後に、`:include'オプションへ余分の引数が
          ある場合、これらのオプションは、含められた構造体のスロットの
          ための、ことによると修正された既定値を伴うスロット記述子の置
          き換えとして扱われる。Steeleから例を借りると:

               (defstruct person name (age 0) sex)
                    => person
               (defstruct (astronaut (:include person (age 45)))
                 helmet-size
                 (favorite-beverage 'tang))
                    => astronaut

               (setq joe (make-person :name "Joe"))
                    => [cl-struct-person "Joe" 0 nil]
               (setq buzz (make-astronaut :name "Buzz"))
                    => [cl-struct-astronaut "Buzz" 45 nil nil tang]

               (list (person-p joe) (person-p buzz))
                    => (t t)
               (list (astronaut-p joe) (astronaut-p buzz))
                    => (nil t)

               (person-name buzz)
                    => "Buzz"
               (astronaut-name joe)
                    => error: "astronaut-name accessing a non-astronaut"

          したがって、`astronaut'が`person'の特殊化である場合、すべての
          `astronaut'は`person'でもある(しかし逆は真ではない)。すべての
          `astronaut'は、`person'のすべてのスロットを含み、加えて
          astronautに特有の特別なスロットを持つ。(`person-name'のような)
          people上で働く作用は、ちょうど他のpeopleのようにastronaut上で
          働く。

     `:print-function'
          完全なCommon Lispでは、このオプションは、構造体型のインスタン
          スを印字するために呼び出される関数を指定することを許す。
          Emacs Lispシステムは、Lispプリンタ中にこのような機能を許すフッ
          クを提供しないため、このパッケージは単に`:print-function'を無
          視する。

     `:type'
          引数は、シンボル`vector'または`list'のどちらかでなければなら
          ない。これは、新しい構造体型を実装するために、どちらの基礎と
          なるLispデータ型が使われるべきかを語る。ベクタが既定で使われ
          るが、`(:type list)'は、その代わりに構造体オブジェクトがリス
          トとして格納されることを引き起こす。

          構造体オブジェクト用にベクタ表現を使うことは、Emacs Lispでは
          ベクタを作ることはやや遅いとはいえ、すべての構造体スロットが
          素早くアクセスできるという有利な点を持つ。リストは作りやすい
          が、後の方のスロットをアクセスするのに比較的長い時間がかかる。

     `:named'
          この引数を取らないオプションは、特有の"タグ"シンボルが構造体
          オブジェクトの先頭に格納されることを引き起こす。`:type'を使い、
          かつ`:named'を使わないことは、構造体型が識別機能を持たない単
          なるベクタまたはリストとして格納される結果になる。

          `:type'を明示的に指定しない場合、既定は名前付きベクタを使うこ
          とである。したがって、`:named'は`:type'との結合にのみ有用であ
          る。

               (defstruct (person1) name age sex)
               (defstruct (person2 (:type list) :named) name age sex)
               (defstruct (person3 (:type list)) name age sex)

               (setq p1 (make-person1))
                    => [cl-struct-person1 nil nil nil]
               (setq p2 (make-person2))
                    => (person2 nil nil nil)
               (setq p3 (make-person3))
                    => (nil nil nil)

               (person1-p p1)
                    => t
               (person2-p p2)
                    => t
               (person3-p p3)
                    => error: function person3-p undefined

          名前のない構造体はタグを持たないので、`defstruct'は、それを認
          識するために有用な述語を作ることができない。また、
          `person3-name'のようなアクセサは生成されるが、どんな型チェッ
          クもできないだろう。たとえば`person3-name'関数は、この場合は
          単に`car'の同義語である。対称的に、`person2-name'は処理の前に、
          その引数が実際に`person2'オブジェクトであるかを確かめることが
          できる。

     `:initial-offset'
          引数は非負の整数でなければならない。それは、構造体の先頭で"空
          のままにしておくスロット数を指定する。構造体が名前付きの場合、
          タグがリストまたはベクタの指定された位置に現れる; さもなけれ
          ば、第1のスロットがその位置に現れる。より早い位置は、コンスト
          ラクタによって`nil'で満たされ、それ以外は無視される。型が他の
          型を`:include'する場合、`:initial-offset'は、含まれる型の最後
          のスロットと最初の新しいスロットの間のスキップされるスロット
          数を指定する。

注記されている場合を除いて、このパッケージの`defstruct'機能はCommon
Lispのそれと完全に互換である。




File: cl-j, Node: アサーション, Next: 効率の配慮, Prev: 構造体, Up: Top

アサーションとエラー
********************

この節は"アサーション"、すなわちプログラムが正しく働いている場合に真で
なければならない条件をテストする2つのマクロを記述する。アサーションは、
Lispプログラムの振る舞いに決して何も追加しない;すべてがそうあるべきであ
るように、単に"正気のチェック"をするだけである。

最適化属性`speed'が3にセットされており、`safety'が3より小さい場合、バイ
トコンパイラは、下記のアサーションを最適化し去る。アサーションは最適化
し去られるかもしれないので、それらが副作用を含むことは悪い考えである。

 -- Special form: assert TEST-FORM [SHOW-ARGS STRING ARGS...]
     このフォームは、TEST-FORMが真である(すなわち評価して非`nil'値にな
     る)ことを確かめる。そうである場合、`nil'を戻す。テストが満足されな
     い場合、`assert'はエラーを通知する。

     TEST-FORMを含む既定のエラーメッセージが得られる。STRING引数と付加
     的な余分の引数を含むことで、異なるエラーメッセージを指定できる。こ
     れらの引数は、エラーを通知するために単に`error'へ渡される。

     付加的な第2の引数SHOW-ARGSが`nil'ではなく`t'である場合、
     エラーメッセージは(STRINGがあってもなくても)、トップレベル
     FORMのあらゆる非定数引数を含む。たとえば:

          (assert (> x 10) t "x is too small: %d")

     このSHOW-ARGSの使用法は、Common Lispへの拡張である。真のCommon
     Lispでは、第2引数は、エラーからの継続の前にユーザーによって`setf'
     可能なPLACESのリストを与える。Emacs Lispは継続可能なエラーをサポー
     トしないので、PLACESを指定することは意味がない。

 -- Special form: check-type FORM TYPE [STRING]
     このフォームは、FORMは評価して型TYPEの値になるかを確かめる。そうで
     ある場合、`nil'を戻す。そうでない場合、`check-type'は
     `wrong-type-argument'エラーを通知する。既定のエラーメッセージは、
     TYPEとFORM自身に加えて、誤った値をリストする。STRINGが指定される場
     合、それはエラーメッセージのTYPEの場所へ含められる。たとえば:

          (check-type x (integer 1 *) "a positive integer")

     TYPEに使われてよい型指定子の記述は、*Note データ型の述語::.

     Common Lispでは、`check-type'への第1引数は`setf'での使用に適切な
     PLACEでなければならないことに注意せよ。なぜなら`check-type'は、ユー
     ザがPLACEを修正することを許す継続可能なエラーを通知するからである。

下記のエラー関連マクロも定義される:

 -- Special form: ignore-errors FORMS...
     これは、正確に`progn'のようにFORMSを実行するが、FORMS
     の間はエラーが無視される点が異なる。より正確には、エラーが通知された
     場合、`ignore-errors'は直ちにFORMSの実行を中止して`nil'
     を戻す。FORMSが正常に終了する場合、`ignore-errors'は最後の
     FORMの結果を戻す。



File: cl-j, Node: 効率の配慮, Next: Common Lispとの互換性, Prev: アサーション, Up: Top

効率の配慮
**********


マクロ
======

`defun*'や`loop'、`setf'のようなこのパッケージの高度な機能の多くは、
Lispマクロとして実装されている。バイトコンパイルされたコードでは、これ
らの複雑な表記法は単純で効率のよい同等のLispコードに展開される。たとえ
ば、フォーム

     (incf i n)
     (push x (car p))

は、コンパイル時に下記のLispフォームへ展開される:

     (setq i (+ i n))
     (setcar p (cons x (car p)))

これらは、Lispでそれぞれの作用を行なう最も効率的な方法である。したがっ
て、コンパイルされたコードの中では、より読みやすい`incf'や`push'フォー
ムを使うことに性能上の不利益はない。

他方、*インタプリトされた*コードは、実行されるたびにこれらのマクロを展
開しなければならない。この理由により、マクロを猛烈に使うコードはコンパ
イルされることが強く推奨される(このマニュアルで"関数"ではなく"特殊フォー
ム"とラベルを付けられている機能はマクロである)。`incf'を100回使うループ
は、コンパイルされた場合はかなり速く実行し、マクロ展開が100回生成され、
使用され、捨て去られる必要がないので、ガベジコレクションもより少なくな
るだろう。

`cl-prettyexpand'関数を使うことで、どのようにマクロが展開するかを知るこ
とができる。

 -- Function: cl-prettyexpand FORM &optional FULL
     この関数は、引数として1つのLispフォームを取り、現バッファ(字下げが
     適正に働くようにLispモードでなければならない)にきちんとフォーマッ
     トされたそのコピーを挿入する。フォーム中に現れるすべてのLispマクロ
     も展開する。この関数を使う最も容易な方法は、`*scratch*'バッファへ
     行き、たとえば以下をタイプして、

          (cl-prettyexpand '(loop for x below 10 collect x))

     閉じ括弧の直後で`C-x C-e'をタイプすることである; 展開

          (block nil
            (let* ((x 0)
                   (G1004 nil))
              (while (< x 10)
                (setq G1004 (cons x G1004))
                (setq x (+ x 1)))
              (nreverse G1004)))

     がバッファへ挿入されるだろう(`block'マクロはインタプリタとコンパイ
     ラで異なって展開されるので、`cl-prettyexpand'はそれをそのままにし
     ている。一時変数`G1004'は`gensym'によって作られた)。

     付加引数FULLが真の場合、`block'や`eval-when'、コンパイラマクロを含
     む*すべての*マクロが展開される。展開は、FORMがコンパイルされるファ
     イル中のトップレベルフォームであるかのようになされる。たとえば、

          (cl-prettyexpand '(pushnew 'x list))
               -| (setq list (adjoin 'x list))
          (cl-prettyexpand '(pushnew 'x list) t)
               -| (setq list (if (memq 'x list) list (cons 'x list)))
          (cl-prettyexpand '(caddr (member* 'a list)) t)
               -| (car (cdr (cdr (memq 'a list))))

     `adjoin'や`caddr'、`member*'はすべて、共通の場合にそれらを最適化す
     るための組み込みのコンパイラマクロを持っていることに注意せよ。



エラーチェック
==============

Common Lispへの追従は一般に、効率を犠牲にしていない。いくつかの例外が、
周辺的な非互換性を犠牲にして相当な利益が可能な場合になされた。一例は、
キーワード引数を走査するための`memq'(これはバイトコンパイラによって非常
に効率的に扱われる)の使用である; これは、キーワードシンボルがキーワード
とデータの値に同時に使われるようなまれな場合に混乱する可能性がある。こ
れが実用的なコードの中で起こることはきわめてありそうになく、`memq'の使
用は、キーワード引数を伴う関数が`&optional'引数を使う関数とほとんど同じ
くらい速いことを許す。

(Steeleの本で具体化された)Common Lisp標準は、従うプログラム中では発生し
ないことになっている状況を示すために、句"その場合、それはエラーである"
を使う; 処理系は、これらの状況中でエラーを通知することを、必須ではない
が強く奨励される。このパッケージはときどき、コンパクトさと効率の利益の
ために、このようなエラーチェックを省略する。たとえば、`do'変数指定子は、
1つか2つ、あるいは3つのフォームのリストということになっている; 余分の
フォームは、このパッケージでは文法エラーを通知するのではなく無視される。
`endp'関数は単に、このパッケージでは`null'の同義語である。キーワード引
数を取る関数は、奇数個の引数を受け入れ、値`nil'がそれに続くかのように末
尾のキーワードを扱う。

(`defun*'やその友人によって処理されるとき)引数リストは、今述べた重要で
ない点を除いて、厳しくチェック*される*; 特に、キーワード引数は有効性を
チェックされ、`&allow-other-keys'と`:allow-other-keys'は完全に実装され
ている。キーワード有効性チェックは、わずかに時間を消費する(しかしバイト
コンパイルされたコードではそれほど悪くはない); チェックを省略するために
`&allow-other-keys'を使える。`find'や`member*'のようなこのパッケージで
定義された関数は、そのキーワード引数の有効性チェックを行なう。



最適化コンパイラ
================

Emacs 18に付属のバイトコンパイラは、ファイルのトップレベル位置
(すなわち、`defun'や他の囲むフォームの外)に現れるマクロの展開に
失敗する。これは、`defun*'や`eval-when'、`defstruct'
のようなトップレベルマクロを使うプログラムに、悲惨な
結果をもたらすだろう。この問題を回避するために、"CL"パッケージは、
トップレベルマクロを展開するようにEmacs 18のコンパイラに
パッチをあてる。あなた自身のマクロがトップレベルコンテキストで使われる
場合も、このパッチが適用されるだろう。このパッチは、すでに類似の
パッチが適用されたEmacs 18コンパイラの版に害を与えないし、
Jamie ZawinskiとHallvard Furusethによって書かれた最適化Emacs 19
コンパイラには影響しない。パッチはEmacsのメモリ中の
バイトコンパイラコードへ適用され、ディスク上の格納されている
`bytecomp.elc'ファイルへ適用されるのでは*ない*。

(Emacs 18のための)Emacs 19コンパイラは、`archive.cis.ohio-state.edu'の
ようなさまざまなEmacs Lispアーカイブサイトで利用できる。その使用は大い
に推奨される; Common Lispマクロの多くは、最適化により改善される可能性が
あるコードを発する。特に、`block'は(明示的であろうと、`defun*'や`loop'
のような構文要素中に暗黙であろうと)かなりの実行時の不利益を持つ;最適化
コンパイラは、ブロックの内部で`return'や`return-from'によって実際に参照
されない`block'を取り除く。



File: cl-j, Node: Common Lispとの互換性, Next: 古いCLとの互換性, Prev: 効率の配慮, Up: Top

Common Lispとの互換性
*********************

下記は、このパッケージとSteele(第2版)に文書化されたCommon Lispとの間の
すべての既知の非互換のリストである。

`member'や`assoc'、`floor'のようなある種の関数名は、(非互換な)Emacs
Lisp関数によってすでに取られていた; このパッケージは、これらの関数の
Common Lisp版の名前に`*'を付加する。

語`defun*'は、拡張されたCommon Lisp引数リストを関数で使うために、
`defun'の代わりに必要である。同様に、`defmacro*'と`function*'は、これら
のフォームの完全な機能の引数リストを理解する版である。`&whole'キーワー
ドは、`defmacro'引数リストでは(再帰的引数リストの中を例外として)動作し
ない。

効率的な実装を許すために、キーワード引数は、キーワードシンボルが他のキー
ワード引数の*値*として渡された場合に混乱するかもしれない、わずかに下等
な構文解析器を使う(つまり、`(memq :KEYWORD REST-OF-ARGUMENTS)'が、与え
られたキーワード引数の中を`:KEYWORD'を見つけようと走査するために使われ
る)。

`eql'と`equal'述語は、IEEE浮動小数点の正の0と負の0を
区別しない。`equalp'述語は、Common Lispといくつかの相違がある;
*Note 述語::.

`setf'メカニズムは完全に互換だが、setf-methodは5つの値を直接戻すのでは
なく、5つの値のリストを戻す点が異なる。また、(`(defun (setf foo) ...)'
が典型的であるような)新しい"`setf'関数"の概念は実装されていない。

`do-all-symbols'フォームは、OBARRAY引数がない
`do-symbols'と同じである。Common Lispでは、このフォームはすべての
パッケージ中のすべてのシンボルの上で繰り返す。Emacsのobarrayは、
ファーストクラスのパッケージメカニズムではないので、
`do-all-symbols'が既定のobarray以外を確認する方法はない。

`loop'マクロは、`loop-finish'と型指定子が実装されていない点を除いて完全
である。

多値戻し機能はリストを多値として扱うが、それはEmacs Lispは多重戻り値を
直接サポートしないためである。`values'または`values-list'が、
`multiple-value-bind'や他の多値受け取り側へ戻るために常に使われる場合、
マクロはCommon Lispと互換だろう; `values'が`multiple-value-...'なしで使
われたり、`multiple-value-...'が`values'なしで使われたりする場合、効果
はCommon Lispとは異なるだろう。

多くのCommon Lisp宣言は無視され、その他は概念としてはCommon Lisp標準に
マッチするが、詳細はマッチしない。たとえば局所`special'宣言は、Emacs
Lispでは純粋に助言だが、Steeleの本に規定されたスコープ規則に厳密には従
わない。

変数`*gensym-counter*'は、0ではなく疑似乱数値で開始する。これは、生成さ
れたシンボルは、ファイルへ書かれ、ファイルからロードされたときにintern
されるという事実をうまく処理できる。

`defstruct'機能は互換だが、構造体は、ある特殊な別の型ではなく、既定では
`:type vector :named'の型である点が異なる。また、`:type'スロットオプショ
ンは無視される。

`check-type'の第2引数は異なる扱いをされる。



File: cl-j, Node: 古いCLとの互換性, Next: Common Lispの移植, Prev: Common Lispとの互換性, Up: Top

古いCLとの互換性
****************

下記は、このパッケージとより古いQuirozの`cl.el'パッケージとの間のすべて
の既知の非互換のリストである。

このパッケージの関数の多重戻り値のエミュレーションは、より古いパッケー
ジのそれと非互換である。あのパッケージは、真のCommon Lisp多重戻り値にで
きる限り近付くように試みた; 不幸にも、それは100%信頼できるものではなく、
自由に使われた場合に時おり意外なことになりがちだった。このパッケージは、
よりシンプルな方法を使う。すなわち、値のリストで多値を置き換える。それ
は、著しくCommon Lispとは相違するが、より予測可能である。

`defkeyword'フォームと`keywordp'関数は、このパッケージでは実装されてい
ない。

`member'や`floor'、`ceiling'、`truncate'、`round'、`mod'、`rem'関数は、
Emacs 18またはEmacs 19に存在する関数との衝突を避けるために、このパッケー
ジでは接尾辞`*'が付けられる。より古いパッケージは、単にこれらの関数を再
定義し、組み込みの意味を上書きして、Emacs 19で重大な可搬性の問題を引き
起こした(いくつかのより最近のQuirozパッケージの版は、それらの名前を
`cl-member'その他へ変えた; このパッケージは、`member*'その他への別名と
して後者の名前を定義する)。

古いパッケージのバグがあるかCommon Lisp標準と一致しないある種の関数は、
このパッケージの準拠している版と非互換である。たとえば、`eql'や
`member'は、あのパッケージでは`eq'や`memq'の同義語であったり、`setf'は
その引数の評価の正しい順序を保存できなかったり、など。

最後に、より古いパッケージとは異なり、このパッケージは注意深く、内部名
のすべてに接頭辞`cl-'を付けている。(`floatp-safe'や`letf'のような)追加
の機能として明示的に定義されているいくつかの関数を除いて、このパッケー
ジは、Common Lispの一部ではない、どんな非`cl-'シンボルも移出しない。



`cl-compat'パッケージ
=====================

"CL"パッケージは、互換パッケージ`cl-compat'のフォームの中に、古い
`cl.el'のいくつかの機能のエミュレーションを含む。それを使うためには、あ
なたのプログラムの中に`(require 'cl-compat)'を置くこと。

古いパッケージは、`cl-'接頭辞や他の表記法なしで、かなりの数の内部
ルーチンを定義していた。これらのルーチンへの呼び出しが、既存のLisp
コードに入り込んでしまっているかもしれない。`cl-compat'は、下記の
内部ルーチンのエミュレーションを提供する: `pair-with-newsyms'、
`zip-lists'、`unzip-lists'、`reassemble-arglists'、
`duplicate-symbols-p'、`safe-idiv'.

いくつかの`setf'フォームは、ユーザコードが直接呼び出すかもしれない内部
関数への呼び出しへ翻訳された。関数`setnth'や`setnthcdr'、`setelt'がこの
カテゴリに入る; それらは`cl-compat'で定義されるが、最良の修正は`setf'を
適正に使うように変えることである。

`cl-compat'ファイルは、キーワード関数`keywordp'や`keyword-of'、
`defkeyword'を定義する。データとしてのキーワードの使用には反対なので、
それらは新しい"CL"パッケージによっては定義されない。

キーワード引数構文解析用の`build-klist'メカニズムは、`cl-compat'でエミュ
レートされている; しかし`with-keyword-args'はエミュレートされておらず、
どんな場合でも、`defun*'によって提供されるより自然なキーワード引数処理
を使うように変えるのが最良である。

多重戻り値は、2つのCommon Lispパッケージで異なって扱われる。古い
パッケージの方法は、真のCommon Lispにより互換だったが、ある場合には
偽の多重戻り値を報告することを引き起こす発見的方法を使った。
`cl-compat'パッケージは、古いCLパッケージと互換の多重値マクロの
集合を定義する; 再び、それらは本質的に発見的であるが、古いパッケージの
マクロが動作するところならどこでも動作することが保証される。"公式の"
多重値機能との名前の衝突を避けるため、`cl-compat'のそれは
大文字で始まる名前を持つ: `Values'、`Values-list'、
`Multiple-value-bind'など。

関数`cl-floor'や`cl-ceiling'、`cl-truncate'、`cl-round'は、古いスタイル
の多値メカニズムを使うために、ちょうどそれらが古いパッケージでしたのと
同じように`cl-compat'で定義される。より新しい`floor*'や友人は、多値とし
てではなくリスト中にその2つの結果を戻す。古いパッケージの古い版は、あり
のままの名前`floor'や`ceiling'その他を使ったことに注意せよ; それらは
Emacs 19の組み込みのものと衝突するので、`cl-compat'はそれらの名前を使え
ない。



File: cl-j, Node: Common Lispの移植, Next: Function Index, Prev: 古いCLとの互換性, Up: Top

Common Lispの移植
*****************

このパッケージは、Emacs Lispへの拡張として使われることを意図されており、
真のCommon LispのEmacs実装としては意図されていない。Emacs LispとCommon
Lispの間の残りの相違のいくつかは、大きなCommon Lispアプリケーションを
Emacsへ移植することを難しくしている。一例として、このパッケージの機能の
いくつかは、ANSIまたはSteeleに完全には従っていない; *Note Common Lispと
の互換性::. しかし、このパッケージがまったく提供しない機能もかなり多く
ある。ここには、Common LispコードをEmacsに持ってくるときに警戒したくな
る、いくつかの主要な省略がある。

   * 大文字小文字の区別がないこと。Common Lispのシンボルは、既定では大
     文字小文字の区別がない。いくつかのプログラムは、ある関数または変数
     をある場所では`foo'として、別の場所では`Foo'または`FOO'として参照
     する。Emacs Lispはそれれを3つの別のシンボルとして扱う。

     いくつかのCommon Lispコードは、完全に大文字で書かれている。一方
     Emacsは、プログラム自身の関数や変数にこの規約を喜んで使わせるので、
     `if'や`defun'のようなLisp組み込みへの呼び出しは、小文字に変えなけ
     ればならなくなるだろう。

   * レキシカルスコープ。Common Lispでは、関数引数や`let'の束縛は、物理
     的にその本体内(またはその本体のマクロ展開内)での参照にだけ適用する。
     Emacs Lispでは対照的に、本体から呼び出された関数の内側でさえ変数へ
     の束縛が見える"動的スコープ"を使う。

     Common Lispの変数は、`special'と宣言するか`defvar'を使うことで動的
     スコープにすることができる。Emacs Lispでは、すべての変数が
     `special'と宣言されているようなものである。

     しばしば、動的スコープLispの中でさえレキシカルスコープのために書か
     れたコードを使うことができるが、常にというわけではない。これは、
     Emacs Lispでは失敗するCommon Lispコード断片の例である:

          (defun map-odd-elements (func list)
            (loop for x in list
                  for flag = t then (not flag)
                  collect (if flag x (funcall func x))))

          (defun add-odd-elements (list x)
            (map-odd-elements (function (lambda (a) (+ a x))) list))

     Common Lispでは、2つの関数の`x'の使用法は完全に独立している。
     Emacs Lispでは、`add-odd-elements'によって作られた`x'への束縛は、
     `(+ a x)'関数が呼び出される間は`map-odd-elements'の束縛で隠される
     だろう。

     (このパッケージは、自身のマッピング関数の中で内部的に`x'ではなく
     `cl-x'のような名前を使うことで、このような問題を避ける; あなた自身
     の変数のために`cl-'接頭辞を使わない限り、衝突は起こらない)

     Common Lispスタイルのレキシカルな束縛を確立する`lexical-let'フォー
     ムの記述と、Emacs正規の`let'とどのように異なるかのいくつかの例は、
     *Note レキシカルな束縛::.

   * リーダマクロ。Common Lispは、個々の文字のレベルで働く第2のマクロの
     型を含む。たとえば、Common Lispは`''と呼ばれるリーダマクロによって
     引用符表記法を実装するが、Emacs Lispの構文解析器は、単に引用符を特
     殊な場合として扱う。いくつかのLispパッケージは、自身用の特殊文法を
     作るためにリーダマクロを使うが、それをEmacs構文解析器は読めない。

     ついでに言えば、リーダマクロの欠如は、Emacs Lispの普通ではない
     バッククォート文法の背後にある理由である。バッククォートはLisp
     パッケージとして実装されており、Emacs構文解析器に組み
     込みではないので、標準の関数/マクロ呼び出し表記法と共に使われる、
     ``'と名付けられた正規のマクロを使うように強いられる。

   * その他の文法機能。Common Lispは、Emacs Lisp構文解析器が理解できな
     い、`#'で始まるかなりの数の表記法を提供する。たとえば、
     `#| ... |#'は代替の注釈表記法であり、`#+lucid (foo)'は、Lucid
     Common Lisp内を除いて`(foo)'を無視するように構文解析器に言う。

   * パッケージ。Common Lispでは、シンボルは"パッケージ"に分けられる。
     Lisp組み込みのシンボルは、典型的には1つのパッケージに格納される;ベ
     ンダ拡張のシンボルは別のパッケージに置かれ、それぞれのアプリケーショ
     ンプログラムは、それ自身のシンボルのためのパッケージを持つかもしれ
     ない。あるシンボルはパッケージによって"移出"され、他のシンボルは内
     部的である; あるパッケージは、他のパッケージの移出されたシンボルを
     使用"または移入する。この移入と移出のために通常は見えないかもしれ
     ないシンボルをアクセスするために、Common Lispは、`package:symbol'
     または`package::symbol'のような文法を提供する。

     Emacs Lispは、すべてのinternされたシンボルに1つの名前空間を持ち、
     名前の先頭に`cl-'のような接頭辞を置くという命名規約を使う。いくつ
     かのEmacsパッケージは、接頭辞として`cl:'や`cl::'を使うCommon Lisp
     に似た規約を採用する。しかし、Emacs構文解析器はコロンを理解せず、
     単にそれらをシンボル名の一部として扱う。したがって、`mapcar'と
     `lisp:mapcar'はCommon Lispでは同じシンボルを参照するかもしれないが、
     Emacs Lispではそれらは完全に別のものである。あるシンボルを、時には
     正式な名前で参照し、別の時には短い名前で参照するCommon Lispプログ
     ラムは、Emacsにはきれいに移植できないだろう。

     Emacs Lispは"obarray"の概念を持っており、それはパッケージに似たシ
     ンボルの集積だが、この機能は真のパッケージメカニズムとして使えるほ
     ど十分に強力ではない。

   * `format'関数は、Common LispとEmacs Lispの間でまったく違っている。
     フォーマット文字列の前に、追加の"宛先"引数をとる。`nil'の宛先は、
     Emacs Lispのように文字列をフォーマットすることを意味する; `t'の宛
     先は、(Emacsの`message'のように)ターミナルへ書くことを意味する。ま
     た、フォーマット制御文字列は完全に異なる;フォーマットコードを導入
     するために、`%'の代わりに`~'を使い、利用できるコードの集合はずっと
     豊富である。文字列リテラルの`\n'のような表記法はない; その代わりに、
     `format'は"改行"フォーマットコードである`~%'とともに使われる。より
     高度なフォーマットコードは、パラグラフ詰め込み、大文字小文字変換、
     そしてループや条件付き実行のような機能さえ提供する。

     このパッケージで、Common Lispの`format'の大部分を実装することは可
     能だったかもしれないとしても(もちろん`format*'の名のもとに)、時間
     と労力をかけるだけの値打ちがないように思われた。`format*'のかなり
     のサブセットを実装するためですら、巨大なコード量が必要だっただろう
     し、さらに、Emacs Lispの`format'を越えて提供する機能はめったに有用
     ではないだろう。

   * ベクタ定数は、Emacs Lispでは角括弧を使うが、Common Lispでは`#(a b
     c)'記法を使う。さらに問題を複雑にすることには、Emacs 19は、何か完
     全に違うこと--属性を持つ文字列のために、それ自身の`#('表記法を導入
     する。

   * Common Lispでは、文字と整数は別である。文字定数の表記法も異なる:
     `?A'の代わりに`#\A'である。また、`string='と`string-equal'はEmacs
     Lispでは同義語だが、Common Lispでは後者は大文字小文字を区別しない。

   * データ型。いくつかのCommon Lispデータ型は、Emacs Lispには存在しな
     い。有理数と複素数はなく、大きな整数もない(すべての整数は"fixnum"
     である)。すべての配列は1次元である。リードテーブルやパス名はない;
     ストリームは、それら自身が新しいデータ型ではなく、存在するデータ型
     の集合である。ハッシュ表やランダムステート、構造体、パッケージ
     (obarray)は別の型ではなく、Lispベクタやリストから造られる。

   * Common Lisp Object System(CLOS)とCommon Lispコンディションシステム
     は実装されていない。しかし、`ftp://ftp.ultranet.com/pub/zappo'の
     EIEIOパッケージは、いくつかのCLOS機能を実装する。

   * 異なる名前のEmacs Lisp機能と完全に重複するCommon Lisp機能は、一般に
     実装されていない。たとえば、Emacs Lispが`defconst'を
     使うところで、Common Lispは`defconstant'を使う。同様に、
     `make-list'は2つのLispで異なった方法でその引数をとるが、正確に
     同じことをするので、このパッケージはCommon Lispスタイルの
     `make-list'をわざわざ実装しなかった。

   * このパッケージに含まれていない、より注意が必要ないくつかのCommon Lisp
     機能は: `compiler-let'、`tagbody'、`prog'、
     `ldb/dpb'、`parse-integer'、`cerror'。

   * 再帰。再帰は、Emacs LispでちょうどCommon Lispと同じように動作する
     が、さまざまなEmacs Lispシステムやコンパイラの詳細が、再帰を多くの
     Lispよりも非効率的にしている。ある流派は、他のテクニックよりも
     Lispで再帰を使うことを好む; 彼らは、以下のようなものを使って数のリ
     ストを合計するかもしれない:

          (defun sum-list (list)
            (if list
                (+ (car list) (sum-list (cdr list)))
              0))

     そこでは、より繰り返し的に考えるプログラマは以下のフォームの1つを
     書くかもしれない:

          (let ((total 0)) (dolist (x my-list) (incf total x)) total)
          (loop for x in my-list sum x)

     これは、多くのCommon Lispではおもにスタイル上の選択だろうが、
     Emacs Lispでは、繰り返しフォームは再帰よりもかなり速いことを知って
     おくべきである。またLispプログラマは、現在のEmacs Lispコンパイラは
     末尾再帰を最適化しないことを注記したいだろう。



File: cl-j, Node: Function Index, Next: Variable Index, Prev: Common Lispの移植, Up: Top

Function Index
********


* Menu:

* abs:                          数の関数.               (line  10)
* acons:                        連想リスト.             (line  34)
* adjoin:                       集合としてのリスト.     (line  36)
* assert:                       アサーション.           (line  17)
* assoc*:                       連想リスト.             (line  11)
* assoc-if:                     連想リスト.             (line  27)
* assoc-if-not:                 連想リスト.             (line  27)
* block:                        ブロックと脱出.         (line  14)
* butlast:                      リスト関数.             (line  47)
* caddr:                        リスト関数.             (line  11)
* callf:                        修正マクロ.             (line 144)
* callf2:                       修正マクロ.             (line 158)
* case:                         条件付き実行.           (line  31)
* ceiling*:                     数の関数.               (line  53)
* check-type:                   アサーション.           (line  37)
* cl-float-limits:              処理系パラメータ.       (line  23)
* cl-prettyexpand:              効率の配慮.             (line  40)
* clrhash:                      ハッシュ表.             (line  55)
* coerce:                       データ型の述語.         (line  61)
* compiler-macroexpand:         マクロ.                 (line  56)
* concatenate:                  列関数.                 (line  26)
* copy-list:                    リスト関数.             (line  75)
* copy-tree:                    リスト関数.             (line  79)
* count:                        列の検索.               (line  24)
* count-if:                     列の検索.               (line  26)
* count-if-not:                 列の検索.               (line  26)
* decf:                         修正マクロ.             (line  45)
* declaim:                      宣言.                   (line  25)
* declare:                      宣言.                   (line  33)
* defalias:                     関数別名.               (line  11)
* define-compiler-macro:        マクロ.                 (line  25)
* define-modify-macro:          setf独自化.             (line  12)
* define-setf-method:           setf独自化.             (line  97)
* defmacro*:                    引数リスト.             (line  32)
* defsetf:                      setf独自化.             (line  42)
* defsetf:                      setf独自化.             (line  74)
* defstruct:                    構造体.                 (line  19)
* defsubst*:                    引数リスト.             (line  23)
* deftype:                      データ型の述語.         (line  70)
* defun*:                       引数リスト.             (line  17)
* delete:                       列関数.                 (line  69)
* delete*:                      列関数.                 (line  57)
* delete-duplicates:            列関数.                 (line  91)
* delete-if:                    列関数.                 (line  64)
* delete-if-not:                列関数.                 (line  64)
* destructuring-bind:           マクロ.                 (line  14)
* do:                           繰り返し.               (line  33)
* do*:                          繰り返し.               (line  71)
* do-all-symbols:               繰り返し.               (line 111)
* dolist:                       繰り返し.               (line  88)
* do-symbols:                   繰り返し.               (line 103)
* dotimes:                      繰り返し.               (line  96)
* ecase:                        条件付き実行.           (line  58)
* endp:                         リスト関数.             (line  25)
* eql:                          等値の述語.             (line  10)
* equalp:                       等値の述語.             (line  36)
* etypecase:                    条件付き実行.           (line  77)
* eval-when:                    評価の時間.             (line  17)
* eval-when-compile:            評価の時間.             (line  85)
* evenp:                        数の述語.               (line  23)
* every:                        列上のマッピング.       (line  63)
* expt:                         数の関数.               (line  15)
* fill:                         列関数.                 (line  32)
* find:                         列の検索.               (line  11)
* find-if:                      列の検索.               (line  26)
* find-if-not:                  列の検索.               (line  26)
* first:                        リスト関数.             (line  18)
* flet:                         関数束縛.               (line  10)
* floatp-safe:                  数の述語.               (line  27)
* floor*:                       数の関数.               (line  32)
* function*:                    引数リスト.             (line  41)
* gcd:                          数の関数.               (line  20)
* gensym:                       シンボル生成.           (line  11)
* gentemp:                      シンボル生成.           (line  32)
* get*:                         属性リスト.             (line  12)
* getf:                         属性リスト.             (line  30)
* gethash:                      ハッシュ表.             (line  36)
* get-setf-method:              setf独自化.             (line 129)
* hash-table-count:             ハッシュ表.             (line  65)
* hash-table-p:                 ハッシュ表.             (line  73)
* ignore-errors:                アサーション.           (line  54)
* incf:                         修正マクロ.             (line  17)
* intersection:                 集合としてのリスト.     (line  55)
* isqrt:                        数の関数.               (line  28)
* labels:                       関数束縛.               (line  44)
* last*:                        リスト関数.             (line  36)
* lcm:                          数の関数.               (line  24)
* ldiff:                        リスト関数.             (line  67)
* letf:                         修正マクロ.             (line  98)
* letf*:                        修正マクロ.             (line 140)
* lexical-let:                  レキシカルな束縛.       (line  11)
* lexical-let*:                 レキシカルな束縛.       (line  93)
* list*:                        リスト関数.             (line  58)
* list-length:                  リスト関数.             (line  30)
* load-time-value:              評価の時間.             (line  94)
* locally:                      宣言.                   (line  39)
* loop:                         繰り返し.               (line  11)
* loop:                         ループの基本.           (line  16)
* macrolet:                     マクロ束縛.             (line  10)
* make-hash-table:              ハッシュ表.             (line  13)
* make-random-state:            乱数.                   (line  28)
* map:                          列上のマッピング.       (line  23)
* mapc:                         列上のマッピング.       (line  38)
* mapcan:                       列上のマッピング.       (line  47)
* mapcar*:                      列上のマッピング.       (line  11)
* mapcon:                       列上のマッピング.       (line  51)
* maphash:                      ハッシュ表.             (line  59)
* mapl:                         列上のマッピング.       (line  43)
* maplist:                      列上のマッピング.       (line  31)
* member:                       集合としてのリスト.     (line  10)
* member*:                      集合としてのリスト.     (line  16)
* member-if:                    集合としてのリスト.     (line  26)
* member-if-not:                集合としてのリスト.     (line  26)
* merge:                        列のソート.             (line  36)
* minusp:                       数の述語.               (line  15)
* mismatch:                     列の検索.               (line  31)
* mod*:                         数の関数.               (line  71)
* multiple-value-bind:          多値.                   (line  18)
* multiple-value-setq:          多値.                   (line  24)
* nbutlast:                     リスト関数.             (line  54)
* nintersection:                集合としてのリスト.     (line  59)
* notany:                       列上のマッピング.       (line  68)
* notevery:                     列上のマッピング.       (line  73)
* nset-difference:              集合としてのリスト.     (line  67)
* nset-exclusive-or:            集合としてのリスト.     (line  75)
* nsublis:                      式の置き換え.           (line  35)
* nsubst:                       式の置き換え.           (line  23)
* nsubst-if:                    式の置き換え.           (line  25)
* nsubst-if-not:                式の置き換え.           (line  25)
* nsubstitute:                  列関数.                 (line 100)
* nsubstitute-if:               列関数.                 (line 102)
* nsubstitute-if-not:           列関数.                 (line 102)
* nunion:                       集合としてのリスト.     (line  51)
* oddp:                         数の述語.               (line  19)
* pairlis:                      連想リスト.             (line  37)
* plusp:                        数の述語.               (line  11)
* pop:                          修正マクロ.             (line  49)
* position:                     列の検索.               (line  18)
* position-if:                  列の検索.               (line  26)
* position-if-not:              列の検索.               (line  26)
* proclaim:                     宣言.                   (line  20)
* progv:                        動的束縛.               (line  12)
* psetf:                        修正マクロ.             (line  11)
* psetq:                        代入.                   (line  11)
* push:                         修正マクロ.             (line  55)
* pushnew:                      修正マクロ.             (line  60)
* random*:                      乱数.                   (line  13)
* random-state-p:               乱数.                   (line  49)
* rassoc:                       連想リスト.             (line  24)
* rassoc*:                      連想リスト.             (line  20)
* rassoc-if:                    連想リスト.             (line  27)
* rassoc-if-not:                連想リスト.             (line  27)
* reduce:                       列上のマッピング.       (line  78)
* rem*:                         数の関数.               (line  74)
* remf:                         属性リスト.             (line  59)
* remhash:                      ハッシュ表.             (line  50)
* remove:                       列関数.                 (line  74)
* remove*:                      列関数.                 (line  45)
* remove-duplicates:            列関数.                 (line  84)
* remove-if:                    列関数.                 (line  64)
* remove-if-not:                列関数.                 (line  64)
* remprop:                      属性リスト.             (line  20)
* remq:                         列関数.                 (line  79)
* replace:                      列関数.                 (line  35)
* rest:                         リスト関数.             (line  22)
* return:                       ブロックと脱出.         (line  54)
* return-from:                  ブロックと脱出.         (line  48)
* rotatef:                      修正マクロ.             (line  83)
* round*:                       数の関数.               (line  65)
* search:                       列の検索.               (line  45)
* set-difference:               集合としてのリスト.     (line  63)
* set-exclusive-or:             集合としてのリスト.     (line  71)
* setf:                         基本的setf.             (line  10)
* shiftf:                       修正マクロ.             (line  67)
* some:                         列上のマッピング.       (line  55)
* sort*:                        列のソート.             (line   8)
* stable-sort:                  列のソート.             (line  27)
* sublis:                       式の置き換え.           (line  30)
* subseq:                       列関数.                 (line  10)
* subsetp:                      集合としてのリスト.     (line  79)
* subst:                        式の置き換え.           (line  12)
* subst-if:                     式の置き換え.           (line  25)
* subst-if-not:                 式の置き換え.           (line  25)
* substitute:                   列関数.                 (line  95)
* substitute-if:                列関数.                 (line 102)
* substitute-if-not:            列関数.                 (line 102)
* symbol-macrolet:              マクロ束縛.             (line  20)
* tailp:                        集合としてのリスト.     (line  31)
* the:                          宣言.                   (line  42)
* tree-equal:                   リスト関数.             (line  86)
* truncate*:                    数の関数.               (line  58)
* typecase:                     条件付き実行.           (line  62)
* typep:                        データ型の述語.         (line  10)
* union:                        集合としてのリスト.     (line  43)
* unless:                       条件付き実行.           (line  21)
* when:                         条件付き実行.           (line  11)



File: cl-j, Node: Variable Index, Prev: Function Index, Up: Top

Variable Index
********


* Menu:

* float-epsilon:                処理系パラメータ.       (line  68)
* float-negative-epsilon:       処理系パラメータ.       (line  73)
* *gensym-counter*:             シンボル生成.           (line  21)
* least-negative-float:         処理系パラメータ.       (line  62)
* least-negative-normalized-float: 処理系パラメータ.    (line  65)
* least-positive-float:         処理系パラメータ.       (line  50)
* least-positive-normalized-float: 処理系パラメータ.    (line  55)
* most-negative-fixnum:         処理系パラメータ.       (line  14)
* most-negative-float:          処理系パラメータ.       (line  46)
* most-positive-fixnum:         処理系パラメータ.       (line  10)
* most-positive-float:          処理系パラメータ.       (line  41)
* *random-state*:               乱数.                   (line  21)

Tag table:
Node: Top1264
Node: 概観2793
Node: 使用法4067
Node: 構成4483
Node: インストール5458
Node: 命名規約6120
Node: プログラム構造7702
Node: 引数リスト7894
Node: 評価の時間13030
Node: 関数別名17241
Node: 述語17600
Node: データ型の述語17737
Node: 等値の述語20673
Node: 制御構造22425
Node: 代入22687
Node: 汎変数23501
Node: 基本的setf24057
Node: 修正マクロ29607
Node: setf独自化34274
Node: 変数束縛38697
Node: 動的束縛38931
Node: レキシカルな束縛39410
Node: 関数束縛42147
Node: マクロ束縛43925
Node: 条件付き実行45963
Node: ブロックと脱出48037
Node: 繰り返し49889
Node: ループ機能53368
Node: ループの基本53739
Node: ループの例55101
Node: For節56409
Node: 繰り返し節63686
Node: 蓄積節64790
Node: その他の節66093
Node: 多値69699
Node: マクロ70770
Node: 宣言72717
Node: シンボル77602
Node: 属性リスト77748
Node: シンボル生成79675
Node: 数80886
Node: 数の述語81050
Node: 数の関数81651
Node: 乱数83882
Node: 処理系パラメータ85453
Node: 列87550
Node: 列の基本87829
Node: 列上のマッピング89574
Node: 列関数92931
Node: 列の検索96574
Node: 列のソート98317
Node: リスト99695
Node: リスト関数99841
Node: 式の置き換え102478
Node: 集合としてのリスト103562
Node: 連想リスト106173
Node: ハッシュ表107284
Node: 構造体110938
Node: アサーション120781
Node: 効率の配慮122543
Node: Common Lispとの互換性126278
Node: 古いCLとの互換性128029
Node: Common Lispの移植130515
Node: Function Index136242
Node: Variable Index148486

End tag table
