Info file: cvs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `cvs-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.



START-INFO-DIR-ENTRY
* CVS-JA: (cvs-ja).        Concurrent Versions System (Japanese)
END-INFO-DIR-ENTRY

Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.  Copyright (C) 1995-1999 Makoto
Hiroyasu Copyright (C) 1999 Yoshiki Hayashi

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.





File: cvs-ja.info, Node: Top, Next: Overview, Prev: (dir), Up: (dir)

CVS 1.10.8 Japanese Manual
**************************

この info manual は、CVS version 1.11 の使用方法と管理方法について記述
します。

* Menu:

* Overview::                    CVS への導入
* Repository::                  全てのソースが保存される場所
* Starting a new project::      CVS でプロジェクトを始める
* Revisions::                   リビジョンの数値とシンボルの名前
* Branching and merging::       開発の枝の多様化/再一本化
* Recursive behavior::          CVS はディレクトリを降りていく
* Adding and removing::         ファイル/ディレクトリを加える/取り除
                                く/名前を変える
* History browsing::            ファイルの履歴をいろいろな方法で閲覧する

CVS と現実の世界
-----------------------
* Binary files::                CVS はバイナリ・ファイルを扱うことができる
* Multiple developers::         CVS の開発者グループの援助の仕方
* Revision management::         リビジョン管理のポリシーへの質問
* Keyword substitution::        CVS はファイルの中にリビジョンを含むこ
                                とができる
* Tracking sources::            サード・パーティーソースの追っかけ
* Builds::                      CVS とコンパイルに関する問題
* Special Files::		デバイス、リンクと他の普通でないファイ
                                ル

リファレンス
-----------
* CVS commands::                CVS の命令は同じものを使う
* Invoking CVS::                CVS の命令の quick reference
* Administrative files::        管理ファイルへのリファレンスマニュアル
* Environment variables::       CVS に影響する全ての環境変数
* Compatibility::               CVS のバージョンを上げる
* Troubleshooting::             動作しないときのいくらかのこつ
* Credits::                     このマニュアルへの貢献者達
* BUGS::                        CVS かこのマニュアルのバグの対処
* 翻訳者より: Translation.      日本語訳について
* Index::                       索引



File: cvs-ja.info, Node: Overview, Next: Repository, Prev: Top, Up: Top

概観
****

この章は CVS を一度も使ったことが無く、おそらく以前にバージョン管理ソ
フトを使ったことの無い人のためのものです。

既に CVS に親しんでいて、特定の機能を学んだり、特定の命令を覚えようと
しているときは、ここは全て飛ばしてください。

* Menu:

* What is CVS?::                CVS で何が出きるか
* What is CVS not?::            CVS が解決しようとしない問題
* A sample session::            基本的な CVS の利用のツアー



File: cvs-ja.info, Node: What is CVS?, Next: What is CVS not?, Prev: Overview, Up: Overview

CVS とは?
=========

CVS はバージョン管理システムであり、あなたのソース・ファイルの変遷を記
録するのに使用します。


例えば、ソフトウェアの修正に伴なってバグが入り込み、発見されるまでに長
い時間がかかったとします。CVS を使っていれば、古いバージョンを簡単に復
元し、バグの原因となった変更点を正確に調べることができます。この特徴に
救われる時が必ずあります。

全てのバージョンの全てのファイルを保存しておくこともできますが、ディス
ク容量の無駄使いでしかありません。CVS は、バージョン間の差分のみを保存
する方法により、各ファイルの全バージョンを一つのファイルに記録します。

CVS は、複数の開発者が同じソフトウェアに取り組む場合に、真価を発揮しま
す。このような場合にはよほど気を付けていないと、他の人が変更したファイ
ルを上書きしてしまいます。GNU Emacs のようなエディタを使えば、複数の人
が同時に同じファイルを編集することはありません。しかし不幸なことに、全
員が同じエディタを使うとは限りません。CVS は開発者を互いに隔離すること
により、この問題を解決しました。全ての開発者は自分のディレクトリで作業
し、その仕事を CVS が組み合わせます。

CVS は Dick Grune が作成し、1986年 12 月に `comp.sources.unix' の 
volume 6 に投稿した、シェル・スクリプトから始まりました。現在の CVS は、
これらのシェル・スクリプトのコードを全く含みませんが、衝突解決のアルゴ
リズムの大部分を受け継いでいます。

1989年 4 月に Brian Berliner が CVS を設計し、コーディングしました。そ
の後、Jeff Polk が CVS の ベンダー枝とモジュールの設計を助けました。

CVS をインターネットからの自由なダウンロードなど、いろいろな方法で取得
することができます。 CVS のダウンロードや、他の CVS の話題の情報は、以
下のところを参照してください。

     http://www.cyclic.com/
     http://www.loria.fr/~molli/cvs-index.html

`info-cvs' という CVS 専門のメーリング・リストがあります。
参加、又は脱退したい場合には、
`info-cvs-request@gnu.org' にメールを出して下さい。
Usenet グループの方を好むのであれば、正しいグループは
`comp.software.config-mgmt' で、CVS の議論を
するために適した場所です (他の構成管理システムと一緒で
すが)。 将来は `comp.software.config-mgmt.cvs' を
作ることも可能かもしれませんが、おそらく
`comp.software.config-mgmt' に十分な流量があるよう
になったときだけでしょう。

*Note BUGS:: でより詳細に説明されている bug-cvs メーリングリストを講読
するともできます。講読するためには、bug-cvs-request@gnu.org にメールを
送ってください。



File: cvs-ja.info, Node: What is CVS not?, Next: A sample session, Prev: What is CVS?, Up: Overview

CVS は何ではない?
=================

CVS は多くのことができますが、全ての人に全てのことをするようにはなって
いません。

CVS は構築システムではありません。

     リポジトリと modules ファイルの構造と構築システム (例.
     `Makefile') とは相互作用するかもしれませんが、本質的に独立したも
     のです。

     CVS は、何かの作り方を指示したりはしません。CVS はあなたの意思に
     従って、ツリー構造から望むファイルを取り出すだけです。

     CVS は、`checkout' 先の作業ディレクトリのディスク容量の使用法につ
     いて指示したりはしません。あなたが `Makefile' やスクリプトを全て
     のディレクトリで書き、それらが各々全ての相対的な位置を知る必要が
     あるとすると、リポジトリ全てを取り出す必要が生じます。

     あなたが仕事をモジュール化し、(`Makefile' に link, mount, `VPATH'
     等を使用して、)ファイルを共有するような構築システムを構成すれば、
     好きな様にディスクの利用法を決めることが出来ます。

     しかしこれら*全ての*システムは、構築と維持に多大な労力が必要なこ
     とに、気を付けなければいけません。CVS は、このような問題に関して
     考慮しません。

     もちろん、これらの構築システムを支援するための道具(スクリプト,
     `Makefile' 等) は、CVS の管理下に置くと良いでしょう。

     何らかの変更があった際に、再構築が必要なファイルを調べるのは、や
     はり CVS の守備外です。伝統的な手法の一例をあげると、構築には 
     `make' を用い、`make' に必要な依存関係は自動化されたツールを用い
     て生成します。

     CVS と結合して構築を行うための情報は *Note Builds:: を参照してく
     ださい。

CVS は管理者代理ではありません。

     あなたの管理者や上司は、期日に従っているかどうかや、 マージ点、枝
     の名前、リリースの日時等について、あなたと度々話しあうことを求め
     られています。彼等がそうしないなら、CVS は役に立ちません。

     CVS は、あなたの調律に従ってソースを踊らせる楽器のようなものです。
     あなたは楽器奏者もしくは作曲者のようなものです。どんな楽器も勝手
     に演奏をしたりしないし、音楽が勝手に書かれたりもしません。

CVS は開発者同士の意志疎通の代用にはなりません。

     あるファイルに衝突が起きた場合に、ほとんどの開発者はそれほど苦労
     せずに解決します。しかし、"衝突" ("conflict")のより一般的な定義に
     は、開発者同士の意志疎通なしには解決できない困難な問題も含まれま
     す。

     同じファイル (もしくはファイルの集合) に、同時に加えられた変更に
     論理的な衝突があっても、CVS には分りません。"衝突"という概念は単
     に文字列の比較によるもので、同じファイルを基に加えられた二つの変
     更が、`merge' コマンド (つまり `diff3') を驚かせるのに十分なほど
     近接している場合にのみ生じます。

     CVS は、プログラムの論理に、文字列でない衝突や、散らばった衝突が
     あったとしても、警告を表示しません。

     例: あなたは `A' で定義された関数 `X' の引数を変更したとします。
     同じ時に、誰かが `B' を編集して、古い引数を使って `X' を呼び出し
     たとします。これは CVS の能力の範囲外です。

     仕様書を読み、同僚と話し合う習慣を付けましょう。


CVS は変更管理をしません。

     変更管理という言葉は様々な意味を持ちます。まず"バグ追跡"と解釈す
     れば、バグ報告と各バグの状態(修正されたか? どのリリースか? 報告者
     は修正を確認したか? ) についてのデータベース管理を意味します。CVS 
     とバグ追跡システムとの連携については、`rcsinfo' と `editinfo' ファ
     イルを見て下さい (*Note Administrative files::)。

     論理的には一つと考えられる変更のため、複数のファイルが同時に変更
     されたことを覚えておくことも、変更管理と呼ばれます。複数のファイ
     ルの変更を一つの `cvs commit' により格納した場合、CVS はそれらの
     ファイルが同時に格納されたことを忘れてしまいます。そして、それら
     のファイルを結ぶ事柄は、同じログ・メッセージを持つことだけになる
     のです。GNU 形式の `ChangeLog' を用いれば何らかの助けになるでしょ
     う。

     各変更の状態を覚えておく能力を、変更管理と呼ぶシステムもあります。
     開発者によって加えられた変更もあれば、他の開発者によって追試中の
     変更もあるとか、そういったことです。一般的に CVS でこのようなこと
     をするには、(`cvs diff' や `diff' を用いて) 差分を生成し、`patch' 
     を当てる人物にメールとして送ります。これは非常に融通のきく方法で
     すが、CVS 以外の機構に依存しているので、問題が無いことを保証でき
     ません。

CVS は自動検査プログラムではありません。

     `commitinfo' ファイルを使えば、強制的に必須の項目を検査することは
     可能だと思います。しかし、そんなことをしようとしたプロジェクトの
     ことは聞いたことがありません。

CVS は手順規範を備えていません。

     変更やリリースに必要とされる色々な手順や多くの承認を、確実に行な
     う方法を備えたシステムもあります。CVS を用いてこれを達成すること
     も可能ですが、ちょっと面倒だと思います。場合によっては、
     `commitinfo', `loginfo', `rcsinfo', `verifymsg' 等のファイルを用
     いて、変更点を格納する前に、必要な手順を確実に踏むように設定でき
     るでしょう。また枝やタグといった機構を用いて、開発用の枝で仕事を
     実行し、安定性が証明された確実な変更だけを安定化指向の枝に統合す
     ることも考えられます。



File: cvs-ja.info, Node: A sample session, Prev: What is CVS not?, Up: Overview

作業例
======


CVS を紹介する方法として、CVS を使って典型的な仕事をしてみます。最初に
理解すべきことは CVS は全てのファイルを中央に集められた "リポジトリ"
("repository") (*Note Repository::) に保存するということです。この節で
はリポジトリは準備されていると仮定します。

あなたの仕事は単純なコンパイラを作成することです。ソースは少しの C言語
で書かれたファイルでできていて、`Makefile' を含んでいるとします。この
コンパイラを `tc' (Trivial Compiler) と呼ぶことにします。そして `tc' 
というモジュール名でリポジトリに登録されています。

* Menu:

* Getting the source::          作業場所の作成
* Committing your changes::     あなたの仕事を他の人が利用可能にする
* Cleaning up::                 お掃除
* Viewing differences::         差分を見る



File: cvs-ja.info, Node: Getting the source, Next: Committing your changes, Prev: A sample session, Up: A sample session

ソースの取得
------------

まず、`tc' のソースの作業コピーを取ってくることから始めましょう。これ
には `checkout' コマンドを使用します:

     $ cvs checkout tc

とすると `tc' という新しい作業ディレクトリが作られ、その中にソース・ファ
イルがコピーされます。

     $ cd tc
     $ ls
     CVS         Makefile    backend.c   driver.c    frontend.c  parser.c

`CVS' というディレクトリは CVS が内部的に使用します。普通はその中にあ
るどんなファイルでも修正したり削除してはいけません。

で、あなたの好きなエディタを用いて `backend.c' をハックして、数時間後
にコンパイラの最適化経路を加えたとします。RCS と SCCS の利用者への注意: 
編集したいファイルをロックする必要はありません。その説明は、 *Note
Multiple developers::.



File: cvs-ja.info, Node: Committing your changes, Next: Cleaning up, Prev: Getting the source, Up: A sample session

変更の格納
----------

あなたはコンパイラが相変わらずコンパイル可能であることを確認し、
`backend.c' の新しいバージョンとすることに決めました。これは新しい 
`backend.c' をリポジトリに格納し、同じリポジトリを使っている他の人が使
用できるようにします。

     $ cvs commit backend.c

CVS はログ・メッセージを記すためにエディタを開きます。そこで "Added an
optimization pass." などと入力し、一時ファイルに保存し、エディタを終了
します。

どのエディタが開かれるかは環境変数 `$CVSEDITOR' により決定されます。
`$CVSEDITOR' が設定されておらず、環境変数 `$EDITOR' が設定されていれば、
これを使用します。`$CVSEDITOR' と `$EDITOR' の両方が設定されていなけれ
ば、オペレーティングシステムに依って違ったデフォルトが使われます。例え
ば、unix では `vi'で、Windows NT/95 では `notepad' です。

加えて、CVS は `$VISUAL' 環境変数も調べます。この動作が望ましいか、ま
た CVS の将来のリリースが `$VISUAL' を調べるべきかどうか、という意見は
人によって異なります。`$VISUAL' が設定されていないか、`$EDITOR' に設定
されていることを確実にすることで、どちらになっても対処することができま
す。CVS がエディタを開始したときは、修正されたファイルのリストを含んで
います。CVS のクライアントでは、このリストはファイルの修正時刻を、最後
にファイルを得た時刻か更新された時刻と比較したものに基づいています。で
すから、ファイルの修正時刻が変わっているけれど内容が変更されていないと
いうときも、修正されたものとして表示されます。これに対する最も簡単な対
処法は単純に気にしないことです--それを commitすると、CVS は内容は修正
されていないことを発見し、無修正ファイルであるとして扱います。次の 
`update'はファイルが無修正であるという事実に基づき、将来のセッションで
ファイルが表示されないように、タイムスタンプを保存されているものに設定
し直します。

わざわざエディタを開くのが嫌ならば、代わりにコマンド行の `-m' フラグを
使うことでログメッセージを以下のように指定することができます:

     $ cvs commit -m "Added an optimization pass" backend.c



File: cvs-ja.info, Node: Cleaning up, Next: Viewing differences, Prev: Committing your changes, Up: A sample session

お掃除
------

他の仕事に取りかかる前に、tc の作業コピーを消去することにしました。も
ちろん、次のようにしても可能です

     $ cd ..
     $ rm -r tc

しかし、`release' コマンドを使用するほうが良いでしょう (*Note
release::):

     $ cd ..
     $ cvs release -d tc
     M driver.c
     ? tc
     You have [1] altered files in this repository.
     Are you sure you want to release (and delete) directory `tc': n
     ** `release' aborted by user choice.

`release' コマンドは、あなたの修正が格納されているかどうか確認します。
ログを記録する設定ならば、ファイル `history' にメモします。 *Note
history file::.

`release' コマンドに `-d' フラグを使用すると、確認と同時に作業コピーを
削除します。

上の例では、`release' コマンドが何行か出力しています。`? tc' は CVS が 
`tc' というファイルを知らないという意味です。モジュール `tc' のことで
はなく、生成したコンパイラ `tc' を指しており、これはリポジトリに格納し
なくて良いので無視して構いません。この警告を消すための情報は *Note
cvsignore:: 参照。`release' の出力の詳細な説明は *Note release
output:: 参照。

`M driver.c' の方は重要です。これは、`driver.c' というファイルに加えた
修正が、格納されていないことを指摘しています。

`release' コマンドは、常に作業コピーの修正が加えられたファイルの数を報
告した後、ファイルを削除したり履歴ファイルにメモする前に、その確認を求
めてきます。

ここでは大事を取って、最後に `release' が確認を求めたときに `n RET' を
入力しました。



File: cvs-ja.info, Node: Viewing differences, Prev: Cleaning up, Up: A sample session

差分を見る
----------

あなたは `driver.c' に加えた修正を覚えていなかったので、何をしたのか調
べる必要があります。

     $ cd tc
     $ cvs diff driver.c

このコマンドは `diff' を実行して、取り出した時と、あなたの作業コピーの 
`driver.c' のバージョンを比較します。その出力を見て、最適化経路を有効
にするオプションを、コマンド行で指定できるようにしたことを思い出しまし
た。その変更を格納して、このモジュールに対する作業を終了します。

     $ cvs commit -m "Added an optimization pass" driver.c
     Checking in driver.c;
     /usr/local/cvsroot/tc/driver.c,v  <--  driver.c
     new revision: 1.2; previous revision: 1.1
     done
     $ cd ..
     $ cvs release -d tc
     ? tc
     You have [0] altered files in this repository.
     Are you sure you want to release (and delete) directory `tc': y



File: cvs-ja.info, Node: Repository, Next: Starting a new project, Prev: Overview, Up: Top

リポジトリ
**********

CVS の"リポジトリ" ("repository") は、バージョン管理の対象となる全ての
ファイルとディレクトリの、完全なコピーを保管します。

通常、リポジトリ中のファイルを直接利用することはありません。その代わり
に CVS コマンドを使用して、作業者自身のファイルのコピーを "作業ディレ
クトリ" に取り出し、そのコピーを用いて作業します。

そして一連の変更が完了したときに、変更点をリポジトリに書き戻します (も
しくは "格納" します ("commit"))。リポジトリは、変更を加えたものと同じ
になり、また同時に変更点や、変更日時などの情報も正確に記録されます。リ
ポジトリは作業ディレクトリのサブディレクトリやその逆ではないことに注意
してください。別の位置にあるべきです。

CVS は様々な方法でリポジトリを利用することができます。リポジトリは、使
用中のコンピュータ内であってもいいし、別の部屋のコンピュータや、別の国
のコンピュータであっても構いません。リポジトリに接続する方法を区別する
ために、リポジトリの名前の最初に"接続経路" ("access method") を加える
ことがあります。例えば `:local:' は、リポジトリであるディレクトリを利
用することを意味します。つまり `:local:/usr/local/cvsroot' で表される
リポジトリは、CVS を実行したコンピュータの `/usr/local/cvsroot' という
リポジトリを意味します。他の接続経路については *Note Remote
repositories:: 参照。

接続経路の指定が省略され、リポジトリに `:' が含まれない場合には、
`:local:' が仮定されます。`:' が含まれていた場合には、`:ext:' か 
`:server:' が仮定されます。例えばリポジトリ `/usr/local/cvsroot' が同
じコンピュータ内にある場合、`:local:/usr/local/cvsroot' を省略して
`/usr/local/cvsroot' と記述しても構いません。しかし(Windows NT などで)、
リポジトリが `c:\src\cvsroot' にある場合、 `:local:c:\src\cvsroot' と
して、接続経路を明示する必要があります。

リポジトリは二つの要素から構成されます。`$CVSROOT/CVSROOT' には CVS の
管理用ファイルが置かれます。その他のディレクトリには、使用者が定義した
モジュールの実体が置かれます。

* Menu:

* Specifying a repository::     どのリポジトリを使うか CVS に教える
* Repository storage::          リポジトリの構造
* Working directory storage::   作業ディレクトリの構造
* Intro administrative files::  モジュールの定義
* Multiple repositories::       複数のリポジトリ
* Creating a repository::       リポジトリの作成
* Backing up::                  リポジトリのバックアップ
* Moving a repository::         リポジトリの移動
* Remote repositories::         別のマシンのリポジトリを利用する
* Read-only access::            リポジトリの読み込みのみの利用を許可する
* Server temporary directory::  サーバは一時ディレクトリを作成する



File: cvs-ja.info, Node: Specifying a repository, Next: Repository storage, Prev: Repository, Up: Repository

CVS にリポジトリの場所を教える
==============================

CVS にリポジトリの場所を教えるには、いくつか方法があります。一つ目はコ
マンド行で、`-d' ("directory" を示します) オプションを用いて指定する方
法です:

     cvs -d /usr/local/cvsroot checkout yoyodyne/tc

二つ目は、環境変数 `$CVSROOT' に、絶対パスでリポジトリを指定する方法で
す。例では `/usr/local/cvsroot'です。`csh' や `tcsh' のユーザは各々
`.cshrc' や `.tcshrc' に次の行を加えて下さい:

     setenv CVSROOT /usr/local/cvsroot

`sh' や `bash' のユーザは各々 `.profile' や `.bashrc' に次の行を加えて
下さい:

     CVSROOT=/usr/local/cvsroot
     export CVSROOT

`-d' によるリポジトリの指定は、環境変数 `$CVSROOT' よりも優先されます。
一旦リポジトリから作業コピーを取得すれば、リポジトリの場所が記憶されま
す(この情報は、作業ディレクトリ内の `CVS/Root' に記録されます)。

オプション `-d' とファイル `CVS/Root' は、どちらも環境変数 `$CVSROOT' 
よりも優先されます。また、`-d' と `CVS/Root' が一致しない場合は、前者
が使用されます。もちろん、二つともが同じリポジトリを参照するのが、まと
もなやり方です。



File: cvs-ja.info, Node: Repository storage, Next: Working directory storage, Prev: Specifying a repository, Up: Repository

リポジトリでのデータの保存方法
==============================

CVS がリポジトリに情報を保存する*方法*を知っていても、たいてい何の役に
も立ちません。実際、過去に書式が変更されましたし、将来変更されることも
あるでしょう。ほとんど全ての場合、CVS コマンドを通してリポジトリを利用
しますから、書式を変更しても混乱は起きません。

しかし、リポジトリでのデータ保存方法の知識が必要な場合もあります。例え
ば CVS のロック解除が必要な場合 (*Note Concurrency::) や、リポジトリの
ファイルの許可属性を適切に設定する必要がある場合などです。

* Menu:

* Repository files::            リポジトリに保管されるファイル
* File permissions::            ファイル使用許可
* Windows permissions::         Windows 特有の問題
* Attic::                       Attic に保存されるファイルもある
* CVS in repository::           CVS ディレクトリの追加情報
* Locks::                       CVS ロックは並列接続を制御する
* CVSROOT storage::             CVSROOT の少しの違い



File: cvs-ja.info, Node: Repository files, Next: File permissions, Prev: Repository storage, Up: Repository storage

リポジトリのどこにファイルを保存するか
--------------------------------------


リポジトリの全体構造は作業コピーに対応するディレクトリ木で構成されてい
ます。例えば、リポジトリが

     /usr/local/cvsroot

にあれば、次のようなディレクトリの木構造になります (ディレクトリだけを
表示しています):

     /usr
      |
      +--local
      |   |
      |   +--cvsroot
      |   |    | 
      |   |    +--CVSROOT
               |      (管理用ファイル)
               | 
               +--gnu
               |   | 
               |   +--diff
               |   |   (GNU diff のソース)
               |   | 
               |   +--rcs
               |   |   (RCS のソース)
               |   | 
               |   +--cvs
               |       (CVS のソース)
               | 
               +--yoyodyne
                   | 
                   +--tc
                   |    |
                   |    +--man
                   |    |
                   |    +--testing
                   | 
                   +--(その他の Yoyodyne のソフトウェア)

ディレクトリの中身は、管理下にあるファイルの"履歴ファイル" ("history
files") です。履歴ファイルの名前は、各ファイル名の最後に `,v' を付加し
たものです。次に、ディレクトリ `yoyodyne/tc' のリポジトリ構造を示しま
す:
       `$CVSROOT'
         |
         +--yoyodyne
         |   |
         |   +--tc
         |   |   |
                 +--Makefile,v
                 +--backend.c,v
                 +--driver.c,v
                 +--frontend.c,v
                 +--parser.c,v
                 +--man
                 |    |
                 |    +--tc.1,v
                 |
                 +--testing
                      |
                      +--testpgm.t,v
                      +--test2.t,v

履歴ファイルは、どのリビジョンのファイルでも再構築できる情報を持ち、ま
た変更内容が格納された時のログ・メッセージと、その時のユーザの名前も記
録しています。ファイルをこのような書式で保管した最初のプログラムが、
RCS というバージョン管理システムであったために、履歴ファイルは "RCS ファ
イル" と呼ばれます。ファイル書式の完全な記述は、RCS の配布セットにある
`rcsfile(5)' の `man' ページか、CVS のソース配布のファイル 
`doc/RCSFILES' を参照してください。このファイル書式は非常に一般的なの
で、CVS や RCS 以外のシステムでも、少くとも理解をすることができます。

CVS で使用されている RCS ファイルは標準の書式と少し違います。最大の違
いは魔法の枝です。詳細は *Note Magic branch numbers:: を参照してくださ
い。CVS では、有効なタグ名は RCS で使用できるもののサブセットになって
います。CVS の規則は *Note Tags:: を参照してください。



File: cvs-ja.info, Node: File permissions, Next: Windows permissions, Prev: Repository files, Up: Repository storage

ファイル使用許可
----------------
全ての `,v' ファイルは読み込み専用であり、この使用許可を変えるべきでは
ありません。これに対し、リポジトリ中のディレクトリは、ファイルの修正を
行なう人物に対して、書き込みを許可しなくてはいけません。これはつまり、
ファイルの修正を行なう人物からなるグループを作って (`group(5)'参照)、
そのディレクトリの所有グループとすることを意味しています。

従って、ディレクトリ単位でしかファイルのアクセス権を管理することができ
ません。

CVS はロック・ファイルを作成する必要があるため (*Note Concurrency::)、
ファイルを取り出す使用者にも、書き込み許可が必要であることに注意して下
さい。

利用者は `CVSROOT/val-tags' ファイルに書き込み許可が必要なことも注意し
てください。CVS はそれをどのタグが有効かを記録するために使います (作成
時と、ときどきタグが使用されたときに更新されます)。

それぞれの RCS ファイルは最後に書き込んだ利用者に所有されます。これは
あまり重要ではありません。重要なのは誰がディレクトリを所有しているかで
す。

木の中に新しいディレクトリを加える場合、CVS はできるだけ適当な使用許可
を与える努力をします。しかし新しいディレクトリの使用許可が、親ディレク
トリのものと異なる必要がある場合には、手動で変更する必要があります。環
境変数 `CVSUMASK' を設定すれば、リポジトリに作成されるディレクトリやファ
イルの使用許可を管理できます。`CVSUMASK' は、作業ディレクトリのファイ
ル使用許可には影響しません。作業コピーの使用許可は、新たに作成したファ
イルに通常与えられるものと同じです。但し、CVS が読み込みだけを許可する
ことがあります(監視時 *Note Setting a watch::, -r 使用時 *Note Global
options::, `CVSREAD' 設定時 *Note Environment variables:: を各々参照)。

クライアント/サーバ CVS を使用すると (*Note Remote repositories::)、
`CVSUMASK' を設定する良い方法はありません。クライアントマシンでの設定
は効果がありません。`rsh' で接続しているなら、オペーレーティングシステ
ムの説明に書いてあるように、`.bashrc' や`.cshrc' で `CVSUMASK' を設定
することができます。この振る舞いは将来のバージョンの CVS では変更され
るかもしれません。クライアントの `CVSUMASK' の設定には頼らず、それは無
効になるでしょう。

pserver を使う場合は、一般的に、 CVSROOT ディレクトリと木構造でそれよ
り上のディレクトリには厳しい使用許可が必要です。*Note Password
authentication security:: を参照してください。

オペレーティングシステムには特定のプログラムが、プログラムの呼び手には
できないような動作をする能力とともに実行される機能があるものがあります。
例えば、unix の set user ID (setuid) や set group ID (setgid) 機能や
VMS の installed image 機能です。CVS はそのような機能を使用するように
書かれていませんので、そのような方法で CVS をインストールすると事故の
過失に対する保護しか提供できなくなります。方法を欺くことを試そうとして
いる人は誰でもそうすることができ、設定に応じて CVS だけに留まらない使
用許可を得るかもしれません。代わりに pserver を使用することを考えるか
もしれません。それは同じ属性のいくつかを共有していますので、間違ったセ
キュリティの設定や、修正したいものよりも大きなセキュリティホールを提供
する可能性がありますので、このオプションを考えているなら、pserver の説
明文書を注意深く読んでください。(*Note Password authentication
security::)。



File: cvs-ja.info, Node: Windows permissions, Next: Attic, Prev: File permissions, Up: Repository storage

Windows に特有なファイルの使用許可問題
--------------------------------------

ファイルの使用許可には Windows オペレーティングシステムに特有の問題も
あります (Windows 95, Windows NT, とおそらくこの系統の将来のオペレーティ
ングシステムです。以下の項目で OS/2 に当てはまることもあるでしょうが、
確かではありません)。

ローカルの CVS を使っていて、リポジトリが Samba SMB サーバによってネッ
トワーク接続されたファイルシステムにあるときに、使用許可で問題がおこる
ことがあることが報告されています。Samba の設定で WRITE=YES にすると修
正される/何とかなると言われています。責任放棄: 私はそのオプションを使
用可にしたときの副作用について十分な調査をしていません。加えて、問題を
避けるために CVS が違ったようにすることができるかどうかも調べていませ
ん。何か発見したなら、*Note BUGS:: に書かれているように我々に報せてく
ださい。



File: cvs-ja.info, Node: Attic, Next: Locks, Prev: Windows permissions, Up: Repository storage

The attic
---------

ときどき CVS は RCS ファイルを `Attic' に保存することがあることに気付
くでしょう。例えば、CVSROOT が `/usr/local/cvsroot' でディレクトリ 
`yoyodyne/tc' のファイル`backend.c' について話をしているとき、普通はファ
イルは以下のところにあります

     /usr/local/cvsroot/yoyodyne/tc/backend.c,v

しかし、attic に行けば、代わりに

     /usr/local/cvsroot/yoyodyne/tc/Attic/backend.c,v

になります。利用者にとってはファイルが attic にあるかどうかは関係あり
ません。CVS はこれを記録し、必要なときは attic を調べます。詳細を知り
たい人のために書くと、幹の先頭リビジョンが `dead' の状態であるまさにそ
のときだけ、ファイルは attic に保存されます。`dead' の状態とはそのリビ
ジョンでファイルが消去されたか、一度も加えられたことがない、ということ
です。例えば、枝にファイルを加えると、幹のリビジョンは`dead' の状態に
なり枝のリビジョンは `dead' ではない状態になります。



File: cvs-ja.info, Node: CVS in repository, Next: Locks, Prev: Attic, Up: Repository storage


リポジトリの CVS ディレクトリ
-----------------------------

それぞれのリポジトリのディレクトリの `CVS' ディレクトリはファイル属性
などの情報が収められています (`CVS/fileattr' というファイルです。)。将
来はこのディレクトリには他のファイルが加えられる可能性がありますから、
実装は追加のファイルを静かに無視するのが良いでしょう。

この動作は CVS 1.7 とその後のものだけで実装されています。詳細は*Note
Watches Compatibility:: を参照してください。

fileattr ファイルの書式は以下の形式の登録の連続したものです (`{' と 
`}' は括弧の中のテキストを0回以上繰り返すことができるということです):

ENT-TYPE FILENAME <tab> ATTRNAME = ATTRVAL {; ATTRNAME = ATTRVAL}
<linefeed>

ENT-TYPE はファイルでは `F' で、その場合は登録はそのファイルの属性を指
定します。

ENT-TYPE が `D' で、FILENAME が空であると、新しく追加されたファイルへ
の既定属性を指定します。

他の ENT-TYPE は将来の拡張のために予約されています。CVS 1.9 とそれ以前
のものはファイル属性を書き込むときにいつでもそれらを消すでしょう。CVS
1.10 とそれ以降はそれらを保存します。

行の順番は関係無いことに注意してください。fileattr ファイルを書き込む
プログラムは便利な様に再編成するかもしれません。

ファイル名でのタブとラインフィード、ATTRNAME での `=', ATTRVAL での 
`;'、などを引用する方法は今はありません。

習慣では、ATTRNAME は CVS により特別な意味を持っている属性は `_' で始
まります。他の ATTRNAME は使用者定義の属性のためにあります (もしくは、
実装が使用者定義の属性のサポートを始めたときにそうなるでしょう)。

作りつけの属性です:

`_watched'
     存在すると、ファイルが監視下にあり、読み込み専用で取り出すべきで
     あることを意味します。

`_watchers'
     このファイルを監視している使用者です。値はWATCHER > TYPE { ,
     WATCHER > TYPE } で、EDITOR は使用者名、VAL は 
     TIME+HOSTNAME+PATHNAME で、TIME は `cvs edit' コマンド (もしくは
     それと等価なもの) が発生したときで、HOSTNAME と PATHNAME は作業ディ
     レクトリのためです。

例:

     Ffile1 _watched=;_watchers=joe>edit,mary>commit
     Ffile2 _watched=;_editors=sue>8 Jan 1975+workstn1+/home/sue/cvs
     D _watched=

は `file1' は読み込み専用で取り出されるべきだということです。加えて、
joe は edit を監視しており、mary は commit を監視しています。ファイル 
`file2' は読み込み専用で取り出されるべきです。sue は 1975年1 月8日にマ
シン `workstn1' のディレクトリ `/home/sue/cs'編集を始めました。この例
を表現するために、`D', `Ffile1', `Ffile2' の後に空白を表示していますが、
実際は単独のタブ文字がそこにあり、空白があってはいけません。



File: cvs-ja.info, Node: Locks, Next: CVSROOT storage, Prev: Attic, Up: Repository storage

リポジトリの CVS ロック
-----------------------

利用者から見える部分の CVS のロックに焦点をあてた紹介は *Note
Concurrency:: を参照してください。次の部分は同じリポジトリをアクセスす
る他のツールに干渉することなく CVS のリポジトリにアクセスするようなツー
ルを書きたい人を対象にしています。"読み込みロック" ("read lock"), "書
き込みロック" ("write lock"), "デッドロック" ("deadlock") のような概念
がよくわからなかったら、オペレーティングシステムやデータベースの文献を
参照すると良いかもしれません。

リポジトリ中の `#cvs.rfl.' で始まる全てのファイルは読み込みロックです。
リポジトリ中の `#cvs.wfl' で始まる全てのファイルは書き込みロックです。
古いバージョンの CVS (CVS 1.5 以前) は `#cvs.tfl' で始まる名前のファイ
ルも作成していましたが、ここではそれらは議論しません。ディレクトリ 
`#cvs.lock' はマスターロックとして働きます。すなわち、他のロックを取得
する前に、まずこのロックを取得しなければならない、ということです。

書き込みロックを取得するためには、まず `#cvs.lock' ディレクトリを作成
します。この操作は原子的操作でなければなりません (これはたいていのオペ
レーティングシステムで真のはずです)。 既にディレクトリが存在したために
失敗すれば、しばらく待ってもう一度試します。`#cvs.lock' ロックを取得し
た後、`#cvs.rfl.' の後に選択した情報 (例えば、ホスト名とプロセス番号) 
が続いた名前のファイルを作成します。それからマスターロックを解放するた
めに `#cvs.lock' ディレクトリを消去します。それからリポジトリを読んで
続行します。終った後、読み込みロックを解放するために`#cvs.rfl' ファイ
ルを消去します。

書き込みロックを取得するためには、読み込みロックと同様にまず 
`#cvs.lock' ディレクトリを作成します。それから `#cvs.rfl.'  で始まるファ
イルが無いかどうかを調べます。もしあれば、`#cvs.lock' を消去し、しばら
く待って、もう一度試します。読み込み手がいないときは、`#cvs.wfl' の後
に選択した情報を続けた名前のファイルを作成します (例えば、ホスト名とプ
ロセス番号)。ロック `#cvs.lock' を続けます。リポジトリへの書き込みを実
行します。それが終わると、まず `#cvs.wfl' ファイルを消去し、それから 
`#cvs.lock' ディレクトリを消去します。`#cvs.rfl' ファイルと違って、
`#cvs.wfl' ファイルは情報提供のためだけにあることに注意してください。
`#cvs.lock' そのもののロックを続ける以上のロック操作の効果はありません。

それぞれのロック (書き込みロック及び読み込みロック) は `Attic' と`CVS' 
を含んだリポジトリの単独のディレクトリのみをロックしますが、バージョン
管理下の他のディレクトリは含まないことに注意してください。木全体をロッ
クするためには、それぞれのディレクトリをロックする必要があります (必要
なロックのどれかの取得に失敗したら、デッドロックを避けるために再挑戦の
前に木全体を解放しなければならないことに注意してください)。

CVS は個々の `foo,v' ファイルへのアクセス制御のために書き込みロックを
期待するということにも注意してください。RCS には `,foo,' ファイルがロッ
クとして働く機構がありますが、CVS はそれを実装しておらず、CVS の書き込
みロックを取り出すことが推奨されています。さらなる議論/合理性は CVS の
ソースコードの rcs_internal_lockfile のところのコメントを読んでくださ
い。



File: cvs-ja.info, Node: CVSROOT storage, Prev: Locks, Up: Repository storage

CVSROOT ディレクトリでファイルが保管される方法
----------------------------------------------

`$CVSROOT/CVSROOT' ディレクトリにはいろいろな管理ファイルがあります。
ある面ではこのディレクトリはリポジトリの他のディレクトリとよく似ていま
す。そこにはファイル名が `,v' で終わる多くの RCS ファイルがあり、多く
の CVS コマンドは同じ方法でそれを操作します。しかし、少しの違いはあり
ます。

それぞれの管理ファイルには、RCS ファイルに加えて、ファイルの取り出され
た版のコピーがあります。例えば、RCS ファイル `loginfo,v' とそれの最新
リビジョンであるファイル `loginfo' があります。管理ファイルを格納した
ときは、CVS は

     cvs commit: Rebuilding administrative file database

を印字し、`$CVSROOT/CVSROOT' の取り出された版のコピーを更新するように
なっています。もしそうならなければ、何かがおかしくなっています (*Note
BUGS::)。自分自身のファイルをこのように更新されるファイル群に追加する
ために、それらを管理ファイル `checkoutlist' に追加できます (*Note
checkoutlist::)。

初期設定では `modules' ファイルは上で説明されているように振舞います。
modules ファイルがとても大きくなると、普通のテキスト・ファイルとして保
存しているとモジュールの探索が遅くなるかもしれません (CVS が最初にこの
機能を追加したときほど関心があるかどうかは定かではありません。ベンチマー
クは見ていませんので)。ですから、CVS ソースコードに適切な修正を加える
ことで、modules ファイルを Berkeley db や GDBM のような `ndbm' インター
フェースを実装したデータベースで保存することができます。このオプション
が使用されると、modules データベースは`module.db', `modules' と/もしく
は `modules.dir' に保存されます。

いろいろな管理ファイルの意味に関する情報は *Note Administrative
files:: を参照してください。



File: cvs-ja.info, Node: Working directory storage, Next: Intro administrative files, Prev: Repository storage, Up: Repository

リポジトリでのデータの保存方法
==============================


しばしば表面に現れてくるかもしれない CVS の内部についての話をしている
間に、CVS が作業ディレクトリの `CVS' ディレクトリに何を入れるかも話し
た方が良いでしょう。リポジトリと同様に、CVS がこの情報を扱い、普通は 
CVS のコマンドを通してだけそれを使用します。でも、ときにはそれを覗くの
も良いでしょうし、グラフィカル・ユーザ・インターフェース の `jCVS' や 
emacs のための `VC' パッケージなどの他のプログラムがそれを見る必要があ
るかもしれません。そのようなプログラムは、上で書いたプログラムやコマン
ド行 CVS クライアントの将来のバージョンを含む、そのファイルを使う他の
プログラムと協調して動作しようと望むなら、この節の推奨規格に従う必要が
あります。

`CVS' ディレクトリには複数のファイルがあります。このディレクトリを読む
プログラムは、将来の拡張の余地を残すために、ディレクトリには存在するけ
れどここで説明されていないファイルは静かに無視するのが望ましいです。

ファイルは使用しているシステムのテキストファイルの習慣に従って保存され
ます。これはテキストファイルの保管の習慣が違うシステム間では作業ディレ
クトリは可搬性が無いということです。これは意図的になされていて、おそら
く CVS で管理されているファイル自体がそのようなシステム間では可搬性が
ないであろう、という理由に基づいています。

`Root'
     このファイルは *Note Specifying a repository:: で説明されているよ
     うに、現在の CVS のルートを保持しています。

`Repository'
     このファイルは現在のディレクトリが対応するリポジトリでのディレク
     トリを保持しています。指定は絶対パス名と相対パス名のどちらでも可
     能です。CVS は少なくともバージョン 1.3 くらいから両方の形式を読み
     込む能力を備えています。相対パスはルートからの相対位置で、より賢
     い方法ですが、絶対パス名は非常によく使われており、実装は両方を受
     け付けることが望まれます。例えば、以下のコマンドの後で

          cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc

     `Root' は以下のようになり

          :local:/usr/local/cvsroot

     `Repository' は

          /usr/local/cvsroot/yoyodyne/tc

     か

          yoyodyne/tc

     のどちらかになります。

     特定の作業ディレクトリがリポジトリのディレクトリに対応しなければ、
     `Repository' は `CVSROOT/Emptydir' になっているはずです。

`Entries'
     このファイルは作業ディレクトリ中のファイルとディレクトリの一覧を
     挙げています。各行の最初の文字はそれがどんな行かを示します。将来
     の拡張ができるように、文字を認識できない場合は、ファイルを読み込
     んでいるファイルは暗黙にその行を飛ばすことが望まれます。

     最初の文字が `/' であれば、様式は:

          /NAME/REVISION/TIMESTAMP[+CONFLICT]/OPTIONS/TAGDATE

     で、`[' と `]' は登録の一部ではありませんが、その代わりに `+' と
     衝突の印は省略任意であることを示しています。NAME はディレクトリ中
     のファイルの名前です。REVISION は作業中のファイルの元のリビジョン
     で、`0' の場合は追加されたファイル、`-' の後にリビジョンは削除さ
     れたファイルです。TIMESTAMP は CVS がファイルを作成したときのタイ
     ムスタンプです。タイムスタンプがファイルの実際の修正時刻と違えば、
     ファイルは修正されたということです。それは ISO C astime() 関数で
     使われる様式で保存されます (例えば、`Sun Apr 7 01:29:26 1996')。
     ファイルが常に修正されていると見なされるように、例えば、`Result
     of merge' のようにその様式とは違う文字列を書くかもしれません。こ
     れは特別な場合ではありません。ファイルが修正されたかどうかを調べ
     るために、プログラムはファイルのタイムスタンプを単純に TIMESTAMP 
     と文字列比較をするべきです。衝突があれば、CONFLICT は、ファイルが
     衝突の印とともに書き込まれた後でファイルの修正時刻に設定すること
     ができます (*Note Conflicts example::)。 もし CONFLICT がその後も
     実際の修正時刻と同じであるなら、ユーザは明かに衝突を解消していま
     せん。OPTIONS は貼り付けられたオプションを保持しています (例えば、
     バイナリ・ファイルのための `-kbd')。TAGDATE は `T' の後にタグ名が
     続いているか、日付 (date) の `D' で、貼り付けられたタグか日付がつ
     づいているかのどちらかを保持しています。TIMESTAMP が単独のタイム
     スタンプではなく、スペースで分離されたタイムスタンプの対であるな
     ら、CVS 1.5 より前のバージョンの CVS を扱っているということに注意
     してください (ここでは説明されていません)。

     CVS/Entries のタイムスタンプの標準時 (ローカルもしくは共通時) は
     オペレーティングシステムがファイル自身のタイムスタンプとして保存
     するものと同じである必要があります。例えば、Unix ではファイルのタ
     イムスタンプは共通時刻 (UT) ですので、CVS/Entries のタイムスタン
     プもそうなっているべきです。VMS ではファイルのタイムスタンプはロー
     カル時刻なので、VMS 上の CVS はローカル時刻を使うべきです。この規
     則は、標準時が変わったためだけでファイルが修正されたようにならな
     いためです (例えば、サマータイムになったり、それが終わったときな
     どです)。

     `Entries' の行の最初の文字が `D' であると、それはサブディレクトリ
     を現しています。行が `D' だけのときは、 `Entries' ファイルを書い
     たプログラムはサブディレクトリを記録したということを現します (で
     すから、そのような行があって、他に `D' で始まる行がなければ、サブ
     ディレクトリがないことがわかります)。そうでなければ、行は次のよう
     になっています:

          D/NAME/FILLER1/FILLER2/FILLER3/FILLER4

     ここで NAME はサブディレクトリの名前であり、将来の拡張のために、
     全ての FILLER 部分は暗黙の内に無視されるべきです。`Entries' を修
     正するプログラムはこれらの部分を保存するのが望まれています。

     ファイル `Entries' 中の行はどんな順番でも構いません。

`Entries.Log'
     このファイルは `Entries' に無いさらなる情報を記録することはありま
     せんが、`Entries' ファイル全体を再書き込みすることなく、情報を更
     新するための方法をもたらし、その中には `Entries' と `Entries.Log' 
     を書いているプログラムが不意に異常終了しても情報を保護する機能も
     あります。`Entries' ファイルを読み込むプログラムは`Entries.Log' 
     も調べるべきです。後者が存在すれば、`Entries' を読み込んで、
     `Entries.Log' にある変更を適用すべきです。変更を適用した後で、
     `Entries' を再度書き込んで、`Entries' を消去する習慣が推奨されて
     います。`Entries.Log' の行の様式は、単独文字コマンドがあり、その
     後にスペースが続き、その後は `Entries' の行に指定された様式になり
     ます。単独文字コマンドは登録が追加されたことを示す`A' と登録が消
     去されたことを示す `R' か、`Entries' の登録行は暗黙に無視されるべ
     きことを示す他の文字です (将来の拡張のため)。2 番目の文字が 
     `Entries.Log' の行の2番目の文字がスペースでないと、それは CVS の
     古いバージョンで書かれています (ここでは説明されていません)。

     読み込みではなく、書き込みをしているプログラムは、もし望むならば
     `Entries.Log' ファイルを安全に無視することもできます。

`Entries.Backup'
     これは一時ファイルです。推奨された使用法は、新しい Entriy ファイ
     ルを `Entries.Backup' に書き、それから `Entries' に改名する (もし
     可能なら原子的操作で) ことです。

`Entries.Static'
     このファイルが関連する唯一のことはそれが存在するか否か、というこ
     とです。もし存在すると、ディレクトリの一部分だけが取得されていて、
     CVS はそのディレクトリに追加のファイルを作成しないということです。
     それを消去するためには、`update' コマンドを `-d' オプションととも
     に使ってください。そうすれば、追加のファイルを取得して、
     `Entries.Static' を消去します。

`Tag'
     このファイルはディレクトリごとの貼り付いたタグを保持します。最初
     の文字は枝のタグには `T'、枝でないタグは `N'、日付は `D' になり、
     他の文字は、将来の拡張のため暗黙に無視されるべきとなっています。
     この文字の後にタグや日付が続きます。ディレクトリごとの貼り付きタ
     グや日付は新規に追加されたファイルに適用されること等に使用される
     ことに注意してください。貼り付きタグと日付に関する一般的な情報は 
     *Note Sticky tags:: を参照してください。

`Checkin.prog'
`Update.prog'
     これらのファイルはそれぞれ modules ファイルの `-i' と `-u' オプショ
     ンで指定されたプログラムを保存します。

`Notify'
     このファイルはまだサーバに送信されていない通知 (例えば、`edit' や 
     `unedit' のため) を保存します。書式はまだここでは説明されていませ
     ん。

`Notify.tmp'
     このファイルと `Notify' の関係は `Entries.Backup' と `Entries' の
     関係と同じです。即ち、`Notify' を書くためにはまず新しい内容を 
     `Notify.tmp' に書き、それから (可能であれば自動的に) それを 
     `Notify' に改名します。

`Base'
     監視を使用していると、`edit' コマンドはファイルの元のコピーを 
     `Base' ディレクトリに保存します。これで、サーバと通信できないとき
     でさえ `unedit' コマンドが実行できるようになります。

`Baserev'
     このファイルは `Base' ディレクトリのそれぞれのファイルのリビジョ
     ンを一覧にします。書式は:

          BNAME/REV/EXPANSION

     で、EXPANSION は将来の拡張のために、無視されるべきものです。

`Baserev.tmp'
     このファイルと `Baserev' の関係は `Entries.Backup' と`Entries' と
     の関係と同じです。即ち、`Baserev' に書くために、まず新しい内容を 
     `Baserev.tmp' に書き、それから (もし可能なら自動的に) それを 
     `Baserev' に改名します。

`Template'
     このファイルには `rcsinfo' ファイルで指定された雛型が入っています
     (*Note rcsinfo::)。それはクライアントだけに使われます。非クライア
     ント/ サーバ型 CVS は直接 `rcsinfo' ファイルを調べます。



File: cvs-ja.info, Node: Intro administrative files, Next: Multiple repositories, Prev: Working directory storage, Up: Repository

管理用ファイルの紹介
====================


`$CVSROOT/CVSROOT' には、いくつか "管理用ファイル" ("administrative
files") があります。完全な説明は *Note Administrative files::. これら
のファイルが無くても CVS を使用することができます。しかし、少なくとも 
`modules' というファイルが適切に設定してあれば CVS のコマンドはうまく
働きます。

管理用ファイルの中で、最も重要なファイルは `modules' です。これはリポ
ジトリの中の全てのモジュールを定義しています。`modules' ファイルの例を
次に示します。

     CVSROOT         CVSROOT
     modules         CVSROOT modules
     cvs             gnu/cvs
     rcs             gnu/rcs
     diff            gnu/diff
     tc              yoyodyne/tc

`modules' ファイルは行ごとに意味を持つファイルです。`modules' ファイル
の各行はそれぞれ、モジュール名, 空白, モジュールのあるディレクトリ名と
いう書式で記述されます。モジュールのあるディレクトリ名は、`$CVSROOT' 
からの相対パスです。`modules' ファイルの各行はそれぞれ、モジュール名, 
空白, モジュールのあるディレクトリ名という書式で記述されます。モジュー
ルのあるディレクトリ名は、`$CVSROOT' からの相対パスです。上の例の最後
の4行はそのような行の例です。


モジュール `modules' を定義する行については、ここでは説明しません。よ
り詳しい説明は *Note modules:: 参照。


管理用ファイルの編集
--------------------

管理用ファイルは、他のモジュールと同じ方法で編集します。`cvs checkout
CVSROOT' を用いて作業コピーを取り出して、編集し、通常通り変更内容を格
納します。

間違いのある管理用ファイルを格納することも可能です。このような場合には、
間違いを正して新たなリビジョンを登録します。しかし管理用ファイルに深刻
な間違いがあれば、新たなリビジョンの登録さえも不可能になります。



File: cvs-ja.info, Node: Multiple repositories, Next: Creating a repository, Prev: Intro administrative files, Up: Repository

複数のリポジトリ
================

特定の状況では一つ以上のリポジトリを持つことは良い考えです。例えば二つ
のプロジェクトがあり、全くコードが重複しないような場合です。複数のリポ
ジトリ持つためにはしなければならないことは、適切なリポジトリを、環境変
数 `$CVSROOT' で設定するか、CVS のオプション `-d' に指定するか、もしく
は、(一度作業ディレクトリを取り出せば) 単純に CVS に作業ディレクトリ取
り出しに使われたリポジトリを使わせる、ということだけです。

複数のリポジトリを持つ大きな利点は、各々を別のサーバに置けることです。
CVS バージョン 1.10 では、単独のコマンドは違うリポジトリのディレクトリ
を再帰的に辿ることはできません。開発バージョンの CVS では、複数のサー
バから作業ディレクトリに取り出すことがでます。CVS は要求されたコマンド
を実行するために必要であれば、再帰的に動作し、対応する数のサーバ・マシ
ンに接続するという細い作業全部を扱います。以下は作業ディレクトリを設定
する例です:

     cvs -d server1:/cvs co dir1
     cd dir1
     cvs -d server2:/root co sdir
     cvs update

`cvs co' コマンドは作業ディレクトリを設定し、それから `cvs update' コ
マンドは server2 に接続し、dir1/sdir サブディレクトリを更新し、その他
のものを更新するために server1 に接続します。



File: cvs-ja.info, Node: Creating a repository, Next: Backing up, Prev: Multiple repositories, Up: Repository

リポジトリの作成
================


CVS リポジトリを設定するために、まずソースファイルのリビジョン履歴を保
存したいマシンとディスクを選びます。CPU とメモリの要求は小さなものです
ので、たいていのマシンは十分なはずです。詳細は *Note Server
requirements:: を参照してください。

ディスクスペースの必要量を見積もると、別のシステムから RCS ファイルを
移管しているのであれば、リポジトリの最初の大きさは大体そのくらいになり、
バージョンの履歴が全然無い状態で始めるのであれば、大雑把な大きさはリポ
ジトリのCVS の管理下に置かれるコードのほぼ3倍をサーバで用意することに
なります (最終的にはこれより大きくなるでしょうが、しばらくは大丈夫なは
ずです)。開発者が作業するマシンでは各開発者に作業ディレクトリとほぼ同
じディスクスペースを用意すると良いでしょう (各開発者の利用に基づいて、
全体の木かそれの一部分のどちらかになります)。

リポジトリはサーバ経由からか直接 CVS を使う全てのマシンからか、(直接も
しくはネットワーク接続されたファイルシステム経由で) 利用可能にする必要
があります。クライアントのマシンは CVS プロトコル経由以外でそれにアク
セス可能である必要はありません。CVS は、リポジトリにロック・ファイルを
作成する必要があるため (*Note Concurrency::)、利用者が読み込み許可しか
持たないリポジトリを、CVS から使うことはできません。

リポジトリを作成するときには、`cvs init' コマンドを実行して下さい。通
常の方法で指定された CVS のルート (*Note Repository::) 以下の、空のリ
ポジトリを利用できるように整えます。例えば次のようにします。

     cvs -d /usr/local/cvsroot init

`cvs init' は注意深いので、リポジトリに存在するファイルを上書きしませ
ん。従って既に利用できる状態のリポジトリに対して `cvs init' を実行して
も、何の不都合もありません。

`cvs init' は、操作履歴を記録するように設定します。もしこれを望まない
のであれば、`cvs init' を実行した後に、`history' ファイルを削除して下
さい。*Note history file::.



File: cvs-ja.info, Node: Backing up, Next: Moving a repository, Prev: Creating a repository, Up: Repository

リポジトリのバックアップ
========================

リポジトリ中のファイルに関して、特に魔法のような事はありません。ほとん
どの場合、他のファイルと同様にバックアップできます。しかし、考慮すべき
点も幾つかあります。

最初の点は偏執的で、バックアップ中には CVS を使用しないか、バックアッ
プ中はバックアッププログラムに CVS をロックさせる必要があります。CVS 
を使わないために、リポジトリを操作できるマシンへのログインを禁止したり、
CVS サーバを停止したり、同様な機構を利用するかもしれません。詳細はあな
たのオペレーティングシステムと、CVS を設定した方法に依存します。CVS を
ロックするためには、`#cvs.rfl' ロックをそれぞれのリポジトリのディレク
トリに作成するでしょう。このように言ってきましたが、これらの事前注意を
せずにただバックアップを行なっても、結果が特に悲惨になる可能性はあまり
ありません。バックアップから復元すると、リポジトリは不整合状態になるか
もしれませんが、手で修正することが非常に難しいということは無いでしょう。

リポジトリをバックアップから復元し、リポジトリ中の変更がバックアップ時
から変更されていると仮定すると、失敗に影響を受けなかったディレクトリは
今やリポジトリに存在しなくなってしまったリビジョンを参照しているかもし
れません。そのようなディレクトリで CVS を実行しようとすると、普通はエ
ラーメッセージを出力します。これらの変更をもう一度リポジトリに戻す方法
の一つに以下のようなものがあります:

   * 新しい作業ディレクトリを取得します。

   * 失敗前に作業ディレクトリからファイルをコピーします (もちろん、
     `CVS' ディレクトリの内容をコピーしないでください)。

   * 新しい作業ディレクトリで作業をし、`cvs update' や `cvs diff' のよ
     うなコマンドを使って何が変更されたかを見つけ、準備ができたなら、
     変更をリポジトリに格納します。



File: cvs-ja.info, Node: Moving a repository, Next: Remote repositories, Prev: Backing up, Up: Repository

リポジトリの移動
================

リポジトリ中のファイルのバックアップが他のファイルのバックアップと良く
似ているように、リポジトリを別の場所に移動する必要があるときも、それは
他のファイルの集合を移動するのと非常に良く似ています。

主に考慮することは、作業ディレクトリがリポジトリを指しているか、という
ことです。移動されたリポジトリを扱う一番簡単な方法は、移動後にただ新し
い作業ディレクトリを取得することです。もちろん、移動前に古い作業ディレ
クトリが格納されたかを確かめたいでしょう。もしくは変更を失わないような
何らかの他の方法を見つけているかもしれません。もし本当に既に存在する作
業ディレクトリを再利用したいなら、`CVS/Repository' ファイルを手で手術
することで可能です。`CVS/Repository' と `CVS/Root' ファイルの情報は 
*Note Working directory storage:: で参照することができますが、わずらい
たいと本当に思っていないかぎりは、労力に見合わないでしょう。



File: cvs-ja.info, Node: Remote repositories, Next: Read-only access, Prev: Moving a repository, Up: Repository

別のマシンのリポジトリ
======================

ソースの作業コピーはリポジトリと別のマシンに存在することができます。
CVS をこの方法で使うことは "クライアント/サーバ" ("client/server") 操
作として知られています。"クライアント" として、CVS を作業ディレクトリ
を mount できるマシンで CVS を実行し、"サーバ" となる、リポジトリを 
mount できるマシンと通信するように告げます。一般的に、遠隔リポジトリを
使うことは、リポジトリ名の様式が以下のようになることを除き、ローカルの
ものを使うのと同じです:

     :METHOD:USER@HOSTNAME:/path/to/repository

どれが本当に設定する必要があるかは、サーバに接続している方法に依って変
わります。

METHOD が指定されず、リポジトリ名に `:' が含まれる場合には、使用するオ
ペレーティングシステムに依って `ext' か `server' が既定値とされます。
詳しくは *Note Connecting via rsh:: 参照。

* Menu:

* Server requirements::         サーバのためのメモリと他の資源
* Connecting via rsh::          接続に `rsh' プログラムを利用する
* Password authenticated::      パスワードを利用して直接接続する
* GSSAPI authenticated::        GSSAPI を利用して直接接続する
* Kerberos authenticated::      ケルベロスを利用して直接接続する
* Connecting via fork::         接続に fork された `cvs server'を使う



File: cvs-ja.info, Node: Server requirements, Next: Connecting via rsh, Prev: Remote repositories, Up: Remote repositories

サーバの要求
------------

サーバとしてどんな種類のマシンが適切かという質問への手短な答は、要求は
こじんまりとしたものであるということです--32M のメモリやそれ以下のサー
バでさえ、かなり大きなソース木とかなりの量の活動を扱うことができます。

もちろん、本当の答はもっと複雑です。既知の大量のメモリ消費をする部分の
見積りは、メモリの要求を見積るのに十分でしょう。ここにはそのような部分
が2つ書いてあります。他のメモリ消費は比較的小さいはずです (もしそうで
ないものがあれば、この説明文書を更新できるように、*Note BUGS:: に書か
れているように、我々に知らせてください)。

大量のメモリ消費をする最初の部分は、CVS サーバを使っているときの大きな
取り出しです。サーバは、扱っているそれぞれのクライアントのための2つの
プロセスからなります。子プロセスのメモリ消費は非常に少く抑えられている
はずです。親プロセスのメモリ消費は、特にクライアントとのネットワーク接
続が遅ければ、一つのディレクトリのソースの大きさよりも少し大きくなるか、
2メガバイトほどかどちらか大きいものになることが予想されています。

それぞれの CVS サーバの大きさを予想上の一度に活動するサーバ数で掛けた
ものによって、サーバのメモリの要求の輪郭を得ることができます。たいてい
の場合、親プロセスでのメモリ消費は物理メモリではなくてスワップメモリで
しょう。


大量のメモリ消費の2番目の部分は、大きなファイルを格納しているときの
`diff' です。これはバイナリ・ファイルでさえも必要です。大体の目安は、
格納したい最大のファイルの大きさの10倍を用意することですが、5倍が適当
でしょう。例えば、10メガバイトのファイルを格納したいときは、格納をする
マシン (クライアント/サーバ ならサーバマシン、クライアント/サーバ でな
ければ、CVS を実行しているマシン) に100メガバイトのメモリがあるのが良
いです。これは物理メモリでなく、スワップであるかもしれません。メモリが
必要なのは短時間だけなので、そのような格納が同時に2つ以上なされるとき
のためのメモリを準備する必要は特にありません。

クライアントの資源消費はさらに少ないです--オペレーティングシステムを動
作させるために十分な能力のあるマシンなら、ほとんど問題はないでしょう。

ディスク容量に対する要求の情報は、*Note Creating a repository:: を参照
してください。



File: cvs-ja.info, Node: Connecting via rsh, Next: Password authenticated, Prev: Server requirements, Up: Remote repositories

rsh で接続する
--------------

CVS はこれらの操作を実行するために `rsh' プロトコルを用いますので、遠
隔側の使用者のホストはローカルの使用者の接続を許可する`.rhosts' を持つ
必要があります。

例えば、あなたがローカルマシン `toe.example.com' の利用者`mozart' であ
り、サーバマシンは `faun.example.org' であるとしましょう。faun では、
以下の行を `bach' のホームディレクトリの `.rhosts' ファイルに書いてく
ださい:

     toe.example.com  mozart

そして、`rsh' の動作を次の行で確認します。

     rsh -l bach faun.example.org 'echo $PATH'

次に `rsh' が、サーバを発見できるかどうか確認する必要があります。上記
の例で `rsh' が表示したパスの中に、サーバである `cvs' のあるディレクト
リが含まれているかどうか確認して下さい。`.login' や `.profile' でなく、
`.bashrc', `.cshrc' 等にパスを設定する必要があります。代わりに、クライ
アント側で環境変数 `CVS_SERVER' に、`/usr/local/bin/cvs-1.6' などと、
使用したいサーバ名を設定できます。

`inetd.conf' を編集したり、CVS のサーバ・デーモンを走らせる必要はあり
ません。

`rsh' 経由で `CVSROOT' を利用するときに指定できる接続経路は二つありま
す。`:server:' を指定した場合、CVS が内部実装した `rsh' のクライアント
が用いられますが、移植版では利用できないものもあります。`:ext:' を指定
した場合、外部の `rsh' プログラムが用いられます。`rsh' が既定となって
いますが、サーバを利用できる他のプログラムを呼び出す場合は、環境変数 
`CVS_RSH' に設定して下さい (例えば HP-UX 9 では、`rsh' は何か別のもの
なので `remsh' を用いて下さい)。指定するプログラムは、データを変更しな
いで送受信できなくてはいけません。例えば Windows NT の `rsh' は、既定
では CRLF を LF に換えるので不適当です。CVS の OS/2 版はこれを回避する
ため、`rsh' に `-b' を渡して切り抜けていますが、標準的な `rsh' でない
プログラムを黙認する形になるので、将来は別のやり方になるでしょう。
`CVS_RSH' に `SSH' 等の `rsh' の代替物を設定した場合、この節の残りの 
`.rhosts' の使用説明などは、おそらく不適当でしょうから、各 `rsh' の代
替物の文書資料を参照して下さい。

例を続けます。仮に `faun.example.org' のリポジトリ 
`/usr/local/cvsroot/' 中のモジュール `foo' を利用したい場合には、もう
準備はできています:

     cvs -d :ext:bach@faun.example.org:/usr/local/cvsroot checkout foo

(クライアント側とサーバ側で、使用者名が同じ場合には、`bach@' を省略す
ることが出来ます。)




File: cvs-ja.info, Node: Password authenticated, Next: GSSAPI authenticated, Prev: Connecting via rsh, Up: Remote repositories

パスワード認証による直接接続
----------------------------

CVS のクライアントは、パスワード・プロトコルを用いて、サーバと接続する
こともできます。この方法は、`rsh' の使用が可能でなく (例えばサーバが防
火壁の向こうにある場合)、またケルベロスも利用できない場合に特に有効で
す。

この方法を使用するために、サーバとクライアント双方での調整が必要になり
ます。

* Menu:

* Password authentication server::     サーバ側の設定
* Password authentication client::     クライアントの使用
* Password authentication security::   この方法が何をして何をしないか



File: cvs-ja.info, Node: Password authentication server, Next: Password authentication client, Prev: Password authenticated, Up: Password authenticated

パスワード認証のためのサーバの設定
..................................

まず最初に、`$CVSROOT' と `$CVSROOT/CVSROOT' ディレクトリの使用許可を
きつくすることを考えるでしょう。詳細は *Note Password authentication
security:: を参照してください。

サーバ側では `/etc/inetd.conf' を編集する必要があります。正しいポート
に接続を受けた時、`inetd' がコマンド `cvs pserver' を実行する様に変更
します。ポート番号の既定値は 2401 ですが、クライアントをコンパイルした
時に、`CVS_AUTH_PORT' に他の値を定義した場合には異なります。

あなたの使用する `inetd' が、ポート番号を素のまま `/etc/inetd.conf' に
書いて良いならば、次の記述で十分でしょう (`inetd.conf' には一行で記述
して下さい):

     2401  stream  tcp  nowait  root  /usr/local/bin/cvs
     cvs -f --allow-root=/usr/cvsroot pserver

`-T' オプションで一時ファイルを作成するディレクトリも指定できます。

`--allow-root' オプションは使用可能な CVSROOT ディレクトリを指定します。
違う CVSROOT ディレクトリの使用を試みるクライアントは接続できません。
許可したい CVSROOT ディレクトリが2つ以上あるなら、オプションを繰り返し
てください。(不幸なことに、`inetd' の多くのバージョンはコマンドと引数
の両方、もしくはどちらかの長さ全体に対して非常に小さくなるように制限を
課しています。この問題に対する普通の解決は、`inetd' に CVS を必要な引
数と共に起動するシェルスクリプトを実行させることです。)

あなたの使用する `inetd' が、素のポート番号ではなく、サービス名を要求
するならば、`/etc/services' に次の行を追加して下さい:

     cvspserver      2401/tcp

そして `inetd.conf' には、`2401' ではなく `cvspserver' と記述して下さ
い。

以上を注意して行なった後、`inetd' を再起動するか、初期設定ファイルを再
読させるのに必要な処置を取って下さい。

これの設定に問題があるときは、*Note Connection:: を参照してください。

クライアントはパスワードを平文のまま保存または伝送します (ほぼそのよう
に--詳細は *Note Password authentication security::)。従って、リポジト
リを利用する時に、正規のパスワードを危険に曝さないために、CVS では普通
は別のパスワードファイルを使用します。このファイルは 
`$CVSROOT/CVSROOT/passwd' です。欄が少ないことを除けば、Unix システム
での `/etc/passwd' と同様にコロンで分割した書式を使います: CVS 使用者
名、省略可能なパスワード、認証が成功したかのように実行するためにサーバ
が使用する任意に省略可能な使用者名です。次に5つの登録がある `passwd' 
ファイルを例示します:

     anonymous:
     bach:ULtgRLXo7NRxs
     spwang:1sOp854gDF3DY
     melissa:tGX1fS8sun6rY:pubcvs
     qproj:XR4EZcEs0szik:pubcvs

パスワードは、標準 Unix の関数 `crypt()' によって暗号化されます。従っ
て、標準 Unix の `/etc/passwd' から直接コピーすることも可能です。

例の最初の行は使用者 `anonymous' として認証しようとする全ての CVS クラ
イアントに空パスワードなど、パスワードに関わらず、使用を許可します。
(これは匿名読み込み専用アクセスを許可するサイトでよくすることです。"読
み込み専用" の方法は *Note Read-only access:: を参照してください。)

2行目と3行目は `bach' と `spwang' がそれぞれ平文のパスワードを提供した
場合にアクセスを許可します。

4行目は `mellisa' が正しいパスワードを使用したときにアクセスを許可しま
すが、彼女の CVS での操作はサーバではシステムユーザ `pubcvs' として行
われます。ですから、`melissa' という名前のシステム使用者は必要ではあり
ませんが、`pubcvs' という名前の使用者は存在している必要が*あります*。

5行目はシスステムユーザは共有できることを示しています。`qproj' として
認証を成功した全てのクライアントは `melissa' と同様に、実際は`pubcvs' 
でして実行します。そのようにすることで、リポジトリ中にそれぞれのプロジェ
クトごとに単独の共有ユーザを作成することができ、それぞれの開発者に 
`$CVSROOT/CVSROOT/passwd' ファイルで専用の行を与えることができます。そ
れぞれの行の CVS 使用者名は違うかもしれませんが、システムの使用者名は
同じです。別の CVS 使用者名を使う理由は、CVS は操作をそれらの名前で記
録するからです: `melissa' が変更をプロジェクトに書き込むと、その格納は
プロジェクトの履歴に `pubcvs' ではなく、`melissa' の名前で記録されます。
システムのユーザ名を共有する理由は、リポジトリの該当する部分の使用許可
を、そのアカウントのみが書き込み許可を持つように設定することができるか
らです。

CVS はシステム認証を行なうこともできます。パスワード認証では、まずサー
バが、`$CVSROOT/CVSROOT/passwd' ファイル中の、使用者のエントリを確認し
ます。使用者のエントリがあれば、そのエントリを上で説明された様に認証に
使用します。ユーザを発見できないか、CVS の `passwd' ファイルが存在しな
い場合には、オペレーティングシステムの使用者の調査機構を使って使用者名
とパスワードとの認証を試すことができます。(この失敗時の動作は `config' 
ファイルで `SystemAuth=no' を設定することで、使用不能にすることができ
ます)。しかしながら、システムの認証に立ち戻ることは安全性の面で危険を
冒すことになるかもしれないことには注意してください: CVS の操作はそのユー
ザの普通のログインパスワードで認証され、パスワードはネットワークを平文
で流れます。詳しくは *Note Password authentication security:: を参照し
てください。

現在、CVS の `passwd' ファイルにパスワードを加えるには、他のどこかから
コピーするしか方法がありません。いつの日か `cvs passwd' コマンドができ
ることでしょう。

`$CVSROOT/CVSROOT' の多くのファイルと違って、`passwd' ファイルは CVS 
経由ではなく、直接編集するのが普通です。これは`passwd' ファイルが作業
コピーに含まれているセキュリティの危険性のためです。`passwd' ファイル
を `$CVSROOT/CVSROOT' をチェックアウトに含めたい場合は *Note
checkoutlist:: を参照してください。



File: cvs-ja.info, Node: Password authentication client, Next: Password authentication security, Prev: Password authentication server, Up: Password authenticated

パスワード認証によるクライアントの使用
......................................
CVS コマンドをパスワード認証サーバを通じて遠隔リポジトリで実行するため
には、`pserver' プロトコル、使用者名、リポジトリのホスト、リポジトリへ
のパスを指定します。例えば:

     cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout someproj

もしくは、

     CVSROOT=:pserver:bach@faun.example.org:/usr/local/cvsroot
     cvs checkout someproj

しかし、全員に使用可能なリポジトリ (すなわち、使用者名がパスワードを要
求しないもの) でない限り、最初に "ログイン" しなければなりません。ログ
インはリポジトリのパスワードを認証します。これは `login' コマンドで行
われ、対話的にパスワード認証を促します。

     cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot login
     CVS password:

パスワードを入力し終わると、CVS がサーバで認証します。認証が成功すれば、
その使用者名、ホスト、リポジトリ、パスワードが永久に記録されます。です
から、将来のリポジトリでの通信は `cvs login' の実行を要求しません。(認
証が失敗すれば、CVS はパスワードが正しくないことを言った後終了し、何も
記録されません。)

既定では、登録はファイル `$HOME/.cvspass' に保存されます。ファイルの形
式は人間が読めるもので、ある程度人間が編集可能でもありますが、パスワー
ドは平文で保存されているのではないことは注意してください--それらは "純
真な" 侵入 (つまり、システム管理者や他の悪意のない人間が不注意に見ると
いった事) を防ぐため、簡単な符号化がされています。

このファイルの既定の場所を `CVS_PASSFILE' 環境変数を設定することで変更
することができます。この変数を使用するのであれば、`cvs login' を実行す
る*前に*設定しなければいけません。`cvs login' を実行した後に設定した場
合、その後の CVS コマンドは、サーバに送るパスワードを見付けられません。

一度ログインをすると、その遠隔リポジトリを使う全ての CVS のコマンドは
保存されたパスワードで認証します。ですから、例えば

     cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout foo

はそのまま動作します (サーバ側でパスワードが変更されない限り。その場合
は `cvs login' をもう一度実行する必要があります)。

リポジトリ指定中に `:pserver' が存在していなければ、CVS は変わりに 
`rsh' で接続すると仮定することに気を付けてください(*Note Connecting
via rsh::)。

もちろん、一度作業コピーを取り出してそこから CVS のコマンドを実行して
いれば、明示的にリポジトリを指定する必要は無くなります。というのは、
CVS は作業コピーの `CVS' サブディレクトリから導き出すことができるから
です。

任意の遠隔リポジトリのパスワードは `cvs logout' コマンドを使用すると 
`CVS_PASSFILE' から消去できます。



File: cvs-ja.info, Node: Password authentication security, Prev: Password authentication client, Up: Password authenticated

パスワード認証における安全性の考察
..................................

パスワードは、平文を簡単に符号化してクライアント側に保存されており、送
信の際も同じ符号化が用いられます。この符号化は、パスワードが偶然見られ
ること (すなわちシステム管理者が不注意に見てしまう事) を防ぐためのもの
で、素人の攻撃からパスワードの取得を防ぐことさえ出来ません。

CVS 独自のパスワードファイルにより (*Note Password authentication
server::)、リポジトリを利用する時には、システムにログインする時とは別
のパスワードが使用できます。しかし、一旦リポジトリが読み込み専用でない
状態で利用可能になれば、多様な方法により、サーバ上でプログラムが実行可
能になります。つまりリポジトリの利用は、かなり広範囲にシステムが利用で
きる事を暗示しています。これを防止するように CVS を修正する事は可能で
しょうが、これを書いている時点までには誰もやっていません。

`$CVSROOT/CVSROOT' ディレクトリには `passwd' と他のセキュリティを調べ
るために使われるファイルがあるので、このディレクトリの使用許可をを 
`/etc' と同じくらいきつくしなければならないことに注意してください。同
じことが `$CVSROOT' ディレクトリそのものと、木のそれより上の部分のすべ
てのディレクトリにもあてはまります。そのようなディレクトリに書き込み許
可のある全ての人はシステムの任意の使用者になることができます。これらの
使用許可は普通は pserver を使っていないときに使用するものよりもきつい
ものであることに注意してください。

要約すると、パスワードを得た人物は誰でもリポジトリを利用できます(これ
はまたある程度通常のシステム利用も可能になるということを含むかもしれま
せん。) ネットワークのパケットを漁ったり、保護された (つまり所有者のみ
読み込み可能な) ファイルを読むことができる、全ての人物がパスワードを入
手可能です。あなたが本物の安全を望むのならば、ケルベロスにしましょう。



File: cvs-ja.info, Node: GSSAPI authenticated, Next: Kerberos authenticated, Prev: Password authenticated, Up: Remote repositories

GSSAPI による直接接続
---------------------

GSSAPI は ケルベロス5のようなネットワークセキュリティシステムとの一般
的なインターフェースです。動作する GSSAPI ライブラリを持っているなら、
CVS を GSSAPI で認証して、直接 TCP 接続を通して接続することができます。

これをするためには、CVS が GSSAPI サポート付きでコンパイルされている必
要があります。CVS を configure しているときに、ケルベロス version 5 を
使う GSSAPI ライブラリが存在するかどうかを発見しようとします。構築する
ために `--with-gssapi' も使用できます。

接続は GSSAPI を使って認証されますが、メッセージストリームは既定では認
証*されません*。ストリームの認証を要求するためには、広域オプション 
`-a' を使用する必要があります。

既定状態では、データ転送は暗号化*されません*。クライアントとサーバ双方
を、暗号化を有効にしてコンパイルしておく必要があります。構築時に 
`--enable-encryption' オプションを付加して、暗号化機能を有効にして下さ
い。また暗号化を要求するために、使用時に広域オプション `-x' を付加する
必要があります。

GSSAPI 接続はパスワード認証サーバを扱うのと同じサーバのサーバ側で扱わ
れます。*Note Password authentication server:: 参照。ケルベロスのよう
な強い認証を提供する GSSAPI 機構を使用しているなら、平文のパスワードに
よる認証を使用不能にしたいと思うかもしれません。そのためには、空の 
`CVSROOT/passwd' パスワードファイルを作成して、config ファイルで 
`SystemAuth=no' を設定します (*Note config::)。

GSSAPI サーバは cvs/HOSTNAME の主な名前を使い、HOSTNAME はサーバーホス
トの正式な名前です。あなたの GSSAPI 機構で要求されているようにこれを設
定しなければなりません。

GSSAPI を使用して接続するには、`:gserver:' を使用します。例えば、以下
のようになります。

     cvs -d :gserver:faun.example.org:/usr/local/cvsroot checkout foo



File: cvs-ja.info, Node: Kerberos authenticated, Next: Connecting via fork, Prev: GSSAPI authenticated, Up: Remote repositories

ケルベロスによる直接接続
------------------------

ケルベロスを使う一番簡単な方法は *Note Connecting via rsh:: で説明され
ているようにケルベロスの `rsh' を使用することです。rsh を利用する際の
主な欠点は、全てのデータが他のプログラムを経由する必要があるため、時間
がかかるかもしれない事です。もしケルベロスが導入されているならば、ケル
ベロスの認証により、直接 TCP 接続する事が可能です

この部分はケルベロスネットワークセキュリティシステム、バージョン4 に関
するものです。ケルベロス バージョン5は前節で説明されているように、
GSSAPI 一般ネットワークセキュリティインターフェースを通して使用するよ
うになっています。

このためには、ケルベロスの支援を受けるように CVS をコンパイルする必要
があります。CVS は configre 時にケルベロスが利用できるかどうかを検出し
ようとしますが、駄目ならフラグ `--with-krb4' を用いて強制させることも
可能です。

既定状態では、データ転送は暗号化され*ません*。クライアントとサーバ双方
を、暗号化を有効にしてコンパイルしておく必要があります。構築時に 
`--enable-encryption' オプションを付加して、暗号化機能を有効にして下さ
い。また暗号化を要求するために、使用時に広域オプション `-x' を付加する
必要があります。

サーバの `inetd.conf' を編集する必要があります。クライアントが使用する
既定のポート番号は 1999 です。他のポートを使用したい場合には、クライア
ントの環境変数 `CVS_CLIENT_PORT' で指定して下さい。

CVS を利用する前に、通常の方法で切符を取得して下さい (一般的には 
`kinit' です)。この切符でサーバへのログインが許可されるはずです。これ
で準備ができました:

     cvs -d :kserver:faun.example.org:/usr/local/cvsroot checkout foo

ここで接続に失敗した場合、以前のバージョンの CVS は rsh で再接続を試み
ましたが、このバージョンでは再試行されません。



File: cvs-ja.info, Node: Connecting via fork, Prev: Kerberos authenticated, Up: Remote repositories

fork を通じての接続
-------------------

この接続方法で、ローカル・ディスクのリポジトリに遠隔プロトコルを使って
接続することができます。言い換えると、それは `:local:' とほとんど同じ
ことをしますが、変な振舞いや、バグやその他のものはローカルのCVS のもの
ではなく、遠隔 CVS のものです。

毎日の作業では、`:local:' か `:fork:' を好むかは個人の好みに依ります。
もちろん `:fork:' は `cvs' と遠隔プロトコルをデバッグしているときは特
に役立ちます。特に、我々は他の遠隔アクセス方法のネットワーク関連の設定、
変更、時間切れ設定、認証全てを避けることができ、その上で遠隔プロトコル
を使う接続を作成することができるのです。

`fork' 方法を用いて接続するためには、`:fork:' とローカルのリポジトリへ
のパス名を使用します。例えば、:

     cvs -d :fork:/usr/local/cvsroot checkout foo

`:ext:' と同様に、サーバは既定値の `cvs' と呼ばれるか、`CVS_SERVER' 環
境変数の値になります。



File: cvs-ja.info, Node: Read-only access, Next: Server temporary directory, Prev: Remote repositories, Up: Repository

読み込み専用リポジトリ接続
==========================

パスワード認証サーバを使っている人に読み込み専用リポジトリ接続を認める
ことができます (*Note Password authenticated::)。 (他の接続方法は全て
リポジトリマシンへのログイン接続を仮定していて、ローカルのファイル使用
許可が認めるものは何でもできるので、読み込み使用者のための明示的な援助
はありません。)

読み込み専用接続の使用者は、特定の "管理" ファイル (ロックファイルや履
歴ファイル) を除いて、リポジトリを変更しない CVS の操作のみを実行でき
ます。この機能を使用者の別名付けと一緒に使うことが望ましいでしょう 
(*Note Password authentication server::)。

以前のバージョンの CVS と違って、読み込み専用使用者はリポジトリを読む
ことができるだけで、サーバのプログラムを実行できないようになっているは
ずです。そうしないと、予期しないレベルの接続を得ることができてしまいま
す。もしくは、より正確に言うと、*既知の*穴は塞がれました。この機能は新
しく、包括的なセキュリティ審査がなされていませんので、セキュリティへの
関心に従って、どのような程度の注意も払うべきというのは正当のようです。

使用者に読み込み専用を指定するためには、2つ方法があります: 包含と排除
です。

"包含" は、使用者を特別に `$CVSROOT/CVSROOT/readers' ファイルに一覧表
示するということで、それは単純な改行で分離された利用者の一覧です。これ
は `readers' ファイルの例です:

     melissa
     splotnik
     jrandom

(最後の使用者の後の改行を忘れないでください。)

"排除" は *書き込み* 接続のできる人を全て明示的に一覧表示するというこ
とです--もしファイル

     $CVSROOT/CVSROOT/writers

が存在すると、それに挙げられている使用者だけが書き込み接続ができ、その
他の人は読み込み専用接続になります (もちろん、読み込み専用使用者も、相
変らず CVS `passwd' ファイルに挙げられている必要があります。)
`writers' ファイル は `readers' ファイルと同じ書式です。

注意: CVS `passwd' ファイルが cvs の使用者をシステムの使用者にマップし
ているときは、*cvs* の使用者名を使って書き込み専用接続を拒否したり認め
たりしていて、システムの使用者名を使っていないことを確認してください。
すなわち、`readers' と `writers' ファイルにcvs の使用者名があるという
ことで、それはシステムの使用者名と同じかもしれませんし、違うかもしれま
せん。

これは読み込み専用接続か読み込み書き込み接続かを認めるかに関するサーバ
の振舞いの完全な説明です。

`readers' が存在して、この使用者がそこに挙げられていれば、読み込み専用
接続になります。もしくは、`writers' が存在していて、使用者がそこに挙げ
られていなければ読み込み専用接続になります (`readers' が存在するけれど、
そこには挙げられていないというときにもそのようになります)。その他の場
合では、完全な読み込み書き込み接続になります。

もちろん、使用者が両方のファイルに挙げられていれば、衝突が発生します。
これはより保守的な方法で解決されます。リポジトリの保護は少なすぎるより
多すぎるほどの方が良いですので: そのような使用者は読み込み専用接続にな
ります。



