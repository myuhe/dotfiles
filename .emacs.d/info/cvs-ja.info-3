Info file: cvs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `cvs-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.



START-INFO-DIR-ENTRY
* CVS-JA: (cvs-ja).        Concurrent Versions System (Japanese)
END-INFO-DIR-ENTRY

Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.  Copyright (C) 1995-1999 Makoto
Hiroyasu Copyright (C) 1999 Yoshiki Hayashi

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.





File: cvs-ja.info, Node: Updating a file, Next: Conflicts example, Prev: File status, Up: Multiple developers

ファイルを最新にする
====================

ファイルを更新もしくはマージしたい場合には、`update' コマンドを使用し
ます。これは最新でないファイルに対しては `checkout' コマンドとほとんど
等価です。つまり、ファイルの最新リビジョンをリポジトリから取り出して、
作業ディレクトリに置きます。

`update' コマンドを使用しても、あなたの修正が失なわれることはありませ
ん。より新しいバージョンが無い場合には、`update' は何もしません。新し
いバージョンが存在し、かつ作業ファイルが修正されている場合、CVS は全て
の変更を作業コピーにマージします。

例えばリビジョン 1.4 を取り出して、編集を始めたとします。その合間に他
の人物がバージョン 1.5 を格納し、またすぐに 1.6 になったとします。ここ
で `update' コマンドを使用した場合、CVS は 1.4 と 1.6 間の変更を、あな
たのファイルに組み入れます。

1.4 と 1.6 間の変更が、あなたの変更と似たようなものであれば、"重複"
("overlap") が起きます。そして警告が表示され、ファイルには重複した行が
両方並記されて、特別なマークで囲まれます。`update' コマンドの詳細は 
*Note update::.



File: cvs-ja.info, Node: Conflicts example, Next: Informing others, Prev: Updating a file, Up: Multiple developers

衝突の例
========

リビジョン 1.4 の `drive.c' は次のような内容とします:

     #include <stdio.h>

     void main()
     {
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? 0 : 1);
     }

リビジョン 1.6 では `drive.c' は次のようになっています:

     #include <stdio.h>

     int main(int argc,
              char **argv)
     {
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(!!nerr);
     }

リビジョン 1.4 を元にしたあなたの `driver.c' の作業コピーは、`cvs
update' の前に次ようになっています:

     #include <stdlib.h>
     #include <stdio.h>

     void main()
     {
         init_scanner();
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

この時 `cvs update' を実行してみます:

     $ cvs update driver.c
     RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
     retrieving revision 1.4
     retrieving revision 1.6
     Merging differences between 1.4 and 1.6 into driver.c
     rcsmerge warning: overlaps during merge
     cvs update: conflicts found in driver.c
     C driver.c

CVS は上記のように、衝突が起きたことが報告します。あなたが編集したオリ
ジナルのファイルは、無修正で `.#driver.c.1.4' という名前で保存されます。
`driver.c' の新しいバージョンは次のようになります:

     #include <stdlib.h>
     #include <stdio.h>

     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
     <<<<<<< driver.c
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     =======
         exit(!!nerr);
     >>>>>>> 1.6
     }

@noindent

重複しなかった修正がどの様に作業コピーに組み込まれているか注意して下さ
い。重複した部分は`<<<<<<<', `=======' 及び `>>>>>>>' ではっきりと囲ま
れています。

ファイルを編集して衝突が起きた部分を解決し、マークと間違った行を消しま
す。最終的に次のようになったとします:
     #include <stdlib.h>
     #include <stdio.h>

     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

今やこのファイルを格納してリビジョン 1.7 とすることができます。

     $ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
     Checking in driver.c;
     /usr/local/cvsroot/yoyodyne/tc/driver.c,v  <--  driver.c
     new revision: 1.7; previous revision: 1.6
     done

衝突が起きたが未解決であるファイルは、安全を考慮して、CVS が格納するこ
とを拒否します。衝突を解決するとき、ファイルの編集時間を変更する必要が
あります。前のバージョンの CVS では、ファイルに衝突マークがないことを
確認する必要もありました。ファイルには正しく衝突マークがあるかもしれま
せんので (すなわち、行頭にある `>>>>>>> ' は衝突の印ではありません)、
現在のバージョンの CVS は警告を印字してファイルの格納を実行します。

もしあなたが pcl-cvs (GNU Emacs 用 CVS フロントエンド) の、1.04 よりも
新しいリリースを使用しているならば、衝突を解決するのに emerge という 
Emacs パッケージが利用できます。pcl-cvs の文書を見て下さい。



File: cvs-ja.info, Node: Informing others, Next: Concurrency, Prev: Conflicts example, Up: Multiple developers

格納したことを他の人に知らせる
==============================

新しいリビジョンが格納されたときに、それを開発者全員に通知するようにし
ておくと便利でしょう。`modules' ファイルの `-i' オプションか `loginfo' 
ファイルにより、この手順を自動化することができます *Note
modules::. *Note loginfo::.  この機構により、例えば全ての開発者にメー
ルを出したり、ニュースに記事を投稿したりすることができます。



File: cvs-ja.info, Node: Concurrency, Next: Watches, Prev: Informing others, Up: Multiple developers

同時に CVS の実行を試みる複数の開発者
=====================================

複数の開発者が同時に CVS を実行しようとした場合、次のようなメッセージ
が表示されます:

     [11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo

CVS は 30秒毎に実行を試み、まだ待つ必要があれば再度メッセージを表示し、
そうでなければ処理を続けます。不適当な程長く待ち続けているようならば、
ロックさせている人物を見付けて、実行中の cvs コマンドを訊いてみて下さ
い。cvs コマンドが実行されてないのならば、メッセージで書かれているリポ
ジトリディレクトリを見て、彼等が所有している `#cvs.tfl', `#cvs.rfl',
`#cvs.wfl' という名前で始まるファイルを捜して、削除して下さい。

このロックは CVS の内部データ構造を保護するもので、RCS で使用される"ロッ
ク" ("lock") という言葉とは全く何の関係もないことに注意してください。
RCS のロックについては、独占取得についての記述を参照して下さい (*Note
Multiple developers::)。

任意のリポジトリから何人でも、同時に読み出すことが可能です。誰かが書き
込み中の場合にだけ、他の人の読み出しや書き込みが禁止されます。

次に示すような動作を望む人がいるでしょう

     ある人物が一つの cvs コマンドで複数のファイルに対する変更点を
     格納した時、他の誰かが同時に update を実行すると、全てのファイルが
     更新されるか、全く更新されないかのどちらかである。

が、CVS はこのように動作*しません*。例えば以下のファイルがあるとして、

     a/one.c
     a/two.c
     b/three.c
     b/four.c

ある人物が次のコマンドを実行した時、

     cvs ci a/two.c b/three.c

同時に他の誰かが `cvs update' を実行した場合、`update' を実行している
人は `b/three.c' の変更点のみが更新され、`a/two.c' の変更点は更新され
ないでしょう。



File: cvs-ja.info, Node: Watches, Next: Choosing a model, Prev: Concurrency, Up: Multiple developers

ファイル編集者の追跡機構
========================

多くのグループが CVS を既定状態で使用していますが、ほぼ完全に満足して
いるようです。しかし時には、自分と他人の修正点が重複する事があり、この
重複を処理して再び格納しなくてはいけません。あるグループでは、誰がどの
ファイルを編集中か分るようにしています。従って、二人で同じファイルを編
集する場合、誰が何時何をするのか相談できるため、格納時に驚かされずに済
みます。この節では、このような調整作業を行なう機能について説明しますが、
二人の開発者が同時に同じファイルを編集する能力は維持されます。

開発者は、編集するファイルを読み書き可能にする時に、(`chmod' でなく)
`cvs edit' を使用し、もう使用しない作業ディレクトリを処分する時に、
(`rm' でなく) `cvs release' を使用することが推奨されます。しかし、CVS 
はこれらの手順を強制する事は出来ません。


* Menu:

* Setting a watch::             監視するファイルを CVS に教える
* Getting Notified::            誰に通知するか CVS に教える
* Editing files::               監視下にあるファイルの編集方法
* Watch information::           誰が監視や編集をしているか
* Watches Compatibility::       監視は CVS 1.6 以前と上手く協調しない



File: cvs-ja.info, Node: Setting a watch, Next: Getting Notified, Prev: Watches, Up: Watches

監視するファイルを CVS に教える
-------------------------------

監視機能を有効にするには、まずそのファイルを監視するように指示する必要
があります。

 -- コマンド: cvs watch on [`-LR'] FILES ...

     この指定以降、FILES を編集しようとする開発者は `cvs edit' を実行
     する必要があります。開発者が編集前に `cvs edit' の実行を忘れない
     様に、CVS は FILES の読み込みだけを許可します。

     FILES がディレクトリを含む場合、リポジトリの対応するディレクトリ
     内の全てのファイルに加えて、将来ディレクトリに追加されるファイル
     全てが CVS の監視対象になります。この動作を利用して、ディレクトリ
     毎に通知方針を設定することができます。またオプション `-l' を指定
     しない場合、ディレクトリ以下が再帰的に処理されます。`-l' オプショ
     ンが `~/.cvsrc' で設定されている場合は `-R' オプションを使って再
     帰を強制することができます (*Note ~/.cvsrc::)。

     FILES を省略した場合、現在のディレクトリが指定されたと解釈します。


 -- コマンド: cvs watch off [`-LR'] FILES ...

     取り出し時に FILES を読み込み専用にはしません。ですから、開発者は 
     `cvs edit' と `cvs undit' の使用に注意することはありません。CVS 
     は `config' 管理ファイルで `PreservePermissions' オプションを使用
     すうことになっいるための他の使用許可の条件が無いかぎり、FILES を 
     普通に読み書き両用で取り出します。(*Note Special Files::, *Note
     config::).

     FILES や引数指定時の振舞いは、`cvs watch on' の場合と同じです。




File: cvs-ja.info, Node: Getting Notified, Next: Editing files, Prev: Setting a watch, Up: Watches

誰に通知するか CVS に教える
---------------------------

あるファイルに対して種々の操作が行われた時に通知を受けたい場合には、そ
の旨を CVS に知らせます。そのファイルに対して `cvs watch on' を用いな
くても、通知の要求は可能です。しかし、開発者がコマンド `cvs edit' を用
いるとは限らないため、通常は `cvs watch on' を用いた方が良いでしょう。

 -- コマンド: cvs watch add [`-A' ACTION] [`-LR'] FILES ...

     現在の使用者を、 FILES に対して操作が行なわれた時に通知を受けとる
     人の一覧に追加します。

     オプション `-a' には、通知して欲しい操作の種類を指定します。
     ACTION は次のうちのどれかです:


     `edit'
          あなた以外の人物が、ファイルに対してコマンド `cvs edit' (後
          述) を適用した場合。

     `unedit'
          あなた以外の人物が、ファイルに対してコマンド `cvs unedit'
          (後述) または `cvs release' を適用した場合。また、ファイルが
          消されて `cvs update' により再度生成された場合。

     `commit'
          あなた以外の人物が、ファイルに対する変更を格納した場合。

     `all'
          上記全て。

     `none'
          上記以外。(これは後述の `cvs edit' で使用すると便利です。)


     オプション `-a' は何度指定しても良いし、全く指定しなくても構いま
     せん。省略した場合には、`all' が指定されたと解釈します。

     FILES や引数指定時の振舞いは、`cvs watch on' の場合と同じです。



 -- コマンド: cvs watch remove [`-A' ACTION] [`-LR'] FILES ...

     `cvs watch add' で設定した通知要求を取り下げます。引数は同じです。
     オプション `-a' を用いた場合、指定された事項に対する通知のみを停
     止します。


通知すべき状態が発生した時、CVS は管理用ファイル `notify' を見ます。
`notify' は他の管理用ファイルと同じように編集して下さい。(*Note Intro
administrative files::)。管理用ファイルの慣例に従って (*Note syntax::)、
このファイルの各行には、正規表現に続けて実行したいコマンドを記述します。
コマンドの引数には、(通知すべき使用者に置換される) `%s' という文字列を
一つだけ指定する必要があり、通知内容はコマンドの標準入力に与えられます。
ファイル `notify' に書く標準のものは次の一行です:

     ALL mail %s -s \"CVS notification\"

この記述により、使用者に電子メールで通知が行なわれます。

上記の行をそのまま記述した場合、使用者はサーバ上で通知を受ける事に注意
して下さい。他の場所に通知したい場合には、もちろん `notify' に記述して
も良いのですが、CVS ではもっと簡単に各使用者の通知先を設定できます。
`CVSROOT' に `users' というファイルを作成し、USER:VALUE という書式で、
各使用者について一行ずつ記述して下さい。CVS は、`notify' に記述された 
USER の代りに、VALUE (通常は別のマシンのメールアドレス) に通知します。

CVS はあなた自身の変更は通知しません。現時点では、この照合は通知を発生
させる動作をしている人の使用者名が通知を受ける人の使用者名と合うかどう
かに基づいてなされています。実際のところ、一般的に、監視機構はそれぞれ
の使用者の一つの編集だけを追跡します。おそらく、監視がそれぞれの作業ディ
レクトリを別に追跡するとより便利なので、この振舞いは変更する価値がある
でしょう。



File: cvs-ja.info, Node: Editing files, Next: Watch information, Prev: Getting Notified, Up: Watches

監視下にあるファイルの編集方法
------------------------------

監視下にあるファイルを取り出した場合、読み込みだけが許可されるため、単
純に編集はできません。読み書きを可能にし、そのファイルを編集する意図を
他の人に伝えるために、`cvs edit' コマンドを使用して下さい。上記の作業
を "checkout" と呼ぶシステムもありますが、CVS ではこの用語をソースのコ
ピーを得る ("取り出す") という意味で用います (*Note Getting the
source::)。他のシステムでは、この操作は "get" とか "fetch" と呼ばれま
す。

 -- コマンド: cvs edit [OPTIONS] FILES ...

     作業ファイル FILES を編集する準備をします。CVS は FILES の読み書
     きを許可し、FILES に対する `edit' 通知を求める使用者に通知します。

     `cvs edit' コマンドに、`cvs watch add' コマンドと同じ OPTIONS を
     使用すれば、一時的に FILES を監視することができます。CVS は、
     FILES が `unedit' もしくは `commit' されたときに、監視を止めます。
     通知を受けたくない場合には、`-a none' を指定して下さい。

     FILES や引数指定時の振舞いは、`cvs watch' の場合と同じです。

     *注意:* `PreservePermissions' オプションがリポジトリで使用可になっ
     ていると (*Note config::)、CVS はどの FILES の使用許可も変更しま
     せん。この変更の理由は `cvs edit' の使用が CVS リポジトリのファイ
     ル使用許可を保管する機能と干渉しないようにするということです。


変更を全て終了したら、通常は `cvs commit' を用いて、監視下にあるファイ
ルの変更点を格納し、読み込みだけが許可された状態に戻します。しかし、途
中で変更を止めたり、何も変更しないと決めた場合には、`cvs unedit' コマ
ンドを使用します。

 -- コマンド: cvs unedit [`-LR'] FILES ...

     作業ファイル FILES に加えた変更を捨て、変更前のリポジトリのバージョ
     ンに戻します。FILES に対して、`cvs watch on' による通知要求がある
     場合、CVS は FILES の読み込みだけを許可します。また FILES に対す
     る `unedit' 通知を求める使用者に通知します。

     FILES や引数指定時の振舞いは、`cvs watch' の場合と同じです。

     ファイルが監視されてないときにはおそらく `unedit' コマンドが動作
     しないため、リポジトリのバージョンに戻したい場合は、ファイルを削
     除してから `cvs update' で新たにコピーを取得して下さい。これは厳
     密には同じ意味ではなく、削除して更新した場合には、あなたが最後に
     更新した後にリポジトリに加えられた変更も付随します。

CVS のクライアント/サーバを使用していて、サーバとうまく接続できなかっ
た場合でも、`cvs edit' や `cvs unedit' コマンドが使用できます。次に 
CVS コマンドが成功した時に、一緒に通知が行なわれます。



File: cvs-ja.info, Node: Watch information, Next: Watches Compatibility, Prev: Editing files, Up: Watches

誰が監視や編集をしているか
--------------------------

 -- コマンド: cvs watchers [`-LR'] FILES ...

     現在、FILES の変更を監視している人物の一覧を表示します。監視され
     ているファイルと、各監視者のメールアドレスを報告します。

     FILES や引数指定時の振舞いは、`cvs watch' の場合と同じです。



 -- コマンド: cvs editors [`-LR'] FILES ...

     現在、FILES を編集している人物の一覧を表示します。各編集者のメー
     ルアドレス、編集作業を開始した時間、ファイルが置かれた作業ディレ
     クトリのパス名とホスト名を報告します。

     FILES や引数指定時の振舞いは、`cvs watch' の場合と同じです。




File: cvs-ja.info, Node: Watches Compatibility, Prev: Watch information, Up: Watches

古いバージョンの CVS と監視機能
-------------------------------

監視機能を使用している場合、リポジトリに `CVS' というディレクトリが作
成され、このディレクトリに監視情報が格納されます。このリポジトリに対し
て CVS 1.6 以前のものを使用した場合には、以下のエラー・メッセージが出
力されます (全て一行にでます):

     cvs update: cannot open CVS/Entries for reading:
     No such file or directory

そして、操作が途中で終了します。監視機能を使用するためには、このリポジ
トリを利用するクライアント/サーバ両方で、CVS を新しいものと交換する必
要があります。もし新しいものと交換できない場合には、`watch off' と 
`watch remove' コマンドを用いて監視を全て停止すれば、リポジトリを CVS
1.6 が利用できる状態に再構築できます。



File: cvs-ja.info, Node: Choosing a model, Prev: Watches, Up: Multiple developers

独占取得と無条件取得の選択
==========================

独占取得、無条件取得それぞれに一長一短があります。ここでは、この問題を
簡単に説明しますが、残りの多くは個人的な見解の相違や、各グループの作業
スタイルの相違だと思います。開発者チームを構成するには様々な方法があり
ます。CVS は特定の構成を強制せず、各々を実現する機能を提供するだけです。

独占取得には、非常に非生産的な部分があります。二人が同じファイルを編集
する場合でも、編集部分が異なる場合には、どちらか一方の編集を禁止する必
要は全くありません。また、ファイルを編集するためにロックした後、ロック
解除を忘れてしまうことが、普通に起こり得ます。

独占取得に特別な安心感を持つ人々は、無条件取得を用いた場合の衝突の多さ
や、それを解決する困難さをよく訴えます。しかし多くのグループの経験から
言うと、衝突は稀であり、解決も普通は比較的簡単なものです。

衝突は2人の開発者がコードの与えられた部分の適切な設計について意見が食
い違っているときにのみ起こることを理解するまで、深刻な衝突の発生の少な
さは驚きでしょう。このような衝突は、そもそもチーム内での意思疎通が上手
く行っていないことを示しています。*どのような*ソース管理方法を採るにし
ても、開発者が共同で作業する際には、システム全体の設計方針に従わなけれ
ばいけません。きちんと従っていれば、簡単にマージできる重複ばかりになる
でしょう。

無条件取得が、全く不適当な場合があります。管理下にあるファイルの形式を
マージする道具が無く (例えばワード・プロセッサによるファイルや、CAD プ
ログラムで編集されたファイル等)、マージ可能なデータ書式を使用するよう
にプログラムを変更できない場合、悪夢のような衝突解決をするよりは、普通
は独占取得を用いて簡単に衝突を避けたほうが賢明でしょう。

上の *Note Watches:: で記述された監視機構は、独占取得と無条件取得の中
間的なものと考えられます。ファイルを編集する前に、他の誰がファイルを編
集中なのか調べることができます。これは単純に双方の同時編集を禁止するの
ではなく、現況を報告し、それが問題かどうかは自分で判断してもらいます。
これを適切に使用すれば、独占取得と無条件取得の中でも最善の選択となるで
しょう。



File: cvs-ja.info, Node: Revision management, Next: Keyword substitution, Prev: Multiple developers, Up: Top

リビジョン管理
**************


ここまで読んだあなたは、CVS を使って何ができるかを、もう随分理解してい
るでしょう。ここでは、あなたが決めるべき事柄について少し説明します。

あなたが一人で CVS を使用して開発しているならば、ここは読み飛ばして結
構です。複数の人物が同じリポジトリを使って作業する場合に、ここで説明す
る問題が重要になってきます。

* Menu:

* When to commit::              この問題の論議



File: cvs-ja.info, Node: When to commit, Prev: Revision management, Up: Revision management

いつ格納すべきか?
=================

あなたのグループは、格納の時期に関して、どのような方針を採るか決めてお
く必要があります。幾つかの方針が可能であり、CVS での経験を重ねることに
よって、独自の方法を見付けることができるでしょう。

とにかく早く格納することにして、コンパイルもせずに格納してしまったとし
ます。あなたの同僚が、作業ソースを更新してあなたのバギーなファイルを取
り込んだ場合、彼はコンパイルができません。逆にめったに格納しない場合、
同僚はあなたがコードに加えた改良の利益を得ることができず、衝突がより多
くなるでしょう。

コンパイルできるかどうか確認したファイルだけを格納する方法がよく採られ
ます。あるサイトでは、ファイルが検査に合格することを要求します。
`commitinfo' ファイルを使用して (*Note commitinfo::)、このような方針を
強制できますが、その前によく考えなくてはいけません。十分過ぎる程管理さ
れた開発環境を作ると、厳格になり過ぎて、非生産的になり、ソフトウェアを
書くという目的が果たせなくなります。



File: cvs-ja.info, Node: Keyword substitution, Next: Tracking sources, Prev: Revision management, Up: Top

キーワード置換
**************


作業ファイルを編集している間は、いつでも `cvs status' や `cvs log' を
使ってそのファイルの状態を調べることができます。しかし開発環境から取り
出した場合は、各ファイルのリビジョンを識別するのが難しくなります。

CVSは、"キーワード置換" ("keyword substitution") (もしくは"キーワード
展開" ("keyword expansion")) と呼ばれる機構により、ファイルの識別を補
助します。ファイル中に `$KEYWORD$', `$KEYWORD:...$' といった書式で埋め
込まれた文字列を、ファイルを取り出すときに `$KEYWORD:VALUE$' といった
書式の文字列に置き換えます。

* Menu:

* Keyword list::                キーワード
* Using keywords::              キーワードの使用
* Avoiding substitution::       置換を止めるには
* Substitution modes::          置換モード
* Log keyword::                 キーワード $Log$ の問題点



File: cvs-ja.info, Node: Keyword list, Next: Using keywords, Prev: Keyword substitution, Up: Keyword substitution

キーワード一覧
==============


これはキーワードの利用の一覧です:

`$Author$'
     そのリビジョンを格納したユーザのログイン名。

`$Date$'
     そのリビジョンを格納した日付と時間 (UTC)。

`$Header$'
     標準のヘッダは、RCS ファイルのフルパス名, リビジョン番号, 日付 
     (UTC), 最終変更者, ファイル状態, (ロックされているならば) ロック
     している人物という情報で構成されます。CVS を使用する場合、普通ファ
     イルはロックされません。

`$Id$'
     RCS ファイル名がフルパスでないことを除けば、`$Header$' と同じです。

`$Name$'
     このファイルを取り出すときに使用したタグ名。キーワードは明示的な
     タグ名で取り出したときにのみ展開されます。例えば、コマンド `cvs
     co -r first' を実行すると、キーワードを `Name: first' に展開しま
     す。

`$Locker$'
     そのリビジョンをロックしている人物のログイン名。(ロックされていな
     ければ空で、`cvs admin -l' が使われていなければそれが普通です。)

`$Log$'
     RCS ファイル名, リビジョン番号, 最終変更者, 日付 (UTC) から構成さ
     れるヘッダ行に続けて、格納時のログ・メッセージを挿入します。以前
     に挿入されたログ・メッセージを置き換えるのでは*なく*、新しいメッ
     セージを `$Log:...$' の次の行に挿入します。それぞれの新しい行には 
     `$Log' キーワードの前にあるものと同じ文字列が付きます。例えば、ファ
     イルが以下のようになっているとします。

            /* Here is what people have been up to:
             *
             * $Log: frob.c,v $
             * Revision 1.1  1997/01/03 14:23:51  joe
             * Add the superfrobnicate option
             *
             */

     そうすると、`$Log' を展開するときに追加される行はその前に ` * ' 
     が付きます。以前のバージョンの CVS、RCS と違って、RCS ファイル の 
     "註釈符" ("comment leader") は使用されません。`$Log' キーワードは、
     ソース・ファイルに全てのログを残したい場合には便利ですが、問題点
     も幾つかあります (*Note Log keyword::)。

`$RCSfile$'
     パスを含まない RCS ファイル名。

`$Revision$'
     そのリビジョンを表わすリビジョン番号。

`$Source$'
     RCS ファイルのフルパス名。

`$State$'
     そのリビジョンの状態。各リビジョンの状態は、`cvs admin -s' で割り
     当てることができます--- *Note admin options:: 参照。




File: cvs-ja.info, Node: Using keywords, Next: Avoiding substitution, Prev: Keyword list, Up: Keyword substitution

キーワードの使用
================

キーワードを使いたい場合は、`$Id$' などの適当な文字列をファイルに記述
してから格納するだけです。CVS は格納操作の一環として自動的に文字列を展
開します。

`$Id$' 文字列をソースファイルに入れて、生成されるファイルにそれが渡さ
れるようにするのはよくあることです。例えば、コンピュータプログラムのソー
スコードを管理していれば、その文字列を含むように初期化されている変数を
入れるでしょう。またバイナリ中に直接文章を埋め込むために `#pragma
ident' 命令が使用できるコンパイラもあります。もしくは、文書管理システ
ムが生成されたファイルに文字列を渡す方法を提供するかもしれません。


`ident' コマンド (RCS パッケージの一部) を使用して、ファイルからキーワー
ドとその値を抜き出すことができます。もちろんテキスト・ファイルにも使え
ますが、バイナリ・ファイルからキーワードを抜き出したいときに非常に便利
です。

     $ ident samp.c
     samp.c:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
     $ gcc samp.c
     $ ident a.out
     a.out:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $

別のリビジョン管理システムとして有名なものに SCCS があります。SCCS に
は、`ident' と非常によく似た同じ用途のコマンド `what' が含まれます。
RCS を持たないサイトの多くは SCCS を使っています。`what' コマンドは 
`@(#)' という文字列を探すため、両方のコマンドに対応するキーワードを含
めるのは簡単です。キーワードの前に、簡単な SCCS の魔法の呪文を唱えるだ
けで良いのです:

     static char *id="@(#) $Id: ab.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";



File: cvs-ja.info, Node: Avoiding substitution, Next: Substitution modes, Prev: Using keywords, Up: Keyword substitution

置換を止めるには
================

キーワード置換にも欠点があります。ファイル中に表われる文字列 
`$Author$' は、RCS によってキーワードと見倣されます。この文字列を 
`$Author: ceder $' などと解釈させずに、そのまま使いたい事があるでしょ
う。

不幸なことに、選択的にキーワード置換を止めることはできません。`-ko' に
よって完全にキーワード置換を止めることができます (*Note Substitution
modes::)。

RCS キーワードが最終製品に現われるとしても、ソース・ファイル中には使い
たくない場合が多くあります。例えばこのマニュアルのソースには 
`$Author$' ではなく、`$@asis{}Author$' と記述しています。`nroff' や 
`troff' であれば、ヌル文字である `\&' をキーワード中に埋め込めば同様の
効果を発揮します。



File: cvs-ja.info, Node: Substitution modes, Next: Log keyword, Prev: Avoiding substitution, Up: Keyword substitution

置換モード
==========

各ファイルには既定の置換モードが設定されており、作業ディレクトリの各ファ
イルの置換モードも別々に設定できます。前者は `cvs add' や `cvs admin' 
にオプション `-k' を付けて設定します。後者は `cvs checkout' や `cvs
update' にオプション `-k' や `-A' を付けて設定します。`cvs diff' にも 
`-k' オプションがあります。例が幾つかありますので、*Note Binary
files:: と *Note Merging and keywords:: 参照。

利用できるモードを以下に示します:

`-kkv'
     既定形式でキーワード文字列を生成します。例えば、キーワード 
     `Revision' に対して `$Revision: 5.7 $' が生成されます。

`-kkvl'
     `-kkv' とほぼ同様ですが、指定されたリビジョンがロックされていれば、
     ロックしている人物の名前を挿入します。ロックしている人物名は `cvs
     admin -l' が使用されているときだけ関係があります。

`-kk'
     キーワード文字列からキーワードのみを生成し、その値は省略されます。
     例えば、キーワード `Revision' に対して、`$Revision: 5.7 $' ではな
     く、`$Revision$' が生成されます。このオプションは、リビジョン間の
     違いを比較する時、キーワードによる違いを無視するのに便利です 
     (*Note Merging and keywords::)。

`-ko'
     そのファイルが格納される前の、古いキーワード文字列を生成します。
     例えば、キーワード `Revision' に対して、`$Revision: 5.7 $' ではな
     く、ファイルが格納された時の文字列である `$Revision: 1.1 $' が生
     成されます。

`-kb'
     `-ko' と同様ですが、リポジトリに格納される標準的な行末形式 (ライ
     ンフィードのみ) を、クライアント側のオペレーティングシステムに適
     した形式へ変換しません。行端にラインフィードのみが使用されるシス
     テム (unix 等) では、このオプションは `-ko' と同じです。バイナリ・
     ファイルの詳細情報は *Note Binary files:: 参照。

`-kv'
     キーワードの値のみを生成します。例えば、キーワード `Revision' に
     対して、`$Revision: 5.7 $' ではなく、`5.7' が生成されます。これは、
     `$Revision: $' といった、キーワード識別子を除くのが困難なプログラ
     ミング言語のファイルを生成する時に便利です。しかし、キーワード名
     が削除されてしまうために、これ以後はキーワード置換を行うことがで
     きません。従って使用には注意が必要です。

     オプション `-kv' は、`cvs export' で使用される事が多くあります---
     *Note export::。しかしモジュールがバイナリ・ファイルを含む場合は、
     うまく処理できないので使用しない方が賢明です。




File: cvs-ja.info, Node: Log keyword, Prev: Substitution modes, Up: Keyword substitution

キーワード $Log$ の問題点
=========================

キーワード `$Log$' にはちょっと問題があります。開発環境で作業をしてい
るならば、キーワード `$Log$' を使用しなくても、`cvs log' を使えば同じ
情報が簡単に手に入ります。いずれにしても出荷用のファイルに履歴情報は必
要ないでしょう。

さらに重要な問題は、枝を幹にマージするときに、RCS が `$Log$' の項目を
うまく扱えないことです。このマージ操作の結果、衝突が起きることがよくあ
ります。

またファイル中のログ・メッセージは、*修復*される傾向にあります。(綴の
間違いやほんとの間違い等)。しかしこの結果、`cvs log' の情報とファイル
の中身が一致しないことになります。これも問題といえば問題でしょう。

どうしてもキーワード `$Log$' を使うのならば、ファイルの先頭ではなく、
ファイルの *最後* に挿入することを推奨します。この方法ならば、長い変更
メッセージを毎日眺めなくて済みます。



File: cvs-ja.info, Node: Tracking sources, Next: Builds, Prev: Keyword substitution, Up: Top

サード・パーティーのソースの追っかけ
************************************

あなたのサイトに合わせてプログラムを修正した場合、そのプログラムの次の
リリースにも同じ修正を加えたいでしょう。CVS を用いてこの作業を自動化す
ることができます。

CVS の用語では、プログラムの開発元を"ベンダー" ("vendor") と呼びます。
ベンダーの配布物は、修正を加えずに "ベンダー枝" ("vendor branch") とい
う枝に格納します。CVS はこの為に 1.1.1 という番号を予約しています。

あなたがソースを修正して格納した場合、そのリビジョンは幹に入ります。ベ
ンダーから新しいリリースが届いたら、それをベンダー枝に加えて、修正を幹
にコピーします。

ベンダー枝を作り、更新するには、`import' コマンドを使用します。新しい
ファイルを import すると、ベンダー枝に `最初' のリビジョンが作られ、
`checkout' する人は誰でもそのリビジョンを取得します。格納されたローカ
ルな修正は幹に置かれ、`最初' のリビジョンが作られます。

* Menu:

* First import::                初めて持ち込む
* Update imports::              import コマンドで更新する
* Reverting local changes::     最新のベンダーリリースに戻す
* Binary files in imports::     バイナリ・ファイルには特別な操作が必要
* Keywords in imports::         キーワード置換は望ましくない
* Multiple vendor branches::    複数の場所からソースを取得すると?



File: cvs-ja.info, Node: First import, Next: Update imports, Prev: Tracking sources, Up: Tracking sources

初めて持ち込む
==============

まず最初に、`import' コマンドを使ってソースを登録します。`import' コマ
ンドでサード・パーティーの追っかけをする場合には、"ベンダー・タグ"
("vendor tag") と"リリース・タグ" ("release tag") を用いると良いでしょ
う。"ベンダー・タグ"は枝のタグ名です (`-b BRANCH' フラグを使用しなけれ
ば、枝のリビジョンは常に 1.1.1 です---*Note Multiple vendor
branches::.)。"リリース・タグ"は特定のリリースを指すタグ名で、ここでは 
`FSF_0_04' とします。

`import' は起動されたディレクトリを変更 *しない* ことに注意してくださ
い。特に、そのディレクトリが CVS の作業ディレクトリとして設定されるこ
とはありません。ソースに作業をしたいなら、まずそれを持ち込んで、それか
ら違うディレクトリに取り出してください (*Note Getting the source::)。

ディレクトリ `wdiff-0.04' に `wdiff' というプログラムのソースがあると
します。将来に新しいリリースがなされたときでも適用したい個人的な修正を
加えようとしています。まず、リポジトリに `wdiff' のソースを加えること
から始めましょう:

     $ cd wdiff-0.04
     $ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF_DIST WDIFF_0_04

上の例では、ベンダー・タグを `FSF_DIST' とし、唯一のリリース・タグを 
`WDIFF_0_04' としています。



File: cvs-ja.info, Node: Update imports, Next: Reverting local changes, Prev: First import, Up: Tracking sources

import コマンドで更新する
=========================

新しいリリースのソースが届いたら、それを最初と同じく `import' コマンド
でリポジトリに加えます。違いは、最初と異なるリリース・タグを用いること
だけです。

     $ tar xfz wdiff-0.05.tar.gz
     $ cd wdiff-0.05
     $ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF_DIST WDIFF_0_05

ファイルがローカルな修正を受けてなければ、今加えたものが最初のリビジョ
ンになります。ローカルな変更を加えていれば、`import' コマンドは変更を
幹にマージするように警告を出し、`checkout -j' を使うように促します。

     $ cvs checkout -jFSF_DIST:yesterday -jFSF_DIST wdiff

このコマンドで `wdiff' の最新のリビジョンが取り出され、`yesterday' 以
降にベンダー枝 `FSF_DIST' に加えられた変更を、作業コピーにマージします。
マージの過程で衝突が起きれば、通常の方法で解決して下さい (*Note
Conflicts example::)。その後、変更したファイルを格納します。

上記の実行例のように日時を使用する場合、一日に一つ以上のリリースを 
`import' しないと仮定しています。この仮定に反するならば、次のようにし
て下さい:

     $ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff

今の例では、上の二つのコマンドは等価です。



File: cvs-ja.info, Node: Reverting local changes, Next: Binary files in imports, Prev: Update imports, Up: Tracking sources

最新のベンダーリリースに戻す
============================

全てのファイルで `先頭' のリビジョンを変更してベンダー枝に戻すことでロー
カルの変更を完全に復旧し、最新のベンダーリリースに戻ることができます。
例えば、ソースの取り出したコピーを `~/work.d/wdiff' に置いていて、その
ディレクトリの全てのファイルをベンダーのバージョンに戻したいのなら、次
のように入力します:

     $ cd ~/work.d/wdiff
     $ cvs admin -bWDIFF .

`-bWDIFF' は `-b' の後空白を入れないで指定しなければなりません。*Note
admin options::.



File: cvs-ja.info, Node: Binary files in imports, Next: Keywords in imports, Prev: Reverting local changes, Up: Tracking sources

cvs import でバイナリ・ファイルを扱う方法
=========================================

`-k' wrapper 機能オプションを使って、どのファイルがバイナリであるかを
教えます。*Note Wrappers::.



File: cvs-ja.info, Node: Keywords in imports, Next: Multiple vendor branches, Prev: Binary files in imports, Up: Tracking sources

cvs import でキーワード置換を扱う方法
=====================================

持ち込んでいるソースにキーワードがある場合があります (*Note Keyword
substitution::)。例えば、ベンダーは CVS や他の似たキーワード展開構文を
使うシステムを使っているかもしれません。既定の方法でファイルを持ち込ん
だだけでは、ベンダーのキーワード展開があなた自身の CVS コピーでも行わ
れます。この情報はベンダーから持ち込んだソースの情報であることがありま
すから、ベンダーの展開を維持した方がより便利でしょう。

ベンダーのキーワード展開を維持するためには、最初にファイルを持ち込むと
きに `cvs import' に `-ko' オプションを付けます。こうすると、そのファ
イルのキーワード展開を完全に止めます。もっと選択的な方法を望む場合は、
`cvs update' や `cvs admin' に適切に `-k' オプションを使用します。



File: cvs-ja.info, Node: Multiple vendor branches, Prev: Keywords in imports, Up: Tracking sources

複数のベンダー枝
================

今までの例はソースを取得しているベンダーは一つだけだと仮定しています。
いろいろな場所からソースを得るような場合もあります。例えば、多くの違っ
た人やチームがソフトウェアを修正しているプロジェクトに関係しているとし
ます。これを扱う方法はいろいろありますが、たくさんのソースツリーが散ら
ばっていて、とりあえずやりたいことはそれら全てを CVS に放り込んで少な
くとも一箇所にまとめることだ、ということがあります。

複数のベンダーがある状況を扱うために、`cvs import' に `-b' オプション
を指定できます。その引数は持ち込むベンダー枝です。既定値は`-b 1.1.1' 
です。

例えば、赤チームと青チームの2つのチームがあり、あなたにソースを送って
くるとします。赤チームが努力したものを枝 1.1.1 に持ち込んで、ベンダー
タグ RED を使いたいと思っています。青チームが努力したものは枝 1.1.3 に
持ち込んで、ベンダータグ BLUE を使おうとしています。使用するコマンドは
以下のようになります。

     $ cvs import dir RED RED_1-0
     $ cvs import -b 1.1.3 dir BLUE BLUE_1-5

ベンダータグ が `-b' オプションと合わなくても、CVS は発見しないことに
注意してください。例えば、

     $ cvs import -b 1.1.3 dir RED RED_1-0

慎重に; この種類の不適当な組合せは混乱や、よりひどいことへの種になりま
す。不釣合いを指定することでの便利な使用をここでは考え付きません。もし
そのような使用を発見しても、使わないでください。CVS は将来のリリースで
はそれをエラーにするでしょう。




File: cvs-ja.info, Node: Builds, Next: Special Files, Prev: Tracking sources, Up: Top

構築システムと CVS の関係方法
*****************************

紹介で書かれているように、CVS にはソースコードからソフトウェアを構築す
るためのソフトウェアはありません。この部分は構築システムがCVS と協調す
るかもしれない種々の側面を説明します。

RCS に慣れている人からの特に多い、よくある質問は、どうすれば構築機構が
最新のソースのコピーを手に入れることができるか、ということです。CVS で
は2重になります。まず最初に、CVS はディレクトリを再帰的に辿ることがで
きますので、各ファイルが最新であることを確認するために `Makefile' (も
しくは、構築ツールが使う設定ファイルの名前) を修正する必要はありません。
その代わりに、まず `cvs -q update' として、それから `make' や構築ツー
ルを起動するコマンドを実行するという2つのコマンドだけを使います。2番目
に、あなた自身の作業が終わるまで、誰かの変更したコピーを取得*したい* 
と思わないかもしれません。1つの方法はまずソースを更新して、それから実
装、構築し、考えていた変更を試してからソースを格納する (必要ならまず更
新します) というものです。定期的に(変更の合間に、さっき書いた方法で) 
木全体を更新することで、ソースが十分に新しいことを保証できます。

よくある要求は、どのソースファイルのどのリビジョンが特定の構築に相当す
るかを記録することです。このような種類の機能は "bill of materials" な
どと呼ばれることがあります。CVS で実現する最良の方法は `tag'コマンドが
どのバージョンが与えられた構築に相当するかを記録することです (*Note
Tags::)。

CVS を一番素直な方法で使うと、それぞれの開発者は特定の構築に使われるソー
スツリー全体のコピーを持っています。ソースツリーが小さかったり、開発者
が地理的に離れたところにいるのなら、これが好ましい解決方法です。実のと
ころ、大きなプロジェクトを遂行する手段の一つはプロジェクトを小さな分割
してコンパイルされるサブシステムに分け、開発者に必要なことは主に作業し
ているサブシステムだけを取り出すだけにするように、内部でリリースする方
法を作ることです。

別の手段は、開発者にいくつかのファイルのコピーだけの所有をして、他のファ
イルには中央管理下のソースファイルを見に行くことができるようにする機構
を設定することです。多くの人は、大部分のオペレーティング・システムにあ
るシンボリックリンクや、`make' の多くのバージョンにある `VPATH' 機能を
使う様な解決法に到達しました。このような種類のものを助けるために設計さ
れた構築ツールに Odin というものがあります 
(`ftp://ftp.cs.colorado.edu/pub/distribs/odin' 参照)。



File: cvs-ja.info, Node: Special Files, Next: CVS commands, Prev: Builds, Up: Top

特別なファイル
**************


普通の環境では、CVS は普通のファイルでのみ動作します。プロジェクトの全
てのファイルは永続すると仮定されています。開き、読み込み、閉じるという
操作などが可能でなければなりません。また、CVS はファイルの使用許可と所
有権を無視します。そのような問題はインストール時に開発者によって解決さ
れる必要があります。言い換えれば、デバイスを "格納" することは不可能で
す。デバイスファイルを開けなければ、CVS はそれを扱うことを拒否します。
ファイルはリポジトリの取り扱い中にも所有権や使用許可を失います。

リポジトリで設定変数 `PreservePermissions' (*Note config::) が設定され
ていると、CVS は以下のファイルの特性をリポジトリに記録します:

   * 使用者とグループの所有権
   * 使用許可
   * 主・副デバイス番号
   * シンボリックリンク
   * ハードリンク機構

`PreservePermissions' オプションを使うと CVS の振舞いにいくつか影響し
ます。まず、CVS で使用可能になった新しい操作の中に、全ての使用者には使
用可能でないものができます。特に、ファイルの所有権と特別なファイルの特
性とはスーパーユーザにだけ変更できるものでしょう。ですから、
`PreservePermissions' 設定変数が設定されていると、使用者は CVS の操作
をうるために `root' になる必要があるでしょう。

`PreservePermissions' が使用されていると、CVS の操作の中には (`cvs
status' のように) ファイルのハードリンク構造を認識せず、合っていないハー
ドリンクに関して見せかけの警告を出力します。これは CVS の内部構造がハー
ドリンクに必要なデータ全てを集めるのを難しくしており、そのために不正確
なデータでファイルの衝突を調べるからです。

CVS はファイルの内容が変更されたときのみ、それが変更されたと考えること
による、より微妙な違いがあります (特に、作業ファイルの修正時刻がリポジ
トリのそのファイルと合わないとき)。ですから、使用許可、所有権、ハード
リンクが変わったり、デバイスの主、副番号が変わったとしても、CVS は報告
しません。そのような変更をリポジトリに格納するためには、`cvs commit
-f' で格納を強制する必要があります。これは、ファイルの使用許可が変わっ
ていて、リポジトリのファイルが作業コピーより新しいと、`cvs update' の
実行は、知らない間に作業コピーの使用許可を変更しているということでもあ
ります。

CVS リポジトリでのハードリンクの変更は特に慎重な扱いが必要です。`foo' 
がファイル `old' にリンクされていたけれど、後でファイル `new' にリンク
され直したとしましょう。`foo', `old', `new' は全て中のリンクパターンは
変更されているけれど、`foo' と `new' だけが修正されていて、そのために 
`old' は格納の候補としてみなされない、という変な状況になることがありま
す。このような方法により整合しない結果は非常に簡単に作られます。ですか
ら、ハードリンクをリポジトリに保存するのが重要なときは、賢明な動作方法
は最後の格納からリンクや状態が変わったファイル全てに `touch' すること
です。実際、複雑なハードリンク構造のディレクトリを格納する前には 
`touch *' をするのが賢いかもしれません。

おそらく明らかである理由により、普通のファイルだけがマージできるという
ことを書いておくのも意味のあることでしょう。もし `cvs update' や `cvs
checkout -j' がシンボリックリンクを普通のファイルとマージしようとした
り、2つのデバイスファイルが違った種類のデバイスのためのものであったり
すると、CVS は衝突を報告して、マージの実行を拒否します。また、テキスト
がないファイル上でのテキスト比較は無意味なので、`cvs diff' はこれらの
ファイル間の相違を報告しません。

`PreservePermissions' 機能はクライアント/サーバの CVS では動作しません。
別の制限に、ハードリンクは同じディレクトリの他のファイルへのリンクでな
ければならない、というものがあります。ディレクトリをまたいだハードリン
クは使用できません。



File: cvs-ja.info, Node: CVS commands, Next: Invoking CVS, Prev: Special Files, Up: Top

CVS のコマンド便覧
******************

この付録は CVS コマンドの全体構造の説明をし、いくつかのコマンドは詳し
く説明します (他のものは別のところで説明されています。CVS コマンドの簡
単な便覧は、*Note Invoking CVS::)。

* Menu:

* Structure::                   CVS コマンド構造の全て
* Exit status::                 CVS の成功か失敗を示す
* ~/.cvsrc::                    既定オプションと ~/.cvsrc ファイル
* Global options::              cvs_command の左側に付けるオプション
* Common options::              cvs_command の右側に付けるオプション
* admin::                       管理
* checkout::                    編集の為にソースを取り出す
* commit::                      ファイルをリポジトリに格納する
* diff::                        リビジョン間の差分を見る
* export::                      CVS からソースを取り出す, checkout に類似
* history::                     ファイルと使用者の状態を表示
* import::                      CVS にソースを取り込む, ベンダー枝を使用
* log::                         ファイルのログ情報を表示
* rdiff::                       リリース間の `patch' 形式の差分
* release::                     ディレクトリの放棄を表明する
* update::                      作業コピーをリポジトリと一致させる



File: cvs-ja.info, Node: Structure, Next: Exit status, Prev: CVS commands, Up: CVS commands

CVS コマンド構造の全て
======================

CVS のコマンド全体の書式を示します:

     cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]

`cvs'
     CVS プログラムの名前です。

`cvs_options'
     CVS のサブコマンド全体に適用されるオプションです。以下で説明され
     ています。

`cvs_command'
     いくつかの違ったサブコマンドの一つです。幾つかのコマンドでは別名
     が使用できます。別名はそのコマンドの便覧マニュアルのところで書か
     れています。次の二つの場合にだけ `cvs_command' を省略できます。つ
     まり `cvs -H' として利用可能なコマンドのリストを得る場合か、`cvs
     -v' として CVS 自身のバージョン情報を得る場合です。

`command_options'
     コマンド固有のオプションです。

`command_args'
     コマンドの引数です。

不幸な事に、`cvs_options' と `command_options' の間で幾つか混乱があり
ます。`-l' は `cvs_option' として使われたときいくつかのコマンドに影響
します。`command_option' として使されたときは、より多くのコマンドで意
味を持ちます。つまり、上の分類をあまり深刻に受けとめないでください。代
わりに文書を見るようにしましょう。



File: cvs-ja.info, Node: Exit status, Next: ~/.cvsrc, Prev: Structure, Up: CVS commands

CVS の終了状態
==============

CVS はそれ呼んだ環境に "終了状態" ("exit status") を設定することで、成
功したか失敗したかを示すことができます。終了状態を調べる正確な方法はオ
ペレーティング・システムごとに異なります。例えば、unix のシェルスクリ
プトでは、最後のコマンドが成功終了状態を返せば変数 `$?' は0で、終了状
態が失敗を示していれば、0より大きくなります。

CVS が成功した場合は、成功状態を返します。エラーがあれば、エラーメッセー
ジを印字して、失敗状態を返します。`cvs diff' コマンドはこの例外です。
違いが見つからなければ成功状態を返し、違いが見つかるか、エラーが発生し
たときに失敗状態を返します。この振舞いはエラーの検知には良くないので、
将来では `cvs diff' が他の CVS コマンドと同じように振舞うように変更さ
れる可能性があります。



File: cvs-ja.info, Node: ~/.cvsrc, Next: Global options, Prev: Exit status, Up: CVS commands

既定オプションと ~/.cvsrc ファイル
==================================

よく使用する `command_option' が幾つかあり、そのオプションを必ず指定す
るように設定したいことがあります。例えば (実際に .cvsrc を実装した要因
の一つですが) 多くの人には `diff' の既定出力は大変読みにくく、context 
形式か unidiff 形式のほうが遥かに分かりやすいでしょう。

シェル・スクリプトやエイリアスに頼らなくても、`~/.cvsrc' ファイルを用
いて `cvs_commands' 各々に既定のオプションを加えることができます。

`~/.cvsrc' の書式は簡単です。実行された `cvs_command' と同じ名前で始ま
る行が検索されます。一致した行を発見したら、行の残りの部分をオプション
に分割し (空白のところで)、コマンド行からのオプションを与える*前に*、
得られたオプションをコマンドの引数として与えます。コマンドが別名を持つ
場合 (例えば、`checkout' と `co')、コマンド行で使われるものとは限りま
せんが、公的な名前がファイルとの合致時に使用されます。例えば 
`~/.cvsrc' の内容が次の様であった場合:

     log -N
     diff -u
     update -P
     checkout -P

`cvs co foo' も、コマンド `cvs checkout foo' と同様に `-P' が引数とし
て与えられます。

上記の例では `cvs diff foobar' の出力は unidiff 形式になります。`cvs
diff -c foobar' だと指定通り context 形式になります。`diff' には "古い
" 形式で出力するためのオプションが無いため、"古い" 形式を使いたい場合
には少し面倒ですが `cvs -f diff foobar' とする必要があります。

コマンド名の部分に `cvs' と記述すれば、広域オプションを指定することが
できます (*Note Global options::)。例えば `.cvsrc' 中の以下の行は、

     cvs -z6

CVS が圧縮レベル 6 を用いるように指定しています。



File: cvs-ja.info, Node: Global options, Next: Common options, Prev: ~/.cvsrc, Up: CVS commands

広域オプション
==============

`cvs_options' (`cvs_command' の左側に与えられる) として利用できるもの
を以下に示します:

`--allow-root=ROOTDIR'
     正しい CVSROOT ディレクトリを指定します。*Note Password
     authentication server:: 参照。

`-a'
     クライアントとサーバの全ての通信を認証します。CVS クライアントで
     だけ意味をもちます。これを書いている時点では、GSSAPI 接続を行う場
     合だけに実装されています (*Note GSSAPI authenticated::)。認証は流
     れている TCP 接続のハイジャックというような攻撃から身を守ることが
     できます。認証を使用しても暗号化は使用されません。

`-b BINDIR'
     CVS 1.9.18 以前では、これは RCS プログラムが BINDIR ディレクトリ
     にあることを指定していました。現在のバージョンの CVS は RCS プロ
     グラムを実行しません。互換性のためにこのオプションがありますが、
     指定しても何もしません。

`-T TEMPDIR'
     一時ファイルが置かれるディレクトリを TEMPDIR とします。環境変数 
     `$TMPDIR' の設定や、コンパイル時のディレクトリ設定よりも優先され
     ます。この値は絶対パス名で指定して下さい。

`-d CVS_ROOT_DIRECTORY'
     リポジトリのルートディレクトリのパス名を CVS_ROOT_DIRECTORY とし
     ます。環境変数 `$CVSROOT' よりも優先します。*Note Repository::.

`-e EDITOR'
     リビジョンのログ情報の入力に EDITOR を使用します。環境変数 
     `$CVSEDITOR' や `$EDITOR' よりも優先します。詳しい情報は *Note
     Committing your changes:: 参照。

`-f'
     `~/.cvsrc' を読みません。このオプションが最も良く使われるのは、
     CVS のオプション設定に直交性がない時です。例えば `cvs log' のオプ
     ション `-N' (タグの表示を抑制します) に対応する表示を行なうオプショ
     ンはありません。従って、`~/.cvsrc' の `log' エントリに `-N' があっ
     たとき、タグを表示するには `-f' を使用する他ありません。

`-H'
`--help'
     指定された `cvs_command' の使用法を表示します (コマンドが実際に実
     行されることはありません)。コマンド名を指定しない場合には、`cvs
     -H' は他のヘルプオプションの一覧などを含む、CVS の全体のヘルプを
     表示します。

`-l'
     `cvs_command' をコマンド履歴に記録しません (しかしコマンドは実行
     されます)。コマンド履歴の情報は *Note history::.

`-n'
     ファイルを更新しません。`cvs_command' を実行した場合の表示だけが
     行なわれます。既存のファイルを削除, 更新, マージしたり、新しいファ
     イルを作成することはありません。

     CVS は必ずしも `-n' を付けなかったときと全く同じ出力をするわけで
     はないことに注意してください。ときどき、出力が同じ場合があります
     が、他の場合では、CVS は正確に同じ出力をするために必要な実行を飛
     ばします。

`-Q'
     コマンドの出力が完全に抑止され、重大な問題が発生した場合にのみ出
     力が行なわれます。

`-q'
     コマンドの出力を減らします。再帰的にサブディレクトリを辿る時の報
     告などの補助情報は抑止されます。

`-r'
     新たな作業ファイルを読み込み専用にします。環境変数 `$CVSREAD' を
     設定するのと同じ効果があります (*Note Environment variables::)。
     既定では、そのファイルが監視されてない限り作業ファイルへの書き込
     みが許可されます (*Note Watches::)。

`-s VARIABLE=VALUE'
     ユーザ変数を設定します (*Note Variables::)。

`-t'
     プログラムの実行状態をトレースします。CVS が実行する各ステップの
     情報を表示します。`-n' オプションと共に使用し、不慣れなコマンドの
     潜在的な影響を調べるのに便利です。

`-v'
`--version'
     CVS のバージョンと著作権情報を表示します。

`-w'
     新しい作業ファイルを読み書き可能にします。環境変数 `$CVSREAD' の
     設定を無効にします。`$CVSREAD' が設定されておらず、`-r' オプショ
     ンも無い場合には、作成されるファイルは読み書き可能とされます。

`-x'
     クライアントとサーバ間の全ての通信を暗号化します。これは CVS クラ
     イアントでだけ意味を持ち、また現時点では GSSAPI 接続を用いる場合 
     (*Note GSSAPI authenticated::) かケルベロス接続 (*Note Kerberos
     authenticated::) を用いる場合にしか実装されていません。暗号化を使
     用するということは送信されるメッセージも認証されるということです。
     既定状態では暗号化機能は使用できません。特別に 
     `--enable-encryption' を指定して CVS を構築する必要があります。

`-z GZIP-LEVEL'
     圧縮レベルを設定します。CVS クライアントでだけ意味を持ちます。




File: cvs-ja.info, Node: Common options, Next: admin, Prev: Global options, Up: CVS commands

共通のコマンド・オプション
==========================

ここでは、複数の CVS コマンドで共通に使用できる `command_options' につ
いて説明します。これらのオプションは、必ず `cvs_command' の右側に付け
られます。以下に示すオプションは、全てのコマンドで使えるわけではありま
せん。各オプションは、それが意味をなすコマンドにおいてのみ使用可能です。
しかし以下のオプションを持つコマンドがあるならば、そのオプションは他の
コマンドのものと同じ動作であると考えて良いでしょう。(各コマンドの固有
オプションのほとんどは、他の CVS コマンドのものとは異なる意味を持って
います。)

 *警告:* `history' コマンドは例外です。このコマンドには、ここに示す標
準オプションと重複する固有オプションが多くあります。

`-D DATE_SPEC'
     DATE_SPEC 以前のリビジョンのうち、最新のものを使用します。
     DATE_SPEC には、過去の日付を示すものを一つだけ指定します。

     このオプションを用いて作業ファイルを取り出すと、指定した日付が"貼
     り付け"られます。つまり `-D' オプションの引数が記録され、これ以後
     の `update' の際に同じ日付が用いられます (貼り付いたタグ/日付につ
     いての詳細は *Note Sticky tags::)。`-D' は以下のコマンドで利用で
     きます: `checkout', `diff', `export', `history', `rdiff', `rtag',
     `update'.  (`history' コマンドはこのオプションを少し違った方法で
     使用します。*Note history options::).


     CVS では、様々な形式で日付を指定できます。最も標準的なものは 
     (International Standards Organization による) ISO8601 と (RFC 822 
     で規定され、RFC1123 で修正された) Internet e-mail の標準です。

     ISO8601 はいろんな異種があります。すこし例を挙げます:

          1972-09-24
          1972-09-24 20:05

     ISO8601 の日付様式にはいろいろなものがあり、CVS はそれらの多くを
     受け付けますが、おそらくながーい話し*全部*を聞きたいとは思わない
     でしょう :-)。


     Internet e-mail で使用が認められている日付に加えて、CVS では、い
     くつかのフィールドが省略されたものも使えます。例えば、以下のよう
     なものです:

          24 Sep 1972 20:05
          24 Sep

     特定の標準時が指定されていない場合は、日付はローカルの標準時とし
     て解釈されます。

     この2つの書式の使用が好まれます。しかし、CVS は今は他の日付の書式
     を幅広く受け付けます。それらはここでは故意に詳しくは説明されてお
     らず、CVS の将来のバージョンはそれら全ては受け付けないかもしれま
     せん。

     そのような書式の中に`月/日/年'.  というものがあります。これは月と
     日が逆の順番になっているものに慣れている人を混乱させます。
     `1/4/96' は1月4日であり、4月1日ではありません。

     シェルは空白を引数の区切りにするので、`-D' の引数を引用符で囲むの
     を忘れてはいけません。`-D' オプションを付けたコマンド行は、次の様
     になるでしょう:

          $ cvs diff -D "1 hour ago" cvs.texinfo

`-f'
     日付やタグ名を指定して CVS コマンドを用いた場合、そのタグ名を持た
     ない (その時には存在しなかった) ファイルは、普通は無視されます。
     タグでも日付でも引っ掛からなかったファイルを復元したい場合に、
     `-f' オプションを使用します (そのファイルの最新のリビジョンが取り
     出されます)。

     `-f' のときでさえ、指定したタグは存在していなければならないことに
     注意してください (すなわち、必ずしも全てのファイルというわけでは
     なく、いくつかのファイルにおいて)。 これは CVS が、名前の入力を間
     違えたときにエラーを出すことを続けられるようにするためです。

     `-f' は以下のコマンドで利用できます: `annotate', `checkout',
     `export', `rdiff', `rtag', `update'.

     *警告:* `commit' と `remove' コマンドにも `-f' オプションがありま
     すが、異なる動作をします。*Note commit options::, *Note Removing
     files:: 参照。

`-k KFLAG'
     既定のキーワード置換モードを変更します。KFLAG の詳細は *Note
     Substitution modes:: 参照。

     このオプションを用いて作業ファイルを取り出すと、KFLAG が"貼り付け
     "られます。つまり、このオプションを `checkout' や `update' コマン
     ドに用いた場合、CVS は指定した KFLAG をそのファイルに結合します。
     これ以後、同ファイルに対する `update' コマンドには KFLAG が使用さ
     れ続けます。この効果は別の指定を行なうまで止みません。

     `-k' オプションは以下のコマンドで利用できます: `add', `checkout',
     `diff', `import', `update'.

`-l'
     Local の頭文字です。再帰的にサブディレクトリを辿らず、カレントディ
     レクトリでのみコマンドを実行します。

     *警告:* `cvs_command' の左側に指定する `cvs -l' と混同しないよう
     にして下さい。

     以下のコマンドで利用できます: `annotate', `checkout', `commit',
     `diff', `edit', `editors', `export', `log', `rdiff', `remove',
     `rtag', `status', `tag', `unedit', `update', `watch', and
     `watchers'.

`-m MESSAGE'
`-m MESSAGE'
     エディタを起動せず、ログ情報を MESSAGE に記述します。

     以下のコマンドで利用できます: `add', `commit', `import'.

`-n'
     `checkout'/`commit'/`rtag' コマンド実行時に、常には実行されるプロ
     グラムを実行しません。各コマンド実行時のプログラムは、管理用ファ
     イル `modules' に記述されます (*Note modules::)。つまり、このオプ
     ションは `modules' の記述を無効にします。

     *警告:* `cvs_command' の左側に指定する `cvs -n' と混同しないよう
     にして下さい。

     以下のコマンドで利用できます: `checkout', `commit', `export',
     `rtag'.

`-P'
     空のディレクトリを削除 (prune) します。*Note Removing
     directories:: 参照。

`-p'
     リポジトリから取得したファイルを、カレントディレクトリに置かず、
     標準出力に送り (pipe) ます。

     以下のコマンドで利用できます: `checkout', `update'.

`-R'
     再帰的にディレクトリを辿って実行します。これは指定しなくても実行
     されます。

     以下のコマンドで使用可能です: `annotate', `checkout', `commit',
     `diff', `edit', `editors', `export', `rdiff', `remove', `rtag',
     `status', `tag', `unedit', `update', `watch', `watchers'.

`-r TAG'
     既定の"先頭" ("head") リビジョンの代りに、引数 TAG で指定されたリ
     ビジョンを使用します。`tag' か `rtag' コマンドで任意に定義された
     タグの他に、二つの特別なタグ `HEAD' と `BASE' が常に利用できます。
     `HEAD' は、リポジトリにある最新のリビジョンを参照します。`BASE' 
     は、作業コピーの由来となるリビジョンを参照します。


     タグを指定して `checkout' や `update' コマンドを実行し、自分の作
     業ファイルを作った場合、そのタグは貼り付けられます。つまりこのタ
     グが記録され、以後他のものを指定するまで `update' に同じタグが使
     われ続けます (貼り付いたタグ/日付についての詳細は *Note Sticky
     tags::)。

     TAG には、*Note Tags:: で説明されているような文字列や、*Note
     Branching and merging:: で説明されているような枝の名前のどちらで
     あることもできます。

     コマンド・オプション `-r' と一緒に広域オプション `-q' を指定する
     と、RCS ファイルが指定したタグを含まない場合に、警告出力が抑止さ
     れるので便利です。

     *警告:* `cvs_command' の左側に指定する `cvs -r' と混同しないよう
     にして下さい!

     `-r' は以下のコマンドで利用できます :`checkout', `commit',
     `diff', `history', `export', `rdiff', `rtag', `update'.

`-W'
     フィルタを適用したいファイルを指定します。フィルタを適用したいファ
     イルが複数あるときは、このオプションを何個並べても構いません。ファ
     イル `.cvswrappers' での指定方法と同じ形式で指定します。

     以下のコマンドで利用できます: `import', `update'.




File: cvs-ja.info, Node: admin, Next: checkout, Prev: Common options, Up: CVS commands

admin--管理
===========

   * 必須: リポジトリ, 作業ディレクトリ
   * 変更: リポジトリ
   * 別名: rcs

これは雑多な管理機構への CVS のインターフェースです。CVS では役に立つ
か疑わしいようなものもありますが、歴史的な互換性の目的のために存在して
います。このコマンドは*必ず*再帰的に動作するため、使用の際には細心の注
意を払って下さい。

Unix ではグループ名 `cvsadmin' が存在する場合、そのグループの一員だけ
が `cvs admin' を利用できます(誰にで実行できる `cvs admin -k' コマンド
を除きます)。このグループはサーバ側か、非クライアント/サーバの CVS を
実行している全てのシステムで存在している必要があります。その名前で無人
のグループを作成すれば、`cvs admin' の使用を全面的に禁止できます。NT 
では、`cvsadmin' 機能は存在せず、全ての使用者が `cvs admin' を実行でき
ます。

* Menu:

* admin options::               admin のオプション



File: cvs-ja.info, Node: admin options, Prev: admin, Up: admin

admin のオプション
------------------

これらのオプションの中には CVS での有用性に疑問符が付くものもあります
が、歴史的な互換性のために存在しています。中には、効果を解除するまで、
CVS を使えなくなるものもあります!

`-AOLDFILE'
     CVS では使用されません。OLDFILE の利用者一覧を、指定した RCS ファ
     イルの利用者一覧に追加します。

`-aLOGINS'
     CVS では使用されません。RCS ファイルの利用者一覧に、LOGINS で指定
     された利用者を追加します。LOGINS はカンマで区切った利用者の一覧で
     す。

`-b[REV]'
     既定の枝を REV に設定します。CVS では、普通は既定の枝は操作しませ
     ん。貼り付いたタグ (*Note Sticky tags::) を使うのがどの枝で作業を
     するかを決める良い方法です。`cvs admin -b' を実行する理由は一つだ
     けあります: ベンダー枝を使用しているときに、ベンダーのバージョン
     に戻すため、です (*Note Reverting local changes::)。`-b' と引数の
     間に空白があってはいけません。

`-cSTRING'
     註釈符を STRING にします。註釈符は現在のバージョンの CVS でも、
     RCS 5.7 でも使用されていません。ですから、心配する必要は全くあり
     ません。*Note Keyword substitution::.

`-e[LOGINS]'
     CVS では使用されません。LOGINS に含まれる利用者を、RCS ファイルの
     利用者一覧から削除します。LOGINS が省略された場合は、利用者一覧を
     全て削除します。`-e' と引数の間に空白があってはいけません。

`-I'
     標準入力が端末でない場合でも対話的に動作します。このオプションは
     クライアント/サーバの CVS では動作せず、将来のCVS のリリースから
     は消えるでしょう。

`-i'
     CVS では無意味です。これはリビジョンを作成することなく、新しい 
     RCS ファイルを作成して、初期化します。CVS では、`cvs add' コマン
     ドでファイルを加えてください (*Note Adding files::)。

`-kSUBST'
     既定のキーワード置換モードを SUBST にします。*Note Substitution
     modes::.  ここで既定とした方法よりも、`cvs update', `cvs export',
     `cvs checkout' での `-k' オプションが優先されます。

`-l[REV]'
     リビジョン REV をロックします。枝番号が与えられた場合、その枝の最
     新リビジョンをロックします。REV が省略された場合は、既定の枝の最
     新リビジョンをロックします。引数 と `-l' の間にスペースがあっては
     いけません。

     CVS のソース配布物の中の `contrib' ディレクトリの中に、
     `rcslock.pl' という名前のスクリプトがあります。これを用いて上記の
     ロック状態を、CVS における独占取得 (一時に一人だけがファイル編集
     可能な状態) に置き換えることができます。詳細はスクリプトの註釈を
     参照して下さい (寄贈物の支援と権利の放棄声明文が書かれたファイル 
     `README' も一読して下さい)。その註釈によれば、厳格ロックモード 
     (既定) に設定しておく必要があります。

`-L'
     厳格にロックを求める設定 (厳格ロックモード) にします。厳格ロック
     モードだと、RCS ファイルの所有者であっても、ロックしていないファ
     イルは格納できません。CVS で使用する場合は、厳格ロックモードにす
     る必要があります。上記 `-l' オプションの説明も参照して下さい。

`-mREV:MSG'
     リビジョン REV のログ・メッセージを MSG に替えます。


`-NNAME[:[REV]]'
     これ以前の NAME の設定を無効にすることを除けば、`-n' と同じように
     働きます。魔法の枝での使用法は *Note Magic branch numbers:: を参
     照してください。

`-nNAME[:[REV]]'
     枝またはリビジョン REV にタグ名 NAME を付けます。通常は `cvs tag' 
     か `cvs rtag' を代わりに用いると良いでしょう。`:' と REV の両方を
     省略すると、タグ名が削除されます。また NAME が既に使用されていた
     場合は、エラー・メッセージが出力されます。REV がタグ名のときは、
     相当する番号に置換されます。枝番号の後に `.' を付けて REV に指定
     した場合、その枝の現時点での最新リビジョンになります。`:' だけで 
     REV を指定しなかった場合、既定の枝 (通常は幹) の現時点での最新リ
     ビジョンになります。例えば `cvs admin -nNAME: RCS/*' は、指定され
     た全ての RCS ファイルの、現時点での最新リビジョンに NAME というタ
     グ名を付けます。一方 `cvs admin -nNAME:$ RCS/*' では、各作業ファ
     イルのキーワード文字列に含まれるリビジョンに NAME というタグ名を
     付けます。

`-oRANGE'

     RANGE の範囲のリビジョンを消去 ("過去のものにする") します。

     このコマンドは何をしているかを *正確に* 知っていないと非常に危険
     であることに注意してください (例えば、以下の REV1:REV2 という構文
     がいかに間違いやすいかという警告を読んでください)。

     ディスクの容量が少ないなら、このオプションは役に立つかもしれませ
     ん。しかし、使う前によく考えてください--このコマンドを取り消すた
     めには最後のバックアップで復元するしかありません! 不注意や、(天が
     禁止している) CVS のバグによって、計画していたものと違うリビジョ
     ンを消してしまったら、リビジョンが消去される前のエラーを修正する
     機会はありません。おそらく、まずリポジトリのコピーで試すというの
     は良い考えでしょう。

     以下のどれかで RANGE を指定します:

     `REV1::REV2'
          CVS が rev1 から rev2 に関連付けられた差分だけを保存し、間の
          段階を保存しないように、rev1 と rev2 間の全てのリビジョンを
          壊します。例えば、`-o 1.3::1.5' の後では、リビジョン 1.3, リ
          ビジョン 1.5, 1.3 から 1.5 の差分を取得することができますが、
          リビジョン 1.4 や 1.3 と 1.4 の差分を取得することはできませ
          ん。他の例です: `-o 1.3::1.4' と`-o 1.3::1.3' は間に消去する
          リビジョンが無いので、何の効果もありません。

     `::REV'
          REV のある枝と REV 自身の間のリビジョンを壊します。枝の始点
          と REV はそのまま残ります。例えば、`-o ::1.3.2.6' はリビジョ
          ン 1.3.2.1, リビジョン 1.3.2.5, とその間の全てのものを消去し
          ますが、1.3 と 1.3.2.6 はそのまま残します。

     `REV::'
          REV と REV のある枝の最後との間のリビジョンを壊します。リビ
          ジョン REV はそのまま残りますが、先頭のリビジョンは消去され
          ます。

     `REV'
          リビジョン REV を消去します。例えば、`-o 1.3' は `-o
          1.2::1.4' と等価です。

     `REV1:REV2'
          同じ枝の REV1 から REV2 のリビジョンを、それを含めて消去し
          ます。REV1 や REV2 やその間の全てのリビジョンを取得するこ
          とはできなくなります。例えば、コマンド `cvs admin -oR_1_01:R_1_02
          .' はほとんど役に立ちません。それは、タグ R_1_02 までのリビジョンを、
          それを含めて消去するということです。でも注意してください!
          R_1_02 と R_1_03 で変更されていないファイルがあれば、そのファ
          イルはタグ R_1_02 と R_1_03 で*同じ*数値リビジョン番号になっ
          ています。ですから、R_1_02 を取得できなるだけではありません。
          R_1_03 もテープから復元しなければならなくなります! たいてい
          の場合、代わりに REV::REV2 と指定しようと思うでしょう。

     `:REV'
          REV のある枝の最初から、REV までのリビジョンを、それを含めて
          消去します。

     `REV:'
          REV のある枝の最後から、REV までのリビジョンを、それを含めて
          消去します。

     消去されるべきリビジョンは全て枝やロックを持っていてはいけません。

     消去されるべきリビジョンにタグ名があり、`::' 構文のどれかを指定す
     ると、CVS はエラーを出して、どのリビジョンも消去されません。タグ
     名とリビジョンの両方を消去したいなら、まず `cvs tag -d' でタグ名
     を消去し、それから `cvs admin -o' を実行します。`::' でない構文を
     いてい すると、CVS はリビジョンを消去しますが、タグ名を存在しない
     リビジョン指すタグ名として残します。この振舞いは CVS の以前のバー
     ジョンとの互換性のために残されています。しかし、これは便利ではあ
     りませんので、将来は `::' の場合と同様の振舞いに変更されるかもし
     れません。

     CVS が枝を扱う方法のために、REV は、もし枝であれば名前で指定する
     ことはできません。説明は、*Note Magic branch numbers::.

     だれも壊したリビジョンのコピーを取り出していないことを確認してく
     ださい。誰かがそれを編集して、格納し直そうとすると、変なことが起
     こります。このため、このオプションは無駄な格納を戻すためには良い
     方法ではありません。代わりにその変更を元に戻すための新しいリビジョ
     ンを格納してください (*Note Merging two revisions::)。

`-q'
     簡素な (quiet) 表示、つまり実行時に診断情報を表示しません。

`-sSTATE[:REV]'
     CVS でも使用します。リビジョン REV の状態を識別する文字列を STATE 
     にします。REV が枝番号の場合、その枝の最新リビジョンの状態を変更
     します。REV を省略すると、既定の枝の最新リビジョンを変更します。
     STATE には、どのような文字列を用いても構いません。通常使用される
     のは、`Exp' (実験段階), `Stab' (安定動作), `Rel' (出荷済) といっ
     た組み合わせです。既定では、新しく作成されたリビジョンの状態は 
     `Exp' にされます。各リビジョンの状態は、`cvs log' (*Note log::) 
     の出力や、キーワード `$Log$', `$State$' (*Note Keyword
     substitution::) の内容で確認できます。ここで、CVS が `dead' とい
     う状態を独自の目的で用いることに注意して下さい。`dead' 状態を扱う
     際には、`cvs remove' や `cvs add' といったコマンドを使用し、`cvs
     admin -s' を使用してはいけません。

`-t[FILE]'
     CVS でも使用します。RCS ファイルの説明文を FILE の内容に書き換え
     ます。FILE のパス名は `-' で始まってはいけません。各ファイルの説
     明文は `cvs log' (*Note log::) の出力で確認できます。`-t' と引数
     の間に空白があってはいけません。

     FILE が省略された場合、標準入力が用いられ、ファイル終端 (EOF) も
     しくは `.' のみの行で終了します。対話的動作が可能なら入力促進も可
     能です。`-I' を参照してださい。クライアント/サーバの CVS では標準
     入力からの読み込みは動作せず、将来の CVS のリリースでは変更される
     かもしれません。

`-t-STRING'
     `-tFILE' と同様です。RCS ファイルの説明文を STRING に書き換えます。
     `-t' と引数の間に空白があってはいけません。


`-U'
     厳格にはロックしない設定 (非厳格ロックモード) にします。非厳格ロッ
     クモードだと、RCS ファイルの所有者ならば、ロックしていないファイ
     ルも格納できます。CVS で使用する場合は、厳格ロックモードにする必
     要があります。上記 `-l' オプションの説明も参照して下さい。

`-u[REV]'
     このオプションを CVS で使用する際の説明は、上記 `-l' オプションを
     参照して下さい。リビジョン REV のロックを解除します。枝を指定した
     場合、その枝の最新リビジョンのロックを解除します。REV を省略する
     と、その人物が行なった最後のロックを解除します。通常は、ロックを
     掛けた人物だけがロックを解除できます。誰か他の人物がロックを解除
     した場合には、ロックを掛けた人物にメールが送信されます。このメー
     ルにはロックを解除した理由等が書き添えられます。連絡文はロックを
     解除した人物が入力し、ファイル終端 (EOF) もしくは `.' のみの行で
     終了します。`-u' とその引数の間に空白があってはいけません。

`-VN'
     前のバージョンの CVS ではこのオプションはバージョン N の RCS ファ
     イルが認識できる RCS ファイルを書くことを意味していましたが、今は
     旧式となり、それを指定するとエラーを起こします。

`-xSUFFIXES'
     前のバージョンの CVS では、これは RCS ファイルの名前を指定するた
     めの方法として説明されていました。しかし、CVS は常に CVS で使用さ
     れる RCS ファイルは `,v' で終わることを要求してきましたので、この
     オプションは今まで役に立ったことはありません。





File: cvs-ja.info, Node: checkout, Next: commit, Prev: admin, Up: CVS commands

checkout--編集の為にソースを取り出す
====================================

   * 書式: checkout [options] modules...
   * 必須: リポジトリ
   * 変更: 作業ディレクトリ
   * 別名: co, get

MODULES で指定されたモジュールの作業ディレクトリを作成、もしくは更新し、
その中にソース・ファイルをコピーします。CVS のほとんどのコマンドは作業
ディレクトリを扱うものなので、まず `checkout' を実行しておく必要があり
ます。

MODULES は、リポジトリ中のディレクトリやファイルへの相対パスだけでなく、
ディレクトリやファイルの集合に対する別名でも構いません。別名は管理用ファ
イル `modules' で定義します *Note modules::.

指定したモジュールにもよりますが、`checkout' は再帰的にディレクトリを
作成し、そこに適切なソース・ファイルを入れていきます。そして (他の開発
者が各自のコピーを編集しているかどうかに関わらず)、好きなときに自分の
ソース・ファイルを編集し、他人の変更を取り入れるために更新したり、自分
の変更をリポジトリに反映するために格納したりします。

`checkout' で作成されるディレクトリに注意して下さい。最上位のディレク
トリは、必ず `checkout' を実行したディレクトリに追加され、通常は指定し
たモジュールと同じ名前になります。モジュールに別名が定義されている場合、
サブディレクトリは違う名前になりますが心配は要りません。`checkout' の
処理中、各ファイルを作業領域に展開したと同時にその相対パスが表示されま
すから、この表示でサブディレクトリを確認して下さい (広域オプション 
`-Q' を付けた場合は表示がありません)。

CVS にオプション `-r' が付けられた場合 (*Note Global options::)、環境
変数 `CVSREAD' が設定されていた場合 (*Note Environment variables::)、
ファイルが監視されていた場合 (*Note Watches::) を除いて、`checkout' が
作成するファイルは読み書き可能な状態になります。

`checkout' で作成したディレクトリの上で、再度 `checkout' を実行しても
構わないということに注意してください。これはリポジトリに作成された新し
いディレクトリが作業領域に現れるという点で、`update' コマンドに `-d' 
オプションを付けるのと同様の効果があります。しかし、`update' は引数に
ディレクトリ名を取りますが、`checkout' は引数にモジュール名を取ります。
`checkout' をこの様に使うためには、最上位のディレクトリから実行しなけ
ればなりませんので (普段 `checkout' を実行する場所です)、存在するディ
レクトリを更新するために `checkout' を実行する前に、ディレクトリを最上
位のディレクトリに変更することを忘れないでください。

`checkout' コマンドの出力は *Note update output:: を参照して下さい。

* Menu:

* checkout options::            checkout のオプション
* checkout examples::           checkout の使用例



File: cvs-ja.info, Node: checkout options, Next: checkout examples, Prev: checkout, Up: checkout

checkout のオプション
---------------------

`checkout' では、以下の標準オプションが利用できます (完全な記述は 
*Note Common options::):

`-D DATE'
     DATE 以前の最も新しいリビジョンを取り出します。このオプションは貼
     り付けられ、勝手に `-P' オプションも実行されます。貼り付いたタグ/
     日付についての詳細は *Note Sticky tags::.

`-f'
     `-D DATE' や `-r TAG' と一緒に指定します。指定したリビジョンが見
     付からなかった場合、(そのファイルを無視せずに) 最も新しいリビショ
     ンを取り出します。

`-k KFLAG'
     キーワード置換モードを KFLAG に指定します。詳細は *Note
     Substitution modes:: を参照。このオプションは貼り付けられます。つ
     まりこれ以後、この作業ディレクトリでファイルが更新されるときには、
     同じ KFLAG が使用され続けます。`status' コマンドを用いて貼り付い
     たオプションを見ることができます。`status' コマンドの情報は *Note
     Invoking CVS:: を参照してください。

`-l'
     Local、つまり現在の作業ディレクトリでのみコマンドが実行されます。

`-n'
     ファイルを取り出したとき、普段は実行されるプログラムを実行しませ
     ん。このプログラムは管理用ファイル `modules' のオプション `-o' で
     指定されます (*Note modules::)。

`-P'
     空になったディレクトリを削除 (prune) します。*Note Moving
     directories:: を参照してください。

`-p'
     ファイルを標準出力に送り (pipe) ます。

`-R'
     ディレクトリを再帰的に取り出します。このオプションは指定しなくて
     も実行されます。

`-r TAG'
     TAG で指定されたリビジョンを取り出します。このオプションは貼り付
     けられ、`-P' オプションも勝手に実行されます。貼り付いたタグ/日付
     についての詳細は *Note Sticky tags::.

さらに `checkout' では次の固有オプションも使用可能です:

`-A'
     全ての貼り付いたタグや日付、また `-k' オプションの指定を剥がしま
     す。貼り付いたタグ/日付についての詳細は *Note Sticky tags:: を参
     照してください。

`-c'
     管理用ファイル `modules' の内容を、アルファベット順に並べて標準出
     力に出します。作業ディレクトリは全く変更されません。

`-d DIR'
     モジュール名を使用する代りに DIR というディレクトリを作成します。
     一般的に、このフラグは `mkdir DIR; cd DIR' の後に `-d' フラグ無し
     で checkout コマンドを実行することと同じです。

     しかし、重要な例外があります。単独の項目を取り出しているときには、
     出力に間に空のディレクトリが無いディレクトリが現れた方がとても便
     利です。この場合*のみ*、CVS は空のディレクトリを避けるためにパス
     名を "短く" します。

     例えば、ファイル `bar.c' がある `foo' というモジュールがあるとす
     ると、コマンド `cvs co -d dir foo' はディレクトリ `dir' を作成し、
     中に `bar.c' を置きます。同様に、サブディレクトリ `baz' があり、
     その中に `quux.c' のあるモジュール `bar' があるとすると、コマンド 
     `cvs -d dir co bar/baz' はディレクトリ `dir' 作成し、その中に 
     `quux.c' を置きます。

     `-N' フラグを使うと、この振舞いは抑制されます。上と同じモジュール
     の定義で、`cvs co -N -d dir foo' はディレクトリ `dir/foo' を作成
     してその中に `bar.c' を置き、`cvs co -N -d dir bar/baz' はディク
     トリ `dir/bar/baz' を作成してその中に `quux.c' を置きます。

`-j TAG'
     `-j' オプションを二つ指定した場合、最初に指定したリビションから次
     に指定したリビジョンへの変更を、作業ディレクトリにマージします。

     `-j' オプションが一つの場合、その分岐リビジョンから指定したリビジョ
     ンへの変更を、作業ディレクトリにマージします。分岐リビジョンとは、
     作業ディレクトリの元になったリビジョンと、`-j' で指定したリビジョ
     ンとの共通の祖先です。

     `-j' オプションに枝を指定する場合、日付の指定を付加することができ
     ます。このとき選択されるリビジョンは、指定日以前のものに制限され
     ます。日付の指定は、タグ名の後のコロン (:) に続けて記述します:
     `-jSYMBOLIC_TAG:DATE_SPECIFIER'。

     *Note Branching and merging::.

`-N'
     `-d DIR' と併用した場合にのみ有効です。このオプションを指定した場
     合、単独モジュールを取り出したときに、作業ディレクトリのモジュー
     ルパスを "短く" しません。例と説明は `-d' フラグを参照してくださ
     い。

`-s'
     `-c' と同様ですが、全てのモジュールの状態をアルファベット順に並べ
     て標準出力に出します。モジュールの状態を設定するために管理用ファ
     イル `modules' の中で使われるオプション `-s' の情報は、*Note
     modules::.



