Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Minibuffer History, Next: Completion, Prev: Object from Minibuffer, Up: Minibuffers

ミニバッファの履歴
==================

"ミニバッファ履歴リスト"（minibuffer history list）はミニバッファでの以
前の入力を記録し、ユーザーがそれらを手軽に再利用できるようにします。履歴
リストは実際にはシンボルでありリストではありません。最新のものが先頭にあ
る（以前の入力の）文字列のリストを値とする変数です。

異なる種類の入力に用いる多くの別々の履歴リストがあります。ミニバッファを
利用するたびに適した履歴リストを指定するのは、Lispプログラマの責任です。

基本的なミニバッファ入力関数`read-from-minibuffer'と`completing-read'の
両者は、読者が指定する履歴リストを省略可能な引数HISTとして受け付けます。
指定可能な値はつぎのとおりです。

VARIABLE
     変数VARIABLE（シンボル）を履歴リストとして用いる。

(VARIABLE . STARTPOS)
     変数VARIABLE（シンボル）を履歴リストとして用い、初期履歴位置を
     STARTPOS （履歴リストの最新要素を0とする整数）と仮定する。

     STARTPOSを指定した場合、整合性を保つために、履歴リストの当該要素を
     ミニバッファの初期内容にも指定すること。

HISTを指定しなければ、デフォルトの履歴リスト`minibuffer-history'を用いる。
その他の標準的な履歴リストについては以下を参照。読者が独自の履歴リスト変
数を作成してもよい。初めて使用するまえに単に`nil'で初期化しておく。

`read-from-minibuffer'と`completing-read'の両者は履歴リストに新たな要素
を自動的に追加し、リスト上の要素を再利用するためのコマンドをユーザーに提
供する。履歴リストを使うために読者のプログラムで行うべきことは、履歴リス
トを初期化し必要なときにその名前を入力関数に渡すだけである。ミニバッファ
入力関数が履歴リストを使用していないときには、履歴リストを変更しても安全
である。

標準的なミニバッファ履歴リスト変数を以下にあげておく。

 -- Variable: minibuffer-history
     ミニバッファの履歴入力用のデフォルトの履歴リスト。

 -- Variable: query-replace-history
     `query-replace'（および同様のコマンド）の引数用の履歴リスト。

 -- Variable: file-name-history
     ファイル名引数用の履歴リスト。

 -- Variable: buffer-name-history
     バッファ名引数用の履歴リスト。

 -- Variable: regexp-history
     正規表現引数用の履歴リスト。

 -- Variable: extended-command-history
     拡張コマンド名である引数用の履歴リスト。

 -- Variable: shell-command-history
     シェルコマンドである引数用の履歴リスト。

 -- Variable: read-expression-history
     Lisp式として評価する引数用の履歴リスト。



File: elisp-ja.info, Node: Completion, Next: Yes-or-No Queries, Prev: Minibuffer History, Up: Minibuffers

補完
====

"補完"（completion）とは、名前の省略から始まる名前の残り部分を補充する機
能です。ユーザー入力を正しい名前のリストと比較し、すでにユーザーが入力し
たものに名前がどの程度一致するかを決定することで補完します。たとえば、
`C-x b'（`switch-to-buffer'）と打って、切り替えたいバッファ名の始めの数
文字を打ってTAB（`minibuffer-complete'）を打つと、Emacsは可能な限りその
名前を補充します。

Emacsの標準のコマンドは、シンボル、ファイル、バッファ、プロセスの名前を
補完できます。本節の関数を用いれば、その他の種類の名前の補完も実装できま
す。

関数`try-completion'は補完のための基本関数です。与えられた文字列の集まり
から初期文字列にもっとも適合する最長のものを返します。

関数`completing-read'は補完のための上位レベルのインターフェイスを提供し
ます。`completing-read'の呼び出しには、正しい名前のリストを決定する方法
を指定します。この関数は、補完に有用なコマンドを数個のキーにバインドした
ローカルキーマップを使うミニバッファを活性にします。その他の関数は、特定
の種類の名前を補完して読み取るために単純化したインターフェイスを提供しま
す。

* Menu:

* Basic Completion::       Low-level functions for completing strings.
                             (These are too low level to use the minibuffer.)
* Minibuffer Completion::  Invoking the minibuffer with completion.
* Completion Commands::    Minibuffer commands that do completion.
* High-Level Completion::  Convenient special cases of completion
                             (reading buffer name, file name, etc.)
* Reading File Names::     Using completion to read file names.
* Programmed Completion::  Finding the completions for a given file name.



File: elisp-ja.info, Node: Basic Completion, Next: Minibuffer Completion, Prev: Completion, Up: Completion

基本補完関数
------------

2つの関数`try-completion'と`all-completions'は、それ自身ではミニバッファ
を使いません。これらについて本章で述べるのは、ミニバッファを使う上位レベ
ルの補完機能と同列にしておくためです。

 -- Function: try-completion STRING COLLECTION &optional PREDICATE
     この関数は、COLLECTIONにあるSTRINGを補完する共通の最長な部分文字列
     を返す。COLLECTIONの値は、連想リスト、オブジェクト配列、あるいは、
     実質的な文字列の集まりを返す関数（下記参照）であること。

     補完では、COLLECTIONで指定した各補完候補とSTRINGを比較する。補完候
     補の先頭部分がSTRINGに等しければ、その補完候補は一致するという。一
     致する補完候補がなければ、`try-completion'は`nil'を返す。たった1つ
     の補完候補に一致し、かつ、完全に一致すれば、`try-completion'は`t'を
     返す。さもなければ、一致する補完候補すべてに共通する最長の文字列を
     値とする。

     COLLECTIONが連想リスト（*Note Association Lists::）であると、連想リ
     ストの要素のCAR群が補完候補の集まりになる。

     COLLECTIONがオブジェクト配列（*Note Creating Symbols::）であると、
     オブジェクト配列内のすべてのシンボルの名前が補完候補の集まりになる。
     グローバル変数`obarray'は、インターンしたすべてのLispシンボルの名前
     を収めたオブジェクト配列を保持する。

     新たなオブジェクト配列を作成する唯一の正しい方法は、まず空で作成し
     てから`intern'で1つ1つシンボルを追加することであることに注意。なお、
     1つのシンボルを複数のオブジェクト配列にはインターンできない。

     引数PREDICATEが`nil'以外である場合、それは1引数の関数であること。そ
     の関数は一致する補完候補の検査に使われ、PREDICATEが`nil'以外を返す
     場合にのみ一致した候補とみなす。PREDICATEに渡す引数は、（CARが文字
     列である）連想リストのコンスセルであるか、オブジェクト配列からの
     （シンボル名では*ない*）シンボルである。

     COLLECTIONには、関数であるシンボルを使うこともできる。その関数には
     補完処理を完遂する責任がある。`try-completion'はその関数が返したも
     のを返す。その関数は3引数、つまり、STRING、PREDICATE、`nil'で呼ばれ
     る。（第3引数がある理由は、`all-completions'でも同じ関数を使い、い
     ずれの場合にも適切に動作できるようにするため。）*Note Programmed
     Completion::。

     以下の最初の例では、文字列`foo'は連想リストの3つのCARに一致する。す
     べての一致は`fooba'で始まるため、これが結果になる。2番目の例では、
     たった1つの一致があり、しかも、完全に一致するので、値は`t'である。

          (try-completion 
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               => "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               => t

     つぎの例では、`forw'で始まるシンボルが多数あり、それらはすべて単語
     `forward'で始まる。ほとんどのシンボルでは、これに`-'が続くが、すべ
     てがそうではないので、`forward'までしか補完できない。

          (try-completion "forw" obarray)
               => "forward"

     最後の例は、述語`test'の検査に通るのは3つの一致のうち2つだけである
     （文字列`foobaz'は短すぎる）。両者は文字列`foobar'で始まる。

          (defun test (s) 
            (> (length (car s)) 6))
               => test
          (try-completion 
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)) 
           'test)
               => "foobar"

 -- Function: all-completions STRING COLLECTION &optional PREDICATE NOSPACE
     この関数はSTRINGの補完すべてのリストを返す。この関数の引数は、
     `try-completion'のものと同じである。

     COLLECTIONが関数であると、STRING、PREDICATE、`t'の3引数で呼ばれる。
     `all-completions'はこの関数が返す値を返す。*Note Programmed
     Completion::。

     NOSPACEが`nil'以外であると、STRINGが空白で始まらない限り、空白で始
     まる補完は無視する。

     `try-completion'の例に示した関数`test'を用いた例を示す。

          (defun test (s) 
            (> (length (car s)) 6))
               => test

          (all-completions  
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               => ("foobar1" "foobar2")

 -- Variable: completion-ignore-case
     この変数の値が`nil'以外であると、Emacsは補完において大文字小文字を
     区別しない。



File: elisp-ja.info, Node: Minibuffer Completion, Next: Completion Commands, Prev: Basic Completion, Up: Completion

補完とミニバッファ
------------------

本節ではミニバッファからの補完による読み取り用の基本インターフェイスにつ
いて述べます。

 -- Function: completing-read PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL HIST DEFAULT INHERIT-INPUT-METHOD
     この関数は、与えられた補完でユーザーを補佐してミニバッファで文字列
     を読み取る。文字列であるプロンプトPROMPTでミニバッファを活性にする。

     実際の補完は、COLLECTIONとPREDICATEを関数`try-completion'に渡して行
     う。これは、補完を用いるローカルキーマップでバインドされたコマンド
     で行われる。

     REQUIRE-MATCHが`nil'であると、ミニバッファでの入力に関わらずミニバッ
     ファから抜けるコマンドは動作する。REQUIRE-MATCHが`t'であると、ミニ
     バッファでの入力がCOLLECTIONの1つの要素に補完できない限り、ミニバッ
     ファから抜ける通常のコマンドは動作しない。REQUIRE-MATCHが`nil'でも
     `t'でもないと、ミニバッファでの入力がCOLLECTIONの1つの要素に一致し
     ない限り、ミニバッファから抜けるコマンドは動作しない。

     しかし、REQUIRE-MATCHの値に関わらず、空の入力はつねに許される。その
     場合、`completing-read'はDEFAULTを返す。DEFAULTの値は（`nil'でなけ
     れば）履歴コマンドを介してもユーザーが使える。

     ミニバッファが空の状態でRETを打つと、ユーザーは空入力で抜けることが
     できる。そうすると、`completing-read'は`""'を返す。これにより、読み
     取った値に対してコマンドが使うどんなデフォルトでも指定できる。
     REQUIRE-MATCHの値、および、COLLECTIONに空文字列が含まれるかどうかに
     関わらず、ユーザーはこのようにしてRETで戻れる。

     関数`completing-read'は`read-minibuffer'を呼び出すことで動作する。
     REQUIRE-MATCHが`nil'であると、キーマップとして
     `minibuffer-local-completion-map'を使い、`nil'以外であると
     `minibuffer-local-must-match-map'を使う。*Note Completion
     Commands::。

     引数HISTは、入力を保存しミニバッファ履歴コマンドで使う履歴リスト変
     数を指定する。デフォルトは`minibuffer-history'である。*Note
     Minibuffer History::。

     INITIALが`nil'以外であると、`completing-read'はこれを入力の一部とし
     てミニバッファに挿入する。これにより、ユーザーは補完コマンドととも
     に入力を編集できる。ほとんどの場合、INITIALではなくDEFAULTを使うこ
     とを勧める。

     引数INHERIT-INPUT-METHODが`nil'以外であると、ミニバッファに入るまえ
     のカレントバッファがなんであれ、カレントバッファから現在の入力方式
     （*Note Input Methods::）と`enable-multibyte-characters'（*Note
     Text Representations::）の設定を継承する。

     組み込み変数`completion-ignore-case'が`nil'以外であると、大文字小文
     字を区別せずに候補に対して入力を比較する。*Note Basic Completion::。

     `completing-read'を用いた例を以下に示す。

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; 上の式を評価するとミニバッファはつぎのようになる 

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo-!-
          ---------- Buffer: Minibuffer ----------

     ユーザーが`DEL DEL b RET'を打つと、`completing-read'は`barfoo'を返
     す。

     関数`completing-read'は、補完を実際に行うコマンドに情報を渡すために
     3つの変数を束縛する。3つの変数とは、`minibuffer-completion-table'、
     `minibuffer-completion-predicate'、`minibuffer-completion-confirm'
     である。これらについて詳しくは、*Note Completion Commands::を参照。



File: elisp-ja.info, Node: Completion Commands, Next: High-Level Completion, Prev: Minibuffer Completion, Up: Completion

補完を行うミニバッファコマンド
------------------------------

本節では、補完を行うためにミニバッファで用いられるキーマップ、コマンド、
ユーザーオプションについて述べます。

 -- Variable: minibuffer-local-completion-map
     `completing-read'は、補完候補の1つと完全に一致しなくてもよい場合に
     ローカルキーマップとしてこの値を使う。デフォルトでは、このキーマッ
     プのバインディングはつぎのとおり。

     `?'
          `minibuffer-completion-help'

     SPC
          `minibuffer-complete-word'

     TAB
          `minibuffer-complete'

     他の文字は`minibuffer-local-map' （*Note Text from Minibuffer::）と
     同様にバインドされる。

 -- Variable: minibuffer-local-must-match-map
     `completing-read'は、補完候補の1つと完全に一致する必要がある場合に
     ローカルキーマップとしてこの値を使う。そのため、ミニバッファから無
     条件に抜けるコマンド`exit-minibuffer'にバインドしたキーはない。デフォ
     ルトでは、このキーマップのバインディングはつぎのとおり。

     `?'
          `minibuffer-completion-help'

     SPC
          `minibuffer-complete-word'

     TAB
          `minibuffer-complete'

     `C-j'
          `minibuffer-complete-and-exit'

     RET
          `minibuffer-complete-and-exit'

     他の文字は`minibuffer-local-map'と同様にバインドされる。

 -- Variable: minibuffer-completion-table
     この変数の値は、ミニバッファでの補完に用いられる連想リストやオブジェ
     クト配列である。これは、`completing-read'が`try-completion'に渡すも
     のを保持したグローバル変数である。`minibuffer-complete-word'などの
     ミニバッファ補完コマンドで使用される。

 -- Variable: minibuffer-completion-predicate
     この変数の値は、`completing-read'が`try-completion'へ渡す述語である。
     この変数は、他のミニバッファ補完関数でも使われる。

 -- コマンド: minibuffer-complete-word
     この関数は、ミニバッファの内容を多くても1単語分補完する。ミニバッファ
     の内容に対応する補完がたった1つであっても、単語構成文字ではない文字
     以降は補充しない。*Note Syntax Tables::。

 -- コマンド: minibuffer-complete
     この関数は、ミニバッファの内容を可能な限り補完する。

 -- コマンド: minibuffer-complete-and-exit
     この関数は、確認が必要でないとき、つまり、
     `minibuffer-completion-confirm'が`nil'であるときには、ミニバッファ
     の内容を補完後に抜ける。確認が必要*である*ときには、このコマンドを
     ただちに繰り返すことで確認をとる。このコマンドは、連続して2回呼ばれ
     ると、確認しないようにプログラムしてある。

 -- Variable: minibuffer-completion-confirm
     この変数の値が`nil'以外の場合、Emacsはミニバッファから抜けるまえに
     補完を確認してくる。関数`minibuffer-complete-and-exit'は、抜けるま
     えにこの変数の値を検査する。

 -- コマンド: minibuffer-completion-help
     この関数は、ミニバッファの現在の内容に対する補完のリストを作る。引
     数COLLECTIONとして変数`minibuffer-completion-table'の値を、引数
     PREDICATEとして`minibuffer-completion-predicate'の値を用いて
     `all-completions'を呼び出すことで動作する。補完のリストは、
     `*Completions*'という名前のバッファにテキストとして表示される。

 -- Function: display-completion-list COMPLETIONS
     この関数は、通常はバッファであるストリーム`standard-output'に
     COMPLETIONSを表示する。（ストリームについては詳しくは*Note Read and
     Print::。）引数COMPLETIONSは、普通は、`all-completions'が返した補完
     のリストであるが、そうでなくてもよい。各要素は、シンボルか文字列で
     あり、その場合、そのまま表示される。各要素が2つの文字列から成るリス
     トである場合、文字列を連結したものを表示する。

     この関数は、`minibuffer-completion-help'から呼ばれる。以下のように、
     `with-output-to-temp-buffer'とともに用いるのがもっとも一般的である。

          (with-output-to-temp-buffer "*Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 -- User Option: completion-auto-help
     この変数が`nil'以外であると、つぎの補充文字が一意に決まらない場合に
     は、自動的に補完のリストを表示する。



File: elisp-ja.info, Node: High-Level Completion, Next: Reading File Names, Prev: Completion Commands, Up: Completion

高レベルの補完関数
------------------

本節では、特定の種類の名前を補完付きで読み取るための高レベルの便利な関数
について述べます。

多くの場合、これらの関数をLisp関数の途中では呼び出さないでください。可能
な場合には、`interactive'の指定で、コマンドの引数を読み取る操作の一部と
してすべてのミニバッファ入力を行ってください。*Note Defining Commands::。

 -- Function: read-buffer PROMPT &optional DEFAULT EXISTING
     この関数はバッファ名を読み取り、文字列として返す。引数DEFAULTはデフォ
     ルトの名前を表し、ユーザーがミニバッファから空で抜け出したときに返
     される値である。`nil'以外であるときには、文字列かバッファであること。
     これはプロンプトとして現れるが、ミニバッファには初期入力として挿入
     されない。

     EXISTINGが`nil'以外であると、指定した名前は既存のバッファ名であるこ
     と。テキストが正しくないとミニバッファから抜ける通常のコマンドは動
     作せず、RETは正しい名前を探すため補完を行う。（しかし、DEFAULTが正
     しいかどうかは検査しない。ユーザーがミニバッファを空で抜ければ、な
     んであろうとDEFAULTが返される。）

     以下の例では、ユーザーは`minibuffer.t'と入力してからRETを打つ。引数
     EXISTINGは`t'であり、入力した名前で始まる唯一のバッファ名は
     `minibuffer.texi'であるので、この名前が値になる。

          (read-buffer "Buffer name? " "foo" t)
          ;; 上の式を評価すると、ミニバッファは空で
          ;; つぎのようなプロンプトが表示される

          ---------- Buffer: Minibuffer ----------
          Buffer name? (default foo) -!-
          ---------- Buffer: Minibuffer ----------

          ;; ユーザーはminibuffer.t RETと打つ
               => "minibuffer.texi"

 -- Variable: read-buffer-function
     この変数は、バッファ名の読み取り方を指定する。たとえば、この変数に
     `iswitchb-read-buffer'を設定すると、バッファ名を読み取るために
     `read-buffer'を呼び出すすべてのEmacsコマンドは、バッファ名を読むた
     めにパッケージ`iswitchb'を使うようになる。

 -- Function: read-command PROMPT &optional DEFAULT
     この関数はコマンド名を読み取り、Lispシンボルとして返す。引数PROMPT
     は、`read-from-minibuffer'と同様に使われる。なんであっても
     `commandp'が`t'を返せばコマンドであり、`commandp'が`t'を返すシンボ
     ルはコマンド名であることに注意。*Note Interactive Call::。

     引数DEFAULTは、ユーザー入力が空だった場合に返したい値を指定する。こ
     れは、シンボルか文字列であること。文字列であると、`read-command'は、
     これを返すまえにインターンする。DEFAULTが`nil'であると、デフォルト
     を指定しないことを意味し、ユーザー入力が空であると戻り値は`nil'であ
     る。

          (read-command "Command name? ")

          ;; 上の式を評価後には、ミニバッファは空で 
          ;; つぎのようなプロンプトが表示される

          ---------- Buffer: Minibuffer ---------- 
          Command name?  
          ---------- Buffer: Minibuffer ----------

     ユーザーが`forward-c RET'と打つと、この関数は`forward-char'を返す。

     関数`read-command'は`completing-read'のインターフェイスを単純化した
     ものである。既存のLispシンボルの集まりから補完するために変数
     `obarray'を使い、コマンド名のみを対象とするために述語`commandp'を使
     う。

          (read-command PROMPT)
          ==
          (intern (completing-read PROMPT obarray 
                                   'commandp t nil))

 -- Function: read-variable PROMPT &optional DEFAULT
     この関数はユーザー変数の名前を読み取り、シンボルとして返す。

     引数DEFAULTは、ユーザー入力が空だった場合に返したい値を指定する。こ
     れは、シンボルか文字列であること。文字列であると、`read-variable'は、
     これを返すまえにインターンする。DEFAULTが`nil'であると、デフォルト
     を指定しないことを意味し、ユーザー入力が空であると戻り値は`nil'であ
     る。

          (read-variable "Variable name? ")

          ;; 上の式を評価後には、ミニバッファは空で 
          ;; つぎのようなプロンプトが表示される

          ---------- Buffer: Minibuffer ----------
          Variable name? -!-
          ---------- Buffer: Minibuffer ----------

     ユーザーが`fill-p RET'と打つと、`read-variable'は`fill-prefix'を返
     す。

     この関数は`read-command'に似ているが、`commandp'のかわりに述語
     `user-variable-p'を使う。

          (read-variable PROMPT)
          ==
          (intern
           (completing-read PROMPT obarray
                            'user-variable-p t nil))

*Note User-Chosen Coding Systems::の関数`read-coding-system'や
`read-non-nil-coding-system'も参照してください。



File: elisp-ja.info, Node: Reading File Names, Next: Programmed Completion, Prev: High-Level Completion, Up: Completion

ファイル名の読み取り
--------------------

ここでは、ファイル名を読み取るように設計された高レベルの別の補完関数につ
いて述べます。デフォルトディレクトリの自動挿入などの特別な機能を提供しま
す。

 -- Function: read-file-name PROMPT &optional DIRECTORY DEFAULT EXISTING INITIAL
     この関数は、PROMPTをプロンプトとし、補完を行ってミニバッファでファ
     イル名を読み取る。DEFAULTが`nil'以外であると、ユーザーが単にRETを打
     つと、この関数はDEFAULTを返す。DEFAULTが正しいかどうかは検査せず、
     それがなんであれ、ユーザーがミニバッファを空で抜けるとそれを返す。

     EXISTINGが`nil'以外であると、ユーザーは既存ファイルの名前を指定する
     必要がある。RETは、可能ならば正しい名前に補完を行うが、それが正しく
     ない場合には抜けない。EXISTINGの値が`nil'でも`t'でもないと、RETは補
     完後の確認を必要とする。EXISTINGが`nil'であると、存在しないファイル
     の名前も許す。

     引数DIRECTORYは、相対ファイル名の補完に用いるディレクトリを指定する。
     `insert-default-directory'が`nil'以外であると、初期入力として
     DIRECTORYをミニバッファに挿入する。カレントバッファの
     `default-directory'の値がデフォルトになる。

     INITIALを指定すると、（DIRECTORYがあればそれを挿入後に）バッファに
     挿入される初期ファイル名になる。この場合、ポイントはINITIALの先頭に
     置かれる。INITIALのデフォルトは`nil'であり、いかなるファイル名も挿
     入しない。INITIALの動作を見るには、コマンド`C-x C-v'を試してほしい。
     *注意：*` ' ほとんどの場合、INITIALではなくDEFAULTを使うことを勧め
     る。

     例を示す。

          (read-file-name "The file is ")

          ;; 上の式を評価後には、ミニバッファはつぎのようになる

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/-!-
          ---------- Buffer: Minibuffer ----------

     `manual TAB'を打つと、つぎのようになる。

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi-!-
          ---------- Buffer: Minibuffer ----------

     ユーザーがRETと打つと、`read-file-name'はファイル名を文字列
     `"/gp/gnu/elisp/manual.texi"'として返す。

 -- User Option: insert-default-directory
     この変数は`read-file-name'が使う。その値は、`read-file-name'が、デ
     フォルトディレクトリの名前と（あれば）初期ファイル名をミニバッファ
     に入れて動作を開始するかどうかを制御する。この変数の値が`nil'である
     と、`read-file-name'は（引数INITIALで初期入力を指定しない限り）ミニ
     バッファに初期入力を入れない。その場合でも、相対ファイル名の補完に
     はデフォルトディレクトリを使うが表示はしない。

     例を示す。

          ;; デフォルトディレクトリを入れて始める
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/-!-
          ---------- Buffer: Minibuffer ----------

          ;; ミニバッファは空であり、プロンプトのみ
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is -!-
          ---------- Buffer: Minibuffer ----------



File: elisp-ja.info, Node: Programmed Completion, Prev: Reading File Names, Up: Completion

プログラム補完
--------------

意図した補完候補を持った連想リストやオブジェクト配列を作成することが困難
な場合もあります。そのような場合、与えられた文字列に対する補完を計算する
独自の関数を与えることができます。これを"プログラム補完"（programmed
completion）と呼びます。

この機能を使うには、`completing-read'の引数COLLECTIONに関数定義を持つシ
ンボルを渡します。関数`completing-read'は、`try-completion'や
`all-completions'に読者の補完関数を渡すようにして、読者の関数にすべてを
任せます。

補完関数はつぎの3つの引数を受け取ります。

   * 補完すべき文字列。

   * 補完候補を選別する述語関数、あるいは、選別しないのならば`nil'。読者
     の関数では、各補完候補についてこの述語を呼び出し、`nil'が返されたら
     当該候補を無視する。

   * 操作の型を示すフラグ。

3つの操作型に対応してフラグの値は3つあります。

   * `nil'は`try-completion'を指定する。補完関数は、指定された文字列の補
     完を返すこと。あるいは、文字列が一意に完全に一致する場合には`t'を返
     し、文字列の補完がまったくなければ`nil'を返す。

     文字列が一意に完全に一致する場合であっても、より長い候補に一致する
     場合には、この関数は`t'ではなく文字列を返すこと。

   * `t'は`all-completions'を指定する。補完関数は、指定された文字列に対
     する補完のリストを返すこと。

   * `lambda'は、完全な一致を指定する。補完関数は、指定された文字列が候
     補に完全に一致する場合には`t'を返し、さもなければ`nil'を返すこと。

補完関数COLLECTIONには関数シンボルに加えて、ラムダ式（関数であるリスト）
も許すほうが一貫性があって見通しがよいはずですが、それは不可能です。リス
トには補完候補表としての意味がすでにあり、連想リストがそれです。関数とし
ての可能性もある通常の連想リストの扱いに失敗するようでは、信頼性がなくな
ります。そのため、読者が補完に使用したい関数は、シンボルに入れておく必要
があるのです。

Emacsは、ファイル名の補完にはプログラム補完を用います。*Note File Name
Completion::。



File: elisp-ja.info, Node: Yes-or-No Queries, Next: Multiple Queries, Prev: Completion, Up: Minibuffers

Yes/Noの問い合わせ
==================

本節ではユーザーにyes/noを問い合わせるための関数について述べます。関数
`y-or-n-p'には、1文字で答えます。誤った答えでも重大な問題に至らないよう
な問い合わせに便利です。`yes-or-no-p'には3文字か4文字で答える必要がある
ため、より重要な問い合わせに適しています。

これらの関数がマウスを使って起動されたコマンドから呼ばれると、より正確に
は、`last-nonmenu-event'（*Note Command Loop Info::）が`nil'かリストであ
ると、関数は問い合わせのための対話ボックスやポップアップメニューを使いま
す。さもなければ、キーボード入力を使います。呼び出しにおいて
`last-nonmenu-event'に適切な値を束縛することでマウスかキーボード入力の使
用を強制できます。

厳密にいえば、`yes-or-no-p'はミニバッファを使いますが、`y-or-n-p'は使い
ません。ですが、両者をここで説明しておきます。

 -- Function: y-or-n-p PROMPT
     この関数はユーザーに問い合わせ、エコー領域で入力を待ちます。ユーザー
     が`y'を打てば`t'を返し、`n'を打てば`nil'を返します。さらに、SPCを
     「y」、DELを「n」ともみなします。`C-]'を`C-g'のように『中断』ともみ
     なします。というのは、問い合わせはミニバッファを使っているようにみ
     えるので、これから抜けるためにユーザーが`C-]'を使いそうだからである。
     応答は1文字であり、RETで終える必要はない。大文字と小文字は同じ意味
     である。

     『問い合わせ』では、エコー領域にPROMPTを表示し、
     文字列`(y or n) 'が続きます。
     入力が正しい応答（`y'、`n'、`SPC'、
     `DEL'、中断など）でないと、
     関数は`Please answer y or n.'を表示して
     問い合わせるを繰り返す。

     応答は編集できないので、この関数は実際にはミニバッファを使わない。
     ミニバッファが使うのと同じ画面領域を使うエコー領域（*Note The Echo
     Area::）を実際には使う。問い合わせ中は、カーソルはエコー領域に移動
     する。

     応答とその意味は、たとえ`y'や`n'であっても組み込まれているわけでは
     ない。キーマップ`query-replace-map'がそれらを指定する。*Note Search
     and Replace::。

     以下の例では、ユーザーはまず`q'を打つが、これは正しくない。つぎのプ
     ロンプトに対して、ユーザーは`y'を打つ。

          (y-or-n-p "Do you need a lift? ")

          ;; 上の式を評価後には、エコー領域には
          ;; つぎのプロンプトが表示される

          ---------- Echo area ----------
          Do you need a lift? (y or n) 
          ---------- Echo area ----------

          ;; ユーザーがqを打つと、つぎのようになる

          ---------- Echo area ----------
          Please answer y or n.  Do you need a lift? (y or n) 
          ---------- Echo area ----------

          ;; ユーザーが正しい応答を打つと
          ;; 問い合わせのうしろに表示される

          ---------- Echo area ----------
          Do you need a lift? (y or n) y
          ---------- Echo area ----------

     ここでは、エコー領域のメッセージを複数行示したが、実際には、1度に1
     つのメッセージだけが表示される。

 -- Function: y-or-n-p-with-timeout PROMPT SECONDS DEFAULT-VALUE
     `y-or-n-p'と同様だが、ユーザーがSECONDS秒以内に答えないと、入力を待
     たずにDEFAULT-VALUEを返す。これにはタイマを使う。*Note Timers::を参
     照。引数SECONDSは整数でも浮動小数点でもよい。

 -- Function: yes-or-no-p PROMPT
     この関数はユーザーに問い合わせ、ミニバッファでの入力を仮定する。ユー
     ザーが`yes'を入力すると`t'を返し、`no'を入力すると`nil'を返す。応答
     を終えるためにユーザーはRETを打つ必要がある。大文字と小文字は同じ意
     味である。

     `yes-or-no-p'は、まず、PROMPTに続けて
     `(yes or no) 'をエコー領域に表示する。
     ユーザーは正しい応答の1つを入力する必要がある。
     さもないと、この関数は`Please answer yes or no.'を2秒ほど
     表示してから問い合わせを繰り返す。

     `yes-or-no-p'は`y-or-n-p'よりもユーザーの手間を必要とし、より重要な
     決定に適している。

     例を示す。

          (yes-or-no-p "Do you really want to remove everything? ")

          ;; 上の式を評価後には、つぎのプロンプトが 
          ;; 空のミニバッファとともに表示される 

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no) 
          ---------- Buffer: minibuffer ----------

     ユーザーは、まず`y RET'を打つが、この関数は完全な単語`yes'を要求す
     るので正しくない。以下のプロンプトを少し時間をおいて表示する。

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------



File: elisp-ja.info, Node: Multiple Queries, Next: Reading a Password, Prev: Yes-or-No Queries, Up: Minibuffers

複数のY/Nの問い合わせ
=====================

各バッファについて『バッファを保存するか』などの一連の単純な問い合わせを
する場合には、個々に問い合わせるかわりに`map-y-or-n-p'を用いてまとめて問
い合わせるべきです。

 -- Function: map-y-or-n-p PROMPTER ACTOR LIST &optional HELP ACTION-ALIST
     この関数は、各問について1文字の応答をエコー領域から読み取ることで、
     ユーザーに一連の問い合わせを行う。

     LISTの値は、問い合わせ対象のオブジェクトを指定する。オブジェクトの
     リストであるか、生成関数であること。関数である場合、それは引数なし
     で呼ばれ、つぎの問い合わせ対象のオブジェクトを返すか、問い合わせの
     終了を意味する`nil'を返す。

     引数PROMPTERは、各問い合わせをどのように問うかを指定する。PROMPTER
     が文字列であると、問い合わせ文はつぎのように計算される。

          (format PROMPTER OBJECT)

     ここで、OBJECTは（LISTから得た）問い合わせ対象のオブジェクトである。

     文字列でなければ、PROMPTERは1引数（問い合わせ対象のオブジェクト）の
     関数であり、問い合わせ文を返す。値が文字列であれば、それがユーザー
     への問い合わせ文になる。関数は、（ユーザーに問い合わせずに）当該オ
     ブジェクトを処理することを意味する`t'か、（ユーザーに問い合わせずに）
     当該オブジェクトを無視することを意味する`nil'を返してもよい。

     引数ACTORは、ユーザーの応答に対してどのように動作するかを指定する。
     これは1引数の関数であり、ユーザーが「はい」と答えたオブジェクトで呼
     ばれる。引数は、つねにLISTから得たオブジェクトである。

     引数HELPを指定する場合、つぎの形のリストであること。

          (SINGULAR PLURAL ACTION)

     ここで、SINGULARは操作対象のオブジェクトを記述する単数形の名詞を含
     んだ文字列であり、PLURALは対応する複数形の名詞であり、ACTIONは動作
     を記述する他動詞であること。

     HELPを指定しないと、デフォルトは`("object" "objects" "act on")'であ
     る。

     各問い合わせでは、ユーザーは当該対象オブジェクトに対する操作に`y'、
     `Y'、`SPC'で答える。`n'、`N'、DELは、そのオブジェクトを無視する。
     `!'はそのオブジェクトを含めて後続のものも処理する。ESCや`q'は（後続
     のオブジェクトをすべて無視して）抜ける。`.'（ピリオド）は現在の対象
     オブジェクトを処理してから抜ける。`C-h'はヘルプメッセージを表示する。
     これらは、`query-replace'が受け付ける応答と同じである。キーマップ
     `query-replace-map'が、`query-replace'と同様に`map-y-or-n-p'に対す
     る（応答の）意味を定義する。*Note Search and Replace::を参照。

     ACTION-ALISTを使って、可能な応答とそれらの意味を追加指定することも
     できる。これは、`(CHAR FUNCTION HELP)'の形の要素から成る連想リスト
     であり、それぞれが1つの追加応答を定義する。この要素の中で、CHARは
     （応答である）1つの文字、FUNCTIONは1引数（LISTからのオブジェクト）
     の関数、HELPは文字列である。

     ユーザーがCHARで答えると、`map-y-or-n-p'はFUNCTIONを呼び出す。これ
     が`nil'以外を返せば、当該オブジェクトを『処理』したとみなして、
     `map-y-or-n-p'はLISTのつぎのオブジェクトに移る。`nil'であると、同じ
     オブジェクトについてプロンプトを繰り返す。

     `map-y-or-n-p'がマウスを使って起動されたコマンドから呼ばれると、よ
     り正確には、`last-nonmenu-event'（*Note Command Loop Info::）が、
     `nil'かリストであると、関数は問い合わせのための対話ボックスやポップ
     アップメニューを使う。その場合、キーボード入力やエコー領域は使わな
     い。呼び出しにおいて`last-nonmenu-event'に適切な値を束縛することで
     マウスかキーボード入力の使用を強制できる。

     `map-y-or-n-p'の戻り値は、処理したオブジェクトの個数である。



File: elisp-ja.info, Node: Reading a Password, Next: Minibuffer Misc, Prev: Multiple Queries, Up: Minibuffers

パスワードの読み取り
====================

別のプログラムへ渡すパスワードを読み取るには、関数`read-passwd'を使いま
す。

 -- Function: read-passwd PROMPT &optional CONFIRM DEFAULT
     この関数は、プロンプトPROMPTを表示してパスワードを読み取る。ユーザー
     が入力するパスワードは表示せず、そのかわりにパスワードの各文字ごと
     に`.'を表示する。

     省略可能な引数CONFIRMが`nil'以外であると、パスワードを2回読み取り、
     両者が同一である必要がある。同一でないと、連続して2回同じパスワード
     を打つまでユーザーは何度でも繰り返す必要がある。

     省略可能な引数DEFAULTは、ユーザーが空のパスワードを入力したときに返
     すデフォルトのパスワードを指定する。DEFAULTが`nil'であると、
     `read-passwd'はそのような場面では空文字列を返す。



File: elisp-ja.info, Node: Minibuffer Misc, Prev: Reading a Password, Up: Minibuffers

ミニバッファに関するその他
==========================

本節では、ミニバッファに関係する他の基本関数や変数について述べます。

 -- コマンド: exit-minibuffer
     このコマンドは活性なミニバッファから抜ける。通常、ミニバッファのロー
     カルキーマップでキーにバインドされる。

 -- コマンド: self-insert-and-exit
     このコマンドは（*Note Command Loop Info::の`last-command-char'にあ
     る）最新のキーボード入力文字を活性なミニバッファに挿入してから抜け
     る。

 -- コマンド: previous-history-element N
     このコマンドは、ミニバッファの内容をN番目まえの（古い）履歴要素の値
     で置き換える。

 -- コマンド: next-history-element N
     このコマンドは、ミニバッファの内容をN番目先のより新しい履歴要素の値
     で置き換える。

 -- コマンド: previous-matching-history-element PATTERN
     このコマンドは、ミニバッファの内容をPATTERN（正規表現）に一致するま
     えの（古い）履歴要素の値で置き換える。

 -- コマンド: next-matching-history-element PATTERN
     このコマンドは、ミニバッファの内容をPATTERN（正規表現）に一致するつ
     ぎの（新しい）履歴要素の値で置き換える。

 -- Function: minibuffer-prompt
     この関数は、現在活性なミニバッファのプロンプト文字列を返す。活性な
     ミニバッファがなければ`nil'を返す。

 -- Function: minibuffer-prompt-width
     この関数は、現在活性なミニバッファのプロンプト文字列の表示幅を返す。
     活性なミニバッファがなければ0を返す。

 -- Variable: minibuffer-setup-hook
     ミニバッファに入るたびに実行されるノーマルフック。*Note Hooks::。

 -- Variable: minibuffer-exit-hook
     ミニバッファから抜けるたびに実行されるノーマルフック。*Note Hooks::。

 -- Variable: minibuffer-help-form
     この変数の現在値は、ミニバッファの内側で`help-form'のローカルな束縛
     に使われる。（*Note Help Functions::）。

 -- Function: active-minibuffer-window
     この関数は、現在活性なミニバッファのウィンドウを返す。あるいは、活
     性なミニバッファがなければ`nil'を返す。

 -- Function: minibuffer-window &optional FRAME
     この関数は、フレームFRAMEで使われるミニバッファ用ウィンドウを返す。
     FRAMEが`nil'であると、カレントフレームを意味する。フレームで使うミ
     ニバッファ用ウィンドウは、そのフレームの一部である必要はない。ミニ
     バッファを持たないフレームでは、他のフレームのミニバッファ用ウィン
     ドウを使う。

 -- Function: window-minibuffer-p WINDOW
     この関数は、WINDOWがミニバッファ用ウィンドウであると`nil'以外を返す。

与えられたウィンドウがミニバッファ用であるかどうかを調べるために、
`(minibuffer-window)'の戻り値と比較するのは正しくありません。というのは、
フレームが複数個あると複数のミニバッファ用ウィンドウがあるからです。

 -- Function: minibuffer-window-active-p WINDOW
     この関数は、ミニバッファ用ウィンドウWINDOWが活性であると`nil'以外を
     返す。

 -- Variable: minibuffer-scroll-window
     この変数の値が`nil'以外であると、値はウィンドウオブジェクトであるこ
     と。ミニバッファで関数`scroll-other-window'が呼ばれると、
     `scroll-other-window'はこのウィンドウをスクロールする。

最後に、再帰ミニバッファ（*Note Recursive Editing::）を扱う関数と変数に
ついて述べます。

 -- Function: minibuffer-depth
     この関数は、活性なミニバッファの現在の深さを非負整数で返す。活性な
     ミニバッファがなければ0を返す。

 -- User Option: enable-recursive-minibuffers
     この変数が`nil'以外であると、ミニバッファ用ウィンドウが活性であって
     も、（`find-file'などの）ミニバッファを使うコマンドを起動できる。そ
     のような起動では、新たなミニバッファに対する再帰編集レベルが作られ
     る。内側の（深い）ミニバッファを編集中には、外側の（浅い）レベルの
     ミニバッファは見えない。

     この変数が`nil'であると、ミニバッファ用ウィンドウが活性なときには、
     別のウィンドウに切り替えたとしてもミニバッファコマンドは使えない。

コマンド名に`nil'以外の属性`enable-recursive-minibuffers'があると、当該
コマンドをミニバッファから起動したときでさえ、当該コマンドはミニバッファ
を使って引数を読み取れます。ミニバッファコマンド
`next-matching-history-element' （ミニバッファでは通常`M-s'）は、この機
能を使っています。


File: elisp-ja.info, Node: Command Loop, Next: Keymaps, Prev: Minibuffers, Up: Top

コマンドループ
**************

読者がEmacsを起動すると、Emacsはほぼただちに"エディタコマンドループ" 
（editor command loop）に入ります。このループは、キー列を読み取り、それ
らの定義を実行し、結果を表示します。本章では、これがどのように行われるの
か、および、Lispプログラムからこれを行うためのサブルーティンについて述べ
ます。

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How `C-g' works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.



File: elisp-ja.info, Node: Command Overview, Next: Defining Commands, Prev: Command Loop, Up: Command Loop

コマンドループの概要
====================

コマンドループがまず始めに行うことはキー列、つまり、コマンドへ変換される
イベント列を読むことです。これには関数`read-key-sequence'を呼び出します。
読者のLispコードでもこの関数を呼び出せます（*Note Key Sequence Input::）。
Lispプログラムでは、`read-event'（*Note Reading One Event::）で低レベル
の入力を行ったり、`discard-input'（*Note Event Input Misc::）で処理待ち
中の入力を破棄できます。

キー列は現在活性なキーマップを介してコマンドに変換されます。この処理方法
については*Note Key Lookup::。この結果は、キーボードマクロであるか、対話
的に呼び出し可能な関数であるはずです。キーが`M-x'であると、別のコマンド
の名前を読み取り、そのコマンドを呼び出します。これはコマンド
`execute-extended-command'（*Note Interactive Call::）で処理されます。

コマンドを実行するには、まず、その引数を読む必要があります。これは、
`command-execute'（*Note Interactive Call::）を呼び出して行います。Lisp
で書かれたコマンドでは、`interactive'指定が引数の読み方を指示します。前
置引数（*Note Prefix Command Arguments::）を使ったり、プロンプトを表示し
てミニバッファ（*Note Minibuffers::）から読みます。たとえば、コマンド
`find-file'には、ミニバッファからファイル名を読むことを指示した
`interactive'指定があります。コマンドの関数本体ではミニバッファを使いま
せん。このコマンドをLispコードから関数として呼び出す場合、通常のLisp関数
の引数としてファイル名文字列を指定する必要があります。

コマンドが文字列やベクトル（つまり、キーボードマクロ）である場合、
`execute-kbd-macro'を用いてそれらを実行します。読者自身がこの関数を呼び
出してもかまいません（*Note Keyboard Macros::）。

動作中のコマンドの実行を止めるには、`C-g'を打ちます。この文字は"中断"
（quitting）を引き起こします（*Note Quitting::）。

 -- Variable: pre-command-hook
     エディタコマンドループは、各コマンドのまえにこのノーマルフックを実
     行する。その際、`this-command'にはこれから実行するコマンドが保持さ
     れ、`last-command'には直前のコマンドがある。*Note Hooks::。

 -- Variable: post-command-hook
     エディタコマンドループは、（中断やエラーのために完了しなかったコマ
     ンドを含めて）各コマンドのあとにこのノーマルフックを実行する。初め
     てコマンドループに入ったときにも実行する。その際、`this-command'に
     は実行し終えたばかりのコマンドがあり、`last-command'にはその前のコ
     マンドがある。*Note Hooks::。

`pre-command-hook'や`post-command-hook'の実行中は、中断を禁止します。こ
れらのフックの1つを実行中にエラーが起きると、エラーの無限ループを防ぐた
めに、フックの実行を終了しフック変数を`nil'にします。



File: elisp-ja.info, Node: Defining Commands, Next: Interactive Call, Prev: Command Overview, Up: Command Loop

コマンドの定義
==============

Lisp関数の本体に、スペシャルフォーム`interactive'を呼び出すフォームがトッ
プレベルにあると、Lisp関数はコマンドになります。このフォームは実際に呼び
出されてもなにもしませんが、このフォームがあることで、対話的に呼び出せる
ことを表します。その引数が、対話的呼び出しにおける引数の読み方を制御しま
す。

* Menu:

* Using Interactive::     General rules for `interactive'.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.



File: elisp-ja.info, Node: Using Interactive, Next: Interactive Codes, Prev: Defining Commands, Up: Defining Commands

`interactive'の使い方
---------------------

本節では、Lisp関数を対話的に呼び出し可能なコマンドにするフォーム
`interactive'の書き方について述べます。

 -- Special form: interactive ARG-DESCRIPTOR
     このスペシャルフォームは、これを含む関数がコマンドであり、（`M-x'や
     当該関数にバインドしたキー列を入力することで）対話的に呼び出せるこ
     とを宣言する。引数ARG-DESCRIPTORは、コマンドを対話的に呼び出したと
     きにコマンドに対する引数の計算方法を宣言する。

     他の関数と同様に、コマンドはLispプログラムからも呼び出せるが、その
     場合、呼び出し側が引数を渡し、ARG-DESCRIPTORにはなんの効果もない。

     フォーム`interactive'が効果を発揮するのは、コマンドループ（実際には
     サブルーティン`call-interactively'）が関数を呼び出すまえに関数定義
     を走査してこのフォームを探すからである。関数が呼び出されると、フォー
     ム`interactive'を含めてその本体のフォームが実行されるが、そのとき、
     `interactive'は引数を評価せずに単に`nil'を返す。

引数ARG-DESCRIPTORには3つの可能性があります。

   * 省略するか`nil'。この場合、コマンドは引数なしで呼ばれる。コマンドが
     1つ以上の引数を必要とする場合、これはただちにエラーになる。

   * 文字列ではないLisp式。この場合、それはフォームであり、コマンドに渡
     す引数リストを得るために評価される。

     この式が（ミニバッファを使うことを含めて）キーボード入力を読む場合
     には、入力を読むまえのポイントの整数値やマークは、入力を読んだあと
     では正しくない可能性があることに留意すること。カレントバッファがサ
     ブプロセスの出力を受け取る可能性があるからである。コマンドが入力を
     待っているあいだにサブプロセスの出力が到着すると、ポイントやマーク
     を再配置する可能性がある。

     しては*いけない*ことの例を示す。

          (interactive
           (list (region-beginning) (region-end)
                 (read-string "Foo: " nil 'my-history)))

     キーボード入力を読み終えてからポイントやマークを調べることで、問題
     を回避する。

          (interactive
           (let ((string (read-string "Foo: " nil 'my-history)))
             (list (region-beginning) (region-end) string)))

   * 文字列。この場合、その内容は、コード文字とそれに続く（コード文字に
     よっては使ったり無視する）プロンプトから成ること。プロンプトは、文
     字列の終りか改行で終る。簡単な例を示す。

          (interactive "bFrobnicate buffer: ")

     コード文字`b'は、補完を用いて既存のバッファ名を読むことを指示する。
     バッファ名は、コマンドに渡される唯一の引数である。文字列の残りはプ
     ロンプトである。

     文字列内に改行文字があると、それはプロンプトを終える。その部分で文
     字列が終らないときには、文字列の残りの部分には、別の引数を指定する
     コード文字やプロンプトがある。このようにして、何個の引数でも指定で
     きる。

     プロンプトの文字列では、プロンプト内の（第1引数から始まる）まえの引
     数値を含めるために`%'を使える。これは`format'（*Note Formatting
     Strings::）を用いて行う。たとえば、既存バッファの名前を読み、続けて
     そのバッファに与える新たな名前を読むにはつぎのようにする。

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     文字列の最初の文字が`*'である場合、バッファが読み出し専用であるとエ
     ラーを通知する。

     文字列の最初の文字が`@'であり、コマンドを起動したキー列にマウスイベ
     ントが含まれる場合、コマンドを実行するまえにそれらのイベントの最初
     のものに関連したウィンドウを選択する。

     `*'と`@'は同時に使え、その順序は関係ない。引数の実際の読み取りはプ
     ロンプトの（`*'でも`@'でもない最初の文字で始まる）残りの部分で制御
     される。



File: elisp-ja.info, Node: Interactive Codes, Next: Interactive Examples, Prev: Using Interactive, Up: Defining Commands

`interactive'のコード文字
-------------------------

以下に述べるコード文字の説明では、つぎに定義するいくつかのキーワードを含
みます。

「補完」
     補完を使える。`completing-read'を使って引数を読むため、TAB、SPC、
     RETは名前を補完する（*Note Completion::）。`?'は補完候補のリストを
     表示する。

「既存」
     既存オブジェクトの名前を必要とする。不正な名前は受け付けない。現在
     の入力が正しくないとミニバッファから抜けるコマンドは動作しない。

「デフォルト」
     ミニバッファにユーザーがなにもテキストを入力しないときに使われるな
     んらかのデフォルト値。デフォルトはコード文字に依存する。

「入出力なし」
     このコード文字は、入力をまったく読まずに引数を計算する。したがって、
     プロンプト文字列を使わず、読者が指定したプロンプト文字列は無視する。

     コード文字はプロンプト文字列を使わないが、この文字が文字列の最後の
     文字でない場合には改行を続けること。

「プロンプト」
     コード文字の直後にプロンプトが続く。プロンプトは文字列の終りか改行
     で終る。

「スペシャル」
     このコード文字は、対話指定文字列の先頭でのみ意味を持ち、プロンプト
     や改行を必要としない。これは1つの孤立した文字である。

以下に、`interactive'に使うコード文字を説明します。

`*'
     カレントバッファが読み出し専用であるとエラーを通知する。「スペシャ
     ル」。

`@'
     このコマンドを起動したキー列の最初のマウスイベントが表すウィンドウ
     を選択する。「スペシャル」。

`a'
     関数名（つまり、`fboundp'を満たすシンボル）。「既存」、「補完」、
     「プロンプト」。

`b'
     既存バッファの名前。デフォルトでは、カレントバッファ（*Note
     Buffers::）の名前を使う。「既存」、「補完」、「デフォルト」、「プロ
     ンプト」。

`B'
     バッファ名。バッファが既存である必要はない。デフォルトでは、カレン
     トバッファ以外の最近使ったバッファの名前を使う。「補完」、「デフォ
     ルト」、「プロンプト」。

`c'
     文字。カーソルはエコー領域には移動しない。「プロンプト」。

`C'
     コマンド名（つまり、`commandp'を満たすシンボル）。「既存」、「補完」、
     「プロンプト」。

`d'
     整数としてのポイント位置（*Note Point::）。「入出力なし」。

`D'
     ディレクトリ名。デフォルトは、カレントバッファのカレントデフォルト
     ディレクトリ`default-directory'（*Note System Environment::）。「既
     存」、「補完」、「デフォルト」、「プロンプト」。

`e'
     コマンドを起動したキー列の最初やつぎのマウスイベント。より正確には、
     `e'はリストであるイベントを取得するので、読者はリスト内のデータを調
     べられる。*Note Input Events::。「入出力なし」。

     1つのコマンドの対話指定で複数回`e'を使える。コマンドを起動したキー
     列がN個のリストであるイベントである場合、N番目の`e'は、N番目のその
     ようなイベントを与える。`e'では、ファンクションキーやASCII文字など
     のリストでないイベントは数えない。

`f'
     既存ファイルの名前（*Note File Names::）。デフォルトディレクトリは
     `default-directory'。「既存」、「補完」、「デフォルト」、「プロンプ
     ト」。

`F'
     ファイル名。ファイルが既存である必要はない。「補完」、「デフォルト」、
     「プロンプト」。

`i'
     無関係な引数。このコードは、引数の値につねに`nil'を与える。「入出力
     なし」。

`k'
     キー列（*Note Keymap Terminology::）。現在のキーマップにおいてコマ
     ンドがみつかる（あるいは未定義コマンド）までイベントを読み続ける。
     キー列引数は、文字列かベクトルとして表現される。カーソルはエコー領
     域には移動しない。「プロンプト」。

     この種の入力は、`describe-key'や`global-set-key'などのコマンドで使
     われる。

`K'
     キー列であり、読者がその定義を変更することを意図している。これは`k'
     と同様に動作するが、キー列の最後の入力イベントに対しては、未定義キー
     を定義済みのものに変換するために（必要なときに）普通使われる変換処
     理を抑制する。

`m'
     整数としてのマーク位置。「入出力なし」。

`M'
     カレントバッファの入力方式を用いてミニバッファで読んだ任意のテキス
     ト。文字列として返す（*Note 入力方式: (emacs)Input Methods.）。「プ
     ロンプト」。

`n'
     ミニバッファで読んだ数。入力が数でないと、ユーザーに再入力を促す。
     もし前置引数があってもそれは使わない。「プロンプト」。

`N'
     数値前置引数。前置引数がなければ、`n'で数を読む。数を必要とする。
     *Note Prefix Command Arguments::。「プロンプト」。

`p'
     数値前置引数。（この`p'は小文字。）「入出力なし」。

`P'
     生の前置引数。（この`P'は大文字。）「入出力なし」。

`r'
     2つの数値引数としてのポイントとマーク。小さいほうが先にくる。これは、
     1つではなく2つの連続した引数を指定する唯一のコード文字。「入出力な
     し」。

`s'
     ミニバッファで読んだ任意のテキスト。文字列として返す（*Note Text
     from Minibuffer::）。`C-j'かRETで入力を終える。（これらの文字を入力
     に含めるには`C-q'を使う。）「プロンプト」。

`S'
     ミニバッファで読んだ名前をインターンしたシンボル。白文字で入力を終
     える。（文字列に白文字を含めるには`C-q'を使う。）（丸括弧や角括弧な
     どの）通常はシンボルを終える他の文字は、ここではシンボルを終端しな
     い。「プロンプト」。

`v'
     ユーザーオプションと宣言された変数（つまり、述語`user-variable-p'を
     満たす）。*Note High-Level Completion::。「既存」、「補完」、「プロ
     ンプト」。

`x'
     入力構文で表されたLispオブジェクト。`C-j'かRETで終える。オブジェク
     トは評価しない。*Note Object from Minibuffer::。「プロンプト」。

`X'
     `x'のようにLispフォームを読むが、評価しその値がコマンドの引数になる。
     「プロンプト」。

`z'
     コーディングシステム名（シンボル）。ユーザーの入力が空であると、引
     数の値は`nil'。*Note Coding Systems::。「補完」、「既存」、「プロン
     プト」。

`Z'
     このコマンドに前置引数を指定した場合にのみ、コーディングシステム名
     （シンボル）。前置引数がないと、`Z'は引数の値に`nil'を与える。「補
     完」、「既存」、「プロンプト」。



File: elisp-ja.info, Node: Interactive Examples, Prev: Interactive Codes, Up: Defining Commands

`interactive'の使用例
---------------------

ここでは`interactive'の例を示します。

     (defun foo1 ()              ; `foo1'は引数なし
         (interactive)           ; 2単語分先へ進める
         (forward-word 2))
          => foo1

     (defun foo2 (n)             ; `foo2'は1引数
         (interactive "p")       ; 数値前置引数
         (forward-word (* 2 n)))
          => foo2

     (defun foo3 (n)             ; `foo3'は1引数
         (interactive "nCount:") ; ミニバッファで読む
         (forward-word (* 2 n)))
          => foo3

     (defun three-b (b1 b2 b3)
       "Select three existing buffers.
     Put them into three windows, selecting the last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3))
          => three-b
     (three-b "*scratch*" "declarations.texi" "*mail*")
          => nil



File: elisp-ja.info, Node: Interactive Call, Next: Command Loop Info, Prev: Defining Commands, Up: Command Loop

対話的呼び出し
==============

コマンドループでは、キー列をコマンドへ変換し終えると、関数
`command-execute'を用いてそのコマンドを起動します。コマンドが関数であれ
ば、`command-execute'は引数を読み取り、コマンドを呼び出す
`call-interactively'を呼びます。読者自身がこれらの関数を呼び出してもかま
いません。

 -- Function: commandp OBJECT
     OBJECTが対話的呼び出しに適していれば、つまり、OBJECTがコマンドであ
     れば`t'を返す。さもなければ`nil'を返す。

     対話的呼び出しが可能なオブジェクトには、（キーボードマクロとして扱
     われる）文字列やベクトル、トップレベルで`interactive'を呼び出してい
     るラムダ式、そのようなラムダ式をコンパイルしたバイトコード関数オブ
     ジェクト、対話的（`autoload'の4番目の引数が`nil'以外）と宣言された
     自動ロードオブジェクト、一部の基本関数が含まれる。

     シンボルの関数定義が`commandp'を満たせば、シンボルも`commandp'を満
     たす。

     キーやキーマップはコマンドではない。それらはコマンドを探すために使
     われる（*Note Keymaps::）。

     `commandp'の実用的な使用例については、*Note Accessing
     Documentation::の`documentation'を参照。

 -- Function: call-interactively COMMAND &optional RECORD-FLAG KEYS
     この関数は、対話的呼び出し可能な関数COMMANDをその対話指定に従って引
     数を読み取り呼び出す。COMMANDが関数でなかったり、対話的に呼び出せな
     い（つまり、コマンドでない）場合には、エラーを通知する。キーボード
     マクロ（文字列やベクトル）はコマンドとみなすが、それらは関数でない
     ため、この関数はキーボードマクロを受け付けない。

     RECORD-FLAGが`nil'以外であると、コマンドとその引数を無条件にリスト
     `command-history'に追加する。さもなければ、引数を読むためにコマンド
     がミニバッファを使った場合にのみ追加する。*Note Command History::。

     もし引数KEYSを指定すると、コマンドがそれを起動したイベントを問い合
     わせたときに与えるイベント列を指定する。

 -- Function: command-execute COMMAND &optional RECORD-FLAG KEYS
     この関数はCOMMANDを実行する。引数COMMANDは`commandp'を満たすこと。
     つまり、対話的呼び出し可能な関数かキーボードマクロであること。

     `command'が文字列やベクトルであると、`execute-kbd-macro'で実行され
     る。関数であると、省略可能なRECORD-FLAGとともに関数を
     `call-interactively'に渡す。

     シンボルは、その関数定義を使って処理する。`autoload'で定義されたシ
     ンボルは、対話的呼び出し可能な関数と宣言されていればコマンドとみな
     す。そのような定義では、指定されたライブラリをロードしてからシンボ
     ルの定義を再検査して処理する。

     もし引数KEYSを指定すると、コマンドがそれを起動したイベントを問い合
     わせたときに与えるイベント列を指定する。

 -- コマンド: execute-extended-command PREFIX-ARGUMENT
     この関数は`completing-read'（*Note Completion::）を使ってミニバッファ
     でコマンド名を読む。そして`command-execute'を使って指定されたコマン
     ドを実行する。コマンドが返した値が`execute-extended-command'の値に
     なる。

     コマンドが前置引数を必要とする場合、PREFIX-ARGUMENTの値を受け取る。
     `execute-extended-command'が対話的に呼ばれた場合、現在の生の前置引
     数がPREFIX-ARGUMENTとして使われ、それが実行するコマンドへ渡される。

     `execute-extended-command'は通常`M-x'に定義付けられ、
     そのため、プロンプトとして文字列`M-x 'を使う。
     （`execute-extended-command'を起動するために使われた
     イベントをプロンプトにするべきであるが、
     それを実装するのは手間がかかる。）
     もし前置引数を指定すると、その内容もプロンプトの一部になる。

          (execute-extended-command 1)
          ---------- Buffer: Minibuffer ----------
          1 M-x forward-word RET
          ---------- Buffer: Minibuffer ----------
               => t

 -- Function: interactive-p
     この関数は、これ（`interactive-p'の呼び出し）を含んだ関数が
     `call-interactively'で対話的に呼び出されると`t'を返す。（Lispから
     `call-interactively'が呼び出されても、エディタコマンドループが直接
     呼び出しても違いはない。）これを含んだ関数がLispの評価（あるいは
     `apply'や`funcall'）で呼び出された場合は、対話的呼び出しではない。

`interactive-p'のもっとも一般的な用途は、情報メッセージを表示するかどう
か決めることです。特別な例外として、キーボードマクロを実行中にはいつでも、
`interactive-p'は`nil'を返します。これは情報メッセージを省いてマクロの実
行を速くするためです。

つぎのように使います。

     (defun foo ()
       (interactive)
       (when (interactive-p)
         (message "foo")))
          => foo

     (defun bar ()
       (interactive)
       (setq foobar (list (foo) (interactive-p))))
          => bar

     ;; M-x fooと打つ
          -| foo

     ;; M-x barと打つ
     ;; これはなにも表示しない

     foobar
          => (nil t)

この種のことを行う別の方法は、コマンドを対話的呼び出しでは`nil'以外の値
になる引数`print-message'を取るようにし、その引数が`nil'以外になるような
`interactive'指定を使うことです。つぎのようにします。

     (defun foo (&optional print-message)
       (interactive "p")
       (when print-message
         (message "foo")))

`p'で与えられる数値前置引数はけっして`nil'になりません。



File: elisp-ja.info, Node: Command Loop Info, Next: Input Events, Prev: Interactive Call, Up: Command Loop

コマンドループからの情報
========================

エディタコマンドループは、自身や実行中のコマンドのために状態記録を数個の
Lisp変数に設定します。

 -- Variable: last-command
     この変数は、コマンドループが（現在のコマンドの）まえに実行したコマ
     ンドの名前を記録する。通常、この値は関数定義を持つシンボルであるが、
     保証はしない。

     コマンドが後続のコマンドに対する前置引数を指定する場合を除いて、コ
     マンドからコマンドループへ戻ると`this-command'から値をコピーする。

     この変数は現在の端末に対してつねにローカルであり、バッファに対して
     ローカルにはならない。*Note Multiple Displays::。

 -- Variable: real-last-command
     `last-command'と同様にEmacsがこの変数に設定するが、Lispプログラムで
     はけっして変更しない。

 -- Variable: this-command
     この変数は、エディタコマンドループがいま実行しているコマンドの名前
     を記録する。`last-command'と同様に、通常は関数定義を持つシンボルで
     ある。

     コマンドループは、コマンドを実行する直前にこの変数に設定し、コマン
     ドが終了すると（コマンドが後続のコマンドに対する前置引数を指定する
     場合を除いて）この値を`last-command'にコピーする。

     後続のコマンドに対するフラグとして実行中にこの変数に設定するコマン
     ドもある。特に、テキストをキルする関数群は`this-command'に
     `kill-region'を設定して、直後に続くキルコマンドではキルしたテキスト
     をまえのキルに追加するようにする。

特定のコマンドがエラーを起こした場合に直前のコマンドとは認識されたくない
場合には、読者はそのコマンドがそれを防ぐように書く必要があります。1つの
方法は、以下に示すように、コマンドの始めで`this-command'に`t'を設定し、
コマンドの終りで`this-command'に正しい値を戻します。

     (defun foo (args...)
       (interactive ...)
       (let ((old-this-command this-command))
         (setq this-command t)
         ...do the work...
         (setq this-command old-this-command)))

`let'で`this-command'を束縛しません。というのは、エラーがあると`let'は古
い値を復元するからです。これこそがここでは避けたい`let'の機能です。

 -- Function: this-command-keys
     この関数は、現在のコマンドに対して直前のコマンドが生成した前置引数
     を含めて、現在のコマンドを起動したキー列を含んだ文字列かベクトルを
     返す。すべてのイベントが文字であれば、値は文字列である。*Note Input
     Events::。

          (this-command-keys)
          ;; C-u C-x C-eを使ってこの式を評価する
               => "^U^X^E"

 -- Function: this-command-keys-vector
     `this-command-keys'と同様だが、つねにベクトルでイベントを返すため、
     文字列に入力イベントを保持する際の複雑さを扱う必要がない（*Note
     Strings of Events::）。

 -- Variable: last-nonmenu-event
     この変数は、マウスメニューによるイベントを考慮せずに、キー列として
     読んだ最後の入力イベントを保持する。

     この変数の1つの用途は、メニューをポップアップする位置を
     `x-popup-menu'に指示することである。`y-or-n-p'（*Note Yes-or-No
     Queries::）も内部的に使っている。

 -- Variable: last-command-event
 -- Variable: last-command-char
     この変数には、コマンドの一部としてコマンドループが読んだ最後の入力
     イベントが設定される。この変数の主な用途は、どの文字を挿入すべきか
     を決定するために`self-insert-command'が使うことである。

          last-command-event
          ;; C-u C-x C-eを使ってこの式を評価する
               => 5

     `C-e'のASCIIコードは5なので、値は5である。

     Emacs 18版との互換性のために別名`last-command-char'がある。

 -- Variable: last-event-frame
     この変数は、最後の入力イベントを振り向けたフレームを記録する。通常
     これは、イベントが生成されたときに選択されていたフレームであるが、
     そのフレームが入力フォーカスを別のフレームに振り向けていると、この
     値はイベントを振り向けた先のフレームである。*Note Input Focus::。



File: elisp-ja.info, Node: Input Events, Next: Reading Input, Prev: Command Loop Info, Up: Command Loop

入力イベント
============

Emacsのコマンドループは、キーボードやマウスのユーザーの操作を表す"入力イ
ベント"（input event）列を読みます。キーボード操作に対するイベントは、文
字かシンボルです。マウスイベントはつねにリストです。本節では、入力イベン
トの表現方法やその意味を詳しく説明します。

 -- Function: eventp OBJECT
     この関数は、OBJECTが入力イベントであるかイベント型であると`nil'以外
     を返す。

     任意のシンボルがイベントやイベント型として使われることに注意。
     `eventp'は、Lispのプログラムコードがシンボルをイベントとして使うか
     どうか区別できない。そのかわりに、シンボルが、Emacsの現在のセッショ
     ンにおいて入力として読まれたイベントに使われたことがあるかどうかを
     区別する。シンボルがそのように使われたことがなければ、`eventp'は
     `nil'を返す。

* Menu:

* Keyboard Events::		Ordinary characters--keys with symbols on them.
* Function Keys::		Function keys--keys with names, not symbols.
* Mouse Events::                Overview of mouse events.
* Click Events::		Pushing and releasing a mouse button.
* Drag Events::			Moving the mouse before releasing the button.
* Button-Down Events::		A button was pushed and not yet released.
* Repeat Events::               Double and triple click (or drag, or down).
* Motion Events::		Just moving the mouse, not pushing a button.
* Focus Events::		Moving the mouse between frames.
* Misc Events::                 Other events window systems can generate.
* Event Examples::		Examples of the lists for mouse events.
* Classifying Events::		Finding the modifier keys in an event symbol.
				Event types.
* Accessing Events::		Functions to extract info from events.
* Strings of Events::           Special considerations for putting
				  keyboard character events in a string.



File: elisp-ja.info, Node: Keyboard Events, Next: Function Keys, Prev: Input Events, Up: Input Events

キーボードイベント
------------------

キーボードからは2種類の入力があります。普通のキーとファンクションキーで
す。普通のキーは文字に対応します。それらが生成するイベントは、Lispでは文
字として表現されます。文字イベントのイベント型は文字自身（整数）です。
*Note Classifying Events::を参照してください。

入力文字イベントは、0から524287までの"基本コード"（basic code）と以下の"
修飾ビット"（modifier bit）の任意の組み合わせです。

meta
     文字コードのビット2**27 は、メタキーを押し下げながら文字を打ったこ
     とを表す。

control
     文字コードのビット2**26 は非ASCII文字のコントロール文字を表す。

     `C-a'などのASCIIコントロール文字には独自の特別な基本コードがあるた
     め、Emacsはそれを表すための特別なビットを必要としない。つまり、
     `C-a'のコードは単に1である。

     しかし、コントロールキーを使った`%'などのASCIIにないコントロールと
     の組み合わせを打った場合、得られる数値は`%'のコードに2**26 を加えた
     ものである（端末で非ASCIIのコントロール文字を扱えるとして）。

shift
     文字コードのビット2**25 は、シフトキーを押し下げながらASCIIコントロー
     ル文字を打ったことを表す。

     英文字では、基本コードそのものが大文字か小文字かを表す。数字文字と
     区切り文字では、シフトキーは異なる基本コードのまったく異なる文字を
     選ぶ。可能な限りASCII文字集合ですませるために、これらの文字に対して
     は、Emacsはビット2**25 を使わない。

     しかし、ASCIIでは`C-A'と`C-a'を区別できないため、Emacsは、`C-A'では
     ビット2**25 を使うが、`C-a'ではこのビットを使わない。

hyper
     文字コードのビット2**24 は、ハイパーキーを押し下げながら文字を打っ
     たことを表す。

super
     文字コードのビット2**23 は、スーパーキーを押し下げながら文字を打っ
     たことを表す。

alt
     文字コードのビット2**22 は、アルトキーを押し下げながら文字を打った
     ことを表す。（ALTとラベルされたキーが実際にはメタキーである端末も存
     在する。）

読者のプログラム内では、特定の修飾ビットの値を明示することは避けるのが最
良です。文字の修飾ビットを検査するには、関数`event-modifiers'（*Note
Classifying Events::）を使います。キーバインディングを作るときには、
（`\C-'、`\M-'などの）修飾ビットを伴う文字の入力表現を使います。
`define-key'でキーバインディングを作るときには、文字の指定には`(control
hyper ?x)'のようなリストを使います（*Note Changing Key Bindings::）。関
数`event-convert-list'は、そのようなリストをイベント型に変換します
（*Note Classifying Events::）。



File: elisp-ja.info, Node: Function Keys, Next: Mouse Events, Prev: Keyboard Events, Up: Input Events

ファンクションキー
------------------

ほとんどのキーボードには、"ファンクションキー"（function key）、つまり、
文字ではない名前や記号のキーがあります。Emacs Lispでは、ファンクションキー
はシンボルで表現されます。シンボルの（小文字の）名前がファンクションキー
のラベルです。たとえば、F1というラベルのキーを押すと、入力ストリームには
シンボル`f1'が置かれます。

ファンクションキーイベントのイベント型は、イベントシンボルそれ自身です。
*Note Classifying Events::。

ファンクションキーに対するシンボル命名慣習の特例を以下に示します。

`backspace', `tab', `newline', `return', `delete'
     これらのキーは、ほとんどのキーボードにある特別なキーを持つ一般的な
     ASCIIコントロール文字に対応する。

     ASCIIでは、`C-i'とTABは同じ文字である。これらを区別できる端末では、
     前者を整数9、後者をシンボル`tab'と表現することで、EmacsはLispプログ
     ラムに区別を伝える。

     ほとんどの場面では、これら2つを区別しても有用ではない。そのため、通
     常、`function-key-map'（*Note Translating Input::）は、`tab'を9に対
     応付けるようには設定してある。したがって、文字コード9（文字`C-i'）
     に対するキーバインディングは`tab'にも適用される。この種の他のシンボ
     ルについても同様である。関数`read-char'も同様にこれらのイベントを文
     字に変換する。

     ASCIIでは、BSは実際には`C-h'である。しかし、`backspace'は文字コード
     127（DEL）に変換され、文字コード8（BS）には変換されない。ほとんどの
     ユーザーはこれを好む。

`left', `up', `right', `down'
     カーソル矢印キー
`kp-add', `kp-decimal', `kp-divide', ...
     （普通のキーボードの右側にある）キーパッドのキー。
`kp-0', `kp-1', ...
     キーパッドの数字キー。
`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     キーパッドのPFキー
`kp-home', `kp-left', `kp-up', `kp-right', `kp-down'
     キーパッドの矢印キー。Emacsは、通常、これらを対応するキーパッドのも
     のではない`home'、`left'、...のキーに変換する。
`kp-prior', `kp-next', `kp-end', `kp-begin', `kp-insert', `kp-delete'
     普通のキーに対応するキーパッドのキー。Emacsは、通常、同じ名前のキー
     パッドのものではないキーに変換する。

ファンクションキーにもALT、CTRL、HYPER、META、SHIFT、SUPERの修飾キーを使
えます。それらを表現するには、シンボル名に接頭辞を付けます。

`A-'
     アルト修飾。
`C-'
     コントロール修飾。
`H-'
     ハイパー修飾。
`M-'
     メタ修飾。
`S-'
     シフト修飾。
`s-'
     スーパー修飾。

したがって、METAを押し下げたF3キーのシンボルは`M-f3'です。複数の接頭辞を
使うときには、アルファベット順に書くことを勧めますが、キーバインディング
の探索関数や修飾関数の引数では関係ありません。



File: elisp-ja.info, Node: Mouse Events, Next: Click Events, Prev: Function Keys, Up: Input Events

マウスイベント
--------------

Emacsでは4種類のマウスイベント、つまり、クリックイベント、ドラッグイベン
ト、ボタン押し下げイベント、モーションイベントを扱えます。すべてのマウス
イベントは、リストで表現します。リストのCARはイベント型であり、どの修飾
キーとともにどのマウスボタンを使ったかを表します。イベント型では、ダブル
（連続2回）／トリプル（連続3回）の押し下げも区別できます（*Note Repeat
Events::）。リストの残りの要素は、位置情報と時間情報です。

キーの探索では、イベント型のみが意味を持ちます。型が同じであれば、異なる
イベントでも同じコマンドを実行します。コマンドでは、対話指定コード`e'を
用いてイベントの完全な値を参照できます。*Note Interactive Codes::。

マウスイベントで始まるキー列は、カレントバッファのキーマップではなく、マ
ウスが入っているウィンドウのバッファのキーマップを用いて読まれます。つま
り、あるウィンドウ内でクリックしても、当該ウィンドウやバッファを選択する
とは限らず、その動作はキー列のコマンドバインディングで完全に制御されます。



File: elisp-ja.info, Node: Click Events, Next: Drag Events, Prev: Mouse Events, Up: Input Events

クリックイベント
----------------

ユーザーがマウスのボタンを同じ場所で押し下げてから離すと、"クリック"
（click）イベントが生成されます。マウスクリックイベントはつぎの形式です。

     (EVENT-TYPE
      (WINDOW BUFFER-POS (X . Y) TIMESTAMP)
      CLICK-COUNT)

通常の各要素の意味はつぎのとおりです。

EVENT-TYPE
     どのマウスボタンが使われたかを表すシンボル。ボタンを左から右へ番号
     を付けて、シンボル`mouse-1'、`mouse-2'、...の1つである。

     ファンクションキーの場合と同様に、アルト、コントロール、ハイパー、
     メタ、シフト、スーパーの修飾キーを表す接頭辞`A-'、`C-'、`H-'、`M-'、
     `S-'、`s-'も使える。

     このシンボルはイベントのイベント型としての役割も果たす。キーバイン
     ディングはイベント型でイベントを指定する。したがって、`mouse-1'に対
     するキーバインディングは、イベント型EVENT-TYPEが`mouse-1'であるすべ
     てのイベントに適用される。

WINDOW
     クリックを行ったウィンドウ。

X, Y
     ウィンドウWINDOWの左上端を`(0 . 0)'としたクリック位置のピクセル単位
     の座標。

BUFFER-POS
     クリックした文字のバッファ内位置。

TIMESTAMP
     イベントが発生したときのミリ秒単位の時刻。（この値は、Emacs Lispの
     整数の範囲では約5時間で一周するので、時間的に近傍のイベントを関連付
     ける場合にのみ有用である。）

CLICK-COUNT
     同じマウスボタンを素早く押し下げた繰り返し回数。*Note Repeat
     Events::。

モード行やスクロールバーなどのスクリーンの特別な部分で発生したイベントで
は、BUFFER-POS、XとYの意味は少々異なります。

スクロールバーの内側でのクリックでは、BUFFER-POSはシンボル
`vertical-scroll-bar'か`horizontal-scroll-bar'であり、`(X . Y)'は
`(PORTION . WHOLE)'に置き換えられます。ここで、PORTIONはスクロールバーの
先頭や左端からのクリック位置、WHOLEはスクロールバー全体の長さです。

モード行やウィンドウWINDOWを右隣のものと区切る縦方向の区切り行の内側では、
BUFFER-POSはシンボル`mode-line'か`vertical-line'です。モード行では、Yは
意味のあるデータではありません。縦方向の区切り行では、Xは意味のあるデー
タではありません。

1つの特別な場面では、BUFFER-POSは単一のシンボルではなく（上に述べた1つの）
シンボルを含んだリストになります。イベントに対する仮想的なプレフィックス
キーを入力ストリームに挿入するとこのようになります。*Note Key Sequence
Input::。



