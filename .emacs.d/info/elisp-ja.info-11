Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Drag Events, Next: Button-Down Events, Prev: Click Events, Up: Input Events

ドラッグイベント
----------------

Emacsには、ドラッグイベントがあります。ユーザーがマウスボタンを押し下げ
てから、ボタンを離すまえに別の文字位置へマウスを動かすと"ドラッグ"（drag）
イベントが発生します。マウスのすべてのイベントのように、Lispではドラッグ
イベントはリストとして表現されます。つぎのように、リストは開始マウス位置
と終了位置を記録しています。

     (EVENT-TYPE
      (WINDOW1 BUFFER-POS1 (X1 . Y1) TIMESTAMP1)
      (WINDOW2 BUFFER-POS2 (X2 . Y2) TIMESTAMP2)
      CLICK-COUNT)

ドラッグイベントでは、シンボルEVENT-TYPEの名前には接頭辞`drag-'が付きま
す。たとえば、ボタン2を押し下げてマウスをドラッグするとイベント
`drag-mouse-2'が生成されます。イベントの2番目と3番目の要素は、ドラッグの
開始位置と終了位置を与えます。なお、データにはクリックイベントと同じ意味
があります（*Note Click Events::）。ドラッグイベントかどうかを区別せずに、
マウスの任意のイベントの2番目の要素は同じ方法で参照できます。

接頭辞`drag-'は、`C-'や`M-'のような修飾キー接頭辞に続きます。

`read-key-sequence'が、キーバインディングを持たないドラッグイベントを受
け取り、かつ、それに対応するクリックイベントにはバインディングがある場合、
ドラッグイベントの開始位置をクリック位置とするクリックイベントに変換しま
す。つまり、望まなければ、読者はクリックイベントとドラッグイベントを区別
する必要がありません。



File: elisp-ja.info, Node: Button-Down Events, Next: Repeat Events, Prev: Drag Events, Up: Input Events

ボタン押し下げイベント
----------------------

クリックイベントとドラッグイベントは、ユーザーがマウスボタンを離したとき
に発生します。ボタンを離すまではクリックとドラッグを区別する方法がないた
め、ボタンを離すまで発生しえません。

ボタンを押し下げたらただちに動作を始めたい場合には、読者は"ボタン押し下
げ"（button-down）イベントを処理する必要があります。 (1) (*Note
Button-Down Events-Footnotes::) ボタンを押し下げるとただちに発生します。
それらは、シンボルEVENT-TYPEの名前に接頭辞`down-'があることを除けば、ク
リックイベント（*Note Click Events::）とまったく同じリストで表現されます。
接頭辞`down-'は、`C-'や`M-'のような修飾キー接頭辞に続きます。

関数`read-key-sequence'は、コマンドバインディングを持たないボタン押し下
げイベントを無視します。したがって、Emacsのコマンドループもそれらを無視
します。つまり、読者がボタン押し下げイベントでなにかをしたいのでなければ、
読者はボタン押し下げイベントを定義する必要はありません。ボタン押し下げイ
ベントを定義する理由は、ボタンが離されるまで（モーションイベントを読んで）
マウスの動きを追跡するためです。*Note Motion Events::。


File: elisp-ja.info  Node: Button-Down Events-Footnotes, Up: Button-Down Events

(1) 「ボタン押し下げ」は、「ドラッグ」の対句。



File: elisp-ja.info, Node: Repeat Events, Next: Motion Events, Prev: Button-Down Events, Up: Input Events

繰り返しイベント
----------------

マウスを動かさずに同一のマウスボタンを素早く連続して押し下げると、Emacs
は2回目以降の押し下げに対して特別な"繰り返し"（repeat）マウスイベントを
生成します。

もっとも一般的な繰り返しイベントは"ダブルクリック"（double-click）イベン
トです。ボタンを2回クリックすると、Emcasはダブルクリックイベントを生成し
ます。（他のすべてのクリックイベントのように）読者がボタンを離したときに
イベントが生成されます。

ダブルクリックイベントのイベント型には、接頭辞`double-'が含まれます。し
たがって、metaを押し下げて2番目のボタンをダブルクリックすると、Lispプロ
グラムには`M-double-mouse-2'が送られます。ダブルクリックイベントにバイン
ディングがなければ、対応する普通のクリックイベントを用いて実行します。し
たがって、実際に利用したくない限りは、読者はダブルクリック機能に注意する
必要はありません。

ユーザーがダブルクリックすると、Emacsはまず普通のクリックイベントを生成
し、つぎにダブルクリックイベントを生成します。したがって、ダブルクリック
イベントのコマンドバインディングでは、すでに普通のクリックコマンドが動作
済みであると仮定して設計する必要があります。普通のクリックの結果をもとに
望みのダブルクリックの結果を得るようにします。

普通のクリックの意味にダブルクリックの意味を『追加』するようにすると便利
です。ダブルクリックのユーザーインターフェイスはこのようにすることを勧め
ます。

ボタンをクリックして、ふたたびボタンを押し下げてそのままマウスを動かすと、
最終的にボタンを離した時点で、"ダブルドラッグ"（double-drag）イベントが
生成されます。そのイベント型には`drag'のかわりに`double-drag'が含まれま
す。ダブルドラッグイベントにバインディングがなければ、Emacsは普通のドラッ
グイベントとしてバインディングを探します。

ダブルクリックイベントやダブルドラッグイベントを生成するまえに、ユーザー
がボタンを2回目に押し下げたとき、Emacsは"ダブルダウン"（double-down）イ
ベントを生成します。このイベント型には`down'のかわりに`double-down'が含
まれます。ダブルダウンイベントにバインディングがなければ、Emacsは普通の
ボタン押し下げイベントとしてバインディングを探します。どちらでもバインディ
ングがみつからなければ、ダブルダウンイベントは無視します。

まとめると、ボタンをクリックしてただちに再度ボタンを押し下げると、Emacs
は、はじめのクリックに対してボタン押し下げイベントとクリックイベントを生
成し、再度ボタンを押し下げるとダブルダウンイベントを生成し、最後にダブル
クリックイベントかダブルドラッグイベントを生成します。

ボタンを2回クリックしてから再度押し下げる操作を素早く行うと、Emacsは、"
トリプルダウン"（triple-down）イベントに続けて"トリプルクリック"
（triple-click）イベントか"トリプルドラッグ"（triple-drag）イベントを生
成します。これらのイベント型には`double'のかわりに`triple'が含まれます。
トリプルのイベントにバインディングがなければ、Emacsは対応するダブルのイ
ベントを使います。

ボタンを3回以上クリックしてから再度押し下げると、3回目以降の押し下げに対
するイベントはすべてトリプルのイベントです。Emacsは、クアドラプル（4回）、
クインタプル（5回）、…などのイベントは生成しません。しかし、イベントリ
ストを調べれば、ボタンを何回押したか正確にわかります。

 -- Function: event-click-count EVENT
     この関数は、イベントEVENTにおいてボタンが連続して押された回数を返す。
     EVENTが、ダブルダウンイベント、ダブルクリックイベント、ダブルドラッ
     グイベントであると、値は2である。EVENTがトリプルのイベントであると、
     値は3かそれ以上である。EVENTが（繰り返しイベントではない）普通のマ
     ウスイベントであると、値は1である。

 -- Variable: double-click-time
     繰り返しイベントが生成されるためには、同じスクリーン位置において連
     続してマウスボタンを押し下げ、しかも、各押し下げの間隔は
     `double-click-time'の値未満（ミリ秒）である必要がある。
     `double-click-time'に`nil'を設定すると、連続したクリックの検出を禁
     止する。`t'を設定すると時間制限をなくし、Emacsは連続したクリックの
     検出を位置だけで行う。



File: elisp-ja.info, Node: Motion Events, Next: Focus Events, Prev: Repeat Events, Up: Input Events

モーションイベント
------------------

Emacsは、ボタン操作を伴わないマウスの移動を表す"マウスモーション"（mouse
motion）イベントを生成することがあります。マウスモーションイベントはつぎ
のようなリストで表現されます。

     (mouse-movement (WINDOW BUFFER-POS (X . Y) TIMESTAMP))

リストの2番目の要素は、クリックイベント（*Note Click Events::）と同様に、
マウスの現在位置を表します。

スペシャルフォーム`track-mouse'により、その本体の内側ではモーションイベ
ントの生成を可能にできます。フォーム`track-mouse'の外側では、Emacsはマウ
スの移動のみに対するイベントを生成しないので、それらのイベントは現れませ
ん。*Note Mouse Tracking::。



File: elisp-ja.info, Node: Focus Events, Next: Misc Events, Prev: Motion Events, Up: Input Events

フォーカスイベント
------------------

ウィンドウシステムは、どのウィンドウにキーボード入力を与えるかをユーザー
が制御するための一般的な方法を提供します。ウィンドウを選ぶことを"フォー
カス"（focus）と呼びます。ユーザーがEmacsのフレームを切り替える操作を行
うと、"フォーカスイベント"（focus event）が生成されます。グローバルキー
マップにあるフォーカスイベントの普通の定義は、Emcasの新たなフレームを選
択するようになっていて、これはユーザーが期待することです。*Note Input
Focus::。

Lispでは、フォーカスイベントはつぎのようなリストで表現されます。

     (switch-frame NEW-FRAME)

ここで、NEW-FRAMEは切り替え先のフレームです。

Xのほとんどのウィンドウマネージャは、マウスをウィンドウへ入れるだけで当
該ウィンドウにフォーカスが設定されるようになっています。フレームにマウス
が入るとカーソルの形状を変更するので、Emacsでもそのようにします。しかし、
Lispプログラムにとっては、なんらかの入力が到着するまではフォーカスの変更
について知る必要がありません。そのため、ユーザーが実際にキーボードのキー
を打つか新たなフレームでマウスボタンを押し下げたときだけ、Emacsはフォー
カスイベントを生成します。フレーム間でマウスを動かしただけでは、フォーカ
スイベントは生成されません。

キー列の途中にフォーカスイベントが現れると、キー列を乱します。そのため、
Emacsはキー列の途中にはフォーカスイベントを生成しません。ユーザーがキー
列の途中で、つまり、プレフィックスキーのあとでフォーカスを変更すると、複
数イベントのキー列のまえかうしろにフォーカスイベントを移動し、途中には現
れないようにEmacsはイベントの順序を並び替えます。



File: elisp-ja.info, Node: Misc Events, Next: Event Examples, Prev: Focus Events, Up: Input Events

ウィンドウシステムのその他のイベント
------------------------------------

ウィンドウシステム内で起きたことを表す他のイベントもあります。

`(delete-frame (FRAME))'
     この種のイベントは、Emacsのフレームであるウィンドウを削除するコマン
     ドをユーザーがウィンドウマネージャに与えたことを表す。

     イベント`delete-frame'の標準定義はフレームFRAMEの削除である。

`(iconify-frame (FRAME))'
     この種のイベントは、ウィンドウマネージャを用いてユーザーがフレーム
     FRAMEをアイコン化したことを表す。これに対する標準定義は`ignore'であ
     る。というのは、フレームはすでにアイコンになっているので、Emacsが行
     うことはなにもないからである。このイベント型の目的は、必要ならばそ
     の種のイベントを読者が追跡できるようにしておくことである。

`(make-frame-visible (FRAME))'
     この種のイベントは、ウィンドウマネージャを用いてユーザーがアイコン
     化したフレームFRAMEを開いたことを表す。これに対する標準定義は
     `ignore'である。というのは、フレームはすでに見えるようになっている
     ので、Emacsが行うことはなにもないからである。

`(mouse-wheel POSITION DELTA)'
     この種のイベントは、（MSインテリマウスなどの）マウスのホイールを動
     かすと生成される。その典型的な効果はスクロールやズーミングである。

     要素DELTAはホイールの回転方向と回転量である。その絶対値はホイールを
     回すごとに増加する数である。負のDELTAは、逆転、つまり、ユーザーへ近
     付く方向への回転を表し、正のDELTAは、順転、つまり、ユーザーから遠ざ
     かる方向への回転を表す。

     要素POSITIONはイベントの発生位置を表し、マウスクリックイベントで使
     われる形式と同じである。

     この種のイベントは、ある種のシステムでのみ生成される。

`(drag-n-drop POSITION FILES)'
     この種のイベントは、Emacsの外側のアプリケーションで一群のファイルを
     選択し、それらをEmacsのフレームにドラッグ＆ドロップしたときに生成さ
     れる。

     要素POSITIONはイベントの発生位置を表し、マウスクリックイベントで使
     われる形式と同じであり、要素FILESはドラッグ＆ドロップされたファイル
     名のリストである。このイベントを扱う通常の処理は、それらのファイル
     を訪問することである。

     現状では、この種のイベントは、ある種のシステムでのみ生成される。

これらのイベントがキー列の途中、つまり、プレフィックスキーのうしろに現れ
ると、複数イベントのキー列のまえかうしろに当該イベントを移動し、途中には
現れないようにEmacsはイベントの順序を並び替えます。



File: elisp-ja.info, Node: Event Examples, Next: Classifying Events, Prev: Misc Events, Up: Input Events

イベントの例
------------

ユーザーが同じ場所でマウスの左ボタンを押し下げてから離すと、つぎのような
イベント列が生成されます。

     (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
     (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

コントロールキーを押し下げた状態で、ユーザーがマウスの2番目のボタンを押
し下げ、マウスをつぎの行へドラッグすると、つぎのような2つのイベントが生
成されます。

     (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
     (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                     (#<window 18 on NEWS> 3510 (0 . 28) -729648))

メタキーとシフトキーを押し下げた状態で、ユーザーがマウスの2番目のボタン
をウィンドウのモード行で押し下げ、マウスを別のウィンドウへドラッグすると、
つぎのような2つのイベントが生成されます。

     (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
     (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                       (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                        -453816))



File: elisp-ja.info, Node: Classifying Events, Next: Accessing Events, Prev: Event Examples, Up: Input Events

イベントの分類
--------------

各イベントには"イベント型"（event type）があって、キーバインディング処理
のためにイベントを分類します。キーボードイベントでは、イベント型はイベン
トの値に等しいです。したがって、文字に対するイベント型は文字であり、ファ
ンクションキーに対するイベント型はシンボルそのものです。リストであるイベ
ントでは、イベント型はリストのCARにあるシンボルです。したがって、イベン
ト型はつねにシンボルか文字です。

イベント型が同じであるイベントは、キーバインディングに関する限り同じです。
つまり、それらは同じコマンドを実行します。しかし、これは、それらが必ずし
も同じことを行うという意味ではありません。イベント全体を調べてなにを行う
かを決定するコマンドもあります。たとえば、マウスイベントの生起位置を使っ
て、バッファのどの部分を処理するかを決めるコマンドもあります。

イベントをおおまかに分類すると有用な場合もあります。たとえば、他の修飾キー
やマウスボタンには関係なしに、METAキーが使われているイベントかどうか調べ
たいことがあるでしょう。

関数`event-modifiers'や`event-basic-type'は、そのような情報を便利に与え
るためのものです。

 -- Function: event-modifiers EVENT
     この関数は、EVENTにある修飾子のリストを返す。修飾子はシンボルであり、
     `shift'、`control'、`meta'、`alt'、`hyper'、`super'である。さらに、
     マウスイベントシンボルの修飾子リストには、必ず、`click'、`drag'、
     `down'の1つが含まれる。

     引数EVENTは、イベントオブジェクト全体であるか、単なるイベント型であ
     る。

     例を示す。

          (event-modifiers ?a)
               => nil
          (event-modifiers ?\C-a)
               => (control)
          (event-modifiers ?\C-%)
               => (control)
          (event-modifiers ?\C-\S-a)
               => (control shift)
          (event-modifiers 'f5)
               => nil
          (event-modifiers 's-f5)
               => (super)
          (event-modifiers 'M-S-f5)
               => (meta shift)
          (event-modifiers 'mouse-1)
               => (click)
          (event-modifiers 'down-mouse-1)
               => (down)

     クリックイベントに対する修飾子リストには`click'が明示的に含まれるが、
     イベントシンボルの名前自体には`click'は含まれない。

 -- Function: event-basic-type EVENT
     この関数は、EVENTにあるキーやマウスボタンを返す。たとえばつぎのとお
     り。

          (event-basic-type ?a)
               => 97
          (event-basic-type ?A)
               => 97
          (event-basic-type ?\C-a)
               => 97
          (event-basic-type ?\C-\S-a)
               => 97
          (event-basic-type 'f5)
               => f5
          (event-basic-type 's-f5)
               => f5
          (event-basic-type 'M-S-f5)
               => f5
          (event-basic-type 'down-mouse-1)
               => mouse-1

 -- Function: mouse-movement-p OBJECT
     この関数は、OBJECTがマウス移動のイベントならば`nil'以外を返す。

 -- Function: event-convert-list LIST
     この関数は、修飾子名と基本イベント型のリストをそれらが示すイベント
     型に変換する。たとえばつぎのとおり。

          (event-convert-list '(control ?a))
               => 1
          (event-convert-list '(control meta ?a))
               => -134217727
          (event-convert-list '(control super f1))
               => C-s-f1



File: elisp-ja.info, Node: Accessing Events, Next: Strings of Events, Prev: Classifying Events, Up: Input Events

イベントの参照
--------------

本節では、マウスボタンイベントやモーションイベント内のデータを参照するた
めの便利な関数について述べます。

つぎの2つの関数は、以下の形式のリストであるマウスボタンイベントの開始位
置や終了位置を返します。

     (WINDOW BUFFER-POSITION (X . Y) TIMESTAMP)

 -- Function: event-start EVENT
     イベントEVENTの開始位置を返す。

     EVENTがクリックイベントやボタン押し下げイベントであると、イベントの
     位置を返す。EVENTがドラッグイベントであると、ドラッグの開始位置を返
     す。

 -- Function: event-end EVENT
     イベントEVENTの終了位置を返す。

     EVENTがドラッグイベントであると、ユーザーがマウスボタンを離したとき
     の位置を返す。EVENTがクリックイベントかボタン押し下げイベントである
     と、実際の値は開始位置であり、その種のイベントにある唯一の位置情報
     である。

つぎの5つの関数は、上に述べた位置情報のリストを引数として、そのさまざま
な部分を返す。

 -- Function: posn-window POSITION
     POSITION内のウィンドウを返す。

 -- Function: posn-point POSITION
     POSITIONのバッファ内位置を返す。これは整数である。

 -- Function: posn-x-y POSITION
     POSITION内のピクセル単位のxy座標をコンスセル`(X . Y)'として返す。

 -- Function: posn-col-row POSITION
     POSITIONの（文字単位の）行（row）とコラム（col）の座標をコンスセル
     `(COL . ROW)'として返す。これらは実際にはPOSITION内のXとYの値から計
     算される。

 -- Function: posn-timestamp POSITION
     POSITION内の時刻情報を返す。

つぎの関数はスクロールバーでのイベントを解読するのに便利です。

 -- Function: scroll-bar-event-ratio EVENT
     スクロールバー内でのイベントから、スクロールバーに対する縦方向の位
     置を返す。その値は2つの整数を含むコンスセル`(PORTION . WHOLE)'であ
     り、その比は位置の割合を表す。

 -- Function: scroll-bar-scale RATIO TOTAL
     この関数は（実質的には）RATIOにTOTALを掛け、結果を整数に丸める。引
     数RATIOは数ではなく`(NUM . DENOM)'であり、典型的には
     `scroll-bar-event-ratio'が返す値である。

     この関数はスクロールバー内での位置をバッファ内での位置へ換算するの
     に便利である。つぎのように行う。

          (+ (point-min)
             (scroll-bar-scale
                (posn-x-y (event-start event))
                (- (point-max) (point-min))))

     スクロールバー内でのイベントには、xy座標のかわりに比を表す2つの整数
     があることに注意。



File: elisp-ja.info, Node: Strings of Events, Prev: Accessing Events, Up: Input Events

キーボードイベントを文字列で保持する
------------------------------------

文字列が使われるほとんどの場面では、文字列にはテキスト文字、つまり、バッ
ファやファイルにある文字と同じ種類のものが入っていると考えています。文字
列にはキーボード文字が入っているとみなして使うLispプログラムもあります。
たとえば、文字列には、キー列やキーボードマクロの定義が入っているのです。
しかし、キーボード文字を文字列に保持するのは複雑であり、それは歴史的な互
換性を保つためにするのであり、また、つねに可能とは限りません。

新しいプログラムでは、キーボードイベントを文字列に保持しないで、このよう
な複雑さを避けるように推奨します。つぎのようにします。

   * キー列に対しては、それらを`lookup-key'や`define-key'に対する引数以
     外にも使うつもりならば、文字列のかわりにベクトルを使う。たとえば、
     `read-key-sequence'のかわりに`read-key-sequence-vector'を
     `this-command-keys'のかわりに`this-command-keys-vector'を使う。

   * メタ文字を含むキー列は、それらを`define-key'に直接渡す場合であって
     も、ベクトルで書く。

   * 文字列である可能性があるキー列の内容を調べるときには、
     `listify-key-sequence'（*Note Event Input Misc::）を使って、それを
     リストに変換しておく。

複雑さの原因は、キーボード入力に含まれる修飾ビットにあります。メタ修飾子
以外の修飾ビットを文字列に入れることは不可能であり、メタ修飾子は特別な場
合として唯一許されているのです。

初期のGNU Emacsでは、メタ文字を128から255の範囲のコードで表現していまし
た。その当時、基本文字コードは0から127でしたから、キーボード文字のすべて
のコードは文字列に収まったのです。多くのLispプログラムでメタ文字を表すた
めに文字列定数内で`\M-'を使い、特に、`define-key'や類似の関数に対する引
数に使われ、キー列やイベント列はつねに文字列で表現されていました。

127を超える大きな基本文字コードと追加の修飾ビットを扱えるようにしたとき、
メタ文字の表現方法を変更せざるをえませんでした。現在、メタ修飾子を表す文
字内のビットは2**27 であり、そのような数を文字列に入れることはできません。

文字列定数で`\M-'を使っているプログラムを扱えるように、文字列にメタ文字
を入れるための特別な規則があります。以下は、文字列を入力文字の列として解
釈するための規則です。

   * キーボード文字の値が0から127の範囲にあれば、無変更で文字列に入れる。

   * コードが2**27 から2**27+127, の範囲にあるこれらの文字のメタ変種は文
     字列に入れられるが、それらの数値を変更する必要がある。ビット2**27 
     のかわりに2**7 ビットに変更し、128から255の範囲の値にする。ユニバイ
     ト文字列だけにこれらのコードを入れられる。

   * 256以上の非ASCII文字はマルチバイト文字列だけに入れられる。

   * その他のキーボード文字イベントは文字列に収められない。これには、128
     から255の範囲のキーボードイベントも含む。

キーボード入力文字の文字列を作る`read-key-sequence'などの関数はつぎの規
則に従います。つまり、文字列に収まらないイベントであるときには、文字列の
かわりにベクトルを作ります。

読者が文字列で`\M-'の入力構文を使うと、それらは128から255の範囲のコード
になります。対応するキーボードイベントを文字列に保存するように変更したと
きに得られるコードと同じです。したがって、文字列内のメタイベントは、それ
らがどのように文字列に収められたかに関わらず、整合性のある動作をします。

しかし、本節のはじめに述べた推奨方法に従ってこれらのことがらを避けるほう
が、ほとんどのプログラムはよりよく動作するでしょう。



File: elisp-ja.info, Node: Reading Input, Next: Special Events, Prev: Input Events, Up: Command Loop

入力の読み取り
==============

エディタコマンドループは、関数`read-key-sequence'を使ってキー列を読み取
ります。なお、関数`read-key-sequence'は関数`read-event'を使います。これ
らやイベント入力を扱う他の関数は、Lispプログラムからも使えます。*Note
Temporary Displays::の`momentary-string-display'、および、*Note
Waiting::の`sit-for'を参照してください。端末の入力モードの制御や端末入力
のデバッグに関する関数や変数については、*Note Terminal Input::。入力イベ
ントを読むときにそれらを変換したり修正する機能については、*Note
Translating Input::。

上位レベルの入力機能については、*Note Minibuffers::を参照してください。

* Menu:

* Key Sequence Input::		How to read one key sequence.
* Reading One Event::		How to read just one event.
* Quoted Character Input::	Asking the user to specify a character.
* Event Input Misc::    	How to reread or throw away input events.



File: elisp-ja.info, Node: Key Sequence Input, Next: Reading One Event, Prev: Reading Input, Up: Reading Input

キー列の入力
------------

コマンドループは、`read-key-sequence'を呼ぶことでキー列の入力を読み取り
ます。Lispプログラムからこの関数を呼び出してもよく、たとえば、
`describe-key'は、説明対象とするキーを読むためにこの関数を使います。

 -- Function: read-key-sequence PROMPT
     この関数は、キー列を読み取り文字列かベクトルとして返す。完全なキー
     列を収集し終えるまで、つまり、現在活性なキーマップにおいて、非プレ
     フィックスコマンドを指定するのに十分になるまで、イベントを読み続け
     る。

     イベントがすべて文字であり、かつ、それらが文字列に収まるならば、
     `read-key-sequence'は文字列（*Note Strings of Events::）を返す。さ
     もなければ、ベクトルを返す。ベクトルならば、任意の種類のイベント、
     つまり、文字、シンボル、リストを保持できるからである。文字列やベク
     トルの要素は、キー列のイベントである。

     引数PROMPTは、プロンプトとしてエコー領域に表示する文字列であるか、
     あるいは、プロンプトを表示しないことを意味する`nil'である。

     以下の例では、プロンプト`?'がエコー領域に表示され、ユーザーは`C-x
     C-f'と打つ。

          (read-key-sequence "?")

          ---------- Echo Area ----------
          ?C-x C-f
          ---------- Echo Area ----------

               => "^X^F"

     関数`read-key-sequence'は中断を抑止する。この関数が動作中に`C-g'を
     打っても、他の文字と同様に扱い、`quit-flag'を設定しない。*Note
     Quitting::。

 -- Function: read-key-sequence-vector PROMPT
     これは`read-key-sequence'と同様であるが、つねにベクトルとしてキー列
     を返し、文字列としてはけっして返さない。*Note Strings of Events::。

入力文字が大文字であって、それらにキーバインディングがないとき、対応する
小文字にキーバインディングがあれば、`read-key-sequence'は文字を小文字に
変換します。`lookup-key'はこのような変換を行わないことに注意してください。

関数`read-key-sequence'は、ある種のマウスイベントも変換します。バインディ
ングのないドラッグイベントをクリックイベントに変換したり、バインディング
のないボタン押し下げイベントを完全に無視します。さらに、フォーカスイベン
トとその他のウィンドウイベントを並び替えて、それらが他のイベントのキー列
の途中に現れないようにします。

マウスイベントが、モード行やスクロールバーなどのウィンドウの特別な部分で
生起しても、特別なイベント型はなく、マウスボタンや修飾キーの組み合わせを
普通どおりに表したシンボルです。ウィンドウのどの部分かに関する情報は、イ
ベント内の別の部分、つまり、座標に入っています。しかし、
`read-key-sequence'は、その情報をシンボル`mode-line'、`vertical-line'、
`horizontal-scroll-bar'、`vertical-scroll-bar'を用いた仮想的な『プレフィッ
クスキー』に変換します。ウィンドウの特別な部分におけるマウスクリックの意
味は、これらの仮想的なプレフィックスキーを用いてキー列を定義することで定
義できます。

たとえば、`read-key-sequence'を呼び出してから、ウィンドウのモード行でク
リックすると、つぎのような2つのイベントを得ます。

     (read-key-sequence "Click on the mode line: ")
          => [mode-line
              (mouse-1
               (#<window 6 on NEWS> mode-line
                (40 . 63) 5959987))]

 -- Variable: num-input-keys
     この変数の値は、現在のEmacsセッションにおいて、これまでに処理された
     キー列の個数である。これには、端末から読み取ったキー列、および、実
     行したキーボードマクロから読み取ったキー列が含まれる。

 -- Variable: num-nonmacro-input-events
     この変数は、端末からこれまでに受け取った入力イベントの総個数を保持
     する。キーボードマクロで生成されたものは含まない。



File: elisp-ja.info, Node: Reading One Event, Next: Quoted Character Input, Prev: Key Sequence Input, Up: Reading Input

単一イベントの読み取り
----------------------

コマンド入力用の最低レベルの関数は、単一イベントを読み取る関数です。

 -- Function: read-event &optional PROMPT SUPPRESS-INPUT-METHOD
     この関数は、必要ならばイベントの到着を待って、コマンド入力のつぎの
     イベントを読み取って返す。イベントは、ユーザーか（実行中の）キーボー
     ドマクロから直接得る。

     PROMPTが`nil'以外であると、これはプロンプトとしてエコー領域に表示さ
     れる文字列であること。さもなければ、`read-event'は入力待ちであるこ
     とを示すメッセージを表示せずに、そのかわりに、現在のコマンドを実行
     するに至ったイベントや現在のコマンドが読み取ったイベントをプロンプ
     トとして表示する。*Note The Echo Area::。

     SUPPRESS-INPUT-METHODが`nil'以外であると、このイベントの読み取りに
     関しては現在の入力方式を使わない。入力方式の処理をせずにイベントを
     読みたいときには、つねにこのようにすること。`input-method-function'
     を束縛してはならない（下記参照）。

     変数`cursor-in-echo-area'が`nil'以外であると、`read-event'は、エコー
     領域に表示されたメッセージの末尾にカーソルを一時的に移動する。さも
     なければ、`read-event'はカーソルを移動しない。

     `read-event'がヘルプ文字と定義されたイベントを受け取ると、それを返
     さずに`read-event'がイベントを直接処理してしまう場合がある。*Note
     Help Functions::。"特殊イベント"（special event）と呼ばれる他のイベ
     ントも`read-event'が直接処理する（*Note Special Events::）。

     `read-event'を呼んで右矢印のファンクションキーを押すとつぎのように
     なる。

          (read-event)
               => right

 -- Function: read-char
     この関数はコマンド入力の文字を読み取りそれを返す。文字を得るまで、
     文字以外のイベントはすべて破棄する。

     最初の例では、ユーザーは文字`1'（ASCIIコード49）を打つ。2番目の例は、
     `eval-expression'を使ってミニバッファから`read-char'を呼び出すキー
     ボードマクロの定義である。`read-char'はキーボードマクロの直後の文字、
     つまり、`1'を読む。そして、`eval-expression'はその戻り値をエコー領
     域に表示する。

          (read-char)
               => 49

          ;; これを評価するために読者はM-:を使うと仮定する
          (symbol-function 'foo)
               => "^[:(read-char)^M1"
          (execute-kbd-macro 'foo)
               -| 49
               => nil

`read-event'は、あれば現在の入力方式も起動します。
`input-method-function'が`nil'以外であれば、それは関数であるはずです。
`read-event'が修飾ビットのない（SPCを含む）印字文字を読み取ると、引数と
してイベントを渡してその関数を呼び出します。

 -- Variable: input-method-function
     これが`nil'以外であると、その値は現在の入力方式関数を指定する。

     *注意：*` ' この変数を`let'で束縛しないこと。この変数はしばしばバッ
     ファローカルであり、入力を読む周囲で束縛すると（読者がこれをもっと
     も束縛*しそうな*ところ）、Emacsが入力を待っているときにバッファが非
     同期に切り替わると、誤ったバッファに値を復元してしまうことがある。

入力方式関数は、入力として使われるイベントのリストを返すべきです。（リス
トが`nil'であると入力がなかったことを意味し、`read-event'は別のイベント
を待つ。）これらのイベントは、`unread-command-events'内のイベントよりま
えに処理されます。入力方式関数が返したイベントは、それらが修飾ビットがな
い印字文字であっても、入力方式関数に再度渡されることはありません。

入力方式関数が`read-event'や`read-key-sequence'を呼び出すときには、
`input-method-function'を`nil'に束縛して再帰呼び出しを防ぐべきです。

キー列の2番目以降のイベントを読むときには、入力方式関数を呼び出しません。
したがって、それらの文字は、入力方式処理の対象ではありません。入力方式の
処理では、`overriding-local-map'と`overriding-terminal-local-map'の値を
検査するのがよいです。これらの変数のいずれかが`nil'以外であるときには、
入力方式ではその引数をリストに入れ、それ以上処理せずにそのリストを返すべ
きです。



File: elisp-ja.info, Node: Quoted Character Input, Next: Event Input Misc, Prev: Reading One Event, Up: Reading Input

クォートした文字の入力
----------------------

ユーザーに文字入力を促して、コントロール文字やメタ文字を文字そのものや文
字の8進数コードで手軽に入力できるようにするには、関数`read-quoted-char'
を使います。コマンド`quoted-insert'は、この関数を使っています。

 -- Function: read-quoted-char &optional PROMPT
     この関数は`read-char'に似ているが、最初に読んだ文字が8進数字文字
     （0-7）であると、任意個数の8進数字文字を読み取り（8進数字文字以外が
     現れると止める）、その数値の文字コードが表す文字を返す。

     最初の文字を読むと中断を抑制するので、ユーザーは`C-g'を入力できる。
     *Note Quitting::。

     PROMPTを与えると、それはユーザーへのプロンプトを表す文字列を指定す
     る。プロンプト文字列はつねにエコー領域に表示され、あとに`-'が続く。

     つぎの例では、ユーザーは8進数177（10進数では127）を打つ。

          (read-quoted-char "What character")

          ---------- Echo Area ----------
          What character-177
          ---------- Echo Area ----------

               => 127



File: elisp-ja.info, Node: Event Input Misc, Prev: Quoted Character Input, Up: Reading Input

その他のイベント入力機能
------------------------

本節では、イベントを処理せずに『まえもって覗き見』する方法、処理待ちの入
力の有無の検査方法、処理待ちの入力の破棄方法について述べます。関数
`read-passwd'も参照してください（*Note Reading a Password::）。

 -- Variable: unread-command-events
     この変数は、コマンド入力として読まれることを待っているイベントのリ
     ストを保持する。イベントはリストに現れる順に使われ、使われると1つ1
     つ取り除かれる。

     関数でイベントを読んだあとにそれを使わない場面があるため、この変数
     が必要になる。この変数にイベントを保存すると、コマンドループやコマ
     ンド入力を読む関数によって通常どおり処理される。

     たとえば、数値前置引数を実現する関数は、任意個数の数字文字を読み取
     る。数字文字でないイベントをみつけたら、そのイベントを読み戻して、
     コマンドループが通常どおりに読めるようにする必要がある。同様に、イ
     ンクリメンタルサーチでは、この機能を使って探索においては意味を持た
     ないイベントを読み戻す。なぜなら、そのようなイベントは探索を終了さ
     せ、通常どおり実行される必要があるからである。

     `unread-command-events'に入れられるようにキー列からイベントを確実に
     簡単に取り出す方法は`listify-key-sequence'を使うことである（*Note
     Strings of Events::）。

     もっとも最近に読み戻したイベントが最初に再度読まれるように、普通は
     このリストの先頭にイベントを追加する。

 -- Function: listify-key-sequence KEY
     この関数は、文字列やベクトルであるKEYを個々のイベントのリストに変換
     する。この結果は`unread-command-events'に入れられる。

 -- Variable: unread-command-char
     この変数は、コマンド入力として読まれる文字を保持する。値「-1」は、
     『空』を意味する。

     この変数はほとんど廃れており、かわりに`unread-command-events'を使う
     べきである。Emacs 18版以前向けに書かれたプログラムを扱うためだけに
     存在する。

 -- Function: input-pending-p
     この関数は、現在、コマンド入力があるかどうかを調べる。ただちに返る
     が、入力があれば値`t'を、さもなければ`nil'を返す。入力がないのに`t'
     を返すことが稀にある。

 -- Variable: last-input-event
 -- Variable: last-input-char
     この変数は、コマンドの一部として、あるいは、Lispプログラムが明示的
     に読み取った最後の端末入力イベントを記録する。

     以下の例で、Lispプログラムは文字`1'（ASCIIコード49）を読む。それが
     `last-input-event'の値になるが、（この式を評価するコマンドは`C-x
     C-e'と仮定するので）`last-command-event'の値は`C-e'のままである。

          (progn (print (read-char))
                 (print last-command-event)
                 last-input-event)
               -| 49
               -| 5
               => 49

     Emacs 18版との互換性のために、別名`last-input-char'が存在する。

 -- Function: discard-input
     この関数は端末入力バッファの内容を廃棄し、定義中のキーボードマクロ
     を取り消す。これは`nil'を返す。

     以下の例で、フォームを評価しはじめてから、ユーザーは何文字か打つ。
     `sleep-for'が待機を終えると、`discard-input'は待機中に打たれた文字
     をすべて破棄する。

          (progn (sleep-for 2)
                 (discard-input))
               => nil



File: elisp-ja.info, Node: Special Events, Next: Waiting, Prev: Reading Input, Up: Command Loop

特殊イベント
============

特殊イベントは、読まれるとただちに非常に低レベルで処理されます。関数
`read-event'はこれらのイベントをそれ自身で処理してしまい、それらを返すこ
とはありません。

このように処理されるイベントは表示されることはなく、キー列に組み込まれる
こともなく、`last-command-event'や`(this-command-keys)'の値に現れること
もありません。特殊イベントが数値引数を破棄することはなく、
`unread-command-events'で読み戻すことはできません。特殊イベントがキーボー
ドマクロに現れることはなく、読者がキーボードマクロを定義しているときに、
特殊イベントがキーボードマクロに記録されることはありません。

しかし、それらのイベントは、読まれた直後には`last-input-event'に現れます
から、これからイベントの定義で実際のイベントを見ることができます。

`iconify-frame'、`make-frame-visible'、`delete-frame'のイベント型は、通
常このように処理されます。特殊イベントをどのように処理するか、どのイベン
トが特殊イベントであるかを定義するキーマップは変数`special-event-map'に
あります（*Note Active Keymaps::）。



File: elisp-ja.info, Node: Waiting, Next: Quitting, Prev: Special Events, Up: Command Loop

時間待ちと入力待ち
==================

待機関数は、指定時間経過するか入力がくるまで待つように設計してあります。
たとえば、ユーザーに表示を眺める時間を与えるために計算途中で休止したいで
しょう。`sit-for'は、休止してスクリーンを更新し、入力がくるとただちに戻
ります。一方、`sleep-for'はスクリーンを更新せずに休止します。

 -- Function: sit-for SECONDS &optional MILLISEC NODISP
     この関数は（処理待ちのユーザーからの入力がなければ）再表示を行い、
     SECONDS秒休止するか、入力がくるまで待つ。入力がこずに（*Note Event
     Input Misc::の`input-pending-p'を参照）指定時間だけ休止した場合は、
     戻り値は`t'である。さもなければ、戻り値は`nil'である。

     引数SECONDSは整数である必要はない。それが浮動小数点数であると、
     `sit-for'は秒の小数も待つ。秒単位しか扱えないシステムもあり、そのよ
     うなシステムではSECONDSを秒に切り下げる。

     省略可能な引数MILLISECは、ミリ秒単位の追加待ち時間を指定する。これ
     はSECONDSで指定した時間に加えられる。秒未満を扱えないシステムでは、
     MILLISECに0以外を指定するとエラーになる。

     入力がくると再表示をつねに取り止め、再表示開始まえに入力がくると、
     いっさい再表示しない。したがって、処理待ちの入力があると、再表示を
     強制する方法はない。しかし、処理待ちの入力がなければ、`(sit-for 0)'
     で再表示を強制できる。

     NODISPが`nil'以外であると、`sit-for'は再表示はしないが、入力がくる
     とただちに（あるいは指定時間だけ経過すると）戻る。

     フレームをアイコンにしたりアイコンにしたフレームを開くとイベントが
     生成されるため、`sit-for'は戻る。*Note Misc Events::。

     `sit-for'の普通の目的は、読者が表示したテキストを読む時間をユーザー
     に与えることである。

 -- Function: sleep-for SECONDS &optional MILLISEC
     この関数は表示を更新せずに単にSECONDS秒だけ休止する。入力にはいっさ
     い注意を払わない。`nil'を返す。

     引数SECONDSは整数である必要はない。それが浮動小数点数であると、
     `sleep-for'は秒の小数も待つ。秒単位しか扱えないシステムもあり、その
     ようなシステムではSECONDSを秒に切り下げる。

     省略可能な引数MILLISECは、ミリ秒単位の追加待ち時間を指定する。これ
     はSECONDSで指定した時間に加えられる。秒未満を扱えないシステムでは、
     MILLISECに0以外を指定するとエラーになる。

     遅延を保証したい場合に`sleep-for'を使う。

現在時刻を取得する関数については*Note Time of Day::。



File: elisp-ja.info, Node: Quitting, Next: Prefix Command Arguments, Prev: Waiting, Up: Command Loop

中断
====

Lisp関数が動作中に`C-g'を打つと、Emacsがなにを行っていても"中断"を引き起
こします。つまり、もっとも内側の活性なコマンドループに制御が戻ります。

コマンドループがキーボード入力を待っているときに`C-g'を打っても、中断を
引き起こさずに、普通の入力文字として動作します。もっとも単純な場合、
`C-g'はコマンド`keyboard-quit'を実行しますが、その効果は中断を引き起こす
ことですから、読者には区別できないはずです。しかし、プレフィックスキーに
続けて`C-g'を打つと、それらは組み合わされて未定義キーになります。その効
果は、前置引数を含めてプレフィックスキーを取り消します。

ミニバッファでは、`C-g'には別の定義があって、ミニバッファを強制終了させ
ます。つまり、ミニバッファから抜け出て中断します。（単に中断したのでは、
ミニバッファ*内で* コマンドループに戻るだけである。）コマンドループで入
力を読んでいるときに`C-g'で直接中断しない理由は、このようにミニバッファ
でその意味を再定義できるようにするためです。ミニバッファでは、プレフィッ
クスキーに続く`C-g'は再定義してなく、プレフィックスキーと前置引数を取り
消すという通常の効果を持ちます。`C-g'がつねに直接中断するのでは、このよ
うにすることさえ不可能です。

`C-g'が直接に中断するときには、変数`quit-flag'に`t'を設定します。Emacsは
この変数を適切なときに検査し`nil'でないと中断します。したがって、
`quit-flag'に`nil'以外を設定すると中断を引き起こします。

Cのコードのレベルでは、どこでも中断できるわけではありません。`quit-flag'
を検査している特別な箇所だけです。このようにするのは、それ以外の箇所で中
断するとEmacsの内部状態に矛盾をきたす可能性があるからです。中断は安全な
場所まで延期されるので、中断によってEmcasがクラッシュすることはありませ
ん。

`read-key-sequence'や`read-quoted-char'などのある種の関数は、入力を待っ
ている場合であっても中断を完全に抑制します。中断するかわりに、`C-g'は入
力として働きます。`read-key-sequence'の場合、コマンドループにおいて`C-g'
の特別なふるまいをもたらします。`read-quoted-char'の場合、`C-q'で`C-g'を
クォートできるようになります。

変数`inhibit-quit'に`nil'以外の値を束縛することでLisp関数のある部分にお
いて中断を抑制できます。そうすると、`C-g'はそれでもいつもどおり
`quit-flag'を`t'にしますが、その通常の結果である中断は抑制されます。最終
的にフォーム`let'の終りで束縛が解除されるなどして`inhibit-quit'が再度
`nil'になります。その時点でも`quit-flag'が`nil'以外であると要求した中断
がただちに起こります。このふるまいは、プログラムの『臨界領域』では中断が
起こらないことを保証する理想的なものです。

（`read-quoted-char'などの）ある種の関数では、`C-g'は特別に処理され中断
を引き起こしません。`inhibit-quit'に`t'を束縛して入力を読み取り、
`inhibit-quit'が再度`nil'になるまえに`quit-flag'を`nil'にすることでその
ようにします。これを`read-quoted-char'の定義の以下の抜粋で示しましょう。
最初の入力文字のあとで通常の中断を許す方法も示しています。

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((message-log-max nil) done (first t) (code 0) char)
         (while (not done)
           (let ((inhibit-quit first)
                 ...)
     	(and prompt (message "%s-" prompt))
     	(setq char (read-event))
     	(if inhibit-quit (setq quit-flag nil)))
           ...変数`code'に設定する...)
         code))

 -- Variable: quit-flag
     `inhibit-quit'が`nil'であれば、この変数が`nil'以外であるとEmacsはた
     だちに中断する。`C-g'は、`inhibit-quit'に関わらず、通常、
     `quit-flag'に`nil'以外を設定する。

 -- Variable: inhibit-quit
     この変数は、`quit-flag'が`nil'以外の値に設定されたときにEmacsが中断
     すべきかどうかを決定する。`inhibit-quit'が`nil'以外であると、
     `quit-flag'に特別な意味はない。

 -- コマンド: keyboard-quit
     この関数は`(signal 'quit nil)'で`quit'条件を通知する。これは中断と
     同じことを行う。（*Note Errors::の`signal'を参照。）

中断として使う`C-g'以外の特殊文字を使えます。*Note Terminal Input::の関
数`set-input-mode'を参照してください。
 


File: elisp-ja.info, Node: Prefix Command Arguments, Next: Recursive Editing, Prev: Quitting, Up: Command Loop

前置コマンド引数
================

Emacsのほとんどのコマンドは、"前置引数"（prefix argument）、つまりコマン
ド自身のまえに指定された数を利用できます。（前置引数とプレフィックスキー
を混同しないこと。）前置引数はつねに値で表現され、`nil'であると現在は前
置引数がないことを表します。各コマンドは、前置引数を使ってもよいし、無視
してもかまいません。

前置引数には2つの表現方法があります。"生"（raw）と"数値"（numeric）です。
エディタコマンドループでは、内部的には生の表現を使い、その情報を保持する
Lisp変数もそのようにしますが、コマンドではどちらの表現を要求してもかまい
ません。

生の前置引数の値にはつぎの可能性があります。

   * 前置引数がないことを意味する`nil'。その数値としての値は1であるが、
     多くのコマンドでは`nil'と整数1を区別する。

   * それ自身が表す整数。

   * 整数を要素とする1要素のリスト。この形式の前置引数は、数字文字なしの
     1個以上の`C-u'の結果である。リスト内の数値は整数であるが、そのよう
     なリストと整数のみを区別するコマンドもある。

   * シンボル`-'。数字文字なしに`M--'や`C-u -'を打ったことを表す。これに
     等価な数値は-1であるが、整数-1とシンボル`-'を区別するコマンドもある。

いろいろな前置引数でつぎの関数を呼び出す例を示します。

     (defun display-prefix (arg)
       "Display the value of the raw prefix arg."
       (interactive "P")
       (message "%s" arg))

以下は、生の前置引数で`display-prefix'を呼び出した結果です。

             M-x display-prefix  -| nil

     C-u     M-x display-prefix  -| (4)

     C-u C-u M-x display-prefix  -| (16)

     C-u 3   M-x display-prefix  -| 3

     M-3     M-x display-prefix  -| 3      ; （`C-u 3'と同じ）

     C-u -   M-x display-prefix  -| -      

     M--     M-x display-prefix  -| -      ; （`C-u -'と同じ）

     C-u - 7 M-x display-prefix  -| -7     

     M-- 7   M-x display-prefix  -| -7     ; （`C-u -7'と同じ）

Emacsは、前置引数を保持するために2つの変数、`prefix-arg'と
`current-prefix-arg'を使います。他のコマンド向けに前置引数を設定する
`universal-argument'などのコマンドは、前置引数を`prefix-arg'に保持します。
対照的に、`current-prefix-arg'には現在のコマンドに対して前置引数を運ぶ役
割があり、この変数に設定しても以後のコマンドに対する前置引数にはなんの効
果もありません。

通常、コマンドは、`interactive'宣言により、「生」か「数値」のいずれの表
現の前置引数を使うか指定します。（*Note Using Interactive::。）あるいは、
変数`current-prefix-arg'にある前置引数の値を関数から直接見てもかまいませ
んが、これは見通しのよい方法ではありません。

 -- Function: prefix-numeric-value ARG
     この関数は、有効な生の前置引数の値ARGからそれに等価な数値を返す。引
     数は、シンボル、数、リストのいずれかである。それが`nil'であると、戻
     り値は1である。`-'であると、戻り値は-1である。数であると、その数を
     返す。リストであると、リストの（数であるはずの）CARを返す。

 -- Variable: current-prefix-arg
     この変数は、*現在の*コマンドに対する生の前置引数を保持する。コマン
     ドが直接この変数を調べてもよいが、前置引数を参照する普通の方法は
     `(interactive "P")'を使うことである。

 -- Variable: prefix-arg
     この変数の値は、*つぎの*編集コマンド向けの生の前置引数である。後続
     のコマンド向けの前置引数を指定する`universal-argument'などのコマン
     ドは、この変数に設定することで動作する。

 -- Variable: last-prefix-arg
     まえのコマンドで使われた生の前置引数の値。

つぎのコマンドは、後続のコマンド向けの前置引数を設定するためのものです。
それ以外の目的には呼ばないでください。

 -- コマンド: universal-argument
     このコマンドは入力を読み取り、後続のコマンド向けの前置引数を指定す
     る。なにをしているか理解していない限り、読者自身でこのコマンドを呼
     ばないこと。

 -- コマンド: digit-argument ARG
     このコマンドは、後続のコマンド向けの前置引数に追加する。引数ARGは、
     このコマンドが呼び出されるまえの生の前置引数であり、前置引数を更新
     する計算に使われる。なにをしているか理解していない限り、読者自身で
     このコマンドを呼ばないこと。

 -- コマンド: negative-argument ARG
     このコマンドは、後続のコマンド向けの数値前置引数に追加する。引数ARG
     は、このコマンドが呼び出されるまえの生の前置引数であり、その値の符
     号を変えて新たな前置引数とする。なにをしているか理解していない限り、
     読者自身でこのコマンドを呼ばないこと。



File: elisp-ja.info, Node: Recursive Editing, Next: Disabling Commands, Prev: Prefix Command Arguments, Up: Command Loop

再帰編集
========

Emacsが動作を始めると、Emacsのコマンドループに自動的に入ります。このトッ
プレベルのコマンドループからはけっして抜けることはなく、Emacsが動いてい
る限り動作し続けます。Lispプログラムからコマンドループを起動することもで
きます。そうすると、活性なコマンドループが複数作られることになるので、そ
れを"再帰編集"（recursive editing）と呼びます。再帰編集レベルには、それ
を起動したコマンドを一時休止させ、当該コマンドを再開するまでユーザーにど
んな編集でも許す効果があります。

再帰編集中に利用可能なコマンドは、トップレベルのコマンドループと同じもの
でありキーマップで定義されます。再帰編集を抜けるための数個の特別なコマン
ドがあり、完了すると再帰編集レベルから抜ける別のコマンドもあります。（再
帰編集を抜けるコマンドはつねに利用可能であるが、再帰編集中でないとなにも
行わない。）

再帰編集を含むすべてのコマンドループでは、コマンドループから実行したコマ
ンドのエラーによってコマンドループから抜け出さないように汎用目的のエラー
ハンドラを設定します。

ミニバッファでの入力は、特別な種類の再帰編集です。これには、ミニバッファ
やミニバッファ用ウィンドウを表示するなどの特別な処理がありますが、読者が
考えるよりは少ないのです。ミニバッファでは特別なふるまいをするキーもあり
ますが、それらはミニバッファのローカルマップによるものです。ウィンドウを
切り替えると、Emacsの普通のコマンドを使えます。

再帰編集レベルを起動するには、関数`recursive-edit'を呼び出します。この関
数にはコマンドループが含まれています。さらに、`exit'を伴った`catch'の呼
び出しもあり、これにより、`exit'へ投げることで再帰編集レベルから抜け出せ
るようになっています（*Note Catch and Throw::）。`t'以外の値を投げると、
`recursive-edit'は、呼び出し側の関数へ普通に戻ります。コマンド`C-M-c'
（`exit-recursive-edit'）は、これを行います。値`t'を投げると
`recursive-edit'に中断を引き起こし、1つ上のレベルのコマンドループへ制御
を戻します。これを"強制終了"（aborting）と呼び、`C-]'
（`abort-recursive-edit'）で行えます。

ミニバッファを使う場合を除いて、ほとんどのアプリケーションでは再帰編集を
使うべきではありません。カレントバッファのメジャーモードを一時的な特別な
メジャーモードに変更するほうが、一般にはユーザーにとってより便利です。た
だし、当該メジャーモードには、まえのモードに戻るコマンドを用意しておきま
す。（rmailのコマンド`e'は、この方式を使っている。）あるいは、『再帰的に』
編集する別のテキストをユーザーに与えたい場合には、特別なモードの新たなバッ
ファを作成してそれを選択します。当該モードには、処理を終えてまえのバッファ
に戻るコマンドを定義しておきます。（rmailのコマンド`m'は、このようにす
る。）

再帰編集はデバッグに便利です。ブレークポイントの一種として関数定義に
`debug'の呼び出しを挿入しておくと、その箇所に達したときにいろいろと調べ
られます。`debug'は再帰編集を起動しますが、デバッガとしての機能も提供し
ます。

`query-replace'で`C-r'を打ったり、`C-x q'（`kbd-macro-query'）を使ったと
きにも再帰編集レベルが使われます。

 -- Function: recursive-edit
     この関数はエディタコマンドループを起動する。Emacsの初期化過程で自動
     的に呼び出され、ユーザーが編集できるようにする。Lispプログラムから
     呼ばれると、再帰編集レベルに入る。

     以下の例では、関数`simple-rec'は、まず1単語分ポイントを進め、エコー
     領域にメッセージを表示して再帰編集に入る。そうすると、ユーザーは望
     むことはなんでもできるようになり、（再帰編集を）抜けるために`C-M-c'
     を打つと、`simple-rec'の実行を継続する。

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress")
            (recursive-edit)
            (forward-word 1))
               => simple-rec
          (simple-rec)
               => nil

 -- コマンド: exit-recursive-edit
     この関数は、（ミニバッファでの入力を含む）もっとも内側の再帰編集か
     ら抜ける。その関数定義は実質的には`(throw 'exit nil)'である。

 -- コマンド: abort-recursive-edit
     この関数は、再帰編集から抜けたあとで`quit'を通知することで、（ミニ
     バッファでの入力を含む）もっとも内側の再帰編集を要請したコマンドを
     強制終了する。その関数定義は実質的には`(throw 'exit t)'である。
     *Note Quitting::。

 -- コマンド: top-level
     この関数は、すべての再帰編集を抜ける。すべての計算を抜け出てメイン
     のコマンドループへ直接戻るため、値は返さない。

 -- Function: recursion-depth
     この関数は再帰編集の現在の深さを返す。活性な再帰編集がなければ0を返
     す。



File: elisp-ja.info, Node: Disabling Commands, Next: Command History, Prev: Recursive Editing, Up: Command Loop

コマンドを禁止する
==================

"コマンドを禁止する"とは、コマンドを実行するまえにユーザーの確認を必要と
するようにコマンドに印を付けることです。コマンドを禁止するのは、初心者に
混乱をもたらす可能性のあるコマンドに対してや、コマンドの誤用を防ぐためで
す。

コマンドを禁止する低レベルの機構は、コマンドのLispシンボルに`nil'以外の
属性`disabled'を入れることです。これらの属性は、通常、ユーザーの`.emacs'
ファイルにてつぎのようなLisp式で設定します。

     (put 'upcase-region 'disabled t)

数個のコマンドにはデフォルトでこれらの属性がありますから、`.emacs'ファイ
ルで属性を取り除きます。

属性`disabled'の値は文字列であり、コマンドを禁止したことを表すメッセージ
です。たとえばつぎのとおりです。

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

禁止したコマンドを対話的に起動するとどうなるかについて詳しくは*Note 使用
禁止コマンド: (emacs)Disabling。コマンドを禁止しても、Lispプログラムから
関数として呼び出すことにはなんの影響もありません。

 -- コマンド: enable-command COMMAND
     これ以降、特別な確認なしにCOMMANDを実行可能にする。さらに（ユーザー
     が了承すれば）ユーザーの`.emacs'ファイルを変更して、将来のセッショ
     ンでもそのようにする。

 -- コマンド: disable-command COMMAND
     これ以降、COMMANDの実行には特別な確認を必要とするようにする。さらに
     （ユーザーが了承すれば）ユーザーの`.emacs'ファイルを変更して、将来
     のセッションでもそのようにする。

 -- Variable: disabled-command-hook
     禁止したコマンドをユーザーが対話的に起動したとき、禁止したコマンド
     のかわりにこのノーマルフックを実行する。フック関数では、
     `this-command-keys'を使ってコマンドを実行するためにユーザーがなにを
     入力したかを調べ、コマンドそのものを探し出せる。*Note Hooks::。

     デフォルトでは、`disabled-command-hook'には、ユーザーに処理を進める
     かどうかを問い合わせる関数が入っている。



File: elisp-ja.info, Node: Command History, Next: Keyboard Macros, Prev: Disabling Commands, Up: Command Loop

コマンド履歴
============

コマンドループでは、実行した複雑なコマンドの履歴を管理していて、それらの
コマンドを簡単に繰り返せるようにしています。"複雑なコマンド"とは、ミニバッ
ファを使って引数を読むコマンドです。これには、任意の`M-x'コマンド、任意
の`M-:'コマンド、ミニバッファから引数を読み取る`interactive'指定を持つ任
意のコマンドが含まれます。コマンド自身の実行中に明示的にミニバッファを使っ
ても、複雑なコマンドとはみなしません。

 -- Variable: command-history
     この変数の値は、最近使った複雑なコマンドのリストであり、各要素は評
     価すべきフォームを表す。編集セッション中は、すべての複雑なコマンド
     を集積するが、（変数`history-length'で指定される）最大サイズに達す
     ると新しい要素を追加するたびに古い要素を削除する。

          command-history
          => ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

この履歴リストは、実際にはミニバッファ履歴（*Note Minibuffer History::）
の特別な場合です。要素は文字列ではなく式なのです。

まえのコマンドを編集したり取り出すための専用コマンドがたくさんあります。
コマンド`repeat-complex-command'と`list-command-history'は、ユーザーマニュ
アル（*Note ミニバッファコマンドの繰り返し: (emacs)Repetition.）に説明し
てあります。ミニバッファ内では、通常のミニバッファ履歴コマンドを使えます。



File: elisp-ja.info, Node: Keyboard Macros, Prev: Command History, Up: Command Loop

キーボードマクロ
================

"キーボードマクロ"は、コマンドとみなせる入力イベントのまとまった列であり、
キーの定義から構成されます。Lispにおけるキーボードマクロの表現は、イベン
トを含んだ文字列やベクトルです。キーボードマクロとLispマクロ（*Note
Macros::）を混同しないでください。

 -- Function: execute-kbd-macro KBDMACRO &optional COUNT
     この関数はキーボードマクロKBDMACROをイベント列として実行する。
     KBDMACROが文字列かベクトルであると、その中のイベントをユーザーが入
     力した場合とまったく同様に実行する。列は単一のキーイベントである必
     要は*ない*。通常、キーボードマクロの定義は、複数のキー列を連結した
     ものである。

     KBDMACROがシンボルであると、KBDMACROのかわりにその関数定義を用いる。
     それがさらに別のシンボルであると、この処理を繰り返す。最終的な結果
     は、文字列かベクトルであること。結果がシンボルでも文字列でもベクト
     ルでもないと、エラーを通知する。

     引数COUNTは繰り返し回数であり、KBDMACROをその回数だけ実行する。
     COUNTを省略するか`nil'であると、KBDMACROを1回実行する。COUNTが0であ
     ると、KBDMACROの実行をエラーに出会うか探索に失敗するまで繰り返す。

     `execute-kbd-macro'を使った例については*Note Reading One Event::。

 -- Variable: executing-macro
     この変数は、現在実行中のキーボードマクロの定義である文字列やベクト
     ルを保持する。これが`nil'であると、現在実行中のマクロはない。コマン
     ドでこの変数を検査することで、マクロ実行で起動されたときのふるまい
     を変更できる。読者自身はこの変数に設定しないこと。

 -- Variable: defining-kbd-macro
     この変数は、キーボードマクロを定義中かどうかを表す。コマンドでこの
     変数を検査することで、マクロ定義中のふるまいを変更できる。コマンド
     `start-kbd-macro'と`end-kbd-macro'がこの変数に設定する。読者自身は
     設定しないこと。

     この変数は現在の端末に対してつねにローカルであり、バッファに対して
     ローカルにはならない。*Note Multiple Displays::。

 -- Variable: last-kbd-macro
     この変数は、もっとも最近に定義されたキーボードマクロの定義である。
     その値は、文字列かベクトル、あるいは、`nil'である。

     この変数は現在の端末に対してつねにローカルであり、バッファに対して
     ローカルにはならない。*Note Multiple Displays::。




File: elisp-ja.info, Node: Keymaps, Next: Modes, Prev: Command Loop, Up: Top

キーマップ
**********

入力イベントとコマンドとのバインディング（対応）は、"キーマップ"（keymap）
と呼ばれるデータ構造に記録されています。キーマップの各バインディング（あ
るいは"バインド"（bind））は、個々のイベント型を別のキーマップかコマンド
に対応付けます。イベント型のバインディングがキーマップであると、後続の入
力イベントを探すためにそのキーマップを使います。コマンドがみつかるまで、
これを繰り返します。この処理全体を"キー探索"（key lookup）と呼びます。

* Menu:

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				   of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Active Keymaps::	        Each buffer has a local keymap
                                   to override the standard (global) bindings.
				   A minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.
* Menu Keymaps::		Defining a menu as a keymap.



File: elisp-ja.info, Node: Keymap Terminology, Next: Format of Keymaps, Prev: Keymaps, Up: Keymaps

キーマップの用語
================

"キーマップ"（keymap）は、イベント型を定義に対応させる表です。（この定義
は任意のLispオブジェクトであるが、コマンドループによる実行においては、特
定の型のみが意味を持つ）。与えられたイベント（あるいはイベント型）とキー
マップから、Emacsはイベントの定義を得ることができます。イベントは、文字、
ファンクションキー、マウス操作です（*Note Input Events::）。

ある単位を構成する入力イベントの列を"キー列"（key sequence）、あるいは、
略して"キー"（key）と呼びます。単一イベントから成る列はつねにキー列であ
り、複数イベント列もキー列です。

キーマップは、任意のキー列に対するバインディング、つまり、定義を決定しま
す。キー列が単一イベントから成るとき、そのバインディングはキーマップ内の
当該イベントの定義です。複数のイベントから成るキー列のバインディングは、
繰り返し処理で探します。つまり、最初のイベントのバインディングを探すと、
それはキーマップであるはずです。続いて、そのキーマップから2番目のイベン
トのバインディングを探します。これをキー列のすべてのイベントを使い尽くす
まで行います

キー列のバインディングがキーマップであると、そのキー列を"プレフィックス
キー"（prefix key）と呼びます。さもなければ、（追加できるイベントがない
ので）"完全なキー"（complete key）と呼びます。バインディングが`nil'であ
ると、キーは"未定義"であるといいます。プレフィックスキーの例は、`C-c'、
`C-x'、`C-x 4'です。定義されている完全なキーの例は、`X'、RET、`C-x 4
C-f'です。未定義な完全なキーの例は、`C-x C-g'と`C-c 3'です。詳しくは、
*Note Prefix Keys::。

キー列のバインディングを探す際の規則では、（最後のイベントのまえまでにみ
つかる）途中のバインディングはすべてキーマップであると仮定します。これが
満たされないと、イベントの列があるまとまりを構成せず、1つのキー列になり
ません。いいかえれば、有効なキー列の末尾からいくつかのイベントを取りさる
と、つねにプレフィックスキーになる必要があります。たとえば、`C-f C-n'は
キー列ではありません。`C-f'はプレフィックスキーではないので、`C-f'で始ま
る列はキー列ではありません。

複数イベントから成るキー列の候補は、プレフィックスキーのバインディングに
依存します。したがって、キーマップが異なればそれらは異なり、バインディン
グを変更するとそれらは変わります。しかし、単一イベントから成る列は、プレ
フィックスに依存しないので、つねにキー列です。

ある時点には、複数個の主キーマップが活性です。つまり、キーバインディング
の探索に使われます。それらは、すべてのバッファが共有する"グローバルマッ
プ"（global map）、特定のメジャーモードに関連付けられた"ローカルマップ"
（local keymap）、現在オンにしてあるマイナモードに属する"マイナモードキー
マップ"（minor mode keymaps）です。（すべてのマイナモードにキーマップが
あるわけではない。）ローカルキーマップのバインディングは、対応するグロー
バルなバインディングを隠します（つまり優先する）。マイナモードキーマップ
は、ローカルとグローバルの両方のキーマップを隠します。詳しくは*Note
Active Keymaps::。



File: elisp-ja.info, Node: Format of Keymaps, Next: Creating Keymaps, Prev: Keymap Terminology, Up: Keymaps

キーマップの形式
================

キーマップは、そのCARがシンボル`keymap'であるリストです。リストの残りの
要素がキーマップのキーバインディングを定義します。オブジェクトがキーマッ
プであるかどうか検査するには、関数`keymapp'（下記参照）を使います。

キーマップでは、シンボル`keymap'のうしろに、さまざまな種類の要素が現れま
す。

`(TYPE . BINDING)'
     イベント型TYPEに対する1つのバインディングを指定する。普通の各バイン
     ディングは、文字やシンボルである特定の"イベント型"に適用される。
     *Note Classifying Events::。

`(t . BINDING)'
     "デフォルトのキーバインディング"を指定する。キーマップの他の要素に
     一致しない任意のイベントには、そのバインディングとして指定した
     BINDINGを与える。デフォルトのバインディングにより、すべてを列挙せず
     に可能なすべてのイベントにバインドできる。デフォルトのバインディン
     グを有するキーマップは、任意の低優先順位のキーマップを隠してしまう。

`VECTOR'
     キーマップの要素がベクトルであると、当該ベクトルをASCII文字全体、つ
     まり、コード0から127に対するバインディングとみなす。ベクトルのN番目
     の要素は、コードNの文字に対するバインディングである。これは、多くの
     バインディングを記録するコンパクトな方法である。このようなベクトル
     のキーマップを"完全なキーマップ"（full keymap）と呼ぶ。それ以外のキー
     マップを"疎なキーマップ"（sparse keymaps）と呼ぶ。

     キーマップにベクトルがあると、ベクトルの要素が`nil'であってもベクト
     ルが各ASCII文字のバインディングをつねに定義する。そのような`nil'の
     バインディングは、ASCII文字に対してはキーマップのデフォルトのキーバ
     インディングを無効にする。しかし、ASCII文字以外のイベントに対しては、
     デフォルトのバインディングが意味を持つ。`nil'のバインディングが低優
     先順位のキーマップを隠すことは*ない*。つまり、ローカルマップが`nil'
     のバインディングを与えると、Emacsはグローバルマップのバインディング
     を使う。

`STRING'
     バインディングに加えて、キーマップでは、要素として文字列を持つこと
     もできる。これを"全面プロンプト文字列"（overall prompt string）と呼
     び、キーマップをメニューとして使うことを可能にする。*Note Menu
     Keymaps::。

キーマップは、メタ文字に対するバインディングを直接には記録していません。
そのかわりに、キー探索においては、メタ文字は2文字から成る列とみなし、先
頭文字はESC（あるいは、`meta-prefix-char'の現在値）です。つまり、キー
`M-a'は実際には`ESC a'と表現され、そのグローバルなバインディングは
`esc-map'の`a'でみつかります（*Note Prefix Keys::）。

Lispモードに対するローカルキーマップの例を示します。これは疎なキーマップ
です。DEL、TAB、`C-c C-l'、`M-C-q'、`M-C-x'に対するバインディングを定義
しています。

     lisp-mode-map
     => 
     (keymap 
      ;; TAB
      (9 . lisp-indent-line)                 
      ;; DEL
      (127 . backward-delete-char-untabify)  
      (3 keymap 
         ;; C-c C-l
         (12 . run-lisp))                    
      (27 keymap 
          ;; M-C-qはESC C-qとみなされる
          (17 . indent-sexp)                 
          ;; M-C-xはESC C-xとみなされる
          (24 . lisp-send-defun)))           

 -- Function: keymapp OBJECT
     この関数は、OBJECTがキーマップであれば`t'を返し、さもなければ`nil'
     を返す。より正確には、この関数は、そのCARが`keymap'であるリストかど
     うかを検査する。

          (keymapp '(keymap))
              => t
          (keymapp (current-global-map))
              => t



File: elisp-ja.info, Node: Creating Keymaps, Next: Inheritance and Keymaps, Prev: Format of Keymaps, Up: Keymaps

キーマップの作成
================

ここでは、キーマップを作成するための関数について述べます。

 -- Function: make-keymap &optional PROMPT
     この関数は新たに完全なキーマップ（つまり、すべてのASCII文字に対する
     定義を収めた長さ128のベクトル）を作成しそれを返す。新たなキーマップ
     では、すべてのASCII文字に対するバインディングは`nil'であり、それ以
     外の種類のイベントに対するバインディングはない。

          (make-keymap)
              => (keymap [nil nil nil ... nil nil])

     PROMPTを指定すると、それはキーマップに対する全面プロンプト文字列に
     なる。全面プロンプト文字列はメニューキーマップ（*Note Menu
     Keymaps::）に有用である。

 -- Function: make-sparse-keymap &optional PROMPT
     この関数は、新たに空の疎なキーマップを作成しそれを返す。新たなキー
     マップにはイベントに対するバインディングはいっさいない。引数PROMPT
     は、`make-keymap'の場合同様、プロンプト文字列を指定する。

          (make-sparse-keymap)
              => (keymap)

 -- Function: copy-keymap KEYMAP
     この関数はKEYMAPのコピーを返す。KEYMAPにバインディングとして直接現
     れる任意のキーマップも任意のレベルまで再帰的にコピーされる。しかし、
     文字に対する定義が、その関数定義がキーマップであるようなシンボルに
     出会うと再帰的なコピーを行わないため、同じシンボルが新たなコピーに
     も現れる。

          (setq map (copy-keymap (current-local-map)))
          => (keymap
               ;; (これはメタ文字を意味する)
               (27 keymap         
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))

          (eq map (current-local-map))
              => nil
          (equal map (current-local-map))
              => t



File: elisp-ja.info, Node: Inheritance and Keymaps, Next: Prefix Keys, Prev: Creating Keymaps, Up: Keymaps

継承とキーマップ
================

キーマップでは、"親キーマップ"（parent keymap）と呼ぶ別のキーマップのバ
インディングを継承できます。そのようなキーマップはつぎのようになります。

     (keymap BINDINGS... . PARENT-KEYMAP)

このキーマップは、キーを探索する時点においてPARENT-KEYMAPが有するすべて
のバインディングを継承しますが、それらにはBINDINGSが追加されたり優先しま
す。

`define-key'や他のキーバインディング関数でPARENT-KEYMAPのバインディング
を変更すると、それらの変更は、BINDINGSで隠されない限り継承側のキーマップ
からも見えます。その逆は真ではありません。`define-key'で継承側のキーマッ
プを修正すると、それはBINDINGSに影響するだけでPARENT-KEYMAPには影響しま
せん。

親キーマップを用いたキーマップを作成する正しい方法は、
`set-keymap-parent'を使うことです。親キーマップを用いたキーマップを直接
作成するようなコードがある場合には、`set-keymap-parent'を用いるようにプ
ログラムを変更してください。

 -- Function: keymap-parent KEYMAP
     この関数は、キーマップKEYMAPの親キーマップを返す。KEYMAPに親がなけ
     れば`keymap-parent'は`nil'を返す。

 -- Function: set-keymap-parent KEYMAP PARENT
     キーマップKEYMAPの親キーマップとしてPARENTを設定し、PARENTを返す。
     PARENTが`nil'であると、この関数はKEYMAPに親キーマップをいっさい与え
     ない。

     KEYMAPに（プレフィックスキー用のバインディングである）サブマップが
     あれば、それらもPARENTが指定するプレフィックスキーを反映する新たな
     親マップを受け取る。

`text-mode-map'からキーマップを継承する方法を示します。

     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map text-mode-map)
       map)



File: elisp-ja.info, Node: Prefix Keys, Next: Active Keymaps, Prev: Inheritance and Keymaps, Up: Keymaps

プレフィックスキー
==================

"プレフィックス"（prefix key）とは、そのバインディングがキーマップである
キー列のことです。そのキーマップが、プレフィックスキー以降のキーでなにを
するかを定義します。たとえば、`C-x'はプレフィックスキーであり、変数
`ctl-x-map'に保持されたキーマップを使います。このキーマップは、`C-x'で始
まるキー列に対するバインディングを定義します。

Emacsの標準プレフィックスキーのなかには、Lisp変数にも保持されたキーマッ
プを使うものがあります。

   * `esc-map'は、プレフィックスキーESC用のグローバルマップである。した
     がって、すべてのメタ文字のグローバルな定義はここにある。このキーマッ
     プは`ESC-prefix'の関数定義でもある。

   * `help-map'は、プレフィックスキー`C-h'に対するグローバルキーマップで
     ある。

   * `mode-specific-map'は、プレフィックスキー`C-c'に対するグローバルキー
     マップである。このキーマップは実際にはグローバルでありモード固有で
     はないが、その名前は、`C-h b'（`display-bindings'）の出力において
     `C-c'に関する有用な情報を与える。というのは、このプレフィックスキー
     の主な用途は、モード固有のバインディングのためだからである。

   * `ctl-x-map'は、プレフィックスキー`C-x'に対して使われるグローバルキー
     マップである。このキーマップは、シンボル`Control-X-prefix'の関数セ
     ルに現れる。

   * `mule-keymap'は、プレフィックスキー`C-x RET'に対して使われるグロー
     バルキーマップである。

   * `ctl-x-4-map'は、プレフィックスキー`C-x 4'に対して使われるグローバ
     ルキーマップである。

   * `ctl-x-5-map'は、プレフィックスキー`C-x 5'に対して使われるグローバ
     ルキーマップである。

   * `2C-mode-map'は、プレフィックスキー`C-x 6'に対して使われるグローバ
     ルキーマップである。

   * `vc-prefix-map'は、プレフィックスキー`C-x v'に対して使われるグロー
     バルキーマップである。

   * `facemenu-keymap'は、プレフィックスキー`M-g'に対して使われるグロー
     バルキーマップである。

   * Emacsには、他にも、`C-x @'、`C-x a i'、`C-x ESC'、`ESC ESC'のプレ
     フィックスキーがある。これらは、特別な名前を持たないキーマップを使
     う。

プレフィックスキーのキーマップバインディングは、当該プレフィックスキーに
続くイベントを探すために使われます。（その関数定義がキーマップであるシン
ボルでもよい。効果は同じであるが、シンボルはプレフィックスキーに対する名
前として働く。）したがって、`C-x'のバインディングはシンボル
`Control-X-prefix'であり、その関数セルがコマンド`C-x'用のキーマップを保
持している。（`ctl-x-map'の値も同じキーマップである。）

プレフィックスキーの定義は、任意の活性なキーマップにあってかまいません。
プレフィックスキーとしての`C-c'、`C-x'、`C-h'、ESCの定義はグローバルマッ
プにあるので、これらのプレフィックスキーはつねに利用できます。メジャーモー
ドやマイナモードでは、プレフィックスキーの定義をローカルキーマップやマイ
ナモードキーマップに入れることで、キーをプレフィックスとして再定義できま
す。*Note Active Keymaps::。

複数の活性なキーマップにおいて、キーがプレフィックスと定義されていると、
さまざまな定義は実質的には併合されます。マイナモードキーマップで定義され
たコマンドが最優先で、つぎにローカルマップのプレフィックス定義、そしてグ
ローバルマップのプレフィックス定義が続きます。

以下の例では、ローカルキーマップにおいて、`C-p'を`C-x'に等価なプレフィッ
クスキーにします。続いて`C-p C-f'のバインディングを`C-x C-f'のように関数
`find-file'にします。キー列`C-p 6'はどの活性なキーマップでもみつかりませ
ん。

     (use-local-map (make-sparse-keymap))
         => nil
     (local-set-key "\C-p" ctl-x-map)
         => nil
     (key-binding "\C-p\C-f")
         => find-file

     (key-binding "\C-p6")
         => nil

 -- Function: define-prefix-command SYMBOL
     この関数は、SYMBOLをプレフィックスキーのバインディングとして使える
     ように準備する。つまり、完全なキーマップを作成し、SYMBOLの関数定義
     にそのキーマップを保存する。以後、SYMBOLにキー列をバインドすると、
     当該キー列をプレフィックスキーに入る。

     この関数は、変数としてのSYMBOLにも値としてキーマップを設定する。
     SYMBOLを返す。




File: elisp-ja.info, Node: Active Keymaps, Next: Key Lookup, Prev: Prefix Keys, Up: Keymaps

活性なキーマップ
================

Emacsには、通常、たくさんのキーマップがあります。ある時点では、それらの
数個が"活性"になっていて、ユーザー入力の解釈に関与します。それらは、グロー
バルキーマップ、カレントバッファのローカルキーマップ、オンになっているマ
イナモードのキーマップです。

"グローバルキーマップ"（global keymap）は、`C-f'のようなカレントバッファ
に依存せずに定義されたキーのバインディングを保持します。変数`global-map'
はこのキーマップを保持していて、このキーマップはつねに活性です。

各バッファには別のキーマップ、つまり、バッファの"ローカルキーマップ"
（local keymap）があり、キーに対する新しい定義や無効にする定義を保持して
います。カレントバッファのローカルキーマップは、`overriding-local-map'で
無効にしない限り、つねに活性です。テキスト属性により、バッファの特定部分
に対する代替ローカルマップを指定できます。*Note Special Properties::を参
照してください。

各マイナモードもキーマップを持てます。その場合、マイナモードがオンである
と当該キーマップは活性です。

変数`overriding-local-map'が`nil'以外であると、バッファのローカルキーマッ
プとそのすべてのマイナモードキーマップに取ってかわるローカルキーマップを
指定します。

キーが入力されるとどのコマンドを実行するかを決定するために、すべての活性
なキーマップを一緒に使います。Emacsは、キーマップの1つでバインディングが
みつかるまで、優先順位が高いほうからこれらのキーマップを1つ1つ探索します。
1つのキーマップで探索する処理のことを"キー探索"（key lookup）といいます。
*Note Key Lookup::を参照してください。

通常、Emacsはまず`minor-mode-map-alist'で指定される順にマイナモードキー
マップでキーを探します。キーに対するバインディングがなければ、Emacsはロー
カルキーマップで探します。そこにもバインディングがなければ、Emacsはグロー
バルキーマップで探します。しかし、`overriding-local-map'が`nil'以外であ
れば、Emacsはまずそのキーマップで探してから、グローバルキーマップで探し
ます。

同じメジャーモードを使う各バッファは、通常、同じローカルキーマップを使う
ので、キーマップはモードにローカルであると考えることができます。（たとえ
ば`local-set-key'を使って）バッファのローカルキーマップを修正すると、当
該キーマップを共有している別のバッファでもその修正が見えます。

Lispモードや他の数個のメジャーモードで使われるローカルキーマップは、それ
らのモードがまだ使われていなくても存在します。そのようなローカルキーマッ
プは、`lisp-mode-map'などの変数の値です。使用頻度の低いほとんどのメジャー
モードでは、セッションで始めてそのモードを使ったときにローカルキーマップ
を作成します。

ミニバッファにもローカルキーマップがあります。それにはさまざまな補完コマ
ンドや脱出コマンドが含まれます。*Note Intro to Minibuffers::。

Emacsには、別の用途のキーマップもあります。`read-key-sequence'でイベント
を変換するためのものです。*Note Translating Input::。

標準的なキーマップの一覧については*Note Standard Keymaps::。

 -- Variable: global-map
     この変数は、Emacsがキーボード入力をコマンドに対応させるためのデフォ
     ルトのグローバルキーマップを保持する。グローバルキーマップは、通常、
     このキーマップである。デフォルトのグローバルキーマップは、すべての
     印字文字に`self-insert-command'をバインドする完全なキーマップである。

     グローバルマップのバインディングを修正することは実用的ですが、この
     変数には、動作開始時のキーマップ以外の値は設定しないこと。

 -- Function: current-global-map
     この関数は、現在のグローバルキーマップを返す。`global-map'を変更し
     ていなければ、これは`global-map'の値と同じである。

          (current-global-map)
          => (keymap [set-mark-command beginning-of-line ... 
                      delete-backward-char])

 -- Function: current-local-map
     この関数は、カレントバッファのローカルキーマップを返す。なければ
     `nil'を返す。つぎの例では、（lisp対話モードを使っている）バッファ
     `*scratch*'のキーマップは疎なキーマップであり、ASCIIコード27のESCに
     対する指定も別の疎なキーマップである。

          (current-local-map)
          => (keymap 
              (10 . eval-print-last-sexp) 
              (9 . lisp-indent-line) 
              (127 . backward-delete-char-untabify) 
              (27 keymap 
                  (24 . eval-defun) 
                  (17 . indent-sexp)))

 -- Function: current-minor-mode-maps
     この関数は、現在オンになっているマイナモードのキーマップのリストを
     返す。

 -- Function: use-global-map KEYMAP
     この関数は、キーマップKEYMAPを新たな現在のグローバルキーマップとす
     る。これは`nil'を返す。

     グローバルキーマップを変更することは、とうてい普通のことではない。

 -- Function: use-local-map KEYMAP
     この関数は、キーマップKEYMAPをカレントバッファの新たなローカルキー
     マップとする。KEYMAPが`nil'であると、バッファにはローカルキーマップ
     がなくなる。`use-local-map'は`nil'を返す。ほとんどのメジャーモード
     コマンドは、この関数を使う。

 -- Variable: minor-mode-map-alist
     この変数は、変数の値に応じて活性になっている／いないキーマップを記
     述する連想リストである。その要素はつぎの形である。

          (VARIABLE . KEYMAP)

     変数VARIABLEの値が`nil'以外であれば、キーマップKEYMAPは活性である。
     典型的には、VARIABLEはマイナモードをオン／オフする変数である。*Note
     Keymaps and Minor Modes::。

     `minor-mode-map-alist'の要素と`minor-mode-alist'の要素とは、異なる
     構造であることに注意してほしい。キーマップは要素のCDRである必要があ
     り、要素のCADRがキーマップであるようなリストではだめである。CADRは、
     （リストの）キーマップであるか、関数定義がキーマップであるシンボル
     である。

     複数のマイナモードキーマップが活性な場合、それらの優先順位は、
     `minor-mode-map-alist'での順番である。読者は、互いに干渉しないよう
     にマイナモードを設計する必要がある。正しくできていれば、順序は関係
     ないはずである。

     マイナモードについて詳しくは*Note Keymaps and Minor Modes::を参照。
     `minor-mode-key-binding'（*Note Functions for Key Lookup::）も参照
     のこと。

 -- Variable: minor-mode-overriding-map-alist
     この変数は、メジャーモードから特定のマイナモード向けのキーバインディ
     ングを無効にするためのものである。この連想リストの要素は、
     `minor-mode-map-alist'の要素と同じ形で、`(VARIABLE . KEYMAP)'である。

     `minor-mode-overriding-map-alist'の要素として変数が現れると、当該要
     素が指定するキーマップで、`minor-mode-map-alist'内の同じ変数で指定
     したキーマップを完全に置き換える。

     `minor-mode-overriding-map-alist'は、すべてのバッファにおいて、自動
     的にバッファにローカルになる。

 -- Variable: overriding-local-map
     `nil'以外の値であると、この変数は、バッファのローカルキーマップ、な
     らびに、すべてのマイナモードキーマップのかわりに用いるキーマップを
     保持する。このキーマップは、現在のグローバルキーマップを除く、他の
     すべての活性なキーマップを無効にする。

 -- Variable: overriding-terminal-local-map
     `nil'以外であると、この変数は、`overriding-local-map'、および、バッ
     ファのローカルキーマップとすべてのマイナモードキーマップのかわりに
     用いるキーマップを保持する。

     この変数はつねに現在の端末に対してローカルであり、バッファに対して
     ローカルにはならない。*Note Multiple Displays::。これはインクリメン
     タルサーチモードの実装に使われている。

 -- Variable: overriding-local-map-menu-flag
     この変数が`nil'以外であれば、`overriding-local-map'や
     `overriding-terminal-local-map'の値は、メニューバーの表示に影響する。
     デフォルト値は`nil'であり、そのため、それらのマップはメニューバーに
     は影響しない。

     これら2つのキーマップ変数は、メニューバーの表示に影響しないときであっ
     ても、メニューバーを用いて入力したキー列の実行には影響することに注
     意してほしい。そのため、メニューバーのキー列が到着したら、そのキー
     列を探索し実行するまえに、これらの変数をクリアすべきである。これら
     の変数を使うモードでは、典型的にはつぎのようにする。つまり、モード
     で処理できないイベントは『読み戻し』てモードから抜ける。

 -- Variable: special-event-map
     この変数は特殊イベント用のキーマップを保持する。イベント型のバイン
     ディングがこのキーマップにあれば、そのイベントは特殊イベントであり、
     `read-event'が当該イベントのバインディングを直接実行する。*Note
     Special Events::。



