Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Key Lookup, Next: Functions for Key Lookup, Prev: Active Keymaps, Up: Keymaps

キー探索
========

"キー探索"（key lookup）とは、与えられたキーマップからキー列のバインディ
ングを捜し出す処理です。バインディングを実際に実行することは、キー探索で
はありません。

キー探索では、キー列の各イベントのイベント型のみを使い、イベントの他の部
分は無視します。実際、キー探索に使われるキー列では、マウスイベント全体
（リスト）ではなくそのイベント型（シンボル）のみを指定します。*Note
Input Events::。そのような『キー列』は、`command-execute'の動作には不十
分ですが、キーの探索や再バインディングには十分です。

キー列が複数のイベントから構成される場合、キー探索ではイベントを順番に処
理します。先頭のイベントのバインディングを探しますが、それはキーマップで
あるはずです。続いて、そのキーマップから2番目のイベントのバインディング
を探します。これをキー列のすべてのイベントを使い尽くすまで行います。（こ
のように探した最後のイベントに対するバインディングは、キーマップであたっ
りそうでないかもしれない。）つまり、キー探索処理は、キーマップから単一イ
ベントを探索するという単純な処理として定義できます。これがどのように行わ
れるかは、キーマップ内のイベントに対応付けられたオブジェクトの型に依存し
ます。

キーマップでイベント型を探してみつかった値のことを"キーマップ項目"
（keymap entry）という単語で表します。（これには、メニューキーバインディ
ングにある項目文字列や他の追加要素を含まない。というのは、`lookup-key'や
他のキー探索関数は、それらを戻り値として返さないからである。）キーマップ
項目として任意のLispオブジェクトをキーマップに保存できますが、キー探索に
おいてそのすべてが意味を持つとは限りません。意味のある種類のキー項目をつ
ぎに示します。

`nil'
     `nil'は、探索に使ったここまでのイベントが未定義キーを構成することを
     意味する。キーマップにイベント型が記載されてなく、かつ、デフォルト
     のバインディングもない場合には、そのイベント型に対しては、バインディ
     ングが`nil'であるのと等価。

COMMAND
     探索に使ったここまでのイベントは完全なキーを構成し、そのバインディ
     ングはコマンドCOMMANDである。*Note What Is a Function::。

ARRAY
     配列（文字列やベクトル）は、キーボードマクロである。探索に使ったこ
     こまでのイベントは完全なキーを構成し、そのバインディングは配列ARRAY
     である。詳しくは*Note Keyboard Macros::を参照。

KEYMAP
     探索に使ったここまでのイベントはプレフィックスキーを構成する。キー
     列のつぎのイベントはこのキーマップKEYMAPで探す。

LIST
     リストの意味は、リストの要素の型に依存する。

        * LISTのCARがシンボル`keymap'であれば、そのリストはキーマップで
          あり、キーマップとして扱われる（上記参照）。

        * LISTのCARがシンボル`lambda'であれば、そのリストはラムダ式であ
          る。これはコマンドとみなされ、そのように扱われる（上記参照）。

        * LISTのCARがキーマップであり、CDRがイベント型であると、これは"
          間接項目"（indirect entry）である。

               (OTHERMAP . OTHERTYPE)

          キー探索中に間接項目に出会うと、OTHERTYPEのバインディングを
          OTHERMAPで探しそれを用いる。

          この機能により、あるキーを別のキーに対する別名として定義できる。
          たとえば、CARが`esc-map'と呼ばれるキーマップでありCDRが32（SPC
          の文字コード）である項目は、『`Meta-SPC'のグローバルバインディ
          ングをそれがなんであれ使う』という意味になる。

SYMBOL
     シンボルSYMBOLのかわりにその関数定義を使う。それがまたシンボルであ
     ると、この処理を何回でも繰り返す。最終的にこれは、キーマップ、コマ
     ンド、キーボードマクロのいずれかのオブジェクトになるはずである。キー
     マップやコマンドであるリストは許されるが、シンボルを介しては間接項
     目は使えない。

     キーマップやキーボードマクロ（文字列やベクトル）は正しい関数ではな
     いので、関数定義としてキーマップ、文字列、ベクトルを持つシンボルは、
     正しい関数ではない。しかし、キーバインディングとしては正しい。定義
     がキーボードマクロである場合には、そのシンボルは`command-execute'の
     引数としても正しい（*Note Interactive Call::）。

     シンボル`undefined'について特記しておく。これは、キーを未定義として
     扱うことを意味する。正確には、キーは定義されており、そのバインディ
     ングはコマンド`undefined'である。しかし、そのコマンドは、未定義キー
     に対して自動的に行われることと同じことを行う。つまり、（`ding'を呼
     び出して）ベルを鳴らすが、エラーは通知しない。

     `undefined'は、グローバルキーバインディングを無効にしてキーをローカ
     ルに『未定義』にするためにローカルキーマップで使われる。`nil'のロー
     カルバインディングでは、グローバルバインディングを無効にしないため、
     こうはならない。

その他
     その他の型のオブジェクトであると、探索に使ったここまでのイベントは
     完全なキーを構成し、当該オブジェクトがそのバインディングであるが、
     当該バインディングはコマンドとしては実行できない。

まとめると、キー項目は、キーマップ、コマンド、キーボードマクロ、これら3
つのいずれかになるシンボル、間接項目、`nil'です。2つの文字をコマンドに、
1つを別のキーマップに対応付ける疎なキーマップの例を示します。このキーマッ
プは、`emacs-lisp-mode-map'の通常の値です。ここで、それぞれ、9はTAB、127
はDEL、27はESC、17は`C-q'、24は`C-x'の文字コードであることに注意してくだ
さい。

     (keymap (9 . lisp-indent-line)
             (127 . backward-delete-char-untabify)
             (27 keymap (17 . indent-sexp) (24 . eval-defun)))



File: elisp-ja.info, Node: Functions for Key Lookup, Next: Changing Key Bindings, Prev: Key Lookup, Up: Keymaps

キー探索関数
============

ここでは、キー探索に関わる関数や変数について述べます。

 -- Function: lookup-key KEYMAP KEY &optional ACCEPT-DEFAULTS
     この関数はキーマップKEYMAPにおけるKEYの定義を返す。本章で述べる他の
     関数は、`lookup-key'を用いてキーを探す。例を示す。

          (lookup-key (current-global-map) "\C-x\C-f")
              => find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              => 2

     文字列やベクトルであるKEYが、KEYMAPで指定されたプレフィックスキーに
     対して正しいキー列でなければ、KEYは『長すぎる』のであって、1つのキー
     列に収まらない余分なイベントが末尾にある。その場合、戻り値は数であ
     り、完全なキーを構成するKEYの先頭からのイベント数を表す。

     ACCEPT-DEFAULTSが`nil'以外であると、`lookup-key'は、KEYの特定のイベ
     ントに対するバインディングだけでなく、デフォルトのバインディングも
     考慮する。さもなければ、`lookup-key'は、KEYの特定のイベントに対する
     バインディングだけを報告し、特に指定しない限りデフォルトのバインディ
     ングは無視する。（それには、KEYの要素として`t'を与える。*Note
     Format of Keymaps::を参照。）

     KEYにメタ文字が含まれる場合、当該文字は暗黙のうちに2文字の列、つま
     り、`meta-prefix-char'の値と対応する非メタ文字に置き換えられる。し
     たがって、つぎの最初の例は、2番目の例に変換して処理される。

          (lookup-key (current-global-map) "\M-f")
              => forward-word
          (lookup-key (current-global-map) "\ef")
              => forward-word

     `read-key-sequence'と異なり、この関数は、情報を欠落するようには指定
     されたイベントを修正しない（*Note Key Sequence Input::）。特に、文
     字を小文字に変換したり、ドラッグイベントをクリックイベントに変換し
     たりはしない。

 -- コマンド: undefined
     キーを未定義にするためにキーマップで使われる。`ding'を呼び出すが、
     エラーにはならない。

 -- Function: key-binding KEY &optional ACCEPT-DEFAULTS
     この関数は、すべての活性なキーマップを試してKEYに対するバインディン
     グを返す。キーマップでKEYが未定義であると結果は`nil'。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、デフォルトのバ
     インディングを調べるかどうか制御する。

     KEYが文字列でもベクトルでもないとエラーを通知する。

          (key-binding "\C-x\C-f")
              => find-file

 -- Function: local-key-binding KEY &optional ACCEPT-DEFAULTS
     この関数は、現在のローカルキーマップからKEYに対するバインディングを
     返す。未定義ならば`nil'を返す。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、デフォルトのバ
     インディングを調べるかどうか制御する。

 -- Function: global-key-binding KEY &optional ACCEPT-DEFAULTS
     この関数は、現在のグローバルキーマップからKEYに対するバインディング
     を返す。未定義ならば`nil'を返す。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、デフォルトのバ
     インディングを調べるかどうか制御する。

 -- Function: minor-mode-key-binding KEY &optional ACCEPT-DEFAULTS
     この関数は、すべてのオンになっているマイナモードにおけるKEYのバイン
     ディングのリストを返す。より正確には、対`(MODENAME . BINDING)'を要
     素とする連想リストを返す。ここで、MODENAMEはマイナモードをオンにす
     る変数であり、BINDINGは当該モードにおけるKEYのバインディングである。
     KEYにマイナモードでのバインディングがなければ、値は`nil'である。

     最初にみつかったバインディングがプレフィックスの定義（キーマップか
     キーマップとしてのシンボル）でなければ、残りのマイナモードからのバ
     インディングは完全に隠されてしまうのでそれらは省略する。同様に、プ
     レフィックスバインディングに続く非プレフィックスバインディングも省
     略する。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、デフォルトのバ
     インディングを調べるかどうか制御する。

 -- Variable: meta-prefix-char
     この変数は、メタプレフィックス文字の文字コードである。メタ文字をキー
     マップで探索するために2文字列に変換するときに使われる。結果が有用で
     あるためには、この値はプレフィックスイベント（*Note Prefix Keys::）
     であるべきである。デフォルト値は27、ESCのASCIIコードである。

     `meta-prefix-char'の値が27である限り、キー探索では`M-b'を`ESC b'に
     変換し、通常、これはコマンド`backward-word'と定義されている。しかし、
     `meta-prefix-char'に`C-x'のコードである24を設定すると、Emacsは`M-b'
     を`C-x b'に変換し、その標準のバインディングはコマンド
     `switch-to-buffer'である。これを以下に示す。

          meta-prefix-char                    ; デフォルト値
               => 27
          (key-binding "\M-b")
               => backward-word
          ?\C-x                               ; 文字の表示表現
               => 24
          (setq meta-prefix-char 24)
               => 24      
          (key-binding "\M-b")
              => switch-to-buffer            ; ここでM-bと打つと
                                              ; C-x bと打つのと同じ

          (setq meta-prefix-char 27)          ; 混乱を避けるために
               => 27                         ; デフォルト値に戻す！



File: elisp-ja.info, Node: Changing Key Bindings, Next: Key Binding Commands, Prev: Functions for Key Lookup, Up: Keymaps

キーバインディングの変更
========================

キーを再バインドするには、キーマップにおける当該項目を変更します。グロー
バルキーマップでバインディングを変更すると、その変更はすべてのバッファで
効果を発揮します（ただし、ローカルキーマップでグローバルバインディングを
隠しているバッファでは直接の効果はない）。カレントバッファのローカルキー
マップで変更すると、通常、同じメジャーモードを使っているすべてのバッファ
に影響します。関数`global-set-key'や`local-set-key'は、これらの操作を行
うための便利なインターフェイスです（*Note Key Binding Commands::）。より
汎用の関数`define-key'を使うこともできますが、変更対象のキーマップを明示
する必要があります。

キー列の再バインドを書くときには、コントロール文字やメタ文字向けの特別な
エスケープシーケンスを使うのがよいです（*Note String Type::）。構文`\C-'
は後続の文字がコントロール文字であること、構文`\M-'は後続の文字がメタ文
字であることを意味します。したがって、文字列`"\M-x"'は単一の`M-x'を含む
と読まれ、`"\C-f"'は単一の`C-f'を含むと読まれ、`"\M-\C-x"'や`"\C-\M-x"'
はいずれも単一の`C-M-x'を含むと読まれます。同じエスケープシーケンスは、
ベクトルでも使え、文字列が許されない他の場面でも使えます。たとえば、
`[?\C-\H-x home]'です。*Note Character Type::。

キーを定義したり探索する関数では、ベクトルで表したキー列内のイベント型に
対して別の構文、つまり、修飾子名と1つの基本イベント（文字やファンクショ
ンキー名）から成るリストを受け付けます。たとえば、`(control ?a)'は
`?\C-a'に等価であり、`(hyper control left)'は`C-H-left'に等価です。この
ようなリストの利点の1つは、コンパイル済みのファイルに修飾ビットの数値が
現れないことです。

以下の関数では、KEYMAPがキーマップでなかったり、KEYがキー列を表す文字列
やベクトルでないと、エラーを通知します。リストであるイベントの省略形とし
てイベント型（シンボル）を使えます。

 -- Function: define-key KEYMAP KEY BINDING
     この関数は、キーマップKEYMAPにおいてキーKEYに対するバインディングを
     設定する。（KEYが複数イベントの場合、KEYMAPから辿った別のキーマップ
     が実際には変更される。）引数BINDINGは任意のLispオブジェクトであるが、
     ある種の型のものだけが意味を持つ。（意味のある型の一覧については、
     *Note Key Lookup::を参照。）`define-key'が返す値はBINDINGである。

     KEYのおのおののプレフィックスはプレフィックスキーである（キーマップ
     にある）か未定義であること。さもなければ、エラーを通知する。KEYのプ
     レフィックスに未定義なものがあると、`define-key'は当該プレフィック
     スをプレフィックスキーと定義し、KEYの残りの部分を指定どおりに定義で
     きるようにする。

     KEYMAPにKEYのバインディングがなければ、新たなバインディングをKEYMAP
     の先頭に追加する。キーマップ内のバインディングの順序は多くの場合関
     係ないが、メニューキーマップでは意味を持つ（*Note Menu Keymaps::）。

疎なキーマップを作成し、そこにバインディングを作る例を示します。

     (setq map (make-sparse-keymap))
         => (keymap)
     (define-key map "\C-f" 'forward-char)
         => forward-char
     map
         => (keymap (6 . forward-char))

     ;; C-x用の疎なサブマップを作り、
     ;; そこにfのバインディングを入れる
     (define-key map "\C-xf" 'forward-word)
         => forward-word
     map
     => (keymap 
         (24 keymap                ; C-x
             (102 . forward-word)) ;      f
         (6 . forward-char))       ; C-f

     ;; C-pを`ctl-x-map'にバインドする
     (define-key map "\C-p" ctl-x-map)
     ;; `ctl-x-map'
     => [nil ... find-file ... backward-kill-sentence] 

     ;; `ctl-x-map'で、C-fを`foo'にバインドする
     (define-key map "\C-p\C-f" 'foo)
     => 'foo
     map
     => (keymap     ; `foo'は`ctl-x-map'の中にある
         (16 keymap [nil ... foo ... backward-kill-sentence])
         (24 keymap 
             (102 . forward-word))
         (6 . forward-char))

`C-p C-f'に対する新しいバインディングは、実際には`ctl-x-map'の項目を変更
していて、これには、`C-p C-f'とデフォルトのグローバルキーマップ内の`C-x
C-f'の両方のバインディングを変更する効果があることに注意してください。

 -- Function: substitute-key-definition OLDDEF NEWDEF KEYMAP &optional OLDMAP
     この関数は、KEYMAP内のOLDDEFにバインドされたキーのOLDDEFをNEWDEFに
     置き換える。いいかえると、OLDDEFに出会うたびにそれをNEWDEFに置き換
     える。関数は`nil'を返す。

     たとえば、Emacsの標準のバインディングであると、つぎの例は`C-x C-f'
     を再定義する。

          (substitute-key-definition 
           'find-file 'find-file-read-only (current-global-map))

     OLDMAPが`nil'以外であると、そのバインディングによってどのキーを再バ
     インドするかを決定する。再バインディングはKEYMAPで行い、OLDMAPでは
     ない。つまり、別のキーマップ内のバインディングの制御のもとに、キー
     マップを変更できる。たとえば、

          (substitute-key-definition
            'delete-backward-char 'my-funny-delete
            my-map global-map)

     では、グローバルには標準の削除コマンドにバインドされているキーに対
     しては、`my-map'では特別な削除コマンドにする。


     変更前後のキーマップを以下に示す。

          (setq map '(keymap 
                      (?1 . olddef-1) 
                      (?2 . olddef-2) 
                      (?3 . olddef-1)))
          => (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))

          (substitute-key-definition 'olddef-1 'newdef map)
          => nil
          map
          => (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

 -- Function: suppress-keymap KEYMAP &optional NODIGITS
     この関数は、完全なキーマップKEYMAPの内容を変更し、すべての印字文字
     を未定義にする。より正確には、それらにコマンド`undefined'をバインド
     する。これにより、通常のテキストの挿入を不可能にする。
     `suppress-keymap'は`nil'を返す。

     NODIGITSが`nil'であると、`suppress-keymap'は、数字文字では
     `digit-argument'を実行し、`-'では`negative-argument'を実行するよう
     に定義する。さもなければ、それらも他の印字文字と同様に未定義にする。

     関数`suppress-keymap'は、`yank'や`quoted-insert'などのコマンドを抑
     制しないので、バッファを変更不可能にするわけではない。バッファの変
     更を禁止するには、バッファを読み出し専用にする（*Note Read Only
     Buffers::）。

     この関数はKEYMAPを変更するため、読者は、通常、新たに作成したキーマッ
     プに対して使うであろう。ある目的で使用中の既存のキーマップを操作す
     ると、問題を引き起こすことがある。たとえば、`global-map'に適用する
     とEmacsをほとんど使用不能にしてしまう。

     多くの場合、テキストの挿入が必要なくバッファを読み出し専用で使う
     rmailやdiredなどのモードのローカルキーマップの初期化に
     `suppress-keymap'を使う。ファイル`emacs/lisp/dired.el'から持ってき
     た例を示す。これは、diredモード用のローカルキーマップの設定方法であ
     る。

          (setq dired-mode-map (make-keymap))
          (suppress-keymap dired-mode-map)
          (define-key dired-mode-map "r" 'dired-rename-file)
          (define-key dired-mode-map "\C-d" 'dired-flag-file-deleted)
          (define-key dired-mode-map "d" 'dired-flag-file-deleted)
          (define-key dired-mode-map "v" 'dired-view-file)
          (define-key dired-mode-map "e" 'dired-find-file)
          (define-key dired-mode-map "f" 'dired-find-file)
          ...



File: elisp-ja.info, Node: Key Binding Commands, Next: Scanning Keymaps, Prev: Changing Key Bindings, Up: Keymaps

キーをバインドするためのコマンド
================================

本節では、キーのバインディングを変更する便利で対話的なインターフェイスに
ついて述べます。これらは、`define-key'を呼び出して動作します。

単純なカスタマイズのためにファイル`.emacs'で`global-set-key'をしばしば使
います。たとえば、

     (global-set-key "\C-x\C-\\" 'next-line)

や

     (global-set-key [?\C-x ?\C-\\] 'next-line)

や

     (global-set-key [(control ?x) (control ?\\)] 'next-line)

は、1行下がるように`C-x C-\'を再定義します。

     (global-set-key [M-mouse-1] 'mouse-set-point)

は、メタキーを押し下げながらマウスの第1ボタン（左端）をクリックするとク
リック位置にポイントを設定するように再定義します。

 -- コマンド: global-set-key KEY DEFINITION
     この関数は、現在のグローバルキーマップにおいてKEYのバインディングを
     DEFINITIONと設定する。

          (global-set-key KEY DEFINITION)
          ==
          (define-key (current-global-map) KEY DEFINITION)

 -- コマンド: global-unset-key KEY
     この関数は、現在のグローバルキーマップからKEYのバインディングを削除
     する。

     この関数の1つの用途は、KEYに非プレフィックスのバインディングがある
     と再定義できないため、KEYをプレフィックスとして使う長いキーを定義す
     る前準備である。たとえば、つぎのとおり。

          (global-unset-key "\C-l")
              => nil
          (global-set-key "\C-l\C-l" 'redraw-display)
              => nil

     この関数は単に`define-key'を使って実装してある。

          (global-unset-key KEY)
          ==
          (define-key (current-global-map) KEY nil)

 -- コマンド: local-set-key KEY DEFINITION
     この関数は、現在のローカルキーマップにおいてKEYのバインディングを
     DEFINITIONと設定する。

          (local-set-key KEY DEFINITION)
          ==
          (define-key (current-local-map) KEY DEFINITION)

 -- コマンド: local-unset-key KEY
     この関数は、現在のローカルキーマップからKEYのバインディングを削除す
     る。

          (local-unset-key KEY)
          ==
          (define-key (current-local-map) KEY nil)



File: elisp-ja.info, Node: Scanning Keymaps, Next: Menu Keymaps, Prev: Key Binding Commands, Up: Keymaps

キーマップの走査
================

本節では、ヘルプ情報を表示するために現在のキーマップをすべて走査する関数
について述べます。

 -- Function: accessible-keymaps KEYMAP &optional PREFIX
     この関数は、KEYMAPから（0個以上のプレフィックスキーにより）辿れるす
     べてのキーマップのリストを返す。その値は、`(KEY . MAP)'の形の要素か
     ら成る連想リストである。ここで、KEYはプレフィックスキーであり、
     KEYMAP内でのその定義はMAPである。

     連想リスト内での要素の順番は、KEYの長さが増える順である。指定したキー
     マップKEYMAPはプレフィックスのイベントなしに参照できるので、最初の
     要素はつねに`("" . KEYMAP)'である。

     PREFIXを与える場合、それはプレフィックスキー列であること。すると、
     `accessible-keymaps'は、PREFIXで始まるプレフィックスに対応したサブ
     マップのみを含める。それらの要素は、`(accessible-keymaps)'の値と同
     じに見えるが、違いは、いくつかの要素が省略されることである。

     つぎの例では、返された連想リストにおいては、`^['と表示されたキーESC
     はプレフィックスキーであり、その定義は疎なキーマップ`(keymap (83
     . center-paragraph) (115 . foo))'であることを表す。

          (accessible-keymaps (current-local-map))
          =>(("" keymap 
                (27 keymap   ; Note this keymap for ESC is repeated below.
                    (83 . center-paragraph)
                    (115 . center-line))
                (9 . tab-to-tab-stop))

             ("^[" keymap 
              (83 . center-paragraph) 
              (115 . foo)))

     つぎの例では、`C-h'は、疎なキーマップ`(keymap (118
     . describe-variable)...)'を使うプレフィックスキーである。別のプレ
     フィックス`C-x 4'は、変数`ctl-x-4-map'の値でもあるキーマップを使う。
     イベント`mode-line'は、ウィンドウの特別な箇所におけるマウス操作を表
     すための疑似イベントの1つである。

          (accessible-keymaps (current-global-map))
          => (("" keymap [set-mark-command beginning-of-line ... 
                             delete-backward-char])
              ("^H" keymap (118 . describe-variable) ...
               (8 . help-for-help))
              ("^X" keymap [x-flush-mouse-queue ...
               backward-kill-sentence])
              ("^[" keymap [mark-sexp backward-sexp ...
               backward-kill-word])
              ("^X4" keymap (15 . display-buffer) ...)
              ([mode-line] keymap
               (S-mouse-2 . mouse-split-window-horizontally) ...))

     実際に表示されるキーマップはこれらだけとは限らない。

 -- Function: where-is-internal COMMAND &optional KEYMAP FIRSTONLY NOINDIRECT
     この関数は、コマンド`where-is' （*Note ヘルプ機能: (emacs)Help.）が
     使うサブルーティンである。キーマップにおいてCOMMANDにバインドされた
     （任意長の）キー列のリストを返す。

     引数COMMANDは任意のオブジェクトであり、キーマップ項目とは`eq'で比較
     する。

     KEYMAPが`nil'であると、`overriding-local-map'を無視（つまり、その値
     は`nil'とみな）して、現在活性なキーマップを使う。KEYMAPが`nil'以外
     であると、KEYMAPとグローバルキーマップから辿れるキーマップを使う。

     通常、KEYMAPに対する式には`overriding-local-map'を使うのが最良であ
     る。そうすると、`where-is-internal'は正確に活性なキーマップを走査す
     る。グローバルキーマップのみを走査するには、KEYMAPとして`(keymap)'
     （空のキーマップ）を渡す。

     FIRSTONLYが`non-ascii'であると、戻り値は、可能なキー列のリストでは
     なく、最初にみつかったキー列を表す1つの文字列である。FIRSTONLYが`t'
     であると、値は最初のキー列であるが、ASCII文字（あるいはASCII文字の
     メタ変種）のみから成るキー列が他のキー列より優先される。

     NOINDIRECTが`nil'以外であると、`where-is-internal'は間接項目を辿ら
     ない。これにより、間接項目そのものを探すことができる。

          (where-is-internal 'describe-function)
              => ("\^hf" "\^hd")

 -- コマンド: describe-bindings &optional PREFIX
     この関数は、現在のすべてのキーバインディングの一覧を作成し、
     `*Help*'という名前のバッファに表示する。テキストはモードごとにまと
     められ、マイナモード、メジャーモード、グローバルバインディングの順
     である。

     PREFIXが`nil'以外であると、それはプレフィックスキーであること。そう
     すると、PREFIXで始まるキーのみの一覧を作る。

     一覧では、メタ文字は、ESCに続けて対応する非メタ文字で表す。

     連続したASCIIコードの一連の文字が同じ定義である場合には、それらをま
     とめて`FIRSTCHAR..LASTCHAR'と表示する。この場合、どの文字であるか理
     解するには、ASCIIコードを知っている必要がある。たとえば、デフォルト
     のグローバルキーマップでは、`SPC.. ~'の文字が1行に表示される。SPCは
     ASCIIコード32、`~'はASCIIコード126であり、そのあいだには普通の印字
     文字（英文字、数字文字、句読点文字など）がすべて含まれる。これらの
     文字はすべて`self-insert-command'にバインドされている。



File: elisp-ja.info, Node: Menu Keymaps, Prev: Scanning Keymaps, Up: Keymaps

メニューキーマップ
==================

キーマップは、キーボードのキーやマウスボタンに対するバインディングに加え
てメニューも定義できます。

* Menu:

* Defining Menus::		How to make a keymap that defines a menu.
* Mouse Menus::			How users actuate the menu with the mouse.
* Keyboard Menus::		How they actuate it with the keyboard.
* Menu Example::		Making a simple menu.
* Menu Bar::			How to customize the menu bar.
* Modifying Menus::             How to add new items to a menu.



File: elisp-ja.info, Node: Defining Menus, Next: Mouse Menus, Prev: Menu Keymaps, Up: Menu Keymaps

メニューの定義
--------------

キーマップに"全面プロンプト文字列"（overall prompt string）、つまり、キー
マップの要素として文字列が現れれば、メニューとして使えます。その文字列で
メニューの目的を記述します。プロンプト文字列を持ったキーマップを作成する
もっとも簡単な方法は、`make-keymap'や`make-sparse-keymap'（*Note
Creating Keymaps::）を呼ぶときに、引数として文字列を指定します。

メニュー上での項目の順番は、キーマップ内のバインディングの順番と同じです。
`define-key'は、新たなバインディングを先頭に追加するので、順番を気にする
のならば、メニューの底の項目から始めて上の項目へ向かってメニュー項目の定
義を入れます。既存のメニューに項目を追加する場合には、`define-key-after'
（*Note Modifying Menus::）を使ってメニュー内での位置を指定できます。

* Menu:

* Simple Menu Items::       A simple kind of menu key binding,
                              limited in capabilities.
* Alias Menu Items::        Using command aliases in menu items.
* Extended Menu Items::     More powerful menu item definitions
                              let you specify keywords to enable
                              various features.



File: elisp-ja.info, Node: Simple Menu Items, Next: Extended Menu Items, Prev: Defining Menus, Up: Defining Menus

単純なメニュー項目
..................

メニューキーマップのバインディングを定義する単純で旧式の方法はつぎのとお
りです。

     (ITEM-STRING . REAL-BINDING)

CARのITEM-STRINGは、メニューに表示される文字列です。3単語までの短いもの
にし、対応するコマンドの動作を記述します。

つぎのように、ヘルプ文字列となる2つめの文字列も指定できます。

     (ITEM-STRING HELP-STRING . REAL-BINDING)

現状では、Emacsは実際にはHELP-STRINGを使いません。REAL-BINDINGを取り出す
ためにHELP-STRINGを無視する方法を知っているだけです。将来、ユーザーの要
望に応じてメニュー項目に対する追加説明としてHELP-STRINGを使うかもしれま
せん。

`define-key'に関する限り、ITEM-STRINGとHELP-STRINGはイベントのバインディ
ングの一部分です。しかし、`lookup-key'はREAL-BINDINGのみを返し、キーの実
行にはREAL-BINDINGのみが使われます。

REAL-BINDINGが`nil'であると、ITEM-STRINGはメニューに現れますが、それは選
択できません。

REAL-BINDINGがシンボルであり、その属性`menu-enable'が`nil'以外であると、
当該属性は、メニュー項目を活性にするかどうかを制御する式です。Emacsは、
メニューを表示するためにキーマップを使うたびに、その式を評価し、式の値が
`nil'以外である場合に限り、当該メニュー項目をオンにします。メニュー項目
がオフであると、『薄く』表示し、それは選択できません。

メニューバーでは、読者がメニューを見るたびにどの項目がオンであるかを再計
算しません。Xツールキットがあらかじめメニューの木構造全体を必要とするか
らです。メニューバーの再計算を強制するには、`force-mode-line-update'を呼
び出します。（*Note Mode Line Format::）。

メニュー項目には、同じコマンドを起動する等価なキーボードのキー列が（あれ
ば）表示されていることに気づいたと思います。再計算の時間を節約するために、
メニューの表示では、この情報をつぎのようにバインディングの部分リストに隠
し持っています。

     (ITEM-STRING [HELP-STRING] (KEY-BINDING-DATA) . REAL-BINDING)

読者は、メニュー項目にこれらの部分リストを入れないでください。それらはメ
ニューの表示で自動的に計算されます。冗長になるので、項目の文字列には、等
価なキーボード入力を含めないでください。



File: elisp-ja.info, Node: Extended Menu Items, Next: Alias Menu Items, Prev: Simple Menu Items, Up: Defining Menus

拡張メニュー項目
................

拡張形式のメニュー項目は、より柔軟性があり、単純な形式より見通しがよい代
替方法です。それらは、シンボル`menu-item'で始まるリストから成ります。選
択不可の文字列を定義するには、項目をつぎのようにします。

     (menu-item ITEM-NAME)

ここで、文字列ITEM-NAMEは区切り行を表す複数個のダッシュから成ります。

選択可能な実際のメニュー項目を定義するには、拡張形式の項目はつぎのように
なります。

     (menu-item ITEM-NAME REAL-BINDING
         . ITEM-PROPERTY-LIST)

ここで、ITEM-NAMEは、メニュー項目の文字列に評価される式です。つまり、
（項目の）文字列は定数である必要はありません。3番目の要素
ITEM-PROPERTY-LISTは実行すべきコマンドです。リストの残り
ITEM-PROPERTY-LISTは、他の情報を含んだ属性リストの形式です。指定できる属
性はつぎのとおりです。

`:enable FORM'
     FORMの評価結果で、項目をオンにするかどうか決定する（`nil'以外だとオ
     ン）。

`:visible FORM'
     FORMの評価結果で、項目をメニューに含めるかどうか決定する。（`nil'以
     外だと含める）。項目を含めない場合、当該項目が定義されていないかの
     ようにメニューを表示する。

`:help HELP'
     この属性の値HELPは、拡張ヘルプ文字列（現状ではEmacsは使わない）。

`:button (TYPE . SELECTED)'
     この属性は、ラジオボタンとトグルボタンを定義する方法を提供する。CAR
     のTYPEは、`:toggle'か`:radio'であり、どちらであるかを指定する。CDR
     のSELECTEDはフォームであること。その評価結果が、現在ボタンが選択さ
     れているかどうかを決定する。

     "トグル"（toggle）は、SELECTEDの値に応じて『on』か『off』と書かれる
     メニュー項目である。コマンド自身では、SELECTEDが`nil'ならばSELECTED
     に`t'を設定し、`t'ならば`nil'を設定すること。以下は、
     `debug-on-error'が定義されていれば`debug-on-error'をオン／オフする
     メニュー項目の書き方である。

          (menu-item "Debug on Error" toggle-debug-on-error
                     :button (:toggle
                              . (and (boundp 'debug-on-error)
                                     debug-on-error))

     これは、変数`debug-on-error'をオン／オフするコマンドとして
     `toggle-debug-on-error'が定義されているので動作する。

     "ラジオボタン"（radio button）はメニュー項目のグループであり、ある
     時点ではそれらのうちの1つだけを『選択』できる。どれを選択しているか
     を表す変数が必要である。グループ内の各ラジオボタンに対するフォーム
     SELECTEDは、当該変数の値が当該ボタンを選択している値かどうかを検査
     する。ボタンをクリックすると、クリックしたボタンが選択されるように
     当該変数に設定すること。

`:key-sequence KEY-SEQUENCE'
     この属性は、このメニュー項目が起動するコマンドにバインドされる可能
     性があるキー列を指定する。正しいキー列を指定すると、メニュー表示の
     準備が素早くなる。

     まちがったキー列を指定しても、その効果はない。メニューに
     KEY-SEQUENCEを表示するまえに、EmacsはKEY-SEQUENCEがこのメニュー項目
     に実際に等価かどうか調べる。

`:key-sequence nil'
     この属性は、このメニュー項目に等価なキーバインディングが普通はない
     ことを示す。この属性を使うとメニュー表示の準備時間を節約できる。
     Emacsはこのメニュー項目に等価なキーボード入力をキーマップで探す必要
     がないからである。

     しかし、ユーザーがこの項目の定義に対してキー列を再バインドすると、
     Emacsは属性`:keys'を無視して等価なキーボード入力を探す。

`:keys STRING'
     この属性は、このメニュー項目に対する等価なキーボード入力として表示
     する文字列STRINGを指定する。STRINGでは説明文の`\\[...]'の書き方を使
     える。

`:filter FILTER-FN'
     この属性は、動的にメニュー項目を計算する方法を与える。属性値
     FILTER-FNは1引数の関数であること。それが呼ばれるとき、引数は
     REAL-BINDINGになる。関数はかわりに使用するバインディングを返すこと。



File: elisp-ja.info, Node: Alias Menu Items, Prev: Extended Menu Items, Up: Defining Menus

メニュー項目の別名
..................

『同じ』コマンドを使いながらオン条件が異なるメニュー項目を作れると便利な
ことがあります。現状のEmacsでこれを行う最良の方法は、拡張メニュー項目を
使うことです。この機能がなかった頃には、コマンドの別名を定義し、それをメ
ニュー項目で使うことで可能でした。異なるオン条件で`toggle-read-only'を使
う2つの別名の作り方を以下に示します。

     (defalias 'make-read-only 'toggle-read-only)
     (put 'make-read-only 'menu-enable '(not buffer-read-only))
     (defalias 'make-writable 'toggle-read-only)
     (put 'make-writable 'menu-enable 'buffer-read-only)

メニューに別名を使うときには、（典型的にはメニュー以外にはキーバインディ
ングがない）別名ではなく『本物の』コマンド名に対する等価なキーバインディ
ングを表示しするのがしばしば有用です。これを行うには、別名のシンボルには
`nil'以外の属性`menu-alias'を与えます。

     (put 'make-read-only 'menu-alias t)
     (put 'make-writable 'menu-alias t)

こうすると、`make-read-only'と`make-writable'のメニュー項目には
`toggle-read-only'に対するキーバインディングが表示されます。



File: elisp-ja.info, Node: Mouse Menus, Next: Keyboard Menus, Prev: Defining Menus, Up: Menu Keymaps

メニューとマウス
----------------

メニューキーマップがメニューを表示するようにする普通の方法は、メニューキー
マップをプレフィックスキーの定義にすることです。（Lispプログラムから明示
的にメニューをポップアップして、ユーザーの選択を受け取れる。*Note Pop-Up
Menus::を参照。）

プレフィックスキーがマウスイベントで終っていると、Emacsはメニューをポッ
プアップすることでメニューキーマップを扱います。これで、ユーザーはマウス
で選択できるようになります。ユーザーがメニュー項目をクリックすると、当該
メニュー項目をバインディングとする文字やシンボルがイベントとして生成され
ます。（メニューが複数レベルになっていたりメニューバーから開いたときには、
メニュー項目は一連のイベントを生成する。）

メニューの開始にはボタン押し下げイベントを使うのがしばしば最良です。そう
すると、ユーザーはボタンを離すことでメニュー項目を選べます。

明示的に配置すれば、1つのキーマップをメニューペインとして表示できます。
それには、各ペインに対するキーマップを作成し、つぎに、メニューのメインの
キーマップにおいて、（各ペインの）各キーマップに対するバインディングを作
ります。なお、これらのバインディングには、`@'で始まる項目文字列を指定し
ます。項目文字列の残りの部分がペインの名前になります。この例についてはファ
イル`lisp/mouse.el'を参照してください。`@'で始まらない項目文字列の他の普
通のバインディングは1つのペインにまとめられ、サブマップに対して明示的に
作られた他のペインとともに表示されます。

Xツールキットのメニューにはペインはありませんが、そのかわりに、サブメニュー
があります。項目文字列が`@'で始まるかどうかに関わらず、入れ子になった各
キーマップがサブメニューになります。Emacsのツールキット版では、項目文字
列の先頭の`@'に関して特別なことは、`@'がメニュー項目に表示されないことで
す。

個別のキーマップからも複数ペインやサブメニューを作成できます。プレフィッ
クスキーの完全な定義は、さまざまな活性のキーマップ（マイナモード、ローカ
ル、グローバル）が与える定義を併合することで得られます。これらのキーマッ
プのうち複数個がメニューであるとき、そのおのおのが別々のペイン（Xツール
キットを使わないEmacs）や別々のサブメニュー（Xツールキットを使ったEmacs）
になります。*Note Active Keymaps::。



File: elisp-ja.info, Node: Keyboard Menus, Next: Menu Example, Prev: Mouse Menus, Up: Menu Keymaps

メニューとキーボード
--------------------

キーボードイベント（文字や関数）で終るプレフィックスキーに、メニューキー
マップであるような定義があると、ユーザーはメニュー項目を選ぶためにキーボー
ドを使えます。

Emacsはメニューの選択項目（バインディングの項目文字列）をエコー領域に表
示します。それらが1行に収まらなければ、ユーザーはSPCを打つことで選択項目
のつぎの行を見ることができます。SPCを連続して使うと最終的にはメニューの
最後に達し、そうするとメニューの先頭に戻ります。（変数
`menu-prompt-more-char'に、このために用いる文字を指定する。デフォルトは
SPC。）

ユーザーは、メニューから望みの項目をみつけたら、対応する文字、つまり、そ
の項目のバインディングを持つ文字を打ちます。


Emacs類似エディタにおけるこのようなメニューの使い方は、システムHierarkey
に触発されたからです。

 -- Variable: menu-prompt-more-char
     この変数は、メニューのつぎの行を見るために使う文字を指定する。初期
     値は、SPCの文字コードの32である。



File: elisp-ja.info, Node: Menu Example, Next: Menu Bar, Prev: Keyboard Menus, Up: Menu Keymaps

メニューの例
------------

以下に、メニューキーマップの完全な定義の例を示します。これは、メニューバー
のメニュー`Tools'のサブメニュー`Print'の定義であり、単純なメニュー項目を
使います（*Note Simple Menu Items::）。まず、キーマップを作成し名前を与
えます。

     (defvar menu-bar-print-menu (make-sparse-keymap "Print"))

つぎに、メニュー項目を定義します。

     (define-key menu-bar-print-menu [ps-print-region]
       '("Postscript Print Region" . ps-print-region-with-faces))
     (define-key menu-bar-print-menu [ps-print-buffer]
       '("Postscript Print Buffer" . ps-print-buffer-with-faces))
     (define-key menu-bar-print-menu [separator-ps-print]
       '("--"))
     (define-key menu-bar-print-menu [print-region]
       '("Print Region" . print-region))
     (define-key menu-bar-print-menu [print-buffer]
       '("Print Buffer" . print-buffer))

バインディングが『作られる対象』のシンボルに注意してください。定義される
キー列の角括弧の内側に現れています。そのシンボルはコマンド名に等しい場合
もあればそうでない場合もあります。これらのシンボルは『ファンクションキー』
として扱われますが、キーボード上の本物のファンクションキーではありません。
それらはメニュー項目の機能には影響ありませんが、ユーザーがメニューから選
ぶとそれらはエコー領域に『表示』され、`where-is'や`apropos'の出力にも現
れます。

定義が`("--")'であるようなバインディングは区切り行です。実際のメニュー項
目のように、区切りにもキーシンボルがあり、例では`separator-ps-print'です。
1つのメニューに複数の区切りがある場合、それらはすべて異なるキーシンボル
でなければなりません。

つぎには、メニュー内の2つのコマンドのオン条件を定義するコードです。

     (put 'print-region 'menu-enable 'mark-active)
     (put 'ps-print-region-with-faces 'menu-enable 'mark-active)

つぎは、このメニューを親メニューの項目に現れるようにする方法です。

     (define-key menu-bar-tools-menu [print]
       (cons "Print" menu-bar-print-menu))

ここで使っているのは、サブメニューのキーマップ、つまり、変数
`menu-bar-print-menu'の値であって、変数そのものではないことに注意してく
ださい。`menu-bar-print-menu'はコマンドではないので、このシンボルを親メ
ニューの項目に使っても意味がありません。

同じ印刷メニューをマウスクリックに対応付けたければ、つぎのようにしてでき
ます。

     (define-key global-map [C-S-down-mouse-1]
        menu-bar-print-menu)

つぎのようにして、`print-region'に対して拡張メニュー項目（*Note Extended
Menu Items::）を使うこともできます。

     (define-key menu-bar-print-menu [print-region]
       '(menu-item "Print Region" print-region
                   :enable (mark-active)))

拡張メニュー項目では、オン条件はメニュー項目自体の内側に指定します。マー
クがないときにはメニューからこの項目が消えるようにするにはつぎのようにし
ます。

     (define-key menu-bar-print-menu [print-region]
       '(menu-item "Print Region" print-region
                   :visible (mark-active)))



File: elisp-ja.info, Node: Menu Bar, Next: Modifying Menus, Prev: Menu Example, Up: Menu Keymaps

メニューバー
------------

ほとんどのウィンドウシステムでは、各フレームに"メニューバー"（menu bar）、
つまり、フレームの先頭に水平方向に延びているメニューを恒久的に表示できま
す。メニューバーの項目は、すべての活性なキーマップで定義された疑似『ファ
ンクションキー』`menu-bar'のサブコマンドです。

メニューバーに項目を追加するには、読者独自の疑似『ファンクションキー』を
考え（これをKEYとする）、キー列`[menu-bar KEY]'に対するバインディングを
作ります。多くの場合、バインディングはメニューキーマップであって、メニュー
バーの項目上でボタンを押すと別のメニューへ至るようにします。

メニューバーに対する同じ疑似ファンクションキーを複数の活性なキーマップで
定義していても、1つの項目だけが表示されます。ユーザーがメニューバーの当
該項目をクリックすると、当該項目のすべてのサブコマンド、つまり、グローバ
ルのサブコマンド、ローカルのサブコマンド、マイナモードのサブコマンドを含
む1つの複合メニューが表示されます。

メニューバーの内容を決定する際には、通常、変数`overriding-local-map'は無
視されます。つまり、`overriding-local-map'が`nil'であるときに活性になる
キーマップからメニューバーを計算します。*Note Active Keymaps::。

フレームにメニューバーを表示するには、フレームのパラメータ
`menu-bar-lines'が0より大きい必要があります。Emacsはメニューバーそのもの
には1行だけ使います。読者が2行以上を指定すると、残りの行はフレームのウィ
ンドウとメニューバーを区切る行になります。`menu-bar-lines'の値には1か2を
勧めます。*Note Window Frame Parameters::。

メニューバーの項目の設定例を示します。

     (modify-frame-parameters (selected-frame)
                              '((menu-bar-lines . 2)))

     ;; （プロンプト文字列を持つ）メニューキーマップを作り
     ;; それをメニューバーの項目の定義にする
     (define-key global-map [menu-bar words]
       (cons "Words" (make-sparse-keymap "Words")))

     ;; このメニュー内のサブコマンドを定義する
     (define-key global-map
       [menu-bar words forward]
       '("Forward word" . forward-word))
     (define-key global-map
       [menu-bar words backward]
       '("Backward word" . backward-word))

グローバルキーマップに作ったメニューバー項目をローカルキーマップで取り消
すには、ローカルキーマップの当該疑似ファンクションキーのバインディングを
`undefined'で再バインドします。たとえば、つぎのようにしてdiredはメニュー
バーの項目`Edit'を抑制します。

     (define-key dired-mode-map [menu-bar edit] 'undefined)

`edit'は、メニューバー項目`Edit'に対してグローバルキーマップで使う疑似ファ
ンクションキーです。グローバルなメニューバー項目を抑制する主な理由は、モー
ド固有の項目向けに場所を確保するためです。

 -- Variable: menu-bar-final-items
     通常、メニューバーは、グローバルな項目にローカルキーマップで定義さ
     れた項目を続けて表示する。

     この変数は、通常の順ではなくメニューバーの底に表示する項目に対する
     疑似ファンクションキーのリストを保持する。デフォルト値は
     `(help-menu)'であり、したがって、ローカルのメニュー項目に続いて、メ
     ニュー項目`Help'はメニューバーの最後に通常表示される。

 -- Variable: menu-bar-update-hook
     このノーマルフックは、ユーザーがメニューバーをクリックするたびに、
     サブメニューを表示するまえに実行される。これを用いて、内容が変化す
     るサブメニューを更新できる。



File: elisp-ja.info, Node: Modifying Menus, Prev: Menu Bar, Up: Menu Keymaps

メニューの修正
--------------

既存のメニューに新たな項目を挿入するとき、メニューの既存の項目の特定の場
所に挿入したいでしょう。`define-key'で項目を追加すると、通常、メニューの
先頭に入ります。メニューのそれ以外の場所に挿入するには、
`define-key-after'を使います。

 -- Function: define-key-after MAP KEY BINDING AFTER
     KEYに対するバインディングBINDINGをMAP内に作る。ただし、MAP内でのバ
     インディングの位置は、イベントAFTERに対するバインディングのあとにす
     る。引数KEYは長さ1、つまり、1要素のみのベクトルか文字列であること。
     しかし、AFTERは1つのイベント型、つまり、シンボルか文字であり列では
     ないこと。新たなバインディングはAFTERに対するバインディングのうしろ
     に入る。AFTERが`t'であると、新たなバインディングは最後、つまり、キー
     マップの末尾に入る。

     例を示す。

          (define-key-after my-menu [drink]
                            '("Drink" . drink-command) 'eat)

     これは、疑似ファンクションキーDRINKに対するバインディングを作り、
     EATに対するバインディングのあとに入れる。

     shellモードのメニュー`Signals'において、項目`break'のあとに項目
     `Work'を入れる方法はつぎのとおりである。

          (define-key-after
            (lookup-key shell-mode-map [menu-bar signals])
            [work] '("Work" . work-command) 'break)


File: elisp-ja.info, Node: Modes, Next: Documentation, Prev: Keymaps, Up: Top

メジャーモードとマイナモード
****************************

"モード"（mode）とは、Emacsをカスタマイズする定義の集まりであり、読者は
編集中にそれをオン／オフできます。モードには2種類あります。"メジャーモー
ド"（major mode）は、互いに排他的で、特定種類のテキストの編集に使います。
"マイナモード"（minor mode）は、ユーザーがそれぞれを独立にオンにできる機
能を提供します。

本章では、メジャーモードやマイナモードの書き方、それらをモード行に表示す
る方法、ユーザーが指定したフックをモードがどのように実行するかについて述
べます。キーマップや構文テーブルなどの関連事項については、*Note
Keymaps::や*Note Syntax Tables::を参照してください。

* Menu:

* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Imenu::              How a mode can provide a menu
                         of definitions in the buffer.
* Font Lock Mode::     How modes can highlight text according to syntax.
* Hooks::              How to use hooks; how to write code that provides hooks.



File: elisp-ja.info, Node: Major Modes, Next: Minor Modes, Prev: Modes, Up: Modes

メジャーモード
==============

メジャーモードは、特定種類のテキストの編集向けにEmacsを特化します。各バッ
ファには、ある時点では1つのメジャーモードしかありません。

もっとも特化されていないメジャーモードは、"基本（fundamental）モード"で
す。このモードには、モードに固有な定義や変数の設定がありません。そのため、
Emacsの各コマンドはデフォルトのふるまいをし、各オプションもデフォルトの
状態です。他のすべてのメジャーモードでは、さまざまなキーやオプションを再
定義します。たとえば、lisp対話モードでは、`C-j'（`eval-print-last-sexp'）
やTAB（`lisp-indent-line'）など他のキーに対しても特別なキーバインディン
グがあります。

読者の特別な編集作業を補佐するために一群の編集コマンドを書く必要がある場
合、新たなメジャーモードを作ることは一般にはよいことです。実際、メジャー
モードを書くことは（マイナモードを書くことはしばしば難しくなるが、それに
対比すれば）簡単です。

新たなモードが既存のモードに類似していても、既存のモードを2つの目的を果
たすように修正するのは賢いことではありません。そのようにすると、使い難く
保守し難くなるからです。そのかわりに、既存のメジャーモードの定義をコピー
し名前変えてから、コピーを変更します。あるいは、"派生モード" （derived
mode）（*Note Derived Modes::）を定義します。たとえば、
`emacs/lisp/rmailedit.el'にあるrmail編集モードは、テキスト（text）モード
に非常によく似たメジャーモードですが、追加コマンドが3つあります。そのよ
うな定義がテキスト（text）モードとの違いになるのですが、rmail編集モード
はテキスト（text）モードから派生したものです。

rmail編集モードは、バッファのメジャーモードを一時的に変更してバッファを
別の方法（rmailのコマンドではなくEmacsの普通のコマンド）で編集できるよう
にする例題です。そのような場合、一時的なメジャーモードには、普通、バッファ
の通常のモード（この場合にはrmailモード）に戻るコマンドがあります。読者
は、再帰編集の中で一時的に再定義し、ユーザーが再帰編集を抜けるともとに戻
す方法に魅了されるかもしれません。しかし、これを複数のバッファで行うと、
再帰編集はもっとも最近に入った再帰からまず抜けるので、ユーザーの選択に制
約を課すことになり悪い方法です。別のメジャーモードを使えばこのような制約
を回避できます。*Note Recursive Editing::。

標準のGNU Emacs Lispのライブラリのディレクトリには、`text-mode.el'、
`texinfo.el'、`lisp-mode.el'、`c-mode.el'、`rmail.el'などのファイルにい
くつかのメジャーモードのコードが収めてあります。モードの書き方を理解する
ためにこれらのライブラリを調べられます。テキスト（text）モードは、基本
（fundamental）モードについで、もっとも単純なメジャーモードです。rmailモー
ドは複雑な特化されたモードです。

* Menu:

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::     Text mode and Lisp modes.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.
* Derived Modes::           Defining a new major mode based on another major 
                              mode.



File: elisp-ja.info, Node: Major Mode Conventions, Next: Example Major Modes, Prev: Major Modes, Up: Major Modes

メジャーモードの慣習
--------------------

既存のメジャーモードのコードでは、ローカルキーマップや構文テーブルの初期
化、グローバルな名前、フックなどのさまざまなコーディング上の慣習を踏襲し
ています。読者が新たなメジャーモードを定義するときには、これらの慣習に従っ
てください。

   * カレントバッファにおいて新しいモードに切り替える引数なしのコマンド
     を定義し、その名前は`-mode'で終ること。このコマンドが、キーマップ、
     構文テーブル、既存バッファにバッファローカルな変数を設定するが、バッ
     ファの内容は変更しないこと。

   * このモードで使える特別なコマンドに関して記述したこのコマンドに対す
     る説明文字列を書く。読者のモードで`C-h m'（`describe-mode'）を使う
     と、この説明文字列を表示する。

     説明文字列では、`\[COMMAND]'、`\{KEYMAP}'、`\<KEYMAP>'の特別な書き
     方を使え、これらはユーザー独自のキーバインディングに自動的に置き換
     えられる。*Note Keys in Documentation::。

   * メジャーモードコマンドは、`kill-all-local-variables'の呼び出しから
     始めること。それ以前に有効であったメジャーモードのバッファローカル
     な変数に対処するためである。

   * メジャーモードコマンドは、変数`major-mode'にメジャーモードコマンド
     のシンボルを設定すること。これにより、`describe-mode'が表示すべき説
     明文を捜し出す。

   * メジャーモードコマンドは、変数`mode-name'にモードの『愛称』を文字列
     として設定すること。この文字列がモード行に現れる。

   * すべてのグローバルな名前は同一の名前空間にあるので、モードの構成要
     素であるすべてのグローバル変数、定数、関数は、メジャーモード名（名
     前が長ければ、その省略）で始まること。*Note Coding Conventions::。

   * メジャーモードには、通常、それ独自のキーマップがあるはずで、当該モー
     ドのすべてのバッファでローカルキーマップとして使われる。メジャーモー
     ドコマンドは、`use-local-map'を呼び出して、そのローカルキーマップを
     設定すること。詳しくは、*Note Active Keymaps::。

     このキーマップは、`MODENAME-mode-map'という名前のグローバル変数に恒
     久的に保持すること。通常、モードを定義するライブラリでこの変数に設
     定する。

     モードのキーマップ変数に設定するコードの書き方に関する助言について
     は*Note Tips for Defining::。

   * メジャーモードのキーマップでバインドされたキー列は、通常、`C-c'で始
     まり、コントロール文字、数字文字、`{'、`}'、`<'、`>'、`:'、`;'のい
     ずれかが続くようにする。その他の句読点文字はマイナモード向けに予約
     されている。また、通常の英文字はユーザー向けに予約されている。

     メジャーモードにおいては、そのモードによく適合した形で『同じ仕事』
     を行うコマンドであるならば、標準的な意味を持つキー列に当該コマンド
     を再バインドしても合理的である。たとえば、プログラム言語編集用のメ
     ジャーモードでは、`C-M-a'を当該言語にうまく適合した方法で『関数の先
     頭へ移動する』コマンドに再定義する。

     テキスト挿入を許さないdiredやrmailなどのメジャーモードでは、英文字
     や他の印字文字を編集コマンドとして再定義するのも合理的である。dired
     もrmailもこうしている。

   * モードでは、独自の構文テーブルを用意するか、他の関連するモードと構
     文テーブルを共有する。独自の構文テーブルを用意する場合には、
     `MODENAME-mode-syntax-table'という名前の変数に保持すること。*Note
     Syntax Tables::。

   * コメントを書ける言語を扱うモードでは、コメントの構文を定義する変数
     に設定すること。*Note コメントを制御するオプション: (emacs)Options
     for Comments.。

   * モードでは、独自の略語表を用意するか、他の関連するモードと略語表を
     共有する。独自の略語表を用意する場合には、
     `MODENAME-mode-abbrev-table'という名前の変数に保持すること。*Note
     Abbrev Tables::。

   * モードでは、バッファローカルな変数`font-lock-defaults' （*Note Font
     Lock Mode::）に設定して、フォントロック（font-lock）モードに対して
     強調表示の方法を指定すること。

   * モードでは、バッファローカルな変数`imenu-generic-expression'か
     `imenu-create-index-function'（*Note Imenu::）に設定して、iメニュー
     がどのようにバッファ内の定義や節を探すべきかを指定すること。

   * モードに関連する変数の設定には`defvar'か`defcustom'を使い、それらに
     値が設定されている場合には再初期化しないようにする。（再初期化する
     とユーザーのカスタマイズを廃棄してしまう。）

   * Emacsのカスタマイズ変数に対するバッファローカルな束縛は、メジャーモー
     ドコマンドにおいて`make-variable-buffer-local'ではなく
     `make-local-variable'で行う。前者の関数は、すべてのバッファにおいて
     それ以降に設定される当該変数をバッファローカルにしてしまい、このモー
     ドを使わないバッファにも影響する。モードにそのような大局的な効果が
     あるのは望ましくない。*Note Buffer-Local Variables::。

     単一のLispパッケージ内のみにおいて使われる変数に対しては、必要なら
     ば、`make-variable-buffer-local'を使ってもよい。

   * 各メジャーモードには、`MODENAME-mode-hook'という名前の"モードフック
     "（mode hook）があること。モードコマンドは、最後に`run-hooks'を用い
     てフックを実行すること。*Note Hooks::。

   * メジャーモードコマンドは、より基本的なモードのフックを実行してもよ
     い。たとえば、`indented-text-mode'は、`indented-text-mode-hook'に加
     えて`text-mode-hook'も実行する。自前のフックを実行する直前（つまり
     設定が終ったあと）にこれらの他のフックを実行するか、より初期の段階
     で実行してもよい。

   * ユーザーがバッファをこのモードから別のメジャーモードに切り替えたと
     きに特別なことを行う必要がある場合、このモードでは、
     `change-major-mode-hook'（*Note Creating Buffer-Local::）のバッファ
     ローカルな値を設定しておく。

   * このモードが特別に準備したテキストに対してのみ有効な場合には、メジャー
     モードコマンドのシンボルには、つぎのように属性`mode-class'に値
     `special'を設定しておくこと。

          (put 'funny-mode 'mode-class 'special)

     これは、カレントバッファがfunnyモードのときに新たなバッファを作成し
     ても、新しいバッファではfunnyモードを継承しないようにEmacsに指示す
     る。dired、rmail、バッファ一覧などのモードではこの機能を使っている。

   * 新しいモードを識別可能な特定の名前のファイルに対するデフォルトにし
     たい場合には、そのような名前のファイルに対して当該モードを選択する
     ための要素を`auto-mode-alist'に追加する。モードコマンドを自動ロード
     と定義する場合、`autoload'を呼び出している同じファイルにそのような
     要素を追加しておくこと。そうでなければ、モード定義を収めたファイル
     に当該要素を入れるだけで十分である。*Note Auto Major Mode::。

   * 説明文には、ユーザーが個人のファイル`.emacs'に書けるように、
     `autoload'の例、`auto-mode-alist'への追加方法の例を記載すること。

   * モードを定義するファイルのトップレベルのフォームは、それらを複数回
     評価しても不利な結果にならないように書いておくこと。読者が当該ファ
     イルを複数回ロードしなくても、誰かがやるかもしれない。



File: elisp-ja.info, Node: Example Major Modes, Next: Auto Major Mode, Prev: Major Mode Conventions, Up: Major Modes

メジャーモードの例
------------------

基本（fundamental）モードを除くと、テキスト（text）モードはもっとも単純
なモードです。上に述べた慣習の例示として、`text-mode.el'の抜粋をあげてお
きます。

     ;; モード固有の構文テーブルを作る
     (defvar text-mode-syntax-table nil 
       "Syntax table used while in text mode.")

     (if text-mode-syntax-table
         ()              ; 構文テーブルが既存ならば変更しない
       (setq text-mode-syntax-table (make-syntax-table))
       (modify-syntax-entry ?\" ".   " text-mode-syntax-table)
       (modify-syntax-entry ?\\ ".   " text-mode-syntax-table)
       (modify-syntax-entry ?' "w   " text-mode-syntax-table))

     (defvar text-mode-abbrev-table nil
       "Abbrev table used while in text mode.")
     (define-abbrev-table 'text-mode-abbrev-table ())

     (defvar text-mode-map nil)   ; モード固有のキーマップを作る

     (if text-mode-map
         ()              ; キーマップが既存ならば変更しない
       (setq text-mode-map (make-sparse-keymap))
       (define-key text-mode-map "\t" 'indent-relative)
       (define-key text-mode-map "\es" 'center-line)
       (define-key text-mode-map "\eS" 'center-paragraph))

つぎは、テキスト（text）モードのメジャーモード関数の完全な定義です。

     (defun text-mode ()
       "Major mode for editing text intended for humans to read....
      Special commands: \\{text-mode-map}
     Turning on text-mode runs the hook `text-mode-hook'."
       (interactive)
       (kill-all-local-variables)
       (use-local-map text-mode-map)
       (setq local-abbrev-table text-mode-abbrev-table)
       (set-syntax-table text-mode-syntax-table)
       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat "[ \t]*$\\|" page-delimiter))
       (make-local-variable 'paragraph-separate)
       (setq paragraph-separate paragraph-start)
       (setq mode-name "Text")
       (setq major-mode 'text-mode)
       (run-hooks 'text-mode-hook))      ; 最後に、フックによるモードの
                                         ;   カスタマイズをユーザーに許す

3つのlispモード（lispモード、emacs-lispモード、lisp対話モード）には、テ
キスト（text）モードより多くの機能があり、それに応じてコードもより複雑で
す。これらのモードの書き方を例示する`lisp-mode.el'からの抜粋をあげておき
ます。

     ;; モード固有の構文テーブルを作成する
     (defvar lisp-mode-syntax-table nil "")  
     (defvar emacs-lisp-mode-syntax-table nil "")
     (defvar lisp-mode-abbrev-table nil "")

     (if (not emacs-lisp-mode-syntax-table) ; 構文テーブルが既存ならば
                                            ;   変更しない
         (let ((i 0))
           (setq emacs-lisp-mode-syntax-table (make-syntax-table))

           ;; 0までの文字に、単語構成文字ではないが
           ;; シンボル名構成文字であるクラスを設定する
           ;; (文字0は、ASCII文字集合では`48')
           (while (< i ?0) 
             (modify-syntax-entry i "_   " emacs-lisp-mode-syntax-table)
             (setq i (1+ i)))
           ...
           ;; 他の文字の構文を設定する
           (modify-syntax-entry ?  "    " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\t "    " emacs-lisp-mode-syntax-table)
           ...
           (modify-syntax-entry ?\( "()  " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\) ")(  " emacs-lisp-mode-syntax-table)
           ...))
     ;; lispモード向けの略語表を作る
     (define-abbrev-table 'lisp-mode-abbrev-table ())

3つのlispモードは多くのコードを共有しています。つぎの関数はさまざまな変
数に設定します。lispモードの各メジャーモード関数が呼び出します。

     (defun lisp-mode-variables (lisp-syntax)
       (cond (lisp-syntax
     	  (set-syntax-table lisp-mode-syntax-table)))
       (setq local-abbrev-table lisp-mode-abbrev-table)
       ...

`forward-paragraph'などの関数は、変数`paragraph-start'の値を使います。
Lispのコードは普通のテキストとは異なるので、Lispを扱えるように変数
`paragraph-start'を特別に設定する必要があります。また、Lispではコメント
の字下げは特殊な形なので、各lispモードには独自のモード固有の
`comment-indent-function'が必要です。これらの変数に設定するコードが、
`lisp-mode-variables'の残りの部分です。

       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat page-delimiter "\\|$" ))
       (make-local-variable 'paragraph-separate)
       (setq paragraph-separate paragraph-start)
       ...
       (make-local-variable 'comment-indent-function)
       (setq comment-indent-function 'lisp-comment-indent))

各lispモードでは、キーマップが多少異なります。たとえば、lispモードでは
`C-c C-z'を`run-lisp'にバインドしますが、他のlispモードではそうしません。
つぎのコードは、共通するコマンドを設定します。

     (defvar shared-lisp-mode-map ()
       "Keymap for commands shared by all sorts of Lisp modes.")

     (if shared-lisp-mode-map
         ()
        (setq shared-lisp-mode-map (make-sparse-keymap))
        (define-key shared-lisp-mode-map "\e\C-q" 'indent-sexp)
        (define-key shared-lisp-mode-map "\177"
                    'backward-delete-char-untabify))

つぎはlispモード向けのキーマップを設定するコードです。

     (defvar lisp-mode-map ()
       "Keymap for ordinary Lisp mode....")

     (if lisp-mode-map
         ()
       (setq lisp-mode-map (make-sparse-keymap))
       (set-keymap-parent lisp-mode-map shared-lisp-mode-map)
       (define-key lisp-mode-map "\e\C-x" 'lisp-eval-defun)
       (define-key lisp-mode-map "\C-c\C-z" 'run-lisp))

最後に、emacs-lispモードのメジャーモード関数の完全な定義を示します。

     (defun lisp-mode ()
       "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
     Commands:
     Delete converts tabs to spaces as it moves back.
     Blank lines separate paragraphs.  Semicolons start comments.
     \\{lisp-mode-map}
     Note that `run-lisp' may be used either to start an inferior Lisp job
     or to switch back to an existing one.

     Entry to this mode calls the value of `lisp-mode-hook'
     if that value is non-nil."
       (interactive)
       (kill-all-local-variables)
       (use-local-map lisp-mode-map)          ; モードのキーマップを選択する
       (setq major-mode 'lisp-mode)           ; これにより`describe-mode'は
                                              ; 説明文を探し出せる
       (setq mode-name "Lisp")                ; モード行に表示される
       (lisp-mode-variables t)                ; さまざまな変数を定義する
       (setq imenu-case-fold-search t)
       (set-syntax-table lisp-mode-syntax-table)
       (run-hooks 'lisp-mode-hook))           ; フックによるモードの
                                              ; カスタマイズをユーザーに許す



File: elisp-ja.info, Node: Auto Major Mode, Next: Mode Help, Prev: Example Major Modes, Up: Major Modes

メジャーモードの選択方法
------------------------

Emacsは、ファイル名やファイル自体の情報をもとに、当該ファイルを訪問する
ときの新しいバッファに対するメジャーモードを自動的に選択します。また、ファ
イル内のテキストで指定されたローカル変数も処理します。

 -- コマンド: fundamental-mode
     基本（fundamental）モードは、特化してないメジャーモードである。他の
     メジャーモードは、実質的には、このモードとの対比で定義されている。
     つまり、基本（fundamental）モードから始めて、それらのメジャーモード
     ではなにを変更するかを定義している。関数`fundamental-mode'はフック
     を実行*しない*ため、読者はカスタマイズできない。（Emacsの基本
     （fundamental）モードのふるまいを変えたければ、Emacsの*大局的な*状
     態を変える必要がある。）

 -- コマンド: normal-mode &optional FIND-FILE
     この関数は、カレントバッファに対して適切なメジャーモードとバッファ
     ローカルな変数を確立する。この関数はまず`set-auto-mode'を呼び出し、
     続いて、ファイルのローカル変数を必要に応じて解析、束縛、評価するた
     めに`hack-local-variables'を実行する。

     `normal-mode'に対する引数FIND-FILEが`nil'以外であると、
     `normal-mode'は`find-file'から呼び出されたと仮定する。その場合、ファ
     イルの末尾や`-*-'の形式の行にあるローカル変数リストを処理することも
     ある。変数`enable-local-variables'は、この処理を行うかどうかを制御
     する。ファイル内でのローカル変数リストの構文については、*Note ファ
     イルにローカルな変数: (emacs)File Variables。

     読者が対話的に`normal-mode'を実行すると引数FIND-FILEは通常`nil'であ
     る。その場合、`normal-mode'は、ローカル変数リストを無条件に処理する。

     `normal-mode'は、メジャーモード関数を呼び出す周りでは
     `condition-case'を使うので、エラーを補足して`File mode
     specification error'にもとのエラーメッセージを続けてエラーを報告す
     る。

 -- User Option: enable-local-variables
     この変数は、訪問したファイル内のローカル変数リストを処理するかどう
     かを制御する。値`t'は、ローカル変数リストを無条件に処理することを意
     味する。`nil'は、それらを無視することを意味する。それ以外の値である
     と、各ファイルごとにユーザーに問い合わせる。デフォルト値は`t'である。

 -- Variable: ignored-local-variables
     この変数は、ファイルのローカル変数リストで設定してはならない変数の
     リストを保持する。それらの変数に対して指定した値は無視される。

このリストに加えて、属性`risky-local-variable'が`nil'以外の値である変数
も無視されます。

 -- User Option: enable-local-eval
     この変数は、訪問したファイル内のローカル変数リストの`Eval:'を処理す
     るかどうかを制御する。値`t'は、それらを無条件に処理することを意味す
     る。`nil'は、それらを無視することを意味する。それ以外の値であると、
     各ファイルごとにユーザーに問い合わせる。デフォルト値は`maybe'である。

 -- Function: set-auto-mode
     この関数は、カレントバッファに対して適切なメジャーモードを選択する。
     `-*-'行の値、
     （`auto-mode-alist'を使って）訪問したファイルの名前、
     （`interpreter-mode-alist'を使って）`#!'行、
     ファイルのローカル変数リストをもとに決定する。
     しかし、この関数はファイルの末尾付近にある
     ローカル変数`mode:'は調べないが、
     関数`hack-local-variables'は調べる。
     *Note メジャーモードの選択方式: (emacs)Choosing Modes。

 -- User Option: default-major-mode
     この変数は、新たなバッファに対するデフォルトのメジャーモードを保持
     する。標準値は`fundamental-mode'である。

     `default-major-mode'の値が`nil'であると、Emacsは（以前の）カレント
     バッファのメジャーモードを新たなバッファのメジャーモードとする。し
     かし、メジャーモードコマンドのシンボルの属性`mode-class'の値が
     `special'であると、新たなバッファのメジャーモードにはせず、かわりに
     基本（fundamental）モードを使う。この属性を持つモードは、特別に準備
     したテキストに対してのみ有用であるdiredやrmailなどである。

 -- Function: set-buffer-major-mode BUFFER
     この関数はバッファBUFFERのメジャーモードを`default-major-mode'の値
     とする。この変数が`nil'であると、（適切ならば）カレントバッファのメ
     ジャーモードを使う。

     バッファを作成する低レベルの基本関数ではこの関数を使わないが、
     `switch-to-buffer'や`find-file-noselect'などの中レベルのコマンドで
     はバッファを作成するときにこのコマンドを使う。

 -- Variable: initial-major-mode
     この変数の値は、最初のバッファ`*scratch*'のメジャーモードを決定する。
     値は、メジャーモードコマンドのシンボルであること。デフォルト値は、
     `lisp-interaction-mode'である。

 -- Variable: auto-mode-alist
     この変数は、ファイル名のパターン（正規表現、*Note Regular
     Expressions::）と対応するメジャーモードの連想リストを保持する。通常、
     ファイル名パターンでは`.el'や`.c'などの接尾辞を調べるが、そうでなく
     てもよい。連想リストの通常の要素は`(REGEXP . MODE-FUNCTION)'の形で
     ある。

     たとえばつぎのとおり。

          (("\\`/tmp/fol/" . text-mode)
           ("\\.texinfo\\'" . texinfo-mode)
           ("\\.texi\\'" . texinfo-mode)
           ("\\.el\\'" . emacs-lisp-mode)
           ("\\.c\\'" . c-mode) 
           ("\\.h\\'" . c-mode)
           ...)

     展開したファイル名（*Note File Name Expansion::）がREGEXPに一致する
     ファイルを訪問すると、`set-auto-mode'は対応するMODE-FUNCTIONを呼び
     出す。この機能により、Emacsはほとんどのファイルに対して適切なメジャー
     モードを選択する。

     `auto-mode-alist'の要素が`(REGEXP FUNCTION t)'の形であると、
     FUNCTIONを呼び出したあとで、Emacsはファイル名のそれまで一致しなかっ
     た部分について`auto-mode-alist'を再度探索する。この機能は解凍パッケー
     ジには有用である。`("\\.gz\\'" FUNCTION t)'の形の要素で、ファイルを
     解凍し、`.gz'を除いたファイル名に従って解凍済みファイルを適切なモー
     ドにできる。

     `auto-mode-alist'にいくつかのパターン対を追加する方法を示す。（この
     種の式を読者のファイル`.emacs'に使える。）

          (setq auto-mode-alist
            (append 
             ;; ドットで始まる（ディレクトリ名付きの）ファイル名
             '(("/\\.[^/]*\\'" . fundamental-mode)  
               ;; ドットのないファイル名
               ("[^\\./]*\\'" . fundamental-mode)   
               ;; `.C'で終るファイル名
               ("\\.C\\'" . c++-mode))
             auto-mode-alist))

 -- Variable: interpreter-mode-alist
     この変数は、`#!'行でコマンドインタープリタを指定しているスクリプト
     に対して用いるメジャーモードを指定する。この値は、`(INTERPRETER
     . MODE)'の形の要素から成るリストであること。たとえば、デフォルトに
     は`("perl" . perl-mode)'の要素がある。各要素は、ファイルが指定する
     インタープリタがINTERPRETERに一致したらモードMODEを使うことを意味す
     る。INTERPRETERの値は、実際には正規表現である。

     `auto-mode-alist'が使用すべきメジャーモードが指定しなかった場合にの
     みこの変数を使う。

 -- Function: hack-local-variables &optional FORCE
     この関数は、カレントバッファの内容に指定されたローカル変数を必要に
     応じて、解析、束縛、評価する。

     `normal-mode'で述べた`enable-local-variables'の処理は、実際にはここ
     で行う。引数FORCEは、通常、`normal-mode'に与えられた引数FIND-FILEか
     らくる。



File: elisp-ja.info, Node: Mode Help, Next: Derived Modes, Prev: Auto Major Mode, Up: Major Modes

メジャーモードに関するヘルプ
----------------------------

関数`describe-mode'は、メジャーモードに関する情報を得るために使います。
通常、`C-h m'で呼び出されます。関数`describe-mode'は`major-mode'の値を使
いますが、そのために各メジャーモード関数が変数`major-mode'に設定する必要
があるのです。

 -- コマンド: describe-mode
     この関数は、現在のメジャーモードの説明文を表示する。

     関数`describe-mode'は、`major-mode'の値を引数として関数
     `documentation'を呼び出す。そうして、メジャーモード関数の説明文字列
     を表示する。（*Note Accessing Documentation::。）

 -- Variable: major-mode
     この変数は、カレントバッファのメジャーモードに対するシンボルを保持
     する。このシンボルは、当該メジャーモードに切り替えるためのコマンド
     を関数定義として持つこと。関数`describe-mode'は、メジャーモードの説
     明文として当該関数の説明文字列を使う。



File: elisp-ja.info, Node: Derived Modes, Prev: Mode Help, Up: Major Modes

派生モードの定義
----------------

既存のメジャーモードを用いて新たなメジャーモードを定義できると便利です。
これを行う簡単な方法は`define-derived-mode'を使うことです。

 -- Macro: define-derived-mode VARIANT PARENT NAME DOCSTRING BODY...
     これは、NAMEをモード名を表す文字列として使ってVARIANTをメジャーモー
     ドコマンドとして定義する。

     新たなコマンドVARIANTは、関数PARENTを呼び出してから親モードの特定の
     機能を無効にするように定義される。

        * 新たなモードは、`VARIANT-map'という名前の独自のキーマップを持
          つ。`define-derived-mode'は、このキーマップが定義済みでなけれ
          ば、`PARENT-map'から継承するようにこのキーマップを初期化する。

        * 新たなモードでは、変数に`VARIANT-syntax-table'に独自の構文テー
          ブルを保持する。この変数が定義済みでなければ、
          `PARENT-syntax-table'をコピーしてこの変数を初期化する。

        * 新たなモードでは、変数に`VARIANT-abbrev-table'に独自の略語表を
          保持する。この変数が定義済みでなければ、`PARENT-abbrev-table'
          をコピーしてこの変数を初期化する。

        * 新たなモードには独自のモードフック`VARIANT-hook'があり、通常ど
          おり最後にこれを実行する。（新たなモードでは、PARENTを呼び出す
          ことの一部としてPARENTのモードフックも実行する。）

     さらに、BODYでPARENTの他の部分を無効にする方法を指定できる。コマン
     ドVARIANTは、`VARIANT-hook'を呼び出す直前、通常の無効化処理を終えて
     からBODYのフォームを評価する。

     引数DOCSTRINGは、新たなモードに対する説明文字列を指定する。
     DOCSTRINGを省略すると、`define-derived-mode'は説明文字列を生成する。

     仮想的な例を示す。

          (define-derived-mode hypertext-mode
            text-mode "Hypertext"
            "Major mode for hypertext.
          \\{hypertext-mode-map}"
            (setq case-fold-search nil))

          (define-key hypertext-mode-map
            [down-mouse-3] 'do-hyper-link)



