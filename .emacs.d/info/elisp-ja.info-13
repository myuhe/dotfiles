Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Minor Modes, Next: Mode Line Format, Prev: Major Modes, Up: Modes

マイナモード
============

"マイナモード"（minor mode）は、メジャーモードの選択とは独立にユーザーが
オン／オフできる機能を提供します。マイナモードは、個別にも組み合わせても
オンにできます。マイナモードは、長すぎますが『汎用的に使えるオプション機
能のモード』と命名したようがよいかもしれません。

マイナモードは、普通、1つのメジャーモードを変更するだけではありません。
たとえば、自動詰め込みモード（auto-fillモード）は、テキスト挿入を許す任
意のメジャーモードで使えます。汎用的であるためには、マイナモードはメジャー
モードが行うこととは実質的に独立である必要があります。

マイナモードは、メジャーモードに比べて、実装するのがしばしば困難です。1
つの理由は、任意の順でマイナモードをオン／オフできるようにする必要がある
からです。マイナモードは、メジャーモードや他のオンになっているマイナモー
ドとは無関係にその望みの効果を発揮できる必要があります。

しばしば、マイナモードを実装するうえでもっとも大きな問題は、Emacsの残り
の部分に対して必要なフックを探すことです。マイナモードキーマップにより、
従来に比べて簡単になります。

* Menu:

* Minor Mode Conventions::      Tips for writing a minor mode.
* Keymaps and Minor Modes::     How a minor mode can have its own keymap.
* Easy-Mmode::                  A convenient facility for defining minor modes.



File: elisp-ja.info, Node: Minor Mode Conventions, Next: Keymaps and Minor Modes, Prev: Minor Modes, Up: Minor Modes

マイナモードを書くための慣習
----------------------------

メジャーモードに対するのと同じように、マイナモードを書くうえでの慣習があ
ります。メジャーモードの慣習には、マイナモードにも適用されるものがありま
す。つまり、モードを初期化する関数の名前、グローバルシンボルの名前、キー
マップやその他のテーブルや表の使い方です。

それらに加えて、マイナモードに固有な慣習もあります。

   * マイナモードを制御する変数の名前は`-mode'で終ること。これを"モード
     変数"（mode variable）と呼ぶ。マイナモードコマンドは、この変数を
     （オフにするには`nil'、オンにするにはそれ以外に）設定すること。

     可能ならば、変数に設定すると自動的にモードがオン／オフされるように
     モードを実装する。そうすると、マイナモードコマンドは、変数に設定す
     る以外にはなにもしないでよくなる。

     この変数は、モード行にマイナモード名を表示するために
     `minor-mode-alist'でも使われる。マイナモードキーマップを活性にした
     り非活性にしたりもする。各コマンドやフックもこの変数の値を検査する。

     各バッファごとに別々にマイナモードをオンにしたい場合には、この変数
     をバッファローカルにする。

   * モード変数と同じ名前のコマンドを定義する。その仕事は、当該変数に設
     定することでモードをオン／オフすることである。

     当該コマンドは、省略可能な引数を1つ受け取ること。引数が`nil'であれ
     ばモードをトグル（オンであればオフに、オフであればオンに）する。さ
     もなければ、引数が、正整数、`nil'以外のシンボル、`-'、あるいは、CAR
     がそのような整数やシンボルであるようなリストの場合にはモードをオン
     にする。それ以外ではモードをオフにする。

     `transient-mark-mode'の定義から引用した例を示す。モードのふるまいを
     オン／オフする変数としての`transient-mark-mode'の使い方、および、生
     の前置引数に基づいたマイナモードのオン／オフ／トグルの仕方を示す。

          (setq transient-mark-mode
                (if (null arg) (not transient-mark-mode)
                  (> (prefix-numeric-value arg) 0)))

   * モード行にマイナモードを表示したい場合には、各マイナモードについて
     要素を`minor-mode-alist'に追加する（*Note Mode Line Variables::）。
     この要素はつぎの形のリストであること。

          (MODE-VARIABLE STRING)

     ここで、MODE-VARIABLEはマイナモードのオン／オフを制御する変数であり、
     STRINGはモード行でモードを表す短い空白で始まる文字列である。同時に
     複数のモードを表示できるように、これらの文字列は短いこと。

     `minor-mode-alist'に要素を追加するときには、重複を防ぐために既存の
     要素を検査する`assq'を使うこと。たとえばつぎのとおり。

          (or (assq 'leif-mode minor-mode-alist)
              (setq minor-mode-alist
                    (cons '(leif-mode " Leif") minor-mode-alist)))

このリストに要素を1回だけ追加するならば`add-to-list'も使えます（*Note
Setting Variables::）。



File: elisp-ja.info, Node: Keymaps and Minor Modes, Next: Easy-Mmode, Prev: Minor Mode Conventions, Up: Minor Modes

キーマップとマイナモード
------------------------

各マイナモードは、モードがオンのときに活性になる独自のキーマップを持てま
す。マイナモード向けのキーマップを設定するには、`minor-mode-map-alist'に
要素を追加します。*Note Active Keymaps::。

マイナモードキーマップの1つの用途は、ある種の自己挿入文字のふるまいを変
更して、自己挿入に加えてなにかを行わせるようにすることです。一般に、
`self-insert-command'をカスタマイズする機構は（略語モードや自動詰め込み
モード向けに設計された）特別な場合に限られるので、このようなことを行う唯
一の方法です。（標準の`self-insert-command'の定義を読者独自の定義で置き
換えないこと。エディタコマンドループはこの関数を特別扱いしている。）

マイナモードでバインドしているキー列は、`C-c'で始まり、`{'、`}'、`<'、
`>'、`:'、`;'*以外*の句読点文字の1つが続くようにします。（除外した句読点
文字はメジャーモード向けに予約されている。）



File: elisp-ja.info, Node: Easy-Mmode, Prev: Keymaps and Minor Modes, Up: Minor Modes

Easy-Mmode
----------

パッケージeasy-mmodeは、マイナモードを実装する便利な方法を提供します。こ
れを使うと、単純なマイナモードを1つの自己完結した定義に指定できます。

 -- Macro: easy-mmode-define-minor-mode MODE DOC &optional INIT-VALUE MODE-INDICATOR KEYMAP
     このマクロは、MODE（シンボル）という名前の新しいマイナモードを定義
     する。

     このマクロは、マイナモードをトグルするMODEという名前のコマンドを定
     義し、その説明文字列をDOCとする。

     また、MODEという名前の変数も定義する。この変数はモードのオン／オフ
     にしたがって`t'/`nil'に設定される。この変数はINIT-VALUEに初期化され
     る。

     文字列MODE-INDICATORは、モードがオンのときにモード行に表示される文
     字列である。それが`nil'であるとモード行にはモードを表示しない。

     省略可能な引数KEYMAPは、マイナモードのキーマップを指定する。これは、
     値がキーマップであるような変数の名前か、つぎの形のバインディングを
     指定した連想リストであること。

          (KEY-SEQUENCE . DEFINITION)

`easy-mmode-define-minor-mode'を使った例を示します。

     (easy-mmode-define-minor-mode hungry-mode
       "Toggle Hungry mode.
     With no argument, this command toggles the mode. 
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode.

     When Hungry mode is enabled, the control delete key
     gobbles all preceding whitespace except the last.
     See the command \\[hungry-electric-delete]."
      ;; 初期値
      nil
      ;; モード行への表示
      " Hungry"
      ;; マイナモードのバインディング
      '(("\C-\^?" . hungry-electric-delete)
        ("\C-\M-\^?"
         . (lambda () 
             (interactive)
             (hungry-electric-delete t)))))

これは、『hungryモード』という名前のマイナモードを定義します。モードをト
グルするコマンドの名前は`hungry-mode'、モードのオン／オフを表す変数の名
前は`hungry-mode'、モードがオンのときに活性なキーマップを保持する変数の
名前は`hungry-mode-map'です。`C-DEL'と`C-M-DEL'に対するキーバインディン
グでキーマップを初期化します。



File: elisp-ja.info, Node: Mode Line Format, Next: Imenu, Prev: Minor Modes, Up: Modes

モード行の書式
==============

Emacsの（ミニバッファ専用ウィンドウを除く）各ウィンドウにはモード行があっ
て、ウィンドウに表示しているバッファに関する状態情報を表示しています。モー
ド行には、バッファ名、対応するファイル、再帰編集の深さ、メジャーモードと
マイナモードなどのバッファに関する情報が含まれます。

本節では、モード行の内容の制御方法について述べます。モード行に表示される
情報のほとんどはオンになっているメジャーモードとマイナモードに関係するの
で、本章に含めます。

`mode-line-format'は、カレントバッファのモード行に表示する雛型を保持して
いるバッファローカルな変数です。同一バッファに対するすべてのウィンドウは
同じ`mode-line-format'を使い、それらのモード行は（スクロールの割合や行や
コラム位置を除いて）同じように表示されます。

ウィンドウのモード行は、通常、ウィンドウに別のバッファを表示したときや、
バッファの変更状態が`nil'から`t'へあるいはその逆の変化をしたときに更新さ
れます。`mode-line-format'（*Note Mode Line Variables::）が参照する変数
を修正したり、テキストの表示方法に影響するその他の変数やデータ構造
（*Note Display::）を変更したときには、新しい情報を表示したり新たな方法
で表示するためにモード行の更新を強制できます。

 -- Function: force-mode-line-update
     カレントバッファのモード行の更新を強制する。

モード行は、通常、反転表示されます。*Note Inverse Video::の
`mode-line-inverse-video'を参照してください。

* Menu:

* Mode Line Data::        The data structure that controls the mode line.
* Mode Line Variables::   Variables used in that data structure.
* %-Constructs::          Putting information into a mode line.



File: elisp-ja.info, Node: Mode Line Data, Next: Mode Line Variables, Prev: Mode Line Format, Up: Mode Line Format

モード行のデータ構造
--------------------

モード行の内容は、バッファローカルな変数`mode-line-format'に保持されたリ
スト、文字列、シンボル、数から成るデータ構造で制御されます。このデータ構
造を"モード行構成"（mode line construct）と呼びます。これは単純なモード
行構成から再帰的に構築します。同じデータ構造はフレームタイトル（*Note
Frame Titles::）を構築するためにも使われます。

 -- Variable: mode-line-format
     この変数の値は、モード行全体の書式に責任を持つモード行構成である。
     この変数の値は、モード行のテキストを作るためにどの変数を使うか、そ
     れらはモード行のどこに現れるかを制御する。

モード行構成は、定まったテキストの文字列のように単純でもかまいませんが、
普通は、テキストを作るための別の変数の使い方を指定します。それらの変数の
多くはそれ自身、それらの値としてモード行構成を持つように定義されています。

`mode-line-format'のデフォルト値は、`mode-name'や`minor-mode-alist'など
の変数の値を使います。多くの目的には、`mode-line-format'が参照するいくつ
かの変数を変えるだけで十分です。

モード行構成は、リスト、シンボル、文字列のいずれかです。その値がリストで
あれば、その各要素はリスト、シンボル、文字列のいずれかです。

`STRING'
     モード行構成としての文字列は、"`%'記法"を除いて、モード行にそのまま
     表示される。`%'のうしろの10進数は、右側に空白を埋める（つまりデータ
     は左端に揃えられる）ときのフィールド幅を指定する。*Note
     %-Constructs::。

`SYMBOL'
     モード行構成としてのシンボルは、その値を表す。SYMBOLの値は、SYMBOL
     のかわりにモード行構成として使われる。しかし、`t'や`nil'のシンボル、
     および、シンボルの値が空のものは無視する。

     例外が1つある：` ' SYMBOLの値が文字列であると、`%'記法を処理せずに
     文字列をそのまま表示する。

`(STRING REST...) or (LIST REST...)'
     最初の要素が文字列かリストであるリストは、すべての要素を再帰的に処
     理し、結果を連結することを意味する。これはもっとも多用されるモード
     行構成の形である。

`(SYMBOL THEN ELSE)'
     最初の要素がシンボルであるリストは条件節であり、その意味はSYMBOLの
     値に依存する。その値が`nil'以外であると、2番目の要素THENをモード行
     構成として再帰的に処理する。SYMBOLの値が`nil'であると、3番目の要素
     ELSEをモード行構成として再帰的に処理する。ELSEは省略してもよいが、
     その場合、SYMBOLの値が`nil'であるところの要素はモード行に表示されな
     い。

`(WIDTH REST...)'
     最初の要素が整数であるリストは、RESTの結果の切り詰めや引き伸しを指
     定する。残りの要素RESTはモード行構成として再帰的に処理され連結され
     る。（WIDTHが正であれば）結果の右端に空白を追加したり、（WIDTHが負
     であれば）結果を（-WIDTH幅に）右端から切り詰める。

     たとえば、ウィンドウの上端より上にバッファの何割があるかを表示する
     には、`(-3 "%p")'のようなリストを使う。

読者が`mode-line-format'自体を変更するときには、新しい値では、デフォルト
値（*Note Mode Line Variables::）に現れるものと同じ変数を使い、それらの
値をコピーして使ったり、別の書式で情報を表示したりしないでください。こう
しておけば、それらの変数に対する変更を介したユーザーや（`display-time'や
メジャーモードなどの）Lispプログラムが行ったカスタマイズが効果を発揮でき
ます。

ホスト名やデフォルトディレクトリを含んだ`shell-mode'に有用な
`mode-line-format'の例を示します。

     (setq mode-line-format
       (list "-"
        'mode-line-mule-info
        'mode-line-modified
        'mode-line-frame-identification
        "%b--" 
        ;; リストを作るときに評価されることに注意
        ;; 単なる文字列のモード行構成を作る
        (getenv "HOST")
        ":" 
        'default-directory
        "   "
        'global-mode-string
        "   %[("
        'mode-name 
        'mode-line-process  
        'minor-mode-alist 
        "%n" 
        ")%]--"
        '(which-func-mode ("" which-func-format "--"))
        '(line-number-mode "L%l--")
        '(column-number-mode "C%c--")
        '(-3 . "%p")
        "-%-"))

（変数`line-number-mode'、`column-number-mode'、`which-func-mode'は特定
のマイナモードをオンにする。通常どおり、これらの変数の名前はマイナモード
コマンドの名前でもある。）



File: elisp-ja.info, Node: Mode Line Variables, Next: %-Constructs, Prev: Mode Line Data, Up: Mode Line Format

モード行に使われる変数
----------------------

本節では、`mode-line-format'の標準値でモード行のテキストに含められる変数
について述べます。これらの変数に関しては、本来特別なことはありません。別
の変数を使うように`mode-line-format'を変更すれば、別の変数でもモード行に
おいて同じ効果を発揮します。

 -- Variable: mode-line-mule-info
     この変数は、言語環境、バッファのコーディングシステム、現在の入力方
     式に関する情報を表示するモード行構成の値を保持する。*Note Non-ASCII
     Characters::。

 -- Variable: mode-line-modified
     この変数は、カレントバッファが変更されたかどうかを表示するモード行
     構成の値を保持する。

     `mode-line-modified'のデフォルト値は`("%1*%1+")'である。これは、バッ
     ファが変更されていると`**'を、未変更ならば`--'を、読み出し専用なら
     ば`%%'を、読み出し専用でしかも変更されていれば`%*'をモード行に表示
     することを意味する。

     この変数を変更してもモード行の更新を強制しない。

 -- Variable: mode-line-frame-identification
     この変数はカレントフレームを識別する。複数のフレームを表示できるウィ
     ンドウシステムを使用している場合にはデフォルト値は`" "'であり、ある
     時点で1つのフレームしか表示できない普通の端末を使用している場合には
     `"-%F "'である。

 -- Variable: mode-line-buffer-identification
     この変数はウィンドウに表示しているバッファを識別する。デフォルト値
     は`("%12b")'であり、空白で埋めて最低12コラムでバッファ名を表示する。

 -- Variable: global-mode-string
     この変数は、デフォルトでモード行のバッファ名の直後に現れるモード行
     指定を保持する。コマンド`display-time'は、`global-mode-string'が時
     刻と負荷情報を含んだ変数`display-time-string'を参照するように設定す
     る。

     `%M'記法は`global-mode-string'の値を使うが、この変数は
     `mode-line-format'でモード行に含まれるため`%M'は廃れた記法である。

 -- Variable: mode-name
     このバッファローカルな変数は、カレントバッファのメジャーモードの
     『愛称』を保持する。各メジャーモードは、モード行にモード名が現れる
     ようにこの変数に設定すること。

 -- Variable: minor-mode-alist
     この変数は、モード行にマイナモードがオンであることを表示する方法を
     指定する要素からなる連想リストを保持する。`minor-mode-alist'の各要
     素は、2要素リストであること。

          (MINOR-MODE-VARIABLE MODE-LINE-STRING)

     より一般的には、MODE-LINE-STRINGはどのようなモード行指定でもよい。
     それは、MINOR-MODE-VARIABLEの値が`nil'以外のときにモード行に現れ、
     さもなければ現れない。これらの文字列は、繋がらないように空白で始ま
     ること。慣習的には、特定モードに対するMINOR-MODE-VARIABLEは、当該マ
     イナモードがオンであると`nil'以外に設定される。

     `minor-mode-alist'のデフォルト値はつぎのとおり。

          minor-mode-alist
          => ((vc-mode vc-mode)
              (abbrev-mode " Abbrev") 
              (overwrite-mode overwrite-mode) 
              (auto-fill-function " Fill")         
              (defining-kbd-macro " Def")
              (isearch-mode isearch-mode))

     `minor-mode-alist'自体はバッファローカルではない。マイナモードが各
     バッファごとにオンにできる場合には、連想リストに指定した対応する各
     変数はバッファローカルであること。

 -- Variable: mode-line-process
     このバッファローカルな変数は、サブプロセスとの通信用に使われている
     モードの処理状態に関するモード行の情報を保持する。メジャーモード名
     の直後に空白で区切らずに表示される。たとえば、バッファ`*shell*'にお
     けるこの変数の値は`(":%s")'であり、シェルがその状態をメジャーモード
     とともに`(Shell: run)'のように表示できる。通常、この変数は`nil'であ
     る。

 -- Variable: default-mode-line-format
     この変数は、`mode-line-format'を変更していないバッファのデフォルト
     の`mode-line-format'の値を保持する。これは`(default-value
     'mode-line-format)'と同じである。

     `default-mode-line-format'のデフォルト値はつぎのリストである。

          ("-"
           mode-line-mule-info
           mode-line-modified
           mode-line-frame-identification
           mode-line-buffer-identification
           "   "
           global-mode-string
           "   %[("
           mode-name 
           mode-line-process
           minor-mode-alist 
           "%n" 
           ")%]--"
           (which-func-mode ("" which-func-format "--"))
           (line-number-mode "L%l--")
           (column-number-mode "C%c--")
           (-3 . "%p")
           "-%-")

 -- Variable: vc-mode
     各バッファにおいてバッファローカルな変数`vc-mode'は、バッファで訪問
     したファイルが版管理されているか、そうならばその方式を記録している。
     版管理されていない場合はその値は`nil'、さもなければモード行に表示さ
     れる文字列である。



File: elisp-ja.info, Node: %-Constructs, Prev: Mode Line Variables, Up: Mode Line Format

モード行の`%'記法
-----------------

以下は、認識される`%'記法とその意味の表です。`%%'以外の記法では、最大表
示文字数を指定する10進数を`%'のあとに追加できます。

`%b'
     関数`buffer-name'で得られたカレントバッファ名。*Note Buffer Names::。

`%f'
     関数`buffer-file-name'で得られた訪問したファイルの名前。*Note
     Buffer File Name::。

`%F'
     選択しているフレームのタイトル（ウィンドウシステム上のみ）か名前。
     *Note Window Frame Parameters::。

`%c'
     ポイントの現在のコラム番号。

`%l'
     ポイントの現在の行番号。

`%*'
     バッファが読み出し専用であれば`%'（`buffer-read-only'を参照）、
     バッファが変更されていれば`*'（`buffer-modified-p'を参照）、
     さもなければ`-'。
     *Note Buffer Modification::。

`%+'
     バッファが変更されていれば`*'（`buffer-modified-p'を参照）、
     バッファが読み出し専用であれば`%'（`buffer-read-only'を参照）、
     さもなければ`-'。
     `%*'との違いは、変更された読み出し専用バッファに対してのみである。
     *Note Buffer Modification::。

`%&'
     バッファが変更されていれば`*'、さもなければ`-'である。

`%s'
     `process-status'で得たカレントバッファに属するサブプロセスの状態。
     *Note Process Information::。

`%t'
     訪問したファイルがテキストファイルであるかバイナリファイルであるか
     を表す。（特定のオペレーティングシステムでのみ意味を持つ。）

`%p'
     ウィンドウの*上端*の上にあるバッファのテキストの割合、あるいは、
     `Top'、`Bottom'、`All'のいずれかである。

`%P'
     ウィンドウの*下端*の上にあるバッファのテキスト（ウィンドウに見えて
     るテキストと上端の上にあるテキスト）の割合にバッファの先頭が見えて
     いれば`Top'を加えたもの、あるいは、`Bottom'、`All'のいずれかである。

`%n'
     ナロイングしていると`Narrow'、さもなければなにもなし。（*Note
     Narrowing::の`narrow-to-region'を参照）。

`%['
     （ミニバッファのレベルを除く）再帰編集レベルの深さを表す。各編集レ
     ベルごとに1つの`['。*Note Recursive Editing::。

`%]'
     （ミニバッファのレベルを除く）各再帰編集レベルごとに1つの`]'。

`%%'
     文字`%'。`%'記法を許す文字列に`%'をそのまま含めるための方法である。

`%-'
     モード行の残り部分を埋めるに十分な個数のダッシュ。

つぎの2つの`%'記法はまだ使えますが、変数`mode-name'や
`global-mode-string'を使って同じ効果を得られるのでこれらは廃れた記法です。

`%m'
     `mode-name'の値。

`%M'
     `global-mode-string'の値。現在、`display-time'は
     `global-mode-string'の値を変更する。



File: elisp-ja.info, Node: Imenu, Next: Font Lock Mode, Prev: Mode Line Format, Up: Modes

iメニュー
=========

"iメニュー"（Imenu）とは、ユーザーがバッファ内の定義や節の一覧からその1
つを選ぶとバッファ内の当該箇所へ直接移動できる機能です。iメニューは、バッ
ファ内の定義や部分の名前や位置を表すバッファインデックスを構築しておくこ
とで動作し、当該箇所へ移動するためにユーザーがそれらの1つを選べるように
します。本節ではメジャーモードに対するiメニューをカスタマイズする方法を
説明します。

普通のもっとも単純な方法は、変数`imenu-generic-expression'に設定すること
です。

 -- Variable: imenu-generic-expression
     この変数が`nil'以外であると、iメニュー向けの定義を探すための正規表
     現を指定する。もっとも単純な場合、要素はつぎのような形である。

          (MENU-TITLE REGEXP SUBEXP)

     ここで、MENU-TITLEが`nil'以外であると、この要素に一致したものはバッ
     ファインデックスのサブメニューに置くことを意味する。MENU-TITLE自体
     はサブメニューの名前を指定する。MENU-TITLEが`nil'であると、この要素
     に一致したものはバッファインデックスのメニューに直接置かれる。

     リストの2番目の要素REGEXPは正規表現（*Note Regular Expressions::）
     であり、これに一致した箇所がバッファインデックスに現れる定義になる。
     3番目の要素SUBEXPは、定義の名前に一致するREGEXPの部分式である。

     要素はつぎの形でもよい。

          (MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS...)

     この要素に一致するものは、バッファインデックスの特別な項目になり、
     ユーザーが当該項目を選ぶと、ITEM-NAME、バッファ位置、ARGUMENTSを引
     数としてFUNCTIONを呼び出す。

     emacs-lispモード向けには、PATTERNはつぎのようになる。

          ((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Types*"
            "^\\s-*\
          (def\\(type\\|struct\\|class\\|ine-condition\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2))

     この変数に設定すると、カレントバッファにおいてバッファローカルな変
     数になる。

 -- Variable: imenu-case-fold-search
     この変数は、IMENU-GENERIC-EXPRESSIONとの一致に際して大文字小文字を
     区別するかどうかを制御する。デフォルトは`t'であり、大文字小文字を区
     別せずに一致をとる。

     この変数に設定すると、カレントバッファにおいてバッファローカルな変
     数になる。

 -- Variable: imenu-syntax-alist
     この変数は、`imenu-generic-expression'を処理中にカレントバッファの
     構文テーブルに優先する構文テーブルの変更部分の連想リストである。各
     要素はつぎの形であること。

          (CHARACTERS . SYNTAX-DESCRIPTION)

     CARのCHARACTERSは、文字か文字列である。それらの文字は、指定した構文
     SYNTAX-DESCRIPTIONであることを意味する。これは`modify-syntax-entry'
     （*Note Syntax Table Functions::）に渡される。

     この機能は典型的には、通常のシンボル構成文字を単語構成文字として扱
     い、`imenu-generic-expression'を単純化し一致処理を速くする。たとえ
     ば、fortranモードではつぎのように使っている。

            (setq imenu-syntax-alist '(("_$" . "w")))

     こうすると、`imenu-generic-expression'のパターンでは、
     `\\(\\sw\\|\\s_\\)+'のかわりに`\\sw+'を使える。この技法は、名前の先
     頭文字の集合を名前の残りの文字の集合よりも小さく制限する必要がある
     モードで使うには不便であることに注意してほしい。

     この変数に設定すると、カレントバッファにおいてバッファローカルな変
     数になる。

メジャーモードのiメニューをカスタマイズする別の方法は、変数
`imenu-prev-index-position-function'や
`imenu-extract-index-name-function'に設定することです。

 -- Variable: imenu-prev-index-position-function
     この変数が`nil'以外であると、その値は、バッファインデックスに置くつ
     ぎの定義をファイルで後向きに探すための関数であること。

     その関数は、バッファインデックスの項目に対応する箇所にポイントを置
     くこと。項目がみつからなければ`nil'を返すこと。

     この変数に設定すると、カレントバッファにおいてバッファローカルな変
     数になる。

 -- Variable: imenu-extract-index-name-function
     この関数が`nil'以外であると、その値は、ポイントが変数
     `imenu-prev-index-position-function'が返した定義の部分にあると仮定
     して、当該定義の名前を返す関数であること。

     この変数に設定すると、カレントバッファにおいてバッファローカルな変
     数になる。

メジャーモードのiメニューをカスタマイズする最後の方法は、変数
`imenu-create-index-function'に設定することです。

 -- Variable: imenu-create-index-function
     この関数は、バッファインデックスの作成に使う関数を指定する。その関
     数は引数なしで、カレントバッファに対するインデックスを返すこと。
     `save-excursion'の内側から呼ばれるので、その関数がポイントをどこに
     置こうと関係ない。

     デフォルト値は、インデックスの連想リストを生成するために
     `imenu-generic-expression'を使う関数である。読者が別の関数を指定す
     れば、`imenu-generic-expression'は使われない。

     この変数に設定すると、カレントバッファにおいてバッファローカルな変
     数になる。

 -- Variable: imenu-index-alist
     この変数は、カレントバッファに対するインデックスの連想リストを保持
     する。この変数に設定すると、カレントバッファにおいてバッファローカ
     ルな変数になる。

     連想リストの単純な要素は`(INDEX-NAME . INDEX-POSITION)' のような形
     である。このような単純な要素を選ぶと、バッファ内でINDEX-POSITIONへ
     移動する効果がある。

     特別な要素は`(INDEX-NAME POSITION FUNCTION ARGUMENTS...)'のような形
     である。このような特別な要素を選ぶと、つぎのようなフォームを実行す
     る。

          (funcall FUNCTION INDEX-NAME POSITION ARGUMENTS...)

     入れ子になった部分連想リストの要素は`(INDEX-NAME SUB-ALIST)'のよう
     な形である。



File: elisp-ja.info, Node: Font Lock Mode, Next: Hooks, Prev: Imenu, Up: Modes

フォントロック（font-lock）モード
=================================

"フォントロック（font-lock）モード"とは、バッファ内の特定部分に対して、
それらの構文上の役割に応じた属性`face'を自動的に付加する機能のことです。
バッファを解析する方法はメジャーモードに依存しますが、ほとんどのメジャー
モードでは、どの文脈でどのフェイスを使うかを指示する条件を定義します。本
節では、特定の言語向けに、いいかえれば、特定のメジャーモード向けにフォン
トロックをカスタマイズする方法を説明します。

フォントロック（font-lock）モードは、強調表示すべきテキストを2つの方法で、
つまり、構文テーブルに基づいた構文解析、あるいは、（通常、正規表現による）
探索で探します。構文解析による処理を最初に行ってコメントや文字列定数を探
し、`font-lock-comment-face'や`font-lock-string-face' （*Note Faces for
Font Lock::）を使ってそれらを強調表示します。探索による処理がこれに続き
ます。

* Menu:

* Font Lock Basics::
* Search-based Fontification::
* Other Font Lock Variables::
* Levels of Font Lock::
* Faces for Font Lock::
* Syntactic Font Lock::



File: elisp-ja.info, Node: Font Lock Basics, Next: Search-based Fontification, Prev: Font Lock Mode, Up: Font Lock Mode

フォントロック（font-lock）の基本
---------------------------------

フォントロック（font-lock）モードがテキストを強調表示する方法を制御する
変数がいくつかあります。しかし、メジャーモードでこれらの変数を直接に設定
するべきではありません。そのかわりに、バッファローカルな変数
`font-lock-defaults'に設定すべきです。フォントロック（font-lock）モード
がオンになると、この変数に設定された値を使って他のすべての変数に設定しま
す。

 -- Variable: font-lock-defaults
     この変数はメジャーモードがバッファローカルな変数として設定し、当該
     モードにおいてテキストをどのように表示するかを指定する。値はつぎの
     形であること。

          (KEYWORDS KEYWORDS-ONLY CASE-FOLD
           SYNTAX-ALIST SYNTAX-BEGIN OTHER-VARS...)

     最初の要素KEYWORDSは、間接的に`font-lock-keywords'の値を指定する。
     要素KEYWORDSがシンボルであると、その変数としての値が
     `font-lock-keywords'に使われる。あるいは、要素KEYWORDSがそのような
     シンボルのリストであると、各シンボルが1つのレベルの表示方法を指定す
     る。最初のシンボルはレベル1の表示方法、2番目のシンボルはレベル2の表
     示方法といった具合である。

     2番目の要素KEYWORDS-ONLYは、変数`font-lock-keywords-only'の値を指定
     する。これが`nil'以外であると（文字列やコメントの）構文による処理を
     行わない。

     3番目の要素CASE-FOLDは、`font-lock-case-fold-search'の値を指定する。
     これが`nil'以外であると、フォントロック（font-lock）モードは
     `font-lock-keywords'で指定された探索で大文字小文字を区別しない。

     4番目の要素SYNTAX-ALISTが`nil'以外である場合、それは
     `(CHAR-OR-STRING . STRING)'の形のコンスセルのリストであること。これ
     らは表示方法を選ぶための構文テーブルの設定に使われる（*Note Syntax
     Table Functions::）。得られた構文テーブルは`font-lock-syntax-table'
     に保持される。

     5番目の要素SYNTAX-BEGINは、`font-lock-beginning-of-syntax-function'
     の値を指定する（下記参照）。

     OTHER-VARS以降の要素は、`(VARIABLE . VALUE)'という形である。この種
     の要素は、表示方法の選択に影響するその他の変数に設定するために使わ
     れる。



File: elisp-ja.info, Node: Search-based Fontification, Next: Other Font Lock Variables, Prev: Font Lock Basics, Up: Font Lock Mode

探索に基づくフォント選択
------------------------

フォントロック（font-lock）モードのカスタマイズにおいてもっとも重要な変
数は`font-lock-keywords'です。探索に基づく表示方法の選択における探索条件
を指定します。

 -- Variable: font-lock-keywords
     この変数の値は、強調表示するべきキーワードのリストである。このリス
     トに正規表現を書く場合には注意すること。貧弱な書き方をしたパターン
     であると、動作を劇的に遅くする！

`font-lock-keywords'の各要素は、特定のテキストの探し方と当該テキストをど
のように強調表示するか指定します。フォントロック（font-lock）モードは、
`font-lock-keywords'の要素を1つ1つ処理し、各要素において、それに一致する
ものすべてを探して処理します。通常、すでに表示方法を選択済みのテキスト部
分については、それ以降の要素に一致しても表示方法を変えません。しかし、
HIGHLIGHTERの要素OVERRIDEを使って、異なるふるまいを指定できます。

`font-lock-keywords'の各要素はつぎのいずれかの形です。

`REGEXP'
     正規表現REGEXPに一致したものはすべて`font-lock-keyword-face'を使っ
     て強調表示する。

          ;; 孤立した`foo'の出現は
          ;; `font-lock-keyword-face'で強調表示する。
          "\\<foo\\>"

     関数`regexp-opt'（*Note Syntax of Regexps::）は、異なる複数個のキー
     ワードに一致する最適な正規表現を計算するのに有用である。

`FUNCTION'
     関数FUNCTIONを呼び出してテキストを探し、それが探し出したものを
     `font-lock-keyword-face'を使って強調表示する。

     FUNCTIONは、探索限界を引数として呼び出される。みつかれば`nil'以外を
     返すとともにみつけた部分を表すマッチデータを設定する。

`(MATCHER . MATCH)'
     この種の要素では、MATCHERは、上に述べた正規表現か関数を表す。CDRの
     MATCHは、（MATCHERに一致した部分全体のかわりに）強調表示すべき
     MATCHERの部分式を指定する。

          ;; `fubar'の各出現の`bar'を
          ;; `font-lock-keyword-face'で強調表示
          ("fu\\(bar\\)" . 1)

     正規表現MATCHERを作るために`regexp-opt'を使った場合、MATCHの値を計
     算するには`regexp-opt-depth'（*Note Syntax of Regexps::）を使える。

`(MATCHER . FACENAME)'
     この種の要素では、FACENAMEは、強調表示に使うフェイス名を指定する値
     を表す式である。

          ;; `fubar'の出現は、`fubar-face'の値で
          ;; 表されたフェイスを使って強調表示
          ("fubar" . fubar-face)

`(MATCHER . HIGHLIGHTER)'
     この種の要素では、HIGHLIGHTERは、MATCHERに一致した部分の強調表示方
     法を指定するリストである。つぎの形であること。

          (SUBEXP FACENAME OVERRIDE LAXMATCH)

     CARのSUBEXPは、強調表示すべき一致部分の部分式を指定する整数（0は一
     致部分全体を意味する）である。2番目の要素FACENAMEは、上に述べたよう
     にフェイスを指定する。

     HIGHLIGHTERの最後の2つの要素、OVERRIDEとLAXMATCHはフラグである。
     OVERRIDEが`t'であると、当該要素は、`font-lock-keywords'のまえの要素
     で決定済みの表示方法に優先することを表す。`keep'であると、他の要素
     では表示方法が決定していない各文字の表示方法を表す。`prepend'である
     と、属性`face'の先頭にフェイスFACENAMEを追加する。`append'であると、
     属性`face'の末尾にフェイスFACENAMEを追加する。

     LAXMATCHが`nil'以外であると、MATCHERで一致したものの中にSUBEXP番目
     の部分式がなくてもエラーとしないことを意味する。

     この種の要素とその動作の例を示す。

          ;; `foo'や`bar'の出現の表示方法がすでに決まっていても
          ;; `foo-bar-face'で強調表示する
          ;; `foo-bar-face'の値はフェイスであること
          ("foo\\|bar" 0 foo-bar-face t)

          ;; 関数`fubar-match'がみつけた各出現内の最初の部分式を
          ;; `fubar-face'の値が表すフェイスで強調表示する
          (fubar-match 1 fubar-face)

`(MATCHER HIGHLIGHTERS...)'
     この種の要素は、1つのMATCHERに対して複数のリストHIGHLIGHTERを指定す
     る。これが有用であるためには、各HIGHLIGHTERでSUBEXPの値が異なること。
     つまり、それぞれをMATCHERの異なる部分式に適用できること。


`(eval . FORM)'
     FORMは、バッファにおいて`font-lock-keywords'のこの値が始めて使われ
     たときに評価すべき式である。その値は、この表にあげた形の1つであるこ
     と。

*警告：*` ' `font-lock-keywords'の要素は、行をまたがって一致するように設
計しないこと。そのような処理は信頼性がない。`font-lock-fontify-buffer'は、
行にまたがるパターンを正しく扱えるが、読者がバッファを編集したときの更新
処理では、一度に1行ずつ処理するために正しく扱えない。



File: elisp-ja.info, Node: Other Font Lock Variables, Next: Levels of Font Lock, Prev: Search-based Fontification, Up: Font Lock Mode

その他のフォントロック変数
--------------------------

本節では、`font-lock-defaults'を用いてメジャーモードで設定できる他の変数
について述べます。

 -- Variable: font-lock-keywords-only
     `nil'以外であると、フォントロック（font-lock）モードは、構文に基づ
     いてコメントや文字列を強調表示すべきでないことを意味する。
     `font-lock-keywords'に基づく強調表示のみを行う。


 -- Variable: font-lock-keywords-case-fold-search
     `nil'以外であると、`font-lock-keywords'の正規表現探索では大文字小文
     字を区別しないことを意味する。

 -- Variable: font-lock-syntax-table
     この変数は、コメントや文字列の表示方法に用いる構文テーブルを指定す
     る。

 -- Variable: font-lock-beginning-of-syntax-function
     この変数が`nil'以外であると、ポイントを構文上の『トップレベル』で文
     字列やコメントの外側に後方移動する関数であること。フォントロック
     （font-lock）モードは、構文に基づく処理において正しい結果を得るため
     に必要に応じてこの関数を使う。

     関数は引数なしで呼び出される。ポイントを構文ブロックの先頭に置くこ
     と。典型的な値は、`beginning-of-line'（行頭は構文ブロックの外側であ
     る）、あるいは、プログラム向けのモードでは`beginning-of-defun'、テ
     キスト向けのモードでは`backward-paragraph' （モード固有の関数は構文
     ブロックの外側にポイントを移動する）である。

     値が`nil'であると、バッファの先頭を構文ブロックの外側の位置として使
     う。これは誤りではないが、動作を遅くする。

 -- Variable: font-lock-mark-block-function
     この変数が`nil'以外であると、コマンド`M-g M-g'
     （`font-lock-fontify-block'）による再表示のためにテキストの括られた
     範囲を選ぶために引数なしで呼ばれ関数であること。

     関数は、選んだ範囲にリージョンを設定すること。正しい結果を得られる
     ように大きめのテキスト範囲を選ぶのがよいが、再表示処理が遅くならな
     いように大きすぎないこと。典型的な値は、プログラム向けモードでは
     `mark-defun'、テキスト向けモードでは`mark-paragraph'である。



File: elisp-ja.info, Node: Levels of Font Lock, Next: Faces for Font Lock, Prev: Other Font Lock Variables, Up: Font Lock Mode

フォントロックのレベル
----------------------

多くのメジャーモードでは、3段階の表示方法を提供します。
`font-lock-defaults'のKEYWORDSにシンボルのリストを使って複数レベルを定義
できます。各シンボルは1つのレベルの表示方法を指定します。どのレベルを選
ぶかはユーザーの責任です。指定したレベルのシンボルの値は
`font-lock-keywords'の初期化に使われます。

表示方法のレベルを定義する際の慣習をあげておきます。

   * レベル1：` ' 関数宣言、（includeやimportなどの）ファイル指定、文字
     列、コメントを強調表示する。速さが肝心であり、重要な構文やトップレ
     ベルの構成要素のみを強調表示する。

   * レベル2：` ' レベル1に加えて、キーワードのようにふるまう型名を含む
     当該言語のすべてのキーワード、名前付き定数。（構文的な、あるいは、
     意味的な）すべてのキーワードを適切に強調表示するのが目的。

   * レベル3：` ' レベル2に加えて、関数や変数宣言で定義されたシンボル、
     適切なすべての組み込み関数の名前。



File: elisp-ja.info, Node: Faces for Font Lock, Next: Syntactic Font Lock, Prev: Levels of Font Lock, Up: Font Lock Mode

フォントロックのフェイス
------------------------

フォントロック（font-lock）モードでは任意のフェイスを使えますが、フォン
トロック（font-lock）モード向けに特別に定義さたフェイスがあります。これ
らのシンボルのおのおのは、フェイス名でもあり、シンボル自身をデフォルト値
とする変数でもあります。つまり、`font-lock-comment-face'のデフォルト値は、
`font-lock-comment-face'です。これは、フェイス名を値に持つような式を書く
`font-lock-keywords'などの場面で、`font-lock-comment-face'と書けることを
意味します。

`font-lock-comment-face'
     （典型的には）コメントに使われる。

`font-lock-string-face'
     （典型的には）文字列に使われる。

`font-lock-keyword-face'
     （典型的には）キーワード、つまり、Cの`for'や`if'のように構文的に重
     要な名前に使われる。

`font-lock-builtin-face'
     （典型的には）組み込み関数の名前に使われる。

`font-lock-function-name-face'
     （典型的には）関数定義／宣言内において、定義／宣言されている関数の
     名前に使われる。

`font-lock-variable-name-face'
     （典型的には）変数定義／宣言内において、定義／宣言されている変数の
     名前に使われる。

`font-lock-type-face'
     （典型的には）ユーザー定義のデータ型の名前が定義／参照される場所に
     おいて、それらの名前に使われる。

`font-lock-constant-face'
     （典型的には）定数の名前に使われる。

`font-lock-warning-face'
     （典型的には）独特な構文や別のテキストの意味を大きく変えるようなも
     のに使われる。たとえば、Emacs Lispの`;;;###autoload'やCの`#error'指
     定に使われる。



File: elisp-ja.info, Node: Syntactic Font Lock, Prev: Faces for Font Lock, Up: Font Lock Mode

構文的なフォントロック
----------------------

フォントロック（font-lock）モードは、属性`syntax-table'を自動更新するた
めにも使えます。1つの構文テーブルだけでは十分でないような言語において有
用です。

 -- Variable: font-lock-syntactic-keywords
     この変数は構文的なフォントロックをオンにし制御する。その値はつぎの
     形の要素からなるリストであること。

          (MATCHER SUBEXP SYNTAX OVERRIDE LAXMATCH)

     この要素の各部分には、つぎの`font-lock-keywords'の対応する種類の要
     素と同じ意味がある。

          (MATCHER SUBEXP FACENAME OVERRIDE LAXMATCH)

     しかし、属性`face'に使う値FACENAMEを指定するかわりに、属性
     `syntax-table'に使う値SYNTAXを指定する。ここで、SYNTAXは、構文テー
     ブルを値とする変数、`(SYNTAX-CODE . MATCHING-CHAR)'の形の構文テーブ
     ルの項目、あるいは、この2種類のどちらかを値とする式である。



File: elisp-ja.info, Node: Hooks, Prev: Font Lock Mode, Up: Modes

フック
======

"フック"（hook）とは、既存のプログラムから特定の場面で呼び出される（1つ
か一連の）関数を収めた変数です。Emacsは、カスタマイズのためにフックを用
意しています。ほとんどの場合、フックはファイル`.emacs'で設定しますが、
Lispプログラムが行ってもかまいません。標準のフック関数一覧については、
*Note Standard Hooks::。

Emacsの多くのフックは"ノーマルフック"（normal hook）です。これらの変数は、
引数なしで呼び出される関数のリストを保持しています。フック名が`-hook'で
終っていると、ノーマルフックを意味します。読者がそれらを単一の方法で使え
るように、可能な限りノーマルフックにするように心掛けています。

各メジャーモード関数は、その初期化の最終段階で"モードフック"（mode hook）
と呼ばれるノーマルフックを実行すると期待されます。これにより、モードがす
でに設定したバッファローカルな変数を上書きすることで、ユーザーがモードの
ふるまいをカスタマイズしやすくしています。しかし、フックは別の場面でも使
われています。たとえば、フック`suspend-hook'は、Emacsが自身を一時休止す
る直前に実行されます。（*Note Suspending Emacs::）。

ノーマルフックにフック関数を追加する推奨方法は、`add-hook'（下記参照）を
呼ぶことです。フック関数は、`funcall'（*Note What Is a Function::）が受
け付けるならばどんな種類の関数でもかまいません。ほとんどのノーマルフック
変数は最初は空ですが、`add-hook'はその扱い方を知っています。

フック変数の名前が`-hook'で終らない場合、それが"アブノーマルフック"
（abnormal hook）であることを表します。読者は、そのようなフックの正しい
使い方を説明書で調べるべきです。

変数名が`-functions'や`-hooks'で終っていると、その値は関数のリストですが、
それらの関数を引数ありで呼び出したり、関数の戻り値をどこかで使うという意
味でアブノーマル（異常）なのです。リストに関数を追加するには`add-hook'を
使えますが、関数を書くときには注意する必要があります。（これらの変数のう
ち、実際にはノーマルフックであるものもある。ノーマルフックには`-hook'を
使うという慣習を確立するまえに命名したものである。）

変数名が`-function'で終っていると、その値は、関数のリストではなく、1つの
関数です。

lisp対話モードで自動詰め込み（auto-fill）モードをオンにするためにモード
フックを使った例を示します。

     (add-hook 'lisp-interaction-mode-hook 'turn-on-auto-fill)

適当な時期に、Emacsは関数`run-hooks'を使って特定のフックを実行します。こ
の関数は、`add-hook'で追加されたフック関数を呼び出します。

 -- Function: run-hooks &rest HOOKVAR
     この関数は複数個のフック変数名を引数にとり、各フックを順に実行する。
     各引数HOOKVARは、フック変数のシンボルであること。これらの引数は、指
     定された順に処理される。

     フック変数が`nil'以外の値であると、その値は、関数か関数のリストであ
     る。値が関数（ラムダ式や関数定義を持つシンボル）であると、それを呼
     び出す。値がリストであると、順番にその要素を呼び出す。フック関数は、
     引数なしで呼び出される。現在、フック変数に1つの関数を入れることは廃
     れかけている。つねに関数のリストを使うべきである。

     例として、`emacs-lisp-mode'がそのモードフックをどのように実行するか
     を示す。

          (run-hooks 'emacs-lisp-mode-hook)

 -- Function: run-hook-with-args HOOK &rest ARGS
     この関数は、フック関数に引数を渡すアブノーマルフックを実行する方法
     である。各フック関数に引数ARGSを渡して呼び出す。

 -- Function: run-hook-with-args-until-failure HOOK &rest ARGS
     この関数は、フック関数に引数を渡すアブノーマルフックを実行するが、
     フック関数が失敗するとただちに止める方法である。フック関数が`nil'を
     返すまで、各フック関数に引数ARGSを渡して呼び出す。`nil'が返ってくる
     と`nil'で戻る。さもなければ、`nil'以外の値を返す。

 -- Function: run-hook-with-args-until-success HOOK &rest ARGS
     この関数は、フック関数に引数を渡すアブノーマルフックを実行するが、
     フック関数が成功するとただちに止める方法である。フック関数が`nil'以
     外を返すまで、各フック関数に引数ARGSを渡して呼び出す。`nil'以外が返っ
     てくると最後に呼び出したフック関数の戻り値を返す。

 -- Function: add-hook HOOK FUNCTION &optional APPEND LOCAL
     この関数はフック変数HOOKに関数FUNCTIONを追加する手軽な方法である。
     引数FUNCTIONは、正しい個数の引数をとる任意の正しいLisp関数であるこ
     と。たとえば、

          (add-hook 'text-mode-hook 'my-text-hook-function)

     は、`text-mode-hook'というフックに`my-text-hook-function'を追加する。

     `add-hook'は、ノーマルフックに加えてアブノーマルフックにも使える。

     フック関数は実行順序に依存しないように設計するのが最良である。実行
     順序に依存すると『トラブルを呼び込む』ようなものである。しかし、順
     序は予測できる。通常、FUNCTIONはフックリストの先頭に置かれるので、
     （ほかに`add-hook'の呼び出しがなければ）最初に実行される。省略可能
     な引数APPENDが`nil'以外であると、新たなフック関数はフックリストの末
     尾に置かれ、最後に実行される。

     LOCALが`nil'以外であると、新たなフック関数をカレントバッファにバッ
     ファローカルにすることを意味する。これを行うまえに、
     （`make-local-variable'*ではなく*）`make-local-hook'を呼んでフック
     自身をバッファローカルにしておく必要がある。フック自身がバッファロー
     カルでないと、LOCALの値は意味を持たない。フック関数はつねにグローバ
     ルである。

 -- Function: remove-hook HOOK FUNCTION &optional LOCAL
     この関数は、フック変数HOOKからFUNCTIONを取り除く。

     LOCALが`nil'以外であると、グローバルなフックリストではなくバッファ
     ローカルなフックリストからFUNCTIONを削除することを指定する。フック
     変数自身がバッファローカルでないと、LOCALの値は意味を持たない。

 -- Function: make-local-hook HOOK
     この関数は、フック変数`hook'をカレントバッファにバッファローカルに
     する。フック変数がバッファローカルであると、バッファローカルなフッ
     ク関数とグローバルなフック関数を持つことができ、`run-hooks'はそれら
     すべてを実行する。

     この関数は、バッファローカルな値の要素を`t'にすることで動作する。こ
     れは、バッファローカルな値に加えてフック変数のデフォルト値にあるフッ
     ク関数を使うことを表すフラグである。`run-hooks'はこのフラグを理解し、
     `make-local-hook'はすべてのノーマルフックを処理できる。アブノーマル
     フックに関しては、`t'の意味を理解するように更新したものだけが処理で
     きる。

     フック変数に対して`make-local-variable'を直接使わないこと。それだけ
     では不十分である。


File: elisp-ja.info, Node: Documentation, Next: Files, Prev: Modes, Up: Top

説明文
******

GNU Emacs Lispには、便利なオンラインのヘルプ機能があります。そのほとんど
は、関数や変数に付随した説明文字列から取り出したものです。本章では、説明
文を参照するプログラムの書き方に加えて、読者のLispプログラムに適切な説明
文字列を書く方法を説明します。

Emacsの説明文字列は、Emacsマニュアルと同じものではないことに注意願います。
マニュアルには言語texinfoで書いた独自のソースファイルがありますが、説明
文字列は関数や変数の定義の中で指定されています。説明文字列を集めても、よ
いマニュアルとは構成が違いますので、マニュアルとしては十分ではありません。

* Menu:

* Documentation Basics::      Good style for doc strings.
                                Where to put them.  How Emacs stores them.
* Accessing Documentation::   How Lisp programs can access doc strings.
* Keys in Documentation::     Substituting current key bindings.
* Describing Characters::     Making printable descriptions of
                                non-printing characters and key sequences.
* Help Functions::            Subroutines used by Emacs help facilities.



File: elisp-ja.info, Node: Documentation Basics, Next: Accessing Documentation, Prev: Documentation, Up: Documentation

説明文の基本
============

説明文字列は、文字列に対するLisp構文、つまり、文字列のテキストをダブル
クォートで囲って書きます。これは、説明文字列が実際にはLispの文字列オブジェ
クトだからです。関数や変数の定義の正しい箇所に文字列を書くと、説明文とし
ての役割を果たします。関数定義においては、説明文字列は引数のつぎにありま
す。変数定義においては、変数の初期値のつぎにあります。

説明文字列を書くときには、最初の1行は1つの（あるいは2つの）完全な文にし
てください。`apropos'などのある種のコマンドは、複数行にまたがる説明文字
列の最初の1行だけを表示するからです。また、説明文字列の2行目以降を字下げ
しないでください。字下げがあると、`C-h f'（`describe-function'）や`C-h
v'（`describe-variable'）で説明文字列を表示すると不恰好になります。*Note
Documentation Tips::。

説明文字列には、特別な部分文字列、つまり、説明文を表示するときに現在のキー
マップからキーバインディングを探すことを表すものがあります。これにより、
ユーザーがキーバインディングを変更していても説明文字列から関連するコマン
ドのキーを参照できます。（*Note Accessing Documentation::）。

Emacs Lispでは、説明文字列はその説明対象である関数や変数を介して参照しま
す。

   * 関数の説明文は、関数定義自身に収められている（*Note Lambda
     Expressions::）。関数`documentation'がその取り出し方を知っている。

   * 変数の説明文は、変数の属性リストに属性名`variable-documentation'で
     収められている。関数`documentation-property'がその取り出し方を知っ
     ている。

場所を節約するために、あらかじめロード済みの関数や変数（基本関数や自動ロー
ド対象の関数を含む）に対する説明文は、Emacs本体にではなく、ファイル
`emacs/etc/DOC-VERSION'に収めてあります。Emacsセッションの最中にバイトコ
ンパイル済みのファイルからロードされる関数や変数の説明文字列は、当該ファ
イルに収めてあります（*Note Docs and Compilation::）。

Emacs内部のデータ構造では、説明文字列のかわりに、ファイル内の位置を表す
整数かファイル名と整数を含むリストで表します。関数`documentation'や
`documentation-property'は、この情報を用いて適切なファイルから説明文字列
を取り出します。この処理はユーザーには見えません。

説明文字列の利用に関する情報は、*Note ヘルプ機能: (emacs)Helpを参照して
ください。

ディレクトリ`emacs/lib-src'には、ファイル`emacs/etc/DOC-VERSION'を美しく
印刷するためのコマンドが2つあります。`sorted-doc'と`digest-doc'です。



File: elisp-ja.info, Node: Accessing Documentation, Next: Keys in Documentation, Prev: Documentation Basics, Up: Documentation

説明文字列の参照
================

 -- Function: documentation-property SYMBOL PROPERTY &optional VERBATIM
     この関数は、シンボルSYMBOLの属性リストに属性PROPERTYで記録されてい
     る説明文字列を返す。必要ならばファイルからテキストを取り出し、実際
     のキーバインディングに置き換えるために`substitute-command-keys'を実
     行する。（VERBATIMが`nil'以外であると、置換を行わない。）

          (documentation-property 'command-line-processed
             'variable-documentation)
               => "Non-nil once command line has been processed"
          (symbol-plist 'command-line-processed)
               => (variable-documentation 188902)

 -- Function: documentation FUNCTION &optional VERBATIM
     この関数は、関数FUNCTIONの説明文字列を返す。必要ならばファイルから
     テキストを取り出す。続いて、（VERBATIMが`nil'ならば）実際の（現在の）
     キーバインディングを含んだ値を返すために`substitute-command-keys'を
     実行する。

     関数`documentation'は、FUNCTIONに関数定義がないとエラー
     `void-function'を通知する。しかし、関数定義に説明文字列がなくてもエ
     ラーではない。その場合、`documentation'は`nil'を返す。

2つの関数`documentation'と`documentation-property'を用いて、数個のシンボ
ルの説明文字列をバッファ`*Help*'に表示する例を示します。

     (defun describe-symbols (pattern)
       "Describe the Emacs Lisp symbols matching PATTERN.
     All symbols that have PATTERN in their name are described
     in the `*Help*' buffer."
       (interactive "sDescribe symbols matching: ")
       (let ((describe-func
              (function 
               (lambda (s)
                 ;; Print description of symbol.
                 (if (fboundp s)             ; これは関数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (commandp s) 
                            (let ((keys (where-is-internal s)))
                              (if keys
                                  (concat
                                   "Keys: "
                                   (mapconcat 'key-description 
                                              keys " "))
                                "Keys: none"))
                          "Function")
                        (or (documentation s) 
                            "not documented"))))
            
                 (if (boundp s)              ; これは変数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (user-variable-p s) 
                            "Option " "Variable")
                        (or (documentation-property 
                              s 'variable-documentation)
                            "not documented")))))))
             sym-list)

         ;; パターンに一致するシンボルのリストを作る
         (mapatoms (function 
                    (lambda (sym)
                      (if (string-match pattern (symbol-name sym))
                          (setq sym-list (cons sym sym-list))))))

         ;; データを表示する
         (with-output-to-temp-buffer "*Help*"
           (mapcar describe-func (sort sym-list 'string<))
           (print-help-return-message))))

関数`describe-symbols'は`apropos'のように動作しますが、より多くの情報を
提供します。

     (describe-symbols "goal")

     ---------- Buffer: *Help* ----------
     goal-column     Option 
     *Semipermanent goal column for vertical motion, as set by ...

     set-goal-column Keys: C-x C-n
     Set the current horizontal position as a goal for C-n and C-p.
     Those commands will move to this position in the line moved to
     rather than trying to keep the same horizontal position.
     With a non-nil argument, clears out the goal column
     so that C-n and C-p resume vertical motion.
     The goal column is stored in the variable `goal-column'.

     temporary-goal-column   Variable
     Current goal column for vertical motion.
     It is the column where point was
     at the start of current run of vertical motion commands.
     When the `track-eol' feature is doing its job, the value is 9999.
     ---------- Buffer: *Help* ----------

 -- Function: Snarf-documentation FILENAME
     この関数は、実行可能なEmacsをダンプする直前のEmacsの初期化処理中に
     のみ使われる。ファイルFILENAMEに格納された説明文字列のファイル内位
     置を探し出し、それらの情報を実際の文字列のかわりにメモリ内の関数定
     義や変数の属性リストに記録する。*Note Building Emacs::。

     EmacsはファイルFILENAMEをディレクトリ`emacs/etc'から読む。ダンプし
     たEmacsをのちに実行すると、同じファイルをディレクトリ
     `doc-directory'で探す。通常、FILENAMEは`"DOC-VERSION"'である。

 -- Variable: doc-directory
     この変数は、組み込みであったりあらかじめロード済みの関数や変数の説
     明文字列を収めたファイル`"DOC-VERSION"'を置いたディレクトリの名前を
     保持する。

     ほとんどの場合、これは`data-directory'と同じである。Emacsをインストー
     ルせずに構築したディレクトリから起動すると、それらは異なることがあ
     る。*Note Help Functions::の`data-directory'を参照。

     Emacsの古い版では、この目的には`exec-directory'を用いていた。



File: elisp-ja.info, Node: Keys in Documentation, Next: Describing Characters, Prev: Accessing Documentation, Up: Documentation

説明文内のキーバインディングの置換
==================================

説明文字列からキー列を参照するときには、現在の活性なキーバインディングを
使うべきです。これは以下に述べる特別なテキスト列でできます。普通の方法で
説明文字列を参照すると、これらの特別な列は現在のキーバインディング情報で
置き換えられます。置き換えは`substitute-command-keys'を呼び出して行いま
す。読者自身がこの関数を使うこともできます。

特別な列とその意味を以下にあげます。

`\[COMMAND]'
     コマンドCOMMANDを起動するキー列を表す。COMMANDにキーバインディング
     がなければ、`M-x COMMAND'を表す。

`\{MAPVAR}'
     変数MAPVARの値であるキーマップの概要を表す。この概要は
     `describe-bindings'を使って作成する。

`\<MAPVAR>'
     空テキストを表す。副作用のためだけに使う。つまり、この説明文字列内
     のこれ以降にある列`\[COMMAND]'に対するキーマップとしてMAPVARの値を
     指定する。

`\='
     後続の文字をクォートし`\='は破棄する。したがって、`\=\['は`\['とい
     う出力になり、`\=\='は`\='という出力になる。

*注意：*` ' Emacs Lispでは、文字列内の`\'は、2つ続けて書くこと。

 -- Function: substitute-command-keys STRING
     この関数は、STRINGから上記の特別な列を探し、それらをそれらが意味す
     るものに置き換え、結果を文字列で返す。これにより、説明文の表示では、
     ユーザー独自のカスタマイズしたキーバインディングを実際に参照できる。

特別な列の例を示します。

     (substitute-command-keys 
        "To abort recursive edit, type: \\[abort-recursive-edit]")
     => "To abort recursive edit, type: C-]"

     (substitute-command-keys 
        "The keys that are defined for the minibuffer here are:
       \\{minibuffer-local-must-match-map}")
     => "The keys that are defined for the minibuffer here are:

     ?               minibuffer-completion-help
     SPC             minibuffer-complete-word
     TAB             minibuffer-complete
     C-j             minibuffer-complete-and-exit
     RET             minibuffer-complete-and-exit
     C-g             abort-recursive-edit
     "

     (substitute-command-keys
        "To abort a recursive edit from the minibuffer, type\
     \\<minibuffer-local-must-match-map>\\[abort-recursive-edit].")
     => "To abort a recursive edit from the minibuffer, type C-g."



File: elisp-ja.info, Node: Describing Characters, Next: Help Functions, Prev: Keys in Documentation, Up: Documentation

ヘルプメッセージ用の文字変換
============================

これらの関数は、イベント、キー列、文字をテキスト表記に変換します。これら
の表記は、メッセージに文字やキー列をテキストとして含めるのに有用です。と
いうのは、非印字文字や白文字を印字文字の列に変換するからです。白文字でな
い印字文字は文字そのもので表記します。

 -- Function: key-description SEQUENCE
     この関数は、SEQUENCEの入力イベントに対するEmacsの標準表記を含んだ文
     字列を返す。引数SEQUENCEは、文字列、ベクトル、リストである。正しい
     イベントについて詳しくは*Note Input Events::。下記の
     `single-key-description'の例を参照。

 -- Function: single-key-description EVENT
     この関数は、EVENTをキーボード入力向けのEmacsの標準表記で表した文字
     列を返す。普通の印字文字はそのまま現れるが、コントロール文字は`C-'
     で始まる文字列に、メタ文字は`M-'で始まる文字列に、空白、タブなどは、
     `SPC'、`TAB'などとなる。ファンクションキーのシンボルはそれ自身が現
     れる。リストであるイベントはリストのCARのシンボルの名前が現れる。

          (single-key-description ?\C-x)
               => "C-x"
          (key-description "\C-x \M-y \n \t \r \f123")
               => "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"
          (single-key-description 'C-mouse-1)
               => "C-mouse-1"

 -- Function: text-char-description CHARACTER
     この関数は、CHARACTERをテキストに現れる文字向けのEmacsの標準表記で
     表した文字列を返す。`single-key-description'に似ているが、コントロー
     ル文字は、始めにカレットを付けて表現する点が異なる（Emacsのバッファ
     では、コントロールは普通このように表示される）。

          (text-char-description ?\C-c)
               => "^C"
          (text-char-description ?\M-m)
               => "M-m"
          (text-char-description ?\C-\M-m)
               => "M-^M"

 -- Function: read-kbd-macro STRING
     この関数は、キーボードマクロの処理に主に使われるが、
     `key-description'に対するおおまかな逆変換にも使える。空白で区切った
     キーの表記を収めた文字列で、この関数を呼び出す。対応するイベントを
     収めた文字列かベクトルを返す。（指定したイベントに依存して、正しい
     単一のキー列であったりなかったりする。*Note Keymap Terminology::。）



File: elisp-ja.info, Node: Help Functions, Next: Visiting Files, Prev: Describing Characters, Up: Documentation

ヘルプ機能
==========

Emacsにはさまざまオンラインヘルプ関数があり、それらはすべてプレフィック
ス`C-h'のサブコマンドとして使えます。それらについて詳しくは、*Note ヘル
プ機能: (emacs)Helpを参照してください。ここでは、同じ情報を得るプログラ
ムレベルのインターフェイスを説明します。

 -- コマンド: apropos REGEXP &optional DO-ALL
     この関数は、正規表現REGEXPに一致する名前を持つすべてのシンボルを探
     し、それらのリストを返す（*Note Regular Expressions::）。さらに、バッ
     ファ`*Help*'に、各シンボルについて、シンボルとその説明文字列の始め
     の部分から取り出した1行の説明文を表示する。

     DO-ALLが`nil'以外であると、`apropos'は、みつけた関数に対するキーバ
     インディングも表示する。さらに、関数や変数以外も含めてすべてのシン
     ボルを表示する。

     つぎの例では、`apropos'は、`exec'を名前に含むすべてのシンボルを探し
     だす。（ここではバッファ`*Help*'の表示は示さない。）

          (apropos "exec")
               => (Buffer-menu-execute command-execute exec-directory
              exec-path execute-extended-command execute-kbd-macro
              executing-kbd-macro executing-macro)

 -- Variable: help-map
     この変数の値は、ヘルプキー`C-h'に続く文字向けのローカルキーマップで
     ある。

 -- プレフィックスコマンド: help-command
     このシンボルは関数ではない。その関数定義セルは、`help-map'として知
     られるキーマップを保持している。`help.el'での定義はつぎのとおりであ
     る。

          (define-key global-map "\C-h" 'help-command)
          (fset 'help-command help-map)

 -- Function: print-help-return-message &optional FUNCTION
     この関数は、ヘルプコマンドのあとでそれ以前のウィンドウの状態に復元
     する方法を述べた文字列を作成する。メッセージを作成後、FUNCTIONが
     `nil'以外であれば、メッセージをFUNCTIONに適用する。さもなければ、メッ
     セージをエコー領域に表示するために`message'を呼び出す。

     この関数は、スペシャルフォーム`with-output-to-temp-buffer'の中から
     呼び出され、しかも、当該スペシャルフォームで`standard-output'に値が
     束縛されているものと仮定する。使用例については、*Note Accessing
     Documentation::の長い例を参照。

 -- Variable: help-char
     この変数の値はヘルプ文字、つまり、Emacsがヘルプを意味すると認識する
     文字である。デフォルトでは、その値は`C-h'を表す8である。`help-form'
     が`nil'以外のLisp式であると、Emacsがこの文字を読み取るとその式を評
     価し、その結果が文字列であれば結果をウィンドウに表示する。

     通常、`help-form'の値は`nil'である。そうすると、ヘルプ文字にはコマ
     ンド入力のレベルでは特別な意味はなく、普通の意味でのキー列の一部に
     なる。`C-h'の標準のキーバインディングは、いくつかの汎用目的のヘルプ
     機能向けのプレフィックスキーである。

     ヘルプ文字は、プレフィックスキーのうしろでも特別である。プレフィッ
     クスのサブコマンドとしてのバインディングがないと、プレフィックスキー
     のすべてのサブコマンドの一覧を表示する`describe-prefix-bindings'を
     実行する。

 -- Variable: help-event-list
     この変数の値は、別の『ヘルプ文字』として動作するイベント型のリスト
     である。これらのイベントは`help-char'で指定されたイベントとまったく
     同様に扱われる。

 -- Variable: help-form
     この変数が`nil'以外であると、その値は、`help-char'を読むたびに評価
     すべきフォームである。フォームを評価すると文字列を生成すれば、その
     文字列が表示される。

     `read-event'や`read-char'を呼ぶコマンドは、入力中には`help-form'を
     `nil'以外に（たぶん）束縛すべきである。（`C-h'に別の意味がある場合
     には、こうしないこと。）この式の評価結果は、なんのための入力でどの
     ように入力すべきかを説明する文字列であること。

     ミニバッファに入ると、この変数は`minibuffer-help-form' （*Note
     Minibuffer Misc::）の値に束縛される。

 -- Variable: prefix-help-command
     この変数はプレフィックスキーに対するヘルプを表示する関数を保持する。
     ユーザーがプレフィックスキーに続けてヘルプ文字や当該プレフィックス
     のあとではバインディングを持たない文字を打つとその関数が呼ばれる。
     この変数のデフォルト値は`describe-prefix-bindings'である。

 -- Function: describe-prefix-bindings
     この関数は、もっとも最近のキー列のプレフィックスキーのすべてのサブ
     コマンドの一覧を表示するために`describe-bindings'を呼び出す。プレ
     フィックスの説明には、当該キー列の最後のイベント以外のすべてが含ま
     れる。（最後のイベントはヘルプ文字であると仮定する。）

つぎの2つの関数は、『エレクトリック』モードのように制御を放棄せずにヘル
プを提供したいモードのためです。それらの名前は、普通のヘルプ関数と区別す
るために`Helper'で始まります。

 -- コマンド: Helper-describe-bindings
     このコマンドは、ローカルキーマップとグローバルキーマップの両者のす
     べてのキーバインディングの一覧を収めたヘルプバッファを表示したウィ
     ンドウをポップアップする。`describe-bindings'を呼び出すことで動作す
     る。

 -- コマンド: Helper-help
     このコマンドはカレントモードについてのヘルプを提供する。ミニバッファ
     において`Help (Type ? for further options)'のメッセージでユーザーに
     問い合わせ、キーバインディングの意味やモードの目的を調べることを補
     佐する。`nil'を返す。

     このコマンドは、キーマップ`Helper-help-map'を変更することでカスタマ
     イズできる。

 -- Variable: data-directory
     この変数は、Emacsとともに配布された特定の説明文やテキストファイルを
     Emacsが探すためのディレクトリの名前を保持する。Emacsの古い版では、
     この目的には`exec-directory'を用いていた。

 -- Macro: make-help-screen FNAME HELP-LINE HELP-TEXT HELP-MAP
     このマクロは、サブコマンドの一覧を表示するプレフィックスキーのよう
     に動作するFNAMEという名前のコマンドのヘルプを定義する。

     起動されると、FNAMEはウィンドウにHELP-TEXTを表示し、HELP-MAPに従っ
     てキー列を読み実行する。文字列HELP-TEXTは、HELP-MAPが提供するバイン
     ディングを記述するべきである。

     コマンドFNAMEは、HELP-TEXTの表示をスクロールすることで、それ自身で
     は少数のイベントを扱うように定義される。FNAMEがそれらの特殊イベント
     の1つを読み取ると、スクロールしてつぎのイベントを読み取る。読み取っ
     たイベントが、扱えるものでなく、HELP-MAPにバインディングがあれば、
     当該キーのバインディングを実行して戻る。

     HELP-LINEは、HELP-MAP内の選択項目を1行にまとめたものであること。
     Emacsの現在の版では、この引数はオプション`three-step-help'を`t'に設
     定してある場合にのみ使われる。

     このマクロは、`C-h C-h'のバインディングであるコマンド
     `help-for-help'で使われている。

 -- User Option: three-step-help
     この変数が`nil'以外であると、`make-help-screen'で定義されたコマンド
     は、まず文字列HELP-LINEをエコー領域に表示し、ユーザーがヘルプ文字を
     再度打った場合にのみより長い文字列を表示する。


File: elisp-ja.info, Node: Files, Next: Backups and Auto-Saving, Prev: Documentation, Up: Top

ファイル
********

Emacsでは、ファイルやディレクトリを探したり、作成したり、眺めたり、保存
したり、その他のことをできます。本章では、Emacs Lispのファイル関連の関数
のほとんどについて説明しますが、他の一部は*Note Buffers::で、バックアッ
プや自動保存に関することは*Note Backups and Auto-Saving::で説明します。

ファイル関数の多くは、ファイル名の引数を1つないし複数個取ります。ファイ
ル名は実際には文字列です。これらのほとんどの関数では、`expand-file-name'
を呼び出してファイル名引数を展開することで`~'や（`../'を含む）相対ファイ
ル名を正しく処理します。これらの関数は、`$HOME'などの環境変数置換は認識
しません。*Note File Name Expansion::。

* Menu:

* Visiting Files::           Reading files into Emacs buffers for editing.
* Saving Buffers::           Writing changed buffers back into files.
* Reading from Files::       Reading files into buffers without visiting.
* Writing to Files::         Writing new files from parts of buffers.
* File Locks::               Locking and unlocking files, to prevent
                               simultaneous editing by two people.
* Information about Files::  Testing existence, accessibility, size of files.
* Changing Files::           Renaming files, changing protection, etc.
* File Names::               Decomposing and expanding file names.
* Contents of Directories::  Getting a list of the files in a directory.
* Create/Delete Dirs::	     Creating and Deleting Directories.
* Magic File Names::	     Defining "magic" special handling
			       for certain file names.
* Format Conversion::        Conversion to and from various file formats.



File: elisp-ja.info, Node: Visiting Files, Next: Saving Buffers, Prev: Help Functions, Up: Files

ファイルの訪問
==============

ファイルを訪問するとは、ファイルをバッファに読み込むことです。いったんこ
うすると、バッファはそのファイルを"訪問している"（visiting）といい、その
ファイルをバッファの『訪問しているファイル』と呼びます。

ファイルとバッファは2つの異なるものです。ファイルは、コンピュータ内に
（読者が削除しない限り）恒久的に記録されている情報です。一方、バッファは
Emacs内部にある情報であり、編集セッションを終了する（あるいはバッファを
削除する）と消えてしまいます。通常、バッファにはファイルからコピーした情
報があります。つまり、バッファはそのファイルを訪問しているのです。読者は、
バッファ内のコピーを編集コマンドで修正するのです。バッファに対するそのよ
うな変更では、ファイルは変更しません。したがって、変更を恒久的なものにす
るには、読者はバッファを"保存"（save）する、つまり、バッファの変更した内
容をファイルにコピーし戻す必要があります。

ファイルとバッファの区別にも関わらず、バッファを意味してファイルといった
り、その逆のいい方をしばしばします。もちろん、『同じ名前のファイルにただ
ちに保存するつもりでバッファを編集している』とはいわずに『ファイルを編集
している』といいます。しばしば、人間は明確に区別する必要はありません。し
かし、コンピュータプログラムを扱ううえでは、区別を心得ておくことがよいの
です。

* Menu:

* Visiting Functions::         The usual interface functions for visiting.
* Subroutines of Visiting::    Lower-level subroutines that they use.



File: elisp-ja.info, Node: Visiting Functions, Next: Subroutines of Visiting, Prev: Visiting Files, Up: Visiting Files

ファイルを訪問する関数
----------------------

本節では、ファイルを訪問するために通常使う関数について述べます。歴史的な
理由で、これらの関数は`visit-'でなく`find-'という名前で始まります。バッ
ファで訪問したファイルの名前を参照するための関数や変数、ならびに、訪問し
たファイルの名前で既存バッファを探すための関数や変数については、*Note
Buffer File Name::。

Lispプログラムにおいて、ファイルの内容を変更せずにその内容を調べたいとき
には、もっとも速い方法は一時的なバッファで`insert-file-contents'を使うこ
とです。ファイルを訪問する必要はありませんし、それには余計に時間がかかり
ます。*Note Reading from Files::。

 -- コマンド: find-file FILENAME
     このコマンドはファイルFILENAMEを訪問したバッファを選択する。そのよ
     うなバッファが既存ならば当該バッファを使う。さもなければ、新たなバッ
     ファを作成してファイルを読み込む。当該バッファを返す。

     関数`find-file'の本体は非常に簡単で、つぎのとおりである。

          (switch-to-buffer (find-file-noselect filename))

     （*Note Displaying Buffers::の`switch-to-buffer'を参照。）

     `find-file'が対話的に呼び出されると、ミニバッファでFILENAMEを問い合
     わせる。

 -- Function: find-file-noselect FILENAME &optional NOWARN RAWFILE
     この関数は、ファイルを訪問するすべての関数の基である。ファイル
     FILENAMEを訪問した／するバッファを探し／作成し、当該バッファを返す。
     そのようなバッファが既存ならば当該バッファを使う。さもなければ、新
     たなバッファを作成してファイルを読み込む。必要に応じて、バッファを
     カレントバッファにしたりウィンドウに表示できるが、この関数はそこま
     では行わない。

     `find-file-noselect'が既存バッファを使うときには、ファイルの内容が
     当該バッファに最後に訪問してから、あるいは、当該バッファを最後に保
     存してから変更されたかどうかまず確認する。ファイルが変更されていれ
     ば、この関数は変更されたファイルを再度読み込むかどうかユーザーに問
     い合わせる。ユーザーが`yes'と答えると、バッファ内の変更は破棄される。

     省略可能な引数NOWARNが`nil'であると、この関数はさまざまな場面で警告／
     助言メッセージを表示する。たとえば、バッファを作成する必要があり、
     かつ、指定したファイルFILENAMEがない場合には、エコー領域にメッセー
     ジ`New file'を表示し、バッファは空にしておく。

     関数`find-file-noselect'は、ファイルを読み込み終えると通常
     `after-find-file'を呼び出す（*Note Subroutines of Visiting::）。そ
     の関数は、バッファのメジャーモードを設定し、ローカル変数を解析し、
     訪問したファイルより新しい自動保存ファイルが存在するとユーザーに警
     告を発し、`find-file-hooks'の関数を実行して処理を終える。

     省略可能な引数RAWFILEが`nil'以外であると、`after-find-file'を呼び出
     さず、失敗しても`find-file-not-found-hooks'を実行しない。さらに、
     RAWFILEの値が`nil'以外であると、コーディングシステムの変換（*Note
     Coding Systems::）や書式変換（*Note Format Conversion::）も行わない。

     関数`find-file-noselect'は、ファイルFILENAMEを訪問したバッファを返
     す。

          (find-file-noselect "/etc/fstab")
               => #<buffer fstab>

 -- コマンド: find-file-other-window FILENAME
     このコマンドは、選択しているウィンドウ以外のウィンドウにおいて、ファ
     イルFILENAMEを訪問したバッファを選択する。別の既存ウィンドウを使う
     か、ウィンドウを分割する。*Note Displaying Buffers::を参照。

     このコマンドが対話的に呼び出されると、FILENAMEを問い合わせる。

 -- コマンド: find-file-read-only FILENAME
     このコマンドは、`find-file'のようにファイルFILENAMEを訪問したバッファ
     を選択するが、当該バッファは読み出し専用となる。*Note Read Only
     Buffers::。

     このコマンドが対話的に呼び出されると、FILENAMEを問い合わせる。

 -- コマンド: view-file FILENAME
     このコマンドは、閲覧（view）モードでFILENAMEを訪問し、閲覧（view）
     モードを抜けるとそれ以前のバッファに戻る。閲覧（view）モードは、ファ
     イルを素早く眺めるためのコマンドを与えるがテキストの変更は許さない
     マイナモードである。閲覧（view）モードに入ると、ノーマルフック
     `view-mode-hook'を実行する。*Note Hooks::。

     `view-file'が対話的に呼び出されると、FILENAMEを問い合わせる。

 -- Variable: find-file-hooks
     この変数の値は、ファイルを訪問後に呼び出される関数のリストである。
     ファイルにローカル変数指定（があれば）は、フックを実行するまえに処
     理される。フック関数が実行されときには、ファイルを訪問したバッファ
     はカレントバッファになっている。

     この変数はノーマルフックのように動作するが、改名すべきではないと考
     えている。*Note Hooks::。

 -- Variable: find-file-not-found-hooks
     この変数の値は、`find-file'や`find-file-noselect'に存在しないファイ
     ルを与えたときに呼び出される関数のリストである。
     `find-file-noselect'は、ファイルが存在しないことがわかるとただちに
     これらの関数を呼び出す。`nil'以外の値が返されるまで、リストに現れる
     順に呼び出す。`buffer-file-name'は設定済みである。

     関数の値を使い、しかも、一部の関数だけを呼び出すので、これはノーマ
     ルフックではない。



