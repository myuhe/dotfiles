Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Subroutines of Visiting, Prev: Visiting Functions, Up: Visiting Files

訪問するためのサブルーティン
----------------------------

関数`find-file-noselect'は、ユーザーのLispコードでも有用な2つの重要なサ
ブルーティン、`create-file-buffer'と`after-find-file'を使います。本節で
はそれらの使い方を説明します。

 -- Function: create-file-buffer FILENAME
     この関数は、FILENAMEを訪問するのに適するように命名したバッファを作
     成しそれを返す。（ディレクトリを除外した）FILENAMEが使用中の名前で
     なければ、それを名前とする。さもなければ、未使用の名前を得るために
     `<2>'などの文字列を付加する。*Note Creating Buffers::も参照。

     *注意：*` ' `create-file-buffer'は、新たなバッファをファイルに対応
     付け*ない*し、当該バッファを選択しない。デフォルトのメジャーモード
     も使わない。

          (create-file-buffer "foo")
               => #<buffer foo>
          (create-file-buffer "foo")
               => #<buffer foo<2>>
          (create-file-buffer "foo")
               => #<buffer foo<3>>

     この関数は`find-file-noselect'で使われる。この関数は
     `generate-new-buffer'（*Note Creating Buffers::）を使う。

 -- Function: after-find-file &optional ERROR WARN
     この関数は、バッファのメジャーモードを設定し、ローカル変数を解析す
     る（*Note Auto Major Mode::）。`find-file-noselect'やデフォルトの復
     元処理関数（*Note Reverting::）から呼ばれる。

     ディレクトリはあるのにファイルが存在しないためにファイルの読み込み
     がエラーになった場合には、呼び出し側はERRORの値として`nil'以外を渡
     すこと。その場合、`after-find-file'は警告`(New File)'を表示する。よ
     り重大なエラーの場合には、`after-find-file'を呼び出すべきでない。

     WARNが`nil'以外であると、自動保存ファイルが存在しそれが訪問したファ
     イルより新しい場合には、この関数は警告を発する。

     `after-find-file'が最後に行うことは、リスト`find-file-hooks'内のす
     べての関数を呼び出すことである。



File: elisp-ja.info, Node: Saving Buffers, Next: Reading from Files, Prev: Visiting Files, Up: Files

バッファの保存
==============

Emacsでファイルを編集するときには、ファイルを訪問したバッファを実際には
扱っています。つまり、ファイルの内容はバッファにコピーされ、そのコピーを
編集しているのです。バッファを変更しても、当該バッファを"保存"（save）す
るまで、つまり、バッファの内容をファイルへコピーするまでは、ファイルを変
更しません。

 -- コマンド: save-buffer &optional BACKUP-OPTION
     この関数は、最後に訪問／保存してからカレントバッファが変更されてい
     れば、カレントバッファの内容を訪問しているファイルへ保存する。

     `save-buffer'は、バックアップの作成に責任がある。通常、
     BACKUP-OPTIONは`nil'であり、`save-buffer'は、ファイルを訪問してから
     最初に保存するときにのみバックアップファイルを作成する。
     BACKUP-OPTIONが別の値であると、別の場面でもバックアップファイルを作
     成することを指示する。

        * 引数が1つか3つの`C-u'を反映した4か64であると、関数
          `save-buffer'は、バッファをつぎに保存したときにファイルの現在
          の版をバックアップするように印を付ける。

        * 引数が2つか3つの`C-u'を反映した16か64であると、`save-buffer'は、
          保存するまえに無条件にファイルのまえの版をバックアップする。

 -- コマンド: save-some-buffers &optional SAVE-SILENTLY-P EXITING
     このコマンドは、ファイルを訪問している変更されたバッファを保存する。
     通常、各バッファについてユーザーに問い合わせる。しかし、
     SAVE-SILENTLY-Pが`nil'以外であると、ユーザーに問い合わせずにファイ
     ルを訪問しているバッファをすべて保存する。

     省略可能な引数EXITINGが`nil'以外であると、この関数は、ファイルを訪
     問していないある種のバッファを保存する機会も与える。
     `buffer-offer-save'のバッファローカルな値が`nil'以外のバッファが対
     象となる。（ユーザーがこれらのバッファの1つを保存するように答えると、
     ファイル名を指定するように聞いてくる。）関数
     `save-buffers-kill-emacs'は、この引数に`nil'以外の値を渡す。

 -- コマンド: write-file FILENAME
     この関数は、カレントバッファをファイルFILENAMEに保存し、当該ファイ
     ルを訪問しているバッファとし、さらに未変更という印を付ける。続いて、
     バッファ名を一意にするために必要ならば`<2>'のような文字列を付加して、
     バッファをFILENAMEに基づいた名前に改名する。この処理のほとんどは、
     `set-visited-file-name'（*Note Buffer File Name::）と`save-buffer'
     を呼び出して行う。

バッファを保存すると、いくつかのフックを実行します。また、書式変換
（*Note Format Conversion::）を行い、テキスト属性を『注記』（annotations）
（*Note Saving Properties::）に保存することもあります。

 -- Variable: write-file-hooks
     この変数の値は、バッファを訪問しているファイルに書き出すまえに呼ば
     れる関数のリストである。それらの1つが`nil'以外を返すと、すでにファ
     イルに書き出したとみなして残りの関数を呼び出さず、ファイルに書き出
     すための通常のコードも実行しない。

     `write-file-hooks'の関数が`nil'以外を返すときには、その関数には（必
     要ならば）バックアップファイルを作成する責任がある。そのためにはつ
     ぎのコードを実行する。

          (or buffer-backed-up (backup-buffer))

     `backup-buffer'が返したファイルモードの値を保存しておき、読者が書く
     ファイルのモードにその値を使いたい場合がある。`save-buffer'は通常そ
     のようにする。

     `write-file-hooks'のフック関数は、（必要ならば）データの符号化にも
     責任がある。適切なコーディングシステム（*Note Lisp and Coding
     Systems::）を選び、符号化（*Note Explicit Encoding::）を行い、使用
     したコーディングシステムを`last-coding-system-used'に設定する
     （*Note Encoding and I/O::）。

     この変数をバッファローカルにはしないこと。バッファ固有のフック関数
     を指定するには、かわりに`write-contents-hooks'を使う。

     これはノーマルフックではないが、`add-hook'と`remove-hook'でリストを
     扱える。*Note Hooks::。

 -- Variable: local-write-file-hooks
     これは`write-file-hooks'のように働くが、特定のバッファにバッファロー
     カルにするように意図してあり、ファイル名に関するフックやバッファ内
     容を得た方法に関するフックとして使われる。

     変数は恒久的にバッファローカルと印が付いているので、メジャーモード
     を変更してもバッファローカルな値は変更されない。これは、『ファイル』
     の内容を特別な方法で読み込み、対応した方法でデータを保存するフック
     を設定するようなパッケージには便利である。

 -- Variable: write-contents-hooks
     この変数は`write-file-hooks'のように働くが、ファイルの場所に関する
     フックではなく、ファイルの内容に関するフックであると意図されている。
     そのようなフックは、この変数のバッファローカルな束縛としてメジャー
     モードが通常設定する。

     この変数に設定すると自動的にバッファローカルになる。このフックに要
     素を追加するために`add-hooks'を使うときには、引数LOCALに`nil'以外を
     指定し*ない*こと。この変数はバッファローカル*のみ*であるからである。

 -- Variable: after-save-hook
     このノーマルフックは、バッファを訪問したファイルに保存し終えてから
     実行される。このフックの用途の1つは高速ロック（fast-lock）モードで
     ある。このフックを使って強調表示情報をキャッシュファイルに保存する。

 -- Variable: file-precious-flag
     この変数が`nil'以外ならば、`save-buffer'は保存処理中の入出力エラー
     に備えて対処する。つまり、目的の名前のファイルにではなく一時的な名
     前の新規ファイルに書き出し、エラーがないことを確認してから目的の名
     前に改名する。これにより、不正なファイルに起因する問題からディスク
     容量の不足といった問題を回避できる。

     副作用として、バックアップも必然的にコピーして行う。*Note Rename or
     Copy::。それと同時に、大事な（precious）ファイルとして保存すると、
     読者が保存したファイルと別のファイル名とのあいだのハードリンクをつ
     ねに切ってしまう。

     特定のバッファではこの変数に`nil'以外のバッファローカルな値を指定す
     るモードもある。

 -- User Option: require-final-newline
     この変数は、改行で終ら*ない*ファイルを書き出すかどうかを決定する。
     この変数の値が`t'であると、`save-buffer'は、保存するバッファが改行
     で終っていないと黙ってファイルの末尾に改行を追加する。この変数の値
     が`t'ではない`nil'以外であると、`save-buffer'は、必要な場面では改行
     を追加するかどうかユーザーに問い合わせる。

     この変数の値が`nil'であると、`save-buffer'は改行を追加しない。デフォ
     ルト値は`nil'であるが、特定のバッファでは`t'に設定するメジャーモー
     ドもある。

関数`set-visited-file-name'（*Note Buffer File Name::）も参照してくださ
い。



File: elisp-ja.info, Node: Reading from Files, Next: Writing to Files, Prev: Saving Buffers, Up: Files

ファイルの読み込み
==================

関数`insert-file-contents'を使ってディスクからファイルをバッファへコピー
できます。ユーザーレベルのコマンド`insert-file'はマークを設定するので
Lispプログラムでは使わないでください。

 -- Function: insert-file-contents FILENAME &optional VISIT BEG END REPLACE
     この関数は、ファイルFILENAMEの内容をカレントバッファのポイントのう
     しろに挿入する。絶対ファイル名と挿入したデータの長さから成るリスト
     を返す。FILENAMEが読み込めるファイルの名前でないと、エラーを通知す
     る。

     関数`insert-file-contents'は、ファイルの内容を定義済みのファイルの
     書式と比較し、必要ならばファイルの内容を変換する。*Note Format
     Conversion::。リスト`after-insert-file-functions'の関数も呼び出す。
     *Note Saving Properties::を参照。

     VISITが`nil'以外であると、この関数はバッファを未変更と印を付け、ファ
     イルFILENAMEを訪問しているバッファとなるようにバッファのさまざまな
     部分を設定する。これには、バッファが訪問しているファイルの名前、ファ
     イル更新時刻を含む。この機能は`find-file-noselect'で使われており、
     読者自身が使うことはないであろう。

     BEGとENDが`nil'以外であると、それらは挿入すべきファイルの部分を指定
     する整数であること。この場合、VISITは`nil'であること。たとえば、

          (insert-file-contents filename nil 0 500)

     はファイルの最初の500文字を挿入する。

     引数REPLACEが`nil'以外であると、バッファの内容（実際には参照可能な
     部分のみ）をファイルの内容で置き換えることを意味する。これは、単純
     にバッファの内容を削除してからファイル全体を挿入するより好ましい。
     なぜなら、（1）マーカ位置を保存できる場合がある、（2）アンドゥリス
     トにほとんどデータを入れない、からである。

     REPLACEとVISITが`nil'である限り、`insert-file-contents'で（FIFOや入
     出力装置などの）特別なファイルを読むことも可能である。

 -- Function: insert-file-contents-literally FILENAME &optional VISIT BEG END REPLACE
     この関数は`insert-file-contents'のように動作するが、書式を変換しな
     い（*Note Format Conversion::）、文字コードを変換しない（*Note
     Coding Systems::）、`find-file-hooks'を実行しない、自動的に解凍しな
     いなどが異なる。

別のプログラムが読めるようにファイル名を別のプロセスに渡すには、関数
`file-local-copy'を使います。*Note Magic File Names::を参照してください。



File: elisp-ja.info, Node: Writing to Files, Next: File Locks, Prev: Reading from Files, Up: Files

ファイルへの書き出し
====================

関数`append-to-file'や`write-region'を使って、バッファの内容やその一部を
ディスク上のファイルへ直接書き出せます。訪問しているファイルには、これら
の関数で書き出さないでください。訪問の機構に混乱をきたすことがあります。

 -- コマンド: append-to-file START END FILENAME
     この関数は、カレントバッファのSTARTからENDで区切られる領域の内容を
     ファイルFILENAMEの末尾に追加する。当該ファイルが存在しなければ作成
     する。この関数は`nil'を返す。

     書き込めないファイルをFILENAMEに指定したり、ファイルを作成できない
     ディレクトリ上の存在しないファイルをFILENAMEに指定するとエラーを通
     知する。

 -- コマンド: write-region START END FILENAME &optional APPEND VISIT CONFIRM
     この関数は、カレントバッファのSTARTからENDで区切られる領域の内容を
     FILENAMEで指定したファイルに書き出す。

     STARTが文字列であると、`write-region'はバッファのテキストではなくそ
     の文字列を書いたり追加する。

     APPENDが`nil'以外であると、指定したテキストを既存ファイル（があれば）
     の内容に追加する。

     CONFIRMが`nil'以外であると、FILENAMEが既存ファイルの名前であると
     `write-region'は確認を求める。

     VISITが`t'であると、Emacsはバッファとファイルの対応を確立する。つま
     り、バッファはそのファイルを訪問していることになる。さらに、カレン
     トバッファの最終ファイル更新時刻をFILENAMEの更新時刻にし、バッファ
     には未変更と印を付ける。この機能は`save-buffer'が使っているが、読者
     自身が使うことはないであろう。

     VISITが文字列であると、訪問するファイルの名前を指定する。このように
     して、データを1つのファイル（FILENAME）に書き出す一方で、バッファは
     別のファイル（VISIT）を訪問していると設定できる。引数VISITはエコー
     領域のメッセージに使われ、ファイルのロックにも使われる。VISITは
     `buffer-file-name'に保存される。この機能は`file-precious-flag'の実
     装に使われているが、読者は、なにをしているか理解できない限り、この
     機能を使わないこと。

     関数`write-region'は、書き出すデータを`buffer-file-format'で指定さ
     れる適切なファイル書式に変換する。*Note Format Conversion::。さらに、
     リスト`write-region-annotate-functions'の関数も呼び出す。*Note
     Saving Properties::を参照。

     通常、`write-region'はエコー領域にメッセージ`Wrote FILENAME'を表示
     する。VISITが`t'でも`nil'でも文字列でもないと、このメッセージは表示
     しない。この機能は、ユーザーが知る必要のない内部目的にファイルを使
     うプログラムに有用である。

 -- Macro: with-temp-file FILE BODY...
     マクロ`with-temp-file'は、一時的なバッファをカレントバッファとして
     フォームBODYを評価する。そして最後にバッファの内容をファイルFILEに
     書き出す。終了すると一時的なバッファを削除し、フォーム
     `with-temp-file'のまえにカレントバッファであったバッファに戻る。
     BODYの最後のフォームの値を返す。

     `throw'やエラーによる異常終了（*Note Nonlocal Exits::）であってもカ
     レントバッファに戻る。

     *Note Current Buffer::の`with-temp-buffer'も参照。



File: elisp-ja.info, Node: File Locks, Next: Information about Files, Prev: Writing to Files, Up: Files

ファイルロック
==============

2人のユーザーが同時に同じファイルを編集すると、互いに干渉し合います。
Emacsは、ファイルが変更されると"ファイルロック"（file lock）を記録するこ
とで、このような状況が発生しないように努めます。すると、Emacsは別のEmacs
がロックしているファイルを訪問したバッファを変更しようとする最初の試みを
検出でき、ユーザーにどうすべきかを問い合わせます。

複数の計算機がファイルシステムを共有している場合には、ファイルロックには
完全な信頼性はありません。ファイルロックが働かないと、2人のユーザーが同
時に変更する可能性がありますが、それでも、Emacsは2番目に保存したユーザー
に警告できます。また、ディスク上で変更されたファイルを訪問しているバッファ
の変更を検出することで、同時編集のある場面を捕捉できます。*Note
Modification Time::を参照してください。

 -- Function: file-locked-p FILENAME
     ファイルFILENAMEがロックされていなければ、この関数は`nil'を返す。こ
     のEmacsプロセスがロックしているときには`t'を返す。他のEmacsがロック
     している場合には、ロックしているユーザーの名前を返す。

          (file-locked-p "foo")
               => nil

 -- Function: lock-buffer &optional FILENAME
     この関数は、カレントバッファが変更されていればファイルFILENAMEをロッ
     クする。引数FILENAMEのデフォルトは、カレントバッファで訪問している
     ファイルである。カレントバッファがファイルを訪問していなかったり、
     未変更ならばなにもしない。

 -- Function: unlock-buffer
     この関数は、バッファが変更されていれば、カレントバッファで訪問して
     いるファイルのロックを解除する。バッファが未変更ならばファイルをロッ
     クしていないはずであり、この関数はなにもしない。カレントバッファが
     ファイルを訪問していなければ、やはりなにもしない。

 -- Function: ask-user-about-lock FILE OTHER-USER
     この関数は、別のユーザーOTHER-USERがロックしているファイルFILEをユー
     ザーが変更しようとしたときに呼び出される。この関数のデフォルトの定
     義は、ユーザーになにをすべきか問い合わせることである。この関数の戻
     り値がEmacsのつぎの動作を決定する。

        * 値が`t'であると、ファイルのロックを取得することを意味する。す
          ると、このユーザーはファイルを編集でき、別のユーザーOTHER-USER
          はロックを失う。

        * 値が`nil'であると、ロックを無視してとにかくユーザーにファイル
          の編集を許す。

        * この関数はエラー`file-locked'を通知する。この場合、ユーザーが
          行おうとしていた変更は行われない。

          このエラーのエラーメッセージはつぎのようである。

               error--> File is locked: FILE OTHER-USER

          ここで、`file'はファイル名であり、OTHER-USERはそのファイルをロッ
          クしているユーザー名である。

     読者は、関数`ask-user-about-lock'を別の方法で決定する読者独自のもの
     に置き換えてもよい。通常の定義に対応したコードは`userlock.el'にある。



File: elisp-ja.info, Node: Information about Files, Next: Changing Files, Prev: File Locks, Up: Files

ファイルに関する情報
====================

本節に述べる関数はすべて、ファイル名を表す文字列に作用します。すべての関
数の名前は単語`file'で始まり、それらの引数は、特に断らないかぎり、既存の
ファイルやディレクトリである必要があります。

* Menu:

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A symbolic link?
* Truenames::		    Eliminating symbolic links from a file name.
* File Attributes::         How large is it?  Any other names?  Etc.



File: elisp-ja.info, Node: Testing Accessibility, Next: Kinds of Files, Prev: Information about Files, Up: Information about Files

参照可能性の検査
----------------

これらの関数は、特別な方法でファイル参照のパーミッションを検査します。

 -- Function: file-exists-p FILENAME
     ファイルFILENAMEが存在すれば、この関数は`t'を返す。これは必ずしもファ
     イルを読めることは意味せず、単にファイルの属性を調べられるだけであ
     る。（UNIXでは、ファイルが存在し、かつ、それを収めたディレクトリに
     対する実行パーミッションがあれば、ファイル自体のパーミッションに関
     係なくこのようになる。）

     ファイルが存在しなかったり、ファイルの属性を探す権限がなければ、こ
     の関数は`nil'を返す。

 -- Function: file-readable-p FILENAME
     ファイルFILENAMEが存在しそれを読むことができるならば、この関数は`t'
     を返す。さもなければ`nil'を返す。

          (file-readable-p "files.texi")
               => t
          (file-exists-p "/usr/spool/mqueue")
               => t
          (file-readable-p "/usr/spool/mqueue")
               => nil

 -- Function: file-executable-p FILENAME
     ファイルFILENAMEが存在しそれを実行できるならば、この関数は`t'を返す。
     さもなければ`nil'を返す。ファイルがディレクトリである場合、実行パー
     ミッションは、ディレクトリ内のファイルの存在やその属性を検査でき、
     それらのファイルのモードが許せばオープンできることを意味する。

 -- Function: file-writable-p FILENAME
     ファイルFILENAMEに書き出したり作成できるならば、この関数は`t'を返し、
     さもなければ`nil'を返す。ファイルに書き出せるのは、ファイルが存在し
     書ける場合である。作成できるのは、ファイルは存在しないが指定したディ
     レクトリが存在しそのディレクトリに書ける場合である。

     以下の3番目の例では、`foo'の親ディレクトリが存在しないので、たとえ
     ディレクトリを作成できるとしても`foo'は書けない。

          (file-writable-p "~/foo")
               => t
          (file-writable-p "/foo")
               => nil
          (file-writable-p "~/no-such-dir/foo")
               => nil

 -- Function: file-accessible-directory-p DIRNAME
     ディレクトリDIRNAMEの既存ファイルをオープンするパーミッションがあれ
     ば、この関数は`t'を返す。さもなければ（あるいは当該ディレクトリが存
     在しなければ）`nil'を返す。DIRNAMEの値はディレクトリ名である。

     例：` 'つぎの例では、

          (file-accessible-directory-p "/foo")
               => nil

     から、`/foo/'内のファイルを読もうとするとエラーになると推論できる。

 -- Function: access-file FILENAME STRING
     この関数は、ファイルFILENAMEを読むためにオープンし、クローズしてか
     ら`nil'を返す。しかし、オープンに失敗するとSTRINGをエラーメッセージ
     のテキストとしたエラーを通知する。

 -- Function: file-ownership-preserved-p FILENAME
     もしファイルFILENAMEを削除して改めて作成してもファイルの所有者が変
     更されなければ、この関数は`t'を返す。

 -- Function: file-newer-than-file-p FILENAME1 FILENAME2
     ファイルFILENAME1がFILENAME2より新しければ、この関数は`t'を返す。
     FILENAME1が存在しなければ`nil'を返す。FILENAME2が存在しなければ`t'
     を返す。

     以下の例で、ファイル`aug-19'は19日に書かれ、ファイル`aug-20'は20日
     に書かれ、ファイル`no-file'は存在しないと仮定する。

          (file-newer-than-file-p "aug-19" "aug-20")
               => nil
          (file-newer-than-file-p "aug-20" "aug-19")
               => t
          (file-newer-than-file-p "aug-19" "no-file")
               => t
          (file-newer-than-file-p "no-file" "aug-19")
               => nil

     `file-attributes'を使って、2つの数から成るリストとしてファイルの最
     終更新時刻を取得できる。*Note File Attributes::。



File: elisp-ja.info, Node: Kinds of Files, Next: Truenames, Prev: Testing Accessibility, Up: Information about Files

ファイルの種類の区別
--------------------

本節ではさまざまな種類のファイル、つまり、ディレクトリ、シンボリックリン
ク、普通のファイルを区別する方法を説明します。

 -- Function: file-symlink-p FILENAME
     ファイルFILENAMEがシンボリックリンクであると、関数`file-symlink-p'
     は当該リンクが指すファイルの名前を返す。これは、テキストファイル、
     ディレクトリ、別のシンボリックリンク、存在しないファイルの名前のい
     ずれかである。

     ファイルFILENAMEがシンボリックリンクでない（あるいは当該ファイルが
     存在しない）場合、`file-symlink-p'は`nil'を返す。

          (file-symlink-p "foo")
               => nil
          (file-symlink-p "sym-link")
               => "foo"
          (file-symlink-p "sym-link2")
               => "sym-link"
          (file-symlink-p "/bin")
               => "/pub/bin"


 -- Function: file-directory-p FILENAME
     ファイルFILENAMEが既存ディレクトリの名前であると`t'を返し、さもなけ
     れば`nil'を返す。

          (file-directory-p "~rms")
               => t
          (file-directory-p "~rms/lewis/files.texi")
               => nil
          (file-directory-p "~rms/lewis/no-such-file")
               => nil
          (file-directory-p "$HOME")
               => nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               => t

 -- Function: file-regular-p FILENAME
     ファイルFILENAMEが存在しそれが普通のファイル（ディレクトリでもシン
     ボリックリンクでも名前付きパイプでも端末でもその他の入出力装置でも
     ない）であれば、この関数は`t'を返す。



File: elisp-ja.info, Node: Truenames, Next: File Attributes, Prev: Kinds of Files, Up: Information about Files

実名
----

ファイルの"実名"（truename）とは、シンボリックリンクをすべて辿り尽くして
から、要素として現れる`.' や`..' を簡略化して得られる名前です。厳密にい
えば、ファイルが一意の実名を持つ必要はありません。ファイルの異なる実名の
個数は、当該ファイルに対するハードリンクの個数に等しいのです。それでも、
実名はシンボリックリンクによる名前の変動を取り除くため、実名は有用です。

 -- Function: file-truename FILENAME
     関数`file-truename'はファイルFILENAMEの実名を返す。これはシンボリッ
     クリンクをすべて辿り尽くして得られる名前である。引数は絶対ファイル
     名であること。

関連情報については、*Note Buffer File Name::。



File: elisp-ja.info, Node: File Attributes, Prev: Truenames, Up: Information about Files

ファイルに関する他の情報
------------------------

本節では、ファイルの内容以外の詳しい情報を得るための関数を説明します。こ
の情報には、参照パーミッションを制御するモードビット、所有者とグループの
番号、名前の個数、iノード番号、サイズ、参照時刻と更新時刻が含まれます。

 -- Function: file-modes FILENAME
     この関数はFILENAMEのモードビットを整数で返す。モードビットはファイ
     ルのパーミッションとも呼ばれ、UNIX流の参照制御を指定する。最下位ビッ
     トが1であると、当該ファイルはすべてのユーザーが実行でき、2番目の下
     位ビットが1であると、当該ファイルはすべてのユーザーが書けるといった
     具合である。

     戻り値の最大値は4095（8進数7777）であり、これは、だれもが読み／書き／
     実行でき、所有者とグループの両者にビットSUIDが設定してあり、スティッ
     キービットも設定されていることを意味する。

          (file-modes "~/junk/diffs")
               => 492               ; 10進整数
          (format "%o" 492)
               => "754"             ; 8進数に変換

          (set-file-modes "~/junk/diffs" 438)
               => nil

          (format "%o" 438)
               => "666"             ; 8進数に変換

          % ls -l diffs
            -rw-rw-rw-  1 lewis 0 3063 Oct 30 16:00 diffs

 -- Function: file-nlinks FILENAME
     この関数は、ファイルFILENAMEの名前（つまりハードリンク）の個数を返
     す。ファイルが存在しなければ、この関数は`nil'を返す。シンボリックリ
     ンクはそれが指すファイルの名前とはみなさないので、シンボリックリン
     クはこの関数には効果を持たない。

          % ls -l foo*
          -rw-rw-rw-  2 rms       4 Aug 19 01:27 foo
          -rw-rw-rw-  2 rms       4 Aug 19 01:27 foo1

          (file-nlinks "foo")
               => 2
          (file-nlinks "doesnt-exist")
               => nil

 -- Function: file-attributes FILENAME
     この関数はファイルFILENAMEの属性のリストを返す。オープンできないファ
     イルを指定すると`nil'を返す。

     リストの要素は順につぎのとおりである。

       0. ディレクトリは`t'、シンボリックリンクは（それが指す名前の）文
          字列、テキストファイルは`nil'である。

       1. ファイルの名前の個数。別の名前、つまり、ハードリンクは関数
          `add-name-to-file'（*Note Changing Files::）を使って作成する。

       2. ファイルのUID（所有者番号）。

       3. ファイルのGID（グループ番号）。

       4. 2つの整数から成るリストとしての最終参照時刻。最初の整数は時刻
          の上位16ビットであり、2番目は下位16ビット。（これは
          `current-time'の値と同様。*Note Time of Day::を参照。）

       5. 2つの整数から成るリストとしての最終更新時刻（上記と同様）。

       6. 2つの整数から成るリストとしての最終状態更新時刻（上記と同様）。

       7. バイト単位でのファイルのサイズ。

       8. `ls -l'と同様のファイルのモードを表す10文字の文字列。

       9. もしファイルを削除して再度作成した場合にファイルのGID（グルー
          プ番号）が変わる場合には`t'。さもなければ`nil'。

      10. ファイルのiノード番号。可能ならばこれは整数である。iノード番号
          がEmacs Lispの整数として表現できないほど大きな場合、値は`(HIGH
          . LOW)'の形である。ただし、LOWは下位16ビットである。

      11. ファイルが置いてあるファイルシステムのファイルシステム番号。こ
          の要素とファイルのiノード番号により、システム上の任意の2つのファ
          イルを区別するために十分な情報を与える。つまり、2つのファイル
          が同じ値のこれらの番号を持つことはない。

     たとえば、`files.texi'のファイル属性はつぎのようである。

          (file-attributes "files.texi")
               =>  (nil 1 2235 75 
                    (8489 20284) 
                    (8489 20284) 
                    (8489 20285)
                    14906 "-rw-rw-rw-" 
                    nil 129500 -32252)

     この意味はつぎのとおりである。

     `nil'
          ディレクトリでもシンボリックリンクでもない。

     `1'
          唯一の名前（カレントディレクトリで`files.texi'）を持つ。

     `2235'
          UID（ユーザー番号）2235のユーザーが所有している。

     `75'
          GID（グループ番号）75のグループに属する。

     `(8489 20284)'
          最後に参照されたのは8月19日00時09分である。

     `(8489 20284)'
          最後に更新されたのは8月19日00時09分である。

     `(8489 20285)'
          最後にこのiノードを変更したのは8月19日00時09分である。

     `14906'
          長さは14906バイトである。

     `"-rw-rw-rw-"'
          モードは、所有者／グループ／その他は読み書きできる。

     `nil'
          再度作成してもGID（グループ番号）は保存される。

     `129500'
          iノード番号は129500。
     `-32252'
          ファイルシステム番号は-32252。



File: elisp-ja.info, Node: Changing Files, Next: File Names, Prev: Information about Files, Up: Files

ファイルの名前と属性の変更
==========================

本節の関数は、ファイルを改名／コピー／削除／リンクしたり、ファイルのモー
ドを設定するためのものです。

引数NEWNAMEをとる関数では、NEWNAMEで指定したファイルが既存の場合、関数の
動作は引数OK-IF-ALREADY-EXISTSの値に依存します。

   * OK-IF-ALREADY-EXISTSが`nil'であると、エラー`file-already-exists'を
     通知する。

   * OK-IF-ALREADY-EXISTSが数であると、確認を必要とする。

   * OK-IF-ALREADY-EXISTSがそれ以外の値であると、確認せずに古いファイル
     を置き換える。

 -- Function: add-name-to-file OLDNAME NEWNAME &optional OK-IF-ALREADY-EXISTS
     この関数は、OLDNAMEで指定したファイルに追加の名前NEWNAMEを与える。
     つまり、NEWNAMEはOLDNAMEへの新たな『ハードリンク』になる。

     つぎの例では、2つのファイル`foo'と`foo3'がある。

          % ls -li fo*
          81908 -rw-rw-rw-  1 rms       29 Aug 18 20:32 foo
          84302 -rw-rw-rw-  1 rms       24 Aug 18 20:31 foo3

     `add-name-to-file'を呼んでハードリンクを作成し、ファイル一覧を表示
     し直す。1つのファイルに2つの名前`foo'と`foo2'があることがわかる。

          (add-name-to-file "foo" "foo2")
               => nil

          % ls -li fo*
          81908 -rw-rw-rw-  2 rms       29 Aug 18 20:32 foo
          81908 -rw-rw-rw-  2 rms       29 Aug 18 20:32 foo2
          84302 -rw-rw-rw-  1 rms       24 Aug 18 20:31 foo3

     最後につぎの式を評価し

          (add-name-to-file "foo" "foo3" t)

     ファイル一覧を表示し直す。今度は、1つのファイルに3つの名前`foo'、
     `foo2'、`foo3'がある。古い`foo3'の内容は失われている。

          (add-name-to-file "foo1" "foo3")
               => nil

          % ls -li fo*
          81908 -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo
          81908 -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo2
          81908 -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo3

     1つのファイルに複数の名前を許さないオペレーティングシステムでは、こ
     の関数は意味がない。

     *Note File Attributes::の`file-nlinks'も参照。

 -- コマンド: rename-file FILENAME NEWNAME &optional OK-IF-ALREADY-EXISTS
     このコマンドは、ファイルFILENAMEをNEWNAMEと改名する。

     FILENAMEにFILENAME以外の名前があれば、それらの名前は存在し続ける。
     実際、`add-name-to-file'で名前NEWNAMEを追加してからFILENAMEを削除す
     ると、一時的な中間状態があることを除けば、改名と同じ効果がある。

     対話的に呼び出されると、この関数はミニバッファでFILENAMEとNEWNAMEを
     聞く。また、NEWNAMEが既存であると確認を求める。

 -- コマンド: copy-file OLDNAME NEWNAME &optional OK-IF-EXISTS TIME
     このコマンドはファイルOLDNAMEをNEWNAMEへコピーする。OLDNAMEが存在し
     ないとエラーを通知する。

     TIMEが`nil'以外であると、この関数は新たなファイルに古いファイルと同
     じ最終更新時刻を与える。（これは特定のオペレーティングシステムでの
     み動作する。）時刻設定でエラーがあると、`copy-file'はエラー
     `file-date-error'を通知する。

     対話的に呼び出されると、この関数はミニバッファでOLDNAMEとNEWNAMEを
     聞く。また、NEWNAMEが既存であると確認を求める。

 -- コマンド: delete-file FILENAME
     このコマンドは、シェルコマンド`rm FILENAME'と同様にファイルFILENAME
     を削除する。ファイルに複数の名前があると、他の名前では存在し続ける。

     ファイルが存在しなかったり削除できないと、エラー`file-error'の適切
     な種類が通知される。（UNIXでは、ファイルを収めたディレクトリに書け
     ると当該ファイルは削除可能である。）

     *Note Create/Delete Dirs::の`delete-directory'も参照。

 -- コマンド: make-symbolic-link FILENAME NEWNAME &optional OK-IF-EXISTS
     このコマンドは、FILENAMEに対するシンボリックリンクNEWNAMEを作成する。
     これはシェルコマンド`ln -s FILENAME NEWNAME'と同じである。

     対話的に呼び出されると、この関数はミニバッファでFILENAMEとNEWNAMEを
     聞く。また、NEWNAMEが既存であると確認を求める。

 -- Function: define-logical-name NAME STRING
     この関数は論理名NAMEに値STRINGを定義する。VMSでのみ使える。

 -- Function: set-file-modes FILENAME MODE
     この関数はFILENAMEのモードビットをMODE（整数であること）と設定する。
     MODEの下位12ビットのみを使う。

 -- Function: set-default-file-modes MODE
     この関数は、Emacsやそのサブプロセスが作成する新規ファイルのデフォル
     トのファイルモードを設定する。Emacsが作成する各ファイルは最初このモー
     ドになる。UNIXでは、デフォルトのモードは『umask』の値の1の補数であ
     る。

     引数MODEは整数であること。ほとんどのシステムでは、MODEの下位9ビット
     のみが意味を持つ。

     既存ファイルの変更を保存することはファイルの作成とはみなさないため、
     ファイルのモードは変わらず、デフォルトのファイルモードを使わない。

 -- Function: default-file-modes
     この関数は、現在のデフォルトのファイルモードの値を返す。

MS-DOSでは、『実行可能』ファイルモードビットのようなものはありません。そ
のためEmacsは、`.com'、`.bat'、`.exe'のいずれかで終る名前のファイルを実
行可能であるとみなします。これは、`file-modes'や`file-attributes'が返す
値に反映されます。



File: elisp-ja.info, Node: File Names, Next: Contents of Directories, Prev: Changing Files, Up: Files

ファイル名
==========

他の場面と同様にEmacsでは、一般にファイルはその名前で参照します。Emacsで
はファイル名は文字列で表します。ファイルを操作する関数はすべてファイル名
引数を仮定します。

ファイル自体の操作に加えて、Emacs Lispプログラムはファイルの名前そのもの
を操作する必要があります。つまり、ファイル名を分解したり、関連するファイ
ル名を作成するためにその一部を使います。本節ではファイル名を操作する方法
を説明します。

本節の関数は実際にはファイルを参照しませんから、既存のファイルやディレク
トリを表さないファイル名を操作できます。

VMSでは、これらの関数はすべて、VMSのファイル名構文とUNIXの構文の両方を理
解します。つまり、標準LispライブラリはUNIX構文でファイル名を指定でき、変
更せずにVMS上で正しく動作します。MS-DOSやMS-Windowsでは、これらの関数は、
UNIX構文に加えてMS-DOSやMS-Windowsのファイル名構文を理解します。

* Menu:

* File Name Components::  The directory part of a file name, and the rest.
* Directory Names::       A directory's name as a directory
                            is different from its name as a file.
* Relative File Names::   Some file names are relative to a current directory.
* File Name Expansion::   Converting relative file names to absolute ones.
* Unique File Names::     Generating names for temporary files.
* File Name Completion::  Finding the completions for a given file name.
* Standard File Names::   If your package uses a fixed file name,
                            how to handle various operating systems simply.



File: elisp-ja.info, Node: File Name Components, Next: Directory Names, Prev: File Names, Up: File Names

ファイル名の構成要素
--------------------

オペレーティングシステムは、一連のファイルをディレクトリにまとめます。ファ
イルを指定するには、ディレクトリと当該ディレクトリ内のファイルの名前を指
定する必要があります。そのためEmacsは、ファイル名には2つの部分、"ディレ
クトリ名"（directory name）部分と"非ディレクトリ名"（nondirectory name）
部分（つまり"ディレクトリ内のファイル名"）があるとみなします。どちらかの
部分は空でもかまいません。これらの2つの部分を連結するともとのファイル名
になります。

UNIXでは、ディレクトリ部分は最後のスラッシュまでを含んだ部分であり、非ディ
レクトリ部分は残りの部分です。VMSの構文規則は複雑です。

ある種の目的のために、非ディレクトリ部分をさらに名前だけの部分と"版番号"
（version number）に分けます。UNIXでは、バックアップファイルだけにそれら
の名前に版番号があります。VMSでは各ファイルに版番号がありますが、ほとん
どの場合、Emacsで実際に使うファイル名では版番号を省略します。そのため、
Emacsで版番号が見えるのは多くの場合ディレクトリ一覧です。

 -- Function: file-name-directory FILENAME
     この関数はFILENAMEのディレクトリ部分（ディレクトリ部分がなければ
     `nil'）を返す。UNIXでは、この関数はスラッシュで終る文字列を返す。
     VMSでは、`:'、`]'、`>'のいずれかで終る文字列を返す。

          (file-name-directory "lewis/foo")  ; UNIXの例
               => "lewis/"
          (file-name-directory "foo")        ; UNIXの例
               => nil
          (file-name-directory "[X]FOO.TMP") ; VMSの例
               => "[X]"

 -- Function: file-name-nondirectory FILENAME
     この関数はFILENAMEの非ディレクトリ部分を返す。

          (file-name-nondirectory "lewis/foo")
               => "foo"
          (file-name-nondirectory "foo")
               => "foo"
          ;; つぎの例はVMSでのみ正確である
          (file-name-nondirectory "[X]FOO.TMP")
               => "FOO.TMP"

 -- Function: file-name-sans-versions FILENAME
     この関数は、FILENAMEから版番号、バックアップ版番号、末尾のティルダ
     をすべて削除したものを返す。

          (file-name-sans-versions "~rms/foo.~1~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               => "~rms/foo"
          ;; つぎの例はVMSでのみ正確である
          (file-name-sans-versions "foo;23")
               => "foo"

 -- Function: file-name-sans-extension FILENAME
     この関数は、FILENAMEからあれば『拡張子』を除いたものを返す。ファイ
     ル名の拡張子とは、名前の最後の部分にある`.'で始まる部分である。たと
     えばつぎのとおりである。

          (file-name-sans-extension "foo.lose.c")
               => "foo.lose"
          (file-name-sans-extension "big.hack/foo")
               => "big.hack/foo"



File: elisp-ja.info, Node: Directory Names, Next: Relative File Names, Prev: File Name Components, Up: File Names

ディレクトリ名
--------------

"ディレクトリ名"（directory name）とはディレクトリの名前です。ディレクト
リはファイルの一種であり、ファイル名を持ちますが、それはディレクトリ名に
関連付けられますが同一ではありません。（これはUNIXの通常の用語と同じでは
ない。）同じものに対するこれらの異なる2つの名前は、構文の変換で関連付け
ます。UNIXではこれは簡単であり、ディレクトリ名はスラッシュで終りますが、
ファイルとしてのディレクトリの名前にはスラッシュはありません。VMSでは、
関係はより複雑です。

ディレクトリ名とそのファイルとしての名前との違いはわずかですが重大です。
Emacsの変数や関数引数がディレクトリ名と記述されているときには、ディレク
トリのファイルとしての名前は受け付けません。

つぎの2つの関数はディレクトリ名とファイルとしての名前を相互に変換します。
これらは、`$HOME'などの環境変数置換や`~'や`..'などの構造にはなにも特別な
ことはしません。

 -- Function: file-name-as-directory FILENAME
     この関数は、オペレーティングシステムがディレクトリ名と解釈する表現
     で表したFILENAMEの文字列を返す。UNIXでは、文字列に（最後にスラッシュ
     がなければ）スラッシュを付加することを意味する。VMSでは、
     `[X]Y.DIR.1'の形の文字列を`[X.Y]'の形に変換する。

          (file-name-as-directory "~rms/lewis")
               => "~rms/lewis/"

 -- Function: directory-file-name DIRNAME
     この関数は、オペレーティングシステムがファイルの名前と解釈する表現
     で表したDIRNAMEの文字列を返す。UNIXでは、文字列の最後のスラッシュを
     取り除くことを意味する。VMSでは、`[X.Y]'の形の文字列を`[X]Y.DIR.1'
     の形に変換する。

          (directory-file-name "~lewis/")
               => "~lewis"

シンボリックリンクを介して通常参照されるディレクトリにはディレクトリ名の
省略形が有用です。ユーザーはリンクの名前をディレクトリの『名前』としばし
ばみなし、ディレクトリの『本当の』名前を見るのをわずらわしく思うことがあ
ります。リンク名を『本当の』名前の省略形と定義しておくと、Emacsはユーザー
に省略形を表示します。

 -- Variable: directory-abbrev-alist
     変数`directory-abbrev-alist'は、ディレクトリに使う省略形の連想リス
     トを保持する。各要素は`(FROM . TO)'の形であり、ディレクトリ名にFROM
     が現れるとこれをTOに置き換えることを指示する。文字列FROMは実際には
     正規表現であり、つねに`^'で始まること。関数`abbreviate-file-name'が
     これらの置換を行う。

     ファイル`site-init.el'でこの変数に設定し、読者のサイトに適した省略
     形を記述できる。

     ファイルシステム`/home/fsf'などをシンボリック名`/fsf'で通常参照する
     システムの例をつぎに示す。

          (("^/home/fsf" . "/fsf")
           ("^/home/gp" . "/gp")
           ("^/home/gd" . "/gd"))

ディレクトリ名をその省略形に変換するには、つぎの関数を使います。

 -- Function: abbreviate-file-name DIRNAME
     この関数は、`directory-abbrev-alist'の省略形を引数に適用し、ユーザー
     のホームディレクトリを`~'に置き換える。



File: elisp-ja.info, Node: Relative File Names, Next: File Name Expansion, Prev: Directory Names, Up: File Names

ファイルの絶対名と相対名
------------------------

ファイルシステム内のすべてのディレクトリは、ルートディレクトリから始まる
木を形作ります。ファイル名では、木のルートから始まるすべてのディレクトリ
名を指定できて、これを"絶対"（absolute）ファイル名と呼びます。あるいは、
デフォルトディレクトリを基準に木の中でのファイルの位置を指定することもで
き、これを"相対"（relative）ファイル名と呼びます。UNIXでは、絶対ファイル
名はスラッシュかティルダ（`~'）で始まり、相対ファイル名はそれらでは始ま
りません。VMSでの規則は複雑です。

 -- Function: file-name-absolute-p FILENAME
     この関数は、ファイルFILENAMEが絶対ファイル名であれば`t'を返し、さも
     なければ`nil'を返す。VMS上では、この関数はUNIXの構文とVMSの構文の両
     方を理解する。

          (file-name-absolute-p "~rms/foo")
               => t
          (file-name-absolute-p "rms/foo")
               => nil
          (file-name-absolute-p "/user/rms/foo")
               => t



File: elisp-ja.info, Node: File Name Expansion, Next: Unique File Names, Prev: Relative File Names, Up: File Names

ファイル名を展開する関数
------------------------

ファイル名の"展開"（expansion）とは、相対ファイル名を絶対ファイル名に変
換することです。これはデフォルトディレクトリを基準に行うので、展開すべき
ファイル名に加えて、デフォルトディレクトリの名前も指定する必要があります。
また、展開では、`./'や`NAME/../'のような冗長部分を取り除いてファイル名を
単純にします。

 -- Function: expand-file-name FILENAME &optional DIRECTORY
     この関数はFILENAMEを絶対ファイル名に変換する。DIRECTORYが与えられる
     と、FILENAMEが相対ファイル名であれば、デフォルトディレクトリを基準
     にする。（DIRECTORYの値そのものは絶対ディレクトリ名であること。`~'
     で始まってもよい。）さもなければ、バッファの`default-directory'の値
     を使う。たとえばつぎのとおり。

          (expand-file-name "foo")
               => "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               => "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               => "/usr/spool/foo"
          (expand-file-name "$HOME/foo")
               => "/xcssun/users/rms/lewis/$HOME/foo"

     `.'や`..'を含むファイル名は、それらの正則な形に単純化する。

          (expand-file-name "bar/../foo")
               => "/xcssun/users/rms/lewis/foo"

     `expand-file-name'は環境変数を展開*しない*ことに注意。
     `substitute-in-file-name'だけがそれを行う。

 -- Function: file-relative-name FILENAME DIRECTORY
     この関数は展開の逆操作を行う。つまり、DIRECTORYを基準に解釈すると
     FILENAMEと等価になる相対名を返す。

     絶対ファイル名が装置名で始まるシステムもある。そのようなシステムで
     は、DIRECTORYとFILENAMEが2つの異なる装置名で始まると、FILENAMEに等
     価なDIRECTORYを基準にした相対名はない。そのような場合、
     `file-relative-name'は絶対名の形でFILENAMEを返す。

          (file-relative-name "/foo/bar" "/foo/")
               => "bar"
          (file-relative-name "/foo/bar" "/hack/")
               => "/foo/bar"

 -- Variable: default-directory
     このバッファローカルな変数の値は、カレントバッファのデフォルトディ
     レクトリである。これは絶対ディレクトリ名であること。`~'で始まっても
     よい。この変数は各バッファにおいてバッファローカルである。

     `expand-file-name'は、その第2引数が`nil'であるとデフォルトディレク
     トリを使う。

     UNIXでは、この値はつねにスラッシュで終る文字列である。

          default-directory
               => "/user/lewis/manual/"

 -- Function: substitute-in-file-name FILENAME
     この関数は、FILENAME内の環境変数の参照を環境変数の値で置き換える。
     UNIXのシェルの構文規則に従って、`$'は環境変数の値に置換するための接
     頭辞である。

     環境変数名は、`$'に続く（下線を含む）英数字の列である。`$'のつぎの
     文字が`{'であると、対応する`}'までが変数名である。

     ここでは、環境変数`HOME'はユーザーのホームディレクトリ名
     `/xcssun/users/rms'を保持していると仮定する。

          (substitute-in-file-name "$HOME/foo")
               => "/xcssun/users/rms/foo"

     置換後、`/'のつぎに`~'か`/'が現れると、`/'までの部分をすべて取り除
     く。

          (substitute-in-file-name "bar/~/foo")
               => "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               => "/xcssun/users/rms/foo"
               ;; `/usr/local/' has been discarded.

     VMSでは、`$'による置換は行わないため、この関数は冗長部分を取り除く
     以外にはなにも行わない。



File: elisp-ja.info, Node: Unique File Names, Next: File Name Completion, Prev: File Name Expansion, Up: File Names

一意なファイル名の生成
----------------------

一時的なファイルに書く必要があるプログラムもあります。そのようなファイル
向けの名前を作る通常の方法はつぎのとおりです。

     (make-temp-name
      (expand-file-name NAME-OF-APPLICATION
                        temporary-file-directory))

`make-temp-name'の仕事は、異なる2人のユーザーや異なる2つのジョブがまった
く同じファイル名を使わないようにすることです。この例では、変数
`temporary-file-directory'を使って一時的なファイルを置く場所を決めていま
す。すべてのEmacs Lispプログラムでは、すべての一時的なファイル向けのディ
レクトリを指定する一意な方法をユーザーに提供するために、この目的には
`temporary-file-directory'を使うべきです。

 -- Function: make-temp-name STRING
     この関数は、一意なファイル名として使える文字列を生成する。名前は
     STRINGで始まり、各Emacsジョブごとに異なる数を含む。

          (make-temp-name "/tmp/foo")
               => "/tmp/foo232J6v"

     同じEmacsで動作している異なるライブラリのあいだで衝突しないように、
     `make-temp-name'を使う各Lispプログラムでは、独自のSTRINGを使うべき
     である。STRINGの末尾に付加される数は、異なるEmacsジョブで動いている
     同じアプリケーションを区別する。文字を余計に追加することで、1つの
     Emacsジョブであっても異なる名前の個数を非常に多くできる。

 -- Variable: temporary-file-directory
     この変数は、一時的なファイルを作成するためのディレクトリ名を指定す
     る。その値はディレクトリ名（*Note Directory Names::）であるべきだが、
     Lispプログラムにとっては、その値がディレクトリのファイルとしての名
     前であっても処理できるほうがよい。この値を`expand-file-name'の第2引
     数に使うと、そのようにできる。

     デフォルト値は、読者のオペレーティングシステムにおいて合理的な方法
     で決定される。GNUとUNIXシステムでは、環境変数`TMP'や`TMPDIR'を基に
     する。

     読者が一時的なファイル名を選ぶために`make-temp-name'を使わない場合
     であっても、一時的なファイル名を置くディレクトリを決めるためにこの
     変数を使うべきである。



File: elisp-ja.info, Node: File Name Completion, Next: Standard File Names, Prev: Unique File Names, Up: File Names

ファイル名の補完
----------------

本節では、ファイル名の補完向けの低レベルのサブルーティンについて述べます。
他の補完関数については、*Note Completion::を参照してください。

 -- Function: file-name-all-completions PARTIAL-FILENAME DIRECTORY
     この関数は、ディレクトリDIRECTORYにおいてPARTIAL-FILENAMEで始まる名
     前のファイルに対するすべての補完候補から成るリストを返す。候補の順
     番はディレクトリ内でのファイルの順番であり、それは予測できず有用な
     情報はなにもない。

     引数PARTIAL-FILENAMEは、ディレクトリ部分やスラッシュをいっさい含ま
     ないファイル名であること。DIRECTORYが絶対名でないと、カレントバッファ
     のデフォルトディレクトリをDIRECTORYのまえに補う。

     つぎの例で、カレントデフォルトディレクトリは`~rms/lewis'であり、`f'
     で始まる名前のファイルは、`foo'、`file~'、`file.c'、`file.c.~1~'、
     `file.c.~2~'の5つであると仮定する。

          (file-name-all-completions "f" "")
               => ("foo" "file~" "file.c.~2~" 
                          "file.c.~1~" "file.c")

          (file-name-all-completions "fo" "")  
               => ("foo")

 -- Function: file-name-completion FILENAME DIRECTORY
     この関数は、ディレクトリDIRECTORYにおいてファイル名FILENAMEを補完す
     る。ディレクトリDIRECTORYにおいてFILENAMEで始まるすべてのファイル名
     に共通な最長の文字列を返す。

     FILENAMEで始まるものがたった1つであり完全に一致すると、この関数は
     `t'を返す。ディレクトリDIRECTORYにFILENAMEで始まる名前がないと`nil'
     を返す。

     つぎの例で、カレントデフォルトディレクトリには`f'で始まる名前のファ
     イルは、`foo'、`file~'、`file.c'、`file.c.~1~'、`file.c.~2~'の5つで
     あると仮定する。

          (file-name-completion "fi" "")
               => "file"

          (file-name-completion "file.c.~1" "")
               => "file.c.~1~"

          (file-name-completion "file.c.~1~" "")
               => t

          (file-name-completion "file.c.~3" "")
               => nil

 -- User Option: completion-ignored-extensions
     `file-name-completion'は、このリスト内のいずれかの文字列で終る名前
     のファイルを通常無視する。補完候補すべてがこれらの接頭辞の1つで終る
     場合や、補完候補すべてを含んだバッファが表示されている場合には無視
     しない。

     典型的な値はつぎのとおりである。

          completion-ignored-extensions
               => (".o" ".elc" "~" ".dvi")



File: elisp-ja.info, Node: Standard File Names, Prev: File Name Completion, Up: File Names

標準ファイル名
--------------

Lispプログラムで使われるほとんどのファイル名は、ユーザーが入力したもので
す。しかし、Lispプログラムでは、特定目的の標準ファイル名を指定する必要が
ある場合があります。典型的には、各ユーザーごとのカスタマイズ情報を保持す
るものです。たとえば、省略形の定義は（デフォルトでは）ファイル
`~/.abbrev_defs'に保存されます。パッケージ`completion'は、補完情報をファ
イル`~/.completions'に保存します。これらは、Emacsで特定目的に使われる多
くの標準ファイル名のうちの2つです。

さまざまなのオペレーティングシステムには、正しいファイル名やユーザーのプ
ロフィールデータに使うファイル名に独自の慣習があります。標準ファイル名を
使用するファイルを読み込むLispプログラムでは、各システムごとに当該システ
ムに適したファイル名を使うべきです。関数`convert-standard-filename'は、
これを簡単にします。

 -- Function: convert-standard-filename FILENAME
     この関数は、ファイル名FILENAMEを使用しているオペレーティングシステ
     ムの慣習に従うように変換し、新たな文字列として結果を返す。

Lispプログラムにおいて標準ファイル名を指定する推奨方法は、GNUとUNIXシス
テムの慣習に従った名前を選ぶことです。つまり、ピリオドで始まる非ディレク
トリ部分を選び、それを直接使うかわりに`convert-standard-filename'に渡し
ます。パッケージ`completion'からの例をつぎに示します。

     (defvar save-completions-file-name
             (convert-standard-filename "~/.completions")
       "*The file name to save completions to.")

GNUとUNIXシステム、および、他のいくつかのシステムでは、
`convert-standard-filename'は引数を未変更で返します。別のシステムでは、
システムの慣習に従うように名前を変更します。

たとえば、MS-DOSではこの関数は、先頭の`.'を`_'に、`.'がどこにもなければ
名前の途中の`_'を`.'に、8文字目のうしろに`.'がなければ`.'を挿入し、`.'以
降の3文字よりうしろを切り詰めるなどを行います。（これ以外にも変更する。）
したがって、`.abbrev_defs'は`_abbrev.def'となり、`.completions'は
`_complet.ion'となります。



File: elisp-ja.info, Node: Contents of Directories, Next: Create/Delete Dirs, Prev: File Names, Up: Files

ディレクトリの内容
==================

ディレクトリは、さまざまな名前で入れた別のファイルを収めているファイルの
一種です。ディレクトリは、ファイルシステムの機能です。

Emacsは、ディレクトリ内のファイル名をLispのリストとして一覧にしたり、シェ
ルコマンド`ls'を使ってバッファに名前を表示できます。後者の場合、コマンド
`ls'に渡したオプションに応じて、各ファイルに関する情報も表示できます。

 -- Function: directory-files DIRECTORY &optional FULL-NAME MATCH-REGEXP NOSORT
     この関数は、ディレクトリDIRECTORY内のファイルの名前から成るリストを
     返す。デフォルトでは、リストはアルファベット順になる。

     FULL-NAMEが`nil'以外であると、関数はファイルの絶対ファイル名を返す。
     さもなければ、指定したディレクトリに対する相対名を返す。

     MATCH-REGEXPが`nil'以外であると、この関数は正規表現MATCH-REGEXPに一
     致するファイル名のみを返す。つまり、他の名前のファイルはリストから
     除かれる。

     NOSORTが`nil'以外であると、`directory-files'はリストをソートしない
     ので、ファイル名の順番に規則はない。処理速度を最大にしてファイルの
     処理順序に拘らないならば、これを用いる。処理順序がユーザーに見える
     場合には、ソートしたほうがユーザーは幸せであろう。

          (directory-files "~lewis")
               => ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi" 
                   "files.texi.~1~")

     DIRECTORYが読めないディレクトリの名前であるとエラーを通知する。

 -- Function: file-name-all-versions FILE DIRNAME
     この関数は、ディレクトリDIRNAME内のFILEという名前のファイルのすべて
     の版から成るリストを返す。

 -- Function: insert-directory FILE SWITCHES &optional WILDCARD FULL-DIRECTORY-P
     この関数は、`ls'にSWITCHESを渡して表示したディレクトリFILEの一覧を
     （カレントバッファに）挿入する。ポイントは挿入したテキストのうしろ
     に置かれる。

     引数FILEは、ディレクトリ名であるかワイルドカードを含んだファイル指
     定である。WILDCARDが`nil'以外であると、FILEをワイルドカードを含むファ
     イル指定として扱う。

     FULL-DIRECTORY-Pが`nil'以外であると、ディレクトリ一覧はディレクトリ
     の全内容を表すと仮定することを意味する。FILEがディレクトリであり
     SWITCHESに`-d'を含まない場合には、`t'を指定すべきである。（`ls'のオ
     プション`-d'は、ディレクトリの内容ではなく、ファイルとしてのディレ
     クトリ自身を表示することを意味する。）

     この関数は、変数`insert-directory-program'で指定される名前のディレ
     クトリ表示プログラムを実行して動作する。WILDCARDが`nil'以外であると、
     ワイルドカードを展開するために`shell-file-name'で指定されるシェルを
     実行する。

 -- Variable: insert-directory-program
     この変数の値は、関数`insert-directory'でディレクトリ一覧を生成する
     ために実行するプログラムである。



File: elisp-ja.info, Node: Create/Delete Dirs, Next: Magic File Names, Prev: Contents of Directories, Up: Files

ディレクトリの作成と削除
========================

Emacs Lispのほとんどのファイル操作関数は、ディレクトリであるファイルに使
うとエラーになります。たとえば、`delete-file'ではディレクトリを削除でき
ません。これらの特別な関数はディレクトリを作成したり削除するためのもので
す。

 -- Function: make-directory DIRNAME
     この関数はDIRNAMEという名前のディレクトリを作る。

 -- Function: delete-directory DIRNAME
     この関数は、ディレクトリDIRNAMEを削除する。関数`delete-file'は、ディ
     レクトリであるファイルには使えない。ディレクトリには
     `delete-directory'を使う必要がある。ディレクトリ内にファイルがある
     と、`delete-directory'はエラーを通知する。



File: elisp-ja.info, Node: Magic File Names, Next: Format Conversion, Prev: Create/Delete Dirs, Up: Files

ファイル名を『マジック』にする
==============================

特定のファイル名を特別に扱うことができます。これをそれらの名前を"マジッ
ク"（magic）にするといいます。この機能の主な用途はリモートファイル名
（*Note リモートファイル: (emacs)Remote Files.）を実装することです。

マジックファイル名の種類を定義するには、名前のクラス（正規表現に一致する
ものすべて）を定義する正規表現と、それに一致するファイルに対するEmacsの
基本ファイル操作を実装するハンドラを指定する必要があります。

変数`file-name-handler-alist'は、ハンドラと当該ハンドラの適用を決定する
正規表現からなるリストを保持します。各要素の形はつぎのとおりです。

     (REGEXP . HANDLER)

Emacsのすべてのファイル操作基本関数とファイル名変換基本関数は、指定され
た名前を`file-name-handler-alist'に対して検査します。ファイル名がREGEXP
に一致すると、基本関数はHANDLERを呼び出して当該ファイルを処理します。

HANDLERに与える最初の引数は基本関数の名前です。残りの引数は当該操作に渡
されるべき引数です。（それらの引数の最初のものは典型的にはファイル名自身
である。）たとえば、つぎのようにした場合、

     (file-exists-p FILENAME)

FILENAMEにハンドラHANDLERがあると、HANDLERはつぎのように呼び出されます。

     (funcall HANDLER 'file-exists-p FILENAME)

つぎは、マジックファイル名のハンドラが処理すべき操作です。

`add-name-to-file'、`copy-file'、`delete-directory'、
`delete-file'、
`diff-latest-backup-file'、
`directory-file-name'、
`directory-files'、
`dired-call-process'、
`dired-compress-file'、`dired-uncache'、
`expand-file-name'、
`file-accessible-directory-p'、
`file-attributes'、
`file-directory-p'、
`file-executable-p'、`file-exists-p'、
`file-local-copy'、
`file-modes'、`file-name-all-completions'，
`file-name-as-directory'、
`file-name-completion'、
`file-name-directory'、
`file-name-nondirectory'、
`file-name-sans-versions'、`file-newer-than-file-p'、
`file-ownership-preserved-p'、
`file-readable-p'、`file-regular-p'、`file-symlink-p'、
`file-truename'、`file-writable-p'、
`find-backup-file-name'、
`get-file-buffer'、
`insert-directory'、
`insert-file-contents'、
`load', `make-directory'、
`make-symbolic-link'、`rename-file'、`set-file-modes'、
`set-visited-file-modtime'、`shell-command'、
`unhandled-file-name-directory'、
`vc-registered'、
`verify-visited-file-modtime'、
`write-region'。

`insert-file-contents'に対するハンドラは、引数VISITが`nil'以外であるとき
には`(set-buffer-modified-p nil)'を使ってバッファの変更フラグをクリアす
る必要が典型的にはあります。

ハンドラ関数は、上のすべての操作、ならびに、将来追加されるものを扱える必
要があります。これらの操作すべてをハンドラ自身で実装する必要はありません。
特定の操作について特別なことを行う必要がなければ、『通常どおりに』操作を
処理するために基本関数を再起動できます。ハンドラが認識できない操作につい
ては、基本関数を再起動するべきです。1つの方法はつぎのとおりです。

     (defun my-file-handler (operation &rest args)
       ;; まず、特別に扱う必要がある操作かどうか検査する
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; 知らない操作を扱う
             (t (let ((inhibit-file-name-handlers
                       (cons 'my-file-handler 
                             (and (eq inhibit-file-name-operation operation)
                                  inhibit-file-name-handlers)))
                      (inhibit-file-name-operation operation))
                  (apply operation args)))))

ハンドラ関数で、指定された操作についてはEmacsの通常の基本関数を呼び出す
と決定したときには、基本関数から同じハンドラが再度呼ばれて無限再帰になる
ことを防ぐ必要があります。上の例は、変数`inhibit-file-name-handlers'と
`inhibit-file-name-operation'を使ってこれを行う方法を示すものです。それ
らを上に示したとおりに使うように注意してください。複数のハンドラがあった
り、2つのファイルを扱う操作において各ファイルにハンドラがある場合には、
この詳細は重要です。

 -- Variable: inhibit-file-name-handlers
     この変数は、特定操作については現在適用を禁止されているハンドラのリ
     ストを保持する。

 -- Variable: inhibit-file-name-operation
     特定のハンドラにおいて現在禁止されている操作。

 -- Function: find-file-name-handler FILE OPERATION
     この関数はファイル名FILEに対するハンドラ関数を返す。ハンドラがなけ
     れば`nil'を返す。引数OPERATIONは、ファイルに対して適用する操作であ
     ること。つまり、ハンドラを呼び出すときに第1引数として渡される値。当
     該操作は`inhibit-file-name-operation'と比較する必要がある。

 -- Function: file-local-copy FILENAME
     この関数は、ファイルFILENAMEがマジックでない普通のファイルでなけれ
     ば、FILENAMEをマジックでない普通のファイルにコピーする。

     FILENAMEが、Emacsの外側のプログラムからは直接読んだり書けないマジッ
     クファイル名であると、この関数は普通のファイルにコピーしてそのファ
     イルの名前を返す。

     FILENAMEが普通のファイル名でマジックでなければ、この関数はなにもせ
     ずに`nil'を返す。

 -- Function: unhandled-file-name-directory FILENAME
     この関数は、マジックではないディレクトリの名前を返す。FILENAMEがマ
     ジックでなければ、FILENAMEのディレクトリ部分を使う。マジックファイ
     ル名であると、ファイル名ハンドラを起動し、当該ハンドラがどんな値を
     返すか決定する。

     これは実行中のサブプロセスに有用である。各サブプロセスには、カレン
     トディレクトリとしてマジックでないディレクトリが必要であり、この関
     数はそれを扱うのによい方法である。



File: elisp-ja.info, Node: Format Conversion, Prev: Magic File Names, Up: Files

ファイル書式変換
================

変数`format-alist'は、Emacsバッファ内のデータ（テキスト、テキスト属性、
その他の情報）をファイル内でテキスト表現する方法を記述した"ファイル書式"
（file format）のリストを定義します。Emacsはファイルを読み書きするときに
必要ならば書式変換を行います。

 -- Variable: format-alist
     このリストは、各ファイル書式の定義を含んだリストである。

各書式定義はつぎの形のリストです。

     (NAME DOC-STRING REGEXP FROM-FN TO-FN MODIFY MODE-FN)

書式定義の各要素の意味はつぎのとおりです。

NAME
     当該書式の名前。

DOC-STRING
     当該書式の説明文字列。

REGEXP
     当該書式で表現されたファイルを認識するために使用する正規表現。

FROM-FN
     当該書式のデータを復号化（ファイル内のデータをEmacsの通常のデータ表
     現へ変換）するためのシェルコマンドか関数。

     シェルコマンドは文字列で表現し、Emacsは変換を行うために当該コマンド
     をフィルタとして実行する。

     FROM-FNが関数であると、バッファの変換すべき部分を指定するBEGINとEND
     の2つの引数で呼ばれる。当該関数はその場で編集してテキストを変換する
     こと。これによりテキストの長さが変わる可能性があるので、FROM-FNは変
     更部分の末尾位置を返すこと。

     FROM-FNの責任の1つは、ファイルの先頭がREGEXPで始まらないように保証
     することである。さもないと、再度呼び出される可能性がある。

TO-FN
     当該書式にデータを符号化するためのシェルコマンドか関数。つまり、
     Emacsの通常のデータ表現を当該書式に変換する。

     TO-FNが文字列であるとそれはシェルコマンドであり、Emacsは変換を行う
     ために当該コマンドをフィルタとして実行する。

     TO-FNが関数であると、バッファの変換すべき部分を指定するBEGINとENDの
     2つの引数で呼ばれる。変換を行うには2つの方法がある。

        * その場でバッファを編集する。この場合、TO-FNは変更したテキスト
          範囲の終了位置を返すこと。

        * 注記のリストを返す。このリストは、`(POSITION . STRING)'の形の
          要素から成り、POSITIONは書き出すべきテキスト内での相対位置を指
          定する整数、STRINGはそこに追加すべき注記である。TO-FNがリスト
          を返すときには、リストはPOSITIONの順にソートしてあること。

          `write-region'がバッファからファイルへ実際に書き出すとき、指定
          された注記を対応する位置に埋め込む。これらすべては、バッファを
          変更せずに行われる。

MODIFY
     フラグであり、符号化関数がバッファを変更する場合には`t'、注記のリス
     トを返す場合には`nil'である。

MODE
     当該書式から変換されたファイルを訪問後に呼び出されるモード関数。

関数`insert-file-contents'は、指定されたファイルを読み込むときにファイル
書式を自動的に認識します。ファイルの先頭のテキストを書式定義の正規表現に
対して検査して、一致がみつかれば当該書式の復号化関数を呼び出します。そし
て、既知の書式について再度調べ直します。適用できる書式がなくなるまで検査
し続けます。

関数`find-file-noselect'やこれを使うコマンドでファイルを訪問すると、
（`insert-file-contents'を呼び出すので）同様に変換を行います。さらに、こ
の関数は、復号した各書式についてモード関数を呼び出します。バッファローカ
ルな変数`buffer-file-format'に書式名のリストを保存します。

 -- Variable: buffer-file-format
     この変数は、訪問したファイルの書式を記述している。より正確には、カ
     レントバッファのファイルを訪問する過程で復号したファイル書式名のリ
     ストである。この変数は、すべてのバッファにおいてつねにバッファロー
     カルである。

`write-region'がデータをファイルに書き出すときには、まず、
`buffer-file-format'で指定された書式の符号化関数をリストに現れる順に呼び
出します。

 -- コマンド: format-write-file FILE FORMAT
     このコマンドは、カレントバッファの内容を書式FORMATにてファイルFILE
     に書き出す。さらに、当該書式をバッファを将来保存するときのデフォル
     トとする。引数FORMATは、書式名のリストである。

 -- コマンド: format-find-file FILE FORMAT
     このコマンドは、ファイルFILEを探し、それを書式FORMATに従って変換す
     る。さらに、当該書式をバッファをのちに保存するときのデフォルトとす
     る。

     引数FORMATは、書式名のリストである。FORMATが`nil'であると、変換を行
     わない。対話的に呼び出した場合、FORMATに`nil'を指定するにはRETのみ
     を打つ。

 -- コマンド: format-insert-file FILE FORMAT &optional BEG END
     このコマンドは、ファイルFILEの内容を書式FORMATに従って変換して挿入
     する。BEGとENDが`nil'以外であると、それらは、`insert-file-contents'
     （*Note Reading from Files::）と同様に、読み込むべきファイルの部分
     を指定する。

     戻り値は、`insert-file-contents'が返す値に似ており、絶対ファイル名
     と挿入データの（変換後の）長さのリストである。

     引数FORMATは、書式名のリストである。FORMATが`nil'であると、変換を行
     わない。対話的に呼び出した場合、FORMATに`nil'を指定するにはRETのみ
     を打つ。

 -- Variable: auto-save-file-format
     この変数は、自動保存に対して使用する書式を指定する。その値は、
     `buffer-file-format'の値のように、書式名のリストであるが、
     `buffer-file-format'のかわりに自動保存ファイルを書くために使われる。
     この変数は、すべてのバッファにおいてつねにバッファローカルである。



File: elisp-ja.info, Node: Backups and Auto-Saving, Next: Buffers, Prev: Files, Up: Top

バックアップと自動保存
**********************

バックアップファイルと自動保存ファイルは、クラッシュやユーザー自身の誤り
からEmacsがユーザーを保護するための2つの方式です。自動保存により、現在の
編集セッションにおいて、まえの時点でのテキストを確保します。バックアップ
ファイルにより、現在のセッション以前のファイル内容を確保します。

* Menu:

* Backup Files::   How backup files are made; how their names are chosen.
* Auto-Saving::    How auto-save files are made; how their names are chosen.
* Reverting::      `revert-buffer', and how to customize what it does.



File: elisp-ja.info, Node: Backup Files, Next: Auto-Saving, Prev: Backups and Auto-Saving, Up: Backups and Auto-Saving

バックアップファイル
====================

"バックアップファイル"（backup file）とは、読者が編集中のファイルの古い
内容のコピーです。バッファを訪問しているファイルに初めて保存するときに、
Emacsはバックアップファイルを作成します。通常これは、バックアップファイ
ルは現在の編集セッションよりまえのファイルの内容を保持することを意味しま
す。バックアップファイルの内容は、通常、それが作られると変更されません。

訪問したファイルを新たな名前に改名することで通常バックアップは作られます。
訪問したファイルをコピーしてバックアップファイルを作るように指示すること
もできます。どちらを選ぶかによって、複数の名前を持つファイルでは違いがで
ます。また、編集したファイルの所有者が元所有者と同じであるか、それとも編
集したユーザーが所有者になるかにも影響します。

デフォルトでは、Emacsは各編集ファイルに1つのバックアップファイルを作りま
す。番号付きのバックアップファイルを作るように指示することもでき、そうす
ると、新たなバックアップファイルごとに新たな名前が付きます。古い番号付き
バックアップファイルは必要なくなれば削除できますし、Emacsがそれらを自動
的に削除することも可能です。

* Menu:

* Making Backups::     How Emacs makes backup files, and when.
* Rename or Copy::     Two alternatives: renaming the old file or copying it.
* Numbered Backups::   Keeping multiple backups for each source file.
* Backup Names::       How backup file names are computed; customization.



File: elisp-ja.info, Node: Making Backups, Next: Rename or Copy, Prev: Backup Files, Up: Backup Files

バックアップファイルの作成
--------------------------

 -- Function: backup-buffer
     この関数は、必要ならば、カレントバッファで訪問しているファイルのバッ
     クアップを作成する。バッファを初めて保存するまえに`save-buffer'がこ
     の関数を呼び出す。

 -- Variable: buffer-backed-up
     このバッファローカルな変数は、当該バッファのもとで当該バッファのファ
     イルのバックアップを作成済みかどうかを表す。`nil'以外であれば、バッ
     クアップファイルは作成済みであることを表す。さもなければ、（バック
     アップがオンになっていれば）つぎに保存するときにファイルのバックアッ
     プを作成するべきであることを表す。これは恒久的にバッファローカルで
     あり、`kill-local-variables'によって変更されない。

 -- User Option: make-backup-files
     この変数は、バックアップファイルを作成するかどうかを決定する。`nil'
     以外であると、`backup-inhibited'が`nil'ならば（下記参照）Emacsは初
     めて保存するときに各ファイルのバックアップを作成する。

     つぎの例は、rmailのバッファでのみ変数`make-backup-files'を変更する
     方法である。この変数を`nil'にすると、Emacsはそれらのファイルのバッ
     クアップを作成しなくなり、ディスクスペースの節約になる。（このコー
     ドを読者のファイル`.emacs'に入れてもよい。）

          (add-hook 'rmail-mode-hook 
                    (function (lambda ()
                                (make-local-variable 
                                 'make-backup-files)
                                (setq make-backup-files nil))))

 -- Variable: backup-enable-predicate
     この変数の値は、ファイルをバックアップすべきかどうかを決定するため
     に特定の場面で呼び出される関数である。当該関数は、調べるべきファイ
     ルの名前を引数にとる。当該関数が`nil'を返すと、当該ファイルのバック
     アップは禁止である。さもなければ、本節の他の変数が、バックアップす
     るかどうかやバックアップ方法を指定する。

     デフォルト値はつぎのとおりである。

          (lambda (name)
            (or (< (length name) 5)
                (not (string-equal "/tmp/"
                                   (substring name 0 5)))))

 -- Variable: backup-inhibited
     この変数が`nil'以外であると、バックアップを禁止する。この変数は、訪
     問したファイルの名前に対する`backup-enable-predicate'の検査結果を記
     録している。訪問したファイルに基づいてバックアップを禁止する他の機
     構でもこの変数を使える。たとえば、VCはこの変数に`nil'以外を設定し、
     版管理システムで管理されているファイルに対してバックアップの作成を
     禁止する。

     これは恒久的にバッファローカルであり、メジャーモードを変更しても値
     は失われない。メジャーモードはこの変数に設定するべきではなく、かわ
     りに、`make-backup-files'に設定するべきである。



File: elisp-ja.info, Node: Rename or Copy, Next: Numbered Backups, Prev: Making Backups, Up: Backup Files

改名によるバックアップかコピーによるバックアップか
--------------------------------------------------

Emacsは2つの方法でバックアップファイルを作れます。

   * Emacsは、元ファイルを改名してバックアップファイルとしてから、保存す
     べきバッファを新たなファイルに書き出す。この処理のあとでは、元ファ
     イルの他の名前（つまりハードリンク）はバックアップファイルを指す。
     新たなファイルの所有者は編集しているユーザーになり、そのグループは
     当該ディレクトリでユーザーが新規にファイルを書いた場合のデフォルト
     である。

   * Emacsは元ファイルをバックアップファイルにコピーしてから、元ファイル
     を新たな内容で上書きする。この処理のあとでは、元ファイルの他の名前
     （つまりハードリンク）はファイルの（更新した）現在の版を指し続ける。
     ファイルの所有者とグループは変わらない。

最初の改名による方式がデフォルトです。

変数`backup-by-copying'が`nil'以外であると、2番目の方式、つまり、元ファ
イルをコピーしてからバッファの新たな内容で上書きすることを指示します。変
数`file-precious-flag'が`nil'以外であっても（その主目的の副作用として）
同じ効果があります。*Note Saving Buffers::。

 -- Variable: backup-by-copying
     この変数が`nil'以外であると、Emacsはつねにコピーしてバックアップファ
     イルを作る。

つぎの2つの変数が`nil'以外であると、特定の場面では2番目の方式を使うこと
になります。これらの変数は、特別な場面に該当しないファイルの扱い方には影
響しません。

 -- Variable: backup-by-copying-when-linked
     この変数が`nil'以外の場合、Emacsは、複数の名前（ハードリンク）を持
     つファイルはコピーしてバックアップする。

     この変数は`backup-by-copying'が`nil'以外の場合にのみ意味を持つ。と
     いうのは、その変数が`nil'以外の場合にコピーを用いるからである。

 -- Variable: backup-by-copying-when-mismatch
     この変数が`nil'以外の場合、Emacsは、改名するとファイルの所有者やグ
     ループを変更してしまう場合にコピーしてバックアップする。

     改名してもファイルの所有者やグループを変更しなければ、この値は効果
     を持たない。つまり、ユーザーが所有しているファイルであり、そのグルー
     プが当該ユーザーが新規作成するファイルのデフォルトに一致する場合で
     ある。

     この変数は`backup-by-copying'が`nil'以外の場合にのみ意味を持つ。と
     いうのは、その変数が`nil'以外の場合にコピーを用いるからである。



