Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Visibility of Frames, Next: Raising and Lowering, Prev: Input Focus, Up: Frames

フレームの可視性
================

ウィンドウフレームは、"可視"、"不可視"、"アイコンになっている"のいずれか
です。フレームが可視であると、その内容を見ることができます。アイコンになっ
ているとフレームの内容はスクリーンで見えませんが、アイコンは見えます。フ
レームが不可視であると、それはスクリーン上に見えずアイコンでもありません。

端末フレームは選択されているものだけが表示されるので、端末フレームでは可
視性は意味がありません。

 -- コマンド: make-frame-visible &optional FRAME
     この関数は、フレームFRAMEを可視にする。FRAMEを省略すると、選択され
     ているフレームを可視にする。

 -- コマンド: make-frame-invisible &optional FRAME
     この関数は、フレームFRAMEを不可視にする。FRAMEを省略すると、選択さ
     れているフレームを不可視にする。

 -- コマンド: iconify-frame &optional FRAME
     この関数は、フレームFRAMEをアイコンにする。FRAMEを省略すると、選択
     されているフレームをアイコンにする。

 -- Function: frame-visible-p FRAME
     この関数は、フレームFRAMEの可視性を返す。その値は、FRAMEが可視なら
     ば`t'、不可視ならば`nil'、アイコンになっていれば`icon'である。

フレームの可視性は、フレームパラメータとしても得られます。フレームパラメー
タとして読んだり変更できます。*Note Window Frame Parameters::。

ユーザーは、ウィンドウマネージャを用いてフレームをアイコンにしたりアイコ
ンを開けます。これは、Emacsが制御できるレベルよりしたで行われますが、
Emacsはそのような変更を追跡できるようにイベントを提供します。*Note Misc
Events::。



File: elisp-ja.info, Node: Raising and Lowering, Next: Frame Configurations, Prev: Visibility of Frames, Up: Frames

フレームを手前にしたり奥へ置く
==============================

ほとんどのウィンドウシステムでは、机のたとえを使います。つまり、スクリー
ンの面に垂直な方向を概念的な3軸目と考えて、ウィンドウは積み重なっていて、
もっとも手前からもっとも奥に順序がついています。2つのウィンドウが重なり
合っているところでは、手前のものがそのしたのものを隠しています。もっとも
奥にあるウィンドウであっても、それに重なるウィンドウがなければ見ることが
できます。

ウィンドウのこのような順序は固定されていません。実際、ユーザーは順序を頻
繁に変更します。ウィンドウを"手前に置く"（raising）とは、ウィンドウを積
み重ねのもっとも上に移動することです。ウィンドウを"奥に置く"（lowering）
とは、ウィンドウを積み重ねのもっとも下に移動することです。この移動は概念
的な3軸目に限り、スクリーン上でのウィンドウの位置は変えません。

Emacsのフレームを表すウィンドウは、つぎの関数で手前へ置いたり奥へ置けま
す。

 -- コマンド: raise-frame &optional FRAME
     この関数は、フレームFRAMEを手前に置く（デフォルトは選択されているフ
     レーム）。

 -- コマンド: lower-frame &optional FRAME
     この関数は、フレームFRAMEを奥に置く（デフォルトは選択されているフレー
     ム）。

 -- User Option: minibuffer-auto-raise
     これが`nil'以外であると、ミニバッファが活性になるとミニバッファ用ウィ
     ンドウがあるフレームを手前に置く。

フレームパラメータを使うと、フレームが選択されると自動的に手前に置いたり
（`auto-raise'）、選択を止めると奥へ置け（`auto-lower'）ます。*Note
Window Frame Parameters::。



File: elisp-ja.info, Node: Frame Configurations, Next: Mouse Tracking, Prev: Raising and Lowering, Up: Frames

フレーム構成
============

"フレーム構成"（frame configuration）は、現在のフレームの配置、それらの
すべての属性、それぞれのウィンドウ構成を記録したものです。（*Note Window
Configurations::。）

 -- Function: current-frame-configuration
     この関数は、現在のフレームの配置とそれらの内容を記述したフレーム構
     成のリストを返す。

 -- Function: set-frame-configuration CONFIGURATION
     この関数は、CONFIGURATIONで記述されたフレームの状態に復元する。



File: elisp-ja.info, Node: Mouse Tracking, Next: Mouse Position, Prev: Frame Configurations, Up: Frames

マウスの追跡
============

マウスを"追跡"（track）できると有用なことがあります。つまり、マウスがど
こにあるかを表す指示子を表示してマウスの移動に従って指示子を動かすのです。
効率よくマウスを追跡するには、マウスが実際に移動するまで待つ手段が必要で
す。

マウスを追跡する便利な方法は、マウスの移動を表すイベントを待つことです。
そうすれば、そのようなイベントを待てばマウスの移動を待てます。さらに、発
生しうるそれ以外の種類のイベントを扱うのも簡単です。普通はマウスを永遠に
追跡し続けたいのではなくボタンを離すなどの別のイベントを待ちたいのでしょ
うから、これは有用です。

 -- Special form: track-mouse BODY...
     このスペシャルフォームは、マウスモーションイベントを生成するように
     してBODYを実行する。典型的にはBODYでは`read-event'を使ってモーショ
     ンイベントを読み、それに従って表示を変更する。マウスモーションイベ
     ントの形式については、*Note Motion Events::。

     `track-mouse'の値はBODYの最後のフォームの値である。BODYは、ボタンを
     離したことを表すイベントや追跡を終えるべきイベントに出会うと戻るよ
     うに設計すること。

マウスの移動を追跡する普通の目的は、現在の位置でボタンを押したり離すとな
にが起こるかをスクリーン上に示すことです。

多くの場面では、テキスト属性`mouse-face'（*Note Special Properties::）を
使えば、マウスを追跡する必要はなくなります。これはとても低いレベルで動作
し、Lispレベルでマウスを追跡するより滑らかに動作します。




File: elisp-ja.info, Node: Mouse Position, Next: Pop-Up Menus, Prev: Mouse Tracking, Up: Frames

マウスの位置
============

関数`mouse-position'と`set-mouse-position'で、マウスの現在位置を参照でき
ます。

 -- Function: mouse-position
     この関数は、マウスの位置を表すものを返す。その値は`(FRAME X . Y)'の
     形であり、XとYはフレームFRAMEの内側の左上隅を基準にした文字数で数え
     た位置を表す整数である。

 -- Function: set-mouse-position FRAME X Y
     この関数は、フレームFRAME内でXとYの位置にマウスを移動する。引数XとY
     は整数であり、フレームFRAMEの内側の左上隅を基準にした文字数で数えた
     位置である。FRAMEが不可視であると、この関数はなにもしない。戻り値に
     は意味はない。

 -- Function: mouse-pixel-position
     この関数は`mouse-position'に似ているが、文字単位ではなくピクセル単
     位で座標を返す。

 -- Function: set-mouse-pixel-position FRAME X Y
     この関数は`set-mouse-position'のようにマウスを移動するが、XとYは文
     字単位でなくピクセル単位である。これらの座標はフレームの内側にある
     必要はない。

     FRAMEが不可視であると、この関数はなにもしない。戻り値には意味はない。




File: elisp-ja.info, Node: Pop-Up Menus, Next: Dialog Boxes, Prev: Mouse Position, Up: Frames

ポップアップメニュー
====================

ウィンドウシステムを使っているときには、ユーザーがマウスで選択できるよう
にLispプログラムからメニューをポップアップできます。

 -- Function: x-popup-menu POSITION MENU
     この関数はポップアップメニューを表示し、ユーザーが行った選択を表す
     指示子を返す。

     引数POSITIONは、スクリーンのどこにメニューを置くかを指定する。それ
     はマウスのボタンイベント（ユーザーがボタンを押した場所にメニューを
     置く）かつぎの形のリストでもよい。

          ((XOFFSET YOFFSET) WINDOW)

     ここで、XOFFSETとYOFFSETはウィンドウWINDOWのフレームの左上隅から測っ
     たピクセル単位の座標である。

     POSITIONが`t'であるとマウスの現在位置を使うことを意味する。POSITION
     が`nil'であると、メニューを実際には表示せずに、MENUに指定してあるキー
     マップに等価なキーバインディングをあらかじめ計算することを意味する。

     引数MENUは、メニューに表示するものを指定する。それはキーマップかキー
     マップのリストである（*Note Menu Keymaps::）。あるいは、つぎの形で
     もよい。

          (TITLE PANE1 PANE2...)

     ここで、各ペインはつぎの形のリストである。

          (TITLE (LINE . ITEM)...)

     各LINEは文字列であり、各ITEMは対応するLINEが選ばれたときに返される
     値であること。

*使用上の注意：*` ' メニューキーマップで定義したプレフィックスキーででき
ることには、メニューを表示するために`x-popup-menu'を使わないこと。メニュー
キーマップを使ってメニューを実装すると、`C-h c'や`C-h a'で当該メニューの
個々の項目を見ることができ、それらに対するヘルプを提供できる。
`x-popup-menu'を呼び出すコマンドを定義してメニューを実装すると、ヘルプ機
能には当該コマンドの内側でなにがなされるかわからないので、メニューの項目
に対するヘルプを提供できない。

マウスの移動でサブメニューを切り替えられるメニューバーの機構では、
`x-popup-menu'を呼び出すコマンドの定義を調べられません。したがって、
`x-popup-menu'を使ってサブメニューを実装すると、それらはメニューバーに適
応した動作をできません。このために、メニューバーのすべてのサブメニューは、
親メニュー内のメニューキーマップとして実装してあり、`x-popup-menu'は使っ
ていません。*Note Menu Bar::。

メニューバーに内容が変化するサブメニューを使いたいときでも、メニューキー
マップを使って実装するべきです。内容を変えるには、必要に応じてメニューキー
の内容を更新するために`menu-bar-update-hook'にフック関数を追加します。



File: elisp-ja.info, Node: Dialog Boxes, Next: Pointer Shapes, Prev: Pop-Up Menus, Up: Frames

対話ボックス
============

対話ボックスはポップアップメニューの変形です。少々異なって見えますが、フ
レームの中央につねに現れ、たった1つのレベルで1つのペインです。対話ボック
スの主な用途は、ユーザーが『yes』、『no』、および他の少数の選択肢で答え
るような問い合わせを行うためです。関数`y-or-n-p'と`yes-or-no-p'は、マウ
スクリックで起動されたコマンドから呼ばれるとキーボードではなく対話ボック
スを使います。

 -- Function: x-popup-dialog POSITION CONTENTS
     この関数は、対話ボックスを表示し、ユーザーが選んだ選択肢を表す指示
     子を返す。引数CONTENTSは表示する選択肢を指定し、つぎの形である。

          (TITLE (STRING . VALUE)...)

     これは、`x-popup-menu'に対して単一のペインを指定するリストに似てい
     る。

     戻り値は、選ばれた選択肢のVALUEである。

     リストの要素は、`(STRING . VALUE)'の形のコンスセルのかわりに単に文
     字列でもよい。そうすると、対話ボックスでは選択できなくなる。

     リストに`nil'が現れると、それは左側の項目と右側の項目を区切る。
     `nil'のまえの項目は左側に現れ、`nil'に続く項目は右側に現れる。リス
     トに`nil'を含めなければ、項目のほぼ半分がそれぞれの側に現れる。

     対話ボックスはフレームの中央につねに現れ、引数POSITIONはそのフレー
     ムを指定する。可能な値は`x-popup-menu'と同様であるが、正確な座標は
     関係なくフレームだけが意味を持つ。

     場合によっては、Emacsは本当の対話ボックスを表示できない。そのときに
     はフレームの中央にポップアップメニューで同じ項目を表示する。



File: elisp-ja.info, Node: Pointer Shapes, Next: Window System Selections, Prev: Dialog Boxes, Up: Frames

ポインタの形状
==============

これらの変数は、Xウィンドウシステムを使っているときにさまざまな場面で使
用するマウスポインタの形状を指定します。

`x-pointer-shape'
     この変数は、Emacsのフレーム内で普通に使うポインタ形状を指定する。

`x-sensitive-text-pointer-shape'
     この変数は、マウスに反応するテキスト上にマウスがあるときに使用する
     ポインタ形状を指定する。

これらの変数は、新たに作成したフレームに影響します。既存のフレームには通
常は影響しません。しかし、フレームのマウスの表示色を設定すると、これらの
変数の現在値に基づいてポインタ形状も更新します。*Note Window Frame
Parameters::。

これらのポインタ形状の指定に使える値は、ファイル`lisp/term/x-win.el'で定
義してあります。それらの一覧を見るには`M-x apropos RET x-pointer RET'を
使います。



File: elisp-ja.info, Node: Window System Selections, Next: Font Names, Prev: Pointer Shapes, Up: Frames

ウィンドウシステムのセレクション
================================

Xサーバーは、アプリケーションプログラムのあいだでデータを転送するための"
セレクション"（selection）の集まりを記録します。さまざまなセレクションは、
Emacsではシンボルで表した"セレクション型"（selection type）で区別されま
す。Emacsを含むXクライアントは、任意の型のセレクションを読んだり設定でき
ます。

 -- Function: x-set-selection TYPE DATA
     この関数は、Xサーバーに『セレクション』を設定する。これは2つの引数、
     セレクション型TYPEとそれに割り当てる値DATAを取る。DATAが`nil'である
     と、当該セレクションを削除することを意味する。さもなければDATAは、
     文字列、整数（あるいは2つの数のコンスセルかリスト）、オーバレイ、同
     じバッファを指す2つのマーカのコンスセルのいずれかである。オーバレイ
     やマーカの対は、オーバレイのテキストやマーカのあいだのテキストを表
     す。

     引数DATAは、ベクトルではない正しいセレクション値のベクトルでもよい。

     可能な各TYPEには型に依存した独自のセレクション値がある。TYPEの普通
     の値は`PRIMARY'か`SECONDARY'である。これらのシンボルは、Xウィンドウ
     システムの慣習に従って大文字の名前である。デフォルトは`PRIMARY'であ
     る。

 -- Function: x-get-selection &optional TYPE DATA-TYPE
     この関数は、Emacsや他のXクライアントが設定したセレクションを参照す
     る。これは2つの引数、TYPEとDATA-TYPEを取る。セレクション型TYPEのデ
     フォルトは`PRIMARY'である。

     引数DATA-TYPEは、他のXクライアントから得た生データをLispデータに変
     換するために使用するデータ変換の書式を指定する。意味のある値は、
     `TEXT'、`STRING'、`CHARACTER_POSITION'、`LINE_NUMBER'、
     `COLUMN_NUMBER'、`OWNER_OS'、`HOST_NAME'、`USER'、`CLASS'、`NAME'、
     `ATOM'、`INTEGER'である。（これらのシンボルは、Xウィンドウシステム
     の慣習に従って大文字の名前である。）DATA-TYPEのデフォルトは`STRING'
     である。

Xサーバーには、アプリケーションのあいだで移動するテキストや他のデータを
保存できる番号付きの"カットバッファ"（cut buffer）の集まりもあります。カッ
トバッファは廃れているとみなされますが、それらを使っているXクライアント
向けにEmacsはカットバッファを扱えます。

 -- Function: x-get-cut-buffer N
     この関数は、番号Nのカットバッファの内容を返す。

 -- Function: x-set-cut-buffer STRING
     Emacsが連続したキルをキルリングで順に下向きに移動するのと同様に、こ
     の関数は一連のカットバッファの値を順に下向きに移動してから文字列
     STRINGを最初のカットバッファ（番号0）に保存する。

 -- Variable: selection-coding-system
     この変数は、セレクション、クリップボード、カットバッファを読み書き
     するときに使うコーディングシステムを指定する。*Note Coding
     Systems::。デフォルトは`compound-text'である。



File: elisp-ja.info, Node: Font Names, Next: Fontsets, Prev: Window System Selections, Up: Frames

フォント名の探索
================

 -- Function: x-list-font PATTERN &optional FACE FRAME MAXIMUM
     この関数は、パターンPATTERNに一致する利用可能なフォント名のリストを
     返す。省略可能な引数FACEとFRAMEを指定すると、FRAMEで現在オンになっ
     ているFACEと同じサイズのフォントにリストを制限する。

     引数PATTERNは文字列であること。これはワイルドカード文字を含んでいて
     もよい。`*'は任意の部分文字列に一致し、`?'は任意の1文字に一致する。
     フォント名とパターンの一致を取る際には、大文字小文字を区別しない。

     FACEとFRAMEを指定するときには、FACEはフェイス名（シンボル）であり、
     FRAMEはフレームであること。

     省略可能な引数MAXIMUMは、返すフォントの個数を制限する。これが`nil'
     以外であると、戻り値は最初のMAXIMUM個の一致したフォントに切り詰める。
     MAXIMUMに小さな値を指定すると、多くのフォントに一致する場合ではこの
     関数の動作がだいぶ速くなる。



File: elisp-ja.info, Node: Fontsets, Next: Color Names, Prev: Font Names, Up: Frames

フォントセット
==============

"フォントセット"（fontset）は、フォントのリストであって、各フォントが文
字コードのある範囲に割り付けられています。個々のフォントだけでは、Emacs
が扱う文字集合の範囲全体を表示できませんが、フォントセットならば可能です。
フォントセットにはフォントと同様に名前があり、フレームやフェイス向けに
『フォント』を指定するときのフォント名のかわりにフォントセット名を使えま
す。ここでは、Lispプログラムの制御のもとにフォントセットを定義することに
関する情報を述べます。

 -- Function: create-fontset-from-fontset-spec FONTSET-SPEC &optional STYLE-VARIANT-P NOERROR
     この関数は、指定文字列FONTSET-SPECに従って新たなフォントセットを定
     義する。文字列はつぎの形であること。

          FONTPATTERN, [CHARSETNAME:FONTNAME]...

     コンマの前後の白文字は無視する。

     文字列の始めの部分FONTPATTERNは、最後の2つのフィールドが
     `fontset-ALIAS'であることを除いて、Xの標準フォント名であること。

     新たなフォントセットには2つの名前、つまり、長い名前と短い名前がある。
     長い名前はFONTPATTERNそのものである。短い名前は`fontset-ALIAS'であ
     る。どちらの名前でもフォントセットを参照できる。同じ名前のフォント
     セットがすでに存在する場合、NOERRORが`nil'であるとエラーを通知し、
     この関数はなにもしない。

     省略可能な引数STYLE-VARIANT-Pが`nil'以外であると、フォントセットの
     bold（太字）、italic（斜体）、bold-italic（太字斜体）の各変種も作成
     することを指示する。これらの変種のフォントセットには短い名前はなく、
     FONTPATTERNのboldやitalicを変更して作った長い名前だけである。

     指定文字列ではフォントセットで使うフォントも指定する。詳しくは下記
     参照。

`CHARSET:FONT'という構成は、特定の1つの文字集合向けに（このフォントセッ
トで）使うフォントを指定します。ここで、CHARSETは文字集合の名前であり、
FONTはその文字集合に使うフォントです。この構成は、指定文字列で何回でも使
えます。

明示してない残りの文字集合向けには、FONTPATTERNに基づいてEmacsがフォント
を選びます。つまり、`fontset-ALIAS'を1つの文字集合を指名する値で置き換え
ます。ASCII文字集合向けには、`fontset-ALIAS'を`ISO8859-1'で置き換えます。

これに加えて、いくつか連続したフィールドがワイルドカードであるなら、
Emacsはそれらを1つのワイルドカードにまとめます。これは、自動的に拡大縮小
したフォントの使用を避けるためです。大きめのフォントを縮小したフォントは
編集には使えません。また、小さめのフォントを拡大したフォントも有用ではあ
りません。というのは、Emacsがそうするように、もともと小さなフォントを使
うほうがよいからです。

したがって、FONTPATTERNがつぎのようであると、

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

また、Chinese GB2312文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

上のフォント指定に一致する中国語フォントがないかもしれません。多くのXの
配布には、FAMILYフィールドが`song ti'か`fangsong ti'の中国語フォントだけ
が含まれています。そういった場合、`Fontset-N'をつぎのように指定します。

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうすると、Chinese GB2312の文字を除くフォント指定ではFAMILYフィールドが
`fixed'となり、Chinese GB2312の文字に対するフォント指定ではFAMILYフィー
ルドが`*'となります。



File: elisp-ja.info, Node: Color Names, Next: Resources, Prev: Fontsets, Up: Frames

表示色名
========

 -- Function: x-color-defined-p COLOR &optional FRAME
     この関数は、表示色名が意味のあるものかどうかを報告する。意味があれ
     ば`t'を返し、さもなければ`nil'を返す。引数FRAMEは、どのフレームで調
     べるかを指定する。FRAMEを省略したり`nil'であると、選択されているフ
     レームを使う。

     この関数では、読者が使用しているディスプレイで当該表示色を実際に表
     示できるかどうかはわからない。どんな種類のディスプレイでも定義され
     ていればどんな表示色でも問い合わせることができ、なんらかの結果を得
     られる。Xサーバーはこのように動作するのである。読者のディスプレイで
     表示色COLORを使えるかどうかを検査する近似方法はつぎのとおりである。

          (defun x-color-supported-p (color &optional frame)
            (and (x-color-defined-p color frame)
                 (or (x-display-color-p frame)
                     (member color '("black" "white"))
                     (and (> (x-display-planes frame) 1)
                          (equal color "gray")))))

 -- Function: x-color-values COLOR &optional FRAME
     この関数は、表示色COLORが理想的にはどのように見えるかを記述した値を
     返す。COLORが定義されていれば、その値は、赤の分量、緑の分量、青の分
     量を表す3つの整数のリストである。各整数の範囲は原理的には0から65535
     であるが、実際には65280を超えることはないようである。COLORが定義さ
     れていなければ、値は`nil'である。

          (x-color-values "black")
               => (0 0 0)
          (x-color-values "white")
               => (65280 65280 65280)
          (x-color-values "red")
               => (65280 0 0)
          (x-color-values "pink")
               => (65280 49152 51968)
          (x-color-values "hungry")
               => nil

     フレームFRAMEのディスプレイに対する表示色の値を返す。FRAMEを省略し
     たり`nil'であると、選択されているフレームのディスプレイに対する値を
     返す。



File: elisp-ja.info, Node: Resources, Next: Server Data, Prev: Color Names, Up: Frames

Xリソース
=========

 -- Function: x-get-resource ATTRIBUTE CLASS &optional COMPONENT SUBCLASS
     関数`x-get-resource'は、Xウィンドウのデフォルトのデータベースからリ
     ソースの値を取り出す。

     リソースは、"key"と"class"の組み合わせで添字付けされる。この関数は
     `INSTANCE.ATTRIBUTE'の形（INSTANCEはEmacsを起動した名前）のキーとク
     ラスとして`Emacs.CLASS'を使って探索する。

     省略可能な引数COMPONENTとSUBCLASSは、それぞれ、キーとクラスに追加さ
     れる。2つを指定するかまったく指定しないこと。これらを指定すると、キー
     は`INSTANCE.COMPONENT.ATTRIBUTE'であり、クラスは
     `Emacs.CLASS.SUBCLASS'である。

 -- Variable: x-resource-class
     この変数は、`x-get-resource'が探すアプリケーション名を指定する。デ
     フォルト値は`"Emacs"'である。`x-get-resource'を呼び出す周りでこの変
     数に別の文字列を束縛すれば、『Emacs』以外のアプリケーション名でXリ
     ソースを探せる。

  *Note Xリソース: (emacs)Resources X。



File: elisp-ja.info, Node: Server Data, Prev: Resources, Up: Frames

Xサーバーに関するデータ
=======================

本節では、Emacsが使っているXディスプレイの能力や製造元に関する情報を得る
ために使う関数について述べます。これらの関数のそれぞれには、どのディスプ
レイを対象にするか引数DISPLAYで指定できます。引数DISPLAYは、ディスプレイ
名かフレーム（が表示されいるディスプレイを意味する）のいずれかです。引数
DISPLAYを省略したり`nil'であると、選択されているフレームのディスプレイを
使うことを意味します。

 -- Function: x-display-screens &optional DISPLAY
     この関数は、ディスプレイに対応付けられているスクリーンの個数を返す。

 -- Function: x-server-version &optional DISPLAY
     この関数は、ディスプレイで動作中のXサーバーの版番号のリストを返す。

 -- Function: x-server-vendor &optional DISPLAY
     この関数は、Xサーバーソフトウェアの提供業者を返す。

 -- Function: x-display-pixel-height &optional DISPLAY
     この関数はスクリーンのピクセル単位の高さを返す。

 -- Function: x-display-mm-height &optional DISPLAY
     この関数はスクリーンのミリメートル単位の高さを返す。

 -- Function: x-display-pixel-width &optional DISPLAY
     この関数はスクリーンのピクセル単位の幅を返す。

 -- Function: x-display-mm-width &optional DISPLAY
     この関数はスクリーンのミリメートル単位の幅を返す。

 -- Function: x-display-backing-store &optional DISPLAY
     この関数は、スクリーンのバッキングストア機能を返す。その値は、
     `always'、`when-mapped'、`not-useful'のシンボルのいずれかである。

 -- Function: x-display-save-under &optional DISPLAY
     この関数は、ディスプレイにセーブアンダー機能があれば`nil'以外を返す。

 -- Function: x-display-planes &optional DISPLAY
     この関数は、ディスプレイのプレイン数を返す。

 -- Function: x-display-visual-class &optional DISPLAY
     この関数は、スクリーンのビジュアルクラスを返す。その値は、
     `static-gray'、`gray-scale'、`static-color'、`pseudo-color'、
     `true-color'、`direct-color'のシンボルのいずれかである。

 -- Function: x-display-grayscale-p &optional DISPLAY
     この関数は、スクリーンで白黒の濃淡を表示できると`t'を返す。

 -- Function: x-display-color-p &optional DISPLAY
     この関数は、スクリーンがカラースクリーンならば`t'を返す。

 -- Function: x-display-color-cells &optional DISPLAY
     この関数はスクリーンで使えるカラーセルの個数を返す。





File: elisp-ja.info, Node: Positions, Next: Markers, Prev: Frames, Up: Top

バッファ内の位置
****************

バッファ内"位置"（position）は、バッファ内のテキストの文字を添字付けしま
す。より正確にいえば、バッファ内位置は2つの文字のあいだの箇所（あるいは、
先頭文字ではそのまえ、最後の文字ではそのうしろ）を識別して、指定位置のま
えやうしろの文字を指定できるようにします。しかし、しばしば位置『にある』
文字といいますが、これは位置の直後の文字を意味します。

バッファ内位置は、通常、1から始まる整数で表しますが、"マーカ"（marker）
で表すこともできます。マーカは特別なオブジェクトであり、テキストを挿入し
たり削除しても同じ周りの文字に留まるように自動的に再配置されます。*Note
Markers::。

* Menu:

* Point::         The special position where editing takes place.
* Motion::        Changing point.
* Excursions::    Temporary motion and buffer changes.
* Narrowing::     Restricting editing to a portion of the buffer.



File: elisp-ja.info, Node: Point, Next: Motion, Prev: Positions, Up: Positions

ポイント
========

"ポイント"（point）は、自己挿入文字やテキスト挿入関数を含む多くの編集コ
マンドが使うバッファ内の特別な位置です。他のコマンドは、バッファ内の別の
箇所で編集したり挿入できるようにポイントをテキスト内で移動します。

他のバッファ内位置と同様に、ポイントは文字そのものではなく、2つの文字の
あいだの箇所（あるいは、先頭文字ではそのまえ、最後の文字ではそのうしろ）
を指定します。通常、端末では、ポイントの直後の文字に重ねてカーソルを表示
します。ポイントはカーソルがある文字のまえに実際にはあります。

ポイントの値は、1からバッファのサイズ足す1です。ナロイング（*Note
Narrowing::）していると、ポイントはバッファの参照可能な（バッファの端を
含むかもしれない）範囲内に制限されます。

各バッファには独自のポイント値があり、それは他のバッファのポイント値とは
独立です。各ウィンドウにも独自のポイント値があり、同じバッファを表示して
いる他のウィンドウのポイント値とは独立です。このようなわけで、同じバッファ
を表示しているさまざまなウィンドウで異なるポイント値を持てるのです。1つ
のウィンドウだけにバッファが表示されているときには、バッファのポイントと
ウィンドウのポイントは、通常、同じ値であり、それらを区別することはほとん
ど重要ではありません。詳しくは、*Note Window Point::。

 -- Function: point
     この関数はカレントバッファのポイント値を整数で返す。

          (point)
               => 175

 -- Function: point-min
     この関数は、カレントバッファで参照可能なポイント値の最小値を返す。
     これは通常1であるが、ナロイングしているときには、ナロイングした領域
     の開始位置である。（*Note Narrowing::。）

 -- Function: point-max
     この関数は、カレントバッファで参照可能なポイント値の最大値を返す。
     ナロイングしていなければ、これは`(1+ (buffer-size))'である。ナロイ
     ングしているときには、ナロイングした領域の終了位置である。（*Note
     Narrowing::。）

 -- Function: buffer-end FLAG
     この関数は、FLAGが1未満であれば`(point-min)'を返し、さもなければ
     `(point-max)'を返す。引数FLAGは整数であること。

 -- Function: buffer-size
     この関数は、カレントバッファ内の総文字数を返す。ナロイング（*Note
     Narrowing::）していなければ、`point-max'はこの値より1大きな値を返す。

          (buffer-size)
               => 35
          (point-max)
               => 36



File: elisp-ja.info, Node: Motion, Next: Excursions, Prev: Point, Up: Positions

移動
====

移動関数は、現在のポイント値やバッファの先頭や末尾を基準にして、あるいは、
選択されているウィンドウの端を基準にして、ポイント値を変更します。*Note
Point::。

* Menu:

* Character Motion::       Moving in terms of characters.
* Word Motion::            Moving in terms of words.
* Buffer End Motion::      Moving to the beginning or end of the buffer.
* Text Lines::             Moving in terms of lines of text.
* Screen Lines::           Moving in terms of lines as displayed.
* List Motion::            Moving by parsing lists and sexps.
* Skipping Characters::    Skipping characters belonging to a certain set.



File: elisp-ja.info, Node: Character Motion, Next: Word Motion, Prev: Motion, Up: Motion

文字単位の移動
--------------

これらの関数は、文字数に基づいてポイントを移動します。`goto-char'が基本
になる基本関数であり、他の関数はこれを使っています。

 -- コマンド: goto-char POSITION
     この関数は、カレントバッファのポイント位置を値POSITIONとする。
     POSITIONが1未満であると、バッファの先頭にポイントを移動する。
     POSITIONがバッファの長さより大きい場合には、バッファの末尾にポイン
     トを移動する。

     ナロイングしている場合であっても、POSITIONはバッファの先頭から数え
     るが、参照可能部分の外側にはポイントは移動できない。POSITIONが範囲
     外であると、`goto-char'は参照可能部分の先頭か末尾にポイントを移動す
     る。

     この関数を対話的に呼び出すと、前置引数があればPOSITIONは数値前置引
     数である。さもなければミニバッファから読む。

     `goto-char'はPOSITIONを返す。

 -- コマンド: forward-char &optional COUNT
     この関数は、前方へ、つまり、バッファの末尾に向けて（COUNTが負であれ
     ば、後方へ、つまり、バッファの先頭へ向けて）COUNT文字分ポイントを移
     動する。バッファの先頭や末尾を越えて（ナロイングしているときには参
     照可能部分を越えて）ポイントを移動しようとすると、
     `beginning-of-buffer'か`end-of-buffer'のエラーコードでエラーを通知
     する。

     対話的に呼び出されると、COUNTは数値前置引数である。

 -- コマンド: backward-char &optional COUNT
     この関数は、後方へ、つまり、バッファの先頭に向けて（COUNTが負であれ
     ば、前方へ、つまり、バッファの末尾へ向けて）COUNT文字分ポイントを移
     動する。バッファの先頭や末尾を越えて（ナロイングしているときには参
     照可能部分を越えて）ポイントを移動しようとすると、
     `beginning-of-buffer'か`end-of-buffer'のエラーコードでエラーを通知
     する。

     対話的に呼び出されると、COUNTは数値前置引数である。



File: elisp-ja.info, Node: Word Motion, Next: Buffer End Motion, Prev: Character Motion, Up: Motion

単語単位の移動
--------------

これらの単語を解析する関数は、当該文字が単語の一部かどうかを判定するため
に構文テーブルを使います。*Note Syntax Tables::。

 -- コマンド: forward-word COUNT
     この関数は、前方へ（COUNTが負ならば後方へ）COUNT単語分ポイントを移
     動する。『1単語分移動する』とは、単語構成文字を越えてから単語区切り
     文字（あるいはバッファの参照可能部分の境界）に出会うまでポイントを
     移動することを意味する。

     バッファの境界で止まらず（最後の単語は除く）にCOUNT単語分移動できる
     と、値は`t'である。さもなければ値は`nil'であり、ポイントはバッファ
     の境界で止まる。

     対話的に呼び出されると、COUNTは数値前置引数である。

 -- コマンド: backward-word COUNT
     この関数は`forward-word'と同様であるが、前方へではなく後方へ単語の
     先頭に出会うまで移動する。

     対話的に呼び出されると、COUNTは数値前置引数である。

     この関数は、プログラムではほとんど使われない。負の引数で
     `forward-word'を呼び出すほうが効率的だからである。

 -- Variable: words-include-escapes
     この変数は、`forward-word'とそれを使うもののふるまいに影響する。
     `nil'以外であると、『エスケープ』や『文字クォート』の構文クラスに属
     する文字も単語の一部とみなす。さもなければ、単語の一部とはみなさな
     い。



File: elisp-ja.info, Node: Buffer End Motion, Next: Text Lines, Prev: Word Motion, Up: Motion

バッファの両端への移動
----------------------

バッファの先頭にポイントを移動するには、つぎのように書きます。

     (goto-char (point-min))

同様に、バッファの末尾に移動するには、つぎのようにします。

     (goto-char (point-max))

上のことを行うためにユーザーが使うコマンドが2つあります。これらはマーク
を設定してエコー領域にメッセージを表示するので、これらをLispプログラムか
らは使わないように警告しておきます。

 -- コマンド: beginning-of-buffer &optional N
     この関数は、バッファ（あるいはナロイングしているときには参照可能部
     分）の先頭にポイントを移動し、移動前の位置にマークを設定する。Nが
     `nil'以外であると、バッファの先頭から10分のNの箇所にポイントを移動
     する。

     対話的に呼び出すと、前置引数があればNは数値前置引数である。さもなけ
     ればNのデフォルトは`nil'である。

     *警告：*` 'Lispプログラムではこの関数を使わないこと！

 -- コマンド: end-of-buffer &optional N
     この関数は、バッファ（あるいはナロイングしているときには参照可能部
     分）の末尾にポイントを移動し、移動前の位置にマークを設定する。Nが
     `nil'以外であると、バッファの末尾から10分のNの箇所にポイントを移動
     する。

     対話的に呼び出すと、前置引数があればNは数値前置引数である。さもなけ
     ればNのデフォルトは`nil'である。

     *警告：*` 'Lispプログラムではこの関数を使わないこと！



File: elisp-ja.info, Node: Text Lines, Next: Screen Lines, Prev: Buffer End Motion, Up: Motion

テキスト行単位の移動
--------------------

テキスト行とは、改行文字で区切られたバッファの部分です。改行文字はまえの
行に属するとみなします。最初のテキスト行がバッファの先頭から始まり、バッ
ファの末尾の文字が改行であってもなくても、最後のテキスト行はバッファの末
尾で終ります。バッファをテキスト行に分割することは、ウィンドウの幅、表示
上の行の継続、タブやコントロール文字の表示方法には影響されません。

 -- コマンド: goto-line LINE
     この関数は、バッファの先頭を1行目と数えてLINE行目の先頭にポイントを
     移動する。LINEが1未満であると、バッファの先頭へポイントを移動する。
     LINEがバッファ内の行数より大きいと、バッファの末尾、つまり、*バッファ
     の最後の行の末尾*にポイントを移動する。これは、`goto-line'が行頭に
     ポイントを移動しない唯一の場面である。

     ナロイングしているときでも、LINEはバッファの先頭から数えるが、参照
     可能部分の外側にはポイントは移動しない。したがって、行番号が参照不
     可な部分を指定するときには、`goto-line'は参照可能部分の先頭か末尾へ
     ポイントを移動する。

     `goto-line'の戻り値は、（ナロイングを考慮せずにバッファ全体でみた）
     LINEと実際のポイントの移動先の行の行番号との差である。したがって、
     指定した行に達するまえにバッファの末尾に出会うと値は正である。バッ
     ファの実際の末尾にではなく参照可能部分の末尾に出会うと値は0である。

     対話的に呼び出すと、前置引数があればLINEは数値前置引数である。さも
     なければLINEをミニバッファから読む。

 -- コマンド: beginning-of-line &optional COUNT
     この関数は、現在行の先頭にポイントを移動する。引数COUNTが`nil'でも1
     でもないと、COUNT-1行だけ前方へ移動してから行頭に移動する。

     バッファ（ナロイングしているときには参照可能部分）の末尾に達すると
     ポイントをそこへ移動する。エラーは通知しない。

 -- コマンド: end-of-line &optional COUNT
     この関数は、現在行の末尾にポイントを移動する。引数COUNTが`nil'でも1
     でもないと、COUNT-1行だけ前方へ移動してから行末に移動する。

     バッファ（ナロイングしているときには参照可能部分）の末尾に達すると
     ポイントをそこへ移動する。エラーは通知しない。

 -- コマンド: forward-line &optional COUNT
     この関数は、COUNT行前方の行頭にポイントを移動する。
     COUNTが負であると、
     -COUNT行後方の行頭にポイントを移動する。
     COUNTが0であると、現在行の先頭にポイントを移動する。

     指定行数だけ移動するまえにバッファ（ナロイングしているときには参照
     可能部分）の先頭や末尾に達するとポイントをそこへ移動する。エラーは
     通知しない。

     `forward-line'は、COUNTと実際に移動した行数の差を返す。3行しかない
     バッファの先頭で5行前方へ移動しようとすると、ポイントは最後の行の末
     尾で止まり、値は2になる。

     対話的に呼び出すと、COUNTは数値前置引数である。

 -- Function: count-lines START END
     この関数は、カレントバッファのSTARTとENDのあいだの部分にある行の行
     数を返す。STARTとENDが等しければ0を返す。さもなければ、STARTとENDが
     同じ行にある場合であっても少なくとも1を返す。というのは、それらのあ
     いだのテキストは孤立しているとみなされ、空でなければ少なくとも1行は
     あるはずだからである。

     `count-lines'の使用例を示す。

          (defun current-line ()
            "Return the vertical position of point..."
            (+ (count-lines (window-start) (point))
               (if (= (current-column) 0) 1 0)
               -1))


*Note Near Point::の関数`bolp'や`eolp'も参照してください。これらの関数は
ポイントを移動しませんが、ポイントがすでに行の先頭や末尾にあるかどうかを
検査します。



File: elisp-ja.info, Node: Screen Lines, Next: List Motion, Prev: Text Lines, Up: Motion

スクリーン行分の移動
--------------------

前節の行単位の関数は、改行文字で区切られたテキスト行だけを数えます。対照
的に、これらの関数は、スクリーン上にどのようにテキストが現れるかで定義さ
れるスクリーン上の行を数えます。テキスト行が選択されているウィンドウの幅
に収まるだけ短ければ、1テキスト行は1スクリーン行ですが、しかし、それ以外
では1テキスト行は複数のスクリーン行を占めます。

テキスト行を複数のスクリーン行に継続せずにスクリーン上で切り詰める場合も
あります。このような場合、`vertical-motion'は、`forward-line'によく似た
ポイントの移動を行います。*Note Truncation::。

与えられた文字列の幅は、各文字の見ためを制御するフラグに依存するので、
`vertical-motion'は、テキストを収めたバッファや選択されているウィンドウ
（その幅や切り詰めフラグ、ウィンドウごとに異なりうる表示テーブルがあるた
め）に依存して、特定のテキスト部分に対して異なったふるまいをします。
*Note Usual Display::。

これらの関数は、スクリーン行がどこで区切れるかを決定するためにテキストを
走査するので、走査する量に比例して時間がかかります。読者がこれらを多用す
る意図があるときには、読者のコードの効率を改善するキャッシュをEmacsが提
供します。*Note cache-long-line-scans: Truncation。


 -- Function: vertical-motion COUNT &optional WINDOW
     この関数は、ポイントを含むスクリーン行からCOUNTスクリーン行数だけ下
     向きにポイントを移動する。COUNTが負であると上向きに移動する。

     `vertical-motion'は、ポイントを移動したスクリーン行数を返す。バッファ
     の先頭や末尾に達すると、この値は絶対値ではCOUNTより小さい。

     ウィンドウWINDOWは、幅、水平スクロール、表示テーブルなどのパラメー
     タを得るために使われる。しかし、WINDOWに別のバッファが表示されてい
     るとしても、`vertical-motion'はつねにカレントバッファに作用する。

 -- コマンド: move-to-window-line COUNT
     この関数は、選択されているウィンドウに現在表示されているテキストに
     基づいてポイントを移動する。
     ウィンドウの先頭からCOUNTスクリーン行の先頭にポイントを移動する。
     COUNTが負であると、底（あるいはバッファの末尾がスクリーンの
     底より上にある場合にはバッファの最終行）から数えて
     -COUNTスクリーン行位置を指定する。

     COUNTが`nil'であると、ウィンドウの中央の行の先頭にポイントを移動す
     る。COUNT の絶対値がウィンドウのサイズよりも大きいときには、ウィン
     ドウに十分な高さがあった場合に移動するであろうスクリーン行の箇所に
     ポイントを移動する。そのため、スクロールして当該箇所がスクリーンに
     現れるように再表示する。

     対話的に呼び出されると、COUNTは数値前置引数である。

     戻り値は、ウィンドウの先頭行を0と数えて、移動先の行のウィンドウ行番
     号である。

 -- Function: compute-motion FROM FROMPOS TO TOPOS WIDTH OFFSETS WINDOW
     この関数は、スクリーン上での位置を計算しながらカレントバッファを走
     査する。バッファ内位置FROMがスクリーン座標FROMPOSに対応すると仮定し
     て、FROMから前方へ向けてTOかTOPOSのどちらかに達するまでバッファを走
     査する。バッファ内の終了位置とスクリーン座標を返す。

     座標引数FROMPOSとTOPOSは、`(HPOS . VPOS)'の形のコンスセルである。

     引数WIDTHは、テキストを表示できるコラム数であり、これは継続行の扱い
     に影響する。読者が選んだウィンドウに対して`window-width'が返した値、
     つまり、通常、`(window-width WINDOW)'を使う。

     引数OFFSETSは、`nil'であるか、`(HSCROLL . TAB-OFFSET)'の形のコンス
     セルである。ここで、HSCROLLは左端に表示されていないコラム数であり、
     多くの場合は`window-hscroll'を呼び出して得た値を使う。一方、
     TAB-OFFSETはスクリーン上でのコラム番号とバッファ内でのコラム番号の
     差である。この値は、継続行においてまえのスクリーン行の幅が
     `tab-width'で終らない場合に0以外になる。継続しない行ではつねに0であ
     る。

     ウィンドウWINDOWは、使用する表示テーブルを指定するためだけに使われ
     る。WINDOWに表示されているバッファに関わらず、`compute-motion'はつ
     ねにカレントバッファに作用する。

     戻り値は、5要素のリストである。

          (POS VPOS HPOS PREVHPOS CONTIN)

     ここで、POSは走査を終えたバッファ内位置であり、VPOSは垂直方向のスク
     リーン位置、HPOSは水平方向のスクリーン位置である。

     結果のPREVHPOSは、POSから1文字分戻った箇所の水平位置である。この文
     字のあとで最終行が継続しているときには、結果のCONTINは`t'である。

     たとえば、あるウィンドウのLINEスクリーン行のCOLコラムに対応するバッ
     ファ内位置を探すには、FROMとしてウィンドウの表示開始位置、FROMPOSと
     してウィンドウの左上隅の座標を渡します。TOにはバッファの
     `(point-max)'を渡して走査をバッファの参照可能部分のみに制限し、
     TOPOSとしてLINEとCOLを渡す。つぎのように呼び出す。

          (defun coordinates-of-position (col line)
            (car (compute-motion (window-start)
                                 '(0 . 0)
                                 (point-max)
                                 (cons col line)
                                 (window-width)
                                 (cons (window-hscroll) 0)
                                 (selected-window))))

     ミニバッファに対して`compute-motion'を使うときには、
     `minibuffer-prompt-width'を使って最初のスクリーン行の先頭の水平位置
     を得る必要がある。*Note Minibuffer Misc::。



File: elisp-ja.info, Node: List Motion, Next: Skipping Characters, Prev: Screen Lines, Up: Motion

式単位の移動
------------

ここでは、釣り合った括弧で囲まれた式（Emacs内でそれらを単位に移動すると
きには"S式"（sexps）とも呼ばれる）を扱う関数について述べます。構文テーブ
ルは、これらの関数がさまざまな文字をどのように解釈するかを制御します。
*Note Syntax Tables::を参照してください。S式やその一部を走査する下位レベ
ルの基本関数については、*Note Parsing Expressions::。ユーザーレベルのコ
マンドに関しては、*Note リストとS式に対するコマンド: (emacs)List
Commandsを参照してください。

 -- コマンド: forward-list ARG
     この関数は、釣り合った括弧で囲まれたものをARG個前方へ飛び越えて移動
     する。（単語や文字列のクォート対などの他の構文要素は無視する。）

 -- コマンド: backward-list ARG
     この関数は、釣り合った括弧で囲まれたものをARG個後方へ飛び越えて移動
     する。（単語や文字列のクォート対などの他の構文要素は無視する。）

 -- コマンド: up-list ARG
     この関数は、前方へ向けてARG個の括弧のレベルを抜ける。負の引数では後
     方へ向けて浅いレベルへ移動する。

 -- コマンド: down-list ARG
     この関数は、前方へ向けてARG個の括弧のレベルだけ深く入る。負の引数で
     は後方へ向けて括弧の深い（-ARG）レベルへ移動する。

 -- コマンド: forward-sexp ARG
     この関数は、ARG個の釣り合った式を前方へ向けて飛び越えて移動する。釣
     り合った式には、括弧で区切られたものに加えて、単語や文字列定数など
     の他の種類も含まれる。たとえばつぎのとおり。

          ---------- Buffer: foo ----------
          (concat-!- "foo " (car x) y z)
          ---------- Buffer: foo ----------

          (forward-sexp 3)
               => nil

          ---------- Buffer: foo ----------
          (concat "foo " (car x) y-!- z)
          ---------- Buffer: foo ----------

 -- コマンド: backward-sexp ARG
     この関数は、ARG個の釣り合った式を後方へ向けて飛び越えて移動する。

 -- コマンド: beginning-of-defun ARG
     この関数は、前方へ向けてARG個目の関数定義の先頭へ移動する。ARGが負
     であると、後方へ向けて、関数定義の末尾ではなく関数定義の先頭へ移動
     する。

 -- コマンド: end-of-defun ARG
     この関数は、前方へ向けてARG個目の関数定義の末尾へ移動する。ARGが負
     であると、後方へ向けて、関数定義の先頭ではなく関数定義の末尾へ移動
     する。

 -- User Option: defun-prompt-regexp
     この変数が`nil'以外であると、関数定義を始める開き括弧のまえに現れう
     るテキストを指定する正規表現を保持する。つまり、関数定義は、行の先
     頭がこの正規表現に一致するテキストで始まり、それに開き括弧の構文に
     属する文字が続く行で始まる。



File: elisp-ja.info, Node: Skipping Characters, Prev: List Motion, Up: Motion

文字群の飛び越し
----------------

つぎの2つの関数は、指定した種類の文字を飛び越えてポイントを移動します。
たとえば、白文字を飛び越すためにこれらはしばしば使われます。関連する関数
については、*Note Motion and Syntax::を参照してください。

 -- Function: skip-chars-forward CHARACTER-SET &optional LIMIT
     この関数は、指定した文字の集まりを飛び越えて、カレントバッファ内で
     前方にポイントを移動する。ポイントのあとの文字を調べ、その文字が
     CHARACTER-SETに一致するとポイントを進める。これをCHARACTER-SETに一
     致しない文字に達するまで繰り返す。この関数は飛び越えた文字の個数を
     返す。

     引数CHARACTER-SETは、正規表現の`[...]'の内側と同じであるが、`]'は特
     別扱いせず、`\'は`^'や`-'や`\'をクォートする。したがって、
     `"a-zA-Z"'はすべての英文字を飛び越えて最初の英文字でない文字のまえ
     で止まる。`"^a-zA-Z"'は英文字でない文字を飛び越えて最初の英文字で止
     まる。*Note Regular Expressions::。

     LIMITを指定すると（数かマーカであること）、ポイントを移動できるバッ
     ファ内の最大位置を指定する。ポイントは、LIMITで止まるかLIMITに達す
     るまえに止まる。

     つぎの例では、ポイントは最初は`T'の直前に位置している。フォームを評
     価後には、ポイントはその行末（`hat'の`t'と改行のあいだ）に位置して
     いる。この関数は、すべての英文字と空白を飛び越えるが、改行は飛び越
     えない。

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (skip-chars-forward "a-zA-Z ")
               => nil

          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Function: skip-chars-backward CHARACTER-SET &optional LIMIT
     この関数は、LIMITに達するまで、後方へ向かってCHARACTER-SETに一致す
     る文字を飛び越えてポイントを移動する。これは`skip-chars-forward'と
     同様であるが、移動方向が異なる。

     移動距離を表す値を返す。それは0以下の整数である。



File: elisp-ja.info, Node: Excursions, Next: Narrowing, Prev: Motion, Up: Positions

エクスカージョン
================

プログラムの局所的な部分で『一時的に』ポイントを移動したり、一時的にバッ
ファを切り替えられるとしばしば有用です。これを"エクスカージョン"
（excursion、周遊）と呼び、スペシャルフォーム`save-excursion'で行います。
この構文は、カレントバッファとそのポイントやマーカの値を保存し、エクスカー
ジョンの完了後にそれらを復元します。

ウィンドウの構成を保存したり復元するフォームは、別のところで述べてありま
す（*Note Window Configurations::と*Note Frame Configurations::）。

 -- Special form: save-excursion FORMS...
     スペシャルフォーム`save-excursion'は、カレントバッファの識別子とそ
     のポイントやマーカの値を保存し、FORMSを評価し、最後に、バッファと保
     存しておいたポイントやマーカの値を復元する。`throw'やエラーによる異
     常脱出（*Note Nonlocal Exits::）であっても、これらの保存した値を復
     元する。

     スペシャルフォーム`save-excursion'は、プログラムの一部分だけでバッ
     ファやポイントを移動しプログラムの他の部分への影響を防ぐ標準的な方
     法である。EmacsのLispソースでは4000回以上も使われている。

     `save-excursion'は他のバッファのポイントやマークの値は保存しないの
     で、他のバッファでの変更は`save-excursion'から抜けても持続する。

     同様に、`save-excursion'は、`switch-to-buffer'などの関数で変更され
     たウィンドウとバッファの対応関係は復元しない。これらの対応関係や選
     択されているウィンドウを復元する1つの方法は、`save-excursion'の内側
     で`save-window-excursion'を使うことである（*Note Window
     Configurations::）。

     `save-excursion'の戻り値は、FORMSの最後の結果であるか、FORMSを与え
     なければ`nil'である。

          (save-excursion FORMS)
          ==
          (let ((old-buf (current-buffer))
                (old-pnt (point-marker))
                (old-mark (copy-marker (mark-marker))))
            (unwind-protect
                (progn FORMS)
              (set-buffer old-buf)
              (goto-char old-pnt)
              (set-marker (mark-marker) old-mark)))

  *警告：*` '保存されたポイント値の箇所に普通にテキストを挿入すると、す
べてのマーカを再配置するように保存されたポイント値を再配置する。したがっ
て、保存されたポイント値が復元されると、ポイントは挿入されたテキストのま
えに普通どおりにくる。

`save-excursion'はマーカの位置を保存しますが、バッファを変更する関数が
`deactivate-mark'を行うことを防ぎませんから、コマンドが終了するとマーカ
が不活性になってしまいます。*Note The Mark::。



File: elisp-ja.info, Node: Narrowing, Prev: Excursions, Up: Positions

ナロイング
==========

"ナロイング"（narrowing）とは、Emacsの編集コマンドが参照できるテキストを
バッファの制限された文字の範囲に限定することです。参照できるテキストのこ
とをバッファの"参照可能部分"（accessible portion）と呼びます。

ナロイングは、参照可能部分の先頭と末尾になる2つのバッファ内位置で指定し
ます。ほとんどの編集コマンドやほとんどのEmacs基本関数にとっては、これら
の位置はバッファの先頭や末尾の値を置き換えることになります。ナロイングし
ていると、参照可能部分の外側のテキストは表示されませんし、ポイントは参照
可能部分の外側へは移動できません。

通常はバッファの先頭から数える位置や行番号などの値はナロイングしていても
同様に数えますが、それらを使う関数は参照できないテキストを操作することを
拒否します。

バッファを保存するコマンドはナロイングの影響を受けません。つまり、ナロイ
ングに関係なくバッファ全体を保存します。

 -- コマンド: narrow-to-region START END
     この関数は、カレントバッファのSTARTで始まりENDで終る部分を参照可能
     部分にする。どちらの引数も文字の位置であること。

     対話的に呼び出されると、STARTとENDは現在のリージョンの境界（ポイン
     トとマークの小さいほうがさきにくる）である。

 -- コマンド: narrow-to-page MOVE-COUNT
     このコマンドは、カレントバッファの参照可能部分を現在のページのみを
     含むようにする。省略可能な第1引数MOVE-COUNTが`nil'以外であると、
     MOVE-COUNTページだけ前方か後方へ移動してから1ページ分にナロイングす
     る。変数`page-delimiter'がページの開始箇所と終了箇所を指定する
     （*Note Standard Regexps::）。

     対話的に呼び出されると、MOVE-COUNTは数値前置引数である。

 -- コマンド: widen
     この関数は、カレントバッファのナロイングを解除し、全体を参照できる
     ようにする。これを"ワイドニング"（widening）と呼ぶ。これはつぎの式
     と等価である。

          (narrow-to-region 1 (1+ (buffer-size)))

 -- Special form: save-restriction BODY...
     このスペシャルフォームは、現在の参照可能部分の境界を保存し、フォー
     ムBODYを評価し、最後に、保存した境界を復元してまえと同じナロイング
     状態（あるいはナロイングなし）に復元する。`throw'やエラーによる異常
     脱出（*Note Nonlocal Exits::）であっても、ナロイング状態を復元する。

     `save-restriction'の戻り値は、BODYの最後の結果であるか、BODYを与え
     なければ`nil'である。

     *注意：*` '構文`save-restriction'を使うときにはまちがいやすい。使う
     まえにこの説明全体を読むこと。

     BODYでカレントバッファを切り替えても`save-restriction'はもとのバッ
     ファ（バッファの制限を保存したバッファ）に制限を復元するが、もとの
     カレントバッファには戻さない。

     `save-restriction'はポイントやマークは復元*しない*。それには
     `save-excursion'を使う。`save-restriction'と`save-excursion'の両者
     を一緒に使うときには、`save-excursion'が先に（外側に）くること。さ
     もないと、古いポイント値は一時的なナロイングが有効な状態で復元され
     る。古いポイント値が一時的なナロイングの範囲外にあると正しく復元で
     きない。

     スペシャルフォーム`save-restriction'は、参照可能部分の先頭と末尾を
     バッファの先頭と末尾からの距離として記録する。いいかえれば、参照可
     能部分の前後の参照できないテキストの量を記録する。

     この方法は、BODYでさらにナロイングしても正しい結果を生じる。しかし、
     BODYでワイドニングして保存されているナロイングの範囲外を変更すると
     `save-restriction'が混乱する。このようにしたいときには、
     `save-restriction'は正しい解法ではない。つぎのようにする必要がある。

          (let ((beg (point-min-marker))
                (end (point-max-marker)))
            (unwind-protect
                (progn BODY)
              (save-excursion
                (set-buffer (marker-buffer beg))
                (narrow-to-region beg end))))

     `save-restriction'の正しい使い方の簡単な例を示す。

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo-!-
          ---------- Buffer: foo ----------

          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))

          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo-!-
          ---------- Buffer: foo ----------


File: elisp-ja.info, Node: Markers, Next: Text, Prev: Positions, Up: Top

マーカ
******

"マーカ"（marker）とは、バッファ内位置をそれを取り巻くテキストを基準に指
定するために使われるLispオブジェクトです。テキストが挿入されたり削除され
ると、バッファの先頭からマーカまでの距離は自動的に変更され、マーカは同じ
前後の文字のあいだに留まります。

* Menu:

* Overview of Markers::      The components of a marker, and how it relocates.
* Predicates on Markers::    Testing whether an object is a marker.
* Creating Markers::         Making empty markers or markers at certain places.
* Information from Markers:: Finding the marker's buffer or character position.
* Marker Insertion Types::   Two ways a marker can relocate when you
                               insert where it points.
* Moving Markers::           Moving the marker to a new buffer or position.
* The Mark::                 How "the mark" is implemented with a marker.
* The Region::               How to access "the region".



File: elisp-ja.info, Node: Overview of Markers, Next: Predicates on Markers, Prev: Markers, Up: Markers

マーカの概要
============

マーカは、バッファとそのバッファ内での位置を指定します。マーカは、位置を
必要とする関数に対して位置を表すものとして使えます。バッファ内の位置につ
いて詳しくは*Note Positions::。

マーカには2つの属性、つまり、マーカ位置とマーカバッファがあります。マー
カ位置は、当該バッファ内の位置としてのマーカに（その時点で）等価な整数で
す。しかし、マーカの生存期間中、マーカ位置の値はしばしば変化します。バッ
ファにテキストを挿入したり削除すると、マーカは再配置されます。これは、バッ
ファの任意の箇所で挿入したり削除したとしても、2つの文字のあいだに置かれ
たマーカが同じ文字のあいだに留まるようにするためです。再配置によって、マー
カに等価な整数は変わります。

マーカ位置の周りのテキストを削除すると、削除されたテキストの前後の文字の
あいだにマーカは留まります。マーカの位置にテキストを挿入すると、
`insert-before-markers'（*Note Insertion::）で挿入しない限り、マーカの"
挿入型"（insertion type）（*Note Marker Insertion Types::）に依存して、
マーカは挿入されたテキストのまえかうしろに留まります。

バッファに対する挿入や削除では、すべてのマーカを検査し、必要ならばマーカ
を再配置する必要があります。マーカを多数抱えるバッファでは、このために処
理が遅くなります。そのため、マーカが不要であると確信したときには、マーカ
がどこも指さないようにしておくのがよいです。参照されていないマーカは最終
的には（ガベッジコレクションで）回収されますが、それまでは、マーカがどこ
かを指していると処理時間を浪費します。

マーカ位置にはよく算術演算を施すので、（`+'や`-'を含む）ほとんどの算術演
算は引数としてマーカを受け付けます。そのような場合、マーカはその現在位置
を表します。

マーカを作って位置を設定し、ポイントをマーカへ移動する例を示します。

     ;; どこも指していない新しいマーカを作る
     (setq m1 (make-marker))
          => #<marker in no buffer>

     ;; マーカm1の位置をカレントバッファの
     ;; 99番目と100番目の文字のあいだにする
     (set-marker m1 100)
          => #<marker at 100 in markers.texi>

     ;; バッファの先頭に1文字挿入する
     (goto-char (point-min))
          => 1
     (insert "Q")
          => nil

     ;; それにしたがって`m1'が更新される
     m1
          => #<marker at 101 in markers.texi>

     ;; 同じ位置を指す2つのマーカは`eq'ではないが
     ;; `equal'である
     (setq m2 (copy-marker m1))
          => #<marker at 101 in markers.texi>
     (eq m1 m2)
          => nil
     (equal m1 m2)
          => t

     ;; マーカを使い終ったら、どこも指していないようにする
     (set-marker m1 nil)
          => #<marker in no buffer>



File: elisp-ja.info, Node: Predicates on Markers, Next: Creating Markers, Prev: Overview of Markers, Up: Markers

マーカ向けの述語
================

オブジェクトがマーカであるかどうかや、オブジェクトが整数かマーカであるか
どうかを検査できます。マーカと整数の両者を扱う算術関数に関連して、後者の
検査は有用です。

 -- Function: markerp OBJECT
     この関数は、OBJECTがマーカであれば`t'を返し、さもなければ`nil'を返
     す。多くの関数がマーカや整数を受け付けるが、整数はマーカではないこ
     とに注意すること。

 -- Function: integer-or-marker-p OBJECT
     この関数は、OBJECTが整数かマーカであると`t'を返し、さもなければ
     `nil'を返す。

 -- Function: number-or-marker-p OBJECT
     この関数は、OBJECTが数（整数か浮動小数点数）かマーカであると`t'を返
     し、さもなければ`nil'を返す。



File: elisp-ja.info, Node: Creating Markers, Next: Information from Markers, Prev: Predicates on Markers, Up: Markers

マーカ作成関数
==============

新たにマーカを作成するときには、そのマーカが、どこも指していない、現在の
ポイント位置を指している、バッファの参照可能部分の先頭や末尾を指している、
別のマーカと同じ箇所を指しているのいずれかにできます。

 -- Function: make-marker
     この関数は、どこも指していない新たに作成したマーカを返す。

          (make-marker)
               => #<marker in no buffer>

 -- Function: point-marker
     この関数は、カレントバッファの現在のポイント位置を指す新たに作成し
     たマーカを返す。*Note Point::。例については、下記の`copy-marker'を
     参照。

 -- Function: point-min-marker
     この関数は、バッファの参照可能部分の先頭を指す新たに作成したマーカ
     を返す。ナロイングしていなければ、これはバッファの先頭である。*Note
     Narrowing::。

 -- Function: point-max-marker
     この関数は、バッファの参照可能部分の末尾を指す新たに作成したマーカ
     を返す。ナロイングしていなければ、これはバッファの末尾である。*Note
     Narrowing::。

     本章のソースファイル（の原文）を入れたバッファでのこの関数と
     `point-min-marker'の例を示す。

          (point-min-marker)
               => #<marker at 1 in markers.texi>
          (point-max-marker)
               => #<marker at 15573 in markers.texi>

          (narrow-to-region 100 200)
               => nil
          (point-min-marker)
               => #<marker at 100 in markers.texi>
          (point-max-marker)
               => #<marker at 200 in markers.texi>

 -- Function: copy-marker MARKER-OR-INTEGER &optional INSERTION-TYPE
     引数としてマーカを渡されると、`copy-marker'は、MARKER-OR-INTEGERが
     指すのと同じバッファとバッファ内位置を指す新たなマーカを返す。引数
     として整数を渡されると、`copy-marker'は、カレントバッファで位置
     MARKER-OR-INTEGERを指す新たなマーカを返す。

     新たなマーカの挿入型は引数INSERTION-TYPEで指定する。*Note Marker
     Insertion Types::。

     渡された整数引数が1未満であると、`copy-marker'は、カレントバッファ
     でバッファの先頭を指す新たなマーカを返す。渡された整数引数がバッファ
     の長さより大きいと、`copy-marker'は、バッファの末尾を指す新たなマー
     カを返す。

          (copy-marker 0)
               => #<marker at 1 in markers.texi>

          (copy-marker 20000)
               => #<marker at 7572 in markers.texi>

     MARKER-OR-INTEGERがマーカでも整数でもないと、エラーを通知する。

2つの異なるマーカが、同じバッファの同じバッファ内位置であるか、どちらも
どこも指していないときには、両者を（`eq'ではないが）`equal'とみなします。

     (setq p (point-marker))
          => #<marker at 2139 in markers.texi>

     (setq q (copy-marker p))
          => #<marker at 2139 in markers.texi>

     (eq p q)
          => nil

     (equal p q)
          => t



File: elisp-ja.info, Node: Information from Markers, Next: Marker Insertion Types, Prev: Creating Markers, Up: Markers

マーカの情報
============

本節では、マーカオブジェクトの構成要素を参照する関数について述べます。

 -- Function: marker-position MARKER
     この関数は、MARKERが指す位置を返す。あるいは、MARKERがどこも指して
     いなければ`nil'を返す。

 -- Function: marker-buffer MARKER
     この関数は、MARKERが指すバッファを返す。あるいは、MARKERがどこも指
     していなければ`nil'を返す。

          (setq m (make-marker))
               => #<marker in no buffer>
          (marker-position m)
               => nil
          (marker-buffer m)
               => nil

          (set-marker m 3770 (current-buffer))
               => #<marker at 3770 in markers.texi>
          (marker-buffer m)
               => #<buffer markers.texi>
          (marker-position m)
               => 3770



File: elisp-ja.info, Node: Marker Insertion Types, Next: Moving Markers, Prev: Information from Markers, Up: Markers

マーカの挿入型
==============

マーカが指す箇所に直接テキストを挿入すると、マーカの再配置方法には2つの
可能性、つまり、挿入したテキストのまえに留まるか、あとにくるかのどちらか
です。マーカの"挿入型"（insertion type）を設定することで、あるマーカでは
どちらを選ぶか指定できます。`insert-before-markers'を使うとマーカの挿入
型は無視され、マーカは挿入したテキストのうしろにつねに再配置されることに
注意してください。

 -- Function: set-marker-insertion-type MARKER TYPE
     この関数は、マーカMARKERの挿入型をTYPEとする。TYPEが`t'であると、テ
     キストが挿入されるとMARKERはその位置へ進む。TYPEが`nil'であると、テ
     キストが挿入されてもMARKERはその位置へ進まない。

 -- Function: marker-insertion-type MARKER
     この関数は、MARKERの現在の挿入型を報告する。



File: elisp-ja.info, Node: Moving Markers, Next: The Mark, Prev: Marker Insertion Types, Up: Markers

マーカ位置の移動
================

本節では、既存のマーカの位置を変更する方法について述べます。これを行うと
きには、読者のプログラムの外側で当該マーカが使われているかどうか、使われ
ているときには移動による効果はなにかを確実に理解してください。さもないと、
Emacsの別の部分で混乱を生じるかもしれません。

 -- Function: set-marker MARKER POSITION &optional BUFFER
     この関数は、BUFFERにおいてMARKERをPOSITIONへ移動する。BUFFERを与え
     ないと、デフォルトはカレントバッファである。

     POSITIONが1未満であると、`set-marker'はMARKERをバッファの先頭へ移動
     する。POSITIONがバッファのサイズよりも大きいと、`set-marker'は
     MARKERをバッファの末尾へ移動する。POSITIONが`nil'であったりどこも指
     していないマーカであると、MARKERはどこも指さないようにする。

     戻り値はMARKERである。

          (setq m (point-marker))
               => #<marker at 4714 in markers.texi>
          (set-marker m 55)
               => #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               => #<buffer foo>
          (set-marker m 0 b)
               => #<marker at 1 in foo>

 -- Function: move-marker MARKER POSITION &optional BUFFER
     これは`set-marker'の別名である。



File: elisp-ja.info, Node: The Mark, Next: The Region, Prev: Moving Markers, Up: Markers

マーク
======

各バッファの1つの特別なマーカを"マーク"（mark）として区別します。これは、
`kill-region'や`indent-rigidly'などのコマンド向けにユーザーのために位置
を記録するものです。Lispプログラムでは、ユーザーが使う可能性のある値だけ
をマークに設定し、プログラムの内部向けにはけっしてマークを使いません。た
とえば、コマンド`replace-regexp'は、置換を行うまえのポイント値をマークに
設定します。置換を完了したあとに、ユーザーが手軽にまえの位置に戻れるよう
にするためです。

多くのコマンドは、対話的に呼ばれるとポイントとマークのあいだのテキストに
作用するように設計されています。読者がそのようなコマンドを書くときには、
マークを直接検査しないでください。そのかわりに、`r'を指定した
`interactive'を使います。こうすると、対話的に呼ばれるとポイントとマーク
の値がコマンドの引数に与えられますが、別のLispプログラムからは引数を明示
できます。*Note Interactive Codes::。

各バッファには、他のバッファのマークの値とは独立な独自のマークの値があり
ます。バッファが作成されると、マークは存在しますがどこも指さない状態です。
これを『バッファのマークは欠如している』状態とみなします。

バッファでいったんマークが『存在』するようになれば、マークが存在しなくな
ることは普通はありません。しかし、暫定マーク（transient-mark）モードをオ
ンにすると、マークが"不活性"になることはあります。すべてのバッファでつね
にバッファローカルな変数`mark-active'がマークが活性かどうかを表します。
その値が`nil'以外であるとマークは活性です。コマンドで`deactivate-mark'に
`nil'以外の値を設定すると、エディタコマンドループに戻ったときにマークを
不活性にするようにできます（ただし、暫定マーク（transient-mark）モードが
オンの場合に限る）。

暫定マーク（transient-mark）モードを使う主な目的は、マークが活性であると
このモードはリージョンを強調表示するからです。*Note Display::。

マークに加えて、各バッファには"マークリング"（mark ring）、つまり、マー
クの以前の値を保持したリストがあります。編集コマンドがマークを変更すると、
通常、編集コマンドはマークの古い値をマークリングに保存します。変数
`mark-ring-max'で、マークリングに収める要素の最大個数を指定します。リス
トがこの長さに達すると、新たな要素を加えるたびに古い要素を削除します。

 -- Function: mark &optional FORCE
     この関数は、カレントバッファのマーク位置を整数で返す。

     マークが不活性であると、通常、`mark'はエラーを通知する。しかし、
     FORCEが`nil'以外であると`mark'はマーク位置を返すが、当該バッファで
     マークが設定されたことがなければ`nil'を返す。

 -- Function: mark-marker
     この関数は、カレントバッファのマークを返す。これは、Emacs内部のマー
     ク位置を記録したマーカそのものであり、コピーではない。したがって、
     このマーカの位置を変更すると、マークの位置に直接影響する。この効果
     を望まない限り、そのようにしないこと。

          (setq m (mark-marker))
               => #<marker at 3420 in markers.texi>
          (set-marker m 100)
               => #<marker at 100 in markers.texi>
          (mark-marker)
               => #<marker at 100 in markers.texi>

     他のマーカと同様に、このマーカは任意のバッファでポイントを指すよう
     にできる。マークが指しているバッファ以外のバッファ内位置を指すこと
     は勧めない。そのようにすると、一貫性はあるが妙な結果を生じる。


 -- Function: set-mark POSITION
     この関数は、位置POSITIONにマークを設定し、マークを活性にする。マー
     クの古い値はマークリングに保存し*ない*。

     *注意：*` 'ユーザーにマークが移動したことを示し、かつ、まえのマーク
     位置を破棄したい場合にのみこの関数を使うこと。通常、新たにマークを
     設定したときには、古いマークを`mark-ring'に入れるべきである。この理
     由から、ほとんどのアプリケーションでは、`set-mark'ではなく
     `push-mark'と`pop-mark'を使うべきである。

     Emacs Lispの初心者プログラマは、誤った目的にマークを使いがちである。
     マークはユーザーの便宜のための位置を保存する。編集コマンドは、コマ
     ンドのユーザーレベルの機能の一部としてマークを変更する以外には、マー
     クを変更してはならない。（変更する場合には、その効果を明文化してお
     くべきである。）Lispプログラムの内部で使う位置を記録するには、Lisp
     変数に保存する。たとえばつぎのようにする。

          (let ((beg (point)))
            (forward-line 1)
            (delete-region beg (point))).


 -- Function: push-mark &optional POSITION NOMSG ACTIVATE
     この関数は、カレントバッファのマークをPOSITIONとし、以前のマークの
     コピーを`mark-ring'へ入れる。POSITIONが`nil'であると、ポイントの値
     を使う。`push-mark'は`nil'を返す。

     関数`push-mark'は、通常、マークを活性に*しない*。活性にするには引数
     ACTIVATEに`t'を指定する。

     NOMSGが`nil'であると、メッセージ`Mark set'を表示する。

 -- Function: pop-mark
     この関数は、`mark-ring'から先頭要素を取り出し、そのマークをカレント
     バッファの実際のマークとする。バッファのポイントは移動しない。また、
     `mark-ring'が空であるとなにもしない。マークを不活性にする。

     戻り値に意味はない。

 -- User Option: transient-mark-mode
     この変数が`nil'以外であると暫定マーク（transient-mark）モードがオン
     であるが、バッファを変更する各基本関数は`deactivate-mark'に設定する。
     つまり、バッファを変更するコマンドは、通常、マークを不活性にする。

 -- User Option: mark-even-if-inactive
     これが`nil'以外であると、LispプログラムやEmacsユーザーは、マークが
     不活性であってもマークを使える。このオプションは、暫定マーク
     （transient-mark）モードのふるまいに影響する。このオプションが`nil'
     以外であると、マークが不活性になるとリージョンの強調表示を止めるが、
     マークを使うコマンドはマークが活性であるものとして動作する。

 -- Variable: deactivate-mark
     編集コマンドがこの変数に`nil'以外を設定すると、エディタコマンドルー
     プは（暫定マーク（transient-mark）モードがオンであると）コマンドか
     ら戻るとマークを不活性にする。コマンドが終了したらマークを不活性に
     するために、バッファを変更するすべての基本関数は`deactivate-mark'に
     設定する。

 -- Function: deactivate-mark
     この関数は、暫定マーク（transient-mark）モードがオンであるとマーク
     を不活性にする。さもなければなにもしない。

 -- Variable: mark-active
     この変数が`nil'以外であると、マークは活性である。この変数は各バッファ
     においてつねにバッファローカルである。

 -- Variable: activate-mark-hook
 -- Variable: deactivate-mark-hook
     これらのノーマルフックは、それぞれ、マークが活性になったとき、不活
     性になったときに実行される。マークが活性でありリージョンが変更され
     たときには、フック`activate-mark-hook'はコマンドの終りでも実行され
     る。

 -- Variable: mark-ring
     このバッファローカルな変数の値は、カレントバッファで保存したマーク
     を最新のものから順に並べたリストである。

          mark-ring
          => (#<marker at 11050 in markers.texi> 
              #<marker at 10832 in markers.texi>
              ...)

 -- User Option: mark-ring-max
     この変数の値は、`mark-ring'の最大の大きさである。これより多くのマー
     クを`mark-ring'に積むと、`push-mark'は新しいものを追加するときに古
     いものを削除する。



File: elisp-ja.info, Node: The Region, Prev: The Mark, Up: Markers

リージョン
==========

ポイントとマークのあいだのテキストを"リージョン"（region）といいます。さ
まざまな関数がポイントとマークで区切られたテキストに作用しますが、リージョ
ンそのものに特に関連した関数だけについてここで述べます。

 -- Function: region-beginning
     この関数は、リージョンの先頭の位置を（整数で）返す。これは、ポイン
     トかマークの小さいほうの位置である。

     マークがどこも指していなければ、エラーを通知する。

 -- Function: region-end
     この関数は、リージョンの末尾の位置を（整数で）返す。これは、ポイン
     トかマークの大きいほうの位置である。

     マークがどこも指していなければ、エラーを通知する。

関数`region-beginning'や`region-end'を使う必要があるプログラムはほとんど
ないはずです。リージョンに作用するように設計されたコマンドは、普通、`r'
を指定した`interactive'を使ってリージョンの先頭と末尾をみつけます。これ
により、Lispプログラムからは引数として境界を明示的に指定できます。
（*Note Interactive Codes::。）


File: elisp-ja.info, Node: Text, Next: Non-ASCII Characters, Prev: Markers, Up: Top

テキスト
********

本章では、バッファ内のテキストを扱う関数について述べます。それらのほとん
どは、カレントバッファ内のテキストを調べたり挿入したり削除しますが、しば
しばポイント付近で行います。多くは対話的に使えます。テキストを変更するす
べての関数は、変更を取り消せます（*Note Undo::）。

テキスト関連の多くの関数は、STARTとENDという名前の引数で渡された2つのバッ
ファ内位置で定義されるテキストの領域に作用します。これらの引数は、マーカ
（*Note Markers::）であるか文字の位置を表す数値（*Note Positions::）であ
る必要があります。これらの引数の順番は関係なく、STARTが領域の終了位置で
ENDが開始位置であってもまったく問題ありません。たとえば、`(delete-region
1 10)'と`(delete-region 10 1)'は同値です。STARTやENDがバッファの参照可能
部分の外側にあるとエラー`args-out-of-range'を通知します。対話的な呼び出
しでは、ポイントとマークをこれらの引数として使います。

本章では、バッファ内の文字を（関係あるときには）それらのテキスト属性を含
めて『テキスト』と呼びます。

* Menu:

* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Transposition::    Swapping two portions of a buffer.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Change Hooks::     Supplying functions to be run when text is changed.



