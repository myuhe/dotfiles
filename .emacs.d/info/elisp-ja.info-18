Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Near Point, Next: Buffer Contents, Prev: Text, Up: Text

ポイント付近のテキストを調べる
==============================

多くの関数は、ポイント付近の文字を調べるためのものです。ここでは、数個の
単純な関数について述べます。*Note Regexp Search::の`looking-at'も参照し
てください。

 -- Function: char-after &optional POSITION
     この関数は、カレントバッファ内の位置POSITIONにある（つまり直後の）
     文字を返す。POSITIONがバッファの先頭のまえや末尾のうしろにあるなど
     してこの目的に適した範囲の外側にあると、値は`nil'である。POSITIONの
     デフォルトはポイントである。

     つぎの例では、バッファの最初の文字は`@'であると仮定する。

          (char-to-string (char-after 1))
               => "@"

 -- Function: char-before &optional POSITION
     この関数は、カレントバッファ内の位置POSITIONのまえにある文字を返す。
     POSITIONがバッファの先頭のまえや末尾のうしろにあるなどしてこの目的
     に適した範囲の外側にあると、値は`nil'である。POSITIONのデフォルトは
     ポイントである。

 -- Function: following-char
     この関数は、カレントバッファのポイントのうしろにある文字を返す。こ
     れは`(char-after (point))'と同様である。しかし、ポイントがバッファ
     の末尾にあると、`following-char'は0を返す。

     ポイントはつねに文字のあいだにあり、端末のカーソルはポイントの直後
     の文字に重ねて表示されることに注意してほしい。したがって、
     `following-char'が返す文字は、カーソルが重なっている文字である。

     つぎの例では、ポイントは`a'と`c'のあいだにある。

          ---------- Buffer: foo ----------
          Gentlemen may cry "Pea-!-ce! Peace!,"
          but there is no peace.
          ---------- Buffer: foo ----------

          (char-to-string (preceding-char))
               => "a"
          (char-to-string (following-char))
               => "c"

 -- Function: preceding-char
     この関数は、カレントバッファのポイントのまえの文字を返す。例につい
     ては上記の`following-char'を参照。ポイントがバッファの先頭にあると、
     `preceding-char'は0を返す。

 -- Function: bobp
     この関数は、ポイントがバッファの先頭にあると`t'を返す。ナロイングし
     ていると、これはバッファの参照可能部分の先頭を意味する。*Note
     Point::の`point-min'も参照。

 -- Function: eobp
     この関数は、ポイントがバッファの末尾にあると`t'を返す。ナロイングし
     ていると、これはバッファの参照可能部分の末尾を意味する。*Note
     Point::の`point-max'も参照。

 -- Function: bolp
     この関数は、ポイントが行頭にあると`t'を返す。*Note Text Lines::。バッ
     ファ（あるいはその参照可能部分）の先頭は、つねに行頭とみなす。

 -- Function: eolp
     この関数は、ポイントが行末にあると`t'を返す。*Note Text Lines::。バッ
     ファ（あるいはその参照可能部分）の末尾は、つねに行末とみなす。



File: elisp-ja.info, Node: Buffer Contents, Next: Comparing Text, Prev: Near Point, Up: Text

バッファの内容を調べる
======================

本節では、Lispプログラムでバッファ内の任意の部分のテキストを文字列に変換
するための2つの関数について述べます。

 -- Function: buffer-substring START END
     この関数は、カレントバッファのSTARTとENDの位置で定義される領域のテ
     キストのコピーを含んだ文字列を返す。引数がバッファの参照可能部分の
     内側の位置でないと、`buffer-substring'はエラー`args-out-of-range'を
     通知する。

     STARTがENDより小さい必要はなく、引数の順番はどちらでもよい。しかし、
     ほとんどの場合、小さい引数を先に書く。

     コピーされるテキストにテキスト属性がある場合、テキスト属性もそれが
     属する文字とともに文字列へコピーされる。*Note Text Properties::。し
     かし、バッファのオーバレイ（*Note Overlays::）とそれらの属性は無視
     されコピーされない。

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-substring 1 10)
          => "This is t"
          (buffer-substring (point-max) 10)
          => "he contents of buffer foo
          "

 -- Function: buffer-substring-no-properties START END
     この関数は`buffer-substring'と同様であるが、テキスト属性をコピーせ
     ずに文字だけをコピーする点が異なる。*Note Text Properties::。

 -- Function: buffer-string
     この関数は、カレントバッファの参照可能部分全体の内容を文字列として
     返す。これは、つぎと等価である。

          (buffer-substring (point-min) (point-max))

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-string)
               => "This is the contents of buffer foo
          "

 -- Function: thing-at-point THING
     ポイントの周りやそのうしろにあるTHINGを文字列として返す。

     引数THINGは、構文上の要素の種類を指定するシンボルである。可能な値は、
     `symbol'、`list'、`sexp'、`defun'、`filename'、`url'、`word'、
     `sentence'、`whitespace'、`line'、`page'などである。

          ---------- Buffer: foo ----------
          Gentlemen may cry "Pea-!-ce! Peace!,"
          but there is no peace.
          ---------- Buffer: foo ----------

          (thing-at-point 'word)
               => "Peace"
          (thing-at-point 'line)
               => "Gentlemen may cry "Peace! Peace!,"\n"
          (thing-at-point 'whitespace)
               => nil



File: elisp-ja.info, Node: Comparing Text, Next: Insertion, Prev: Buffer Contents, Up: Text

テキストの比較
==============

この関数により、バッファ内のテキストの部分同士を文字列にコピーせずに比較
できます。

 -- Function: compare-buffer-substrings BUFFER1 START1 END1 BUFFER2 START2 END2
     この関数は、同一バッファ内の2つの部分文字列、あるいは、異なる2つの
     バッファの部分文字列を比較する。始めの3つの引数は、バッファとそのバッ
     ファ内の2つの位置を与え、1つの部分文字列を指定する。残りの3つの引数
     も同様にして別の部分文字列を指定する。カレントバッファを表すために、
     BUFFER1とBUFFER2のいずれか、あるいは、両方に`nil'を指定できる。

     始めの文字列のほうが小さければ値は負であり、始めのほうが大きければ
     値は正であり、等しければ0である。結果の絶対値は、部分文字列の中で最
     初に異なる文字の添字足す1である。

     この関数は、`case-fold-search'が`nil'以外であると、文字の比較では大
     文字小文字を区別しない。テキスト属性はつねに無視する。

     カレントバッファにはテキスト`foobarbar haha!rara!'があるとする。す
     ると、この例の2つの部分文字列は`rbar 'と`rara!'である。2番目の文字
     で最初の文字列のほうが大きいので、結果は2である。

          (compare-buffer-substring nil 6 11 nil 16 21)
               => 2



File: elisp-ja.info, Node: Insertion, Next: Commands for Insertion, Prev: Comparing Text, Up: Text

テキストの挿入
==============

"挿入"（insertion）とは、バッファに新たなテキストを追加することです。挿
入されたテキストはポイント位置に、つまり、ポイントのまえの文字とポイント
のあとの文字のあいだに入ります。挿入されたテキストのまえにポイントを留め
る関数もあれば、そのうしろに留める関数もあります。前者を"ポイントのうし
ろへ"挿入と呼び、後者を"ポイントのまえへ"挿入と呼びます。

挿入により、挿入箇所よりうしろの位置を指すマーカは再配置されて同じ周りの
文字に留まります（*Note Markers::）。マーカが挿入箇所を指している場合に
は、マーカの挿入型（*Note Marker Insertion Types::）に依存して、挿入する
とマーカが再配置されたりされなかったりします。`insert-before-markers'な
どの特定の特殊な関数は、マーカの挿入型に関わらず、挿入されたテキストのう
しろを指すようにそのようなすべてのマーカを再配置します。

カレントバッファが読み出し専用であると、挿入関数はエラーを通知します。

これらの関数は、テキストの文字群をそれらの属性とともに文字列からバッファ
へコピーします。挿入された文字群は、コピーされるまえとまったく同じ属性を
持ちます。対照的に、文字列やバッファの一部ではない孤立した引数として指定
された文字群は、周りのテキストからテキスト属性を継承します。

挿入関数は、文字列由来やバッファ由来のテキストの場合には、マルチバイトバッ
ファへ挿入するためにユニバイトからマルチバイトへテキストを変換し、逆向き
の変換も行います。しかし、カレントバッファがたとえマルチバイトバッファで
あっても、128から255のユニバイト文字コードはマルチバイト文字には変換しま
せん。*Note Converting Representations::。

 -- Function: insert &rest ARGS
     この関数は、文字列や文字群ARGSをカレントバッファのポイント位置に挿
     入し、ポイントを先へ進める。いいかえれば、ポイントのまえにテキスト
     を挿入する。ARGSが文字列でも文字でもないと、エラーを通知する。値は
     `nil'である。

 -- Function: insert-before-markers &rest ARGS
     この関数は、文字列や文字群ARGSをカレントバッファのポイント位置に挿
     入し、ポイントを先へ進める。ARGSが文字列でも文字でもないと、エラー
     を通知する。値は`nil'である。

     挿入箇所を指していたマーカを挿入されたテキストのうしろを指すように
     再配置する点で、この関数は他の挿入関数と異なる。挿入箇所でオーバレ
     イが始まるときには、挿入されたテキストはオーバレイの範囲外に出る。
     空でないオーバレイが挿入箇所で終るときには、挿入されたテキストはオー
     バレイの範囲内に入る。

 -- Function: insert-char CHARACTER &optional COUNT INHERIT
     この関数は、カレントバッファのポイントのまえに文字CHARACTERをCOUNT
     個挿入する。引数COUNTは数（`nil'は1を意味する）であり、CHARACTERは
     文字であること。値は`nil'である。

     この関数は、カレントバッファがたとえマルチバイトバッファであっても、
     128から255のユニバイト文字コードはマルチバイト文字には変換しない。
     *Note Converting Representations::。

     INHERITが`nil'以外であると、挿入された文字は、挿入箇所の前後の2つの
     文字からスティッキテキスト属性を継承する。

 -- Function: insert-buffer-substring FROM-BUFFER-OR-NAME &optional START END
     この関数は、バッファFROM-BUFFER-OR-NAME（既存であること）の部分をカ
     レントバッファのポイントのまえへ挿入する。挿入されるテキストはSTART
     からENDまでの領域である。（これらの引数のデフォルトは、当該バッファ
     の参照可能部分の先頭と末尾である。）この関数は`nil'を返す。

     この例では、バッファ`bar'をカレントバッファとしてフォームを実行する。
     バッファ`bar'は最初は空であると仮定する。

          ---------- Buffer: foo ----------
          We hold these truths to be self-evident, that all
          ---------- Buffer: foo ----------

          (insert-buffer-substring "foo" 1 20)
               => nil

          ---------- Buffer: bar ----------
          We hold these truth-!-
          ---------- Buffer: bar ----------

挿入に加えて周りのテキストからテキスト属性を継承する他の関数については、
*Note Sticky Properties::。字下げ関数が挿入した白文字もテキスト属性を継
承します。



File: elisp-ja.info, Node: Commands for Insertion, Next: Deletion, Prev: Insertion, Up: Text

ユーザーレベルの挿入コマンド
============================

本節では、テキストを挿入する上位レベルのコマンドについて述べます。これら
はLispプログラムでも有用ですが主にユーザー向けのコマンドです。

 -- コマンド: insert-buffer FROM-BUFFER-OR-NAME
     このコマンドは、FROM-BUFFER-OR-NAME（既存であること）の全内容をカレ
     ントバッファのポイントのうしろに挿入する。挿入されたテキストのうし
     ろにマークを置く。値は`nil'である。

 -- コマンド: self-insert-command COUNT
     このコマンドは、最後に打たれた文字を挿入する。ポイントのまえにCOUNT
     回挿入して`nil'を返す。ほとんどの印字文字はこのコマンドにバインドさ
     れている。普通の状況では、`self-insert-command'はEmacsにおいてもっ
     とも頻繁に呼び出される関数であるが、プログラムではキーマップに登録
     する以外にはほとんど使わない。

     対話的に呼ばれると、COUNTは数値前置引数である。

     このコマンドは、挿入した文字が空白や改行であると、
     `auto-fill-function'が`nil'以外であると`auto-fill-function'を呼び出
     す（*Note Auto Filling::）。

     このコマンドは、略語（abbrev）モードがオンであり、かつ、挿入した文
     字が単語構成構文でないと、略語展開を行う。（*Note Abbrevs::と*Note
     Syntax Class Table::。）

     挿入した文字が閉じ括弧構文であるときに`blink-paren-function'を呼び
     出す責任も持つ（*Note Blinking::）。

 -- コマンド: newline &optional NUMBER-OF-NEWLINES
     このコマンドは、カレントバッファのポイントのまえに改行を挿入する。
     NUMBER-OF-NEWLINESを指定すると、その個数だけ改行文字を挿入する。

     この関数は、現在のコラム番号が`fill-column'の値よりも大きく
     NUMBER-OF-NEWLINESが`nil'であると`auto-fill-function'を呼び出す。
     `auto-fill-function'の典型的な仕事は改行を挿入することである。ここ
     での全体としての効果は、改行を2つの異なる位置、つまり、ポイント位置
     と行のまえの箇所に挿入することである。`newline'は、
     NUMBER-OF-NEWLINESが`nil'以外であると自動詰め込みを行わない。

     このコマンドは、左端の余白が0以外であるとその分だけ字下げする。
     *Note Margins::。

     戻り値は`nil'である。対話的に呼ばれると、COUNTは数値前置引数である。

 -- コマンド: split-line
     このコマンドは、行のポイントのうしろの部分を垂直に降ろして変更前の
     真下に行を移動することで現在行を分割する。関数`indent-to'を用いて、
     降ろした行の先頭に必要に応じて白文字を挿入する。

     プログラムではまったくこの関数を使わない。

 -- Variable: overwrite-mode
     この変数は、上書き（overwrite）モードがオンかどうかを制御する。この
     値は、`overwrite-mode-textual'、`overwrite-mode-binary'、`nil'のい
     ずれかであること。`overwrite-mode-textual'は、テキストの上書きモー
     ド（改行とタブを特別に扱う）を指定し、`overwrite-mode-binary'は、バ
     イナリの上書きモード（改行やタブも他の文字と同様に扱う）を指定する。



File: elisp-ja.info, Node: Deletion, Next: User-Level Deletion, Prev: Commands for Insertion, Up: Text

テキストの削除
==============

削除とは、バッファ内のテキストのある部分をキルリング（*Note The Kill
Ring::）に保存せずに取りさることです。削除したテキストはヤンクはできませ
んが、アンドゥ機構（*Note Undo::）を使って再度挿入できます。特別な場合に
はキルリングにテキストを保存する削除関数もあります。

すべての削除関数はカレントバッファに作用し、`nil'の値を返します。

 -- コマンド: erase-buffer
     この関数は、カレントバッファから全テキストを削除して空にする。バッ
     ファが読み出し専用であると、エラー`buffer-read-only'を通知する。さ
     もなければ、いっさい確認を取らずにテキストを削除する。`nil'を返す。

     バッファから多量のテキストを削除すると、通常、『バッファが縮小した』
     としてそのバッファの自動保存を禁止する。しかし、`erase-buffer'はこ
     うしない。これまでのテキストと将来のテキストには関連がなく、これま
     でのテキストのサイズと比較すべきでないと考えるからである。

 -- コマンド: delete-region START END
     このコマンドは、STARTとENDで定義されるカレントバッファのテキストを
     削除する。戻り値は`nil'である。削除された領域の内側にポイントがある
     と、その値は削除後にはSTARTになる。さもなければ、マーカと同様にポイ
     ントは周りのテキストに留まるように再配置される。

 -- コマンド: delete-char COUNT &optional KILLP
     このコマンドは、ポイントの直後の、あるいは、COUNTが負であるとポイン
     トの直前のCOUNT個の文字を削除する。KILLPが`nil'以外であると、削除し
     た文字をキルリングに保存する。

     対話的に呼ばれると、COUNTは数値前置引数であり、KILLPは未処理の前置
     引数である。つまり、前置引数を指定すると、テキストをキルリングに保
     存する。前置引数を指定しないと1文字だけを削除するが、キルリングには
     保存しない。

     戻り値はつねに`nil'である。

 -- コマンド: delete-backward-char COUNT &optional KILLP
     このコマンドは、ポイントの直前の、あるいは、COUNTが負であるとポイン
     トの直後のCOUNT個の文字を削除する。KILLPが`nil'以外であると、削除し
     た文字をキルリングに保存する。

     対話的に呼ばれると、COUNTは数値前置引数であり、KILLPは未処理の前置
     引数である。つまり、前置引数を指定すると、テキストをキルリングに保
     存する。前置引数を指定しないと1文字だけを削除するが、キルリングには
     保存しない。

     戻り値はつねに`nil'である。

 -- コマンド: backward-delete-char-untabify COUNT &optional KILLP
     このコマンドは、タブを空白にかえながら後向きにCOUNT個の文字を削除す
     る。つぎに削除する文字がタブであると、まずタブを配置を保つだけの等
     価な個数の空白に置換してから、タブのかわりにそれらの空白を削除する。
     KILLPが`nil'以外であると、このコマンドは削除した文字をキルリングに
     保存する。

     COUNTが正である場合に限って、タブを空白に変換する。
     COUNTが負であると、ポイントのうしろのちょうど
     -COUNT個の文字を削除する。

     対話的に呼ばれると、COUNTは数値前置引数であり、KILLPは未処理の前置
     引数である。つまり、前置引数を指定すると、テキストをキルリングに保
     存する。前置引数を指定しないと1文字だけを削除するが、キルリングには
     保存しない。

     戻り値はつねに`nil'である。

 -- User Option: backward-delete-char-untabify-method
     このオプションは、`backward-delete-char-untabify'での白文字の扱い方
     を指定する。可能な値は、タブを空白に変換してから空白を削除すること
     を意味するデフォルトの`untabify'、1回の呼び出しでポイントのまえにあ
     る白文字をすべて削除することを意味する`hungry'、白文字に対して特別
     なことをしないことを意味する`nil'である。



File: elisp-ja.info, Node: User-Level Deletion, Next: The Kill Ring, Prev: Deletion, Up: Text

ユーザーレベルの削除コマンド
============================

本節では、テキストを削除する上位レベルのコマンドについて述べます。これら
はLispプログラムでも有用ですが主にユーザー向けのコマンドです。

 -- コマンド: delete-horizontal-space
     この関数は、ポイントの周りの空白やタブをすべて削除する。`nil'を返す。

     つぎの例では、毎回ポイントを2番目と3番目の文字のあいだに置いて、各
     行につき1回ずつ`delete-horizontal-space'を計4回呼び出す。

          ---------- Buffer: foo ----------
          I -!-thought
          I -!-     thought
          We-!- thought
          Yo-!-u thought
          ---------- Buffer: foo ----------

          (delete-horizontal-space)   ; Four times.
               => nil

          ---------- Buffer: foo ----------
          Ithought
          Ithought
          Wethought
          You thought
          ---------- Buffer: foo ----------

 -- コマンド: delete-indentation &optional JOIN-FOLLOWING-P
     この関数は、ポイントがある行をそのまえの行に連結する。連結箇所の白
     文字は削除し、場合によっては空白1個に置き換える。JOIN-FOLLOWING-Pが
     `nil'以外であると、`delete-indentation'は、この行を後続の行に連結す
     る。関数は`nil'を返す。

     詰め込み接頭辞があり、かつ、連結対象の2番目の行がその接頭辞で始まっ
     ている場合には、`delete-indentation'は連結するまえに詰め込み接頭辞
     を削除する。*Note Margins::。

     以下の例では、ポイントは`events'で始まる行にあり、そのまえの行の行
     末に空白があっても違いはない。

          ---------- Buffer: foo ----------
          When in the course of human
          -!-    events, it becomes necessary
          ---------- Buffer: foo ----------

          (delete-indentation)
               => nil

          ---------- Buffer: foo ----------
          When in the course of human-!- events, it becomes necessary
          ---------- Buffer: foo ----------

     行を連結したあと、関数`fixup-whitespace'には、連結箇所に空白を置く
     かどうかを決定する責任がある。

 -- Function: fixup-whitespace
     この関数は、文脈に応じて、ポイントを囲む白文字すべてを1つの空白に置
     換するかまったくなくす。`nil'を返す。

     行の先頭や末尾では、空白の適切な量は0である。閉じ括弧構文の文字のま
     えや、開き括弧構文や式前置子構文の文字のうしろでも空白はないほうが
     適している。それ以外では、空白1個が適している。*Note Syntax Class
     Table::。

     以下の例では、最初の行の単語`spaces'のまえにポイントがあるときに最
     初に`fixup-whitespace'が呼ばれる。2度目に呼ばれるときには、ポイント
     は`('の直後にある。

          ---------- Buffer: foo ----------
          This has too many     -!-spaces
          This has too many spaces at the start of (-!-   this list)
          ---------- Buffer: foo ----------

          (fixup-whitespace)
               => nil
          (fixup-whitespace)
               => nil

          ---------- Buffer: foo ----------
          This has too many spaces
          This has too many spaces at the start of (this list)
          ---------- Buffer: foo ----------

 -- コマンド: just-one-space
     このコマンドは、ポイントの周りのすべての空白やタブを1個の空白に置き
     換える。`nil'を返す。

 -- コマンド: delete-blank-lines
     この関数は、ポイントを囲む空行を削除する。前後に複数の空行がある空
     行にポイントがある場合、1つの空行を残してそれ以外はすべて削除する。
     孤立した1つの空行にポイントがある場合には、その行を削除する。空行で
     ない行にポイントがある場合には、その行のうしろにある空行をすべて削
     除する。

     空行とは、タブや空白のみから成る行と定義する。

     `delete-blank-lines'は`nil'を返す。



File: elisp-ja.info, Node: The Kill Ring, Next: Undo, Prev: User-Level Deletion, Up: Text

キルリング
==========

"キル関数"は削除関数のようにテキストを削除しますが、ユーザーが"ヤンク"
（yank）で再度挿入できるように保存します。これらの関数の多くは、その名前
に`kill-'があります。対照的に、`delete-'で始まる名前の関数は、ヤンクでき
るようにテキストを保存しません（アンドゥはできる）。それらは『削除』関数
です。

キルコマンドの多くは主に対話的に使うものであり、ここではそれらについては
述べません。ここで述べるのは、そのようなコマンドを書くために使う関数につ
いてです。これらの関数は読者がテキストをキルするコマンドを書くために使え
ます。Lisp関数において内部目的のためにテキストを削除する必要があるときに
は、キルリングの内容を乱さないように普通は削除関数を用いるべきです。
*Note Deletion::。

キルしたテキストはあとでヤンクできるように"キルリング"（kill ring）に保
存されます。これは、最後にキルしたテキストだけでなく、最近キルしたものを
多数保持するリストです。これを『リング』と呼ぶのは、要素が循環しているよ
うにヤンクが扱うからです。このリストは変数`kill-ring'に保持されていて、
リスト向けの通常の関数で操作できますが、本節で述べるように、それをリング
として扱う特別な関数もあります。

単語『キル』の使い方が不適当だと考える人々がいます。『キル』したものを特
に破壊*しない*操作を表すために使っているからです。日常生活に照らしてみる
と、死は恒久的であり『キル』したものが生き返ることはありません。したがっ
て、別の隠喩も提案されています。たとえば、原稿を鋏で切り貼りすることに慣
れていた前計算機世代の人々には『カットリング』のほうが意味が通じるでしょ
う。しかし、いまさら用語を変更するのは困難です。

* Menu:

* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::	   Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill-ring data.



File: elisp-ja.info, Node: Kill Ring Concepts, Next: Kill Functions, Prev: The Kill Ring, Up: The Kill Ring

キルリングの概念
----------------

キルリングは、もっとも最近にキルされたものを先頭にして、キルされたテキス
トを文字列としてリストに記録します。たとえば、短いキルリングはつぎのよう
になります。

     ("some text" "a different piece of text" "even older text")

リストの長さが`kill-ring-max'に達すると、新たな項目を追加すると自動的に
最後の項目を削除します。

キルコマンドが他のコマンドと混在する場合、各キルコマンドはキルリングに新
たな項目を追加します。連続した複数のキルコマンドは、キルリングに1つの項
目を作りあげ、それを1個としてヤンクできます。2番目以降の連続したキルコマ
ンドは、最初のキルコマンドが作った項目にテキストを追加していきます。

ヤンクでは、キルリングの1つの項目をリングの『先頭』として区別します。リ
ングの別の項目を『先頭』と指定することでリングを『回転』するコマンドもあ
ります。



File: elisp-ja.info, Node: Kill Functions, Next: Yank Commands, Prev: Kill Ring Concepts, Up: The Kill Ring

キル向けの関数
--------------

`kill-region'は、テキストをキルするための普通のサブルーティンです。この
関数を呼び出す任意のコマンドは『キルコマンド』です（その名前には`kill'が
あるはず）。`kill-region'は、新たにキルされたテキストをキルリングの先頭
に新たな項目として追加したり、もっとも最近の項目に加えます。まえのコマン
ドがキルコマンドであるかどうかを（`last-command'を使って）自動的に判定し、
もしそうならば、キルされたテキストをもっとも最近の項目に加えます。

 -- コマンド: kill-region START END
     この関数は、STARTとENDで定義される領域のテキストをキルする。テキス
     トは削除されるが、テキスト属性とともにキルリングに保存される。値は
     つねに`nil'である。

     対話的に呼ばれると、STARTとENDはポイントとマークである。

     バッファが読み出し専用であると、`kill-region'はキルリングを同様に変
     更するが、バッファを変更せずにエラーを通知する。読み出し専用バッファ
     からキルリングへテキストをコピーするために、ユーザーはすべてのキル
     コマンドを使えるのでこれは便利である。

 -- User Option: kill-read-only-ok
     このオプションが`nil'以外であると、`kill-region'は、バッファが読み
     出し専用であってもエラーとしない。そのかわりに、キルリングを更新し
     バッファは変更せずに戻る。

 -- コマンド: copy-region-as-kill START END
     このコマンドは、STARTとENDで定義される領域を（テキスト属性とともに）
     キルリングに保存するが、バッファからテキストを削除しない。`nil'を返
     す。また、カーソルを一時的に移動してコピーしたテキストの範囲を示す
     か、あるいは、エコー領域にメッセージを表示する。

     このコマンドは`this-command'に`kill-region'を設定しないので、これ以
     降のキルコマンドはキルリングの同じ項目には加えない。

     Emacs 18版でも使うつもりがない限り、Lispプログラムからは
     `copy-region-as-kill'を呼ばないこと。Emacsの新しい版では、そのかわ
     りに`kill-new'や`kill-append'を使うほうがよい。*Note Low-Level Kill
     Ring::。



File: elisp-ja.info, Node: Yank Commands, Next: Low-Level Kill Ring, Prev: Kill Functions, Up: The Kill Ring

ヤンク向けの関数
----------------

"ヤンク"（yank）とは、キルリングからまえにキルされたテキストの項目を再度
挿入することです。

 -- コマンド: yank &optional ARG
     このコマンドは、キルリングの先頭項目のテキストをポイントのまえに挿
     入する。そのテキストの先頭にマークを末尾にポイントを置く。

     ARGがリスト（対話的な呼び出しではユーザーが数字文字なしに`C-u'を打っ
     たとき）であると、`yank'は上に述べたようにテキストを挿入するが、ヤ
     ンクしたテキストの先頭にポイントを末尾にマークを置く。

     ARGが数であると、`yank'はARG番目のもっとも最近にキルされたテキスト、
     つまり、キルリングリストのARG番目の項目を挿入する。

     `yank'はキルリングの内容を変更したり回転しない。`nil'を返す。

 -- コマンド: yank-pop ARG
     このコマンドは、キルリングからヤンクした項目をキルリングの別の項目
     で置き換える。

     これは`yank'や別の`yank-pop'の直後でのみ許される。そのような場合、
     リージョンにはヤンクしたばかりのテキストが含まれる。`yank-pop'はそ
     のテキストを削除し、その位置にキルされた別のテキストを挿入する。削
     除したテキストはすでにキルリングのどこかにあるので、キルリングには
     追加しない。

     ARGが`nil'であると、キルリングの古い項目で置き換える。ARGが数である
     と、ARG番古いキルで置き換える。ARGが負であると、より最近のキルで置
     き換える。

     キルリング内でのキルの順番は、最古のもののつぎに最新のものがあり、
     最新のもののまえに最古のものがあるように折り返されている。

     戻り値はつねに`nil'である。



File: elisp-ja.info, Node: Low-Level Kill Ring, Next: Internals of Kill Ring, Prev: Yank Commands, Up: The Kill Ring

下位レベルのキルリング
----------------------

これらの関数と変数は、下位レベルでキルリングを参照するためのものですが、
Lispプログラムで使っても便利です。これらはウィンドウシステムのセレクショ
ン（*Note Window System Selections::）との相互作用の面倒をみてくれるから
です。

 -- Function: current-kill N &optional DO-NOT-MOVE
     関数`current-kill'は、キルリングの『先頭』として区別するヤンクポイ
     ンタを（新しいキルから古いキルへ向けて）N個分回転し、リングのその位
     置のテキストを返す。

     省略可能な第2引数DO-NOT-MOVEが`nil'以外であると、`current-kill'は、
     ヤンクポインタは変更せずに、現在のヤンクポインタから数えてN番目のキ
     ルを返す。

     Nが0であると、もっとも最近のキルを要求することを表し、
     `current-kill'は、キルリングを調べるまえに（以下に述べる）
     `interprogram-paste-function'の値を呼び出す。

 -- Function: kill-new STRING
     この関数は、テキストSTRINGを新たな項目としてキルリングの先頭に置く。
     必要ならば最古の項目を破棄する。`interprogram-cut-function'（下記参
     照）の値も起動する。

 -- Function: kill-append STRING BEFORE-P
     この関数は、キルリングの先頭項目にテキストSTRINGを追加する。通常、
     STRINGはその項目の末尾に加わるが、BEFORE-Pが`nil'以外であるとその項
     目の先頭に加わる。この関数は、`interprogram-cut-function'（下記参照）
     の値も起動する。

 -- Variable: interprogram-paste-function
     この変数は、ウィンドウシステムを使っているときに別のプログラムから
     キルされたテキストを転送する方法を提供する。その値は、`nil'であるか、
     引数なしの関数であること。

     値が関数であると、『もっとも最近のキル』を得るために`current-kill'
     が呼び出す。関数が`nil'以外の値を返すと、その値は『もっとも最近のキ
     ル』として使われる。`nil'を返せば、`kill-ring'の先頭項目が使われる。

     このフックの普通の用途は、セレクションが別のアプリケーションに属す
     る場合であっても、ウィンドウシステムの一次セレクションをもっとも最
     近のキルとして得ることである。*Note Window System Selections::。

 -- Variable: interprogram-cut-function
     この変数は、ウィンドウシステムを使っているときにキルされたテキスト
     を別のプログラムへ転送する方法を提供する。その値は、`nil'であるか、
     引数なしの関数であること。

     値が関数であると、`kill-new'と`kill-append'がキルリングの新たな先頭
     項目を引数として呼び出す。

     このフックの普通の用途は、新たにキルされたテキストをウィンドウシス
     テムの一次セレクションにすることである。*Note Window System
     Selections::。



File: elisp-ja.info, Node: Internals of Kill Ring, Prev: Low-Level Kill Ring, Up: The Kill Ring

キルリングの内部
----------------

変数`kill-ring'は、文字列のリストの形でキルリングの内容を保持します。もっ
とも最近のキルがつねにリストの先頭にあります。

変数`kill-ring-yank-pointer'は、CARがつぎにヤンクすべきテキストであるよ
うなキルリングリストの項目を指しています。この変数がリングの『先頭』を識
別するといいます。`kill-ring-yank-pointer'を別の項目へ動かすことを"キル
リングを回転する"と呼びます。ヤンクポインタを動かす関数は、リストの末尾
からリストの先頭へ折り返しその逆も行うので、キルリングを『リング』と呼ぶ
のです。リングの回転は仮想的なものであり、`kill-ring'の値は変更しません。

`kill-ring'も`kill-ring-yank-pointer'もLisp変数であり、それらの値は普通
のリストです。`kill-ring-yank-pointer'の名前の単語『ポインタ』は、つぎの
ヤンクコマンドで使うリストの項目を識別することが変数の目的であることを表
します。

`kill-ring-yank-pointer'の値は、キルリングリストの1つの項目とつねに`eq'
です。これが識別する項目は、その項目のCARです。キルリングを変更するキル
コマンドも、`kill-ring'の値をこの変数の値とします。その効果は、新たにキ
ルされたテキストが先頭にくるようにリングを回転することです。

キルリング`("some text" "a different piece of text" "yet older text")'の
第2項目を変数`kill-ring-yank-pointer'が指しているようすをつぎに示します。

     kill-ring                  ---- kill-ring-yank-pointer
       |                       |
       |                       v
       |     -- ---          -- ---      -- ---
        --> |   |   |------> |   |   |--> |   |   |--> nil
             -- ---          -- ---      -- ---
              |                |            |            
              |                |            |            
              |                |             -->"yet older text" 
              |                |
              |                 --> "a different piece of text" 
              |
               --> "some text"

`C-y'（`yank'）の直後に`M-y'（`yank-pop'）を使うとこの状態になります。

 -- Variable: kill-ring
     この変数は、もっとも最近にキルされたものを最初にしてキルされたテキ
     ストを順に並べたリストを保持する。

 -- Variable: kill-ring-yank-pointer
     この変数の値は、キルリングのどの要素がヤンクするためのリングの『先
     頭』であるかを表す。より正確には、その値は`kill-ring'のリストの一部
     であり、そのCARは`C-y'がヤンクするキルされた文字列である。

 -- User Option: kill-ring-max
     この変数の値は、末尾の要素が破棄されるまでにキルリングが増大できる
     最大の長さである。`kill-ring-max'のデフォルト値は30である。



File: elisp-ja.info, Node: Undo, Next: Maintaining Undo, Prev: The Kill Ring, Up: Text

アンドゥ
========

ほとんどのバッファには、バッファのテキストに対する変更をアンドゥ（もとに
戻す）できるようにすべての変更を記録する"アンドゥリスト"（undo list）が
あります。（アンドゥリストのないバッファは、Emacsがアンドゥは有用ではな
いと仮定する特殊目的のバッファである。）バッファのテキストを変更するすべ
ての基本関数は、変数`buffer-undo-list'に収めたアンドゥリストの先頭に自動
的に要素を追加します。

 -- Variable: buffer-undo-list
     この変数の値は、カレントバッファのアンドゥリストである。値`t'はアン
     ドゥ情報の記録を禁止する。

アンドゥリストの要素として可能なものをつぎに示します。

`POSITION'
     この種の要素は、まえのポイント値を記録する。この要素をアンドゥする
     とポイントをPOSITIONへ移動する。通常のカーソル移動では、いかなる種
     類のアンドゥ記録も作らないが、削除操作ではコマンド実行前のポイント
     位置を記録するためにこの項目を作る。

`(BEG . END)'
     この種の要素は、挿入されたテキストを削除する方法を表す。挿入された
     テキストはバッファのBEGからENDまでの範囲を占める。

`(TEXT . POSITION)'
     この種の要素は、削除されたテキストを再度挿入する方法を表す。削除さ
     れたテキストそのものは文字列TEXTである。再度挿入する位置は`(abs
     POSITION)'である。

`(t HIGH . LOW)'
     この種の要素は、未変更のバッファが変更されたことを表す。HIGHとLOWは
     2つの整数であり、それぞれ、まえに訪問したときや保存したときの訪問し
     ているファイルの更新時刻の16ビットを記録している。`primitive-undo'
     はこれらの値を用いて、バッファを再度未変更と印を付けるかどうか判定
     する。ファイルの更新時刻がこれに一致するときにのみ再度未変更とする。

`(nil PROPERTY VALUE BEG . END)'
     この種の要素は、テキスト属性の変更を記録する。変更をアンドゥするに
     はつぎのようにする。

          (put-text-property BEG END PROPERTY VALUE)

`(MARKER . ADJUSTMENT)'
     この種の要素は、周りのテキストが削除されたためにマーカMARKERを再配
     置しADJUSTMENT文字分位置を移動したことを記録する。この要素をアンドゥ
     すると、MARKER - ADJUSTMENT文字に移動する。

`nil'
     この要素は境界である。2つの境界のあいだの要素群を"変更グループ"
     （change group）と呼ぶ。通常、各変更グループは1つのキーボードコマン
     ドに対応し、アンドゥコマンドはグループ全体を1個としてアンドゥする。

 -- Function: undo-boundary
     この関数は、アンドゥリストに境界要素を置く。アンドゥコマンドはその
     ような境界で停止し、連続したアンドゥコマンドはよりまえの境界までア
     ンドゥする。この関数は`nil'を返す。

     エディタコマンドループは、各キー列を実行するまえにアンドゥの境界を
     自動的に作る。したがって、各アンドゥは、1つのコマンドの効果を普通は
     取り消す。自己挿入の入力文字は例外である。コマンドループはそのよう
     な最初の文字に境界を作り、つぎの19個の連続する自己挿入の入力文字で
     は境界を作らず、20番目で境界を作るということを自己挿入の入力文字が
     続く限り行う。

     別のバッファでアンドゥ可能な変更を行うたびにバッファのすべての変更
     で境界を追加する。これは、各コマンドが変更した箇所で各バッファに境
     界を作ることを保証するためである。

     1つのコマンドの効果を複数に分けるためにこの関数を直接呼ぶことは有用
     である。たとえば、`query-replace'は各置換のあとで`undo-boundary'を
     呼び出し、ユーザーが個々の置換を1つ1つアンドゥできるようにする。

 -- Function: primitive-undo COUNT LIST
     これは、アンドゥリストの要素をアンドゥする基本的な関数である。LIST
     の先頭のCOUNT個の要素をアンドゥし、LISTの残りを返す。この関数をLisp
     で書くこともできるが、Cで書いたほうが便利である。

     `primitive-undo'は、バッファを変更するとバッファのアンドゥリストに
     要素を追加する。アンドゥコマンドは一連のアンドゥ操作を始めるときに
     アンドゥリストを保存して混乱を避ける。アンドゥ操作では、保存してお
     いた値を使い更新する。アンドゥによって追加される新たな要素はこの保
     存された値の一部ではないので、それらはアンドゥを続行しても干渉しな
     い。



File: elisp-ja.info, Node: Maintaining Undo, Next: Filling, Prev: Undo, Up: Text

アンドゥリストの管理
====================

本節では、指定されたバッファでアンドゥ情報の記録をオン／オフする方法につ
いて述べます。また、アンドゥリストが大きくなりすぎないように自動的に切り
詰める方法についても説明します。

新たに作成されたバッファのアンドゥ情報の記録は普通は始めオンですが、バッ
ファ名が空白で始まる場合は最初からオフです。つぎの2つの関数を使うか、読
者自身が`buffer-undo-list'に設定すれば、アンドゥ記録を明示的にオン／オフ
できます。

 -- コマンド: buffer-enable-undo &optional BUFFER-OR-NAME
     このコマンドは、バッファBUFFER-OR-NAMEでのアンドゥ記録をオンにし、
     以降の変更を取り消せるようにする。引数を指定しないと、カレントバッ
     ファを使う。当該バッファでアンドゥ記録がすでにオンであると、この関
     数はなにもしない。`nil'を返す。

     対話的に呼ばれると、BUFFER-OR-NAMEはカレントバッファである。他のバッ
     ファを指定できない。

 -- コマンド: buffer-disable-undo &optional BUFFER
 -- コマンド: buffer-flush-undo &optional BUFFER
     この関数はバッファBUFFERのアンドゥリストを破棄し、以降のアンドゥ情
     報の記録をオフにする。その結果、これ以前の変更も以降の変更も取り消
     すことはできない。BUFFERのアンドゥリストがすでにオフであると、この
     関数にはなんの効果もない。

     この関数は`nil'を返す。

     名前`buffer-flush-undo'は廃れているとはみなさないが、好ましい名前は
     `buffer-disable-undo'である。

編集を続けるにしたがってアンドゥリストはどんどん長くなります。これらがメ
モリを使い尽くさないように、読者が設定した上限サイズにガベッジコレクショ
ンが切り詰めます。（この目的においてアンドゥリストの『サイズ』は、リスト
を構成するコンスセルの個数と削除された文字列の和である。）2つの変数
`undo-limit'と`undo-strong-limit'は、許容できるサイズの範囲を制御します。

 -- Variable: undo-limit
     これはアンドゥリストの許容できるサイズの緩い制限である。このサイズ
     を越える位置にある変更グループは保持される最古のものである。

 -- Variable: undo-strong-limit
     これはアンドゥリストの許容できるサイズの上限である。このサイズを越
     える位置にある変更グループは（これより古いものも含めて）削除される。
     例外が1つあり、最新の変更グループはそれがどれほど大きくてもけっして
     破棄しない。



File: elisp-ja.info, Node: Filling, Next: Margins, Prev: Maintaining Undo, Up: Text

詰め込み
========

"詰め込み"（fill）とは、指定されている最大幅（を越えず）にほぼ収まるよう
に（行分け位置を移動して）行の長さを調整することです。さらに、行を"幅揃
え"（justify）することもできます。つまり、左右の両端や片側の余白をきちん
と揃えるため空白を挿入することです。幅は変数`fill-column'で制御します。
読みやすいように、行は70コラム程度に収めるべきです。

テキストを挿入するにつれて自動的にテキストを詰め込むには、自動詰め込み
（auto-fill）モード（*Note Auto Filling::）を使いますが、既存のテキスト
を変更しても正しくない詰め込み状態のまま放置されます。したがって、そのよ
うなテキストは明示的に詰め込む必要があります。

本節のほとんどの関数が返す値には意味はありません。詰め込みを行うすべての
関数は、現在の左端余白、現在の右端余白、現在の幅揃えスタイルに注意をはら
います（*Note Margins::）。現在の幅揃えスタイルが`none'であると、詰め込
み関数は実際にはなにもしません。

詰め込み関数には引数JUSTIFYを取るものもあります。それが`nil'以外であると、
幅揃えの種類を指示します。特定の幅揃えスタイルを指示するものは、`left'、
`right'、`full'、`center'です。それが`t'であると、テキストの当該部分には
現在の幅揃えスタイルを用いることを意味します（下記の
`current-justification'を参照）。これ以外の値は`full'として扱います。

対話的に詰め込み関数を呼ぶときに前置引数を使うと、JUSTIFYとして値`full'
を暗に指示します。

 -- コマンド: fill-paragraph JUSTIFY
     このコマンドは、ポイントがある段落、あるいは、ポイントのあとの段落
     を詰め込む。JUSTIFYが`nil'以外であると、各行の幅揃えも行う。段落の
     境界を探すために普通の段落移動コマンドを用いる。*Note 段落:
     (emacs)Paragraphs.。

 -- コマンド: fill-region START END &optional JUSTIFY NOSQUEEZE TO-EOP
     このコマンドは、STARTからENDの領域内の各段落を詰め込む。JUSTIFYが
     `nil'以外であれば、幅揃えも行う。

     NOSQUEEZEが`nil'以外であると、行分け以外の白文字にはふれないことを
     意味する。TO-EOPが`nil'以外であると、段落の末尾まで、あるいは、
     `use-hard-newlines'がオンならばつぎのハード改行（下記参照）までを詰
     め込むことを意味する。

     変数`paragraph-separate'は、段落の区別方法を制御する。*Note
     Standard Regexps::。

 -- コマンド: fill-individual-paragraphs START END &optional JUSTIFY MAIL-FLAG
     このコマンドは、領域内の各段落を各段落の詰め込み接頭辞に従って詰め
     込む。したがって、段落の行が空白で字下げされていると、詰め込んだあ
     との段落も同じように字下げされる。

     最初の2つの引数STARTとENDは、詰め込むべき範囲の先頭と末尾である。3
     番目と4番目の引数、JUSTIFYとMAIL-FLAGは省略できる。JUSTIFYが`nil'以
     外であると、段落の詰め込みに加えて幅揃えも行う。MAIL-FLAGが`nil'以
     外であると、メイルメッセージなのでヘッダ行を詰め込まないことを意味
     する。

     通常、`fill-individual-paragraphs'は、字下げが変わると新しい段落の
     開始とみなす。`fill-individual-varying-indent'が`nil'以外であると、
     区切り行のみが段落を区切るとみなす。これは段落の先頭行と後続の行で
     字下げが異なる段落を処理できる。

 -- User Option: fill-individual-varying-indent
     この変数は、上に述べたように`fill-individual-paragraphs'の動作を変
     える。

 -- コマンド: fill-region-as-paragraph START END &optional JUSTIFY NOSQUEEZE SQUEEZE-AFTER
     このコマンドは、テキストの領域を1つの段落とみなして詰め込む。領域に
     複数の段落があると、段落のあいだの空行は取りさる。JUSTIFYが`nil'以
     外であると幅揃えも行う。

     対話的な呼び出しでは、前置引数で幅揃えを指示する。

     NOSQUEEZEが`nil'以外であると、行分け以外の白文字にはふれないことを
     意味する。SQUEEZE-AFTERが`nil'以外であると、それは領域内の位置を表
     し、その位置よりまえにある空白を変更しないように指示する。

     適応型詰め込み（adaptive-fill）モードでは、デフォルトの詰め込み接頭
     辞を選ぶためにこのコマンドは`fill-context-prefix'を呼び出す。*Note
     Adaptive Fill::。

 -- コマンド: justify-current-line HOW EOP NOSQUEEZE
     このコマンドは、現在行の単語のあいだに空白を挿入し、ちょうど
     `fill-column'コラムで行が終るようにする。`nil'を返す。

     引数HOWが`nil'以外であると、幅揃えスタイルを指定する。可能な値は、
     `left'、`right'、`full'、`center'、または、`none'である。`t'である
     と、指定されている幅揃えスタイルに従うことを意味する（下記の
     `current-justification'を参照）。`nil'は、幅揃えしないことを意味す
     る。

     EOPが`nil'以外であると、`current-justification'が両端揃えを指定して
     いるときには左端揃えを行うことを意味する。これは段落の最後の行に適
     用される。段落全体として両端揃えであっても、最後の行はそうすべきで
     はない。

     NOSQUEEZEが`nil'以外であると、内側の白文字を変更しないことを意味す
     る。

 -- User Option: default-justification
     この変数の値は、テキスト属性で幅揃えスタイルを指定していないテキス
     トに対して用いる幅揃えスタイルを指定する。可能な値は、`left'、
     `right'、`full'、`center'、`none'である。デフォルト値は`left'である。

 -- Function: current-justification
     この関数は、ポイントの周りのテキストを詰め込むときに使う正しい幅揃
     えスタイルを返す。

 -- User Option: sentence-end-double-space
     この変数が`nil'以外であると、直後に1つの空白を従えたピリオドを文末
     とみなさず、詰め込み関数はそのような箇所で行分けしない。

 -- Variable: fill-paragraph-function
     この変数は、段落の詰め込みに優先する方法をメジャーモードに与える。
     値が`nil'以外であると、`fill-paragraph'は詰め込み処理のためにこの関
     数を呼び出す。関数が`nil'以外の値を返すと、`fill-paragraph'は処理が
     完了したとみなして戻り値をただちに返す。

     この機能の普通の用途は、プログラム言語向けのモードでコメントを詰め
     込むためである。この関数で普通の方法で詰め込む必要がある場合には、
     つぎのようにする。

          (let ((fill-paragraph-function nil))
            (fill-paragraph arg))

 -- Variable: use-hard-newlines
     この変数が`nil'以外であると、詰め込み関数は、テキスト属性`hard'を持
     つ改行を削除しない。これらの『ハード改行』は段落の区切りとして働く。



File: elisp-ja.info, Node: Margins, Next: Adaptive Fill, Prev: Filling, Up: Text

詰め込みのための余白
====================

 -- User Option: fill-prefix
     このバッファローカルな変数は、普通のテキスト行の先頭に現れ、詰め込
     み時には無視すべきテキストの文字列（詰め込み接頭辞）を指定する。詰
     め込み接頭辞で始まらない行は段落の開始行とみなすため、詰め込み接頭
     辞のあとに余分に白文字があるとそれらも段落の開始行とみなす。詰め込
     み接頭辞で始まりそのあとに余分な白文字がない行は、いっしょに詰め込
     める普通のテキスト行である。

     左端余白がある場合には、左端余白のあとに詰め込み接頭辞が続く。

 -- User Option: fill-column
     このバッファローカルな変数は、詰め込んだ行の最大幅を指定する。この
     値は整数であり、コラム数であること。自動詰め込み（auto-fill）モード
     （*Note Auto Filling::）を含めてすべての詰め込み／幅揃え／中央揃え
     を行うコマンドは、この変数に影響される。

     特に他人のために書いているテキストでは、`fill-column'を70未満にする
     べきである。さもないと、人によっては快適に読むには行が長すぎて、テ
     キストが不恰好に見える。

 -- Variable: default-fill-column
     この変数の値は、バッファで`fill-column'の値を設定していない場合の
     `fill-column'のデフォルト値である。これは`(default-value
     'fill-column)'と同じである。

     `default-fill-column'のデフォルト値は70である。

 -- コマンド: set-left-margin FROM TO MARGIN
     FROMからTOまでのテキストの属性`left-margin'を値MARGINにする。自動詰
     め込み（auto-fill）モードがオンであると、このコマンドは、当該領域を
     再詰め込みして新たな余白に適合するようにする。

 -- コマンド: set-right-margin FROM TO MARGIN
     FROMからTOまでのテキストの属性`right-margin'を値MARGINにする。自動
     詰め込み（auto-fill）モードがオンであると、このコマンドは、当該領域
     を再詰め込みして新たな余白に適合するようにする。

 -- Function: current-left-margin
     この関数は、ポイントの周りのテキストを詰め込むときに使う正しい左端
     余白の値を返す。その値は、現在行の最初の文字の属性`left-margin'の値
     （なければ0）と変数`left-margin'の値の和である。

 -- Function: current-fill-column
     この関数は、ポイントの周りのテキストを詰め込むときに使う正しい詰め
     込み幅を返す。その値は、変数`fill-column'の値からポイント直後の文字
     の属性`right-margin'の値を引いたものである。

 -- コマンド: move-to-left-margin &optional N FORCE
     この関数は、ポイントを現在行の左端余白へ移動する。移動先のコラム位
     置は関数`current-left-margin'を呼び出して決定する。引数Nが`nil'以外
     であると、`move-to-left-margin'はN-1先の行へまず移動する。

     FORCEが`nil'以外であると、行の字下げが左端余白の値に一致しないとき
     には、字下げを修正することを指示する。

 -- Function: delete-to-left-margin FROM TO
     この関数は、FROMからTOまでのテキストから左端余白分の字下げを取りさ
     る。削除する字下げ量は、`current-left-margin'を呼び出して決定する。
     この関数が白文字以外を削除することは絶対にない。

 -- Function: indent-to-left-margin
     これは、基本（fundamental）モード、テキスト（text）モードなどが使う
     デフォルトの`indent-line-function'である。その効果は、変数
     `left-margin'の値で指定した位置から現在行が始まるように字下げを調整
     することである。それには白文字の挿入や削除が伴う。

 -- Variable: left-margin
     この変数は、左端余白コラムの起点を指定する。基本（fundamental）モー
     ドでは、`C-j'がこのコラム位置に字下げする。この変数に設定すると自動
     的にバッファローカルになる。

 -- Variable: fill-nobreak-predicate
     この変数は、特定の箇所では行分けしない方法をメジャーモードに提供す
     る。その値は関数であること。この関数は、引数なしで行分け予定箇所に
     ポイントを置いて呼び出される。この関数が`nil'以外を返すと、当該箇所
     では行分けしない。



File: elisp-ja.info, Node: Adaptive Fill, Next: Auto Filling, Prev: Margins, Up: Text

適応型詰め込み（adaptive-fill）モード
=====================================

適応型詰め込みモード（adaptive-fill）では、詰め込むべき各段落のテキスト
から自動的に詰め込み接頭辞を選びます。

 -- User Option: adaptive-fill-mode
     この変数が`nil'以外であると、適応型詰め込みモード（adaptive-fill）
     がオンである。デフォルトでは`t'である。

 -- Function: fill-context-prefix FROM TO
     この関数は適応型詰め込みモード（adaptive-fill）の中核を実装するもの
     であり、FROMからTOのあいだのテキストに基づいて詰め込み接頭辞を選ぶ。
     以下に述べる変数に基づいて、段落の最初の2行を調べてこれを行う。

 -- User Option: adaptive-fill-regexp
     この変数は、適応型詰め込みモード（adaptive-fill）を制御する正規表現
     を保持する。適応型詰め込みモード（adaptive-fill）では、行の（あれば）
     左端余白の白文字のうしろから始まるテキストに対してこの正規表現の一
     致を試みる。一致した文字群が当該行の詰め込み接頭辞の候補になる。

 -- User Option: adaptive-fill-first-line-regexp
     1行だけの段落において、詰め込み接頭辞の候補がこの正規表現に一致する
     か、`comment-start-skip'に一致すると、その候補を使う。さもなければ、
     同じ幅に相当する白文字をかわりに使う。

     1行だけの段落から選んだ詰め込み接頭辞が後続の行の段落の始まりである
     場合には、1行だけの段落からはけっして詰め込み接頭辞を選ばない。

 -- User Option: adaptive-fill-function
     この変数に関数を指定することで、詰め込み接頭辞のより複雑な自動選択
     方法を指定できる。この関数は、`adaptive-fill-regexp'の一致に失敗し
     たときに、行の左端余白のうしろにポイントを置いて呼び出され、当該行
     に基づいて適切な詰め込み接頭辞を返すこと。それが`nil'を返すと、当該
     行には詰め込み接頭辞がないことを意味する。



File: elisp-ja.info, Node: Auto Filling, Next: Sorting, Prev: Adaptive Fill, Up: Text

自動詰め込み（auto-filling）モード
==================================

自動詰め込み（auto-filling）モードは、テキストを挿入するにつれて自動的に
行を詰め込むマイナモードです。本節では、自動詰め込み（auto-filling）モー
ドが使うフックについて述べます。既存のテキストを詰め込んだり幅揃えするた
めに明示的に呼び出す関数については、*Note Filling::を参照してください。

自動詰め込み（auto-filling）モードでは、テキストの一部を再詰め込む際の余
白や幅揃えスタイルを変更するための関数も使えるようにします。*Note
Margins::。

 -- Variable: auto-fill-function
     この変数の値は、自己挿入される空白や改行のあとで呼び出されるべき
     （引数なしの）関数であること。これが`nil'であると、そのような場合に
     特別なことを行わない。

     自動詰め込み（auto-filling）モードがオンであると、
     `auto-fill-function'の値は`do-auto-fill'である。この関数の目的は、
     行分けの通常の方針を実装することである。

          Emacsの古い版では、この変数を`auto-fill-hook'と命名していたが、
          フックの標準的な慣習に従って呼ばれないため19版で
          `auto-fill-function'と改名した。

 -- Variable: normal-auto-fill-function
     この変数は、自動詰め込み（auto-filling）モードがオンになったとき／
     であるときに`auto-fill-function'として用いる関数を指定する。メジャー
     モードでは、この変数のバッファローカルな値に設定することで自動詰め
     込み（auto-filling）モードのふるまいを変更できる。



File: elisp-ja.info, Node: Sorting, Next: Columns, Prev: Auto Filling, Up: Text

テキストのソート
================

本節で述べるソート関数すべては、バッファ内のテキストを並べ替えます。これ
は、リスト内の要素の順番を並べ替える関数`sort' （*Note Rearrangement::）
と対照的です。これらの関数が返す値には意味はありません。

 -- Function: sort-subr REVERSE NEXTRECFUN ENDRECFUN &optional STARTKEYFUN ENDKEYFUN
     この関数は、バッファ内のテキストをレコードに分割してソートする汎用
     のテキストソートルーティンである。本節のコマンドのほとんどは、この
     関数を用いる。

     `sort-subr'の動作方法を理解するためは、バッファの参照可能部分全体が
     "ソートレコード"（sort record）と呼ばれる重なり合いのない断片に分割
     されていると考える。レコードは連続しているかもしれないし、そうでな
     いかもしれないが、けっして重なり合わない。各ソートレコードの一部分
     （あるいは全体）をソートキーとして区別する。ソートでは、ソートキー
     の順に並ぶようにレコードを並び替える。

     通常、レコードをソートキーの昇順に並べ替える。関数`sort-subr'の第1
     引数REVERSEが`nil'以外であると、ソートキーの降順にレコードを並べ替
     える。

     `sort-subr'のつぎの4つの引数は、ソートレコードをまたいでポイントを
     移動するために呼ばれる関数である。それらは、`sort-subr'で多数回呼び
     出される。

       1. NEXTRECFUNは、レコードの末尾にポイントを置いて呼び出される。こ
          の関数は、つぎのレコードの先頭にポイントを移動する。最初のレコー
          ドの先頭は、`sort-subr'を呼び出したときのポイント位置であると
          仮定する。したがって、`sort-subr'を呼び出すまえには、普通、バッ
          ファの先頭にポイントを移動しておくこと。

          この関数は、バッファの末尾にポイントを置いておくことで、ソート
          レコードがなくなったことを表せる。

       2. ENDRECFUNは、レコード内にポイントを置いて呼び出される。レコー
          ドの末尾にポイントを移動する。

       3. STARTKEYFUNは、レコードの先頭からソートキーの先頭へポイントを
          移動するために呼び出される。この引数は省略可能であり、省略する
          とレコード全体をソートキーとする。指定した場合、その関数は、ソー
          トキーとして用いる`nil'以外の値を返すか、バッファのポイント位
          置からソートキーが始まることを表す`nil'を返すこと。後者の場合、
          ソートキーの末尾を探すためにENDKEYFUNが呼ばれる。

       4. ENDKEYFUNは、ソートキーの先頭からソートキーの末尾にポイントを
          移動するために呼び出される。この引数は省略可能である。
          STARTKEYFUNが`nil'を返しこの引数が省略されている（あるいは
          `nil'である）と、ソートキーはレコードの末尾までである。
          STARTKEYFUNが`nil'以外の値を返すのであれば、ENDKEYFUNは必要な
          い。

     `sort-subr'の例として、`sort-lines'の完全な関数定義を示す。

          ;; 説明文字列の始めの2行は、ユーザーが見るときには
          ;; 実質的には1行であることに注意
          (defun sort-lines (reverse beg end)
            "Sort lines in region alphabetically;\
           argument means descending order.
          Called from a program, there are three arguments:
          REVERSE (non-nil means reverse order),\
           BEG and END (region to sort).
          The variable `sort-fold-case' determines\
           whether alphabetic case affects
          the sort order.
            (interactive "P\nr")
            (save-excursion
              (save-restriction
                (narrow-to-region beg end)
                (goto-char (point-min))
                (sort-subr reverse 'forward-line 'end-of-line))))

     ここで、`forward-line'はつぎのレコードの先頭にポイントを移動し、
     `end-of-line'はレコードの末尾にポイントを移動する。レコード全体をソー
     トキーとして用いるため、引数STARTKEYFUNとENDKEYFUNは指定しない。

     関数`sort-paragraphs'もほぼ同様であるが、つぎのように`sort-subr'を
     呼び出す点が異なる。

          (sort-subr reverse
                     (function
                       (lambda ()
                         (while (and (not (eobp))
                                (looking-at paragraph-separate))
                           (forward-line 1))))
                     'forward-paragraph)

     `sort-subr'から戻ったあとでは、ソートレコードを指しているマーカは意
     味のある位置を指していない。

 -- User Option: sort-fold-case
     この変数が`nil'以外であると、`sort-subr'や他のバッファソート関数は、
     文字列の比較において大文字小文字を区別しない。

 -- コマンド: sort-regexp-fields REVERSE RECORD-REGEXP KEY-REGEXP START END
     このコマンドは、STARTとENDのあいだの領域をRECORD-REGEXPとKEY-REGEXP
     の指定に従ってアルファベット順にソートする。REVERSEが負の整数である
     と、逆順にソートする。

     アルファベット順のソートとは、最初の文字同士、2番目の文字同士といっ
     た具合に2つのソートキーを比較することである。不一致がみつかると、ソー
     トキーが等しくないことを意味し、最初の不一致箇所の文字が小さいほう
     のソートキーが小さい。個々の文字は、Emacsの文字集合における文字コー
     ドの数値に従って比較する。

     引数RECORD-REGEXPの値は、バッファをソートレコードに分割する方法を指
     定する。各レコードの末尾において、この正規表現を探索しそれに一致し
     たテキストをつぎのレコードとする。たとえば、正規表現`^.+$'は、少な
     くとも1つの文字のあとに改行があるような行に一致し、そのような行をソー
     トレコードとする。正規表現の構文と意味については、*Note Regular
     Expressions::。

     引数KEY-REGEXPの値は、レコードのどの部分がソートキーであるかを指定
     する。KEY-REGEXPは、レコード全体かその一部分に一致する。後者の場合、
     レコードの残りの部分は、レコードの並び替え順序には影響しないが、レ
     コードをその新たな位置に移動するときにいっしょに移動される。

     引数KEY-REGEXPでRECORD-REGEXPの部分式に一致したテキストを参照しても
     よいし、独立した正規表現でもよい。

     KEY-REGEXPにはつぎの可能性がある。

     `\DIGIT'
          RECORD-REGEXPのDIGIT番目の括弧によるグループ化`\(...\)'に一致
          したテキストがソートキーである。

     `\&'
          レコード全体がソートキーである。

     正規表現
          `sort-regexp-fields'はレコード内でこの正規表現に一致するものを
          探す。一致がみつかれば、それがソートキーになる。レコード内で
          KEY-REGEXPに対する一致がみつからなければ、レコードを無視する。
          つまり、バッファ内での当該レコードの位置を変更しない。（別のレ
          コードが周りに移動してくるかもしれない。）

     たとえば、領域内のすべての行を各行の`f'で始まる最初の単語でソートす
     るには、RECORD-REGEXPに`^.*$'、KEY-REGEXPに`\<f\w*\>'を指定する。つ
     まり、つぎのような式になる。

          (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

     `sort-regexp-fields'を対話的に呼び出すと、ミニバッファで
     RECORD-REGEXPとKEY-REGEXPを問い合わせる。

 -- コマンド: sort-lines REVERSE START END
     このコマンドは、STARTとENDのあいだの領域の行をアルファベット順にソー
     トする。REVERSEが`nil'以外であると、逆順にソートする。

 -- コマンド: sort-paragraphs REVERSE START END
     このコマンドは、STARTとENDのあいだの領域の段落をアルファベット順に
     ソートする。REVERSEが`nil'以外であると、逆順にソートする。

 -- コマンド: sort-pages REVERSE START END
     このコマンドは、STARTとENDのあいだの領域のページをアルファベット順
     にソートする。REVERSEが`nil'以外であると、逆順にソートする。

 -- コマンド: sort-fields FIELD START END
     このコマンドは、STARTとENDのあいだの領域の行を各行のFIELD番目のフィー
     ルド同士をアルファベット順に比較してソートする。フィールドは白文字
     で区切られ、1から数える。FIELDが負であると、行末から-FIELD番目のフィー
     ルドでソートする。このコマンドは、表をソートするのに有用である。

 -- コマンド: sort-numeric-fields FIELD START END
     このコマンドは、STARTとENDのあいだの領域の行を各行のFIELD番目のフィー
     ルド同士を数値として比較してソートする。領域内の各行の指定したフィー
     ルドには数があること。フィールドは白文字で区切られ、1から数える。
     FIELDが負であると、行末から-FIELD番目のフィールドでソートする。この
     コマンドは、表をソートするのに有用である。

 -- コマンド: sort-columns REVERSE &optional BEG END
     このコマンドは、STARTとENDのあいだの領域の行を特定範囲のコラムをア
     ルファベット順に比較してソートする。BEGとENDのコラム位置は、ソート
     対象のコラムの範囲を区切る。

     REVERSEが`nil'以外であると、逆順にソートする。

     このコマンドの普通でない点は、位置BEGを含む行全体と位置ENDを含む行
     全体もソート対象の領域に含まれることである。

     `sort-columns'は、ユーティリティプログラム`sort'を使うため、タブ文
     字を含むテキストを正しく扱えない。ソートするまえに`M-x untabify'を
     使ってタブを空白に変換すること。



File: elisp-ja.info, Node: Columns, Next: Indentation, Prev: Sorting, Up: Text

コラムを数える
==============

コラム関数は、（バッファの先頭から文字を数えた）文字位置を（スクリーンの
行頭から文字を数えた）コラム位置に変換します。

これらの関数は、各文字をそれがスクリーン上で占めるコラム数を基に数える。
つまり、`ctl-arrow'の値に依存してコントロール文字は、2コラムか4コラム占
めると数え、タブ文字は、タブの開始コラムと`tab-width'の値に依存するコラ
ム数を占めると数えることを意味します。*Note Usual Display::。

コラム番号の計算では、ウィンドウの幅や水平スクロール量を無視します。その
結果、コラム値は任意の大きさになりえます。最初の（スクリーン左端の）コラ
ムの番号は0です。

 -- Function: current-column
     この関数は、左端を0としてコラム数で数えたポイントの水平位置を返す。
     コラム位置は、現在行の先頭からポイント位置までの文字すべての表示上
     の表記の幅の総和である。

     `current-column'の使用例については、*Note Text Lines::の
     `count-lines'を参照。

 -- Function: move-to-column COLUMN &optional FORCE
     この関数は、ポイントを現在行のCOLUMNへ移動する。COLUMNの計算では、
     現在行の先頭からポイント位置までの文字すべての表示上の表記の幅を考
     慮する。

     コラムCOLUMNが行末を越える場合、ポイントを行末へ移動する。COLUMNが
     負であると、ポイントを行頭へ移動する。

     コラムCOLUMNがタブなどの複数コラムを占める文字の中ほどにあるために
     そこへ移動できない場合には、ポイントを当該文字の末尾へ移動する。し
     かし、FORCEが`nil'以外でありCOLUMNがタブの中ほどであると、コラム
     COLUMNに正確に移動できるようにタブを空白に変換する。複数コラムを占
     めるその他の文字では、それらを分割する方法がないため、FORCEを指定し
     ても変則的になる。

     コラムCOLUMNに到達できるほど行が長くない場合にも引数FORCEには効果が
     ある。そのような場合、指定コラムに達するように行末に白文字を追加す
     る。

     COLUMNが整数でないと、エラーを通知する。

     戻り値は、実際の移動先のコラム番号である。



File: elisp-ja.info, Node: Indentation, Next: Case Changes, Prev: Columns, Up: Text

字下げ
======

字下げ関数は、行頭の空白を調べたり、そこへ移動したり、変更するために使い
ます。行の他の白文字を変更するものもあります。コラム関数と字下げ関数は左
端を0と数えます。

* Menu:

* Primitive Indent::      Functions used to count and insert indentation.
* Mode-Specific Indent::  Customize indentation for different modes.
* Region Indent::         Indent all the lines in a region.
* Relative Indent::       Indent the current line based on previous lines.
* Indent Tabs::           Adjustable, typewriter-like tab stops.
* Motion by Indent::      Move to first non-blank character.



File: elisp-ja.info, Node: Primitive Indent, Next: Mode-Specific Indent, Prev: Indentation, Up: Indentation

字下げ基本関数
--------------

本節では、字下げを数えたり挿入するために使われる基本関数について述べます。
後続の節の関数群は、これらの基本関数を使っています。関連する関数について
は、*Note Width::。

 -- Function: current-indentation
     この関数は、現在行の字下げを返す。これは最初の白文字以外の文字の水
     平位置である。行全体が白文字や空である場合には、行末の水平位置を返
     す。

 -- コマンド: indent-to COLUMN &optional MINIMUM
     この関数は、ポイント位置からCOLUMNに達するまでタブや空白で字下げす
     る。MINIMUMを指定し`nil'以外であると、COLUMNを越える場合であっても
     最低MINIMUM個の空白を挿入する。さもなければ、ポイントがCOLUMNを越え
     ている場合には、この関数はなにもしない。戻り値は、挿入した字下げが
     終る箇所のコラムである。

     挿入された白文字は周りの文字（普通は、まえの文字）からテキスト属性
     を継承する。*Note Sticky Properties::。

 -- User Option: indent-tabs-mode
     この変数が`nil'以外であると、字下げ関数は空白に加えてタブも挿入する。
     さもなければ、空白のみを挿入する。この変数に設定すると、カレントバッ
     ファでバッファローカルになる。



File: elisp-ja.info, Node: Mode-Specific Indent, Next: Region Indent, Prev: Primitive Indent, Up: Indentation

メジャーモードの制御による字下げ
--------------------------------

各メジャーモードの重要な機能は、キーTABを編集対象の言語に適した字下げに
カスタマイズすることです。本節では、キーTABの機構とそれを制御する方法に
ついて述べます。本節の関数は、予測できない値を返します。

 -- Variable: indent-line-function
     この変数の値は、現在行を字下げするためにTAB（やさまざまなコマンド）
     が使う関数である。コマンド`indent-according-to-mode'は、この関数を
     呼ぶこと以上のことはしない。

     lispモードでは値はシンボル`lisp-indent-line'、Cモードでは
     `c-indent-line'、fortranモードでは`fortran-indent-line'である。標準
     的な字下げがない基本（fundamental）モード、テキスト（text）モード、
     他の多くのモードでは、値は`indent-to-left-margin'（デフォルト値）で
     ある

 -- コマンド: indent-according-to-mode
     このコマンドは、現在のメジャーモードに適した方法で現在行を字下げす
     るために`indent-line-function'で指定される関数を呼び出す。

 -- コマンド: indent-for-tab-command
     このコマンドは、現在行を字下げするために`indent-line-function'で指
     定される関数を呼び出すが、その関数が`indent-to-left-margin'であると、
     かわりに`insert-tab'を呼び出す。（これはタブ文字を挿入する単純なコ
     マンドである。）

 -- コマンド: newline-and-indent
     この関数は、改行を挿入してから、（改行を挿入したばかりの行に続く）
     新たな行をメジャーモードに基づいて字下げする。

     現在の`indent-line-function'を呼び出して字下げを行う。プログラム言
     語向けのモードでは、これはTABが行うことと同じであるが、TABがタブを
     挿入するテキスト向けのモードの一部では、`newline-and-indent'は
     `left-margin'で指定されたコラムに字下げする。

 -- コマンド: reindent-then-newline-and-indent
     このコマンドは、現在行を字下げし直し、ポイント位置に改行を挿入し、
     （改行を挿入したばかりの行に続く）新たな行を字下げする。

     このコマンドは、`indent-line-function'の現在の値を呼び出すことで、
     どちらの行も現在のメジャーモードに基づいて字下げする。プログラム言
     語向けのモードでは、これはTABが行うことと同じであるが、TABがタブを
     挿入するテキスト向けのモードの一部では、
     `reindent-then-newline-and-indent'は、`left-margin'で指定されるコラ
     ムに字下げする。



File: elisp-ja.info, Node: Region Indent, Next: Relative Indent, Prev: Mode-Specific Indent, Up: Indentation

領域全体の字下げ
----------------

本節では、領域内のすべての行を字下げするコマンドについて述べます。これら
は予測できない値を返します。

 -- コマンド: indent-region START END TO-COLUMN
     このコマンドは、START（を含めて）とEND（を含めない）のあいだで始ま
     る空でない各行を字下げする。TO-COLUMNが`nil'であると、
     `indent-region'は、現在のモードの字下げ関数、つまり、
     `indent-line-function'の値を呼び出して、空でない各行を字下げする。

     TO-COLUMNが`nil'以外であると、それは字下げ先のコラム番号を指定する
     整数であること。すると、この関数は、白文字を追加するか削除して、各
     行を指定どおりに字下げする。

     詰め込み接頭辞がある場合、`indent-region'は詰め込み接頭辞で行を始め
     ることで各行を字下げする。

 -- Variable: indent-region-function
     この変数の値は、`indent-region'の短縮版として利用可能な関数である。
     領域の開始位置と終了位置の2つの引数をとる。領域の行を1つ1つ字下げす
     る場合と同じ結果を生じるが、より速く動作することを意図してこの関数
     を設計するべきである。

     値が`nil'であると短縮版はなく、`indent-region'が実際に1行ずつ処理す
     る。

     短縮版関数はCモードやlispモードのようなモードで有用である。そのよう
     なモードでは、`indent-line-function'で関数定義の始まりを走査する必
     要があり、これを各行に適用すると自乗の時間がかかる。短縮版では、字
     下げし終えた関数定義を通過するたびに走査情報を更新でき、これには線
     形時間かかるだけである。個々の行を高速に字下げできるモードでは、短
     縮版は必要ない。

     引数TO-COLUMNに`nil'以外を指定した`indent-region'には別の意味があり、
     この変数を使わない。

 -- コマンド: indent-rigidly START END COUNT
     このコマンドは、START（を含めて）とEND（を含めない）のあいだで始ま
     る行すべてをコラム数COUNTだけ字下げする。これは、領域を1つの塊とし
     て動かしてその領域の『形を保つ』。このコマンドは、字下げしていない
     テキストの領域だけでなく、整形済みの領域を字下げするためにも有用で
     ある。

     たとえば、COUNTが3であると、このコマンドは指定した領域内の各行の行
     頭に3コラムの字下げを追加する。

     メイル（mail）モードでは、`C-c C-y'（`mail-yank-original'）が返信対
     象のメッセージからコピーしたテキストを字下げするために
     `indent-rigidly'を使っている。

 -- Function: indent-code-rigidly START END COLUMNS &optional NOCHANGE-REGEXP
     この関数は`indent-rigidly'と同様であるが、文字列やコメントで始まる
     行を変更しない点が異なる。

     さらに、（NOCHANGE-REGEXPが`nil'以外のとき）行の先頭が
     NOCHANGE-REGEXPに一致する場合にも行を変更しない。



File: elisp-ja.info, Node: Relative Indent, Next: Indent Tabs, Prev: Region Indent, Up: Indentation

先行行相対の字下げ
------------------

本節では、先行する行の内容に基づいて現在行を字下げする2つのコマンドにつ
いて述べます。

 -- コマンド: indent-relative &optional UNINDENTED-OK
     このコマンドは、空白でないまえの行のつぎの"字下げ位置"のコラムに達
     するまで、ポイント位置に白文字を挿入する。字下げ位置とは、白文字に
     続く白文字以外の文字である。つぎの字下げ位置とは、現在行のポイント
     のコラム位置より大きな最初の字下げ位置のことである。たとえば、テキ
     スト行の白文字以外の最初の文字より左側で、その下の行にポイントがあ
     ると、白文字を挿入してそのコラム位置にポイントを移動する。

     空白でないまえの行に、つぎの字下げ位置（つまり、ポイント位置より大
     きなコラム）がないと、`indent-relative'は、（UNINDENTED-OKが`nil'以
     外であれば）なにもしないか、`tab-to-tab-stop'を呼び出す。したがって、
     まえのテキスト行が短くてその行末より右側で、その下の行にポイントが
     あると、このコマンドは、通常どおり、白文字を挿入してつぎのタブ位置
     へポイントを移動する。

     `indent-relative'の戻り値は予測できない。

     つぎの例では、ポイントは2行目の行頭にある。

                      This line is indented twelve spaces.
          -!-The quick brown fox jumped.

     式`(indent-relative nil)'を評価すると、つぎのようになる。

                      This line is indented twelve spaces.
                      -!-The quick brown fox jumped.

     つぎの例では、ポイントは`jumped'の`m'と`p'のあいだにある。

                      This line is indented twelve spaces.
          The quick brown fox jum-!-ped.

     式`(indent-relative nil)'を評価すると、つぎのようになる。

                      This line is indented twelve spaces.
          The quick brown fox jum  -!-ped.

 -- コマンド: indent-relative-maybe
     このコマンドは、引数UNINDENTED-OKに`t'を指定して`indent-relative'を
     呼び出すことで、まえの行と同様に字下げする。戻り値は予測できない。

     空行でないまえの行に現在のコラム位置を越える字下げ位置がなければ、
     このコマンドはなにもしない。



File: elisp-ja.info, Node: Indent Tabs, Next: Motion by Indent, Prev: Relative Indent, Up: Indentation

調整可能な『タブストップ』
--------------------------

本節では、ユーザー指定の『タブストップ』の機構と、それを使ったり設定する
ための機構について説明します。『タブストップ』という名前を使うのは、この
機構がタイプライタのタブストップに似た機能だからです。この機能は、適切な
個数の空白とタブ文字を挿入してつぎのタブストップのコラムへ到達しますが、
バッファ内のタブ文字の表示に影響することはありません（*Note Usual
Display::）。テキスト（text）モードなどの少数のメジャーモードでのみ、入
力としての文字TABがこのタブストップ機能を使います。

 -- コマンド: tab-to-tab-stop
     このコマンドは、`tab-stop-list'で定義されたつぎのタブストップコラム
     まで、ポイントのまえに空白やタブを挿入する。このリストで現在のコラ
     ム番号より大きな要素を探し、その要素を字下げ位置のコラムとして使う。
     そのような要素がなければ、このコマンドはないもしない。

 -- User Option: tab-stop-list
     この変数は、`tab-to-tab-stops'が使うタブストップコラムのリストであ
     る。それらの要素は、昇順の整数であること。タブストップコラムの間隔
     は、等間隔である必要はない。

     タブストップを対話的に編集するには`M-x edit-tab-stops'を使う。



File: elisp-ja.info, Node: Motion by Indent, Prev: Indent Tabs, Up: Indentation

字下げに基づく移動コマンド
--------------------------

これらのコマンドは、主に対話的に使うもので、テキストの字下げに基づいて動
作します。

 -- コマンド: back-to-indentation
     このコマンドは、現在行（ポイントが位置する行）の白文字でない最初の
     文字へポイントを移動する。`nil'を返す。

 -- コマンド: backward-to-indentation ARG
     このコマンドは、ARG行だけポイントを後方へ移動してから、当該行の白文
     字でない最初の文字へポイントを移動する。`nil'を返す。

 -- コマンド: forward-to-indentation ARG
     このコマンドは、ARG行だけポイントを前方へ移動してから、当該行の白文
     字でない最初の文字へポイントを移動する。`nil'を返す。



File: elisp-ja.info, Node: Case Changes, Next: Text Properties, Prev: Indentation, Up: Text

大文字小文字の変更
==================

ここに述べる大文字小文字の変更コマンドは、カレントバッファのテキストに作
用します。文字列や文字の大文字小文字を変換する関数については、*Note Case
Conversion::。どの文字が大文字でどの文字が小文字であり、それらをどのよう
に変換するかをカスタマイズする方法については、*Note Case Tables::。

 -- コマンド: capitalize-region START END
     この関数は、STARTとENDで定義される領域内のすべての単語をキャピタラ
     イズ（大文字で始まるように）する。つまり、各単語の最初の文字を大文
     字に、残りの文字を小文字に変換する。この関数は`nil'を返す。

     領域の端が単語の途中にあると、その単語の領域内の部分を1つの単語とみ
     なす。

     `capitalize-region'を対話的に呼び出すと、STARTとENDはポイントとマー
     クであり、小さいほうがさきにくる。

          ---------- Buffer: foo ----------
          This is the contents of the 5th foo.
          ---------- Buffer: foo ----------

          (capitalize-region 1 44)
          => nil

          ---------- Buffer: foo ----------
          This Is The Contents Of The 5th Foo.
          ---------- Buffer: foo ----------

 -- コマンド: downcase-region START END
     この関数は、STARTとENDで定義される領域内のすべての文字を小文字に変
     換する。この関数は`nil'を返す。

     `downcase-region'を対話的に呼び出すと、STARTとENDはポイントとマーク
     であり、小さいほうが先にくる。

 -- コマンド: upcase-region START END
     この関数は、STARTとENDで定義される領域内のすべての文字を大文字に変
     換する。この関数は`nil'を返す。

     `upcase-region'を対話的に呼び出すと、STARTとENDはポイントとマークで
     あり、小さいほうが先にくる。

 -- コマンド: capitalize-word COUNT
     この関数は、ポイントのうしろのCOUNT個の単語をキャピタライズ（大文字
     で始まるように）し、ポイントをそれらの末尾に移動する。つまり、各単
     語の最初の文字を大文字に、残りの文字を小文字に変換する。COUNTが負で
     あると、まえの-COUNT個の単語を大文字で始まるようにするが、ポイント
     は移動しない。値は`nil'である。

     ポイントが単語の途中にあると、単語を前方へ移動するときにはポイント
     よりまえにある単語の部分を無視する。単語の残りの部分を1つの単語とし
     て扱う。

     `capitalize-word'を対話的に呼び出すと、COUNTは数値前置引数である。

 -- コマンド: downcase-word COUNT
     この関数は、ポイントのうしろのCOUNT個の単語をすべて小文字に替え、ポ
     イントをそれらの末尾に移動する。COUNTが負であると、まえの-COUNT個の
     単語を変換するが、ポイントは移動しない。値は`nil'である。

     `downcase-word'を対話的に呼び出すと、COUNTは数値前置引数である。

 -- コマンド: upcase-word COUNT
     この関数は、ポイントのうしろのCOUNT個の単語をすべて大文字に替え、ポ
     イントをそれらの末尾に移動する。COUNTが負であると、まえの-COUNT個の
     単語を変換するが、ポイントは移動しない。値は`nil'である。

     `upcase-word'を対話的に呼び出すと、COUNTは数値前置引数である。



