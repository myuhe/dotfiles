Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Text Properties, Next: Substitution, Prev: Case Changes, Up: Text

テキスト属性
============

シンボルの属性リスト（*Note Property Lists::）のように、バッファや文字列
の各文字には"テキスト属性リスト" （text property list）を持てます。この
属性は、（本節の原文のタイトルの）文字`T'や`foo'の最初の`o'のような特定
の箇所の特定の文字に属します。同じ文字が異なる箇所に現れるとき、一般には
それぞれに異なる属性を持てます。

各属性には、名前と値があります。どちらも任意のLispオブジェクトでかまいま
せんが、名前は普通はシンボルです。属性リストを参照する普通の方法では、名
前を指定してそれに対応する値を問い合わせます。

文字に属性`category'があるとき、それを文字の"カテゴリ"（category）といい
ます。それはシンボルであるべきです。そのシンボルの属性が、文字の属性のデ
フォルトとして働きます。

文字列とバッファのあいだでテキストをコピーすると、文字とともにその属性も
保たれます。`substring'、`insert'、`buffer-substring'などのさまざまな関
数がそうします。

* Menu:

* Examining Properties::	Looking at the properties of one character.
* Changing Properties::		Setting the properties of a range of text.
* Property Search::		Searching for where a property changes value.
* Special Properties::		Particular properties with special meanings.
* Format Properties::           Properties for representing formatting of text.
* Sticky Properties::           How inserted text gets properties from
                                  neighboring text.
* Saving Properties::           Saving text properties in files, and reading
                                  them back.
* Lazy Properties::             Computing text properties in a lazy fashion
                                  only when text is examined.
* Clickable Text::              Using text properties to make regions of text
                                  do something when you click on them.
* Not Intervals::		Why text properties do not use
				  Lisp-visible text intervals.



File: elisp-ja.info, Node: Examining Properties, Next: Changing Properties, Prev: Text Properties, Up: Text Properties

テキスト属性を調べる
--------------------

テキスト属性を調べるもっとも簡単な方法は、特定の文字の特定の属性の値を問
い合わせることです。それには、`get-text-property'を使います。文字の属性
リスト全体を取得するには`text-properties-at'を使います。複数の文字の属性
を一度に調べるための関数については、*Note Property Search::。

これらの関数は、文字列とバッファの両方を扱えます。文字列内の位置は0から
始まり、バッファ内の位置は1から始まることに注意してください。

 -- Function: get-text-property POS PROP &optional OBJECT
     この関数は、OBJECT（バッファか文字列）内の位置POSのうしろの1文字の
     属性PROPの値を返す。引数OBJECTは省略でき、デフォルトはカレントバッ
     ファである。

     その文字に属性PROPがなくてもシンボルであるカテゴリがあれば、
     `get-text-property'は当該シンボルの属性PROPを返す。

 -- Function: get-char-property POS PROP &optional OBJECT
     この関数は`get-text-property'に似ているが、まずオーバレイを調べてか
     らテキスト属性を調べる。*Note Overlays::。

     引数OBJECTは、文字列、バッファ、ウィンドウのいずれかである。ウィン
     ドウであると、そのウィンドウに表示しているバッファのテキスト属性と
     オーバレイを対象にするが、対象となるオーバレイはそのウィンドウに対
     して活性なものだけである。OBJECTがバッファであると、テキスト属性に
     加えてそのバッファのすべてのオーバレイを対象にする。OBJECTが文字列
     であると、文字列にはオーバレイはないので、テキスト属性のみを対象に
     する。

 -- Function: text-properties-at POSITION &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内の位置POSITIONにある1文字
     の属性リスト全体を返す。OBJECTが`nil'であると、デフォルトはカレント
     バッファである。

 -- Variable: default-text-properties
     この変数は、テキスト属性のデフォルト値を与える属性リストを保持する。
     直接的にもカテゴリシンボルを介して間接的にも文字に属性の値が指定さ
     れていないと、このリストに収めた値をかわりに使う。つぎに例を示す。

          (setq default-text-properties '(foo 69))
          ;; 位置1の文字に属性がないことを保証する
          (set-text-properties 1 2 nil)
          ;; 問い合わせたときに見えるのはデフォルト値である
          (get-text-property 1 'foo)
               => 69



File: elisp-ja.info, Node: Changing Properties, Next: Property Search, Prev: Examining Properties, Up: Text Properties

テキスト属性の変更
------------------

属性を変更する基本関数は、バッファや文字列の指定した範囲に作用します。関
数`set-text-properties'（本節の最後）は、その範囲のテキストの属性リスト
全体を設定します。これは、名前で指定した特定の属性のみを追加／変更／削除
するのにしばしば有用です。

テキスト属性はバッファ（や文字列）の一部分であるとみなされ、スクリーン上
でのバッファの見た目に影響するので、バッファのテキスト属性を変更すると、
バッファには変更済みの印を付けます。バッファのテキスト属性の変更もアンドゥ
（*Note Undo::）できます。

 -- Function: put-text-property START END PROP VALUE &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内のSTARTとENDのあいだのテ
     キストの属性PROPの値をVALUEとする。OBJECTが`nil'であると、デフォル
     トはカレントバッファである。

 -- Function: add-text-properties START END PROPS &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内のSTARTとENDのあいだのテ
     キストのテキスト属性に追加／上書きする。OBJECTが`nil'であると、デフォ
     ルトはカレントバッファである。

     引数PROPSで追加する属性を指定する。これは属性リスト（*Note Property
     Lists::）の形であること。つまり、属性名とその値を交互に並べたリスト
     であること。

     この関数が属性の値をどれか実際に変更したならば、戻り値は`t'である。
     さもなければ（PROPSが`nil'だったり、テキスト内の値と同じ値であると）
     `nil'である。

     たとえば、テキストのある範囲の属性`comment'と`face'を設定するにはつ
     ぎのようにする。

          (add-text-properties START END
                               '(comment t face highlight))

 -- Function: remove-text-properties START END PROPS &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内のSTARTとENDのあいだのテ
     キストから指定したテキスト属性を削除する。OBJECTが`nil'であると、デ
     フォルトはカレントバッファである。

     引数PROPSで削除する属性を指定する。これは属性リスト（*Note Property
     Lists::）の形であること。つまり、属性名とその値を交互に並べたリスト
     であること。ただし、意味があるのは名前のみであり、その値は無視する。
     たとえば、属性`face'を削除するにはつぎのようにする。

          (remove-text-properties START END '(face nil))

     この関数が属性の値をどれか実際に変更したならば、戻り値は`t'である。
     さもなければ（PROPSが`nil'だったり、指定したテキスト内の文字にそれ
     らのいずれの属性もなければ）`nil'である。

     特定のテキストからすべてのテキスト属性を削除するには、新たな属性リ
     ストとして`nil'を指定して`set-text-properties'を使う。

 -- Function: set-text-properties START END PROPS &optional OBJECT
     この関数は、文字列やバッファであるOBJECT内のSTARTとENDのあいだのテ
     キストのテキスト属性を完全に置き換える。OBJECTが`nil'であると、デフォ
     ルトはカレントバッファである。

     引数PROPSは新たな属性リストである。これは、属性名とその値を交互に並
     べたリストであること。

     `set-text-properties'から戻ると、指定した範囲のすべての文字は同一の
     属性を持つことになる。

     PROPSが`nil'であると、テキストの指定した範囲からすべての属性を削除
     する効果がある。たとえば、つぎのようにする。

          (set-text-properties START END nil)

バッファからテキストをコピーするがその属性はコピーしない関数
`buffer-substring-no-properties'（*Note Buffer Contents::）も参照してく
ださい。



File: elisp-ja.info, Node: Property Search, Next: Special Properties, Prev: Changing Properties, Up: Text Properties

テキスト属性を探す関数
----------------------

テキスト属性の典型的な用途では、ほとんどの場合多くの連続した文字の1つの
属性には同じ値があります。1つずつ文字を調べるようにプログラムするよりは、
同じ属性値を持つテキストの塊を処理するほうがとても速いです。

このために使える関数をここで説明します。これらは属性値の比較に`eq'を使い
ます。OBJECTのデフォルトは、すべての場合でカレントバッファです。

高い効率のためには、これらの関数に引数LIMITを使うことが重要であり、1つの
属性を探す関数には特にあてはまります。さもないと、読者が望む属性が変更さ
れないような場合、それらの関数はバッファの末尾まで走査して長い時間を費す
ことになります。

これらの関数はポイントを移動しませんが、そのかわりに位置（あるいは`nil'）
を返します。位置はつねに2つの文字のあいだにあることに注意してください。
これらの関数が返す位置は、異なる属性を持つ2つの文字のあいだです。

 -- Function: next-property-change POS &optional OBJECT LIMIT
     この関数は、文字列やバッファであるOBJECT内の位置POSからテキスト属性
     のいずれかが異なるまでテキストを走査し、その変化する位置を返す。い
     いかえれば、POSの直後の文字のテキスト属性とは異なる属性を持つPOSの
     あとにある最初の文字の位置を返す。

     LIMITが`nil'以外であると、LIMITの位置で走査を終える。その箇所まで異
     なる属性がないと、`next-property-change'はLIMITを返す。

     LIMITが`nil'でありOBJECTの末尾まで属性に変化がないと、値は`nil'であ
     る。値が`nil'以外であると、それはPOSより大きいか等しい位置である。
     値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

     バッファからすべての属性が同じであるテキストの塊を走査する方法の例
     をつぎに示す。

          (while (not (eobp))
            (let ((plist (text-properties-at (point)))
                  (next-change
                   (or (next-property-change (point) (current-buffer))
                       (point-max))))
              ポイントからNEXT-CHANGEまでのテキストを処理する...
              (goto-char next-change)))

 -- Function: next-single-property-change POS PROP &optional OBJECT LIMIT
     この関数は、文字列やバッファであるOBJECT内の位置POSから属性PROPが異
     なるまでテキストを走査し、その変化する位置を返す。いいかえれば、POS
     の直後の文字の属性PROPとは異なる属性PROPをもつPOSのあとにある最初の
     文字の位置を返す。

     LIMITが`nil'以外であると、LIMITの位置で走査を終える。その箇所まで異
     なる属性がないと、`next-single-property-change'はLIMITを返す。

     LIMITが`nil'でありOBJECTの末尾まで属性に変化がないと、値は`nil'であ
     る。値が`nil'以外であると、それはPOSより大きいか等しい位置である。
     値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

 -- Function: previous-property-change POS &optional OBJECT LIMIT
     これは`next-property-change'と同様であるが、前方へではなくPOSから後
     方へ走査する。値が`nil'以外であると、それはPOSより小さいか等しい位
     置である。値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

 -- Function: previous-single-property-change POS PROP &optional OBJECT LIMIT
     これは`next-single-property-change'と同様であるが、前方へではなく
     POSから後方へ走査する。値が`nil'以外であると、それはPOSより小さいか
     等しい位置である。値がPOSに等しいのは、LIMITがPOSに等しい場合のみで
     ある。

 -- Function: next-char-property-change POSITION &optional LIMIT
     これは`next-property-change'と同様であるが、テキスト属性に加えてオー
     バレイも対象にする。この関数はカレントバッファにのみ作用するため、
     OBJECTを表す引数はない。どちらかの属性が異なるつぎの位置を返す。

 -- Function: previous-char-property-change POSITION &optional LIMIT
     これは`next-char-property-change'と同様であるが、前方へではなくPOS
     から後方へ走査する。

 -- Function: text-property-any START END PROP VALUE &optional OBJECT
     STARTとENDのあいだに属性PROPの値がVALUEである文字が1つでもあれば、
     この関数は`nil'以外を返す。より正確には、そのような最初の文字の位置
     を返す。さもなければ`nil'を返す。

     省略可能な5番目の引数OBJECTは、走査すべき文字列やバッファを指定する。
     位置はOBJECTに相対である。OBJECTのデフォルトはカレントバッファであ
     る。

 -- Function: text-property-not-all START END PROP VALUE &optional OBJECT
     STARTとENDのあいだに属性PROPの値がVALUEでない文字が1つでもあれば、
     この関数は`nil'以外を返す。より正確には、そのような最初の文字の位置
     を返す。さもなければ`nil'を返す。

     省略可能な5番目の引数OBJECTは、走査すべき文字列やバッファを指定する。
     位置はOBJECTに相対である。OBJECTのデフォルトはカレントバッファであ
     る。



File: elisp-ja.info, Node: Special Properties, Next: Format Properties, Prev: Property Search, Up: Text Properties

特別な意味を持つ属性
--------------------

特別な組み込みの意味を持つテキスト属性名の一覧を以下に示します。以降の節
では、詰め込みや属性の継承を制御する特別な属性名も示します。それ以外の名
前には標準的な意味はないので、読者はそれらを好きなように使ってかまいませ
ん。

`category'
     文字に属性`category'があるとき、これを文字の"カテゴリ"（category）
     と呼ぶ。これはシンボルであること。そのシンボルの属性が、文字の属性
     のデフォルトとして働く。

`face'
     テキストのフォントと表示色を制御するために属性`face'を使う。その値
     はフェイス名かフェイス名のリストである。詳しくは、*Note Faces::。

     属性値がリストであると、その要素は、`(foreground-color
     . COLOR-NAME)'や`(background-color . COLOR-NAME)'の形でもよい。これ
     らの要素は、前景色だけや背景色だけを指定する。したがって、使用する
     各色を表すフェイスを作成する必要はない。

     テキストの内容に基づいて属性`face'を自動的に更新する方法に関しては、
     *Note Font Lock Mode::。

`mouse-face'
     マウスが文字の上やその近くにあると、属性`face'のかわりに属性
     `mouse-face'が使われる。この目的において『近く』とは、文字とマウス
     の位置のあいだの属性`mouse-face'の値が同じであるすべてのテキストで
     ある。

`local-map'
     属性`local-map'を用いることで、バッファ内のテキストの一部分に対して
     別のキーマップを指定できる。ポイントのうしろの文字のこの属性の値が
     `nil'以外であると、バッファのローカルマップのかわりにその値をキー探
     索に使う。属性値がシンボルであると、シンボルの関数定義をキーマップ
     として使う。*Note Active Keymaps::。

`syntax-table'
     属性`syntax-table'は、構文テーブルがこの文字に指定するものに優先す
     る。*Note Syntax Properties::。

`read-only'
     文字に属性`read-only'があると、その文字を変更できない。変更するどの
     ようなコマンドもエラーになる。

     挿入されるテキストがスティッキ性のために属性`read-only'を継承する場
     合には、読み出し専用文字のつぎにテキストを挿入するとエラーになる。
     したがって、スティッキ性を制御することで、読み出し専用テキストのつ
     ぎへのテキスト挿入を許すかどうかを制御できる。*Note Sticky
     Properties::。

     属性を変更するとバッファを変更したとみなすため、特別なトリックを知
     らない限り、属性を`read-only'を削除できない。つまり、
     `inhibit-read-only'に`nil'以外の値を束縛して、属性を削除する。*Note
     Read Only Buffers::。

`invisible'
     属性`invisible'が`nil'以外であると、その文字はスクリーンに表示され
     ない。詳しくは、*Note Invisible Text::。

`intangible'
     連続する文字に属性`intangible'の`nil'でない同じ値があると、それらの
     あいだにポイントを置けなくなる。前方に向けてこれらの文字の中にポイ
     ントを移動しようとすると、ポイントは実際にはそれらの末尾へ移動する。
     後方に向けてこれらの文字の中にポイントを移動しようとすると、ポイン
     トは実際にはそれらの先頭へ移動する。

     変数`inhibit-point-motion-hooks'が`nil'以外であると、属性
     `intangible'は無視される。

`modification-hooks'
     文字に属性`modification-hooks'がある場合、それは関数のリストである
     こと。その文字の変更にはそれらの関数すべてが呼び出される。各関数は2
     つの引数、つまり、バッファの変更対象部分の先頭と末尾を受け取る。1つ
     の操作で変更される一連の文字に同じ変更フック関数が現れる場合、関数
     が実際に何回呼ばれるか予測できないことに注意してほしい。

`insert-in-front-hooks'
`insert-behind-hooks'
     バッファにテキストを挿入する操作でも、挿入箇所のうしろの文字の属性
     `insert-in-front-hooks'とまえの文字の属性`insert-behind-hooks'に指
     定されている関数群を呼び出す。これらの関数は2つの引数、つまり、挿入
     されたテキストの先頭と末尾を受け取る。これらの関数が呼ばれるのは、
     実際の挿入操作を*終えてから*である。

     バッファ内のテキストを変更するときに呼び出される他のフックについて
     は、*Note Change Hooks::も参照。

`point-entered'
`point-left'
     特別な属性`point-entered'と`point-left'は、ポイント移動を報告するフッ
     ク関数を保持する。ポイントが動くたびに、Emacsはこれらの2つの属性値、
     つまり、

        * 移動前のポイントのうしろの文字の属性`point-left'と
        * 移動後のポイントのうしろの文字の属性`point-entered'

     を比較する。これら2つの値が異なれば、ポイントの古い値と新しい値の2
     つの引数で（`nil'でなければ）それぞれを呼び出す。

     同じことを移動前後のポイントのまえの文字についても行う。その結果、
     （同じかもしれない）`point-left'の関数を2回、かつ／あるいは、（同じ
     かもしれない）`point-entered'の関数を2回実行する。いずれにしても、
     `point-left'の関数が最初に呼ばれ、そのあとで`point-entered'の関数が
     呼ばれる。

     これらの関数では、`char-after'を使ってポイントを移動せずにさまざま
     な箇所の文字を調べられる。ポイントの値が実際に変わったときにのみ、
     これらのフック関数が実行される。

 -- Variable: inhibit-point-motion-hooks
     この変数が`nil'以外であると、`point-left'と`point-entered'のフック
     関数は実行されなくなり、属性`intangible'の効果もなくなる。この変数
     はグローバルに設定せずに、`let'で束縛すること。



File: elisp-ja.info, Node: Format Properties, Next: Sticky Properties, Prev: Special Properties, Up: Text Properties

整形済みテキストの属性
----------------------

これらのテキスト属性は、詰め込みコマンドのふるまいに影響します。これらは
整形済みのテキストを表現するために使われます。*Note Filling::と*Note
Margins::。

`hard'
     改行文字にこの属性があると、『ハード』改行である。詰め込みコマンド
     は『ハード』改行を変更せず、それらをまたがって単語を移動しない。し
     かし、この属性は`use-hard-newlines'が`nil'以外の場合にのみ効果を持
     つ。

`right-margin'
     テキストのこの部分を詰め込むための余分な右端余白を指定する。

`left-margin'
     テキストのこの部分を詰め込むための余分な左端余白を指定する。

`justification'
     テキストのこの部分を詰め込むための幅揃えスタイルを指定する。



File: elisp-ja.info, Node: Sticky Properties, Next: Saving Properties, Prev: Format Properties, Up: Text Properties

テキスト属性のスティッキ性
--------------------------

自己挿入文字は、通常、先行する文字と同じ属性を持ちます。これを属性の"継
承"（inheritance）と呼びます。

Lispプログラムでは、挿入基本関数を選べば、継承して挿入したり継承せずに挿
入できます。`insert'などの普通のテキスト挿入関数は、いかなる属性も継承し
ません。これらは、挿入する文字列の属性をそのまま持ったテキストを挿入し、
それ以外の属性はありません。キルリングなどのある文脈から別の文脈へテキス
トをコピーするプログラムには、これは正しい動作です。継承して挿入するには、
本節で述べる特別な基本関数を使います。自己挿入文字はこれらの基本関数を使っ
ているので、属性を継承します。

継承して挿入するとき、*どの*属性を継承するかは、2つの特別な属性
`front-sticky'と`rear-nonsticky'に依存します。

文字のうしろに挿入すると、その文字の"後続スティッキ"（rear-sticky）であ
る属性を継承します。文字のまえに挿入すると、その文字の"先行スティッキ"
（front-sticky）である属性を継承します。デフォルトでは、テキスト属性は先
行スティッキではなく後続スティッキです。したがって、デフォルトでは、まえ
の文字のすべての属性を継承して、うしろの文字からはなにも継承しません。特
定の属性のスティッキ性を指定することで、異なるふるまいを指定できます。

文字の属性`front-sticky'が`t'であると、その文字のすべての属性は先行スティッ
キです。属性`front-sticky'がリストであると、リストに現れる名前のその文字
の属性は先行スティッキです。たとえば、文字の属性`front-sticky'の値が
`(face read-only)'であると、この文字のまえに挿入するとこの文字の属性
`face'と`read-only'を継承しますが、それ以外には継承しません。

`rear-nonsticky'は反対の働きをします。すべての属性はデフォルトでは後続ス
ティッキですから、属性`rear-nonsticky'はどの属性が後続スティッキで*ない*
かを指定します。文字の属性`rear-nonsticky'が`t'であると、その文字には後
続スティッキである属性はありません。属性`rear-nonsticky'がリストであると、
リストに名前が現れ*ない限り*、属性は後続スティッキです。

継承するようにテキストを挿入すると、まえの文字からは後続スティッキである
すべての属性を継承し、うしろの文字からは先行スティッキであるすべての属性
を継承します。両側の文字に異なるスティッキ性の同じ属性がある場合には、ま
えの文字の属性が優先します。

属性を継承してテキストを挿入する関数はつぎのとおりです。

 -- Function: insert-and-inherit &rest STRINGS
     関数`insert'と同様に文字列STRINGSを挿入するが、前後のテキストから任
     意のスティッキ性の属性を継承する。

 -- Function: insert-before-markers-and-inherit &rest STRINGS
     関数`insert-before-markers'と同様に文字列STRINGSを挿入するが、前後
     のテキストから任意のスティッキ性の属性を継承する。

継承しない普通の挿入関数については、*Note Insertion::。



File: elisp-ja.info, Node: Saving Properties, Next: Lazy Properties, Prev: Sticky Properties, Up: Text Properties

テキスト属性をファイルへ保存する
--------------------------------

つぎの2つのフックを使って、テキスト属性を（テキストそのものとともに）ファ
イルに保存しておき、ファイルを訪問したり挿入するときに同じテキスト属性を
復元できます。

 -- Variable: write-region-annotate-functions
     この変数の値は、ファイルへ書き込むテキストに対する注記の形でテキス
     ト属性を符号化するために`write-region'が呼び出す関数のリストである。
     *Note Writing to Files::。

     リスト内の各関数は2つの引数、つまり、書き込む領域の先頭と末尾で呼び
     出される。これらの関数はバッファの内容を変更しないこと。そのかわり
     に、バッファのテキストに加えてファイルに書き込むべき注記を表すリス
     トを返すべきである。

     各関数は、`(POSITION . STRING)'の形の要素から成るリストを返すべきで
     ある。ここで、POSITIONは書き込まれるテキスト内の相対位置を指定する
     整数、STRINGはそこへ追加する注記である。

     これらの関数が返す各リストは、POSITIONの昇順になっている必要がある。
     複数の関数があると、`write-region'はリストを破壊的に併合して1つのソー
     トしたリストにする。

     `write-region'がバッファからファイルにテキストを実際に書くときに、
     指定された注記を対応する位置に混在させる。バッファを変更せずにこれ
     らすべてを行う。

 -- Variable: after-insert-file-functions
     この変数は、`insert-file-contents'がファイルの内容を挿入してから呼
     び出す関数のリストを保持する。これらの関数は挿入されたテキストで注
     記を走査し、それらが表すテキスト属性にそれらを変換する。

     各関数は1つの引数、つまり、挿入されたテキストの長さで呼ばれ、ポイン
     トは挿入されたテキストの先頭を表す。関数は当該テキストで注記を走査
     して注記を削除し、注記が指定するテキスト属性を作成する。関数は、変
     更を反映した挿入されたテキストの更新された長さを返すこと。関数が返
     した値がつぎの関数の引数になる。

     これらの関数は、挿入されたテキストの先頭にポイントをつねに戻すこと。

     `after-insert-file-functions'の意図された用途は、テキスト表現の注記
     を実際のテキスト属性に変換することである。しかし、別の使い方も可能
     である。

これらのフックを使ってファイルにテキスト属性を保存したり復元するLispプロ
グラムを書いて、さまざまなデータ書式を試してよいものをみつけるようにお願
いします。最終的には、Emacsに取り込める良質で汎用の拡張をユーザーが作り
出すことを願っています。

テキスト属性の名前や値として任意のLispオブジェクトを処理しないように忠告
しておきます。そのような汎用のプログラムは書くのが難しく動作が遅くなりが
ちです。そのかわりに、適当に柔軟性があり符号化が難しくないデータ型の集合
を選びます。

関連する機能については、*Note Format Conversion::。




File: elisp-ja.info, Node: Lazy Properties, Next: Clickable Text, Prev: Saving Properties, Up: Text Properties

テキスト属性の遅延計算
----------------------

バッファ内のすべてのテキストのテキスト属性を計算するかわりに、必要になっ
た時点でテキストの一部分のテキスト属性を計算するようにできます。

バッファからテキスト属性とともにテキストを取り出す基本関数は、
`buffer-substring'です。属性を調べるまえに、この関数はアブノーマルフック
`buffer-access-fontify-functions'を実行します。

 -- Variable: buffer-access-fontify-functions
     この変数は、テキスト属性を計算する関数のリストを保持する。
     `buffer-substring'がバッファの一部分からテキストとテキスト属性をコ
     ピーするまえに、この関数はこのリスト内の関数すべてを呼び出す。各関
     数は、バッファの参照される範囲を指定する2つの引数を受け取る。（バッ
     ファはつねにカレントバッファである。）

関数`buffer-substring-no-properties'はテキスト属性を無視するので、これら
の関数を呼び出しません。

バッファの同じ部分に対してフック関数が複数回呼び出されるのを防ぐには、変
数`buffer-access-fontified-property'を使います。

 -- Variable: buffer-access-fontified-property
     この変数の値が`nil'以外であると、それはテキスト属性の名前として使わ
     れるシンボルである。そのテキスト属性に対する`nil'以外の値は、『この
     文字の他のテキスト属性はすでに計算済みである』ことを意味する。

     `buffer-substring'に指定された範囲のすべての文字において、この属性
     に対して`nil'以外の値があると、`buffer-substring'は
     `buffer-access-fontify-functions'の関数を呼び出さない。それらの文字
     にはすでに正しいテキスト属性があるとみなし、それらにすでにある属性
     をコピーする。

     この機能を使う普通の方法は、`buffer-access-fontify-functions'の関数
     が他の属性ととともにこの属性をそれらが操作した文字に追加する。そう
     すれば、同じテキストに対して何回も呼び出されるのを防ぐことができる。



File: elisp-ja.info, Node: Clickable Text, Next: Not Intervals, Prev: Lazy Properties, Up: Text Properties

クリック可能なテキストを定義する
--------------------------------

バッファ内に"クリック可能なテキスト"（clickable text）を設定するには2つ
の方法があります。これは典型的には2つの部分から成ります。つまり、マウス
が重なるとテキストを強調表示し、テキストのその部分をクリックするとマウス
ボタンがなんらかの処理を行うようにします。

強調表示はテキスト属性`mouse-face'で行います。diredでの方法を例として示
します。

     (condition-case nil
         (if (dired-move-to-filename)
             (put-text-property (point)
                                (save-excursion
                                  (dired-move-to-end-of-filename)
                                  (point))
                                'mouse-face 'highlight))
       (error nil))

`put-text-property'の最初の2つの引数は、テキストの先頭と末尾を指定します。

このテキストをクリックしたときにマウスになにかをさせるようにする普通の方
法は、メジャーモードのキーマップで`mouse-2'を定義することです。クリック
可能なテキストをクリックしたかどうかの検査は、コマンド定義で行われます。
diredではつぎのようにしています。

     (defun dired-mouse-find-file-other-window (event)
       "In dired, visit the file or directory name you click on."
       (interactive "e")
       (let (file)
         (save-excursion
           (set-buffer (window-buffer (posn-window (event-end event))))
           (save-excursion
             (goto-char (posn-point (event-end event)))
             (setq file (dired-get-filename))))
         (select-window (posn-window (event-end event)))
         (find-file-other-window (file-name-sans-versions file t))))

外側の`save-excursion'は、カレントバッファが変わることを防ぎます。内側の
は、クリックしたバッファのポイントを恒久的に変更することを防ぎます。この
例では、diredは関数`dired-get-filename'を用いて、イベントの位置に基づい
て訪問すべきファイルを決定します。

メジャーモードのマウスコマンドを定義するかわりに、テキスト属性
`local-map'を使って、クリック可能なテキストそのものにキーバインディング
を定義することもできます。

     (let ((map (make-sparse-keymap)))
       (define-key-binding map [mouse-2] 'operate-this-button)
       (put-text-property (point)
                          (save-excursion
                            (dired-move-to-end-of-filename)
                            (point))
                          'local-map map))

この方法では、テキストのさまざまなクリック可能な部分に異なるコマンドを定
義できます。さらに、バッファの残りの部分に対しては、メジャーモードの定義
（やグローバルな定義）がそのまま有効です。



File: elisp-ja.info, Node: Not Intervals, Prev: Clickable Text, Up: Text Properties

テキスト属性が範囲でない理由
----------------------------

バッファ内のテキストに属性を付加できるエディタのなかには、ユーザーにテキ
スト内の『範囲』を指定させ、その範囲に属性を付加するものがあります。この
ようなエディタでは、ユーザーやプログラマが個々の範囲の先頭と末尾を決定で
きます。テキスト変更に伴うある種の矛盾するようなふるまいを避けるために、
熟考の結果Emacs Lispでは別の種類のインターフェイスを提供することにしまし
た。

複数の範囲に細分することが意味を持つならば、ある属性の1つの範囲があるだ
けのバッファと、その同じテキストをその同じ属性の2つの範囲にしてあるバッ
ファとを区別できるはずです。

1つの範囲だけを持つバッファにおいて、そのテキストの一部をキルしたとしま
す。バッファに残っているテキストは1つの範囲であり、キルリング（とアンドゥ
リスト）内のコピーは1つの別の範囲になります。そしてキルされたテキストを
ヤンクして戻すと、同じ属性を持つ2つの範囲ができます。つまり、編集すると、
1つの範囲と2つの範囲の区別を保存できなくなります。

テキストを挿入すると2つの範囲を融合することでこの問題を『修正』したとし
ます。バッファにもともと1つの範囲しかなければ、うまくいきます。しかし、
同じ属性の範囲が連続して2つある場合に、一方の範囲をキルしてからヤンクし
て戻したとします。別の場面では救いになる同じ属性の範囲を融合する機能が、
ここではトラブルを引き起こします。つまり、ヤンクすると1つの範囲になって
しまいます。ここでも、編集すると、1つの範囲と2つの範囲の区別を保存できな
くなります。

2つの範囲の境界にテキストを挿入する場合でも、満足できる解決方法がない問
題を提起します。

しかし、『この文字の属性はなにか』といった形の問いに対して一貫したふるま
いをするような編集にするのは簡単です。そのために、これらが唯一の意味ある
問いかけであると判断したのです。範囲の先頭と末尾を問うようなものは実装し
てありません。

実用上は、明示的な範囲の境界のかわりに、テキスト属性を探索する関数を普通
は使えます。それらの関数は、可能な場合にはつねに範囲は融合されると仮定し
て範囲の境界を探すと考えることができます。*Note Property Search::。

Emacsには表示機能として明示的な範囲もあります。*Note Overlays::を参照し
てください。



File: elisp-ja.info, Node: Substitution, Next: Registers, Prev: Text Properties, Up: Text

文字コードの置換
================

つぎの関数は、指定した領域内の文字をそれらの文字コードに基づいて置き換え
ます。

 -- Function: subst-char-in-region START END OLD-CHAR NEW-CHAR &optional NOUNDO
     この関数は、カレントバッファのSTARTとENDで定義される領域のすべての
     文字OLD-CHARを文字NEW-CHARに置き換える。

     NOUNDOが`nil'以外であると、`subst-char-in-region'はアンドゥ用の変更
     を記録せず、バッファに変更済みの印も付けない。この機能は、選択表示
     （*Note Selective Display::）の制御に使われている。

     `subst-char-in-region'はポイントを移動せず、`nil'を返す。

          ---------- Buffer: foo ----------
          This is the contents of the buffer before.
          ---------- Buffer: foo ----------

          (subst-char-in-region 1 20 ?i ?X)
               => nil

          ---------- Buffer: foo ----------
          ThXs Xs the contents of the buffer before.
          ---------- Buffer: foo ----------

 -- Function: translate-region START END TABLE
     この関数は、バッファのSTARTとENDのあいだの文字に変換表を適用する。

     変換表TABLEは文字列であり、`(aref TABLE OCHAR)'は、OCHARに対応する
     変換した文字を与える。TABLEの長さが256未満であると、TABLEの長さより
     大きなコードの文字は変換によっては変更されない。

     `translate-region'の戻り値は、変換によって実際に変更した文字の個数
     を返す。これには、変換表で自分自身に変換された文字は数えない。



File: elisp-ja.info, Node: Registers, Next: Transposition, Prev: Substitution, Up: Text

レジスタ
========

レジスタは、Emacsの編集においてさまざまな種類の値を保持できる変数の一種
です。各レジスタには1文字の名前が付いています。すべてのASCII文字とそれら
のメタ変種（ただし`C-g'を除く）をレジスタの名前に使えます。したがって、
255個のレジスタを使えます。Emacs Lispでは、レジスタ名でレジスタを区別し
ます。

 -- Variable: register-alist
     この変数は、`(NAME . CONTENTS)'の形の要素の連想リストである。通常、
     使用中のEmacsの各レジスタに対して1つの要素がある。

     オブジェクトNAMEは、レジスタを識別する文字（整数）である。

レジスタの内容（CONTENTS）に可能な型はいくつかあります。

数
     数そのものを表す。`insert-register'がレジスタ内で数をみつけると10進
     数に変換する。

マーカ
     マーカはジャンプ先のバッファ内位置を表す。

文字列
     文字列はレジスタに保存されたテキストである。

矩形領域
     矩形領域は文字列のリストで表現される。

`(WINDOW-CONFIGURATION POSITION)'
     これは、1つのフレームに復元するウィンドウ構成とカレントバッファでの
     ポイントの移動先を表す。

`(FRAME-CONFIGURATION POSITION)'
     これは、復元するフレーム構成とカレントバッファでのポイントの移動先
     を表す。

(file FILENAME)
     訪問すべきファイルを表す。この値にジャンプするとファイルFILENAMEを
     訪問する。

(file-query FILENAME POSITION)
     これは、訪問すべきファイルとその中での位置を表す。この値にジャンプ
     するとファイルFILENAMEを訪問しバッファ内位置POSITIONへ移動する。こ
     の種の位置を復元すると、まずユーザーに確認を取る。

本節の関数は、明記してない場合には予測できない値を返します。

 -- Function: get-register REG
     この関数は、レジスタREGの内容、あるいは、内容がなければ`nil'を返す。

 -- Function: set-register REG VALUE
     この関数は、レジスタREGの内容をVALUEとする。レジスタには任意の値を
     設定できるが、他のレジスタ関数は特定のデータ型を期待する。戻り値は
     VALUEである。

 -- コマンド: view-register REG
     このコマンドは、レジスタREGになにが入っているかを表示する。


 -- コマンド: insert-register REG &optional BEFOREP
     このコマンドはレジスタREGの内容をカレントバッファに挿入する。

     通常、このコマンドは挿入したテキストのまえにポイントを置き、そのあ
     とにマークを置く。しかし、省略可能な2番目の引数BEFOREPが`nil'以外で
     あると、まえにマークを置きあとにポイントを置く。この関数を対話的に
     呼び出すときに前置引数を指定すれば、2番目の引数BEFOREPに`nil'以外を
     渡せる。

     レジスタに矩形領域が含まれる場合、ポイント位置に矩形領域の左上隅が
     くるように挿入される。つまり、テキストは現在行とそのしたの連続する
     行に挿入される。

     保存したテキスト（文字列）や矩形領域（リスト）以外がレジスタに入っ
     ていると、現状では有用なことは起こらない。将来これは変更されるであ
     ろう。




File: elisp-ja.info, Node: Transposition, Next: Change Hooks, Prev: Registers, Up: Text

テキストの転置
==============

つぎのサブルーティンは転置コマンドで使われます。

 -- Function: transpose-regions START1 END1 START2 END2 &optional LEAVE-MARKERS
     この関数は、バッファの重なり合わない2つの部分を入れ換える。引数
     START1とEND1で一方の部分の境界を指定し、引数START2とEND2で他方の部
     分の境界を指定する。

     通常、`transpose-regions'は転置したテキスト内のマーカを再配置する。
     つまり、2つの転置部分の一方の内側を指していたマーカはその部分ととも
     に移動して、新しい位置で同じ2つの文字のあいだに留まる。しかし、
     LEAVE-MARKERSが`nil'以外であると、`transpose-regions'はこれを行わず、
     すべてのマーカは再配置されない。



File: elisp-ja.info, Node: Change Hooks, Prev: Transposition, Up: Text

変更フック
==========

これらのフックにより、すべてのバッファ（それらをバッファローカルにしてお
けば特定のバッファ）におけるすべての変更を知るようにできます。テキストの
特定部分の変更を検出する方法については、*Note Special Properties::も参照
してください。

これらのフックに使う関数において正規表現を使う場合には、マッチデータを保
存し復元する必要があります。さもないと、それらを呼び出す編集操作と奇妙な
干渉を引き起こします。

 -- Variable: before-change-functions
     この変数は、バッファを変更するまえに呼び出すべき関数のリストを保持
     する。各関数は2つの引数、つまり、整数で表した変更対象の領域の先頭と
     末尾を受け取る。変更対象のバッファはつねにカレントバッファである。

 -- Variable: after-change-functions
     この変数は、バッファを変更したあとに呼び出すべき関数のリストを保持
     する。各関数は3つの引数、つまり、変更されたばかりの領域の先頭と末尾、
     変更前に存在していたテキストの長さを受け取る。3つの引数はすべて整数
     である。変更対象のバッファはつねにカレントバッファである。

     古いテキストの長さは、変更前のそのテキストの先頭と末尾のバッファ内
     位置の差である。変更済みのテキストの長さは、単純に始めの2つの引数の
     差である。

 -- Macro: combine-after-change-calls BODY...
     このマクロは通常どおりBODYを実行するが、一連の変更に対して安全と思
     えるときには、`after-change-functions'の関数を一度だけ呼び出す。

     プログラムからバッファの同じ部分でテキスト変更を複数回行う場合、プ
     ログラムの当該部分の周りでマクロ`combine-after-change-calls'を使う
     と、フック`after-change-functions'を使用してるときには動作がかなり
     速くなりうる。最終的にフック`after-change-functions'が呼ばれると、
     `combine-after-change-calls'の本体で行った変更すべてを含むようなバッ
     ファ部分が引数に指定される。

     *警告：*` ' フォーム`combine-after-change-calls'の本体の内側では
     `after-change-functions'と`after-change-function'の値を変更しないこ
     と。

     *注意：*` ' 変更がバッファの広く分散した部分に行われるときにもこれ
     は動作するが、推奨できない。非効率なふるまいをするようなフック関数
     があるからである。

 -- Variable: before-change-function
     この廃れた変数は、任意のバッファの変更を行うまえに呼ばれる1つの関数
     を保持する（`nil'ならばそのような関数はなし）。
     `before-change-functions'の関数と同様に呼ばれる。

 -- Variable: after-change-function
     この廃れた変数は、任意のバッファの変更を行ったあとに呼ばれる1つの関
     数を保持する（`nil'ならばそのような関数はなし）。
     `after-change-functions'の関数と同様に呼ばれる。

上の4つの変数は、これらの関数が実行中には一時的に`nil'に束縛されます。つ
まり、これらの関数の1つがバッファを変更しても、その変更ではこれらの関数
を呼び出しません。フック関数においてこれらの関数を実行するような変更を行
いたい場合には、フック関数でこれらの変数をそれらの通常の値に束縛し直しま
す。

この保護的な機構の1つの不便な帰結は、`after-change-functions'や
`before-change-functions'には、その変数の値を変更する関数を持てないこと
です。しかし、これは本当の制限ではありません。それらの関数で実行すべき関
数のリストを変更したければ、単純に1つの定まった関数をフックに追加し、そ
の関数では呼び出すべき別の関数を指定する別の変数を調べます。つぎのように
します。

     (setq my-own-after-change-functions nil)
     (defun indirect-after-change-function (beg end len)
       (let ((list my-own-after-change-functions))
         (while list
           (funcall (car list) beg end len)
           (setq list (cdr list)))))

     (add-hooks 'after-change-functions
                'indirect-after-change-function)

 -- Variable: first-change-hook
     この変数は、未変更状態のバッファを変更するたびに実行されるノーマル
     フックである。


File: elisp-ja.info, Node: Non-ASCII Characters, Next: Searching and Matching, Prev: Text, Up: Top

非ASCII文字
***********

本章では、非ASCIIに関連する特別なことがらとそれらが文字列やバッファにど
のように保存されるかについて述べます。

* Menu:

* Text Representations::
* Converting Representations::
* Selecting a Representation::
* Character Codes::
* Character Sets::
* Chars and Bytes::
* Splitting Characters::
* Scanning Charsets::
* Translation of Characters::
* Coding Systems::
* Input Methods::



File: elisp-ja.info, Node: Text Representations, Next: Converting Representations, Prev: Non-ASCII Characters, Up: Non-ASCII Characters

テキスト表現
============

Emacsには2つの"テキスト表現"、つまり、文字列やバッファでテキストを表す方
法が2つあります。これらは、"ユニバイト"（unibyte）と"マルチバイト"
（multibyte）と呼ばれます。各文字列や各バッファでは、これらの2つの表現の
一方を使います。ほとんどの目的には、Emacsがこれらのあいだで適切に変換す
るので、読者はこれらの表現に関しては無視できます。Lispプログラムでは、こ
れらの違いに注意する必要がしばしばあります。

ユニバイト表現では、各文字は1バイトを占め、そのため、可能な文字コードの
範囲は0から255です。コード0から127はASCII文字です。コード128から255は非
ASCII文字集合の1つ（変数`nonascii-insert-offset'に設定して文字集合を選べ
る）に使われます。

マルチバイト表現では、1文字は1バイト以上を占め、そのため、Emacsの文字コー
ドの範囲全体を格納できるのです。マルチバイト文字の最初のバイトはつねに
128から159（8進数で0200から0237）の範囲にあります。これらの値を"リーディ
ングコード"（leading code）と呼びます。マルチバイト文字の2バイト以降はつ
ねに160から255（8進数で0240から0377）の範囲にあります。これらの値を"トレ
イリングコード"（trailing code）と呼びます。

バッファでは、変数`enable-multibyte-characters'のバッファローカルな値が
使用する表現を指定します。文字列の表現は、文字列を作成するときの文字列の
内容に基づいて決定されます。

 -- Variable: enable-multibyte-characters
     この変数は、バッファのテキスト表現を指定する。これが`nil'以外である
     と、バッファはマルチバイトテキストを保持する。さもなければユニバイ
     トテキストを保持する。

     この変数に直接設定することはできない。そのかわりに、バッファの表現
     を変更するには、関数`set-buffer-multibyte'を使う。

 -- Variable: default-enable-multibyte-characters
     この変数の値は、`(default-value 'enable-multibyte-characters)'に完
     全に等価であり、この変数に設定するとデフォルト値を変更する。バッファ
     の`enable-multibyte-characters'のローカルな束縛に設定することは許さ
     れていないが、デフォルト値を変更することは可能であり、そうしても既
     存のバッファには影響しないので理にかなっている。

     コマンド行オプション`--unibyte'は、起動時の早い段階でデフォルト値に
     `nil'を設定することで役目を果たす。

 -- Function: multibyte-string-p STRING
     文字列STRINGにマルチバイト文字が含まれると`t'を返す。



File: elisp-ja.info, Node: Converting Representations, Next: Selecting a Representation, Prev: Text Representations, Up: Non-ASCII Characters

テキスト表現の変換
==================

Emacsはユニバイトテキストをマルチバイトに変換できます。マルチバイトテキ
ストをユニバイトにも変換できますが、この変換では情報が欠落します。バッファ
にテキストを挿入するとき、あるいは、複数の文字列から1つの文字列にテキス
トを収めるときに、一般にこれらの変換が行われます。文字列の内容をどちらか
の表現に明示的にも変換できます。

Emacsは、文字列を作成するときにはその内容に基づいて文字列の表現を選びま
す。一般則は、ユニバイトテキストを他のマルチバイトテキストに組み入れると
きにはユニバイトテキストをマルチバイトテキストに変換します。マルチバイト
表現のほうが汎用であり、ユニバイトテキストのどんな文字でも保持できるから
です。

バッファにテキストを挿入するときには、Emacsは、当該バッファの
`enable-multibyte-characters'の指定に従ったバッファの表現にテキストを変
換します。特に、ユニバイトバッファにマルチバイトテキストを挿入するときに
は、マルチバイトテキスト内のすべての文字を一般には保存できなくても、
Emacsはテキストをユニバイトに変換します。自然な代替案はバッファ内容をマ
ルチバイトに変換することですが、これは受け入れられません。バッファの表現
はユーザーが選択したものであり自動的には無視できないからです。

ユニバイトテキストをマルチバイトテキストに変換してもASCII文字は無変更で
あり、128から159も同様です。160から255の非ASCIIについては、各文字に
`nonascii-insert-offset'の値を加算することで変換します。この変数に設定す
ると、ユニバイト文字がどの文字集合に対応するかを指定できます（*Note
Character Sets::）。たとえば、`nonascii-insert-offset'が`(- (make-char
'latin-iso8859-1) 128)'の2048であると、非ASCIIのユニバイトはLatin 1に対
応します。`(- (make-char 'greek-iso8859-7) 128)'の2688であると、ギリシャ
文字に対応します。

マルチバイトテキストをユニバイトに変換するのは簡単で、各文字コードと255
の論理積をとります。`nonascii-insert-offset'に文字集合の始まりに対応する
合理的な値が設定されていれば、この変換は逆変換になります。つまり、ユニバ
イトテキストをマルチバイトに変換し、それをユニバイトに戻すともとのユニバ
イトテキストになります。

 -- Variable: nonascii-insert-offset
     この変数は、ユニバイトテキストをマルチバイトに変換するときに非ASCII
     文字に加算する値を指定する。これは、128から255のユニバイトの非ASCII
     の範囲の文字を挿入する`self-insert-command'にも適用される。しかし、
     関数`insert-char'はこの変換を行わない。

     文字集合CSを選択する正しい値は、`(- (make-char CS) 128)'である。
     `nonascii-insert-offset'の値が0であると、実際の変換には0ではなく
     Latin 1文字集合に対する値を使う。

 -- Variable: nonascii-translation-table
     この変数は、`nonascii-insert-offset'のより一般的な代替を提供する。
     128から255の範囲の各コードをマルチバイト文字に変換する方法を独立し
     て指定するために使える。その値はベクトルか`nil'であること。これが
     `nil'以外であると、`nonascii-insert-offset'に優先する。

 -- Function: string-make-unibyte STRING
     この関数は、STRINGのテキストがすでにユニバイトでなければユニバイト
     表現に変換してから結果を返す。STRINGがユニバイトであれば無変更で返
     す。

 -- Function: string-make-multibyte STRING
     この関数は、STRINGのテキストがすでにマルチバイトでなければマルチバ
     イト表現に変換してから結果を返す。STRINGがマルチバイトであれば無変
     更で返す。



File: elisp-ja.info, Node: Selecting a Representation, Next: Character Codes, Prev: Converting Representations, Up: Non-ASCII Characters

表現の選択
==========

既存のバッファや文字列がユニバイトであるときにマルチバイトとして調べたり、
その逆のように調べるのが有用なこともあります

 -- Function: set-buffer-multibyte MULTIBYTE
     カレントバッファの表現方法を設定する。MULTIBYTEが`nil'以外であると、
     バッファはマルチバイトになる。MULTIBYTEが`nil'であると、バッファは
     ユニバイトになる。

     この関数は、バイト列としてみたバッファ内容を変更しない。その結果、
     文字として見たときの内容を変更できる。マルチバイト表現では1文字とみ
     なされる2バイトの列は、ユニバイト表現では2文字になる。

     この関数は、`enable-multibyte-characters'にどちらの表現を使用してい
     るかを記録する。さらに（オーバレイ、テキスト属性、マーカなどの）バッ
     ファ内のさまざまなデータを調整して、それ以前と同様に同じテキストに
     及ぶようにする。

 -- Function: string-as-unibyte STRING
     この関数は、各バイトを1文字とみなしてSTRINGと同じバイトの文字列を返
     す。つまり、値にはSTRINGより多くの文字が含まれることがある。

     STRINGがすでにユニバイトであると、値はSTRINGそのものである。

 -- Function: string-as-multibyte STRING
     この関数は、マルチバイトの各列を1文字とみなしてSTRINGと同じバイトの
     文字列を返す。つまり、値にはSTRINGより少ない文字が含まれることがあ
     る。

     STRINGがすでにマルチバイトであると、値はSTRINGそのものである。



File: elisp-ja.info, Node: Character Codes, Next: Character Sets, Prev: Selecting a Representation, Up: Non-ASCII Characters

文字コード
==========

ユニバイトとマルチバイトのテキスト表現では、異なる文字コードを使っていま
す。ユニバイト表現において正しい文字コードは0から255の範囲であり、これら
の値は1バイトに収まります。マルチバイト表現において正しい文字コードは0か
ら524287の範囲ですが、この範囲のすべての値が正しいとは限りません。特に、
値128から255は（『生のバイト』にはありうる。*Note Explicit Encoding::）、
マルチバイトテキストでは正しくありません。0から127のASCIIコードのみが、
どちらの表現でも完全に正しいのです。

 -- Function: char-valid-p CHARCODE
     この関数は、CHARCODEが2つのテキスト表現のどちらか一方で正しければ
     `t'を返す。

          (char-valid-p 65)
               => t
          (char-valid-p 256)
               => nil
          (char-valid-p 2248)
               => t



File: elisp-ja.info, Node: Character Sets, Next: Chars and Bytes, Prev: Character Codes, Up: Non-ASCII Characters

文字集合
========

Emacsは文字をさまざまな"文字集合"（character set）に分類します。文字集合
にはシンボルである名前があります。各文字はたった1つの文字集合に属します。

一般に、異なる文字体系ごとに1つの文字集合があります。たとえば、
`latin-iso8859-1'は1つの文字集合であり、`greek-iso8859-7'は別の文字集合
であり、`ascii'も別の文字集合です。Emacsの1つの文字集合には最大9025個の
文字を保持できます。したがって、論理的には1つの文字集合にまとめられる文
字群を、複数の文字集合に分割する場合もあります。たとえば、Big 5として一
般には知られている中国文字の1つの集合は、Emacsの2つの文字集合、
`chinese-big5-1'と`chinese-big5-2'に分割されます。

 -- Function: charsetp OBJECT
     OBJECTが文字集合の名前のシンボルであれば`t'を返す。さもなければ
     `nil'を返す。

 -- Function: charset-list
     この関数は、定義されているすべての文字集合の名前のリストを返す。

 -- Function: char-charset CHARACTER
     この関数は文字CHARACTERが属する文字集合の名前を返す。



File: elisp-ja.info, Node: Chars and Bytes, Next: Splitting Characters, Prev: Character Sets, Up: Non-ASCII Characters

文字とバイト
============

マルチバイト表現では、各文字は1バイトかそれ以上のバイトを占めます。各文
字集合には、通常は1バイト長か2バイト長の"導入列"（introduction sequence）
があります（例外：ASCIIの導入列は0バイト長である）。導入列は、文字集合の
任意の文字のバイト列の始まりです。文字のバイト列の残りの部分は、同じ文字
集合内で他の文字とその文字を区別します。文字集合に依存して、区別するため
のバイトは1バイトか2バイトです。そのようなバイト数を文字集合の"次元"
（dimension）と呼びます。

 -- Function: charset-dimension CHARSET
     この関数は、文字集合CHARSETの次元を返す。現在、次元はつねに1か2であ
     る。

文字集合の導入列のバイト長を判定するもっとも簡単な方法はつぎのとおりです。

     (- (char-bytes (make-char CHARSET))
        (charset-dimension CHARSET))



File: elisp-ja.info, Node: Splitting Characters, Next: Scanning Charsets, Prev: Chars and Bytes, Up: Non-ASCII Characters

文字の分割
==========

本節の関数は、文字とそれを表現するために用いられるバイト値のあいだの変換
を行います。ほとんどの目的に関しては、Emacsが必要に応じて自動的に行うた
め、文字を表現するためのバイト列を扱う必要はありません。

 -- Function: char-bytes CHARACTER
     この関数は、文字CHARACTERを表現するために必要なバイト数を返す。これ
     は、文字CHARACTERが属する文字集合だけに依存し、その文字集合（*Note
     Character Sets::）の次元とその導入列の和に等しい。

          (char-bytes 2248)
               => 2
          (char-bytes 65)
               => 1
          (char-bytes 192)
               => 1

     マルチバイト表現とユニバイト表現のどちらに対してもこの関数で正しい
     結果を得られるのは、2つの表現で用いられる非ASCII文字コードに重なり
     がないからである。

 -- Function: split-char CHARACTER
     文字CHARACTERの文字集合の名前に続けて、その文字集合でCHARACTERを識
     別する1バイトか2バイトの値（整数）から成るリストを返す。バイト値の
     個数はその文字集合の次元である。

          (split-char 2248)
               => (latin-iso8859-1 72)
          (split-char 65)
               => (ascii 65)

     ユニバイトの非ASCII文字は、文字集合`ascii'の一部とみなす。

          (split-char 192)
               => (ascii 192)

 -- Function: make-char CHARSET &rest BYTE-VALUES
     この関数は、文字集合CHARSETにおいてBYTE-VALUESで識別される文字を返
     す。これは、`split-char'のほぼ逆関数にあたる。通常、文字集合CHARSET
     の次元に応じて、1つか2つのBYTE-VALUESを指定する。たとえばつぎのとお
     り。

          (make-char 'latin-iso8859-1 72)
               => 2248

BYTE-VALUESを指定せずに`make-char'を呼び出すと、その結果は文字集合
CHARSETを代表する"汎用文字"（generic character）である。汎用文字は整数で
あるが、文字としてバッファに挿入するには正しく*ない*ものである。1つの文
字集合全体を表すために`char-table-range'で使える（*Note Char-Tables::）。
`char-valid-p'は汎用文字に対しては`nil'を返す。たとえばつぎのとおり。

     (make-char 'latin-iso8859-1)
          => 2176
     (char-valid-p 2176)
          => nil
     (split-char 2176)
          => (latin-iso8859-1 0)



File: elisp-ja.info, Node: Scanning Charsets, Next: Translation of Characters, Prev: Splitting Characters, Up: Non-ASCII Characters

文字集合の走査
==============

バッファや文字列の一部分にどの文字集合が現れるかを調べられると有用なこと
があります。その1つの用途は、当該テキストすべてを表現する能力があるコー
ディングシステム（*Note Coding Systems::）を探すことです。

 -- Function: find-charset-region BEG END &optional TRANSLATION
     この関数は、カレントバッファのBEGとENDのあいだに現れる文字集合のリ
     ストを返す。

     省略可能な引数TRANSLATIONは、テキストを走査するときに使用する変換表
     を指定する（*Note Translation of Characters::）。これが`nil'以外で
     あると、領域内の各文字をこの表を介して変換し、戻り値は、バッファ内
     の実際の文字のかわりに変換した文字に関する情報を与える。

 -- Function: find-charset-string STRING &optional TRANSLATION
     この関数は、文字列STRINGに現れる文字集合のリストを返す。

     省略可能な引数TRANSLATIONは変換表を指定する。上記の
     `find-charset-region'を参照。



File: elisp-ja.info, Node: Translation of Characters, Next: Coding Systems, Prev: Scanning Charsets, Up: Non-ASCII Characters

文字の変換
==========

"変換表"（translation table）は、文字群を文字群へ対応付けます。これらの
表は、符号化と復号化、他の目的に使われます。独自の変換表を指定するコーディ
ングシステムもあります。他のすべてのコーディングシステムに適用されるデフォ
ルトの変換表もあります。

 -- Function: make-translation-table TRANSLATIONS
     この関数は、引数TRANSLATIONSに基づいた変換表を返す。引数
     TRANSLATIONSの各要素は、`(FROM . TO)'の形であり、文字FROMをTOへ変換
     することを意味する。

     1つの文字集合全体を同じ次元の別の文字集合へ対応付けることも可能であ
     る。それには、FROMに（文字集合を表す）汎用文字を指定する（*Note
     Splitting Characters::）。この場合、TOも、同じ次元の別の文字集合の
     汎用文字であること。こうすると、この変換表は、FROMの文字集合の各文
     字をTOの文字集合の対応する文字へ変換する。

復号化では、もとの復号化結果の文字に変換表による変換を適用します。コーディ
ングシステムに属性`character-translation-table-for-decode'があれば、これ
は使用する変換表を指定します。さもなければ、
`standard-character-translation-table-for-decode'が`nil'以外であれば、復
号化ではその表を使います。

符号化では、バッファ内の文字に変換表による変換を適用し、変換結果を実際に
符号化します。コーディングシステムに属性
`character-translation-table-for-encode'があれば、これは使用する変換表を
指定します。さもなければ、変数
`standard-character-translation-table-for-encode'が使用する変換表を指定
します。

 -- Variable: standard-character-translation-table-for-decode
     これは、変換表を指定しないコーディングシステムに対する復号化時のデ
     フォルトの変換表である。

 -- Variable: standard-character-translation-table-for-encode
     これは、変換表を指定しないコーディングシステムに対する符号化時のデ
     フォルトの変換表である。



File: elisp-ja.info, Node: Coding Systems, Next: Input Methods, Prev: Translation of Characters, Up: Non-ASCII Characters

コーディングシステム
====================

Emacsがファイルを読み書きしたり、Emacsがサブプロセスへテキストを送ったり
サブプロセスからテキストを受け取るときには、"コーディングシステム"
（coding system）で指定される文字コード変換と行末変換を行います。

* Menu:

* Coding System Basics::
* Encoding and I/O::
* Lisp and Coding Systems::
* User-Chosen Coding Systems::
* Default Coding Systems::
* Specifying Coding Systems::
* Explicit Encoding::
* Terminal I/O Encoding::
* MS-DOS File Types::



File: elisp-ja.info, Node: Coding System Basics, Next: Encoding and I/O, Prev: Coding Systems, Up: Coding Systems

コーディングシステムの基本概念
------------------------------

"文字コード変換"（character code conversion）とは、Emacsの内部で使用する
符号と他の符号とのあいだでの変換のことです。Emacsでは、相互に変換できる
多くの異なる符号を扱えます。たとえば、Emacsは、Latin 1、Latin 2、Latin 3、
Latin 4、Latin 5、ISO 2022のいくつかの変種を相互に変換できます。同じ文字
集合に対する異なる符号を扱うこともできます。たとえば、キリル（ロシア語）
文字に対してはISO、Alternativnyj、KOI8の3つのコーディングシステムがあり
ます。

ほとんどのコーディングシステムでは変換する文字コードを特定しますが、指定
せずにデータに基づいて発見的手法で選ぶものもあります。

"行末変換"（end of line conversion）は、ファイル内の行の終りを表すさまざ
まなシステムで使われている3つの異なる慣習を扱います。UNIXの慣習では、行
送り文字（改行文字とも呼ぶ）を使います。DOSの慣習では、行末には復帰と行
送りの2文字の列を使います。Macの慣習では、復帰のみを使います。

`latin-1'のような"基底コーディングシステム"（base coding system）では、
行末変換を指定せずにデータに基づいて選びます。`latin-1-unix'、
`latin-1-dos'、`latin-1-mac'のような"変種コーディングシステム"（variant
coding system）では、明示的に行末変換も指定します。ほとんどの基底コーディ
ングシステムには、`-unix'、`-dos'、`-mac'を付加して作られる名前の対応す
る3つの変種があります。

コーディングシステム`raw-text'は文字コード変換を行わない特別なもので、こ
のコーディングシステムで訪問したバッファはユニバイトバッファになります。
行末変換も指定しないので内容に基づいて決定でき、行末変換を指定する3つの
変種もあります。`no-conversion'は`raw-text-unix'に等価であり、文字コード
も行末も変換しないことを指定します。

コーディングシステム`emacs-mule'は、Emacs内部での符号でデータを表現する
ことを指定します。これは、コード変換を行わないという意味では`raw-text'に
似ていますが、結果がマルチバイトデータになる点が異なります。

 -- Function: coding-system-get CODING-SYSTEM PROPERTY
     この関数は、コーディングシステムCODING-SYSTEMの指定した属性を返す。
     コーディングシステムのほとんどの属性は内部目的用であるが、読者が有
     用と思うものが1つ、`mime-charset'がある。この属性の値は、当該コーディ
     ングシステムで読み書きする文字コード向けのMIMEに使用する名前である。

          (coding-system-get 'iso-latin-1 'mime-charset)
               => iso-8859-1
          (coding-system-get 'iso-2022-cn 'mime-charset)
               => iso-2022-cn
          (coding-system-get 'cyrillic-koi8 'mime-charset)
               => koi8-r

     属性`mime-charset'の値は、コーディングシステムの別名としても定義さ
     れている。



File: elisp-ja.info, Node: Encoding and I/O, Next: Lisp and Coding Systems, Prev: Coding System Basics, Up: Coding Systems

符号化と入出力
--------------

コーディングシステムの主目的は、ファイルの読み書きに使うことです。関数
`insert-file-contents'はファイルのデータを復号化するためにコーディングシ
ステムを使い、`write-region'はバッファ内容を符号化するためにコーディング
システムを使います。

使用するコーディングシステムを明示する（*Note Specifying Coding
Systems::）こともできるし、デフォルトの機構（*Note Default Coding
Systems::）を暗に使うこともできます。しかし、これらの方式ではすべきこと
を完全に指定しきれないこともあります。たとえば、`undefined'のようなコー
ディングシステムを選んで、データに基づいて文字コード変換を行うようにする
かもしれません。そのような場合、コーディングシステムの選択は入出力操作に
よって完了します。しばしば、選択されたコーディングシステムをあとで知りた
くなります。

 -- Variable: buffer-file-coding-system
     この変数は、カレントバッファで訪問するときに使用したコーディングシ
     ステムを記録する。これは、バッファを保存したり、`write-region'でバッ
     ファの一部を書くときに使われる。これらの操作において、ユーザーに別
     のコーディングシステムを指定するように問い合わせた場合には、
     `buffer-file-coding-system'は指定された別のコーディングシステムに更
     新される。

 -- Variable: save-buffer-coding-system
     この変数は、`write-region'には使わないが、バッファを保存するために
     使うコーディングシステムを指定する。バッファを保存する際に、ユーザー
     に別のコーディングシステムを指定するように問い合わせ、かつ、
     `save-buffer-coding-system'を用いている場合には、これは指定された別
     のコーディングシステムに更新される。

 -- Variable: last-coding-system-used
     ファイルやサブプロセスに対する入出力操作では、使用したコーディング
     システム名をこの変数に設定する。明示的に符号化／復号化する関数
     （*Note Explicit Encoding::）もこの変数に設定する。

     *警告：*` ' サブプロセスから出力を受け取るとこの変数が設定されるた
     め、Emacsが待つたびに変化する可能性がある。したがって、読者の興味が
     ある値を保存するような関数を呼び出した直後にその値をコピーして使う
     こと。

変数`selection-coding-system'は、ウィンドウシステムのセレクションを符号
化する方法を指定します。*Note Window System Selections::。



File: elisp-ja.info, Node: Lisp and Coding Systems, Next: User-Chosen Coding Systems, Prev: Encoding and I/O, Up: Coding Systems

Lispにおけるコーディングシステム
--------------------------------

コーディングシステムを扱うLispの機能について述べます。

 -- Function: coding-system-list &optional BASE-ONLY
     この関数は、すべてのコーディングシステム名（シンボル）のリストを返
     す。BASE-ONLYが`nil'以外であると、値には基底コーディングシステムの
     みを含める。さもなければ、値には変種コーディングシステムも含まれる。

 -- Function: coding-system-p OBJECT
     この関数は、OBJECTがコーディングシステム名であると`t'を返す。

 -- Function: check-coding-system CODING-SYSTEM
     この関数は、CODING-SYSTEMの正当性を調べる。正しいものならば
     CODING-SYSTEMを返す。さもなければ、条件`coding-system-error'付きの
     エラーを通知する。

 -- Function: coding-system-change-eol-conversion CODING-SYSTEM EOL-TYPE
     この関数は、CODING-SYSTEMに類似のコーディングシステムを返すが、
     `eol-type'で指定された行末変換のものである。EOL-TYPEは、`unix'、
     `dos'、`mac'、`nil'のいずれかであること。`nil'であると、返されたコー
     ディングシステムは、データから行末変換を決定する。

 -- Function: coding-system-change-text-conversion EOL-CODING TEXT-CODING
     この関数は、行末変換にEOL-CODINGを使い、テキストの変換にTEXT-CODING
     を使っているコーディングシステムを返す。TEXT-CODINGが`nil'であると、
     `undecided'かEOL-CODINGに応じた`undecided'の変種の1つを返す。

 -- Function: find-coding-systems-region FROM TO
     この関数は、FROMとTOのあいだのテキストの符号化に使用できるコーディ
     ングシステムのリストを返す。リスト内のすべてのコーディングシステム
     は、当該部分のテキストのどんなマルチバイト文字も安全に符号化できる。

     テキストにマルチバイト文字が含まれない場合、関数はリスト
     `(undecided)'を返す。

 -- Function: find-coding-systems-string STRING
     この関数は、文字列STRINGのテキストの符号化に使用できるコーディング
     システムのリストを返す。リスト内のすべてのコーディングシステムは、
     STRINGのどんなマルチバイト文字も安全に符号化できる。テキストにマル
     チバイト文字が含まれない場合、これはリスト`(undecided)'を返す。

 -- Function: find-coding-systems-for-charsets CHARSETS
     この関数は、リストCHARSETS内のすべての文字集合の符号化に使用できる
     コーディングシステムのリストを返す。

 -- Function: detect-coding-region START END &optional HIGHEST
     この関数は、STARTからENDまでのテキストを復号化するもっともらしいコー
     ディングシステムを選ぶ。このテキストは『生のバイト』（*Note
     Explicit Encoding::）であること。

     この関数は、通常、走査したテキストの復号化を扱えるコーディングシス
     テムのリストを返す。それらは優先順位の降順に並ぶ。しかし、HIGHESTが
     `nil'以外であると、戻り値はもっとも順位の高い1つのコーディングシス
     テムである。

     領域にASCII文字だけが含まれる場合、値は`undecided'か`(undecided)'で
     ある。

 -- Function: detect-coding-string STRING HIGHEST
     この関数は`detect-coding-region'と同様であるが、バッファ内のバイト
     のかわりに文字列STRINGの内容に作用する。

サブプロセスとの入出力に使用されるコーディングシステムを調べたり設定する
方法については、*Note Process Information::。



File: elisp-ja.info, Node: User-Chosen Coding Systems, Next: Default Coding Systems, Prev: Lisp and Coding Systems, Up: Coding Systems

ユーザー指定のコーディングシステム
----------------------------------

 -- Function: select-safe-coding-system FROM TO &optional PREFERRED-CODING-SYSTEM
     この関数はFROMとTOのあいだのテキストを符号化するコーディングシステ
     ムを選ぶが、必要ならばユーザーに問い合わせる。

     省略可能な引数PREFERRED-CODING-SYSTEMは、最初に試すコーディングシス
     テムを指定する。それが指定領域のテキストを処理できるならば、それを
     使う。この引数を省略すると、`buffer-file-coding-system'のカレントバッ
     ファでの値をまず試す。

     領域内にPREFERRED-CODING-SYSTEMで符号化できないマルチバイト文字があ
     る場合、この関数は、当該テキストを符号化可能なコーディングシステム
     一覧からユーザーに選択してもらい、ユーザーが選択したものを返す。

     特殊機能：` 'FROMが文字列であると、文字列を調べる対象とし、TOは無視
     する。

補完を用いてユーザーにコーディングシステムを指定させるために使える2つの
関数はつぎのとおりです。*Note Completion::。

 -- Function: read-coding-system PROMPT &optional DEFAULT
     この関数は、文字列PROMPTをプロンプトとしてミニバッファを使ってコー
     ディングシステムを読み取り、コーディングシステム名をシンボルとして
     返す。ユーザーの入力が空であると、DEFAULTは返すべきコーディングシス
     テムを指定する。それはシンボルか文字列であること。

 -- Function: read-non-nil-coding-system PROMPT
     この関数は、文字列PROMPTをプロンプトとしてミニバッファを使ってコー
     ディングシステムを読み取り、コーディングシステム名をシンボルとして
     返す。ユーザーが空を入力しようとすると再度問い合わせる。*Note
     Coding Systems::。



File: elisp-ja.info, Node: Default Coding Systems, Next: Specifying Coding Systems, Prev: User-Chosen Coding Systems, Up: Coding Systems

デフォルトのコーディングシステム
--------------------------------

本節では、特定のファイルや特定のサブプログラムを実行するときのデフォルト
のコーディングシステムを指定する変数と、それらを使った入出力操作を行う関
数について述べます。

これらの変数の目的は、読者が望むデフォルトをいったんこれらに設定しておけ
ば、再度変更する必要がないようにすることです。Lispプログラムの特定の操作
向けに特定のコーディングシステムを指定するには、これらの変数を変更しない
でください。かわりに、`coding-system-for-read'や
`coding-system-for-write'を使って上書きします（*Note Specifying Coding
Systems::）。

 -- Variable: file-coding-system-alist
     この変数は、特定のファイルの読み書きに使用するコーディングシステム
     を指定する連想リストである。各要素は`(PATTERN . CODING)'の形であり、
     PATTERNは特定のファイル名に一致する正規表現である。PATTERNに一致す
     るファイル名に当該要素を適用する。

     要素のCDR、CODINGはコーディングシステムであるか、2つのコーディング
     システムを収めたコンスセルであるか、関数シンボルであること。CODING
     がコーディングシステムであると、ファイルの読み書きの両方にそのコー
     ディングシステムを使う。CODINGが2つのコーディングシステムを収めたコ
     ンスセルであると、そのCARは復号化に使うコーディングシステムを指定し、
     そのCDRは符号化に使うコーディングシステムを指定する。

     CODINGが関数シンボルであると、その関数は、コーディングシステムか、2
     つのコーディングシステムを収めたコンスセルを返すこと。その値は上に
     述べたように使われる。

 -- Variable: process-coding-system-alist
     この変数は、サブプロセスで実行しているプログラムに依存してサブプロ
     セスに使うコーディングシステムを指定する連想リストである。
     `file-coding-system-alist'と同様に働くが、PATTERNはサブプロセスを始
     めるために用いたプログラム名に対して一致を取る点が異なる。この連想
     リストに指定したコーディングシステムは、サブプロセスとの入出力に使
     用するコーディングシステムの初期化に用いれるが、
     `set-process-coding-system'を使って、あとで別のコーディングシステム
     を指定できる。

*警告：*` ' データからコーディングシステムを決定する`undecided'のような
コーディングシステムは、非同期サブプロセスの出力に対しては完全に信頼性の
ある動作はできない。これは、Emacsが非同期サブプロセスの出力が到着するた
びに一塊で処理するからである。コーディングシステムが文字コード変換や行末
変換を未指定にしていると、Emacsは1つの塊から正しい変換を検出しようと試み
るが、これがつねに動作するとは限らない。

したがって、非同期サブプロセスでは、可能な限り文字コード変換と行末変換の
両方を指定したコーディングシステムを使います。つまり、`undecided'や
`latin-1'などではなく、`latin-1-unix'のようなものを使います。

 -- Variable: network-coding-system-alist
     この変数は、ネットワークストリームに使用するコーディングシステムを
     指定する連想リストである。`file-coding-system-alist'と同様に働くが、
     要素内のPATTERNはポート番号か正規表現である点が異なる。それが正規表
     現であると、ネットワークストリームを開くために使用したネットワーク
     サービス名に対して一致をとる。

 -- Variable: default-process-coding-system
     この変数は、なにも指定されていないサブプロセス（やネットワークスト
     リーム）の入出力に使用するコーディングシステムを指定する。

     値は、`(INPUT-CODING . OUTPUT-CODING)'の形のコンスセルであること。
     ここで、INPUT-CODINGはサブプロセスからの入力に適用され、
     OUTPUT-CODINGはそれへの出力に適用される。

 -- Function: find-operation-coding-system OPERATION &rest ARGUMENTS
     この関数は、ARGUMENTSを指定してOPERATIONを行うときに（デフォルトで）
     使用されるコーディングシステムを返す。その値はつぎの形である。

          (DECODING-SYSTEM ENCODING-SYSTEM)

     第1要素DECODING-SYSTEMは（OPERATIONが復号化を行う場合には）復号化に
     用いるコーディングシステムであり、ENCODING-SYSTEMは（OPERATIONが符
     号化を行う場合には）符号化に用いるコーディングシステムである。

     引数OPERATIONは、Emacsの入出力基本関数の`insert-file-contents'、
     `write-region'、`call-process'、`call-process-region'、
     `start-process'、`open-network-stream'のいずれかであること。

     残りの引数は、これらの入出力基本関数に指定するであろう引数と同じで
     あること。基本関数に依存して、引数の1つを"対象"として選ぶ。たとえば、
     OPERATIONがファイル入出力を行う場合、ファイル名を指定する引数が対象
     である。サブプロセスの基本関数では、プロセス名が対象である。
     `open-network-stream'では、サービス名やポート番号が対象である。

     この関数は、OPERATIONに応じて当該対象を`file-coding-system-alist'や
     `process-coding-system-alist'や`network-coding-system-alist'で探す。
     *Note Default Coding Systems::。



File: elisp-ja.info, Node: Specifying Coding Systems, Next: Explicit Encoding, Prev: Default Coding Systems, Up: Coding Systems

1つの操作向けにコーディングシステムを指定する
---------------------------------------------

変数`coding-system-for-read'と／や`coding-system-for-write'を束縛するこ
とで、特定の1つの操作向けのコーディングシステムを指定できます。

 -- Variable: coding-system-for-read
     この変数が`nil'以外であると、ファイルを読むときや同期プロセスからの
     入力に用いるコーディングシステムを指定する。

     これは非同期プロセスやネットワークストリームにも適用されるが、異なっ
     た方法で適用される。サブプロセスを開始したりネットワークストリーム
     を開いたときの`coding-system-for-read'の値は、そのサブプロセスやネッ
     トワークストリームの入力の復号化方法を指定する。変更されない限り、
     そのサブプロセスやネットワークストリームに対して使われ続ける。

     この変数の正しい使い方は、特定の入出力操作に対して`let'で束縛するこ
     とである。そのグローバルな値は通常は`nil'であり、グローバルにこれ以
     外の値を設定するべきではない。この変数の正しい使い方の例をつぎに示
     す。

          ;; 文字コード変換せずにファイルから読む
          ;; CRLFが行末を表すと仮定する
          (let ((coding-system-for-write 'emacs-mule-dos))
            (insert-file-contents filename))

     その値が`nil'以外であると、`coding-system-for-read'は、
     `file-coding-system-alist'、`process-coding-system-alist'、
     `network-coding-system-alist'、を含めて入力に用いるコーディングシス
     テムの他のすべての指定方法に優先する。

 -- Variable: coding-system-for-write
     これは`coding-system-for-read'と同様に働くが、入力ではなく出力に適
     用される点が異なる。ファイル、サブプロセス、ネットワーク接続へ書く
     ことに影響する。

     `call-process-region'と`start-process'のように、1つの操作で入力と出
     力を行うときには、`coding-system-for-read'と
     `coding-system-for-write'の両方が影響する。

 -- Variable: inhibit-eol-conversion
     この変数が`nil'以外であると、コーディングシステムでなにが指定されて
     いようと行末変換を行わない。これは、Emacsの入出力とサブプロセスのす
     べての基本関数、明示的な符号化／復号化関数（*Note Explicit
     Encoding::）に適用される。



File: elisp-ja.info, Node: Explicit Encoding, Next: Terminal I/O Encoding, Prev: Specifying Coding Systems, Up: Coding Systems

明示的な符号化と復号化
----------------------

Emacsへ／からテキストを転送するすべての操作には、テキストを符号化したり
復号化するコーディングシステムを使う能力があります。本節に述べる関数を用
いてテキストを明示的に符号化したり復号化できます。

符号化の結果と復号化する入力は、通常のEmacsのテキストではありません。そ
れらは『生のバイト』、つまり、外部ファイルと同じ方法でテキストを表現する
バイト列です。バッファに生のバイトが収められている場合、
`set-buffer-multibyte'（*Note Selecting a Representation::）を用いてバッ
ファはユニバイト表現であると印を付けるのがもっとも自然ですが、これは必須
ではありません。バッファの内容が単に一時的に生のバイトであるときには、バッ
ファはマルチバイトのままにしておきます。バッファ内容を復号化すれば正しく
なります。

明示的に復号化するためにバッファに生のバイトを入れる普通の方法は、
`insert-file-contents-literally'（*Note Reading from Files::）でファイル
から読むか、`find-file-noselect'でファイルを訪問するときに引数RAWFILEに
`nil'以外を指定します。

テキストの明示的な符号化で得た結果である生のバイトを使う普通の方法は、ファ
イルやプロセスへそれらをコピーします。たとえば、`write-region'（*Note
Writing to Files::）でそれらを書くには、`coding-system-for-write'に
`no-conversion'を束縛して`write-region'の符号化を抑制します。

生のバイトには、正しいマルチバイト文字に余分なトレイリングコードが付いた
ように見える長すぎるバイト列が含まれる場合があります。ほとんどの目的には、
バッファや文字列のそのような列をEmacsは1文字として扱い、その文字コードを
調べるとマルチバイト文字の列に対応した値を得るはずです。余分なバイト列は
無視されます。このふるまいは透明性がよくありませんが、生のバイトはEmacs
の限定された場面でのみ使われ、実用上の問題は回避できます。

 -- Function: encode-coding-region START END CODING-SYSTEM
     この関数は、コーディングシステムCODING-SYSTEMに従ってSTARTからENDの
     テキストを符号化する。符号化結果はバッファ内のもとのテキストを置き
     換える。符号化結果は『生のバイト』であるが、マルチバイトであったバッ
     ファはマルチバイトのままである。

 -- Function: encode-coding-string STRING CODING-SYSTEM
     この関数は、コーディングシステムCODING-SYSTEMに従って文字列STRINGの
     テキストを符号化する。符号化したテキストを含む新たな文字列を返す。
     符号化結果は『生のバイト』のユニバイト文字列である。

 -- Function: decode-coding-region START END CODING-SYSTEM
     この関数は、コーディングシステムCODING-SYSTEMに従ってSTARTからENDの
     テキストを復号化する。復号化結果はバッファ内のもとのテキストを置き
     換える。明示的な復号化が有用であるためには、復号化前のテキストは
     『生のバイト』であること。

 -- Function: decode-coding-string STRING CODING-SYSTEM
     この関数は、コーディングシステムCODING-SYSTEMに従って文字列STRINGの
     テキストを復号化する。復号化したテキストを含む新たな文字列を返す。
     明示的な復号化が有用であるためには、復号化前のSTRINGの内容は『生の
     バイト』であること。



