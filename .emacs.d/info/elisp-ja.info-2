Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info  Node: Copying-Footnotes, Up: Copying

(1) 【注意】現在、このバージョン2の発行者(FSF)住所は、正式に新しい
住所の 
 　59 Temple Place, Suite 330, Boston, MA 02111-1307, USA

 に変わっている。

(2) 【注意】現在、このバージョン2の発行者(FSF)住所は、正式に新しい
住所の59 Temple Place, Suite 330, Boston, MA 02111-1307, USA に変わっ
ている。



File: elisp-ja.info, Node: Introduction, Next: Lisp Data Types, Prev: Copying, Up: Top

はじめに
********

GNU Emacsテキストエディタの大部分は、Emacs Lispと呼ばれるプログラム言語
で記述してあります。Emacs Lispで新たなコードを書いて、それをエディタの拡
張としてインストールできます。しかし、Emacs Lispは、単なる『拡張言語』で
はありません。それ自身、れっきとしたプログラム言語です。他のプログラム言
語でできることは、Emacs Lispでできます。

Emacs Lispは、エディタで使うために設計してあるため、ファイル、バッファ、
ディスプレイ、サブプロセスなどを扱う機能に加えて、テキストを走査し解析す
る特別な機能もあります。Emacs Lispは編集機構に密に組み込まれています。こ
のため、編集コマンドはLispプログラムからも呼び出せる関数ですし、カスタマ
イズのためのパラメータは普通のLisp変数です。

本書は、Emacs Lispを完全に記述することを目指しています。初心者向けの入門
には、Free Software Foundation刊、Bob Chassellの`An Introduction to
Emacs Lisp Programming' (1) (*Note Introduction-Footnotes::) をご覧くだ
さい。本書では、Emacsの操作を熟知しているものと仮定します。操作に関する
基本的な情報は、`The GNU Emacs Manual' (2) (*Note
Introduction-Footnotes::) を参照してください。

おおまかにいえば、始めのほうの章では、多くのプログラム言語に見られる機能
に相当するEmacs Lispの機能を説明し、あとのほうの章では、Emacs Lispに特有
の機能や編集に特化した機能を説明します。

本書は、2.5版です。

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgements::    The authors, editors, and sponsors of this manual.


File: elisp-ja.info  Node: Introduction-Footnotes, Up: Introduction

(1) 【訳注】日本語訳：『Emacs Lispプログラミング入門』、アスキー出版局、
ISBN 4-7561-1805-4

(2) 【訳注】日本語訳：『GNU Emacsマニュアル』、アスキー出版局、ISBN
4-7561-3002-X



File: elisp-ja.info, Node: Caveats, Next: Lisp History, Prev: Introduction, Up: Introduction

警告
====

本書は、数多くの草稿を重ねてきました。ほぼ完璧に近いはずですが、誤りは皆
無ではありません。ふれていない話題も少なからずあります。（大部分の個別の
モードのような）副次的と捉えている話題や、まだ執筆していない話題もありま
す。完全にはこれらに対処しきれませんので、意図的に省いたことがらもありま
す。たとえば、VMSにおける利用方法に関する情報です。

本書で取り上げたことがらに関しては、本書は完璧であるべきですから、例題や
記述内容から章や節の構成順序といったことまで、広く意見を求めています。混
乱を招くような記述や、本書でふれていないことがらを学ぶためにソースや実験
で調べる必要があるときには、本書を改訂すべきなのでしょう。そのときは、ぜ
ひ、教えてください。


本書を読むときには、訂正箇所をみつけたらすぐ送ってくださるようにお願いし
ます。1つの関数や一連の関数向けに、簡素で実用に即した例を思い付いたなら
ば、それを書き上げて、送ってください。章／節／関数の名前を適宜入れてくだ
さい。それから、どの版に対する意見かも書いてください。

意見や訂正は、下記へメイルしてください。

     bug-lisp-manual@gnu.org

ここに蓄積されたメイルは、誰かが改訂作業を始めるまでは、読み出しません。
改訂までに、数か月、ときには、数年経過することもあります。ですから、返事
がないと憤慨しないでください。あなたのメイルは、そのうち処理*されます*。
Emacs保守グループに迅速に連絡したい場合には、`bug-gnu-emacs@gnu.org'にメ
イルしてください。



File: elisp-ja.info, Node: Lisp History, Next: Conventions, Prev: Caveats, Up: Introduction

Lispの歴史
==========

Lisp（LISt Processing language、リスト処理言語）は、人工知能の研究向けに
1950年代末にMITで初めて開発されました。Lisp言語はとても強力なので、エディ
タコマンドを記述するなどの他の目的にも理想的なのです。

長年にわたって何ダースものLispが実装されており、それぞれが独自の特徴を有
しています。その多くは、1960年代のMITのMACプロジェクトで開発された
Maclispの影響を受けています。最終的には、Maclispの系統の実装者達は共同し
て、Common Lispと呼ばれるLispシステムの規格を開発しました。そうこうする
うちに、MITのGerry SussmanとGuy Steeleは、単純化してあるが非常に強力な
Schemeと呼ばれるLispの方言を開発しました。

GNU EmacsはMaclispの影響を強く受けていますが、Common Lispからの影響は少
ないです。Common Lispを知っている読者は、Common Lispとの多くの類似点に気
づかれるでしょう。しかしながら、Common Lispの多くの機能は、省いてあるか、
単純化してあります。これは、GNU Emacsが必要とするメモリ量を削減するため
です。ときには、劇的に単純化してあるために、Common Lispユーザーは混乱す
るかもしれません。GNU Emacs LispとCommon Lispとの相違点は、ことあるごと
に指摘するつもりです。Common Lispを知らない読者は、何も心配することはあ
りません。本書は自己完結しています。

`cl'ライブラリにより、Common Lispをかなりエミュレートできます。*Note
Common Lisp Extension: (cl)Top。

Emacs LispはSchemeの影響をまったく受けていません。しかし、GNUプロジェク
トには、Guileと呼ばれるSchemeの実装があります。拡張が必要なすべての新た
なGNUソフトウェアではGuileを使います。



File: elisp-ja.info, Node: Conventions, Next: Version Info, Prev: Lisp History, Up: Introduction

表記法
======

本節では、本書で用いる表記法を説明します。本節を読み飛ばして、あとで参照
してもかまいません。

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.



File: elisp-ja.info, Node: Some Terms, Next: nil and t, Prev: Conventions, Up: Conventions

用語
----

本書では、『Lispリーダ』および『Lispプリンタ』という言葉で、Lispオブジェ
クトのテキスト表現を実際のLispオブジェクトに変換するLisp内部のルーティン
群、および、逆の変換を行うルーティン群を指します。詳しくは、*Note
Printed Representation::。本書の読者を『プログラマ』と考えて『読者』と呼
びます。『ユーザー』とは作者自身を含めたLispプログラムを使う人のことです。

Lispコードの例は、`(list 1 2 3)'という形式で、このフォントで記します。メ
タな変数の名前や説明対象の関数に対する引数の名前は、FIRST-NUMBERという形
式で、このフォントで書きます。



File: elisp-ja.info, Node: nil and t, Next: Evaluation Notation, Prev: Some Terms, Up: Conventions

`nil'と`t'
----------

Lispでは、シンボル`nil'には3つの異なる意味があります。まず、`nil'という
名前のシンボルです。2つめは、真理値の偽（false）です。3つめは、空リスト、
つまり、要素数が0個のリストです。変数として使った場合、`nil'の値はつねに
`nil'です。

Lispリーダにとっては、`()'と`nil'は同一です。どちらも、同じオブジェクト、
シンボル`nil'を表します。シンボルを異なった書き方にするのは、完全に人間
向けです。`()'や`nil'をLispリーダが読み取ったあとでは、プログラマが実際
にどちらの表記を用いたかわかりません。

本書では、空リストを強調するときには`()'を使い、真理値の偽を強調するとき
には`nil'を使います。これは、Lispプログラムでも使うとよい慣習です。

     (cons 'foo ())                ; 空リストであることを強調する
     (not nil)                     ; 真理値の偽であることを強調する

真理値の真を必要とする場面では、`nil'以外の値は、真（true）であるとみな
します。しかし、真を表す望ましい書き方は`t'です。真を表す値が必要なとき、
適当な判断基準がない場合には`t'を使います。シンボル`t'の値はつねに`t'で
す。

Emacs Lispでは、`nil'と`t'は特別なシンボルであり、評価するとそれ自身にな
ります。そのため、これらをプログラム内で定数として使うとき、これらをクォー
トする必要はありません。これらの値を変更しようとすると、エラー
`setting-constant'になります。コロン（`:'）で始まる名前のシンボルも同様
です。*Note Constant Variables::。



File: elisp-ja.info, Node: Evaluation Notation, Next: Printing Notation, Prev: nil and t, Up: Conventions

評価の表記法
------------

評価可能なLisp式を"フォーム"（form、形式）と呼びます。フォームを評価する
と、Lispオブジェクトである結果を生じます。本書の例題では、これを`=>'で表
します。

     (car '(1 2))
          => 1

これは、『`(car '(1 2))'を評価すると1になる』と読みます。

フォームがマクロ呼び出しの場合には、Lispが評価すべき新たなフォームに展開
します。展開結果を`==>'で表します。展開したフォームの評価結果を示す場合
もあれば、示さない場合もあります。

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

あるフォームを説明するときに、同一の結果を生じる別のフォームを示すことが
あります。2つのまったく等価なフォームを`=='で表します。

     (make-sparse-keymap) == (list 'keymap)



File: elisp-ja.info, Node: Printing Notation, Next: Error Messages, Prev: Evaluation Notation, Up: Conventions

結果表示の表記法
----------------

本書の数多くの例題は、評価するとテキストを表示します。（`*scratch*'バッ
ファのような）Lisp対話バッファで例題のコードを実行すると、表示テキストは
バッファに挿入されます。（関数`eval-region'で評価するなどの）別の手段で
例題を実行すると、表示テキストはエコー領域に表示されます。エコー領域に表
示されるテキストは、1行に切り詰められていることに注意してください。

本書の例題では、表示場所には無関係に、表示テキストを`-|'で表します。フォー
ムを評価した結果返される値（ここでは`bar'）は、後続の行に分けて書きます。

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar



File: elisp-ja.info, Node: Error Messages, Next: Buffer Text Notation, Prev: Printing Notation, Up: Conventions

エラーメッセージ
----------------

エラーを通知する例題もあります。これは、通常、エコー領域にエラーメッセー
ジを表示します。エラーメッセージは、`error-->'で始まる行に示します。エコー
領域には、`error-->'は表示されないことに注意してください。

     (+ 23 'x)
     error--> Wrong type argument: number-or-marker-p, x



File: elisp-ja.info, Node: Buffer Text Notation, Next: Format of Descriptions, Prev: Error Messages, Up: Conventions

バッファ内のテキストの表記法
----------------------------

バッファ内のテキストを修正する例題もあります。このような場合、『実行前』
と『実行後』のテキストを示します。それらの例題では、バッファ名を含めたダッ
シュから成る2行で挟んで、当該バッファの内容を示します。さらに、ポイント
位置を`-!-'で表します。（もちろん、ポイントを表す記号は、バッファ内のテ
キストの一部ではない。現在ポイントが位置する2つの文字の*あいだ*を表す。）

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------



File: elisp-ja.info, Node: Format of Descriptions, Prev: Buffer Text Notation, Up: Conventions

記述形式
--------

関数、変数、マクロ、コマンド、ユーザーオプション、スペシャルフォームは、
本書では統一した形式で記述します。第1行目は、それぞれの名前と、引数があ
れば引数群です。関数、変数、マクロ、コマンド、ユーザーオプションの分類を
行頭に書きます。これに説明文が続き、場合によっては例題も示します。

* Menu:

* A Sample Function Description::       A description of an imaginary
                                          function, `foo'.
* A Sample Variable Description::       A description of an imaginary
                                          variable,
                                          `electric-future-map'.  



File: elisp-ja.info, Node: A Sample Function Description, Next: A Sample Variable Description, Prev: Format of Descriptions, Up: Format of Descriptions

関数の記述例
............

関数の記述では、まず始めに説明対象の関数名があります。同じ行には、引数名
の並びも続きます。これらの名前は、説明文の中で引数の値を参照するために使
います。

引数ならびにキーワード`&optional'が現れていれば、それ以降の引数を省略で
きることを示します（省略した引数の値は`nil'）。関数を呼び出すときに
`&optional'を書いてはいけません。

キーワード`&rest' （このあとには1つの引数名だけが続く）は、残りの引数が
何個でもよいことを示します。直後にある1つの引数名は、変数としての値を持
ち、その値は残りのすべての引数のリストです。関数を呼び出すときに`&rest'
を書いてはいけません。

では、仮想的な関数`foo'の記述を以下に示します。

 -- Function: foo INTEGER1 &optional INTEGER2 &rest INTEGERS
     関数`foo'は、INTEGER2からINTEGER1を引き算し、残りのすべての引数を減
     算結果に加える。INTEGER2を指定しないと、デフォルトでは、数19から引
     き算する。

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     より一般的には、つぎのとおり。

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

（INTEGER、INTEGER1、BUFFERなどの）型名を名前とする引数は、その型の値で
あると仮定します。（BUFFERSのように）型を複数形にした場合には、しばしば、
その型のオブジェクトのリストを意味します。OBJECTという名前の引数は、任意
の型でかまいません。（Emacsオブジェクトの型の一覧については、*Note Lisp
Data Types::）。（NEW-FILEなどの）その他の名前の引数は、関数の説明文の中
で言及します。複数の関数の引数に共通する特徴について、節の始めで説明する
場合もあります。

`&optional'と`&rest'についての詳しい説明は、*Note Lambda Expressions::。

コマンド、マクロ、スペシャルフォームの記述も同じ形式ですが、「関数」のか
わりに「コマンド」、「マクロ」、「スペシャルフォーム」のいずれかです。コ
マンドは、対話的に呼び出せる単なる関数です。マクロは関数とは違った方法で
引数を処理します（引数を評価しない）が、同じ方法で引数を記します。

スペシャルフォームの記述では、省略可能な引数や繰り返される引数を示すため
に、より複雑な記法を使います。というのは、引数並びを個々の引数に分離する
方法が複雑だからです。`[OPTIONAL-ARG]'は、OPTIONAL-ARGが省略可能であるこ
とを示します。また、`REPEATED-ARGS...'は、0個以上の引数を示します。いく
つかの引数をリスト構造の内側にまとめるときには、括弧を使います。

 -- Special form: count-loop (VAR [FROM TO [INC]]) BODY...
     この仮想的なスペシャルフォームは、フォーム群BODYを実行してから変数
     VARを増やすことを反復するループを実現する。最初は、変数の値はFROMで
     ある。以降の反復では、変数を1（あるいは、指定があればINCだけ）増や
     す。VARがTOに等しくなると、BODYを実行せずにループから抜ける。例を示
     す。

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     FROMとTOを省略すると、ループ開始前にVARに`nil'を束縛し、各反復の開
     始時にVARが`nil'以外であるとループから抜け出る。

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     このスペシャルフォームでは、引数FROMとTOは省略できるが、両者を同時
     に指定するか、同時に省略すること。これらを指定した場合、INCを指定し
     てもよい。これらの引数は、引数VARとともにリストにまとめる。これは
     BODYと区別するためであり、BODYは残りのフォームの要素すべてを含む。



File: elisp-ja.info, Node: A Sample Variable Description, Prev: A Sample Function Description, Up: Format of Descriptions

変数の記述例
............

"変数"（variable）は、値を保持するための名前です。ユーザーはどんな変数で
も設定できますが、ユーザーが変更可能な特定の変数群があり、それらを"ユー
ザーオプション"（user options）と呼びます。普通の変数もユーザーオプショ
ンも関数の記述と同じ形式で示しますが、それらに引数はありません。

仮想的な変数`electric-future-map'の記述例を示します。

 -- Variable: electric-future-map
     この変数の値は、Electric Command Futureモードで使用する完全なキーマッ
     プである。このマップに含まれる関数は、まだ実行していないコマンドの
     編集を可能にする。

ユーザーオプションの記述も同じ形式ですが、「変数」のかわりに「ユーザーオ
プション」です。



File: elisp-ja.info, Node: Version Info, Next: Acknowledgements, Prev: Conventions, Up: Introduction

版情報
======

これらの機構は、使用中のEmacsの版に関する情報を提供します。

 -- コマンド: emacs-version
     この関数は、実行中のEmacsの版を記述した文字列を返す。この文字列はバ
     グの報告に含めると有益である。

          (emacs-version)
            => "GNU Emacs 20.3.5 (i486-pc-linux-gnulibc1, X toolkit)
           of Sat Feb 14 1998 on psilocin.gnu.org"

     対話的に呼び出すと、この関数は同じ情報をエコー領域に表示する。

 -- Variable: emacs-build-time
     この変数の値は、ローカルのサイトでEmacsを構築した日時を示す。3つの
     整数から成るリストであり、`current-time'と同様のもの（*Note Time of
     Day::）。

          emacs-build-time
               => (13623 62065 344633)

 -- Variable: emacs-version
     この変数の値は、実行中のEmacsの版番号。`"20.3.1"'のような文字列であ
     る。この文字列の最後の数字は、Emacsのリリース版番号の一部ではなく、
     特定のディレクトリでEmacsを構築するたびに増える。

つぎの2つの変数は、Emacs 19.23以降に存在します。

 -- Variable: emacs-major-version
     Emacsのメジャー版番号を表す整数。Emacs 20.3では、値は20。

 -- Variable: emacs-minor-version
     Emacsのマイナ版番号を表す整数。Emacs 20.3では、値は3。



File: elisp-ja.info, Node: Acknowledgements, Prev: Version Info, Up: Introduction

謝辞
====

本書は、Robert Krawitz、Bil Lewis、Dan LaLiberte、Richard M. Stallman、
Chris Welty、GNUマニュアルプロジェクトのボランティアによる何年にもわたる
努力で執筆されました。Computational Logic社のWarren A. Hunt, Jr.が手配し
た国防省Advanced Research Projects Agency、ARPA Order 6082の援助のもと、
Robert J. Chassellは本書のレビューと編集に協力してくれました。

以下の方々が訂正を送ってくれました。Karl Berry、Jim Blandy、Bard Bloom、
Stephane Boucher、David Boyes、Alan Carroll、Richard Davis、Lawrence
R. Dodd、Peter Doornbosch、David A. Duff、Chris Eich、Beverly Erlebacher、
David Eckelkamp、Ralf Fassel、Eirik Fuller、Stephen Gildea、Bob
Glickstein、Eric Hanchrow、George Hartzell、Nathan Hess、Masayuki Ida、
Dan Jacobson、Jak Kirman、Bob Knighten、Frederick M. Korz、Joe Lammens、
Glenn M. Lewis、K. Richard Magill、Brian Marick、Roland McGrath、Skip
Montanaro、John Gardiner Myers、Thomas A. Peterson、Francesco Potorti、
Friedrich Pukelsheim、Arnold D. Robbins、Raul Rockwell、Per Starback、
Shinichirou Sugou、Kimmo Suominen、Edward Tharp、Bill Trost、Rickard
Westman、Jean White、Matthew Wilding、Carl Witty、Dale Worley、Rusty
Wright、David D. Zuhn。


File: elisp-ja.info, Node: Lisp Data Types, Next: Numbers, Prev: Introduction, Up: Top

Lispのデータ型
**************

Lisp"オブジェクト"（object）とは、Lispプログラムが使用し操作するデータの
ことです。"型"（type）や"データ型"（data type）とは、ここでは、可能なオ
ブジェクトの集合を意味します。

各オブジェクトは、少なくとも、1つの型に属します。同じ型のオブジェクトは、
構造に類似性があり、普通、同じ文脈で使われます。型は互いに重複していても
よく、オブジェクトは複数の型に属することができます。そのため、オブジェク
トが特定の型に属するかどうかは判断できますが、オブジェクトの型を『1つ』
に限定することはできません。

Emacsには少数の基本オブジェクト型を組み込んであります。これらの型は他の
すべてのオブジェクト型を構成するもとであり、"基本型"（primitive types）
と呼びます。各オブジェクトはたった1つの基本型に属します。基本型には、"整
数"（integer）、"浮動小数点数"（float）、"コンス"（cons）、"シンボル"
（symbol）、"文字列"（string）、"ベクトル"（vector）、"subr"、"バイトコー
ド関数"（byte-code function）、ならびに、編集に関連する"バッファ"
（buffer）などの特別な型があります。（*Note Editing Types::。）

各基本型には、その型に属するオブジェクトであるかどうかを検査する対応する
Lisp関数があります。

Lispオブジェクトは"型を自己記述"（self-typing）するという点で、Lispは他
の多くの言語とは異なります。つまり、オブジェクトの基本型は、オブジェクト
自体に暗に含まれています。たとえば、オブジェクトがベクトルであれば、それ
を数と扱うことはありません。Lispには、ベクトルは数ではないとわかっている
のです。

多くの言語では、プログラマは各変数のデータ型を宣言する必要があります。型
はコンパイラが知っているのであって、データの中には入っていません。このよ
うな型宣言はEmacs Lispには存在しません。Lisp変数はどんな型の値でも保持で
き、変数に入れた値と型を記録しています。

本章では、GNU Emacs Lispの各標準型の表示表現と入力構文を説明します。これ
らの型の使用方法の詳細は、あとの章に譲ります。

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.



File: elisp-ja.info, Node: Printed Representation, Next: Comments, Prev: Lisp Data Types, Up: Lisp Data Types

表示表現と入力構文
==================

オブジェクトの"表示表現"（printed representation）とは、Lispプリンタ（関
数`prin1'）がそのオブジェクトを出力表示するときの書式です。オブジェクト
の"入力構文"（read syntax）とは、Lispリーダ（関数`read'）がそのオブジェ
クトを入力として受理する書式です。*Note Read and Print::。

ほとんどのオブジェクトには1つ以上の可能な入力構文があります。ある種の型
のオブジェクトには入力構文はありませんが、そのような型のオブジェクトを
Lispプログラムに直接入力する意味がないからです。このような場合を除くと、
オブジェクトの表示表現はそのオブジェクトの入力構文でもあります。

他の言語では、式はテキストであって、これ以外の形はありません。Lispでは、
式はとにかくLispオブジェクトであって、オブジェクトの入力構文であるテキス
トは副次的なものです。この違いを強調する必要はありませんが、このことを心
に留めておかないと混乱することがあります。

各型には表示表現があります。入力構文のない型もあります。たとえば、バッファ
型には入力構文はありません。このような型のオブジェクトは"ハッシュ記法"
（hash notation）で表示します。つまり、文字列`#<'のあとに説明用の文字列
（典型的には型名にオブジェクトの名前を続けたもの）を続け、対応する`>'で
閉じます。ハッシュ記法を読み取ることはできませんから、Lispリーダが`#<'に
出会うとエラー`invalid-read-syntax'を通知します。

     (current-buffer)
          => #<buffer objects.texi>

読者が対話的に式を評価するとき、Lispインタープリタは、まず、式のテキスト
表現を読み取ってLispオブジェクトを生成し、そのオブジェクトを評価します
（*Note Evaluation::）。しかしながら、評価と読み取りは別々の動作です。読
み取りでは、読み取ったテキストが表すLispオブジェクトを返します。このオブ
ジェクトを、のちに評価する場合もありますが、評価しない場合もあります。オ
ブジェクトを読み取る基本関数`read'については、*Note Input Functions::。



File: elisp-ja.info, Node: Comments, Next: Programming Types, Prev: Printed Representation, Up: Lisp Data Types

コメント
========

"コメント"（comment）は、プログラム内に書かれたテキストであり、プログラ
ムを読む人間のためだけにあり、プログラムの意味にはまったく影響しません。
Lispでは、文字列や文字定数の外にあるセミコロン（`;'）でコメントを始めま
す。コメントは行末までです。Lispリーダは、コメントを破棄します。コメント
は、Lispシステム内部でプログラムを表すLispオブジェクトの一部にはなりませ
ん。

`#@COUNT'という書き方は、後続のCOUNT個の文字を飛び越します。これは、プロ
グラムで生成したバイナリデータを含むコメントに便利です。Emacs Lispのバイ
トコンパイラは、出力ファイルにこのようなコメントを使います（*Note Byte
Compilation::）。しかしながら、ソースファイル向きではありません。

コメントの体裁に関する慣習については、*Note Comment Tips::。



File: elisp-ja.info, Node: Programming Types, Next: Editing Types, Prev: Comments, Up: Lisp Data Types

プログラミング向けの型
======================

Emacs Lispには、大きく2種類の型があります。Lispのプログラミングに関わる
ものと、編集に関わるものです。前者は、さまざまな形でLispの多くの実装に見
られます。後者は、Emacs Lispに固有です。

* Menu:

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of `t' or `nil'.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.



File: elisp-ja.info, Node: Integer Type, Next: Floating Point Type, Prev: Programming Types, Up: Programming Types

整数型
------

Emacs Lispにおける整数の値の範囲は、ほとんどの計算機では、
-134217728から134217727（28ビット長。つまり
-2**27
から2**27 - 1）です。（計算機によっては、より広い範囲になる。）Emacs
Lispの算術演算関数は、桁溢れ（オーバフロー）を検査しないことを覚えておい
てください。したがって、ほとんどの計算機では、`(1+ 134217727)'は-
134217728となります。

整数の入力構文は、（10を基数とした）数字の並びであり、先頭に符号があって
もよく、また、最後にピリオドがあってもかまいません。Lispインタープリタが
生成する表示表現では、先頭の`+'や最後の`.'はありません。

     -1               ; 整数 -1
     1                ; 整数 1
     1.               ; これも整数 1
     +1               ; これも整数 1
     268435457        ; 28ビット長整数では、これも整数 1

より詳しくは、*Note Numbers::。



File: elisp-ja.info, Node: Floating Point Type, Next: Character Type, Prev: Integer Type, Up: Programming Types

浮動小数点数
------------

Emacsは浮動小数点数を扱えます（ただし、コンパイル時のオプションで使用不
可にできる）。浮動小数点数の範囲は、計算機に依存します。

浮動小数点数の表示表現には、小数点（に続けて1桁以上の小数部分）または指
数、あるいは、その両方が必要です。たとえば、`1500.0'、`15e2'、`15.0e2'、
`1.5e3'、`.15e4'は、同じ1500という値の浮動小数点数を書く5つの方法です。
どれも、まったく等価です。

詳しくは、*Note Numbers::。



File: elisp-ja.info, Node: Character Type, Next: Symbol Type, Prev: Floating Point Type, Up: Programming Types

文字型
------

Emacs Lispにおける"文字"（character）は、
整数以外の何物でもありません。
いいかえれば、文字はその文字コードで表現されます。
たとえば、文字`A'は整数 65と表現されます。

プログラムで個々の文字を独立に使うことはあまりありません。文字を並べた*
文字列*（strings）として扱うことが断然多いのです。*Note String Type::。

文字列内、バッファ内、ファイル内の文字は、現時点では、0から524287までの
範囲、19ビット長に制限されます。しかし、この範囲の値すべてが正しい文字コー
ドではありません。0から127までのコードはASCIIコードです。それ以外は、非
ASCIIです（*Note Non-ASCII Characters::）。キーボード入力を表す文字は、
コントロール、メタ、シフトなどの修飾キーを符号化するために、範囲がより広
くなります。

文字は、実際には整数ですから、文字の表示表現は10進数です。また、文字の入
力構文として10進数も可能ですが、Lispプログラムでこのように文字を書くのは
最悪です。Emacs Lispに用意してある文字向けの特別な入力構文を*つねに*使う
べきです。これらの構文は疑問符で始まります。

英数字向けの普通の入力構文は、疑問符に続けて1つの英数字を書きます。した
がって、文字`A'は`?A'、文字`B'は`?B'、文字`a'は`?a'と書きます。

たとえば、つぎのとおりです。

     ?Q => 81     ?q => 113

同じ入力構文を句読点文字にも使えますが、`\'を追加して、Lispコードを編集
するEmacsコマンドが混乱しないようにすることがよいでしょう。たとえば、空
白文字は`?\ 'と書きます。文字`\'は、クォートするために2つめの`\'を使う*
必要があり* `?\\'です。

コントロールg、バックスペース、タブ、改行、垂直タブ、ページ送り、復帰、
エスケープは、それぞれ、`?\a'、`?\b'、`?\t'、`?\n'、`?\v'、`?\f'、`?\r'、
`?\e'と書きます。つまり、つぎのとおりです。

     ?\a => 7                 ; C-g
     ?\b => 8                 ; バックスペース、 BS、C-h
     ?\t => 9                 ; タブ、 TAB、C-i
     ?\n => 10                ; 改行、C-j
     ?\v => 11                ; 垂直タブ、C-k
     ?\f => 12                ; ページ送り文字、C-l
     ?\r => 13                ; 復帰、RET, C-m
     ?\e => 27                ; エスケープ文字、ESC、C-[
     ?\\ => 92                ; バックスラッシュ文字、\

バックスラッシュで始まる系列は"エスケープシーケンス"（escape sequences）
とも呼びます。バックスラッシュが、エスケープ文字の役割を果たすからです。
この使い方は、文字ESCとは関係ありません。

コントロール文字は別の入力構文でも表現できます。疑問符に続けてバックスラッ
シュ、カレット（`^'）、そして、対応するコントロールでない文字を大文字か
小文字で書きます。たとえば、`?\^I'も`?\^i'も、値が9である文字`C-i'の正し
い入力構文です。

カレットのかわりに、`C-'を使ってもかまいません。ですから、`?\C-i'は、
`?\^I'や`?\^i'と等価です。

     ?\^I => 9     ?\C-I => 9

文字列やバッファ内ではASCIIのコントロール文字だけが許されますが、キーボー
ド入力においては`C-'で任意の文字をコントロール文字にできます。これらの非
ASCIIコントロール文字の文字コードは、対応する非コントロール文字の文字コー
ドと2**26 のビットを含みます。普通の端末では、非ASCIIコントロール文字を
生成する手立てはありませんが、Xウィンドウシステムや他のウィンドウシステ
ムでは、簡単に生成できます。

歴史的な理由で、EmacsはDEL文字を`?'に対応したコントロール文字として扱い
ます。

     ?\^? => 127     ?\C-? => 127

その結果、今のところ、Xウィンドウシステムのもとでは意味のある文字
`Control-?'を`\C-'では表現できません。

ファイルや文字列に現れるコントロール文字を表現するには、`^'構文を勧めま
す。キーボード入力のコントロール文字には、`C-'構文が好ましいです。どちら
を使ってもプログラムの意味には影響しませんが、それを読む人には理解の手助
けになるかもしれません。

"メタ文字"（meta character）は、META修飾キーを使って打った文字です。その
ような文字を表す整数は、（ほとんどの計算機では負の数になる）2**27 のビッ
トがセットされています。上位のビットをメタや他の修飾子に用いることで、基
本となる文字コードの範囲をできるだけ大きくします。

文字列では、メタ文字を表すASCII文字には2**7 のビットを付加します。つまり、
文字列に収められるメタ文字のコードは128から255の範囲であり、任意のASCII
文字のメタ変種を使えます。（Emacs 18やそれ以前では、この方式を文字列の外
にある文字にも使っていた。）

メタ文字の入力構文には`\M-'を使います。たとえば、`?\M-A'は`M-A'です。
`\M-'と一緒に8進文字コードも使えますし（下記参照）、`\C-'や文字向けの他
の構文も使えます。したがって、`M-A'は`?\M-A'と書いたり`?\M-\101'と書けま
す。同様に、`C-M-b'は`?\M-\C-b'、`?\C-\M-b'、`?\M-\002'と書けます。

図形文字の大文字小文字は、その文字コードで示されます。たとえば、ASCIIで
は`a'と`A'の文字を区別します。しかし、ASCIIではコントロール文字の大文字
小文字を表現できません。Emacsでは、コントロール文字を打つときに使ったシ
フトキーを表すために2**25 のビットを付加します。このような区別はX端末や
他の特別な端末を使っている場合に限り可能です。普通の端末ではこのような区
別を計算機に送れません。

Xウィンドウシステムでは、文字に設定可能な修飾ビットが他に3つあります。" 
ハイパー"（hyper）、"スーパー"（super）、"アルト"（alt）です。これらの修
飾ビットの構文は、`\H-'、`\s-'、`\A-'です。（これらのプレフィックスでは、
大文字小文字を区別する。）したがって、`?\H-\M-\A-x'は`Alt-Hyper-Meta-x' 
を表します。数値的には、アルトは2**22、スーパーは2**23、ハイパーは2**24
のビット値です。

文字向けのもっとも汎用の入力構文では、文字コードを8進数や16進数で表現し
ます。8進数を使うには、順に、疑問符、バックスラッシュ、（3桁までの）8進
数字文字コードを書きます。たとえば、`?\101'は文字`A'を表し、`?\001'は文
字`C-a'を表し、`?\002'は文字`C-b'を表します。この構文で任意のASCII文字を
表現できますが、ASCIIでの表現よりも8進数値で表現することが重要な場合に限
るべきです。

     ?\012 => 10         ?\n => 10         ?\C-j => 10
     ?\101 => 65         ?A => 65

16進数を使うには、順に、疑問符、バックスラッシュ、`x'、16進数字文字コー
ドを書きます。16進数の桁数はいくつでもよいので、任意の文字コードを表現で
きます。したがって、`?\x41'は文字`A'を表し、`?\x1'は文字`C-a'を表し、
`?\x8e0'はグレーブアクセント付きの文字`a'を表します。

特別なエスケープの意味を持たないどんな文字のまえにもバックスラッシュを付
けることができ、しかも、無害です。したがって、`?\+'は`?+'に等価です。ほ
とんどの文字のまえにバックスラッシュを付ける理由はありません。しかしなが
ら、Lispコードを編集するEmacsコマンドが混乱しないように、`()\|;'`"#.,'の
いずれかの文字のまえにはバックスラッシュを付けるべきです。空白、タブ、改
行、ページ送りのような白文字のまえにもバックスラッシュを付けるべきです。
しかしながら、タブなどの実際の白文字のかわりに、`\t'などの読みやすいエス
ケープシーケンスを使ったほうが明確です。



File: elisp-ja.info, Node: Symbol Type, Next: Sequence Type, Prev: Character Type, Up: Programming Types

シンボル型
----------

GNU Emacs Lispにおける"シンボル"（symbol）は、名前を持ったオブジェクトで
す。シンボル名は、シンボルの表示表現としての役割があります。普通の使い方
では、名前は一意です。つまり、2つのシンボルが同じ名前を持つことはありま
せん。

シンボルは、変数としての役割、関数名としての役割、あるいは、属性リストを
保持する役割を果たします。また、他のすべてのLispオブジェクトと区別するた
めだけの役割を果たすこともあり、データ構造の内部にそのようなシンボルが存
在することを正確に認識できます。ある場面においては、普通、これらのうちの
1つの使い方をします。しかし、ある1つのシンボルに対してすべての使い方をし
てもかまいません。

シンボル名には、どんな文字でも含められます。ほとんどのシンボル名は、英文
字、数字、`-+=*/'の句読点文字で書かれます。そのような名前では、特別な書
き方は必要ありません。名前が数に見えなければ、名前を構成する文字はなんで
もよいのです。（名前が数に見えるときには、名前の先頭に`\'を書いてシンボ
ルであると強制する。）`_~!@$%^&:<>{}'の文字はあまり使われませんが、これ
らにも特別な書き方は必要ありません。これら以外の文字は、バックスラッシュ
でエスケープすれば、シンボル名に含められます。文字列におけるバックスラッ
シュの用法とは対照的に、シンボル名におけるバックスラッシュは、直後の1文
字をクォートするだけです。たとえば、文字列では`\t'はタブ文字を表しますが、
シンボル名では英文字`t'をクォートするだけです。名前にタブ文字を含むシン
ボルを書くには、実際に（バックスラッシュの直後に）タブを使う必要がありま
す。しかし、そのようなことをするのは皆無でしょう。

     Common Lispに関した注意：` ' Common Lispでは、小文字を明示的にエス
     ケープしない限り、小文字をつねに大文字に『変換』する。Emacs Lispで
     は、大文字と小文字を区別する。

シンボル名の例をいくつかあげましょう。5番目の例の`+'は、数として読まれる
のを防ぐためにエスケープしてあることに注意してください。6番目の例では、
これは必要ありません。なぜなら、名前の残りの部分が数としては不正だからで
す。

     foo                 ; `foo'という名前のシンボル
     FOO                 ; `FOO'という名前のシンボル、`foo'とは別
     char-to-string      ; `char-to-string'という名前のシンボル
     1+                  ; `1+'という名前のシンボル
                         ;   （整数の`+1'ではない）
     \+1                 ; `+1'という名前のシンボル
                         ;   （読みにくい名前）
     \(*\ 1\ 2\)         ; `(* 1 2)'という名前のシンボル（悪い名前）
     +-*/_~!@$%^&=:<>{}  ; `+-*/_~!@$%^&=:<>{}'という名前のシンボル
                         ;   これらの文字をエスケープする必要はない



File: elisp-ja.info, Node: Sequence Type, Next: Cons Cell Type, Prev: Symbol Type, Up: Programming Types

シーケンス型
------------

"シーケンス"（sequence）とは、要素の順序集合を表現するLispオブジェクトで
す。Emacs Lispには2種類のシーケンス、つまり、リストと配列があります。し
たがって、リスト型や配列型のオブジェクトは、シーケンス型でもあると考えら
れます。

配列はさらに、文字列、ベクトル、文字テーブル、ブールベクトルに細分されま
す。ベクトルは任意の型の要素を保持できますが、文字列の要素は文字である必
要があり、ブールベクトルの要素は`t'か`nil'のいずれかである必要があります。
バッファ内の文字のように、文字列内の文字はテキスト属性を持てます（*Note
Text Properties::）。ベクトルとブールベクトル (1) (*Note Sequence
Type-Footnotes::) では、それらの要素が文字であったとしても、テキスト属性
を扱えません。文字テーブルは、ベクトルに似ていますが、正しい文字コードで
添字付けします。

リスト、文字列、および、その他の配列型は別のものですが、それらには重要な
類似性があります。たとえば、それらすべてに長さLがあり、それらのすべての
要素は0からL-1で添字付けできます。シーケンス関数と呼ばれるいくつかの関数
は、任意のシーケンス型を扱います。たとえば、シーケンスから指定した添字の
要素を取り出すには、関数`elt'を使います。*Note Sequences Arrays
Vectors::。

一般には、同一のシーケンスを二度読み取ることは不可能です。というのは、読
むたびにつねに新たにシーケンスを作成するからです。シーケンスの入力構文を
二度読むと、同じ内容の2つのシーケンスを得ることになります。1つ例外があり
ます。空リスト`()'は、つねに同じオブジェクト`nil'を表します。


File: elisp-ja.info  Node: Sequence Type-Footnotes, Up: Sequence Type

(1) 【訳注】ベクトルのみの誤り？



File: elisp-ja.info, Node: Cons Cell Type, Next: Array Type, Prev: Sequence Type, Up: Programming Types

コンスセルとリスト型
--------------------

"コンスセル"（cons cell）とは、CARスロットおよびCDRスロットと呼ばれる2つ
のポインタから成るオブジェクトです。各スロットは、任意のLispオブジェクト
を"指す"ことができます。また、現在CARスロットが指しているオブジェクトが
なんであれ、『コンスセルのCARは』といったいい方をします。CDRについても同
様です。

"リスト"（list）はコンスセルが連なったものであり、各コンスセルのCDRスロッ
トは、後続のコンスセルを指すか空リストを指します。リストに作用する関数に
ついては、*Note Lists::。ほとんどのコンスセルは、リストの一部分として使
われるので、"リスト構造"（list structure）という用語は、コンスセルから成
る任意の構造のことを意味します。

CARやCDRという名称は、Lispの歴史に由来します。
最初のLispはIBM 704で動作していました。
この計算機では、ワードを2つの部分、『番地』（address）部分、
『減数』（decrement）部分と呼ばれるものに分けていました。
CARはレジスタの番地部分の内容（Contents of Address Register）を
取り出す命令であり、
CDRはレジスタの減数部分の内容（Contents of Decrement Register）を
取り出す命令でした。
一方、『コンスセル』という名称は、
これらを作成する関数`cons'からきています。
この関数名は、その目的、セルを作る（construction of cells）からきています。

コンスセルはLispの核心なので、『コンスセルではないオブジェクト』に対する
名称もあります。これらのオブジェクトを"アトム"（atoms）と呼びます。

リストの入力構文と表示表現は同一です。開き括弧で始まり、任意個の要素、閉
じ括弧で終えます。

読み取り時には、括弧の内側の各オブジェクトが、リストの各要素になります。
つまり、これらの要素からなるコンスセルを作ります。コンスセルのCARスロッ
トで要素を指します。同じコンスセルのCDRスロットで、リスト上のつぎの要素
を保持している、リストのつぎのコンスセルを指します。最後のコンスセルの
CDRスロットは`nil'を指します。

リストは、コンスセルを1対の箱で表して図示できます。（Lispリーダがこのよ
うな図表示を読むことはない。人間や計算機が理解できるテキスト表記と違い、
箱を用いた図表示は人間だけが理解できる。）つぎの図は、3つの要素から成る
リスト`(rose violet buttercup)'を表します。

         -- ---      -- ---      -- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         -- ---      -- ---      -- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

この図で、各箱は、任意のLispオブジェクトを指すことができるスロットを表し
ます。箱の対でコンスセルを表します。各矢印は、アトムや他のコンスセルであ
るLispオブジェクトを指すポインタです。

この例では、最初のコンスセルのCARを表す最初の箱は、`rose'（シンボル）を
指しています。あるいは、`rose'（シンボル）を『含んでいる』ともいいます。
最初のコンスセルのCDRを表す2番目の箱は、つぎの1対の箱、2番目のコンスセル
を指しています。2番目のコンスセルのCARは`violet'であり、このコンスセルの
CDRは3番目のコンスセルです。3番目の（最後の）コンスセルのCDRは、`nil'で
す。

同じリスト`(rose violet buttercup)'を別の方法で図表示するとつぎのように
なります。

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

内部に要素を持たないリストは、"空リスト"（empty list）です。これはシンボ
ル`nil'と同一です。いいかえれば、`nil'はシンボルでもありリストでもありま
す。

Lispの構文で書き表したリストの例を示します。

     (A 2 "A")            ; 3要素のリスト
     ()                   ; 要素を持たないリスト（空リスト）
     nil                  ; 要素を持たないリスト（空リスト）
     ("A ()")             ; 文字列`"A ()"'だけの1要素のリスト
     (A ())               ; `A'と空リストから成る2要素のリスト
     (A nil)              ; 上と同じ
     ((A B C))            ; 1要素のリスト
                          ;   （その要素は3要素のリスト）

リスト`(A ())'や、これと同じ`(A nil)'を箱と矢印で書くとつぎのようになり
ます。

         -- ---      -- ---
        |   |   |--> |   |   |--> nil
         -- ---      -- ---
          |            |
          |            |
           --> A        --> nil

* Menu:

* Dotted Pair Notation::        An alternative syntax for lists.
* Association List Type::       A specially constructed list.



File: elisp-ja.info, Node: Dotted Pair Notation, Prev: Cons Cell Type, Up: Cons Cell Type

ドット対記法
............

"ドット対記法"（dotted pair notation）とは、CARとCDRを明示したコンスセル
を表すもう1つの構文です。この構文では、`(A . B)'で、CARがオブジェクトAで
ありCDRがオブジェクトBであるコンスセルを表します。したがって、ドット対記
法は、リストの構文よりさらに汎用性があります。ドット対記法では、リスト
`(1 2 3)'は、`(1 .  (2 . (3 . nil)))'と書けます。`nil'で終るリストならば、
どちらの記法でも書き表せますが、リスト記法のほうがわかりやすくて便利です。
リストを表示するときには、コンスセルのCDRがリスト以外の場合に限ってドッ
ト対記法を使います。

ドット対記法を箱で表現してみます。つぎの例は`(rose . violet)'を表したも
のです。

         -- ---
        |   |   |--> violet
         -- ---
          |
          |
           --> rose

最後のCDRが`nil'以外であるようなコンスセルの連鎖を表現するために、リスト
記法にドット対記法を組み合わせることもできます。リストの最後の要素のあと
にドットを書き、続けて、最後のコンスセルのCDRを書きます。たとえば、
`(rose violet . buttercup)'は、`(rose . (violet . buttercup))'に等価です。
このオブジェクトはつぎのようになります。

         -- ---      -- ---
        |   |   |--> |   |   |--> buttercup
         -- ---      -- ---
          |            |
          |            |
           --> rose     --> violet

`(rose . violet . buttercup)'という構文は不正です。これが意味することは
なにもありません。たとえあったとしても、CDRを`violet'用にすでに使ってい
るコンスセルのCDRに`buttercup'を置けということになります。

リスト`(rose violet)'は、`(rose . (violet))'に等価であり、つぎのように図
示できます。

         -- ---      -- ---
        |   |   |--> |   |   |--> nil
         -- ---      -- ---
          |            |
          |            |
           --> rose     --> violet

同様に、3要素のリスト`(rose violet buttercup)'は、`(rose . (violet
. (buttercup)))'に等価です。
つぎのように図示できます。

         -- ---      -- ---      -- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         -- ---      -- ---      -- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup



File: elisp-ja.info, Node: Association List Type, Prev: Cons Cell Type, Up: Cons Cell Type

連想リスト型
............

"連想リスト"（association list）、すなわち、"alist"は、各要素がコンスセ
ルであるように特別に構成したリストのことです。各要素では、CARを"キー"
（key）と考え、CDRを"連想値"（associated value）と考えます。（場合によっ
ては、連想値を、CDRのCARに保持することもある。）連想リストはスタックとし
て使われることがままあります。というのは、リストの先頭に対応関係を追加／
削除するのが簡単だからです。

たとえば、

     (setq alist-of-colors
           '((rose . red) (lily . white)  (buttercup . yellow)))

は、変数`alist-of-colors'に、3要素の連想リストを設定します。最初の要素で
は、`rose'がキーであり、`red'が値です。

連想リストとそれらを操作する関数について詳しい説明は、*Note Association
Lists::。



File: elisp-ja.info, Node: Array Type, Next: String Type, Prev: Cons Cell Type, Up: Programming Types

配列型
------

"配列"（array）は、任意のLispオブジェクトを指すための任意個のスロットか
ら成り、メモリの連続した場所に取ります。配列のどの要素を参照しても、ほぼ
同じ時間かかります。一方、リストの要素を参照するときには、リスト内の要素
の位置に比例した時間が必要です。（リストの末尾の要素を参照するには、リス
トの先頭の要素を参照するより時間がかかる。）

Emacsには、4つの配列型、つまり、文字列、ベクトル、ブールベクトル、文字テー
ブルがあります。

文字列は文字の配列であり、ベクトルは任意のオブジェクトの配列です。ブール
ベクトルは、`t'や`nil'だけを保持できます。これらの種類の配列は、最大の整
数値までなら、任意の長さにできます。文字テーブルは、正しい文字コードで添
字付けする疎な配列であり、任意のオブジェクトを保持できます。

配列の最初の要素は0で添字付けする、
2番目の要素は1で添字付けする、というようになります。
これを"ゼロ原点"（zero-origin）の添字付けと呼びます。
たとえば、4つの要素からなる配列の添字は、0、1、2、そして、3です。
最大の添字は、配列の長さより1だけ小さくなります。
いったん配列を作成すると、その長さは固定されます。

Emacs Lispのすべての配列は1次元です。（多くの他のプログラム言語では多次
元配列を扱えるが、それは本質的ではない。配列の配列を作れば同じ効果を得ら
れる。）配列のそれぞれの型に応じて、専用の入力構文があります。詳しくは、
以下を参照してください。

配列型はシーケンス型に含まれ、配列型は、文字型、ベクトル型、ブールベクト
ル型、文字テーブル型を含みます。



File: elisp-ja.info, Node: String Type, Next: Vector Type, Prev: Array Type, Up: Programming Types

文字列型
--------

"文字列"（string）とは文字の配列です。テキストエディタということから予想
されるように、Emacsではさまざまな目的に文字列を使います。たとえば、Lisp
シンボルの名前として、ユーザーへのメッセージとして、バッファから取り出し
たテキストを表現するためなどです。Lispの文字列は定数です。つまり、文字列
を評価すると同じ文字列になります。

文字列を操作する関数については、*Note Strings and Characters::。

* Menu:

* Syntax for Strings::
* Non-ASCII in Strings::
* Nonprinting Characters::
* Text Props and Strings::



File: elisp-ja.info, Node: Syntax for Strings, Next: Non-ASCII in Strings, Prev: String Type, Up: String Type

文字列の構文
............

文字列の入力構文は、`"like this"'のように、ダブルクォートで始めて、任意
個の文字を書き、ダブルクォートで終えます。文字列の中にダブルクォートを含
めるには、バックスラッシュを直前に置きます。つまり、`"\""'は、ダブルクォー
ト1個だけから成る文字列です。同様に、バックスラッシュを含めるには、
`"this \\ is a single embedded backslash"'のように、バックスラッシュを直
前に置きます。

文字列の入力構文において、改行文字は特別ではありません。
ダブルクォートのあいだに改行を書けば、
改行は文字列の文字になります。
一方、エスケープした改行、つまり、`\'を直前に書くと、
文字列の一部にはなりません。
すなわち、Lispリーダは、文字列を読む際にエスケープした改行を無視します。
エスケープした空白`\ 'も、同様に無視します。

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          => "It is useful to include newlines 
     in documentation strings, 
     but the newline is ignored if escaped."



File: elisp-ja.info, Node: Non-ASCII in Strings, Next: Nonprinting Characters, Prev: Syntax for Strings, Up: String Type

文字列内の非ASCII文字
.....................

非ASCIIである国際化文字を文字列に含めるには、その文字をそのまま書きます。
Emacsの文字列（および、バッファ）では、非ASCIIの表現方法が2つあります。
ユニバイトとマルチバイトです。マルチバイトバッファやマルチバイト文字列、
あるいは、マルチバイトとして訪問しているファイルなどのマルチバイトのソー
スから文字列定数を読み取るときには、文字をマルチバイト文字として読み取り、
マルチバイト文字列にします。ユニバイトのソースから文字列定数を読み取ると
きには、文字をユニバイト文字として読み取り、文字列はユニバイトになります。

マルチバイトの非ASCII文字は、
必要な桁数の16進エスケープ`\xNNNNNNN'を用いて
書くこともできます。
（マルチバイトの非ASCII文字のコードは、256より大きい。）
16進数字として正しくない文字で16進エスケープを終端します。
16進数字の文字があとに続く場合には、`\ '（バックスラッシュと空白）と
書いて16進エスケープを終端します。
たとえば、`\x8e0\ 'は、グレーブアクセント付きの`a'を表します。
文字列定数内の`\ 'は、バックスラッシュ＋改行と同じです。
文字列内の文字には含まれませんが、先行する16進エスケープを終えます。

マルチバイトの16進エスケープを使うと、文字列はマルチバイトになります。ユ
ニバイトの非ASCIIを文字コードで表現することもできますが、文字コードは128
（8進0200）から255（8進0377）の範囲である必要があります。こうすると、文
字列はユニバイトになります。
  
2種類のテキストの表現方法について詳しくは、*Note Text Representations::。



File: elisp-ja.info, Node: Nonprinting Characters, Next: Text Props and Strings, Prev: Non-ASCII in Strings, Up: String Type

文字列内の非印字文字
....................

文字定数と同じバックスラッシュのエスケープシーケンスを文字列定数でも使え
ます（ただし、文字定数を開始する疑問符は書かない）。たとえば、コンマと空
白で区切った非印字文字のタブと`C-a'を含む文字列を書くには、`"\t, \C-a"'
のようにします。文字の入力構文については、*Note Character Type::。

しかしながら、バックスラッシュのエスケープシーケンスすべてが、文字列にお
いて正しいとは限りません。文字列に含めることが可能なコントロール文字は、
ASCIIコントロール文字に限ります。文字列では、ASCIIコントロール文字の大文
字小文字を区別しません。

正確にいえば、文字列はメタ文字を保持できません。しかし、文字列をキー列と
して使う場合には、文字列内のASCII文字のメタ変種を表現するための特別な慣
習があります。文字列定数内でメタ文字を表すために`\M-'の構文を使うと、文
字列内のその文字に2**7 のビットを設定します。`define-key'や`lookup-key'
に文字列を使うと、このコードは、等価なメタ文字に変換されます。*Note
Character Type::。

文字列では、ハイパー、スーパー、アルトの修飾子を保持できません。



File: elisp-ja.info, Node: Text Props and Strings, Prev: Nonprinting Characters, Up: String Type

文字列内のテキスト属性
......................

文字列は、文字そのものに加えて、文字の属性も保持できます。このため、特別
なことをしなくても、文字列とバッファのあいだでテキストをコピーするプログ
ラムは、テキスト属性をコピーできます。テキスト属性の意味については、
*Note Text Properties::。テキスト属性付きの文字列には、特別な入力構文が
あります。

     #("CHARACTERS" PROPERTY-DATA...)

ここで、PROPERTY-DATAは0個以上のつぎのような3つ組みです。

     BEG END PLIST

3つ組みの要素、BEGとENDは整数であり、文字列内の添字の範囲を表します。
PLISTはその範囲の属性リストです。たとえば、

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

は、最初の3文字が`face'属性として`bold'を持ち、最後の3文字が`face'属性と
して`italic'を持つ、`foo bar'という文字列を表します。（4番目の文字にはテ
キスト属性はなく、その属性リストは`nil'。デフォルトでは、範囲に含まれな
い文字には属性はないので、属性リストが`nil'であるような範囲を言及する必
要はない。）



File: elisp-ja.info, Node: Vector Type, Next: Char-Table Type, Prev: String Type, Up: Programming Types

ベクトル型
----------

"ベクトル"（vector）は、任意の型の要素から成る1次元配列です。ベクトルの
任意の要素を参照しても、それに必要な時間は一定です。（リストでは、ある要
素を参照するために必要な時間は、リストの先頭からの距離に比例する。）

ベクトルの表示表現は、開き角括弧、要素、閉じ角括弧です。これは、入力構文
でもあります。数や文字列と同様に、ベクトルは評価時には定数です。

     [1 "two" (three)]      ; 3要素のベクトル
          => [1 "two" (three)]

ベクトルに作用する関数については、*Note Vectors::。



File: elisp-ja.info, Node: Char-Table Type, Next: Bool-Vector Type, Prev: Vector Type, Up: Programming Types

文字テーブル型
--------------

"文字テーブル"（char-table）は、任意の型の要素から成る1次元配列であり、
文字コードで添字付けします。文字テーブルには、文字コードに情報を与えるた
めの多くの操作を簡単にする付加的な機能があります。たとえば、文字テーブル
は、情報を継承するための親、デフォルト値、特定目的向けの少数の追加スロッ
トを持てます。文字テーブルでは、文字集合全体に対して1つの値を指定するこ
ともできます。

文字テーブルの表示表現はベクトルに似ていますが、先頭に`#^'が余分に付きま
す。

文字テーブルを操作する特別の関数については、*Note Char-Tables::。文字テー
ブルはつぎのように使います。

   * 大文字小文字テーブル（*Note Case Tables::）。

   * 文字カテゴリテーブル（*Note Categories::）。

   * 表示テーブル（*Note Display Tables::）。

   * 構文テーブル（*Note Syntax Tables::）。



File: elisp-ja.info, Node: Bool-Vector Type, Next: Function Type, Prev: Char-Table Type, Up: Programming Types

ブールベクトル型
----------------

"ブールベクトル"（bool-vector）は、`t'か`nil'だけの要素から成る1次元配列
です。

ブールベクトルの表示表現は文字列に似ていますが、`#&'と長さで始まります。
これに続く文字列定数が、ブールベクトルの実際の内容をビットマップで表しま
す。つまり、文字列の『各文字』は8ビット長のデータであり、ブールベクトル
のつぎの8個の要素を表します（1は`t'を表し、0は`nil'を表す）。文字の最下
位ビットが、ブールベクトルの小さい添字に対応します。長さが8の倍数でない
場合には、表示表現には余計な要素が含まれますが、余計な部分に意味はありま
せん。

     (make-bool-vector 3 t)
          => #&3"\007"
     (make-bool-vector 3 nil)
          => #&3"\0"
     ;; 最初の3ビットだけを使っているので、以下はすべて同じ
     (equal #&3"\377" #&3"\007")
          => t



File: elisp-ja.info, Node: Function Type, Next: Macro Type, Prev: Bool-Vector Type, Up: Programming Types

関数型
------

他のプログラム言語の関数が実行可能であるように、"Lisp関数"（Lisp
function）は実行可能なコードです。しかしながら、Lispにおいては、関数は基
本Lispオブジェクトであり、そのテキスト表現は副次的なものです。これらの
Lispオブジェクトはラムダ式です。つまり、先頭要素がシンボル`lambda'である
リストです（*Note Lambda Expressions::）。

ほとんどのプログラム言語では、名前のない関数を書くことは不可能です。Lisp
では、本質的には、関数に名前はありません。ラムダ式のことを"無名関数"
（anonymous function）とも呼びます（*Note Anonymous Functions::）。Lisp
における名前付き関数は、実際には、関数セルに正しい関数を収めたシンボルで
す（*Note Defining Functions::）。

多くの場合、LispプログラムのLisp式中に関数名を書くと関数が呼ばれます。し
かし、実行時に関数オブジェクトを構成したり取得して、基本関数`funcall'や
`apply'で、それを呼び出すことができます。*Note Calling Functions::。



File: elisp-ja.info, Node: Macro Type, Next: Primitive Function Type, Prev: Function Type, Up: Programming Types

マクロ型
--------

"Lispマクロ"（Lisp macro）は、Lisp言語を拡張するユーザー定義の構造です。
関数に似たオブジェクトで表現しますが、引数渡しの意味は異なります。Lispマ
クロは、リストの最初の要素がシンボル`macro'であり、リストのCDRが`lambda'
シンボルを含むLisp関数オブジェクトであるフォームです。

Lispマクロオブジェクトは、通常、組み込み関数`defmacro'で定義しますが、
Emacsにとっては、`macro'で始まるリストはマクロです。マクロの書き方の説明
は、*Note Macros::。

*警告*：` 'Lispマクロとキーボードマクロ（*Note Keyboard Macros::）は、まっ
たく別のものです。単に『マクロ』といった場合には、Lispマクロを意味するの
であって、キーボードマクロのことではありません。



File: elisp-ja.info, Node: Primitive Function Type, Next: Byte-Code Type, Prev: Macro Type, Up: Programming Types

基本関数型
----------

"基本関数型"（primitive function）は、Lispから呼び出し可能な関数ですが、
C言語で書いてあります。基本関数のことを"subr"とか"組み込み関数"
（built-in functions）とも呼びます。（『subr』は『subroutine』からきてい
る。）ほとんどの基本関数は、呼び出すときにすべての引数を評価します。引数
すべてを評価しない基本関数を"スペシャルフォーム"（special form）と呼びま
す（*Note Special Forms::）。

関数を呼び出す側からすれば、関数が基本関数かどうかは関係ありません。しか
し、Lispで書いた関数で基本関数を再定義しようとすると、問題があります。と
いうのは、基本関数はCのコードから直接呼ばれるからです。再定義した関数を
Lispから呼び出す場合には新しい定義を使いますが、Cのコードは組み込みの定
義を使い続けるでしょう。したがって、*基本関数を再定義しないでください*。

"関数"（function）という用語で、LispやCで書かれたEmacsのすべての関数を指
します。Lispで書いた関数に関しては、*Note Function Type::。

基本関数には入力構文はなく、サブルーティン名を含むハッシュ記法で表示しま
す。

     (symbol-function 'car)          ; シンボルの関数セルを参照する
          => #<subr car>
     (subrp (symbol-function 'car))  ; 基本関数か？
          => t                       ; そのとおり



File: elisp-ja.info, Node: Byte-Code Type, Next: Autoload Type, Prev: Primitive Function Type, Up: Programming Types

バイトコード関数型
------------------

バイトコンパイラは、"バイトコード関数オブジェクト" （byte-code function
objects）を作り出します。内部的には、バイトコード関数オブジェクトはベク
トルによく似ています。しかしながら、評価過程においては、関数呼び出しのよ
うに見えるときには、このデータ型を特別に扱います。バイトコンパイラについ
ては、*Note Byte Compilation::。

バイトコード関数オブジェクトの表示表現と入力構文は、ベクトルに似ています
が、開き角括弧`['のまえに`#'が付きます。



File: elisp-ja.info, Node: Autoload Type, Prev: Byte-Code Type, Up: Programming Types

自動ロード型
------------

"自動ロードオブジェクト"（autoload object）は、先頭要素がシンボル
`autoload'であるリストです。実際の定義のかわりにシンボルの関数定義として
使われ、必要なときにロードすべき実際の定義を収めたLispコードファイルを示
します。自動ロードオブジェクトには、ファイル名に加えて、実際の関数定義に
関する他の情報も入っています。

ファイルをロードし終えると、シンボルには、自動ロードオブジェクトではない
新たな関数定義が入ります。この新たな定義を始めからあったかのように呼び出
します。ユーザーの視点からは、ロードしたファイル内の関数定義を使って、予
想どおりに関数呼び出しが行われます。

自動ロードオブジェクトは、普通、関数`autoload'で作ります。この関数は、シ
ンボルの関数セルにオブジェクトを格納します。より詳しくは、*Note
Autoload::。



File: elisp-ja.info, Node: Editing Types, Next: Type Predicates, Prev: Programming Types, Up: Lisp Data Types

編集向けの型
============

前節の型は一般のプログラム向けに使うもので、そのほとんどは、ほんどのLisp
方言に共通しています。Emacs Lispには、編集に関連した目的向けにいくつかの
データ型があります。

* Menu:

* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::		Windows subdivide frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.



File: elisp-ja.info, Node: Buffer Type, Next: Marker Type, Prev: Editing Types, Up: Editing Types

バッファ型
----------

"バッファ"（buffer）は、編集可能なテキストを保持するオブジェクトです
（*Note Buffers::）。ほとんどのバッファは、ディスクファイル（*Note
Files::）の内容を保持して編集できるようにしますが、他の目的に使われるも
のもあります。ほとんどのバッファは、ユーザーが見るためのものであり、ある
期間、ウィンドウ（*Note Windows::）に表示されます。しかし、バッファがい
ずれかのウィンドウに必ずしも表示される必要はありません。

バッファの内容は文字列によく似ていますが、Emacs Lispにおいては、バッファ
は文字列のようには使われず、適用可能な操作も異なります。たとえば、既存の
バッファにテキストを効率よく挿入できますが、文字列にテキストを『挿入』す
るには、部分文字列を連結する必要があり、まったく新しい文字列オブジェクト
になります。

各バッファには、"ポイント"（point）と呼ばれる特別な箇所があります（*Note
Positions::）。どんなときにも、1つのバッファが"カレントバッファ"
（current buffer）です。ほとんどの編集コマンドは、カレントバッファのポイ
ント付近の内容に作用します。多くのEmacsの標準関数は、カレントバッファ内
にある文字を操作したり検査します。本書には、これらの関数の説明にあてた章
が1つあります（*Note Text::）。

各バッファに関連付けられたデータ構造には、つぎのものがあります。

   * ローカル構文テーブル（*Note Syntax Tables::）

   * ローカルキーマップ（*Note Keymaps::）。および

   * バッファにローカルな変数束縛リスト（*Note Buffer-Local Variables::）。

   * オーバレイ（*Note Overlays::）。

   * バッファ内のテキストのテキスト属性（*Note Text Properties::）。

ローカルキーマップと変数リストには、それぞれ、グローバルな束縛や値に優先
するものが入っています。これらは、プログラムを変更せずに、各バッファごと
に、プログラムのふるまいをカスタマイズするために使われます。

バッファは"間接"（indirect）でもよく、その場合、別のバッファとテキストを
共有しつつ異なった表示を行えます。*Note Indirect Buffers::。

バッファには入力構文はありません。バッファ名を含んだハッシュ記法で表示し
ます。

     (current-buffer)
          => #<buffer objects.texi>



File: elisp-ja.info, Node: Marker Type, Next: Window Type, Prev: Buffer Type, Up: Editing Types

マーカ型
--------

"マーカ"（marker）は、特定のバッファ内の位置を表します。したがって、マー
カには2つの構成要素、つまり、バッファを示すものと位置を示すものがありま
す。バッファ内のテキストを変更すると、マーカがバッファ内の同じ2つの文字
のあいだをつねに指すことを保証するように、位置の値を更新します。

マーカには入力構文はありません。バッファ内の文字位置とバッファ名を含んだ
ハッシュ記法で表示します。

     (point-marker)
          => #<marker at 10779 in objects.texi>

マーカの検査、作成、コピー、移動の方法については、*Note Markers::。



File: elisp-ja.info, Node: Window Type, Next: Frame Type, Prev: Marker Type, Up: Editing Types

ウィンドウ型
------------

"ウィンドウ"（window）は、Emacsがバッファを表示するために使用する端末画
面の部分のことです。各ウィンドウには、対応付けられたバッファが1つあり、
そのバッファの内容をウィンドウに表示しています。一方、あるバッファが、1
つのウィンドウや複数のウィンドウに表示されることもあり、どのウィンドウに
も表示されないこともあります。

同時に複数のウィンドウが存在できますが、どんなときにも1つのウィンドウだ
けが"選択されたウィンドウ" （selected window）です。これは、Emacsがコマ
ンドを受け付け可能なときにカーソルを（通常）表示するウィンドウです。選択
されたウィンドウは、通常、カレントバッファを表示しますが、これは必須では
ありません。

画面上のウィンドウはフレームにまとめられています。各ウィンドウは、たった
1つのフレームに属します。*Note Frame Type::。

ウィンドウには入力構文はありません。ウィンドウ番号と表示中のバッファ名を
含んだハッシュ記法で表示します。ウィンドウ番号は、ウィンドウを一意に識別
するためにあります。これは、ウィンドウが表示しているバッファは頻繁に変わ
るからです。

     (selected-window)
          => #<window 1 on objects.texi>

ウィンドウを操作する関数の説明は、*Note Windows::。



File: elisp-ja.info, Node: Frame Type, Next: Window Configuration Type, Prev: Window Type, Up: Editing Types

フレーム型
----------

"フレーム"（frame）は、画面上の矩形領域であって、1つ以上のEmacsウィンド
ウを含みます。フレームには最初は1つのウィンドウ（とミニバッファウィンド
ウ）が含まれますが、これを左右や上下に小さなウィンドウに分割できます。

フレームには入力構文はありません。フレームのタイトルとメモリ内のアドレス
（フレームを一意に識別するのに有用）を含んだハッシュ記法で表示します。

     (selected-frame)
          => #<frame emacs@psilocin.gnu.org 0xdac80>

フレームを操作する関数の説明は、*Note Frames::。



File: elisp-ja.info, Node: Window Configuration Type, Next: Frame Configuration Type, Prev: Frame Type, Up: Editing Types

ウィンドウ構成型
----------------

"ウィンドウ構成"（window configuration）は、フレーム内のウィンドウの位置／
サイズ／内容に関する情報を記録し、同じ配置のウィンドウをあとで再度作成で
きるようにします。

ウィンドウ構成には入力構文はありません。表示表現は、
`#<window-configuration>'のようになります。ウィンドウ構成に関連した関数
の説明は、*Note Window Configurations::。



File: elisp-ja.info, Node: Frame Configuration Type, Next: Process Type, Prev: Window Configuration Type, Up: Editing Types

フレーム構成型
--------------

"フレーム構成"（frame configuration）は、すべてのフレームのウィンドウの
位置／サイズ／内容に関する情報の記録です。これは、実際には、リストのCAR
が`frame-configuration'であり、リストのCDRが連想リストであるリストです。
連想リストの各要素で、そのCARに現れるフレーム1個を記述します。

フレーム構成に関連した関数の説明は、*Note Frame Configurations::。



File: elisp-ja.info, Node: Process Type, Next: Stream Type, Prev: Frame Configuration Type, Up: Editing Types

プロセス型
----------

単語"プロセス"（process）は、通常、実行中のプログラムを意味します。Emacs
自身、この種のプロセスとして実行されています。しかし、Emacs Lispでは、プ
ロセスとは、Emacsプロセスが作成したサブプロセスを表すLispオブジェクトの
ことです。Emacsのサブプロセスで実行される、シェル、GDB、ftp、コンパイラ
などのプログラムは、Emacsの能力を拡張します。

Emacsサブプロセスは、Emacsからテキスト入力を受け取り、さらに処理できるよ
うにEmacsにテキスト出力を返します。Emacsはサブプロセスにシグナルを送るこ
ともできます。

プロセスオブジェクトに入力構文はありません。プロセス名を含んだハッシュ記
法で表示します。

     (process-list)
          => (#<process shell>)

プロセスを作成したり削除したり、プロセスに関する情報を返したり、プロセス
へ入力やシグナルを送ったり、プロセスから出力を受け取る関数に関する情報は、
*Note Processes::。



File: elisp-ja.info, Node: Stream Type, Next: Keymap Type, Prev: Process Type, Up: Editing Types

ストリーム型
------------

"ストリーム"（stream）は、文字を出し入れする対象、つまり、入力用に文字を
供給したり、出力として文字を受け取ったりといったことに使えるオブジェクト
です。多くの異なる型をこのように使えます。マーカ、バッファ、文字列、関数
です。ほとんどの場合、入力ストリーム（文字の供給源）は、キーボード、バッ
ファ、ファイルから文字を取得します。出力ストリーム（文字の消費先）は、
`*Help*'バッファなどのバッファやエコー領域に文字を送ります。

オブジェクト`nil'は、他の意味に加えて、ストリームとしても使えます。変数
`standard-input'や`standard-output'の値になります。また、オブジェクト`t'
も、ミニバッファ（*Note Minibuffers::）を使う入力ストリームやエコー領域
への出力（*Note The Echo Area::）を意味します。

ストリームには表示形式も入力構文もなく、その基本型で表示します。

構文解析関数や表示関数を含むストリームに関連した関数の説明は、*Note Read
and Print::。



File: elisp-ja.info, Node: Keymap Type, Next: Overlay Type, Prev: Stream Type, Up: Editing Types

キーマップ型
------------

"キーマップ"（keymap）は、ユーザーが打ったキーをコマンドに対応付けます。
この対応付けは、ユーザーのコマンド入力をどのように実行するかを制御します。
キーマップは、実際には、リストであり、そのCARはシンボル`keymap'です。

キーマップの作成、プレフィックスキーの扱い方、グローバルやローカルなキー
マップ、キーバインディングの変更に関する情報は、*Note Keymaps::。



File: elisp-ja.info, Node: Overlay Type, Prev: Keymap Type, Up: Editing Types

オーバレイ型
------------

"オーバレイ"（overlay）は、バッファのある部分に作用する属性を指定します。
各オーバレイは、バッファの指定した範囲に作用し、属性リスト（属性名と値の
要素を交互に繰り返すリスト）を含んでいます。オーバレイ属性は、バッファの
一部を一時的に異なった方式で表示するために使われます。オーバレイ属性に入
力構文はなく、バッファ名と位置範囲を含んだハッシュ記法で表示します。

オーバレイの作成と使用法については、*Note Overlays::。



File: elisp-ja.info, Node: Type Predicates, Next: Equality Predicates, Prev: Editing Types, Up: Lisp Data Types

型述語
======

Emacs Lispインタープリタ自身は、関数を呼び出すときに渡す実引数の型検査を
行いません。そうできないのは、他のプログラム言語が行うようには、Lispの関
数の引数にはデータ型の宣言がないからです。したがって、各実引数がその関数
で扱える型に属するかどうかを検査するのは、各関数の責任です。

すべての組み込み関数は、必要なときには実引数の型検査を行い、引数が誤った
型であれば、エラー`wrong-type-argument'を通知します。たとえば、`+'に扱え
ない引数を渡すと、つぎのようになります。

     (+ 2 'a)
          error--> Wrong type argument: number-or-marker-p, a

読者のプログラムで、異なる型を異なるように扱いたい場合には、明示的に型検
査を行う必要があります。オブジェクトの型を検査するもっとも一般的な方法は、
"型述語"（type predicate）関数を呼び出すことです。Emacsには、各型ごとに
型述語があり、型を組み合わせたものに対する述語もあります。

型述語関数は1つの引数を取ります。引数が適切な型に属していれば`t'を返し、
さもなければ`nil'を返します。述語関数に関するLisp一般の慣習に従って、ほ
とんどの型述語の名前は`p'で終ります。

以下は、リストの検査に述語`listp'を使い、シンボルの検査に述語`symbolp'を
使う例です。

     (defun add-on (x)
       (cond ((symbolp x)
              ;; Xがシンボルならば、それをLISTに加える
              (setq list (cons x list)))
             ((listp x)
              ;; Xがリストならば、その要素をLISTに追加する
              (setq list (append x list)))
             (t
              ;; シンボルとリストだけを扱う
              (error "Invalid argument %s in add-on" x))))

定義済みの型述語を、アルファベット順に、参照先を併記してあげておきます。

`atom'
     *Note atom: List-related Predicates.。

`arrayp'
     *Note arrayp: Array Functions.。

`bool-vector-p'
     *Note bool-vector-p: Bool-Vectors.。

`bufferp'
     *Note bufferp: Buffer Basics.。

`byte-code-function-p'
     *Note byte-code-function-p: Byte-Code Type.。

`case-table-p'
     *Note case-table-p: Case Tables.。

`char-or-string-p'
     *Note char-or-string-p: Predicates for Strings.。

`char-table-p'
     *Note char-table-p: Char-Tables.。

`commandp'
     *Note commandp: Interactive Call.。

`consp'
     *Note consp: List-related Predicates.。

`display-table-p'
     *Note display-table-p: Display Tables.。

`floatp'
     *Note floatp: Predicates on Numbers.。

`frame-configuration-p'
     *Note frame-configuration-p: Frame Configurations.。

`frame-live-p'
     *Note frame-live-p: Deleting Frames.。

`framep'
     *Note framep: Frames.。

`functionp'
     *Note functionp: Functions.。

`integer-or-marker-p'
     *Note integer-or-marker-p: Predicates on Markers.。

`integerp'
     *Note integerp: Predicates on Numbers.。

`keymapp'
     *Note keymapp: Creating Keymaps.。

`listp'
     *Note listp: List-related Predicates.。

`markerp'
     *Note markerp: Predicates on Markers.。

`wholenump'
     *Note wholenump: Predicates on Numbers.。

`nlistp'
     *Note nlistp: List-related Predicates.。

`numberp'
     *Note numberp: Predicates on Numbers.。

`number-or-marker-p'
     *Note number-or-marker-p: Predicates on Markers.。

`overlayp'
     *Note overlayp: Overlays.。

`processp'
     *Note processp: Processes.。

`sequencep'
     *Note sequencep: Sequence Functions.。

`stringp'
     *Note stringp: Predicates for Strings.。

`subrp'
     *Note subrp: Function Cells.。

`symbolp'
     *Note symbolp: Symbols.。

`syntax-table-p'
     *Note syntax-table-p: Syntax Tables.。

`user-variable-p'
     *Note user-variable-p: Defining Variables.。

`vectorp'
     *Note vectorp: Vectors.。

`window-configuration-p'
     *Note window-configuration-p: Window Configurations.。

`window-live-p'
     *Note window-live-p: Deleting Windows.。

`windowp'
     *Note windowp: Basic Windows.。

オブジェクトの型を調べるもっとも一般的な方法は、関数`type-of'を呼び出す
ことです。各オブジェクトはたった1つの基本型に属することを思い出してくだ
さい。`type-of'はどの1つかを教えてくれます（*Note Lisp Data Types::）。
しかし、`type-of'は、基本型以外についてはなにも知りません。多くの場合、
`type-of'より型述語を使うほうが便利でしょう。

 -- Function: type-of OBJECT
     この関数は、OBJECTの基本型を示すシンボルを返す。その値は、`symbol'、
     `integer'、`float'、`string'、`cons'、`vector'、`char-table'、
     `bool-vector'、`subr'、`compiled-function'、`marker'、`overlay'、
     `window'、`buffer'、`frame'、`process'、`window-configuration'のシ
     ンボルのうちの1つ。

          (type-of 1)
               => integer
          (type-of 'nil)
               => symbol
          (type-of '())    ; `()'は`nil'
               => symbol
          (type-of '(x))
               => cons



