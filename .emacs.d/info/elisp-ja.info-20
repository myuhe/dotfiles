Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Terminal I/O Encoding, Next: MS-DOS File Types, Prev: Explicit Encoding, Up: Coding Systems

端末入出力の符号化
------------------

Emacsは、コーディングシステムを用いてキーボード入力を復号化したり、端末
出力を符号化できます。Latin-1などの特定の符号を用いてテキストを送信した
り表示する端末に対しては、これは有用です。Emacsは、端末に対する符号化や
復号化では`last-coding-system-used'に設定しません。

 -- Function: keyboard-coding-system
     この関数は、キーボード入力の復号化に用いているコーディングシステム
     を返す。コーディングシステムを使用していなければ`nil'を返す。

 -- Function: set-keyboard-coding-system CODING-SYSTEM
     この関数は、キーボード入力の復号化に使用するコーディングシステムと
     してCODING-SYSTEMを指定する。CODING-SYSTEMが`nil'であると、キーボー
     ド入力に復号化を用いないことを意味する。

 -- Function: terminal-coding-system
     この関数は、端末出力の符号化に用いているコーディングシステムを返す。
     コーディングシステムを使用していなければ`nil'を返す。

 -- Function: set-terminal-coding-system CODING-SYSTEM
     この関数は、端末出力の符号化に使用するコーディングシステムとして
     CODING-SYSTEMを指定する。CODING-SYSTEMが`nil'であると、端末出力に符
     号化を用いないことを意味する。



File: elisp-ja.info, Node: MS-DOS File Types, Prev: Terminal I/O Encoding, Up: Coding Systems

MS-DOSのファイル型
------------------

MS-DOSやMS-Windows上のEmacsは、特定のファイル名をテキストファイルやバイ
ナリファイルとして認識します。『バイナリファイル』とは、必ずしも文字を意
味しないバイト値のファイルです。Emacsは、バイナリファイルに対しては行末
変換や文字コード変換を行いません。一方、その名前から『テキストファイル』
と印が付いた新規ファイルを作成すると、EmacsはDOSの行末変換を行います。

 -- Variable: buffer-file-type
     この変数は、各バッファで自動的にバッファローカルになり、バッファで
     訪問したファイルのファイル型を記録する。バッファが
     `buffer-file-coding-system'でコーディングシステムを指定しない場合、
     バッファ内容を書き出すときに用いるコーディングシステムをこの変数を
     用いて決定する。テキストに対しては`nil'、バイナリに対して`t'である
     こと。これが`t'であると、コーディングシステムは`no-conversion'であ
     る。さもなければ、`undecided-dos'を用いる。

     通常、この変数はファイルを訪問すると設定される。いかなる変換も行わ
     ずにファイルを訪問すると`nil'に設定される。

 -- User Option: file-name-buffer-file-type-alist
     この変数は、テキスト／バイナリファイルを認識するための連想リストを
     保持する。各要素は(REGEXP . TYPE)の形である。ここで、REGEXPはファイ
     ル名に対して一致をとり、TYPEは、テキストファイルでは`nil'、バイナリ
     ファイルでは`t'、あるいは、どちらであるかを計算するために呼び出す関
     数である。それが関数であると、1つの引数（ファイル名）で呼ばれ、`t'
     か`nil'を返すこと。

     MS-DOSやMS-Windowsで動作しているEmacsは、この連想リストを調べて、ファ
     イルを読む際に使用するコーディングシステムを決定する。テキストファ
     イルでは`undecided-dos'が使われる。バイナリファイルでは
     `no-conversion'が使われる。

     指定したファイルがこの連想リストの要素に一致しないと、
     `default-buffer-file-type'がファイルの扱い方を指定する。

 -- User Option: default-buffer-file-type
     この変数は、`file-name-buffer-file-type-alist'が指定しない型のファ
     イルの扱い方を指定する。

     この変数が`nil'以外であると、そのようなファイルはバイナリとして扱わ
     れ、コーディングシステム`no-conversion'を用いる。さもなければそれら
     に対して特別なことを行わずに、Emacsの通常のとおりにファイル内容から
     コーディングシステムを決定する。



File: elisp-ja.info, Node: Input Methods, Prev: Coding Systems, Up: Non-ASCII Characters

入力方式
========

"入力方式"（input method）は、キーボードから非ASCII文字を入力する簡便な
方法を提供します。プログラムが読み取るための非ASCII文字の符号変換を行う
コーディングシステムと異なり、入力方式は人間向けのコマンドを提供します。
（テキストを入力するための入力方式の使い方については、*Note 入力方式:
(emacs)Input Methods.。）入力方式の定義方法については本書ではまだ明文化
してありませんが、ここではそれらの使い方について述べます。

各入力方式には名前があります。それは現在のところ文字列ですが、将来は入力
方式名としてシンボルも使えるようになります。

 -- Variable: current-input-method
     この変数は、カレントバッファで現在活性な入力方式の名前を保持する。
     （この変数に設定すると自動的にバッファローカルになる。）`nil'である
     と、バッファでは入力方式が活性ではない。

 -- Variable: default-input-method
     この変数は、入力方式を選ぶコマンド向けのデフォルトの入力方式を保持
     する。`current-input-method'と異なり、この変数は通常はグローバルで
     ある。

 -- Function: set-input-method INPUT-METHOD
     この関数は、カレントバッファにおいて入力方式INPUT-METHODを活性にす
     る。`default-input-method'にもINPUT-METHODを設定する。INPUT-METHOD
     が`nil'であると、この関数はカレントバッファの入力方式を不活性にする。

 -- Function: read-input-method-name PROMPT &optional DEFAULT INHIBIT-NULL
     この関数は、プロンプトPROMPTを用いてミニバッファで入力方式名を読む。
     DEFAULTが`nil'以外であると、ユーザーが空の入力をするとデフォルトで
     これを返す。しかし、INHIBIT-NULLが`nil'以外であると、空の入力はエラー
     を通知する。

     戻り値は文字列である。

 -- Variable: input-method-alist
     この変数は、使用可能なすべての入力方式を定義する。各要素は1つの入力
     方式を定義し、つぎの形であること。

          (INPUT-METHOD LANGUAGE-ENV ACTIVATE-FUNC
           TITLE DESCRIPTION ARGS...)

     ここで、INPUT-METHODは入力方式名であり文字列である。LANGUAGE-ENVも
     別の文字列であり当該入力方式を推奨する言語環境の名前である。（これ
     は説明文目的のためだけである。）

     TITLEは、この入力方式が活性である場合にモード行に表示される文字列で
     ある。DESCRIPTIONはこの入力方式と何向きであるかを説明する文字列であ
     る。

     ACTIVATE-FUNCは、この入力方式を活性にするために呼び出す関数である。
     ARGSがあればACTIVATE-FUNCへの引数として渡される。つまり、
     ACTIVATE-FUNCの引数はINPUT-METHODとARGSである。

入力方式に対する基本的なインターフェイスは変数`input-method-function'を
介して行います。*Note Reading One Event::。



File: elisp-ja.info, Node: Searching and Matching, Next: Syntax Tables, Prev: Non-ASCII Characters, Up: Top

探索と一致
**********

GNU Emacsにはバッファから指定したテキストを探す方法が2つあります。文字列
そのものを正確に探索するのと正規表現の探索です。正規表現の探索のあとでは、
正規表現全体やそのさまざまな部分に一致したテキストを表す"マッチデータ"
（match data）を調べることができます。

* Menu:

* String Search::         Search for an exact match.
* Regular Expressions::   Describing classes of strings.
* Regexp Search::         Searching for a match for a regexp.
* POSIX Regexps::         Searching POSIX-style for the longest match.
* Search and Replace::	  Internals of `query-replace'.
* Match Data::            Finding out which part of the text matched
                            various parts of a regexp, after regexp search.
* Searching and Case::    Case-independent or case-significant searching.
* Standard Regexps::      Useful regexps for finding sentences, pages,...

`skip-chars...'などの関数もある種の探索を行います。*Note Skipping
Characters::。



File: elisp-ja.info, Node: String Search, Next: Regular Expressions, Prev: Searching and Matching, Up: Searching and Matching

文字列の探索
============

これらは、バッファ内のテキストを探索するための基本関数です。これらはプロ
グラムで使うことを意図していますが、対話的に呼び出すこともできます。その
場合、探索文字列を問い合わせてきますが、LIMITとNOERRORは`nil'に、REPEAT
は1に設定されます。

これらの探索関数は、バッファがマルチバイトであると探索文字列をマルチバイ
トに変換します。バッファがユニバイトであると探索文字列をユニバイトに変換
します。*Note Text Representations::。

 -- コマンド: search-forward STRING &optional LIMIT NOERROR REPEAT
     この関数は、ポイントから前方へ向けて文字列STRINGにちょうど一致する
     ものを探す。それに成功すれば、ポイントをみつけた出現箇所の末尾に移
     動し、ポイントの新たな値を返す。一致がみつからなければ、戻り値と副
     作用はNOERRORに依存する（下記参照）。

     つぎの例では、ポイントは始めは行頭にある。そして`(search-forward
     "fox")'は`fox'の最後の文字のうしろにポイントを移動する。

          ---------- Buffer: foo ----------
          -!-The quick brown fox jumped over the lazy dog.
          ---------- Buffer: foo ----------

          (search-forward "fox")
               => 20

          ---------- Buffer: foo ----------
          The quick brown fox-!- jumped over the lazy dog.
          ---------- Buffer: foo ----------

     引数LIMITは探索の上限を指定する。（カレントバッファ内の位置であるこ
     と。）その位置を越える箇所での一致は受け入れない。LIMITを省略したり
     `nil'であると、デフォルトは、バッファの参照可能部分の末尾である。

     探索に失敗した場合の動作は、NOERRORの値に依存する。NOERRORが`nil'で
     あると、エラー`search-failed'を通知する。NOERRORが`t'であると、
     `search-forward'は`nil'を返しなにもしない。NOERRORが`nil'でも`t'で
     もないと、`search-forward'はポイントを上限位置へ移動して`nil'を返す。
     （この場合にもポイントの新たな値を返すほうが一貫性があるが、値`nil'
     に依存しているプログラムがある。）

     REPEATを指定してあると（正の数であること）、その回数だけ探索を繰り
     返す（一致箇所の末尾を新たな探索の開始位置とする）。連続してこれら
     の探索に成功すると関数は成功し、ポイントを移動してその新たな値を返
     す。さもなければ探索は失敗である。

 -- コマンド: search-backward STRING &optional LIMIT NOERROR REPEAT
     この関数は、ポイントから後方へ向けてSTRINGを探索する。
     `search-forward'と同様であるが、後方へ向けて探索し一致箇所の先頭に
     ポイントを置く点が異なる。

 -- コマンド: word-search-forward STRING &optional LIMIT NOERROR REPEAT
     この関数は、ポイントから前方へ向けてSTRINGに一致する『単語』を探索
     する。一致をみつけると、一致箇所の末尾にポイントを設定しポイントの
     新たな値を返す。

     単語の一致では、STRINGを単語の列とみなし、それらを区切る句読点は無
     視する。バッファ内の同じ単語の列を探す。バッファ内の各単語は別々に
     なっている必要があるが（単語`ball'を探索すると単語`balls'には一致し
     ない）、句読点や空白の詳細は無視される（`ball boy'を探索すると
     `ball.  Boy!'に一致する）。

     つぎの例では、ポイントは始めはバッファの先頭にある。探索するとポイ
     ントは`y'と`!'のあいだに移動する。

          ---------- Buffer: foo ----------
          -!-He said "Please!  Find
          the ball boy!"
          ---------- Buffer: foo ----------

          (word-search-forward "Please find the ball, boy.")
               => 35

          ---------- Buffer: foo ----------
          He said "Please!  Find
          the ball boy-!-!"
          ---------- Buffer: foo ----------

     LIMITが`nil'以外（カレントバッファ内の位置）であると、それは探索の
     上限を指定する。みつかった一致箇所はその位置を越えてはならない。

     NOERRORが`nil'であると、探索に失敗するとエラー`word-search-failed'
     を通知する。NOERRORが`t'であると、エラーを通知するかわりに`nil'を返
     す。NOERRORが`nil'でも`t'でもないと、ポイントをLIMIT（あるいはバッ
     ファの末尾）へ移動して`nil'を返す。

     REPEATが`nil'以外であると、その回数だけ探索を繰り返す。ポイントは最
     後の一致箇所の末尾へ置かれる。

 -- コマンド: word-search-backward STRING &optional LIMIT NOERROR REPEAT
     この関数はポイントから後方へ向けてSTRINGに一致する単語を探索する。
     この関数は`word-search-forward'と同様であるが、後方へ向けて探索し一
     致箇所の先頭にポイントを置く点が異なる。



File: elisp-ja.info, Node: Regular Expressions, Next: Regexp Search, Prev: String Search, Up: Searching and Matching

正規表現
========

"正規表現"（regular expression、略して"regexp"）は、文字列の（無限の可能
性もある）集合を表すパターンです。正規表現への一致を探すことは、非常に強
力な操作です。本節では、正規表現の書き方を説明します。続く節では、それら
を探索する方法を説明します。

* Menu:

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.



File: elisp-ja.info, Node: Syntax of Regexps, Next: Regexp Example, Prev: Regular Expressions, Up: Regular Expressions

正規表現の構文
--------------

正規表現では、数個の文字が特別な構成であり、残りは"普通"です。普通の文字
は、その文字だけに一致する単純な正規表現です。特別な文字は、`.'、`*'、
`+'、`?'、`['、`]'、`^'、`$'、`\'であり、将来新たな文字が定義されること
はありません。正規表現に現れるこれら以外の文字は、まえに`\'がない限り普
通の文字です。

たとえば、`f'は特別な文字ではないので普通の文字です。ですから、`f'は文字
列`f'だけに一致する正規表現です。（これは文字列`ff'には一致しない。）同
様に、`o'は`o'だけに一致する正規表現です。

任意の2つの正規表現AとBを連結できます。その結果は、Aが文字列の始めの部分
に一致し、かつ、Bがその文字列の残りに一致するときにその文字列に一致する
正規表現になります。

簡単な例として、正規表現 `f'と`o'を連結して正規表現`fo'を得られます。こ
れは文字列`fo'だけに一致します。これは明らかですね。より強力なことをする
には、特別な文字の1つを使う必要があります。それらの一覧を以下に示します。

`.' （ピリオド）
     特別な文字であり、改行以外の任意の1文字に一致する。連結を使って
     `a.b'のような正規表現を作れる。これは、`a'で始まり`b'で終る任意の3
     文字の文字列に一致する。

`*'
     単独では構成要素ではない。直前の正規表現を可能な限り反復することを
     意味する後置演算子である。すなわち、`o*'は（`o'が存在しない場合も含
     めて）任意個の`o'に一致する。

     `*'はつねに先行する*最小*の正規表現に適用される。したがって、`fo*'
     は`fo'を繰り返すのではなく、`o'を繰り返す。この正規表現は`f'、`fo'、
     `foo'などに一致する。

     `*'を用いた構成の一致を処理するときには、ただちに得られる限りの反復
     回数に展開される。そうしてから、残りのパターンを処理する。一致に失
     敗するとバックトラック（後戻り）が発生して、`*'を用いた構成の反復回
     数を減らしてパターンの残りの部分が一致できるようにする。たとえば、
     文字列`caaar'に対して`ca*ar'を一致させることを考えてみる。始めに、
     `a*'を3つの`a'すべてに一致させようとする。しかし、残りのパターンが
     `ar'なのに`r'しか残っていないため、この試みは失敗する。そこで、つぎ
     は`a*'を`a'2つだけに一致させる。こうすると、残りの正規表現も正しく
     一致する。

     入れ子にした反復演算子がバックトラックのループを指定する場合、それ
     はとても遅くなる。たとえば、正規表現`\(x+y*\)*a'を
     `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz'の列に一致させると最終的に失
     敗するまで何時間も費してしまう。遅さの原因は、Emacsは35個の`x'をグ
     ループに分ける各方法をすべて試してからでないとそれらが一致しないこ
     とを結論できないからである。読者の正規表現が素早く動作することを保
     証するために、入れ子になった繰り返しを注意深く調べること。

`+'
     `*'に似た後置演算子だが、直前の正規表現に1回以上一致する必要がある。
     たとえば、`ca+r'は、文字列`car'や`caaaar'には一致するが、文字列`cr'
     には一致ない。一方、`ca*r'の場合は、上記の3つすべてに一致する。

`?'
     `*'に似た後置演算子だが、直前の正規表現に1回だけ一致するか、あるい
     は、1回も一致しない。たとえば、`ca?r'は、`car'や`cr'に一致するが、
     他のものには一致しない。

`[ ... ]'
     `['で始まり`]'で終る"文字選択"を表す。もっとも単純な場合は、この2つ
     の中括弧のあいだにある文字の1つ1つがこの文字選択に一致する。

     したがって、`[ad]'は、`a'1文字か`d'1文字のどちらにも一致する。
     `[ad]*'は、`a'と`d'だけから成る（空の文字列を含む）任意の文字列に一
     致する。このことから、`c[ad]*r'は、`cr'、`car'、`cdr'、`caddaar'な
     どに一致することがわかる。

     文字選択には、文字範囲の指定を含めることもでき、始めの文字と終りの
     文字のあいだに`-'を書く。つまり、`[a-z]'はすべてのASCII小英文字に一
     致する。範囲指定と個々の文字を自由に織り混ぜてよく、`[a-z$%.]'のよ
     うに書ける。これは、任意のASCII小英文字、`$'、`%'、ピリオドに一致す
     る。
 
     正規表現`[\200-\377]'ですべての非ASCII文字につねに一致するとは限ら
     ない。ユニバイト（*Note Text Representations::）のバッファや文字列
     を探索するときにはうまく働くが、マルチバイトのバッファや文字列では
     多くの非ASCII文字のコードは8進数0377より大きいために働かない。しか
     し、正規表現`[^\000-\177]'は、ASCII文字のみを除外しているため、マル
     チバイト表現でもユニバイト表現でもすべての非ASCII文字に一致する。

     範囲指定の始めと終りは同じ文字集合（*Note Character Sets::）に属し
     ている必要がある。したがって、`[a-\x8e0]'は正しくない。`a'はASCII文
     字集合に属し、文字0x8e0（グレーブアクセント付き`a'）はEmacsの
     Latin-1の文字集合に属しているからである。

     正規表現の普通の特別な文字は、文字選択の内側では特別ではないことに
     注意。文字選択の内側では、まったく別の文字の集まり、`]'、`-'、`^'が
     特別である。

     文字選択に`]'を含めるには、`]'を最初の文字として指定する必要がある。
     たとえば、`[]a]'は、`]'や`a'に一致する。`-'を含めるには、`-'を文字
     選択の最初の文字か最後の文字として書くか、範囲指定のあとに置く。し
     たがって、`[]-]'は、`]'と`-'の両方に一致する。

     文字選択に`^'を含めるには、`^'を文字選択の2番目以降に置く。

`[^ ... ]'
     `[^'は"文字選択の補集合"の始まりを意味し、指定した文字を除く任意の
     文字に一致する。すなわち、`[^a-z0-9A-Z]'は、英文字と数字文字を*除く
     *すべての文字に一致する。

     `^'は文字選択の先頭になければ文字選択では特別な意味を持たない。`^'
     に続く文字は先頭にあるものとして扱われる（いいかえれば、ここでは`-'
     や`]'は特別な意味を持たない）。

     文字選択の補集合は、一致しない文字として改行を指定しない限り、改行
     にも一致する。この点は、`grep'のようなプログラムでの正規表現の扱い
     方と対照的である。

`^'
     空の文字列に一致する特別な文字であり、一致を取る対象のテキストの行
     頭のみに一致する。それ以外では、一致に失敗する。したがって、`^foo'
     は、行頭にある`foo'に一致する。

     バッファのかわりに文字列と一致を取るときには、`^'は文字列の先頭や改
     行文字`\n'のうしろに一致する。

`$'
     `^'と同様だが行末のみに一致する。したがって、`x+$'は、行末にある1文
     字以上の`x'から成る文字列に一致する。

     バッファのかわりに文字列と一致を取るときには、`$'は文字列の末尾や改
     行文字`\n'のまえに一致する。

`\'
     2つの機能がある。（`\'を含む）特別な文字をクォートする（意味を抑え
     る）ことと、特別な構成を導入することである。

     `\'は特別な文字をクォートするので、`\$'は文字`$'だけに一致する正規
     表現、`\['は文字`['だけに一致する正規表現、といった具合になる。

     `\'にはLisp文字列の入力構文（*Note String Type::）でも特別な意味が
     あり、`\'でクォートする必要があることに注意してほしい。たとえば、文
     字`\'に一致する正規表現は`\\'である。文字群`\\'を含むLisp文字列を書
     くには、各`\'をクォートするために`\'が必要である。したがって、`\'に
     一致する正規表現の入力構文は`"\\\\"'である。

*注意：*` '従来との互換性のために、特別な文字がそれらの特別な意味をなし
えない文脈で使われた場合には、普通の文字として扱われる。たとえば、`*foo'
では、`*'の対象となる正規表現が直前にないため、`*'は普通の文字として扱わ
れる。このようなふるまいに依存することはよいことではない。特別な文字は書
く位置に関係なくクォートするべきである。

多くの場合、任意の文字を伴う`\'はその文字だけに一致します。しかし、いく
つか例外があって、`\'で始まる2文字列が特別な意味を持つ場合があります。
（2文字目にくる文字は、単独で使った場合にはつねに普通の文字として扱われ
る。）以下に`\'の構成を示します。

`\|'
     選択肢を指定する。`\|'をあいだに伴った2つの正規表現AとBは、AかBのい
     ずれかに一致する文字列に一致する正規表現となる。

     したがって、`foo\|bar'は、`foo'や`bar'に一致するが、それ以外の文字
     列には一致しない。

     `\|'は、周囲にある適用しうる正規表現の中でも最大のものに適用される。
     `\|'によるグループ化を制限するのは、これを囲む`\( ... \)'によるグルー
     プ化だけである。

     何度`\|'を使っても処理できるだけの十分なバックトラック能力がある。

`\( ... \)'
     以下の3つの目的を果たすグループ化のための構成。

       1. 他の操作に使うために一連の選択肢`\|'を括る。したがって、
          `\(foo\|bar\)x'は、`foox'か`barx'のいずれかに一致する。

       2. 後置演算子、`*'、`+'、`?'を適用できるように、複雑な正規表現を
          括る。したがって、`ba\(na\)*'は、`bananana'のように、（0個以上
          の）任意個の文字列`na'に一致する。

       3. あとで参照できるように、一致した部分文字列を記録する。

     最後の使い方は、括弧によるグループ化という考え方から派生したもので
     はない。同一の`\( ... \)'構成に与えた2つめの別の機能である。実用上、
     これら2つの意味が混同されることはないからである。この機能をつぎに説
     明する。

`\DIGIT'
     D番目に現れた`\( ... \)'に一致したテキストと同じテキストに一致する。

     いいかえれば、一致を処理するときには、`\( ... \)'構成の末尾に達する
     と、この構成に一致したテキストの始めと終りを記録する。そして、正規
     表現のそれよりうしろでは、『D番目に現れた`\( ... \)'に一致したテキ
     スト』という意味でそれがなんであろうと`\'に続けて数字Dを使える。

     1つの正規表現内に現れる最初の9個の`\( ... \)'に一致する文字列には、
     正規表現中で開き括弧が現れた順に、1から9までの番号を割り振る。その
     ため、`\1'から`\9'で、対応する`\( ... \)'に一致したテキストを参照で
     きる。

     たとえば、`\(.*\)\1'は、改行を含まない文字列で、かつ、前半と後半が
     同一である文字列に一致する。`\(.*\)'は前半部分に一致し、それはどの
     ようなものでもかまわない。一方、それに続く`\1'は、前半部分とまった
     く同じテキストに一致しなければならない。

`\w'
     任意の単語構成文字に一致する。エディタの構文テーブルによってこの文
     字が決まる。*Note Syntax Tables::。

`\W'
     単語構成文字以外の文字に一致する。

`\sCODE'
     構文コードがCODEである文字だけに一致する。ここで、CODEは構文コード
     を表す文字である。つまり、`w'は単語構成要素を、`-'は白文字を、`('は
     開き括弧を表すといった具合である。白文字の構文を表すには、`-'か空白
     のいずれかを使う。構文コードとそれらを表す文字の一覧については、
     *Note Syntax Class Table::。

`\SCODE'
     構文がCODEでない任意の文字に一致する。

つぎの正規表現は空の文字列に一致します。つまりこれらは文字を使用しません
が、これらが一致するかどうか文脈に依存します。

`\`'
     空の文字列に一致するが、一致対象であるバッファや文字列の先頭に限る。

`\''
     空の文字列に一致するが、一致対象であるバッファや文字列の末尾に限る。

`\='
     空の文字列に一致するが、ポイント位置に限る。（文字列に対する一致で
     はこの構文は定義されない。）

`\b'
     空の文字列に一致するが、単語の先頭や末尾に限る。したがって、
     `\bfoo\b'は、単語として独立して現れる`foo'に一致する。`\bballs?\b'
     は、単語として独立して現れる`ball'や`balls'に一致する。

     `\b'は、バッファの先頭や末尾にあるテキストとは無関係に、バッファの
     先頭や末尾にも一致する。

`\B'
     空の文字列に一致するが、単語の先頭や末尾*以外*に限る。

`\<'
     空の文字列に一致するが、単語の先頭に限る。`\<'はバッファの先頭にも
     一致するが、単語構成文字が続く場合に限る。

`\>'
     空の文字列に一致するが、単語の末尾に限る。`\>'はバッファの末尾にも
     一致するが、単語構成文字で終了している場合に限る。

任意の文字列が正しい正規表現ではありません。たとえば、（`[]]'のような少
数の例外を除けば）角括弧が対応していない文字列は正しくありませんし、1つ
の`\'で終る文字列も正しくありません。不正な正規表現を探索関数に渡すと、
エラー`invalid-regexp'が通知されます。

 -- Function: regexp-quote STRING
     この関数は、STRINGだけに正確に一致する正規表現の文字列を返す。これ
     により、正規表現を必要とする関数を呼び出すときにこの文字列だけに正
     確に一致できる。

          (regexp-quote "^The cat$")
               => "\\^The cat\\$"

     `regexp-quote'の用途の1つは、正規表現で記述された文脈に正確に一致す
     る文字列を組み合わせることである。たとえば、つぎは、白文字で囲まれ
     たSTRINGの値で表される文字列を探索する。

          (re-search-forward
           (concat "\\s-" (regexp-quote string) "\\s-"))

 -- Function: regexp-opt STRINGS &optional PAREN
     この関数は、文字列STRINGSのいずれかに一致する効率よい正規表現を返す。
     これは、たとえばフォントロック（font-lock）モードなどで、可能な限り
     高速な一致や探索を行う必要がある場合に有用である。

     省略可能な引数PARENが`nil'以外であると、返される正規表現はつねに少
     なくとも1つの括弧によるグループ構文で囲まれる。

     つぎの`regexp-opt'の簡略版定義は、実際の値に等価な（ただしそれほど
     効率よくない）正規表現を生成する。

          (defun regexp-opt (strings paren)
            (let ((open-paren (if paren "\\(" ""))
                  (close-paren (if paren "\\)" "")))
              (concat open-paren
                      (mapconcat 'regexp-quote strings "\\|")
                      close-paren)))

 -- Function: regexp-opt-depth REGEXP
     この関数は、REGEXP内のグループ化構文（括弧で括った式）の総個数を返
     す。



File: elisp-ja.info, Node: Regexp Example, Prev: Syntax of Regexps, Up: Regular Expressions

複雑な正規表現の例
------------------

ここでは、任意個数の白文字を伴った文末を認識するためにEmacsで使われてい
る複雑な正規表現について述べます。それは変数`sentence-end'の値です。

まず、タブ文字と空白を区別するためにLisp構文の文字列として正規表現を示し
ます。文字列定数はダブルクォートで始まり終ります。`\"'は文字列の一部とし
てのダブルクォート、`\\'は文字列の一部としてのバックスラッシュ、`\t'はタ
ブ、`\n'は改行を表します。

     "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

対照的に、変数`sentence-end'を評価するとつぎのようになっているはずです。

     sentence-end
          => "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[       
     ]*"

この出力では、タブと改行はそれ自身として現れています。

この正規表現には、連続してつぎのような4つの部分が含まれています。

`[.?!]'
     パターンの最初の部分は、3つの文字、ピリオド、疑問符、感嘆符のいずれ
     かに一致する文字選択である。一致部分はこれらの3つの文字の1つで始ま
     る必要がある。

`[]\"')}]*'
     パターンの2番目の部分は、ピリオド、疑問符、感嘆符のいずれかに続く、
     任意の閉じ括弧やクォーテーションマークの0個以上の繰り返しに一致する。
     `\"'は、文字列内のダブルクォートを表すLisp構文である。最後の`*'は、
     直前の正規表現（この場合は文字選択）を0回以上繰り返すことを表す。

`\\($\\| $\\|\t\\|  \\)'
     パターンの3番目の部分は、文末に続く白文字、つまり、（空白を伴うかも
     しれない）行末、1つのタブ、2つの空白のいずれかに一致する。2つのバッ
     クスラッシュは、括弧や縦棒を正規表現の構文にする。括弧はグループを
     区切り、縦棒は選択肢を区切る。ドル記号は行末に一致するために用いて
     いる。

`[ \t\n]*'
     パターンの最後の部分は、文末に最低限必要な白文字より余計な白文字に
     一致する。



File: elisp-ja.info, Node: Regexp Search, Next: POSIX Regexps, Prev: Regular Expressions, Up: Searching and Matching

正規表現の探索
==============

GNU Emacsでは、正規表現に一致するつぎの部分をインクリメンタルにもそうで
なくも探せます。インクリメンタルサーチコマンドについては、*Note 正規表現
探索: (emacs)Regexp Searchを参照してください。ここでは、プログラムで有用
な探索関数のみについて述べます。基本的なものは`re-search-forward'です。

これらの探索関数は、バッファがマルチバイトであれば正規表現をマルチバイト
に変換します。バッファがユニバイトであれば、正規表現をユニバイトに変換し
ます。*Note Text Representations::。

 -- コマンド: re-search-forward REGEXP &optional LIMIT NOERROR REPEAT
     この関数は、カレントバッファにおいて前方へ向けて正規表現REGEXPに一
     致するテキストの文字列を探索する。関数はREGEXPに一致しないテキスト
     はすべて飛び越え、みつけた一致箇所の末尾へポイントを置く。ポイント
     の新たな値を返す。

     LIMITが`nil'以外（カレントバッファ内の位置であること）であると、探
     索の上限を表す。その位置を越える箇所での一致は受け入れない。

     REPEATを指定してあると（正の数であること）、その回数だけ探索を繰り
     返す（一致箇所の末尾を新たな探索の開始位置とする）。連続してこれら
     の探索に成功すると関数は成功し、ポイントを移動してその新たな値を返
     す。さもなければ探索は失敗である。

     関数が失敗した場合の動作は、NOERRORの値に依存する。NOERRORが`nil'で
     あると、エラー`search-failed'を通知する。NOERRORが`t'であると、
     `re-search-forward'はなにもせずに`nil'を返す。NOERRORが`nil'でも`t'
     でもないと、`re-search-forward'はポイントをLIMIT（あるいはバッファ
     の末尾）へ移動して`nil'を返す。

     つぎの例では、ポイントは始めは`T'のまえにある。探索を呼び出すと、ポ
     イントは当該行の末尾（`hat'の`t'と改行のあいだ）へ移動する。

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (re-search-forward "[a-z]+" nil t 5)
               => 27

          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 -- コマンド: re-search-backward REGEXP &optional LIMIT NOERROR REPEAT
     この関数は、カレントバッファにおいて後方へ向けて正規表現REGEXPに一
     致するテキストの文字列を探索し、みつけた一致箇所の先頭へポイントを
     置く。

     この関数は`re-search-forward'に類似したものであるが、単純な鏡像では
     ない。`re-search-forward'は、一致箇所の先頭が開始位置に可能な限り近
     い一致箇所を探す。`re-search-backward'が完全な鏡像であれば、一致箇
     所の末尾が可能な限り近い一致箇所を探す。しかし、実際には、一致箇所
     の先頭が可能な限り近い一致箇所を探す。これは、正規表現との一致をと
     る処理は、指定開始位置において先頭から末尾へ向けてつねに行われるか
     らである。

     `re-search-forward'の完全な鏡像には、正規表現の一致を末尾から先頭へ
     向けて行う特別な機能が必要である。それを実装する手間をかけるほどの
     価値はない。

 -- Function: string-match REGEXP STRING &optional START
     この関数は、文字列STRINGにおいて正規表現REGEXPに一致した最初の箇所
     の添字を返す。あるいは、一致がなければ`nil'を返す。STARTが`nil'以外
     であると、STRINGの指定した添字から探索を始める。

     たとえばつぎのとおりである。

          (string-match
           "quick" "The quick brown fox jumped quickly.")
               => 4
          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               => 27

     文字列の最初の文字の添字は0であり、2番目の文字の添字は1であるといっ
     た具合になる。

     この関数から戻ったあとでは、一致箇所を越えた最初の文字の添字は
     `(match-end 0)'で得られる。*Note Match Data::。

          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               => 27

          (match-end 0)
               => 32

 -- Function: looking-at REGEXP
     この関数は、カレントバッファ内のポイントの直後のテキストが正規表現
     REGEXPに一致するかどうかを調べる。ここで『直後』とは、開始位置は固
     定されていて、ポイントのうしろの最初の文字で始まる場合にのみ探索は
     成功する。結果は、一致すれば`t'であり、さもなければ`nil'である。

     この関数はポイントを移動しないが、マッチデータを更新する。
     `match-beginning'や`match-end'を使ってマッチデータを参照できる。

     つぎの例では、ポイントは`T'の直前にある。ポイントがこれ以外の場所に
     あると結果は`nil'になる。

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-at "The cat in the hat$")
               => t



File: elisp-ja.info, Node: POSIX Regexps, Next: Search and Replace, Prev: Regexp Search, Up: Searching and Matching

POSIXの正規表現探索
===================

普通の正規表現関数は、`\|'や反復構文を扱うために必要なときにはバックトラッ
クしますが、これを行い続けるのは*なんらか*の一致をみつけるまでです。みつ
けてしまえば、それらは成功してみつけた最初の一致を報告します。

本節では、正規表現の一致に関するPOSIX規格で規定された完全なバックトラッ
クを行う代替の探索関数について述べます。それらはすべての可能性を試し尽く
しすべての一致箇所を探し終えるまでバックトラックを継続してます。そのため、
POSIXで要求されるとおりの最長の一致を報告できるのです。これは動作がとて
も遅いですから、最長一致が本当に必要な場合に限ってこれらの関数を使ってく
ださい。

 -- Function: posix-search-forward REGEXP &optional LIMIT NOERROR REPEAT
     これは`re-search-forward'と同様であるが、正規表現の一致に関する
     POSIX規格で規定された完全なバックトラックを行う。

 -- Function: posix-search-backward REGEXP &optional LIMIT NOERROR REPEAT
     これは`re-search-backward'と同様であるが、正規表現の一致に関する
     POSIX規格で規定された完全なバックトラックを行う。

 -- Function: posix-looking-at REGEXP
     これは`looking-at'と同様であるが、正規表現の一致に関するPOSIX規格で
     規定された完全なバックトラックを行う。

 -- Function: posix-string-match REGEXP STRING &optional START
     これは`string-match'と同様であるが、正規表現の一致に関するPOSIX規格
     で規定された完全なバックトラックを行う。




File: elisp-ja.info, Node: Search and Replace, Next: Match Data, Prev: POSIX Regexps, Up: Searching and Matching

探索と置換
==========

 -- Function: perform-replace FROM-STRING REPLACEMENTS QUERY-FLAG REGEXP-FLAG DELIMITED-FLAG &optional REPEAT-COUNT MAP
     この関数は、`query-replace'と関連するコマンドの中身である。
     FROM-STRINGの出現を探しだし、それらの一部やすべてを置き換える。
     QUERY-FLAGが`nil'であると、すべての出現を置換する。さもなければ、1
     つ1つユーザーにどうするかを問い合わせる。

     REGEXP-FLAGが`nil'以外であると、FROM-STRINGを正規表現として扱う。さ
     もなければ、その字面とおりに一致する。DELIMITED-FLAGが`nil'以外であ
     ると、単語区切りで囲まれたもののみを対象にする。

     引数REPLACEMENTSは、出現を置き換えるものを指定する。それが文字列で
     あれば、その文字列を使う。文字列のリストでもよく、要素を巡回して使
     う。

     REPEAT-COUNTが`nil'以外であれば、整数であること。これは、
     REPLACEMENTSのリスト内の各文字列をつぎに進めるまえに何回使用するか
     を指定する。

     通常、キーマップ`query-replace-map'で、可能なユーザーの応答を定義す
     る。引数MAPが`nil'以外であれば、`query-replace-map'のかわりに使うキー
     マップである。

 -- Variable: query-replace-map
     この変数は、`y-or-n-p'や`map-y-or-n-p'に加えて、`query-replace'や関
     連する関数に対する正しいユーザー応答を定義する特別なキーマップを保
     持する。2つの意味で普通のものではない。

        * 『キーバインディング』はコマンドではなく、このキーマップを用い
          る関数にのみ意味がある単なるシンボルである。

        * プレフィックスキーは扱えない。各キーバインディングは単一イベン
          トのキー列である必要がある。これは、関数では入力を得るために
          `read-key-sequence'を使わずに、『自前』でイベントを読み取り探
          索するからである。

`query-replace-map'向けの意味のある『バインディング』をつぎに示します。
`query-replace'と関連するものだけに意味のあるものもあります。

`act'
     当該動作を行う、いいかえれば『yes』。

`skip'
     この問いに対する動作は行わない、いいかえれば『no』。

`exit'
     この問いには『no』で答え、残りの応答も『no』と仮定して一連の問いを
     止める。

`act-and-exit'
     この問いには『yes』で答え、残りの応答は『no』と仮定して一連の問いを
     止める。

`act-and-show'
     この問いには『yes』で答えるが、結果を表示する。つぎの問いへは進まな
     い。

`automatic'
     この問いと以降の一連の問いに『yes』で答え、これ以降ユーザーに問い合
     わせない。

`backup'
     問いに答えたまえの箇所へ戻る。

`edit'
     この問いに対処するために、通常の動作のかわりに再帰編集に入る。

`delete-and-edit'
     対象のテキストを削除してから、それを置き換えるために再帰編集に入る。

`recenter'
     ウィンドウの中央に位置決めして再表示してから、同じ問いを問い直す。

`quit'
     ただちに中断する。`y-or-n-p'と関連する関数でのみ、この応答を用いる。

`help'
     ヘルプを表示してから、再度問い直す。



File: elisp-ja.info, Node: Match Data, Next: Searching and Case, Prev: Search and Replace, Up: Searching and Matching

マッチデータ
============

Emacsは、正規表現の探索中に捜し出したテキスト断片の開始／終了位置を記録
しています。つまり、たとえば、rmailメッセージ内で日付のような複雑なパター
ンを探索してから、パターンの制御をもとに一致した一部分を取り出せるのです。

マッチデータは、通常、もっとも最近に行った探索のみを記述するので、あとで
使用したい探索とそのマッチデータを使うあいだに、不注意に別の探索を行わな
いように注意してください。あいだで探索を行う必要がある場合には、その周り
でマッチデータを保存／復元してそれらが上書きされないようにします。

* Menu:

* Replacing Match::	  Replacing a substring that was matched.
* Simple Match Data::     Accessing single items of match data,
			    such as where a particular subexpression started.
* Entire Match Data::     Accessing the entire match data at once, as a list.
* Saving Match Data::     Saving and restoring the match data.



File: elisp-ja.info, Node: Replacing Match, Next: Simple Match Data, Prev: Match Data, Up: Match Data

一致したテキストの置換
----------------------

この関数は、最後の探索で一致したテキストをREPLACEMENTで置換します。

 -- Function: replace-match REPLACEMENT &optional FIXEDCASE LITERAL STRING SUBEXP
     この関数は、最後の探索で一致したバッファ内（あるいは文字列STRING）
     のテキストを置換する。当該テキストをREPLACEMENTで置き換える。

     バッファで最後に探索を行った場合には、STRINGに`nil'を指定すること。
     そうすると、`replace-match'はバッファを編集することで置換を行い、置
     換したテキストの末尾にポイントを置き`t'を返す。

     文字列で探索した場合には、STRINGに同じ文字列を渡すこと。そうすると、
     `replace-match'は新たな文字列を構築することで置換を行い、新たな文字
     列を返す。

     FIXEDCASEが`nil'以外であると、置換テキストの大文字小文字は変更しな
     い。さもなければ、置換テキストの大文字小文字は、対象テキストの大文
     字小文字に応じて変換される。元テキストがすべて大文字であると、置換
     テキストも大文字に変換される。元テキストの最初の単語が大文字で始まっ
     ていると、置換テキストの最初の単語も大文字で始める。元テキストが1単
     語のみであり、しかも、その単語が大文字1文字であると、
     `replace-match'はすべてが大文字ではなく大文字で始まるとみなす。

     `case-replace'が`nil'であると、FIXED-CASEの値に関わらず、大文字小文
     字変換を行わない。*Note Searching and Case::。

     LITERALが`nil'以外であると、必要に応じて大文字小文字変換は行うもの
     のREPLACEMENTをそのまま挿入する。それが`nil'（デフォルト）であると、
     文字`\'を特別に扱う。REPLACEMENTに`\'が現れるときには、つぎの列のい
     ずれかであること。

     `\&'
          `\&'は置換対象のテキスト全体を表す。

     `\N'
          Nを数字文字とすると`\N'は、もとの正規表現内のN番目の部分式に一
          致したテキストを表す。部分式とは、`\(...\)'で囲んでグループ化
          した式である。

     `\\'
          `\\'は置換テキスト内で1つの`\'を表す。

     SUBEXPが`nil'以外であると、一致箇所全体ではなく正規表現のSUBEXP番目
     の部分式に一致した箇所のみを置換することを指示する。たとえば、`foo
     \(ba*r\)'に一致させたあとで、SUBEXPに1を指定して`replace-match'を呼
     び出すと、`\(ba*r\)'に一致したテキストのみを置換することを意味する。



File: elisp-ja.info, Node: Simple Match Data, Next: Entire Match Data, Prev: Replacing Match, Up: Match Data

マッチデータの簡単な参照
------------------------

本節では、最後の探索や一致操作においてなにに一致したのかを調べるためのマッ
チデータの使い方を説明します。

一致したテキスト全体や正規表現の括弧で括った特定の部分式に一致したテキス
トを調べることができます。以下の関数の引数COUNTでどれかを指定します。
COUNTがゼロであれば、一致全体を調べることになります。COUNTが正であれば、
望みの部分式を指定します。

正規表現の部分式は、エスケープした括弧`\(...\)'でグループ化した式である
ことに注意してください。COUNT番目の部分式は、正規表現全体の先頭から`\('
の出現を数えてみつけます。最初の部分式は1、つぎは2、といった具合です。部
分式は正規表現だけにあります。単純な文字列探索のあとでは、利用可能な情報
は一致全体に関するものだけです。

探索に失敗すると、マッチデータを変更することもしないこともあります。過去
には探索に失敗しても変更しなかったのですが、将来そうなります。

 -- Function: match-string COUNT &optional IN-STRING
     この関数は、最後の探索や一致操作で一致したテキストを文字列として返
     す。COUNTがゼロであるとテキスト全体を返す。COUNTが正であれば、COUNT
     番目の括弧で囲んだ部分式に対応する部分のみを返す。COUNTが範囲を越え
     ていたり、当該部分式に一致するものがない場合には、値は`nil'である。

     最後の探索や一致操作を`string-match'で文字列に対して行った場合には、
     引数IN-STRINGとして同じ文字列を渡すこと。バッファの探索や一致のあと
     では、IN-STRINGを省略するか`nil'を渡すこと。ただし、`match-string'
     を呼び出すときのカレントバッファが探索を行ったときのバッファである
     こと。

 -- Function: match-string-no-properties COUNT
     この関数は`match-string'と同様であるが、結果にはテキスト属性を含ま
     ない。

 -- Function: match-beginning COUNT
     この関数は、最後の正規表現探索やその部分式に一致したテキストの開始
     位置を返す。

     COUNTがゼロであると、値は一致全体の開始位置である。さもなければ、
     COUNTは正規表現内の部分式を指定し、関数の値は当該部分式に一致した部
     分の開始位置である。

     一致に利用されなかった選択肢`\|'内の部分式に対しては、値は`nil'であ
     る。

 -- Function: match-end COUNT
     この関数は`match-beginning'と同様であるが、一致箇所の開始位置ではな
     く終了位置を返す点が異なる。

コメントでテキスト内の位置を示しながらマッチデータの利用例を示します。

     (string-match "\\(qu\\)\\(ick\\)"
                   "The quick fox jumped quickly.")
                   ;0123456789      
          => 4

     (match-string 0 "The quick fox jumped quickly.")
          => "quick"
     (match-string 1 "The quick fox jumped quickly.")
          => "qu"
     (match-string 2 "The quick fox jumped quickly.")
          => "ick"

     (match-beginning 1)       ; 一致箇所`qu'の先頭は
          => 4                 ;   添字4

     (match-beginning 2)       ; 一致箇所`ick'の先頭は
          => 6                 ;   添字6

     (match-end 1)             ; 一致箇所`qu'の末尾は
          => 6                 ;   添字6

     (match-end 2)             ; 一致箇所`ick'の末尾は
          => 9                 ;   添字9

別の例も示します。ポイントは始めは行頭にあります。探索によって、ポイント
は空白と単語`in'のあいだに移動します。一致箇所全体の先頭はバッファの9番
目の文字（`T'）であり、最初の部分式の一致箇所の先頭は13番目の文字（`c'）
です。

     (list
       (re-search-forward "The \\(cat \\)")
       (match-beginning 0)
       (match-beginning 1))
         => (9 9 13)

     ---------- Buffer: foo ----------
     I read "The cat -!-in the hat comes back" twice.
             ^   ^
             9  13
     ---------- Buffer: foo ----------

（この例では、返される添字はバッファ内位置であり、バッファの最初の文字を
1と数える。）



File: elisp-ja.info, Node: Entire Match Data, Next: Saving Match Data, Prev: Simple Match Data, Up: Match Data

マッチデータ全体を参照する
--------------------------

関数`match-data'と`set-match-data'は、マッチデータ全体を一度に読んだり書
いたりします。

 -- Function: match-data
     この関数は、最後の探索で一致したテキストに関するすべての情報を収め
     た新たに構築したリストを返す。要素0が式全体に一致した部分の先頭位置
     であり、要素1が式全体に一致した部分の終了位置である。つぎの2つの要
     素は最初の部分式に一致した部分の先頭／終了位置、といった具合である。
     一般に、要素番号2N は`(match-beginning N)'に対応し、要素番号2N + 1 
     は`(match-end N)'に対応する。

     バッファで行った一致ではすべての要素はマーカか`nil'であり、
     `string-match'により文字列で行った一致ではすべての要素は整数か`nil'
     である。

     探索関数の呼び出しとその探索結果としてのマッチデータを参照するため
     の`match-data'の呼び出しのあいだには、別の探索があってはならない。

          (match-data)
               =>  (#<marker at 9 in foo>
                    #<marker at 17 in foo>
                    #<marker at 13 in foo>
                    #<marker at 17 in foo>)

 -- Function: set-match-data MATCH-LIST
     この関数は、MATCH-LISTの要素からマッチデータを設定する。MATCH-LIST
     は、以前に`match-data'の呼び出しで得たリストであること。

     MATCH-LISTが存在しないバッファを指していても、エラーにはならない。
     無意味な情報をマッチデータに設定するが、害にはならない。

     `store-match-data'はほぼ廃れている`set-match-data'の別名である。



File: elisp-ja.info, Node: Saving Match Data, Prev: Entire Match Data, Up: Match Data

マッチデータの保存と復元
------------------------

探索を行う可能性がある関数を呼び出す場合、あとで使うためにそれ以前の探索
によるマッチデータを保存したいときには、当該関数の呼び出しの周りでマッチ
データを保存し復元する必要があります。つぎの例は、マッチデータを保存し損
なった場合に生じる問題点を示しています。

     (re-search-forward "The \\(cat \\)")
          => 48
     (foo)                   ; `foo'はさらに
                             ;   探索する
     (match-end 0)
          => 61              ; 予期しない結果。48でない！

マッチデータの保存と復元は`save-match-data'で行えます。

 -- Macro: save-match-data BODY...
     このマクロは、周りのマッチデータを保存し復元して、BODYを実行する。

スペシャルフォーム`save-match-data'の効果をまねるために`match-data'とと
もに`set-match-data'を使うこともできます。つぎのようにします。

     (let ((data (match-data)))
       (unwind-protect
           ...   ; もとのマッチデータを変更しても大丈夫
         (set-match-data data)))

プロセスフィルタ関数（*Note Filter Functions::）やプロセスの番兵（*Note
Sentinels::）を実行するときには、Emacsは自動的にマッチデータを保存し復元
します。




File: elisp-ja.info, Node: Searching and Case, Next: Standard Regexps, Prev: Match Data, Up: Searching and Matching

探索と大文字小文字
==================

デフォルトでは、Emacsの探索は探索対象テキストの大文字小文字を区別しませ
ん。`FOO'を探す指定を行うと、`Foo'や`foo'にも一致するとみなします。これ
は、正規表現にも適用されます。したがって、`[aB]'は、`a'や`A'や`b'や`B'に
一致します。

この機能を望まないときには、変数`case-fold-search'に`nil'を設定します。
すると、すべての文字は大文字小文字を保ってそのとおりに一致します。これは
バッファローカルな変数ですから、変数を変更してもカレントバッファだけに影
響します。（*Note Intro to Buffer-Local::。）あるいは、
`default-case-fold-search'の値を変更します。これは、`case-fold-search'を
書き変えていないバッファ向けのデフォルト値です。

ユーザーレベルのインクリメンタルサーチ機能では、大文字小文字の区別は異なっ
た扱い方をします。小英文字を与えるとその大文字にも一致しますが、大英文字
を与えると大文字のみに一致します。しかし、これはLispコードで使用している
探索関数にはまったく関係ありません。

 -- User Option: case-replace
     この変数は、置換関数が大文字小文字を保存するかどうかを決定する。変
     数が`nil'であると、置換テキストをそのまま使うことを意味する。`nil'
     以外の値であると、置換対象のテキストに応じて置換テキストの大文字小
     文字を変換することを意味する。

     この変数が実際に効果を発揮するのは関数`replace-match'においてである。
     *Note Replacing Match::。

 -- User Option: case-fold-search
     このバッファローカルな変数は、大文字小文字を区別して探索するかどう
     かを決定する。変数が`nil'であると大文字小文字を区別する。さもなけれ
     ば大文字小文字を区別しない。

 -- Variable: default-case-fold-search
     この変数の値は、`case-fold-search'を書き変えていないバッファ向けの
     デフォルト値である。これは`(default-value 'case-fold-search)'と同じ
     である。



File: elisp-ja.info, Node: Standard Regexps, Prev: Searching and Case, Up: Searching and Matching

編集に用いられる標準的な正規表現
================================

本節では、編集上の特定目的に用いられる正規表現を保持している変数について
述べます。

 -- Variable: page-delimiter
     これは、ページを区切る行頭を記述した正規表現である。デフォルト値は、
     `"^\014"'（つまり、`"^^L"'すなわち`"^\C-l"'）である。これはページ送
     り文字で始まる行に一致する。

つぎの2つの正規表現は、つねに行の先頭から一致が始まると仮定しては*いけま
せん*。一致の開始位置を固定する`^'を使うべきではありません。ほとんどの場
合、段落コマンドは行の先頭でのみ一致を検査しますから、`^'は不必要である
ことを意味します。幅0以外の左端余白があると、段落コマンドは左端余白のう
しろからの一致を受け入れます。そのような場合、`^'は誤りです。しかし、左
端余白をけっして使わないモードならば、`^'は無害です。

 -- Variable: paragraph-separate
     これは、段落を区切る行の始まりを認識するための正規表現である。
     （これを変更したら、`paragraph-start'も変更すること。）
     デフォルト値は`"[ \t\f]*$"'であり、
     （左端余白に続く）空白やタブやページ送りだけから成る行に一致する。

 -- Variable: paragraph-start
     これは、段落を始める行や区切る行の始まりを認識するための正規表現である。
     デフォルト値は`"[ \t\n\f]"'であり、
     （左端余白に続く）空白やタブやページ送りだけから成る行に一致する。

 -- Variable: sentence-end
     これは、文末を記述する正規表現である。（これに関わらず、段落の区切
     りも文末である。）デフォルト値はつぎのとおりである。

          "[.?!][]\"')}]*\\($\\| $\\|\t\\| \\)[ \t\n]*"

     これは、ピリオド、疑問符、感嘆符のいずれかのあとに閉じ括弧文字が続
     き（なくてもよい）、タブや空白や改行が続くことを意味する。

     この正規表現の詳しい説明は、*Note Regexp Example::を参照。


File: elisp-ja.info, Node: Syntax Tables, Next: Abbrevs, Prev: Searching and Matching, Up: Top

構文テーブル
************

"構文テーブル"（syntax table）は、各文字の構文的なテキスト上の機能を指定
します。この情報は、"構文解析関数"や複雑な移動を行うコマンドなどが単語や
シンボルなどの構文要素がどこで始まりどこで終るかを調べるために使います。
現在の構文テーブルが、本章の関数に加えて、単語単位の移動関数（*Note Word
Motion::）、リスト単位の移動関数（*Note List Motion::）の意味を制御しま
す。

* Menu:

* Basics: Syntax Basics.     Basic concepts of syntax tables.
* Desc: Syntax Descriptors.  How characters are classified.
* Syntax Table Functions::   How to create, examine and alter syntax tables.
* Syntax Properties::        Overriding syntax with text properties.
* Motion and Syntax::	     Moving over characters with certain syntaxes.
* Parsing Expressions::      Parsing balanced expressions
                                using the syntax table.
* Standard Syntax Tables::   Syntax tables used by various major modes.
* Syntax Table Internals::   How syntax table information is stored.
* Categories::               Another way of classifying character syntax.



File: elisp-ja.info, Node: Syntax Basics, Next: Syntax Descriptors, Prev: Syntax Tables, Up: Syntax Tables

構文テーブルの概念
==================

"構文テーブル"（syntax table）は、バッファ内の各文字の構文上の用途に関す
る情報をEmacsに与えます。この情報は、"構文解析関数"や複雑な移動を行うコ
マンドなどが単語やシンボルなどの構文要素がどこで始まりどこで終るかを調べ
るために使います。現在の構文テーブルが、本章の関数に加えて、単語単位の移
動関数（*Note Word Motion::）、リスト単位の移動関数（*Note List Motion::）
の意味を制御します。

構文テーブルは文字テーブル（*Note Char-Tables::）です。Cで添字付けられる
要素は、コードがCである文字について記述します。要素の値は、当該文字の構
文上の機能を符号化したリストです。

構文テーブルは、テキスト内を動き回るためにのみ使われ、EmacsのLispリーダ
はこれを使いません。Emacs LispがLisp式を読むときには、組み込みの構文規則
を使います。（入力構文を再定義する方法を与えるLispシステムもあるが、単純
であるようにEacs Lispではこの機能を省くことにした。）

各バッファには独自のメジャーモードがあり、各メジャーモードはさまざまな文
字の構文クラスを独自に扱います。たとえば、lispモードでは文字`;'はコメン
トを始めますが、Cモードでは文を終らせます。このような多様性を扱うために、
Emacsは各バッファごとにローカルな構文テーブルを選びます。典型的には、各
メジャーモードに独自の構文テーブルがあり、そのモードを使っているバッファ
に当該構文テーブルをインストールします。この構文テーブルを変更すると、同
じモードのバッファだけでなく将来そのモードになったバッファでも構文を変更
してしまいます。類似したモードでは1つの構文テーブルを共有することがあり
ます。構文テーブルの設定方法の例については、*Note Example Major Modes::。

構文テーブルでは、標準の構文テーブルから文字のデータを継承し、一方でその
他の文字に独自の指定を行えます。構文クラスの『継承』とは、『標準の構文テー
ブルから当該文字の構文を引き継ぐ』ことです。ある文字に対して標準の構文を
変更すると、それを継承するすべての構文テーブルに影響します。

 -- Function: syntax-table-p OBJECT
     この関数は、OBJECTが構文テーブルならば`t'を返す。



File: elisp-ja.info, Node: Syntax Descriptors, Next: Syntax Table Functions, Prev: Syntax Basics, Up: Syntax Tables

構文記述子
==========

本節では、文字の構文を指定する構文クラスと構文フラグ、それらを"構文記述
子"（syntax descriptor）としてどのように表現するかについて述べます。構文
記述子はLisp文字列であり、望みの構文を指定するために
`modify-syntax-entry'に渡します。

構文テーブルは、各文字の構文クラスを指定します。ある構文テーブルでの文字
のクラスと他の構文テーブルでの当該文字のクラスとのあいだにはなんの関係も
必要ありません。

各クラスはニーモニック文字（指定子）で区別します。ニーモニック文字は、ク
ラスを指定する必要があるときにクラス名として働きます。通常、指定子の文字
は当該クラスによく現れるものです。しかしながら、指定子としての意味は不変
で、その文字の現在の構文とは独立です。

構文記述子は、構文クラス、（括弧のクラスの場合にのみ使われる）釣り合う文
字、フラグを指定するLisp文字列です。最初の文字は、構文クラスを指定する文
字（指定子）です。2番目の文字はその文字に釣り合う文字ですが、使用しない
場合には空白です。そのあとに望みのフラグが続きます。釣り合う文字やフラグ
が必要なければ、文字1つだけで十分です。

たとえば、Cモードにおける文字`*'の構文記述子は
`. 23'（句読点、釣り合う文字なし、
コメント開始の2番目の文字、コメント終了の最初の文字）であり、
`/'は`. 14'（句読点、釣り合う文字なし、
コメント開始の最初の文字、コメント終了の2番目の文字）です。

* Menu:

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.



File: elisp-ja.info, Node: Syntax Class Table, Next: Syntax Flags, Prev: Syntax Descriptors, Up: Syntax Descriptors

構文クラス一覧
--------------

以下の一覧は、構文クラス、そのクラスを表す文字（指定子）、そのクラスの意
味、その使用例です。

 -- 構文クラス: 白文字（whitespace CHARACTER）
     "白文字"（` 'か`-'で指定）は、シンボルや単語を互いに区切る。典型的
     には、白文字には他の構文上の意味はなく、複数個の白文字は1つの白文字
     と構文的には等価である。ほとんどすべてのメジャーモードでは、空白、
     タブ、改行、ページ送りは白文字である。

 -- 構文クラス: 単語構成文字（word CONSTITUENT）
     "単語構成文字"（`w'で指定）は普通の英単語の一部分であり、典型的には、
     プログラムの変数やコマンド名に使われる。すべての大英文字、小英文字、
     数字文字は、典型的には単語構成文字である。

 -- 構文クラス: シンボル構成文字（symbol CONSTITUENT）
     "シンボル構成文字"（`_'で指定）は、単語構成文字に加えて、変数やコマ
     ンド名に使われる追加の文字である。たとえば、英単語の一部分ではない
     がシンボル名に使える特定の文字を指定するために、Lispモードではシン
     ボル構成文字クラスを使う。このような文字は`$&*+-_<>'である。標準のC
     では、単語構成文字でなくてシンボルに使える唯一の文字は下線（`_'）で
     ある。

 -- 構文クラス: 句読点文字（punctuation CHARACTER）
     "句読点文字"（`.'で指定）は、英文の句読点として使われたり、プログラ
     ム言語でシンボルを区切るために使われる文字である。emacs-lispモード
     を含むほとんどのプログラム言語向けモードでは、シンボル構成文字でも
     単語構成文字でもない少数の文字には別の用途があるため、このクラスの
     文字はない。

 -- 構文クラス: 開き括弧文字（open PARENTHESIS CHARACTER）
 -- 構文クラス: 閉じ括弧文字（close PARENTHESIS CHARACTER）
     開き／閉じ"括弧文字"は、文や式を囲む相異なる対として使われる文字で
     ある。そのようなグループ化は、開き括弧文字で始まり閉じ括弧文字で終
     る。各開き括弧文字は特定の閉じ括弧文字に対応し、その逆もいえる。
     Emacsは、通常、閉じ括弧文字を挿入すると対応する開き括弧文字を短時間
     指し示す。*Note Blinking::。

     開き括弧文字クラスは`('で指定し、閉じ括弧文字クラスは`)'で指定する。

     英文向けのテキスト（text）モードとCモードでは、括弧の対は、`()'、
     `[]'、`{}'である。Emacs Lispでは、リストとベクトルの区切り（`()'と
     `[]'）は、括弧文字としてクラス分けされる。

 -- 構文クラス: 文字列クォート（string QUOTE）
     "文字列クォート文字"（`"'で指定）は、LispやCを含む多くの言語で文字
     列定数を区切るために使われる。同じ文字列クォート文字が文字列の最初
     と最後に現れる。

     Emacsの構文解析機能では、文字列を1つの字句とみなす。文字列内の文字
     の普通の構文的な意味は抑制される。

     lisp向けのモードには文字列クォート文字が2つ、ダブルクォート（`"'）
     と縦棒（`|'）がある。`|'はEmacs Lispでは使わないがCommon Lispで使う。
     Cにも2つの文字列クォート文字、文字列用のダブルクォートと文字定数用
     のシングルクォート（`''）がある。

     英文はプログラム言語ではないので、英文には文字列クォート文字はない。
     英文でも引用符は用いるが、その内側の文字の普通の構文的な属性を抑制
     したくないのである。

 -- 構文クラス: エスケープ（escape）
     "エスケープ文字"（`\'で指定）は、Cの文字列や文字定数で使われるよう
     なエスケープシーケンスを開始する。CとLispでは、文字`\'はこのクラス
     に属する。（Cではこの文字は文字列の内側だけで使われるが、Cモードで
     つねにこのように扱っても問題ないことがわかった。）

     `words-include-escapes'が`nil'以外であると、このクラスの文字は単語
     の一部分と解釈される。*Note Word Motion::。

 -- 構文クラス: 文字クォート（character QUOTE）
     "文字クォート文字"（`/'で指定）は、後続の1文字をクォートし、通常の
     構文上の意味を抑制する。直後の1文字のみに影響するという点で、エスケー
     プ文字と異なる。

     `words-include-escapes'が`nil'以外であると、このクラスの文字は単語
     の一部分と解釈される。*Note Word Motion::。

     このクラスは、TeXモードのバックスラッシュに使われる。

 -- 構文クラス: 対になった区切り（paired DELIMITER）
     "対になった区切り文字"（`$'）は文字列クォート文字と同様であるが、区
     切り文字のあいだにある文字の構文上の属性を抑制しない点が異なる。現
     在、対になった区切りはTeXモードのみで使い、数学モードに出入りする
     `$'である。

 -- 構文クラス: 式前置子（expression PREFIX）
     "式前置演算子"（`''）は、式のまえに現れると式の一部であるとみなされ
     る構文上の演算子に使われる。lisp向けのモードでは、（クォートする）
     アポストロフ`''、（マクロで使う）コンマ`,'、（ある種のデータの入力
     構文に使われる）`#'の文字がそうである。

 -- 構文クラス: コメント開始（comment STARTER）
 -- 構文クラス: コメント終了（comment ENDER）
     "コメント開始"文字と"コメント終了"文字は、さまざまな言語でコメント
     を区切るために用いられる。これらのクラスは、それぞれ、`<'と`>'で指
     定する。

     英文にはコメント文字はない。Lispでは、セミコロン（`;'）でコメントが
     始まり、改行かページ送りで終る。

 -- 構文クラス: 継承（inherit）
     この構文クラスは特定の構文を指定しない。標準の構文テーブルで当該文
     字の構文を探す指定である。この構文クラスは`@'で指定する。

 -- 構文クラス: 汎用コメント区切り（generic COMMENT DELIMITER）
     "汎用コメント区切り"文字は、特別な種類のコメントを始めて終える文字
     である。*任意の*汎用コメント区切り文字は*任意の*汎用コメント区切り
     文字に対応するが、普通のコメント開始文字／コメント終了文字には対応
     しない。汎用コメント区切り文字同士のみで対応する。

     この構文クラスは、主にテキスト属性`syntax-table' （*Note Syntax
     Properties::）で使うことを意図したものである。任意の範囲の文字がコ
     メントを形成すると印を付けるには、その範囲の先頭と末尾の文字にそれ
     らが汎用コメント区切りであることを識別する属性`syntax-table'を与え
     る。

 -- 構文クラス: 汎用文字列区切り（generic STRING DELIMITER）
     "汎用文字列区切り"文字は、文字列を始めて終える。このクラスは文字列
     クォートクラスと異なり、汎用文字列区切りは他の汎用文字列区切りに対
     応し、普通の文字列クォート文字には対応しない。

     この構文クラスは、主にテキスト属性`syntax-table' （*Note Syntax
     Properties::）で使うことを意図したものである。任意の範囲の文字が文
     字列定数を形成すると印を付けるには、その範囲の先頭と末尾の文字にそ
     れらが汎用文字列区切りであることを識別する属性`syntax-table'を与え
     る。



File: elisp-ja.info, Node: Syntax Flags, Prev: Syntax Class Table, Up: Syntax Descriptors

構文フラグ
----------

構文テーブルの各文字には、構文クラスに加えて、フラグも指定できます。文字
`1'、`2'、`3'、`4'、`b'、`p'で表現される6つの可能なフラグがあります。

`p'を除くすべてのフラグは、複数の文字から成るコメント区切りの記述に使い
ます。数字フラグは、当該文字のクラスで表される構文上の属性に*加えて*、コ
メント列の一部分でもあることを示します。フラグはクラスや他のフラグとは独
立であり、Cモードの`*'のような文字のためにあります。Cモードの`*'は、句読
点文字である*とともに*、コメント開始列の2番目の文字`/*'*でも*あり、コメ
ント終了列の最初の文字`*/'*でも*あります。

文字Cに対して可能なフラグとそれらの意味を以下に示します。

   * `1'は、Cが2文字のコメント開始列を始めることを意味する。

   * `2'は、Cがそのような列の2番目の文字であることを意味する。

   * `3'は、Cが2文字のコメント終了列を始めることを意味する。

   * `4'は、Cがそのような列の2番目の文字であることを意味する。

   * `b'は、コメント区切りとしてのCがもう1つの『b』形式のコメントに属す
     ることを意味する。

     Emacsでは、任意の1つの構文テーブルで2つの形式のコメントを同時に扱え
     る。これはC++のためである。コメント構文の各形式には、独自の開始列と
     独自の終了列がある。各コメントはどちらか1つの形式である必要がある。
     したがって、『b』形式のコメント開始列で始まるものは、『b』形式のコ
     メント終了列で終る必要がある。

     2つのコメント開始列は同じ文字で始まる必要があり、2文字目のみが異な
     る。『b』形式のコメント開始列の2番目の文字にフラグ`b'を付ける。

     （1文字か2文字の）コメント終了列は、その最初の文字にフラグ`b'が付い
     ていると『b』形式に適用する。さもなければ『a』形式に適用する。

     C++向けの適切なコメント構文の設定はつぎのとおりである。

     `/'
          `124b'
     `*'
          `23'
     newline
          `>b'

     これは4つのコメント区切り列を定義する。

     `/*'
          2文字目の`*'にはフラグ`b'がないので、これは『a』形式のコメント
          開始列である。

     `//'
          2文字目の`/'にはフラグ`b'があるので、これは『b』形式のコメント
          開始列である。

     `*/'
          2文字目の`*'にはフラグ`b'がないので、これは『a』形式のコメント
          終了列である。

     newline
          改行にはフラグ`b'があるので、これは『b』形式のコメント終了列で
          ある。

   * `p'は、Lisp構文向けの追加の『前置文字』を示す。これらの文字は式のあ
     いだに現れるときには白文字として扱う。式の内側に現れると、それらの
     通常の構文コードに従って扱われる。

     関数`backward-prefix-chars'は後方へ向けて移動するときには、構文クラ
     スが式前置子（`''）である文字に加えてこれらの文字も飛び越す。*Note
     Motion and Syntax::。



File: elisp-ja.info, Node: Syntax Table Functions, Next: Syntax Properties, Prev: Syntax Descriptors, Up: Syntax Tables

構文テーブル向け関数
====================

本節では、構文テーブルを作成／参照／変更するための関数について述べます。

 -- Function: make-syntax-table
     この関数は、新たな構文テーブルを作成する。英文字やコントロール文字
     の構文は標準の構文テーブルから継承する。他の文字の構文は標準の構文
     テーブルからコピーする。

     ほとんどのメジャーモードの構文テーブルはこのように作成する。

 -- Function: copy-syntax-table &optional TABLE
     この関数は、構文テーブルTABLEのコピーを作成しそれを返す。TABLEを指
     定しないと（あるいは`nil'）、現在の構文テーブルのコピーを返す。
     TABLEが構文テーブルでないとエラーを通知する。

 -- コマンド: modify-syntax-entry CHAR SYNTAX-DESCRIPTOR &optional TABLE
     この関数は、文字CHARの構文指定を構文記述子SYNTAX-DESCRIPTORとする。
     構文テーブルTABLEにおいてのみ構文を変更し、他の構文テーブルは変更し
     ない。TABLEのデフォルトはカレントバッファの構文テーブルである。
     SYNTAX-DESCRIPTORで望みの構文を指定する。これは、クラス指定子で始ま
     り、必要に応じて釣り合う文字とフラグを含む文字列である。*Note
     Syntax Descriptors::。

     この関数はつねに`nil'を返す。当該構文テーブルにおけるこの文字に対す
     る古い構文情報は破棄される。

     構文記述子の最初の文字が12個の構文クラス指定子の1つでないとエラーを
     通知する。CHARが文字でなくてもエラーを通知する。

     【例】

          ;; 空白文字をクラス白文字にする
          (modify-syntax-entry ?\  " ")
               => nil

          ;; `$'を開き括弧文字にする
          ;;   対応する閉じる文字は`^'である
          (modify-syntax-entry ?$ "(^")
               => nil

          ;; `^'を閉じ括弧文字にする
          ;;   対応する開く文字は`$'である
          (modify-syntax-entry ?^ ")$")
               => nil

          ;; `/'を句読点文字にする
          ;;   コメント開始列の最初の文字、および、
          ;;   コメント終了列の2番目の文字にもする
          ;;   これはCモードで用いられる
          (modify-syntax-entry ?/ ". 14")
               => nil

 -- Function: char-syntax CHARACTER
     この関数は、文字CHARACTERの構文クラスを指定子で表したもので返す。こ
     れは構文クラス*のみ*を返し、釣り合う文字や構文フラグは返さない。

     CHARが文字でないとエラーを通知する。

     つぎの例はCモードにあてはまる。最初の例は、空白の構文クラスが（空白
     で表現される）白文字であることを示す。2番目の例は、`/'の構文が句読
     点であることを示す。これは、この文字がコメント開始／終了の一部分で
     もあることは示さない。3番目の例は、開き括弧は開き括弧クラスであるこ
     とを示す。これは、この文字に釣り合う文字が`)'であることは示さない。

          (string (char-syntax ?\ ))
               => " "

          (string (char-syntax ?/))
               => "."

          (string (char-syntax ?\())
               => "("

     ここでは、`char-syntax'が返す文字を見やすくするために`string'を用い
     た。

 -- Function: set-syntax-table TABLE
     この関数は、TABLEをカレントバッファの構文テーブルにする。TABLEを返
     す。

 -- Function: syntax-table
     この関数は、現在の構文テーブル、つまり、カレントバッファの構文テー
     ブルを返す。



File: elisp-ja.info, Node: Syntax Properties, Next: Motion and Syntax, Prev: Syntax Table Functions, Up: Syntax Tables

構文属性
========

言語の構文を指定するに十分なほど構文テーブルに柔軟性がないときには、バッ
ファ内の特定の文字の出現に対して構文テーブルに優先するテキスト属性
`syntax-table'を指定できます。*Note Text Properties::。

テキスト属性`syntax-table'の正しい値はつぎのとおりです。

SYNTAX-TABLE
     属性値が構文テーブルであると、文字のこの出現に対する構文を判定する
     ためにカレントバッファの構文テーブルのかわりにこのテーブルを用いる。

`(SYNTAX-CODE . MATCHING-CHAR)'
     この形のコンスセルは、文字のこの出現の構文を指定する。

`nil'
     属性が`nil'であると、通常どおり、現在の構文テーブルから文字の構文を
     判定する。

 -- Variable: parse-sexp-lookup-properties
     これが`nil'以外であると、構文を解析する関数は、テキスト属性による構
     文指定に注意を払う。さもなければ、現在の構文テーブルのみを用いる。



File: elisp-ja.info, Node: Motion and Syntax, Next: Parsing Expressions, Prev: Syntax Properties, Up: Syntax Tables

移動と構文
==========

本節では、特定の構文クラスを持つ文字を越えて移動するための関数について述
べます。

 -- Function: skip-syntax-forward SYNTAXES &optional LIMIT
     この関数は、SYNTAXESで指定される構文クラスを持つ文字を越えてポイン
     トを前方へ向けて移動する。バッファの末尾、（指定されていれば）LIMIT
     の位置、飛び越さない文字のいずれかに出会うと停止する。戻り値は移動
     距離であり非負整数である。

 -- Function: skip-syntax-backward SYNTAXES &optional LIMIT
     この関数は、SYNTAXESで指定される構文クラスである文字を越えてポイン
     トを後方へ向けて移動する。バッファの先頭、（指定されていれば）LIMIT
     の位置、飛び越さない文字のいずれかに出会うと停止する。

     戻り値は移動距離である。それはゼロか負の整数である。

 -- Function: backward-prefix-chars
     この関数は、式前置子構文の文字を飛び越えてポイントを後方へ向けて移
     動する。式前置子クラスやフラグ`p'を持つ文字を飛び越す。



File: elisp-ja.info, Node: Parsing Expressions, Next: Standard Syntax Tables, Prev: Motion and Syntax, Up: Syntax Tables

釣り合った式の解析
==================

ここでは、括弧が対になっている"S式"（sexp）とも呼ばれる釣り合った式を解
析したり走査する関数について述べます。構文テーブルで文字の解釈を制御する
ことで、LispモードではLispの式に対して、CモードではCの式に対してこれらの
関数を用いることができます。釣り合った式を飛び越えて移動するための便利な
上位レベルの関数については、*Note List Motion::。

 -- Function: parse-partial-sexp START LIMIT &optional TARGET-DEPTH STOP-BEFORE STATE STOP-COMMENT
     この関数は、カレントバッファのSTARTから始まるS式を解析するが、LIMIT
     を越えては走査しない。位置LIMITで止まるか、以下に述べる条件が満たさ
     れると解析を停止し、当該箇所にポイントを置く。ポイントを置いた箇所
     での解析状況を表す値を返す。

     STATEが`nil'であると、位置STARTは、関数定義の先頭のような括弧の構造
     のトップレベルであると仮定する。あるいは、構造の途中から解析を再開
     したい場合もある。それには、解析の初期状態を引数STATEに指定する必要
     がある。

     3番目の引数TARGET-DEPTHが`nil'以外であると、括弧の深さが
     TARGET-DEPTHに等しくなると解析を停止する。深さは0、あるいは、STATE
     で指定された値から始まる。

     4番目の引数STOP-BEFOREが`nil'以外であると、S式を始める文字に出会う
     と解析を停止する。STOP-COMMENTが`nil'以外であると、コメントの始まり
     に出会うと解析を停止する。STOP-COMMENTがシンボル`syntax-table'であ
     ると、コメントや文字列の始まり、コメントや文字列の終りのいずれかに
     出会ったあとで解析を停止する。

     5番目の引数STATEは9要素のリストであり、以下に述べるようにこの関数の
     値と同じ形である。（9番目の最後の要素は省いてもよい。）
     `parse-partial-sexp'の呼び出しの戻り値を、別の`parse-partial-sexp'
     の呼び出しの解析状態の初期値に使ってよい。

     結果は、解析の最終状態を記述した9要素のリストである。

       0. 0から数えた括弧の深さ。

       1. ポイントを停止した箇所を含むもっとも内側の括弧式の開始位置。な
          ければ`nil'。

       2. 閉じている最後の完全な部分式の開始位置。なければ`nil'。

       3. 文字列の内側であると`nil'以外である。より正確には、これは文字
          列を終える文字である。あるいは、汎用文字列区切り文字で終えると
          きには`t'である。

       4. （どちらかの形式の）コメントの内側であると`t'である。

       5. ポイントがクォート文字の直後であると`t'である。

       6. この解析中に出会った最小の括弧の深さ。

       7. どの形式のコメントが活性であるかを表す。『a』形式であると`nil'、
          『b』形式であると`t'、汎用コメント区切り文字で終るコメントの場
          合には`syntax-table'である。

       8. 文字列やコメントの開始位置。コメントの内側であるときにはこれは
          コメントの開始位置であり、文字列の内側であるときにはこれは文字
          列の開始位置である。文字列やコメントの外側では、この要素は
          `nil'である。

     引数STATEでは、要素0、3、4、5、7は重要である。

     この関数は、入れ子にあった括弧を持つ言語向けに字下げを計算するため
     にしばしば用いられる。

 -- Function: scan-lists FROM COUNT DEPTH
     この関数は、位置FROMから前方へ向けてCOUNT個の釣り合った括弧のグルー
     プを走査する。走査を停止した位置を返す。COUNTが負であると、後方へ向
     けて走査する。

     DEPTHが0以外であると、括弧の深さをその値から数え始める。停止箇所の
     候補位置は、括弧の深さが0になる箇所である。`scan-lists'は、そのよう
     な箇所をCOUNT回数えてから停止する。したがって、DEPTHに正の値を指定
     すると、括弧のレベルをDEPTHレベルだけ抜けることを意味する。

     `parse-sexp-ignore-comments'が`nil'以外であると、コメントを無視して
     走査する。

     走査がバッファ（あるいはその参照可能部分）の先頭や末尾に達し、深さ
     が0でないと、エラーを通知する。深さは0であるが指定個数だけ数えてな
     い場合には、`nil'を返す。

 -- Function: scan-sexps FROM COUNT
     この関数は、位置FROMから前方へ向けてCOUNT個のS式を走査する。走査を
     終えた位置を返す。COUNTが負であると、後方へ向けて移動する。

     `parse-sexp-ignore-comments'が`nil'以外であると、コメントを無視して
     走査する。

     走査が括弧によるグループの途中でバッファ（あるいはその参照可能部分）
     の先頭や末尾に達すると、エラーを通知する。指定個数だけ数えるまえに
     括弧によるグループのあいだで先頭や末尾に達した場合は`nil'を返す。

 -- Variable: parse-sexp-ignore-comments
     値が`nil'以外であると、本節の関数や`forward-sexp'は、コメントを白文
     字として扱う。

     Emacsの古い版では、コメントの終了が`*/'のような形であり、かつ、コメ
     ントの終了と思える場合にのみ、この機能は動作した。改行でコメントを
     終える言語では、改行すべてがコメントの終りではないために、この変数
     を`nil'にする必要があった。このような制限事項はすでにない。

`forward-comment'を使うと、1つのコメントや複数のコメントを飛び越えて前後
に移動できます。

 -- Function: forward-comment COUNT
     この関数は、ポイントを前方へ向けて（COUNTが負ならば後方へ向けて）
     COUNT個のコメントを飛び越えて移動する。コメントか白文字以外のものに
     出会うと停止し、当該箇所にポイントを置く。COUNT個だけ数えたあとにも
     もちろん停止する。

ポイントに続くすべてのコメントと白文字を飛び越えるには、
`(forward-comment (buffer-size))'を使います。バッファ内のコメントの個数
は`(buffer-size)'を越えるはずがないので、引数に使うには`(buffer-size)'は
よいものです。



File: elisp-ja.info, Node: Standard Syntax Tables, Next: Syntax Table Internals, Prev: Parsing Expressions, Up: Syntax Tables

標準的な構文テーブル
====================

Emacsのほとんどのメジャーモードにはそれ独自の構文テーブルがあります。そ
れらのいくつかをつぎに示します。

 -- Function: standard-syntax-table
     この関数は、基本（fundamental）モードで使用する構文テーブルである標
     準の構文テーブルを返す。

 -- Variable: text-mode-syntax-table
     この変数の値は、テキスト（text）モードで使用する構文テーブルである。

 -- Variable: c-mode-syntax-table
     この変数の値は、Cモードのバッファ向けの構文テーブルである。

 -- Variable: emacs-lisp-mode-syntax-table
     この変数の値は、編集コマンドがemacs-lispモードで使用する構文テーブ
     ルである。（これはLispの関数`read'にはなんの効果もない。）



File: elisp-ja.info, Node: Syntax Table Internals, Next: Categories, Prev: Standard Syntax Tables, Up: Syntax Tables

構文テーブルの内部
==================

Lispプログラムでは普通は構文テーブルの要素を直接には操作しません。Lispレ
ベルの構文テーブル関数は、普通は構文記述子（*Note Syntax Descriptors::）
を操作します。ですが、内部形式を明文化しておきます。

構文テーブルの各要素は、`(SYNTAX-CODE . MATCHING-CHAR)'の形のコンスセル
です。CARのSYNTAX-CODEは、構文クラスと構文フラグを符号化する整数です。釣
り合う文字を指定してあると、CDRのMATCHING-CHARは`nil'以外です。

つぎの表は、各構文クラスに対応するSYNTAX-CODEの値です。

                                                                                     
    整数 クラス                整数 クラス                整数 クラス                
                                                                      
    0 whitespace          5 close parenthesis   10 character quote    
                                                                                      
    　 白文字                 　 閉じ括弧                　 文字クォート              
                                                                      
    1 punctuation         6 expression prefix   11 comment-start      
                                                                                      
    　 句読点                 　 式前置子                　 コメント開始              
                                                                      
    2 word                7 string quote        12 comment-end        
                                                                                        
    　 単語                  　 文字列クォート             　 コメント終了              
                                                                      
    3 symbol              8 paired delimiter    13 inherit            
                                                                                       
    　 シンボル                　 対になった区切り            　 継承                  
                                                                      
    4 open parenthesis    9 escape              14 comment-fence      
                                                                                         
    　 開き括弧                　 エスケープ               　 コメント区切り             
                                                                      
    15 string-fence                                                   
                                                                             
    　 文字列区切り                                                          

たとえば、`('の普通の構文値は、`(4 . 41)'です。（41は`)'の文字コード。）

フラグは、最下位ビットから16番目のビットから始まる上位ビットに符号化しま
す。つぎの表は、各構文フラグとそれに対応する2の巾です。

                                                                                     
    フラグ 2の巾               フラグ 2の巾               フラグ 2の巾               
                                                                      
    `1' `(lsh 1 16)'      `3' `(lsh 1 18)'      `p' `(lsh 1 20)'      
                                                                      
    `2' `(lsh 1 17)'      `4' `(lsh 1 19)'      `b' `(lsh 1 21)'      



