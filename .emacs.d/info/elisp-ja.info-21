Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Categories, Prev: Syntax Table Internals, Up: Syntax Tables

カテゴリ
========

"カテゴリ"（category）は、文字を構文的に分類する別の方法です。必要に応じ
て複数のカテゴリを定義できて、そうすると各文字に1つか複数のカテゴリを独
立に設定できます。構文クラスと異なり、カテゴリは互いに排他的ではありませ
ん。1つの文字が複数のカテゴリに属することは普通にあります。

各バッファには"カテゴリテーブル"（category table）があり、どのカテゴリが
定義済みでどの文字がどのカテゴリに属するかを記録しています。各カテゴリテー
ブルはそれ独自のカテゴリ群を定義しますが、それらは標準のカテゴリテーブル
をコピーして普通は初期化されます。そのため、すべてのモードで標準のカテゴ
リを使えます。

各カテゴリには名前があり、それは` 'から`~'までの
範囲のASCII印字文字です。
`define-category'でカテゴリを定義するときにその名前を指定します。

カテゴリテーブルは実際には文字テーブル（*Note Char-Tables::）です。カテ
ゴリテーブルの添字Cの要素は、"カテゴリ集合"（category set）です。これは
ブールベクトルであり、文字Cが属するカテゴリ群を表します。このカテゴリ集
合において、添字CATの要素が`t'であると、CATは集合の要素であることを意味
し、当該文字CはカテゴリCATに属することを意味します。

 -- Function: define-category CHAR DOCSTRING &optional TABLE
     この関数は、名前をCHAR、説明文字列をDOCSTRINGとして新たなカテゴリを
     定義する。

     新たなカテゴリは、カテゴリテーブルTABLEに対して定義される。TABLEの
     デフォルトは、カレントバッファのカテゴリテーブルである。

 -- Function: category-docstring CATEGORY &optional TABLE
     この関数は、カテゴリテーブルTABLEのカテゴリCATEGORYの説明文字列を返
     す。

          (category-docstring ?a)
               => "ASCII"
          (category-docstring ?l)
               => "Latin"

 -- Function: get-unused-category TABLE
     この関数は、カテゴリテーブルTABLEで現在定義されていない新たなカテゴ
     リ名（文字）を返す。TABLEにおいて可能なすべてのカテゴリが使用済みで
     あると`nil'を返す。

 -- Function: category-table
     この関数は、カレントバッファのカテゴリテーブルを返す。

 -- Function: category-table-p OBJECT
     この関数は、OBJECTがカテゴリテーブルであると`t'を返し、さもなければ
     `nil'を返す。

 -- Function: standard-category-table
     この関数は、標準のカテゴリテーブルを返す。

 -- Function: copy-category-table &optional TABLE
     この関数は、カテゴリテーブルTABLEのコピーを作成しそれを返す。TABLE
     を指定しない（あるいは`nil'）と、現在のカテゴリテーブルのコピーを返
     す。TABLEがカテゴリテーブルでないとエラーを通知する。

 -- Function: set-category-table TABLE
     この関数は、カレントバッファのカテゴリテーブルをTABLEとする。TABLE
     を返す。

 -- Function: make-category-set CATEGORIES
     この関数は、新たなカテゴリ集合、つまり、文字列CATEGORIESに指定した
     カテゴリで内容を初期化したブールベクトルを返す。CATEGORIESの要素は
     カテゴリ名であること。新たなカテゴリ集合では、CATEGORIESの各カテゴ
     リに対しては`t'をそれ以外のカテゴリに対しては`nil'を設定する。

          (make-category-set "al")
               => #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: char-category-set CHAR
     この関数は、文字CHARに対するカテゴリ集合を返す。これは、文字CHARが
     属するカテゴリ群を記録したブールベクトルである。関数
     `char-category-set'は、カテゴリテーブルに存在する同じブールベクトル
     を返すため、新たな領域を割り付けない。

          (char-category-set ?a)
               => #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

 -- Function: category-set-mnemonics CATEGORY-SET
     この関数は、カテゴリ集合CATEGORY-SETをこの集合に属するすべてのカテ
     ゴリの名前からなる文字列に変換する。

          (category-set-mnemonics (char-category-set ?a))
               => "al"

 -- Function: modify-category-entry CHARACTER CATEGORY &optional TABLE RESET
     この関数は、カテゴリテーブルTABLE（デフォルトはカレントバッファのカ
     テゴリテーブル）内の文字CHARACTERのカテゴリ集合を変更する。

     普通、カテゴリ集合にCATEGORYを追加して変更する。しかし、RESETが
     `nil'以外であるとCATEGORYを削除する。


File: elisp-ja.info, Node: Abbrevs, Next: Processes, Prev: Syntax Tables, Up: Top

略語と略語の展開
****************

"略語"（abbrev）とは、より長い文字列へ展開される文字の列のことです。ユー
ザーが略語の文字列を挿入すると、その展開形に自動的に置換されます。これに
より打鍵量を省けます。

現在有効な略語の集まりは、"略語表"（abbrev table）に記録されています。各
バッファにはローカルな略語表がありますが、通常、同じメジャーモードのすべ
てのバッファは1つの略語表を共有します。グローバルな略語表もあります。通
常、両方を使います。

略語表は、各略語に対するシンボルを収めたオブジェクト配列として表現されま
す。シンボルの名前が略語です。その値は展開形であり、その関数定義は展開を
行うフック関数です。その属性リストのセルには略語を展開した回数である利用
回数が入ります。それらのシンボルは、通常のオブジェクト配列にはインターン
されませんから、Lisp式を読み取った結果には、それらはけっして現れません。
実際、略語を扱うコード以外では、それらはけっして使われません。したがって、
それらをかなり非標準的に使っても安全です。*Note Creating Symbols::。

ユーザーレベルの略語コマンドについては、*Note 略語の利用法:
(emacs)Abbrevsを参照してください。

* Menu:

* Abbrev Mode::                 Setting up Emacs for abbreviation.
* Tables: Abbrev Tables.        Creating and working with abbrev tables.
* Defining Abbrevs::            Specifying abbreviations and their expansions.
* Files: Abbrev Files.          Saving abbrevs in files.
* Expansion: Abbrev Expansion.  Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::      Abbrev tables used by various major modes.



File: elisp-ja.info, Node: Abbrev Mode, Next: Abbrev Tables, Prev: Abbrevs, Up: Abbrevs

略語（abbrev）モードの設定
==========================

略語（abbrev）モードは、変数`abbrev-mode'の値で制御されるマイナモードで
す。

 -- Variable: abbrev-mode
     この変数の値が`nil'以外であると、バッファに略語が挿入されると自動的
     に展開するようになる。値が`nil'であると、略語を定義することはできる
     が、自動的には展開されない。

     この変数は設定されると自動的にバッファローカルになる。

 -- Variable: default-abbrev-mode
     これは、`abbrev-mode'を上書きしていないバッファ向けの`abbrev-mode'
     の値である。これは`(default-value 'abbrev-mode)'と同じである。



File: elisp-ja.info, Node: Abbrev Tables, Next: Defining Abbrevs, Prev: Abbrev Mode, Up: Abbrevs

略語表
======

本節では、略語表の作成方法と扱い方について述べます。

 -- Function: make-abbrev-table
     この関数は、新たな空の略語表、つまり、シンボルを含まないオブジェク
     ト配列を作成して返す。ベクトルはゼロで埋められる。

 -- Function: clear-abbrev-table TABLE
     この関数は、略語表TABLE内のすべての略語を未定義にして略語表を空にす
     る。関数は`nil'を返す。

 -- Function: define-abbrev-table TABNAME DEFINITIONS
     この関数は、TABNAME（シンボル）を略語表の名前として定義する。つまり、
     この変数としての値は略語表になる。DEFINITIONSに従って略語表に略語を
     定義する。ここで、DEFINITIONSは`(ABBREVNAME EXPANSION HOOK
     USECOUNT)'の形の要素から成るリストである。戻り値はつねに`nil'である。

 -- Variable: abbrev-table-name-list
     その値が略語表であるシンボルのリストである。`define-abbrev-table'は、
     新たな略語表の名前をこのリストに追加する。

 -- Function: insert-abbrev-table-description NAME &optional HUMAN
     この関数は、NAMEで指名される略語表の記述をポイントのまえに挿入する。
     引数NAMEは、その値が略語表であるシンボルである。戻り値はつねに`nil'
     である。

     HUMANが`nil'以外であると、この記述は人間向けである。さもなければ、
     この記述はLisp式、つまり、NAMEの現在の定義どおりにNAMEを定義するよ
     うな`define-abbrev-table'の呼び出しである。



File: elisp-ja.info, Node: Defining Abbrevs, Next: Abbrev Files, Prev: Abbrev Tables, Up: Abbrevs

略語を定義する
==============

これらの関数は、指定した略語表に略語を定義します。`define-abbrev'は下位
レベルの基本的な関数ですが、`add-abbrev'はユーザーに情報を問い合わせるコ
マンドが使います。

 -- Function: add-abbrev TABLE TYPE ARG
     この関数は、ユーザーからの情報に基づいて略語表TABLEに略語を追加する。
     引数TYPEは、この略語の種類を英語で表した文字列である（典型的には、
     `"global"'や`"mode-specific"'。）この文字列はユーザーへのプロンプト
     に使われる。引数ARGは、展開形の単語数である。

     戻り値は、新たな略語を内部的に表現するシンボルであるか、既存の略語
     を再定義することをユーザーが拒否したときには`nil'である。

 -- Function: define-abbrev TABLE NAME EXPANSION HOOK
     この関数は、略語表TABLEにおいて、略語NAMEをEXPANSIONに展開するよう
     に定義し、HOOKを呼び出すように定義する。戻り値は、Emacs内部で略語を
     表現するシンボルを返すが、その名前はNAMEである。

     引数NAMEは文字列であること。引数EXPANSIONは、普通は、目的の展開形
     （文字列）であるが、略語を未定義にするには`nil'である。これが文字列
     でも`nil'でもなければ、略語を『展開する』ときにはHOOKだけを実行する。

     引数HOOKは、関数か`nil'である。HOOKが`nil'以外であると、略語を
     EXPANSIONに置換し終えてから引数なしで呼ばれる。HOOKが呼ばれるときに
     は、ポイントはEXPANSIONの直後に置かれる。

     略語の利用回数は0に初期化される。

 -- User Option: only-global-abbrevs
     この変数が`nil'以外であると、ユーザーはグローバルな略語だけを使う意
     図があることを表す。モード固有の略語を定義するコマンドに対して、グ
     ローバルな略語を定義するように指示する。この変数は本節の関数のふる
     まいを変えることはないが、それらを呼び出す側でこの変数を検査してい
     る。



File: elisp-ja.info, Node: Abbrev Files, Next: Abbrev Expansion, Prev: Defining Abbrevs, Up: Abbrevs

略語をファイルに保存する
========================

略語定義を保存したファイルは、実際には、Lispコードのファイルです。略語は、
同じ内容の同じ略語表を定義するLispプログラムの形で保存されます。したがっ
て、ファイルは`load'（*Note How Programs Do Loading::）でロードできます。
しかし、関数`quietly-read-abbrev-file'がより便利なインターフェイスを提供
します。

`save-some-buffers'などのユーザーレベルの機能では、ここに述べた変数の制
御のもとで、略語をファイルに自動的に保存できます。

 -- User Option: abbrev-file-name
     これは、略語を読み込んだり保存するデフォルトのファイル名である。

 -- Function: quietly-read-abbrev-file FILENAME
     この関数は、`write-abbrev-file'で書いておいたファイルFILENAMEから、
     略語定義を読み取る。FILENAMEが`nil'であると、`abbrev-file-name'で指
     定されるファイルを使う。`save-abbrevs'に`t'を設定して、変更は保存さ
     れるようにする。

     この関数はいっさいメッセージを表示しない。`nil'を返す。

 -- User Option: save-abbrevs
     `save-abbrev'が`nil'以外の値であると、Emacsはファイルを保存するとき
     に略語も保存する。`abbrev-file-name'が略語を保存するファイルを指定
     する。

 -- Variable: abbrevs-changed
     略語を定義したり変更すると、この変数は`nil'以外に設定される。これは、
     読者の略語を保存する機会を与えるために、Emacsのさまざまなコマンドに
     対するフラグとして働く。

 -- コマンド: write-abbrev-file FILENAME
     ロードすると同じ略語を定義するようなLispプログラムの形で、ファイル
     FILENAMEにすべての略語表のすべての略語定義を保存する。この関数は
     `nil'を返す。



File: elisp-ja.info, Node: Abbrev Expansion, Next: Standard Abbrev Tables, Prev: Abbrev Files, Up: Abbrevs

略語の探索と展開
================

通常、略語は、`self-insert-command'を含む特定の対話的なコマンドによって
展開されます。本節では、データのやりとりに使う変数に加えて、そのようなコ
マンドを書くために使用するサブルーティンについて述べます。

 -- Function: abbrev-symbol ABBREV &optional TABLE
     この関数は、名前ABBREVの略語を表すシンボルを返す。そのような略語が
     定義されていなければ、戻り値は`nil'である。省略可能な第2引数TABLEは、
     探索対象の略語表である。TABLEが`nil'であると、この関数は、まずカレ
     ントバッファのローカルな略語表を試し、つぎにグローバルな略語表を試
     す。

 -- Function: abbrev-expansion ABBREV &optional TABLE
     この関数は、ABBREVが（カレントバッファで使用される略語表での定義ど
     おりに）展開されるであろう文字列を返す。省略可能な引数TABLEは、
     `abbrev-symbol'と同様に、使用する略語表を指定する。

 -- コマンド: expand-abbrev
     このコマンドは、ポイントのまえの略語をあれば展開する。略語の直後に
     ポイントがない場合、このコマンドはなにもしない。このコマンドは、展
     開を行えば`t'を返し、さもなければ`nil'を返す。

 -- コマンド: abbrev-prefix-mark &optional ARG
     現在のポイント位置を略語の開始位置としてマークする。つぎに
     `expand-abbrev'を呼び出すと、通常どおりにポイントのまえの単語を使う
     かわりに、ここから（その時点での）ポイントまでのテキストを略語とし
     て展開する。

 -- User Option: abbrev-all-caps
     これが`nil'以外であると、大文字だけで入力された略語を大文字だけで展
     開する。さもなければ、大文字だけで入力された略語は、展開形の各単語
     を大文字で始めるように展開される。

 -- Variable: abbrev-start-location
     これは、`expand-abbrev'がつぎに展開する略語の開始位置として使うバッ
     ファ内位置である。（`nil'であると、そのかわりにポイントのまえの単語
     を使う意味である。）`expand-abbrev'が呼び出されるたびに、
     `abbrev-start-location'は`nil'に設定される。この変数は、
     `abbrev-prefix-mark'でも設定される。

 -- Variable: abbrev-start-location-buffer
     この変数の値は、`abbrev-start-location'が設定されたバッファである。
     別のバッファで略語を展開しようとすると`abbrev-start-location'はクリ
     アされる。この変数は`abbrev-prefix-mark'が設定する。

 -- Variable: last-abbrev
     これは、もっとも最近に略語展開された`abbrev-symbol' （略語を表すシ
     ンボル）である。この情報は、コマンド`unexpand-abbrev'向けに
     `expand-abbrev'が残す（*Note 略語展開の制御: (emacs)Expanding
     Abbrevs.）。

 -- Variable: last-abbrev-location
     これは、もっとも最近に略語展開した箇所である。これは、コマンド
     `unexpand-abbrev'向けに`expand-abbrev'が残した情報を保持する。

 -- Variable: last-abbrev-text
     これは、もっとも最近に略語展開したときの（あれば）大文字小文字変換
     後の展開形のテキストである。略語展開を取り消すと、この値は`nil'であ
     る。これは、コマンド`unexpand-abbrev'向けに`expand-abbrev'が残した
     情報を保持する。

 -- Variable: pre-abbrev-expand-hook
     これは、任意の略語を展開する直前に順に実行される関数を収めたノーマ
     ルフックである。*Note Hooks::。ノーマルフックなので、フック関数は引
     数を受け取らない。しかし、バッファでポイントのまえを調べることで展
     開すべき略語をみつけることができる。

以下のコード例は、`pre-abbrev-expand-hook'の使い方を示します。ユーザーが
略語を句読点文字で終えると、フック関数が確認を求めます。したがって、この
フックにより、ユーザーは展開の可否を決定でき、了承しなかったときには展開
を止められます。

     (add-hook 'pre-abbrev-expand-hook 'query-if-not-space)

     ;; この関数は、`pre-abbrev-expand-hook'が起動する

     ;; ユーザーが略語を空白で終えると、この関数はなにもしない
     ;; （つまり、略語を展開できるように戻る）
     ;; ユーザーがその他の文字を入力したら、
     ;; この関数は展開するかどうかを問い合わせる

     ;; ユーザーがプロンプトにyで答えたら、
     ;; （関数`not'を使っているので）この関数は`nil'を返すが
     ;; 問題ない。戻り値は展開には影響しない

     (defun query-if-not-space ()
       (if (/= ?\  (preceding-char))
           (if (not (y-or-n-p "Do you want to expand this abbrev? "))
               (error "Not expanding this abbrev"))))



File: elisp-ja.info, Node: Standard Abbrev Tables, Prev: Abbrev Expansion, Up: Abbrevs

標準の略語表
============

Emacsにあらかじめロードされるメジャーモード向けの略語表を保持する変数一
覧を示します。

 -- Variable: global-abbrev-table
     これは、モードに依存しない略語向けの略語表である。これに定義された
     略語は、すべてのバッファに適用される。各バッファにはローカルな略語
     表もあり、それらの略語定義はグローバルな略語表の略語定義に優先する。

 -- Variable: local-abbrev-table
     このバッファローカルな変数の値はカレントバッファの（モード固有の）
     略語表である。

 -- Variable: fundamental-mode-abbrev-table
     これは、基本（fundamental）モードで使われるローカルな略語表である。
     いいかえれば、基本（fundamental）モードであるすべてのバッファのロー
     カルな略語表である。

 -- Variable: text-mode-abbrev-table
     これは、テキスト（text）モードで使われるローカルな略語表である。

 -- Variable: lisp-mode-abbrev-table
     これは、lispモードとemacs-lispモードで使われるローカルな略語表であ
     る。


File: elisp-ja.info, Node: Processes, Next: System Interface, Prev: Abbrevs, Up: Top

プロセス
********

オペレーティングシステムの用語では、"プロセス"（process）とは、プログラ
ムを実行する空間のことです。Emacsはプロセスとして動いています。Emacs
Lispのプログラムでは、独自のプロセスとして他のプログラムを起動できます。
それらは、Emacsプロセスの"サブプロセス"（subprocess）とか"子プロセス"
（child process）と呼ばれ、Emacsプロセスはそれらの"親プロセス"（parent
process）です。

Emacsのサブプロセスは、それを作成する方法に依存して、"同期"（synchronous）
であるか"非同期"（asynchronous）です。同期サブプロセスを作成すると、Lisp
プログラムは実行を継続するまえにそのサブプロセスの終了を待ちます。非同期
サブプロセスを作成すると、それはLispプログラムと並行して動作します。この
種のサブプロセスは、Emacs内部ではやはり『プロセス』と呼ばれるLispオブジェ
クトで表現されます。Lispプログラムはこのオブジェクトを用いてサブプロセス
と通信したりそれを制御できます。たとえば、シグナルを送ったり、状態情報を
取得したり、プロセスからの出力を受け取ったり、プロセスへ入力を送れます。

 -- Function: processp OBJECT
     この関数は、OBJECTがプロセスであれば`t'を返し、さもなければ`nil'を
     返す。

* Menu:

* Subprocess Creation::      Functions that start subprocesses.
* Shell Arguments::          Quoting an argument to pass it to a shell.
* Synchronous Processes::    Details of using synchronous subprocesses.
* Asynchronous Processes::   Starting up an asynchronous subprocess.
* Deleting Processes::       Eliminating an asynchronous subprocess.
* Process Information::      Accessing run-status and other attributes.
* Input to Processes::       Sending input to an asynchronous subprocess.
* Signals to Processes::     Stopping, continuing or interrupting
                               an asynchronous subprocess.
* Output from Processes::    Collecting output from an asynchronous subprocess.
* Sentinels::                Sentinels run when process run-status changes.
* Transaction Queues::	     Transaction-based communication with subprocesses.
* Network::                  Opening network connections.



File: elisp-ja.info, Node: Subprocess Creation, Next: Shell Arguments, Prev: Processes, Up: Processes

サブプロセス作成関数
====================

プログラムを実行するために新たなサブプロセスを作る関数が3つあります。そ
の1つ`start-process'は、非同期プロセスを作成してプロセスオブジェクトを返
します（*Note Asynchronous Processes::）。残りの2つ、`call-process'と
`call-process-region'は同期プロセスを作成しますが、プロセスオブジェクト
は返しません（*Note Synchronous Processes::）。

同期／非同期プロセスについては以下の節に述べます。3つの関数の呼び出し方
は類似しているので、ここではそれらに共通な引数について述べます。

いずれの場合でも、関数の引数PROGRAMは、実行すべきプログラムを指定します。
そのファイルがみつからなかったり実行できないと、エラーを通知します。ファ
イル名が相対名であると、変数`exec-path'は探索すべきディレクトリのリスト
を保持しています。Emacsは起動時に環境変数`PATH'の値に基づいて`exec-path'
を初期化します。`~'、`.'、`..'のファイル名の標準的な書き方は、
`exec-path'でも普通どおりに解釈されますが、（`$HOME'などの）環境変数の置
換は認識しません。それには`substitute-in-file-name'を使います（*Note
File Name Expansion::）。

サブプロセスを作成する各関数には、プログラムの標準出力の受け取り場所を指
定する引数BUFFER-OR-NAMEがあります。これはバッファかバッファ名である必要
があります。バッファ名であると、そのバッファが既存でなければ新たに作成し
ます。`nil'でもかまいませんが、その場合、フィルタ関数で処理しない限り出
力を破棄します。（*Note Filter Functions::と*Note Read and Print::）。通
常、複数のプロセスの出力を同じバッファへは送らないようにします。それらの
出力がでたらめに混ざってしまうからです。

サブプロセスを作成する3つの関数すべてに、`&rest'引数であるARGSがあります。
ARGSはすべてが文字列である必要があり、それぞれを区切ってコマンド行引数と
してPROGRAMに与えられます。引数全体を指定されたプログラムへ直接渡すため、
これらの引数ではワイルドカード文字や他のシェル構文の特別な意味はありませ
ん。

*注意*：` '引数PROGRAMにはプログラムの名前だけを指定し、コマンド行引数は
いっさい指定しない。コマンド行引数はARGSで与えること。

サブプロセスのカレントディレクトリは`default-directory'の値で決まります
（*Note File Name Expansion::）。

サブプロセスはEmacsから環境変数を継承しますが、優先するものを
`process-environment'で指定できます。*Note System Environment::。

 -- Variable: exec-directory
     この変数の値は、Emaccsが起動することを意図したGNU Emacsとともに配布
     されたプログラム群を収めたディレクトリ名（文字列）である。プログラ
     ム`movemail'はそのようなプログラムの例であり、inboxから新たなメイル
     を取り出すためにrmailが利用する。

 -- User Option: exec-path
     この変数の値は、サブプロセスで実行するプログラムを探索するディレク
     トリのリストである。各要素はディレクトリ名（文字列）であるか、デフォ
     ルトディレクトリ（つまり`default-directory'の値）を意味する`nil'で
     ある。

     引数PROGRAMが絶対ファイル名でないと、`call-process'と
     `start-process'は`exec-path'の値を使う。



File: elisp-ja.info, Node: Shell Arguments, Next: Synchronous Processes, Prev: Subprocess Creation, Up: Processes

シェル引数
==========

Lispプログラムから、ユーザーが指定したファイル名を含んだコマンドを指定し
てシェルを実行する必要がときどきあります。これらのプログラムでは、任意の
正しいファイル名を扱える必要があります。しかし、シェルは、特定の文字がファ
イル名として現れると特別に扱うので、そのような文字がシェルに混乱をもたら
します。そのような文字を扱うには、関数`shell-quote-argument'を使います。

 -- Function: shell-quote-argument ARGUMENT
     この関数は、ARGUMENTを実際の内容とするシェル構文で表した引数を文字
     列で返す。この戻り値をシェルコマンドに連結し、実行のためにシェルに
     渡しても問題を生じないはずである。

     この関数が行うことの詳細は読者のオペレーティングシステムに依存する。
     この関数は通常のシェル構文に合うように設計してある。非標準のシェル
     を使う場合には、この関数を再定義する必要があろう。MS-DOSでは、この
     関数はARGUMENTを無変更で返す。MS-DOSのシェルにはクォートの機能がな
     いため、これは本当は正しいことではないが最良のことである。

          ;; つぎの例はGNUとUNIXシステムのふるまいである
          (shell-quote-argument "foo > bar")
               => "foo\\ \\>\\ bar"

     シェルコマンドを作る`shell-quote-argument'の使用例をつぎに示す。

          (concat "diff -c "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))



File: elisp-ja.info, Node: Synchronous Processes, Next: Asynchronous Processes, Prev: Shell Arguments, Up: Processes

同期プロセスの作成
==================

"同期プロセス"（synchronous process）を作成すると、Emacsは実行を続行する
まえにそのプロセスが終了するのを待ちます。diredはその例です。`ls'を同期
プロセスで実行し、その出力を少々修正します。プロセスは同期なので、Emacs
がなにかを行おうとするまえにディレクトリ一覧全部がバッファに届きます。

Emacsは同期サブプロセスの終了を待ちますが、ユーザーは`C-g'と打って中断で
きます。`C-g'はまずシグナル`SIGINT'でサブプロセスをキルしようとしますが、
中断を完了するまえにサブプロセスが終了するのを待ちます。その期間にユーザー
がさらに`C-g'を打つと、`SIGKILL'でサブプロセスを即座にキルし、ただちに中
断を完了します。*Note Quitting::。

同期サブプロセス作成関数は、そのプロセスがどのように終了したかを表すもの
を返します。

同期サブプロセスからの出力は、ファイルから読むテキストと同様に、コーディ
ングシステムを用いて一般には復号化します。`call-process-region'がサブプ
ロセスへ送る入力は、ファイルへ書くテキストと同様に、コーディングシステム
を用いて符号化します。*Note Coding Systems::。

 -- Function: call-process PROGRAM &optional INFILE DESTINATION DISPLAY &rest ARGS
     この関数は、別のプロセスでPROGRAMを呼び出し、それが終了するのを待つ。

     INFILEが`nil'でなければプロセスへの標準入力はINFILEであるが、さもな
     ければ`/dev/null'である。引数DESTINATIONでプロセスの出力先をつぎの
     ように指定する。

     バッファ
          このバッファのポイントのまえに出力を挿入する。これにはプロセス
          の標準出力と標準エラーの両者を含む。

     文字列
          文字列で指定した名前のバッファのポイントのまえに出力を挿入する。

     `t'
          カレントバッファのポイントのまえに出力を挿入する。

     `nil'
          出力を破棄する。

     0
          出力を破棄し、サブプロセスの終了を待たずにただちに戻る。

          この場合、このプロセスはEmacsと並行して動作するので真のサブプ
          ロセスではない。しかし、この関数から戻るとEmacsはサブプロセス
          の処理を本質的には終えたという意味で同期プロセスと考えることが
          できる。

     `(REAL-DESTINATION ERROR-DESTINATION)'
          標準出力と標準エラーを分離し、REAL-DESTINATIONの指定に従って通
          常の出力を扱い、ERROR-DESTINATIONに従ってエラー出力を処理する。
          ERROR-DESTINATIONが`nil'であるとエラー出力を破棄し、`t'である
          と通常の出力に混ぜ、文字列であるとその名前のファイルにエラー出
          力を振り向ける。

          エラー出力を入れるバッファを直接に指定することはできない。それ
          を実装するのは難しすぎる。しかし、エラー出力を一時ファイルへ送っ
          てからそのファイルをバッファに挿入すれば、同じ効果を得られる。

     DISPLAYが`nil'以外であると、`call-process'は、出力が挿入されるとバッ
     ファを再表示する。（しかし、コーディングシステムとして実際のデータ
     からコーディングシステムを推定する`undecided'を指定していると、非
     ASCII文字に出会うと再表示を継続できない場合もある。これを修正するの
     が困難である根本的な理由がある。）さもなければ、関数`call-process'
     は再表示しないので、Emacsが通常の過程でそのバッファを再表示するまで
     は、スクリーン上で結果は見えない。

     残りの引数ARGSは、プログラムに対するコマンド行引数を指定する文字列
     である。

     （待たないように指示しない限り）`call-process'が返す値は、プロセス
     の終了理由を表す。数でサブプロセスの終了状態を表し、0は成功、それ以
     外の値は失敗を意味する。プロセスがシグナルで終了すると、
     `call-process'はシグナルを記述する文字列を返す。

     つぎの例では、バッファ`foo'がカレントである。

          (call-process "pwd" nil t)
               => nil

          ---------- Buffer: foo ----------
          /usr/user/lewis/manual
          ---------- Buffer: foo ----------

          (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
               => nil

          ---------- Buffer: bar ----------
          lewis:5LTsHm66CSWKg:398:21:Bil Lewis:/user/lewis:/bin/csh

          ---------- Buffer: bar ----------

     `insert-directory'の定義にある`call-process'のよい使用例をつぎに示
     す。

          (call-process insert-directory-program nil t nil SWITCHES
                        (if full-directory-p
                            (concat (file-name-as-directory file) ".")
                          file))

 -- Function: call-process-region START END PROGRAM &optional DELETE DESTINATION DISPLAY &rest ARGS
     この関数は、PROGRAMを動かすプロセスの標準入力としてSTARTとENDのあい
     だのテキストを送る。DELETEが`nil'以外であると、送ったテキストを削除
     する。これは、カレントバッファに送った入力のかわりに出力を挿入する
     ことを意味するDESTINATIONが`t'であるときに有用である。

     引数DESTINATIONとDISPLAYは、サブプロセスからの出力をどのように扱い、
     出力か到着するたびに表示を更新するかどうかを制御する。詳しくは、上
     記の`call-process'の記述を参照。DESTINATIONが整数0であると、
     `call-process-region'は、サブプロセスの終了を待たずに出力を破棄して
     ただちに`nil'を返す。

     残りの引数ARGSは、プログラムに対するコマンド行引数を指定する文字列
     である。

     `call-process-region'の戻り値は`call-process'と同様であり、待たずに
     戻るように指示すると`nil'であり、さもなければサブプロセスの終了状態
     を表す数か文字列である。

     つぎの例では、バッファ`foo'の始めの5文字（単語`input'）を標準入力と
     してユーティリティ`cat'を実行するために`call-process-region'を使う。
     `cat'は、標準入力を標準出力へコピーする。引数DESTINATIONが`t'である
     ので、出力はカレントバッファに挿入される。

          ---------- Buffer: foo ----------
          input-!-
          ---------- Buffer: foo ----------

          (call-process-region 1 6 "cat" nil t)
               => nil

          ---------- Buffer: foo ----------
          inputinput-!-
          ---------- Buffer: foo ----------

     コマンド`shell-command-on-region'は、つぎのように
     `call-process-region'を使う。

          (call-process-region 
           start end         
           shell-file-name      ; プログラムの名前
           nil                  ; リージョンを削除しない
           buffer               ; 出力は`buffer'へ入れる
           nil                  ; 出力中は再表示しない
           "-c" command)        ; シェルに対する引数

 -- Function: shell-command-to-string COMMAND
     この関数は、シェルコマンドとしてCOMMAND（文字列）を実行し、コマンド
     の出力を文字列として返す。



File: elisp-ja.info, Node: Asynchronous Processes, Next: Deleting Processes, Prev: Synchronous Processes, Up: Processes

非同期プロセスの作成
====================

"非同期プロセス"を作成すると、Emacsとサブプロセスの両者はただちに動作を
継続します。そしてプロセスはEmacsと並行に動作し、両者は以下の節に述べる
関数を用いて互いに通信できます。しかし、通信は部分的に非同期です。特定の
関数を呼び出したときにだけEmacsはプロセスへデータを送り、Emacsが入力待ち
か時間待ちをしているときにだけプロセスからの出力を受け取れます。

ここでは、非同期プロセスの作成方法について述べます。

 -- Function: start-process NAME BUFFER-OR-NAME PROGRAM &rest ARGS
     この関数は、新たな非同期サブプロセスを作成し、そのプロセスでプログ
     ラムPROGRAMを走らせる。Lispにおいて新たなサブプロセスを表すプロセス
     オブジェクトを返す。引数NAMEはプロセスオブジェクトの名前を指定する。
     その名前のプロセスがすでに存在すると、名前を一意にするために（`<1>'
     などを付加して）NAMEを修正する。バッファBUFFER-OR-NAMEは、そのプロ
     セスに対応付けるバッファである。

     残りの引数ARGSは、プログラムに対するコマンド行引数を指定する文字列
     である。

     つぎの例では、最初のプロセスは動き始めると100秒間（休止ではなく）動
     作する。そのあいだに2番目のプロセスを動かし始めると、一意であるため
     にそれには名前`my-process<1>'が与えられる。2番目のプロセスは、最初
     のプロセスが終了するまえにバッファ`foo'にディレクトリ一覧を挿入する。
     2番目のプロセスが終了するとそれを表すメッセージがバッファに挿入され
     る。しばらくして最初のプロセスが終了すると、別のメッセージがバッファ
     に挿入される。

          (start-process "my-process" "foo" "sleep" "100")
               => #<process my-process>

          (start-process "my-process" "foo" "ls" "-l" "/user/lewis/bin")
               => #<process my-process<1>>

          ---------- Buffer: foo ----------
          total 2
          lrwxrwxrwx  1 lewis     14 Jul 22 10:12 gnuemacs --> /emacs
          -rwxrwxrwx  1 lewis     19 Jul 30 21:02 lemon

          Process my-process<1> finished

          Process my-process finished
          ---------- Buffer: foo ----------

 -- Function: start-process-shell-command NAME BUFFER-OR-NAME COMMAND &rest COMMAND-ARGS
     この関数は`start-process'と同様であるが、指定したコマンドを実行する
     ためにシェルを用いる点が異なる。引数COMMANDはシェルコマンドの名前で
     あり、COMMAND-ARGSはそのシェルコマンドに対する引数である。変数
     `shell-file-name'は、使用するシェルを指定する。

     `start-process'で直接にではなくシェルを介してプログラムを実行すると、
     引数のワイルドカードなどのシェルの機能を利用できる。つまり、ユーザー
     指定の任意のファイル名をコマンドに入れる場合には、まえもって
     `shell-quote-argument'でクォートし、ファイル名内のシェルの特別な文
     字がそのような特別な意味を持た*ない*ようにする。*Note Shell
     Arguments::。

 -- Variable: process-connection-type
     この変数は、非同期サブプロセスとの通信に用いる装置の型を制御する。
     これが`nil'以外であると疑似端末PTYを利用できる場合にはそれを用る。
     さもなければパイプを用いる。

     シェル（shell）モードなどのユーザーに見えるプロセス向けには、パイプ
     では不可能なプロセスとその子プロセスとのあいだでジョブ制御（`C-c'、
     `C-z'など）を許すので疑似端末PTYが望ましい。プログラムの内部目的向
     けに使われるサブプロセスでは、効率的なパイプを用いるほうがよい。ま
     た、多くのシステムでは疑似端末PTYの総数には制約があり、それらを浪費
     しないほうがよい。

     `process-connection-type'の値は`start-process'を呼び出したときに使
     われる。したがって、`start-process'の呼び出しの周りでこの変数を束縛
     することで、1つのサブプロセスに対する通信方法を指定できる。

          (let ((process-connection-type nil))  ; パイプを使う
            (start-process ...))

     サブプロセスが実際にはパイプか疑似端末PTYのどちらを使っているかを調
     べるには、関数`process-tty-name'を使う（*Note Process Informatio
     n::）。



File: elisp-ja.info, Node: Deleting Processes, Next: Process Information, Prev: Asynchronous Processes, Up: Processes

プロセスの削除
==============

"プロセスを削除する"とは、サブプロセスからEmacsをただちに切り離し、サブ
プロセスを活性なプロセスリストから取り除くことです。サブプロセスへシグナ
ルを送ってサブプロセスを終了させますが、ただちに終了するとは保証されませ
ん。プロセスオブジェクトを指すLispオブジェクトがある限り、プロセスオブジェ
クトは存在し続けます。プロセスマークは以前と同様に同じ場所（プロセスから
の出力をバッファに挿入した箇所）を指し続けます。

プロセスはいつでも明示的に削除できます。プロセスは終了後に自動的に削除さ
れますが、終了後ただちにではありません。終了したプロセスが自動的に削除さ
れるまえに明示的に削除しても無害です。

 -- User Option: delete-exited-processes
     この変数は、（`exit'を呼び出すかシグナルのために）終了したプロセス
     の自動削除を制御する。`nil'であると、ユーザーが`list-processes'を実
     行するまで存在し続ける。さもなければ、終了後にただちに削除する。

 -- Function: delete-process NAME
     この関数は、NAMEに対応付けられたプロセスをシグナル`SIGHUP'でキルし
     削除する。引数は、プロセス、プロセス名、バッファ、バッファ名のいず
     れかである。

          (delete-process "*shell*")
               => nil

 -- Function: process-kill-without-query PROCESS &optional DO-QUERY
     この関数は、Emacsを終了するときにプロセスPROCESSが動作中であると、
     ユーザーに問い合わせるかどうかを指定する。DO-QUERYが`nil'であると、
     プロセスを黙って削除する。さもなければ、Emacsはプロセスのキルに関し
     て問い合わせる。

     問い合わせるようにしてあったプロセスであると戻り値は`t'であり、さも
     なければ戻り値は`nil'である。新たに作成されたプロセスは、つねに問い
     合わせ用になっている。

          (process-kill-without-query (get-process "shell"))
               => t



File: elisp-ja.info, Node: Process Information, Next: Input to Processes, Prev: Deleting Processes, Up: Processes

プロセス情報
============

プロセスに関する情報を返す関数がいくつかあります。`list-processes'は対話
的利用のためにあります。

 -- コマンド: list-processes
     このコマンドは、活性なすべてのプロセスの一覧を表示する。さらに、
     `Exited'や`Signaled'である状態のプロセスをすべて削除する。`nil'を返
     す。

 -- Function: process-list
     この関数は、削除されていないすべてのプロセスのリストを返す。

          (process-list)
               => (#<process display-time> #<process shell>)

 -- Function: get-process NAME
     この関数はNAMEという名前のプロセスを返す。あるいは、そのようなプロ
     セスがなければ`nil'を返す。NAMEが文字列でないとエラーを通知する。

          (get-process "shell")
               => #<process shell>

 -- Function: process-command PROCESS
     この関数は、プロセスPROCESSを始動するために実行したコマンドを返す。
     これは文字列のリストであり、最初の文字列は実行されたプログラム、残
     りの文字列はそのプログラムに与えた引数である。

          (process-command (get-process "shell"))
               => ("/bin/csh" "-i")

 -- Function: process-id PROCESS
     この関数は、プロセスPROCESSのプロセス番号PIDを返す。これは同じ計算
     機上で動いている他のすべてのプロセスとプロセスPROCESSを区別するため
     の整数である。プロセスのPIDは、プロセスを始動したときにオペレーティ
     ングシステムのカーネルが選び、プロセスが終了するまで変わらない。

 -- Function: process-name PROCESS
     この関数はプロセスPROCESSの名前を返す。

 -- Function: process-contact PROCESS
     この関数は、通常の子プロセスに対しては`t'を返し、ネットワーク接続に
     対しては`(HOSTNAME SERVICE)'を返す（*Note Network::）。

 -- Function: process-status PROCESS-NAME
     この関数は、PROCESS-NAMEの状態をシンボルとして返す。引数
     PROCESS-NAMEは、プロセス、バッファ、プロセス名（文字列）、バッファ
     名（文字列）のいずれかであること。

     実際のサブプロセスに対して可能な値はつぎのとおり。

     `run'
          実行中のプロセスである。
     `stop'
          一時停止しているが継続可能である。
     `exit'
          終了したプロセス。
     `signal'
          致命的なシグナルを受け取ったプロセスである。
     `open'
          ネットワーク接続を開いている。
     `closed'
          ネットワーク接続は閉じている。接続をいったん閉じるとそれを再度
          開くことはできないが、同じ接続先へ新たな接続を開くことはできる。
     `nil'
          PROCESS-NAMEは既存プロセスの名前ではない。

          (process-status "shell")
               => run
          (process-status (get-buffer "*shell*"))
               => run
          x
               => #<process xx<1>>
          (process-status x)
               => exit

     ネットワーク接続では、`process-status'はシンボル`open'か`closed'の
     いずれかを返す。後者は、相手側が接続を閉じたかEmacsが
     `delete-process'を行ったことを表す。

 -- Function: process-exit-status PROCESS
     この関数は、プロセスPROCESSの終了状態か、プロセスをキルしたシグナル
     番号を返す。（どちらであるかを判定するには、`process-status'の結果
     を用いる。）PROCESSが終了していないと値は0である。

 -- Function: process-tty-name PROCESS
     この関数は、プロセスPROCESSがEmacsとの通信に用いている端末名を返す。
     あるいは、端末のかわりにパイプを用いていれば`nil'を返す（*Note
     Asynchronous Processes::の`process-connection-type'を参照）。

 -- Function: process-coding-system PROCESS
     この関数は、プロセスPROCESSからの出力を復号化するために用いているコー
     ディングシステムと、PROCESSへの入力を符号化するために用いているコー
     ディングシステムを記述するコンスセルを返す。

          (CODING-SYSTEM-FOR-DECODING . CODING-SYSTEM-FOR-ENCODING)

 -- Function: set-process-coding-system PROCESS DECODING-SYSTEM ENCODING-SYSTEM
     この関数は、プロセスPROCESSからの以降の出力および入力に用いるコーディ
     ングシステムを指定する。サブプロセスから出力の復号化には
     DECODING-SYSTEMを使い、サブプロセスの入力の符号化には
     ENCODING-SYSTEMを使う。



File: elisp-ja.info, Node: Input to Processes, Next: Signals to Processes, Prev: Process Information, Up: Processes

プロセスへ入力を送る
====================

本節の関数を用いてEmacsが入力を送ると、非同期プロセスは入力を受け取りま
す。入力の送先であるプロセスと、送るべき入力データを指定する必要がありま
す。そのデータは、サブプロセスの『標準入力』に現れます。

疑似端末PTYのバッファ付き入力の容量に上限があるオペレーティングシステム
もあります。そのようなシステムでは、Emacsは他の文字に混ぜて定期的にEOFを
送り、文字が流れるように強制します。ほとんどのプログラムでは、このような
EOFは無害なはずです。

ファイルに書き込むテキストと同様に、サブプロセスの入力は、サブプロセスが
それを受け取るまえにコーディングシステムを用いて普通は符号化されます。
`set-process-coding-system'で使用するコーディングシステムを指定できます
（*Note Process Information::）。さもなければ、`coding-system-for-write'
が`nil'以外であればこれを使います。それ以外ではデフォルトの機構で決まる
ものを使います（*Note Default Coding Systems::）。

 -- Function: process-send-string PROCESS-NAME STRING
     この関数は、文字列STRINGの内容を標準入力としてプロセスPROCESS-NAME
     に送る。引数PROCESS-NAMEは、プロセスかプロセス名であること。これが
     `nil'であると、カレントバッファのプロセスを用いる。

     関数は`nil'を返す。

          (process-send-string "shell<1>" "ls\n")
               => nil


          ---------- Buffer: *shell* ----------
          ...
          introduction.texi               syntax-tables.texi~
          introduction.texi~              text.texi
          introduction.txt                text.texi~
          ...
          ---------- Buffer: *shell* ----------

 -- コマンド: process-send-region PROCESS-NAME START END
     この関数は、STARTとENDで定義される領域内のテキストを標準入力として
     プロセスPROCESS-NAMEへ送る。PROCESS-NAMEはプロセスかプロセス名であ
     ること。（`nil'であると、カレントバッファのプロセスを使う。）

     STARTとENDのどちらかがカレントバッファ内の位置を表す整数でもマーカ
     でもないと、エラーを通知する。（どちらが大きな数であるかは重要では
     ない。）

 -- Function: process-send-eof &optional PROCESS-NAME
     この関数は、プロセスPROCESS-NAMEが入力で「ファイルの終りEOF」を見る
     ようにする。EOFはそれまでに送ったテキストのあとにある。

     PROCESS-NAMEを指定しなかったり`nil'であると、この関数はカレントバッ
     ファのプロセスにEOFを送る。カレントバッファにプロセスがないとエラー
     を通知する。

     関数はPROCESS-NAMEを返す。

          (process-send-eof "shell")
               => "shell"



File: elisp-ja.info, Node: Signals to Processes, Next: Output from Processes, Prev: Input to Processes, Up: Processes

プロセスにシグナルを送る
========================

サブプロセスに"シグナルを送る"ことは、サブプロセスの動作に割り込む一方法
です。それぞれ独自の意味を持つ異なるシグナルがいくつかあります。一連のシ
グナルとそれらの名前は、オペレーティングシステムが定義します。たとえば、
シグナル`SIGINT'は、ユーザーが`C-c'を打った、あるいは、それと同様なこと
が起こったことを意味します。

各シグナルには、サブプロセスに対する標準的な効果があります。ほとんどのシ
グナルはサブプロセスをキルしますが、その実行を一時停止したり再開するもの
もあります。プログラムがシグナルを処理している場合には、シグナルの効果を
一般的に述べることはできません。

本節の関数を呼び出してシグナルを明示的に送ることができます。また、Emacs
は特定の場面で自動的にシグナルを送ります。バッファを削除すると、そのバッ
ファに対応付けられているすべてのプロセスにシグナル`SIGHUP'を送ります。
Emacsを終了するときには、動作しているすべてのサブプロセスにシグナル
`SIGHUP'を送ります。（`SIGHUP'は、ユーザーが電話を切ったことを普通は表す
シグナル。）

シグナルを送る各関数は、省略可能な2つの引数、PROCESS-NAMEとCURRENT-GROUP
を受け付けます。

引数PROCESS-NAMEは、プロセス、プロセス名、`nil'のいずれかです。これが
`nil'であると、カレントバッファに対応付けられているプロセスがデフォルト
になります。PROCESS-NAMEがプロセスを指定しないとエラーを通知します。

引数CURRENT-GROUPは、Emacsのサブプロセスとしてジョブ制御可能なシェルを実
行しているときに違いが現れるフラグです。これが`nil'以外であると、Emacsが
サブプロセスとの通信に用いている端末の現在のプロセスグループにシグナルを
送ります。プロセスがジョブ制御可能なシェルであると、これはシェルの現在の
サブジョブ (1) (*Note Signals to Processes-Footnotes::) であることを意味
します。`nil'であると、Emacsのサブプロセスの直接のプロセスグループにシグ
ナルを送ります。プロセスがジョブ制御可能なシェルであると、これはシェルそ
のものです。

オペレーティングシステムはパイプではプロセスグループを扱わないため、サブ
プロセスとの通信にパイプを用いている場合には、フラグCURRENT-GROUPには効
果はありません。同じ理由で、パイプを用いている場合にはジョブ制御可能なシェ
ル（のジョブ制御機能）は働きません。*Note Asynchronous Processes::の
`process-connection-type'を参照してください。

 -- Function: interrupt-process &optional PROCESS-NAME CURRENT-GROUP
     この関数は、プロセスPROCESS-NAMEにシグナル`SIGINT'を送って割り込む。
     Emacsの外側では、『割り込み文字』（普通、`C-c'であるシステムもあり、
     その他のシステムでは`DEL'）を打つとこのシグナルを送る。引数
     CURRENT-GROUPが`nil'以外であると、この関数は、Emacsがサブプロセスと
     通信している端末上で『`C-c'を打つ』と考えることができる。

 -- Function: kill-process &optional PROCESS-NAME CURRENT-GROUP
     この関数は、プロセスPROCESS-NAMEにシグナル`SIGKILL'を送ってキルする。
     このシグナルはサブプロセスを即座にキルし、サブプロセスはこれを処理
     できない。

 -- Function: quit-process &optional PROCESS-NAME CURRENT-GROUP
     この関数は、プロセスPROCESS-NAMEにシグナル`SIGQUIT'を送る。このシグ
     ナルは、『中断文字』（Emacsの外側では普通は`C-b'や`C-\'）が送るシグ
     ナルと同じものである。

 -- Function: stop-process &optional PROCESS-NAME CURRENT-GROUP
     この関数は、プロセスPROCESS-NAMEにシグナル`SIGTSTP'を送って一時停止
     させる。その実行を再開させるには`continue-process'を使う。

     Emacsの外側でジョブ制御可能なシステムでは、『一時停止文字』（普通は
     `C-z'）が普通はこのシグナルを送る。CURRENT-GROUPが`nil'以外であると、
     この関数は、Emacsがサブプロセスと通信している端末上で『`C-z'を打つ』
     と考えることができる。

 -- Function: continue-process &optional PROCESS-NAME CURRENT-GROUP
     この関数は、プロセスPROCESSにシグナル`SIGTCONT'を送って実行を再開さ
     せる。以前に一時停止させられたPROCESSを再開する。

 -- Function: signal-process PID SIGNAL
     この関数は、必ずしもEmacsの子プロセスではないプロセスPIDにシグナル
     を送る。引数SIGNALは、送るべきシグナルを整数で指定する。


File: elisp-ja.info  Node: Signals to Processes-Footnotes, Up: Signals to Processes

(1) 【訳注】シェルのもとで動いているプロセス群



File: elisp-ja.info, Node: Output from Processes, Next: Sentinels, Prev: Signals to Processes, Up: Processes

プロセスからの出力を受け取る
============================

サブプロセスが標準出力に書く出力を受け取る方法は2つあります。プロセスに
対応付けられたバッファに出力を挿入するか、あるいは、"フィルタ関数"
（filter function）と呼ばれる関数を出力に対して作用させます。プロセスに
バッファもフィルタ関数もなければ、その出力は破棄します。

サブプロセスからの出力は、Emacsが待っている、つまり、端末入力を読んでい
るとき、`sit-for'や`sleep-for'を実行中のとき（*Note Waiting::）、
`accept-process-output'（*Note Accepting Output::）を実行中のときにだけ
到着します。これにより、並行プログラムを普通は悩ますようなタイミングエラー
の問題を最小に抑えます。たとえば、安全にプロセスを作成してから、バッファ
かフィルタ関数を指定できます。この処理の途中で待つような基本関数を呼び出
さなければ、出力は到着しません。

ファイルから読むテキストと同様に、サブプロセスの出力は、バッファやフィル
タ関数が受け取るまえにコーディングシステムを用いて普通は復号化します。
`set-process-coding-system'で使用するコーディングシステムを指定できます
（*Note Process Information::）。さもなければ、`coding-system-for-read'
が`nil'以外であればこれを使います。それ以外ではデフォルトの機構で決まる
ものを使います（*Note Default Coding Systems::）。

*警告：*` ' データからコーディングシステムを決定する`undecided'のような
コーディングシステムは、非同期サブプロセスの出力に対しては完全に信頼性の
ある動作はできない。これは、Emacsが非同期サブプロセスの出力が到着するた
びに一塊で処理するからである。Emacsは1つの塊から正しい変換を検出しようと
試みるが、これがつねに動作するとは限らない。したがって、可能な限り文字コー
ド変換と行末変換の両方を指定したコーディングシステムを使う。つまり、
`undecided'や`latin-1'などではなく、`latin-1-unix'のようなものを使う。

* Menu:

* Process Buffers::       If no filter, output is put in a buffer.
* Filter Functions::      Filter functions accept output from the process.
* Accepting Output::      Explicitly permitting subprocess output.
                            Waiting for subprocess output.



File: elisp-ja.info, Node: Process Buffers, Next: Filter Functions, Prev: Output from Processes, Up: Output from Processes

プロセスバッファ
----------------

プロセスには"対応付けられたバッファ"が（普通は）あります。そのバッファは
Emacsの普通のバッファであり、2つの目的に使われます。プロセスからの出力を
保存することと、プロセスがキルされたことを判定するためです。バッファを用
いてそれを操作しているプロセスを識別することもできます。普通は1つのバッ
ファに1つのプロセスを対応付けるからです。プロセスの多くの応用では、プロ
セスへ送る入力を編集するためにバッファを使いますが、これはEmacs Lispに組
み込まれたことではありません。

プロセスにフィルタ関数（*Note Filter Functions::）がなければ、その出力は
対応付けられたバッファに挿入されます。出力の挿入位置は`process-mark'で決
定され、`process-mark'は挿入したばかりのテキストの末尾を指すように更新さ
れます。`process-mark'は普通はバッファの末尾にありますが、つねにそうであ
るとは限りません。

 -- Function: process-buffer PROCESS
     この関数は、プロセスPROCESSに対応付けられているバッファを返す。

          (process-buffer (get-process "shell"))
               => #<buffer *shell*>

 -- Function: process-mark PROCESS
     この関数は、プロセスPROCESSからの出力を挿入する箇所を指定する
     PROCESSのプロセスマーカを返す。

     PROCESSにバッファがなければ、`process-mark'はどこも指していないマー
     カである。

     バッファにプロセス出力を挿入する際には、挿入箇所を決定するためにこ
     のマーカを使用し、挿入したテキストの末尾を指すようにこのマーカを更
     新する。これにより、出力の連続した塊を順に挿入できるのである。

     バッファに出力を直接挿入する場合と同様に、フィルタ関数はこのマーカ
     を扱うべきである。`process-mark'を用いたフィルタ関数の好例は、以下
     の節にある。

     プロセスへ送るためにユーザーがプロセスバッファに入力することが予想
     されるときは、プロセスマーカは新たな入力とそれ以前の出力を区切る。

 -- Function: set-process-buffer PROCESS BUFFER
     この関数は、プロセスPROCESSにバッファBUFFERを対応付ける。BUFFERが
     `nil'であると、プロセスに対応付けられたバッファはない。

 -- Function: get-buffer-process BUFFER-OR-NAME
     この関数はBUFFER-OR-NAMEに対応付けられたプロセスを返す。バッファに
     複数のプロセスが対応付けられている場合には、それらの1つを選ぶ。（現
     状では、もっとも最近に作られたプロセスを選ぶ。）同じバッファに複数
     のプロセスを対応付けることは一般にはよくない。

          (get-buffer-process "*shell*")
               => #<process shell>

     プロセスのバッファを削除すると、サブプロセスにシグナル`SIGHUP'を送っ
     てプロセスを削除する（*Note Signals to Processes::）。



File: elisp-ja.info, Node: Filter Functions, Next: Accepting Output, Prev: Process Buffers, Up: Output from Processes

プロセスフィルタ関数
--------------------

プロセスの"フィルタ関数"（filter function）は、対応付けられたプロセスか
らの標準出力を受け取る関数です。プロセスにフィルタがあると、そのプロセス
からの*すべて*の出力はフィルタに渡されます。プロセスにフィルタがない場合
に限って、プロセスからの出力向けにプロセスバッファを直接使います。

フィルタ関数は、Emacsがなにかを待っているときにのみ呼ばれます。そのよう
な期間にのみプロセスの出力が到着するからです。Emacsが待つのは、端末入力
を読んでいるとき、`sit-for'や`sleep-for'を実行中のとき（*Note Waiting::）、
`accept-process-output'（*Note Accepting Output::）を実行中のときです。

フィルタ関数は2つの引数、対応付けられたプロセスとそのプロセスから受け取っ
たばかりの出力である文字列を受け取ります。関数は出力に対してなにを行って
もかまいません。

フィルタ関数の内側では中断は普通は禁止されています。さもないと、コマンド
レベルで打った`C-g'の効果や、ユーザーコマンドを中断するために打った`C-g'
の効果は予測できません。フィルタ関数の内側で中断を行いたい場合には、
`inhibit-quit'に`nil'を束縛します。*Note Quitting::。

フィルタ関数の実行中にエラーが発生するとそのエラーは自動的に捕捉され、フィ
ルタ関数を始動したときに動いていたプログラムの実行を停止しないようにしま
す。しかし、`debug-on-error'が`nil'以外であると、エラーを捕捉しません。
これにより、Lispデバッガでフィルタ関数をデバッグできます。*Note
Debugger::。

多くのフィルタ関数は、ときどきあるいはつねに、プロセスのバッファにテキス
トを挿入します。これはフィルタ関数がないときのEmacsの動作を模倣するもの
です。そのようなフィルタ関数では、対象のバッファに挿入するために
`set-buffer'を使う必要があります。カレントバッファをなかば恒久的に切り替
えないように、これらのフィルタ関数はカレントバッファを記録／復元する必要
があります。プロセスマーカを更新し、必要に応じてポイントの値も更新します。
これらはつぎのように行います。

     (defun ordinary-insertion-filter (proc string)
       (with-current-buffer (process-buffer proc)
         (let ((moving (= (point) (process-mark proc))))
           (save-excursion
             ;; テキストを挿入し、プロセスマーカを進める
             (goto-char (process-mark proc))
             (insert string)
             (set-marker (process-mark proc) (point)))
           (if moving (goto-char (process-mark proc))))))

カレントバッファを記録／復元するために`save-excursion'ではなく
`with-current-buffer'を使うのは、2番目の`goto-char'の呼び出しで行うポイ
ントの移動効果を有効にするためです。

新たにテキストが到着するたびにプロセスバッファが見えるようにフィルタ関数
で強制するには、つぎのような行を`with-current-buffer'の直前に入れます。

     (display-buffer (process-buffer proc))

ポイント位置に関わらずに新たな出力の末尾にポイントを移動するには、変数
`moving'を削除して、無条件に`goto-char'を呼び出します。

Emacsの初期の版では、正規表現を探索したり一致処理するフィルタ関数では、
マッチデータを明示的に保存／復元する必要がありました。今のEmacsは、フィ
ルタ関数に対してはこれを自動的に行いますから、フィルタ関数で明示的に行う
必要はありません。*Note Match Data::。

プロセスのバッファに出力を書き込むフィルタ関数は、そのバッファが有効であ
るかどうかを検査するべきです。無効なバッファに挿入しようとするとエラーに
なります。バッファが無効であれば、式`(buffer-name (process-buffer
PROCESS))' を実行すると`nil'を返します。

関数に渡される出力は任意のサイズの塊できます。同じ出力を2回生成するプロ
グラムは、あるときには一度に200文字の塊を1つ送る場合もあれば、40文字の塊
を5つ送る場合もあります。サブプロセスの出力から特定のテキスト文字列を探
すフィルタでは、そのような文字列が2つかそれ以上の出力の塊に分割される場
合も扱えるようにします。

 -- Function: set-process-filter PROCESS FILTER
     この関数は、プロセスPROCESSにフィルタ関数FILTERを指定する。FILTERが
     `nil'であると、プロセスにフィルタはない。

 -- Function: process-filter PROCESS
     この関数は、プロセスPROCESSのフィルタ関数を返す。あるいは、フィルタ
     関数がなければ`nil'を返す。

フィルタ関数の使用例をつぎに示します。

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          => keep-output
     (setq kept nil)
          => nil
     (set-process-filter (get-process "shell") 'keep-output)
          => keep-output
     (process-send-string "shell" "ls ~/other\n")
          => nil
     kept
          => ("lewis@slug[8] % "
     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")




File: elisp-ja.info, Node: Accepting Output, Prev: Filter Functions, Up: Output from Processes

プロセスからの出力を受け取る
----------------------------

非同期サブプロセスからの出力は、Emacsが時間待ちや端末入力などのなんらか
の外部事象を待っているときにのみ到着します。Lispプログラムから特定の場面
で出力の到着を明示的に許したり、プロセスの出力が到着するのを待つことがで
きると有用なことがあります。

 -- Function: accept-process-output &optional PROCESS SECONDS MILLISEC
     この関数は、Emacsにプロセスからの未処理の出力を読み取ることを許す。
     その出力は、対応付けられたバッファに挿入されるか、フィルタ関数に与
     えられる。PROCESSが`nil'以外であると、この関数は、PROCESSからなんら
     かの出力を得るまで戻らない。

     引数SECONDSとMILLISECは、時間切れを指定する。前者は秒単位の時間、後
     者はミリ秒単位の時間を指定する。指定された2つの時間は合計され、任意
     のサブプロセスの出力を受け取ったどうかに関わらず、その時間だけ経過
     すると`accept-process-output'は戻ってくる。

     引数SECONDSは整数である必要はない。浮動小数点数であると、この関数は
     秒未満の時間も待つ。秒未満を扱えないシステムもある。そのようなシス
     テムでは、SECONDSを切り下げる。

     すべてのオペレーティングシステムで秒未満を扱えるわけではない。扱え
     ないシステムでMILLISECにゼロ以外を指定するとエラーになる。

     関数`accept-process-output'は、出力を得ると`nil'以外を返す。あるい
     は、出力が到着するまえに時間切れすると`nil'を返す。



File: elisp-ja.info, Node: Sentinels, Next: Transaction Queues, Prev: Output from Processes, Up: Processes

番兵：プロセスの状態変化の検出
==============================

"プロセスの番兵"（process sentinel）は、プロセスを終了／一時停止／継続さ
せる（Emacsが送ったかプロセス自身の動作によって生起した）シグナルを含め
て対応付けられたプロセスの状態が任意の理由で変化したときに呼び出される関
数です。プロセスの番兵は、プロセスが終了しても呼び出されます。番兵は2つ
の引数、事象が発生したプロセスと事象の種類を記述する文字列を受け取ります。

事象を記述する文字列はつぎのとおりです。

   * `"finished\n"'.

   * `"exited abnormally with code EXITCODE\n"'.

   * `"NAME-OF-SIGNAL\n"'.

   * `"NAME-OF-SIGNAL (core dumped)\n"'.

番兵はEmacsが（たとえば、端末入力や時間経過、プロセスの出力を）待ってい
るときにのみ実行されます。他のLispプログラムの実行途中で無秩序に番兵を実
行した場合に起こるタイミングエラーを回避するためです。`sit-for'や
`sleep-for'（*Note Waiting::）、あるいは、`accept-process-output'（*Note
Accepting Output::）を呼び出すとプログラムは待ちに入り、番兵が動けること
になります。Emacsは、コマンドループで入力を読むときにも番兵の実行を許し
ます。

番兵の内側では中断は普通は禁止されています。さもないと、コマンドレベルで
打った`C-g'の効果や、ユーザーコマンドを中断するために打った`C-g'の効果は
予測できません。番兵の内側で中断を行いたい場合には、`inhibit-quit'に
`nil'を束縛します。*Note Quitting::。

プロセスのバッファに出力を書き込む番兵は、そのバッファが有効であるかどう
かを検査するべきです。無効なバッファに挿入しようとするとエラーになります。
バッファが無効であれば、式`(buffer-name (process-buffer PROCESS))' を実
行すると`nil'を返します。

番兵の実行中にエラーが発生するとそのエラーは自動的に捕捉され、番兵を始動
したときに動いていたプログラムの実行を停止しないようにします。しかし、
`debug-on-error'が`nil'以外であると、エラーを捕捉しません。これにより、
Lispデバッガで番兵をデバッグできます。*Note Debugger::。

Emacsの初期の版では、正規表現を探索したり一致処理する番兵では、マッチデー
タを明示的に保存／復元する必要がありました。今のEmacsは、番兵に対しては
これを自動的に行いますから、番兵で明示的に行う必要はありません。*Note
Match Data::。

 -- Function: set-process-sentinel PROCESS SENTINEL
     この関数は、プロセスPROCESSに番兵SENTINELを対応付ける。SENTINELが
     `nil'であると、プロセスに番兵はない。番兵がない場合のデフォルトのふ
     るまいは、プロセス状態が変化するとプロセスのバッファにメッセージを
     挿入する。

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event `%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               => msg-me
          (kill-process (get-process "shell"))
               -| Process: #<process shell> had the event `killed'
               => #<process shell>

 -- Function: process-sentinel PROCESS
     この関数は、プロセスPROCESSの番兵を返すか、番兵がなければ`nil'を返
     す。

 -- Function: waiting-for-user-input-p
     番兵やフィルタ関数が動作中にこの関数を呼び出すと、番兵やフィルタ関
     数を呼び出したときにEmacsがユーザーからのキーボード入力を待ってると
     `nil'以外を返し、それ以外では`nil'を返す。



File: elisp-ja.info, Node: Transaction Queues, Next: Network, Prev: Sentinels, Up: Processes

トランザクションキュー
======================

トランザクションを用いたサブプロセスとの通信に"トランザクションキュー"
（transaction queue）を使えます。まず`tq-create'を用いて、指定したプロセ
スとの通信用トランザクションキューを作成します。そして、トランザクション
を送るために`tq-enqueue'を呼び出します。

 -- Function: tq-create PROCESS
     この関数は、プロセスPROCESSとの通信用トランザクションキューを作成し
     て返す。引数PROCESSは、バイトストリームを送受信できる機能を有するサ
     ブプロセスであること。つまり、子プロセスであるか、別のマシン上の可
     能性もあるサーバーへのTCP接続である。

 -- Function: tq-enqueue QUEUE QUESTION REGEXP CLOSURE FN
     この関数はキューQUEUEにトランザクションを送る。キューを指定すること
     は、通信相手のサブプロセスを指定する効果がある。

     引数QUESTIONは、トランザクションを始める送出メッセージである。引数
     FNは、対応する応答が戻ってきたときに呼び出す関数である。その関数は2
     つの引数、CLOSUREと受け取った応答で呼び出される。

     引数REGEXPは、1つの応答だけに一致する正規表現である。`tq-enqueue'が
     応答の末尾を判定するために使う。

     `tq-enqueue'の戻り値そのものに意味はない。

 -- Function: tq-close QUEUE
     未処理のトランザクションすべてが完了するのを待ち、接続や子プロセス
     を終了して、トランザクションキューQUEUEを終える。

トランザクションキューはフィルタ関数を用いて実装してあります。*Note
Filter Functions::。



File: elisp-ja.info, Node: Network, Prev: Transaction Queues, Up: Processes

ネットワーク接続
================

Emacs Lispプログラムは、同一マシンや別のマシン上の他のプロセスに対して
TCPネットワーク接続を開くことができます。ネットワーク接続は、サブプロセ
スと同様にLispが扱い、プロセスオブジェクトとして表現されます。しかし、通
信相手のプロセスはEmacsプロセスの子プロセスではありませんから、キルした
りシグナルを送ることはできません。データの送受信のみが可能です。
`delete-process'は接続を閉じますが、もう一方の端のプロセスをキルしません。
そのプロセスは、接続が閉じた場合の動作を判断する必要があります。

ネットワーク接続を表すプロセスオブジェクトとサブプロセスを表すプロセスオ
ブジェクトとは、関数`process-status'を使って区別できます。この関数は、ネッ
トワーク接続に対しては`open'か`closed'をつねに返し、本当のサブプロセスに
対してはこれらのいずれの値もけっして返しません。*Note Process
Information::。

 -- Function: open-network-stream NAME BUFFER-OR-NAME HOST SERVICE
     この関数は、ホストのサーバーに対するTCP接続を開く。接続を表すプロセ
     スオブジェクトを返す。

     引数NAMEは、プロセスオブジェクトに付ける名前を指定する。必要に応じ
     て一意にするために修正される。

     引数BUFFER-OR-NAMEは、接続に対応付けるバッファである。出力を扱うフィ
     ルタ関数を指定しない限り、接続からの出力はそのバッファに挿入される。
     BUFFER-OR-NAMEが`nil'であると、接続にはバッファを対応付けないことを
     意味する。

     引数HOSTとSERVICEは、接続先を指定する。HOSTはホスト名（文字列）であ
     り、SERVICEは定義済みのネットワークサービス（文字列）かポート番号
     （整数）である。



File: elisp-ja.info, Node: System Interface, Next: Display, Prev: Processes, Up: Top

オペレーティングシステムとのインターフェイス
********************************************

本章は、Emacsの起動と終了、オペレーティングシステムの環境に収められた値
の参照方法、端末入出力とフロー制御についてです。

関連情報については*Note Building Emacs::。また、端末やスクリーンに関係す
るオペレーティングシステムの状態情報については、*Note Display::も参照し
てください。

* Menu:

* Starting Up::         Customizing Emacs start-up processing.
* Getting Out::         How exiting works (permanent or temporary).
* System Environment::  Distinguish the name and kind of system.
* User Identification:: Finding the name and user id of the user.
* Time of Day::		Getting the current time.
* Time Conversion::     Converting a time from numeric form to a string, or
                          to calendrical data (or vice versa).
* Timers::		Setting a timer to call a function at a certain time.
* Terminal Input::      Recording terminal input for debugging.
* Terminal Output::     Recording terminal output for debugging.
* Special Keysyms::     Defining system-specific key symbols for X windows.
* Flow Control::        How to turn output flow control on or off.
* Batch Mode::          Running Emacs without terminal interaction.



File: elisp-ja.info, Node: Starting Up, Next: Getting Out, Prev: System Interface, Up: System Interface

Emacsの始動
===========

本節では、Emacsが起動時になにを行うか、および、それらをカスタマイズする
方法について述べます。

* Menu:

* Start-up Summary::        Sequence of actions Emacs performs at start-up.
* Init File::               Details on reading the init file (`.emacs').
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command Line Arguments::  How command line arguments are processed,
                              and how you can customize them.



File: elisp-ja.info, Node: Start-up Summary, Next: Init File, Prev: Starting Up, Up: Starting Up

概要：始動時の動作手順
----------------------

Emacsが始動したときに行う（`startup.el'での）処理の順序はつぎのとおりで
す。

  1. `load-path'にある各ディレクトリファイルにおいて`subdirs.el'という名
     前のファイルを実行することで`load-path'にサブディレクトリを追加する。

  2. `LANG'などの環境変数で要求されていれば、言語環境と端末のコーディン
     グシステムを設定する。

  3. ウィンドウシステムを使用している場合には、そのウィンドウシステム向
     けの初期化ライブラリをロードする。そのライブラリ名は
     `term/WINDOWSYSTEM-win.el'である。

  4. 初期化オプションを処理する。（初期化オプションの一部は、これより初
     期の段階で扱われる。）

  5. 必要ならば、ウィンドウフレームとフェイスを初期化する。

  6. ノーマルフック`before-init-hook'を実行する。

  7. オプション`-no-site-file'が指定されていなければ、ライブラリ
     `site-start'をロードする。このライブラリの名前は普通は
     `site-start.el'である。

  8. コマンド行で`-q'や`-batch'が指定されていなければ、ファイル
     `~/.emacs'をロードする。オプション`-u'で、`~'のかわりに用いるホーム
     ディレクトリを持つ他のユーザー名を指定できる。

  9. `inhibit-default-init'が`nil'以外でなければ、ライブラリ`default'を
     ロードする。（コマンド行で`-q'を指定したり、`-batch'モードでは、こ
     れを行わない。）ライブラリのファイル名は普通は`default.el'である。

 10. ノーマルフック`after-init-hook'を実行する。

 11. バッファ`*scratch*'がカレントバッファであり基本（fundamental）モー
     ドであるならば、`initial-major-mode'に従ってメジャーモードを設定す
     る。

 12. バッチモードやウィンドウシステムを用いていなければ、あれば端末固有
     のLispファイルが存在するならロードする。

 13. `inhibit-startup-echo-area-message'で抑制していなければ、初期メッセー
     ジをエコー領域に表示する。

 14. コマンド行の引数を処理する。

 15. `term-setup-hook'を実行する。

 16. 初期化ファイルの指定に従って選択されているフレームのパラメータを修
     正する`frame-notice-user-settings'を呼び出す。

 17. `window-setup-hook'を実行する。*Note Window Systems::。

 18. 未処理のコマンド行引数（上の数手順）がなく、
     `inhibit-startup-message'の値が`nil'であり、バッファが空であれば、
     コピーレフト／無保証／基本的な利用情報を表示する。

 -- User Option: inhibit-startup-message
     この変数は、（無保証などの）初期の始動メッセージを禁止する。これが
     `nil'以外であるとメッセージを表示しない。

     始動メッセージの内容に十分慣れたら、読者個人の初期化ファイルで設定
     できるようにこの変数がある。新規ユーザーが受け取るはずである情報を
     隠してしまうため、新規ユーザーの初期化ファイルや複数のユーザーに影
     響するような方法でこの変数に設定しないこと。

 -- User Option: inhibit-startup-echo-area-message
     この変数は、エコー領域に表示する始動メッセージを制御する。個人のファ
     イル`.emacs'につぎのフォームを追加することでエコー領域の始動メッセー
     ジを抑制できる。

          (setq inhibit-startup-echo-area-message
                "YOUR-LOGIN-NAME")

     Emacsは、読者のファイル`.emacs'で上に示した式を明示的に検査する。読
     者のログイン名はLisp文字列定数として式に現れる必要がある。
     `inhibit-startup-echo-area-message'に同じ値を設定する別の方法では、
     始動メッセージを禁止できない。

     このように、望むならば自身のためにメッセージを簡単に禁止できるが、
     読者の`.emacs'をむやみにコピーしても、他人に対してはメッセージを禁
     止できない。



File: elisp-ja.info, Node: Init File, Next: Terminal-Specific, Prev: Start-up Summary, Up: Starting Up

初期化ファイル：`.emacs'
------------------------

読者がEmacsを始動すると、Emacsは読者のホームディレクトリからファイル
`.emacs'を普通はロードしようとします。このファイルが存在すれば、これには
Lispコードを入れておく必要があります。コマンド行オプション`-q'と`-u'は、
初期化ファイルの使い方に影響します。`-q'は初期化ファイルをロードしないよ
うに指示し、`-u'は読者の初期化ファイルのかわりに指定したユーザーの初期化
ファイルをロードするように指示します。*Note Emacsの起動と終了:
(emacs)Entering Emacs。

"デフォルトの初期化ファイル"をサイトごとに持てます。これは`default.el'と
いう名前のライブラリです。Emacsは、ライブラリを探索する標準パスからファ
イル`default.el'を探します（*Note How Programs Do Loading::）。Emacsの配
布には、このファイルは付属していません。ローカルなカスタマイズのためにサ
イトで用意します。バッチモードや`-q'を指定してある場合を除いて、デフォル
トの初期化ファイルが存在すると、読者がEmacsを始動するたびにそれをロード
します。しかし、存在するなら、個人の初期化ファイルをさきにロードします。
そこで`inhibit-default-init'に`nil'以外の値を設定してあると、Emacsはその
あとファイル`default.el'をロードしません。

サイトごとのカスタマイズ向けの別のファイルは`site-start.el'です。Emacsは
ユーザーの初期化ファイルをロードする*まえ*にこのファイルをロードします。
このファイルのロードを禁止するにはオプション`-no-site-file'を使います。

 -- Variable: site-run-file
     この変数は、ユーザーの初期化ファイルよりさきにロードするべきサイト
     ごとのカスタマイズファイルを指定する。普通の値は`"site-start"'であ
     る。実際に効果があるようにこれを変更する唯一の方法は、Emacsをダンプ
     するまえに行うことである。

読者のファイル`.emacs'に大量のコードがある場合には、`SOMETHING.el'という
名前の別のファイルへコピーして、それをバイトコンパイルし（*Note Byte
Compilation::）、読者のファイル`.emacs'では、`load'（*Note Loading::）で
そのファイルをロードするようにします。

読者のファイル`.emacs'でよく使われるであろうさまざまなカスタマイズを行う
方法の例については、*Note 初期化ファイルの例: (emacs)Init Examples。

 -- User Option: inhibit-default-init
     この変数は、読者のEmacsセッションにおいては、デフォルトの初期化ライ
     ブラリファイルをロードしないようにする。その値が`nil'以外であるとデ
     フォルトライブラリをロードしない。デフォルト値は`nil'である。

 -- Variable: before-init-hook
     すべての初期化ファイル（ユーザーの初期化ファイル、`default.el'と／
     あるいは`site-start.el'）をロードする直前に一度だけ実行するノーマル
     フック。（実際の効果があるようにこれを変更する唯一の方法は、Emacsを
     ダンプするまえに行うことである。）

 -- Variable: after-init-hook
     すべての初期化ファイル（ユーザーの初期化ファイル、`default.el'と／
     あるいは`site-start.el'）をロード直後、端末固有の初期化のまえに一度
     だけ実行するノーマルフック。



File: elisp-ja.info, Node: Terminal-Specific, Next: Command Line Arguments, Prev: Init File, Up: Starting Up

端末固有の初期化
----------------

端末の各種類ごとに、Emacsがその種類の端末で動作するときにEmacsがロードす
る専用Lispライブラリを持てます。ライブラリ名は、変数`term-file-prefix'の
値と端末種類を連結して作ります。通常、`term-file-prefix'の値は`"term/"'
であり、これを変更することは勧めません。Emacsは通常どおり、`load-path'の
ディレクトリ群において`.elc'と`.el'の接尾辞でファイルを探します。

端末固有ライブラリの普通の機能は、Emacsが識別可能なキー列を送るように特
別なキーを設定することです。端末のすべてのファンクションキーがtermcapに
入っていない場合には、`function-key-map'を設定したり追加する必要もありま
す。

端末種類の名前にハイフンが含まれる場合、ライブラリ名を選ぶうえでは、最初
のハイフンよりまえの名前の部分が有効です。したがって、`aaa-48'と
`aaa-30-rv'のどちらもライブラリ`term/aaa'を使います。必要ならば、ライブ
ラリでは`(getenv "TERM")'を評価することで端末種類の完全な名前を得ること
ができます。

読者のファイル`.emacs'で変数`term-file-prefix'に`nil'を設定すると、端末
固有ライブラリをロードしないようにできます。この機能は、読者独自のカスタ
マイズを試すときに有用です。

変数`term-setup-hook'に設定すれば、端末固有ライブラリの特定の動作に優先
できます。これは、読者のファイル`.emacs'と端末固有ライブラリの両者をロー
ドしたあとの初期化後にEmacsが実行するノーマルフックです。端末専用ライブ
ラリがない端末向けの初期化を定義するためにこの変数を使えます。*Note
Hooks::。

 -- Variable: term-file-prefix
     変数`term-file-prefix'が`nil'以外であると、Emacsは、つぎのように端
     末固有の初期化ファイルをロードする。

          (load (concat term-file-prefix (getenv "TERM")))

     端末固有の初期化ファイルをロードしたくない場合には、読者のファイル
     `.emacs'で変数`term-file-prefix'に`nil'を設定する。それには、読者の
     ファイル`.emacs'に`(setq term-file-prefix nil)'を入れる。

 -- Variable: term-setup-hook
     この変数は、読者のファイル`.emacs'、（あれば）デフォルトの初期化ファ
     イル、端末固有のLispファイルをロードしたあとにEmacsが実行するノーマ
     ルフックである。

     端末固有ファイルの定義に優先するために`term-setup-hook'を使える。

関連する機能については、*Note Window Systems::の`window-setup-hook'を参
照してください。



