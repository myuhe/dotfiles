Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Managing Overlays, Prev: Overlay Properties, Up: Overlays

オーバレイの管理
----------------

本節では、オーバレイを作成、削除、移動したり、それらの内容を調べる関数に
ついて述べます。

 -- Function: make-overlay START END &optional BUFFER FRONT-ADVANCE REAR-ADVANCE
     この関数は、バッファBUFFERに属するSTARTからENDまでを覆うオーバレイ
     を作成しそれを返す。STARTとENDのどちらもバッファ内位置を指定する整
     数かマーカであること。BUFFERを省略すると、カレントバッファにオーバ
     レイを作成する。

     引数FRONT-ADVANCEとREAR-ADVANCEは、オーバレイの開始位置と終了位置に
     おける挿入型を指定する。*Note Marker Insertion Types::。

 -- Function: overlay-start OVERLAY
     この関数は、オーバレイOVERLAYの開始位置を整数で返す。

 -- Function: overlay-end OVERLAY
     この関数は、オーバレイOVERLAYの終了位置を整数で返す。

 -- Function: overlay-buffer OVERLAY
     この関数は、オーバレイOVERLAYが属するバッファを返す。

 -- Function: delete-overlay OVERLAY
     この関数は、オーバレイOVERLAYを削除する。Lispオブジェクトとしてはオー
     バレイは存在し続けるが、それが属したバッファとの対応付けは消失し、
     表示上の効果もなくなる。

     削除したオーバレイは恒久的に無意味ではない。`move-overlay'を呼び出
     して新たなバッファ内位置をそれに与えられる。

 -- Function: move-overlay OVERLAY START END &optional BUFFER
     この関数は、オーバレイOVERLAYをバッファBUFFERに移し、STARTからENDを
     覆うようにする。STARTとENDのどちらもバッファ内位置を指定し、整数か
     マーカである。BUFFERを省略すると、オーバレイは同じバッファに留まる。

     戻り値はOVERLAYである。

     これは、オーバレイの端を変更する唯一の正しい方法である。オーバレイ
     のマーカを手で修正しようとしないこと。他の重要なデータ構造を更新し
     そこない、いくつかのオーバレイを『失う』ことにもなりかねない。

 -- Function: overlays-at POS
     この関数は、カレントバッファの位置POSを覆うすべてのオーバレイのリス
     トを返す。このリスト内の順番に意味はない。オーバレイが位置POSかその
     まえで始まり、かつ、位置POSかそのうしろで終るときに、オーバレイは位
     置POSを覆う。

 -- Function: overlays-in BEG END
     この関数は、BEGからENDまでの領域と重なり合っているすべてのオーバレ
     イのリストを返す。『重なり合っている』とは、少なくとも1文字がオーバ
     レイに覆われていて、かつ、その文字が指定された領域に入っていること
     を意味する。しかし、空のオーバレイであってもそれがBEGにあるかBEGと
     ENDのあいだにあれば、空のオーバレイも結果に含まれる。

 -- Function: next-overlay-change POS
     この関数は、位置POSのうしろにあるオーバレイのつぎの開始位置か終了位
     置を返す。

 -- Function: previous-overlay-change POS
     この関数は、位置POSのまえにあるオーバレイのまえの開始位置か終了位置
     を返す。



File: elisp-ja.info, Node: Width, Next: Faces, Prev: Overlays, Up: Display

表示幅
======

すべての文字が同じ表示幅ではありませんから、これらの関数で文字の表示幅を
検査できます。関連する関数については、*Note Primitive Indent::と*Note
Screen Lines::

 -- Function: char-width CHAR
     この関数は、文字CHARを選択されているウィンドウでカレントバッファに
     表示した場合のコラム幅を返す。

 -- Function: string-width STRING
     この関数は、文字列STRINGを選択されているウィンドウでカレントバッファ
     に表示した場合のコラム幅を返す。

 -- Function: truncate-string-to-width STRING WIDTH &optional START-COLUMN PADDING
     この関数は、幅WIDTHに収まる文字列STRINGの部分を新たな文字列として返
     す。

     STRINGが幅WIDTHに満たない場合、STRINGの終りで結果は終る。STRING内の
     1つの複数コラム文字がコラムWIDTHを越える場合には、その文字は結果に
     含めない。したがって、結果はWIDTHより短くなりえるがそれを越えること
     はない。

     省略可能な引数START-COLUMNは、開始コラムを指定する。これが`nil'以外
     であると、文字列のはじめのSTART-COLUMNコラムを結果から省く。STRING
     内の1つの複数コラム文字がコラムSTART-COLUMNを越える場合には、その文
     字は結果に含めない。

     省略可能な引数PADDINGが`nil'以外であると、結果の文字列の先頭や末尾
     に付加してちょうどWIDTHコラムにするためのパディング文字である。
     WIDTHより短くなる場合に結果の末尾にパディング文字を使う。複数コラム
     文字がコラムSTART-COLUMNを越える場合には、結果の先頭にパディング文
     字を使う。

          (truncate-string-to-width "\tab\t" 12 4)
               => "ab"
          (truncate-string-to-width "\tab\t" 12 4 ?\ )
               => "    ab  "



File: elisp-ja.info, Node: Faces, Next: Blinking, Prev: Width, Up: Display

フェイス
========

"フェイス"（face）とは、図形的な属性、つまり、フォント、前景色、背景色、
下線の名前付きの集合体です。フェイスはスクリーン上のテキストの表示を制御
します。

各フェイスには固有の"フェイス番号"（face number）があり、Emacs内部の下位
レベルでフェイスを区別するために使われます。しかし、ほとんどの目的には、
Lispプログラムでは名前でフェイスを参照できます。

 -- Function: facep OBJECT
     この関数は、OBJECTがフェイスを指名するシンボル（あるいは、フェイス
     データを記録するために内部的に使われる種類のベクトル）であると`t'を
     返す。さもなければ`nil'を返す。

各フェイス名はすべてのフレームで有効であり、デフォルトではすべてのフレー
ムで同じ意味を持ちます。しかし、望みの1つのフレームで特定のフェイス名に
特定の意味を持たせることもできます。

* Menu:

* Standard Faces::      The faces Emacs normally comes with.
* Defining Faces::      How to define a face with `defface'.
* Merging Faces::	How Emacs decides which face to use for a character.
* Face Functions::	How to define and examine faces.



File: elisp-ja.info, Node: Standard Faces, Next: Defining Faces, Prev: Faces, Up: Faces

標準フェイス
------------

つぎの表はすべての標準フェイスとその用途です。

`default'
     このフェイスは通常のテキストに対して使う。

`modeline'
     このフェイスはモード行とメニューバーに対して使う。

`region'
     このフェイスは、暫定マーク（transient-mark）モードでリージョンを強
     調表示するために使う。

`secondary-selection'
     このフェイスは、指定した任意の二次セレクションを示すために使う。

`highlight'
     このフェイスは、さまざま目的向けに強調表示するために使う。

`underline'
     このフェイスは、テキストに下線を引く。

`bold'
     このフェイスは、可能ならば太字（bold）フォントを使う。フレームのフォ
     ントに太字（bold）変種があればそれを使う。太字変種を使用したい場合
     には、太字フォント変種を有するデフォルトフォントを選ぶのは読者の責
     任である。

`italic'
     このフェイスは、フレームのフォントに斜体（italic）変種があればそれ
     を使う。

`bold-italic'
     このフェイスは、フレームのフォントに太字斜体（bold-italic）変種があ
     ればそれを使う。



File: elisp-ja.info, Node: Defining Faces, Next: Merging Faces, Prev: Standard Faces, Up: Faces

フェイスを定義する
------------------

新たなフェイスを定義する方法は、`defface'を使うことです。これは、カスタ
マイズバッファ（*Note 簡便なカスタマイズ方法: (emacs)Easy Customization.）
を用いてユーザーがカスタマイズできるカスタマイズ項目（*Note
Customization::）の一種を作成します。

 -- Macro: defface FACE SPEC DOC [KEYWORD VALUE]...
     SPECに従ったデフォルトを持つカスタマイズ可能なフェイスとしてFACEを
     宣言する。シンボルFACEをクォートしないこと。引数DOCは、フェイスの説
     明文字列を指定する。

     `defface'を実行すると、SPECに従ったフェイスを定義し、ファイル
     `.emacs'から読み取った任意のカスタマイズをSPECの指定に優先させる。

     SPECの目的は、異なる種類の端末でフェイスがどのような見た目になるか
     を指定することである。`(DISPLAY ATTS)'の形の要素から成る連想リスト
     であること。要素のCARのDISPLAYは端末の種類を指定する。CDRのATTSはフェ
     イスの属性とその値のリストであり、その種類の端末上でそのフェイスが
     どのように見えるかを指定する。可能な属性は、
     `custom-face-attributes'の値で定義される。

     SPECの要素のDISPLAY部分は、要素を適用するフレームを決定する。SPECの
     1つより多くの要素が指定されたフレームに一致する場合、そのフレームに
     一致した最初の要素だけを用いる。DISPLAYには2つの可能性がある。

     `t'
          SPECの要素はすべてのフレームで一致する。したがって、SPECの以降
          の要素をけっして使わない。通常、`t'はSPECの最後の（あるいは唯
          一）の要素に使う。

     リスト
          DISPLAYがリストであると、各要素は`(CHARACTERISTIC VALUE...)'の
          形であること。ここで、CHARACTERISTICはフレームの分類方法であり、
          VALUEはDISPLAYを適用すべき分類とみなす値である。特性
          CHARACTERISTICの可能な値はつぎのとおりである。

          `type'
               フレームが使用するウィンドウシステムの種類であり、`x'、
               `pc'（MS-DOSのコンソール）、`w32'（MS Windows 9X/NT）、
               `tty'のいずれかである。

          `class'
               フレームで扱える表示色の種類であり、`color'、`grayscale'、
               `mono'のいずれかである。

          `background'
               背景の種類であり、`light'か`dark'のいずれかである。

          DISPLAYの1つの要素において、指定されたCHARACTERISTICに1つより
          多くのVALUEを指定すると、それらのいずれの値でも受け入れる。
          DISPLAYに1つより多くの要素がある場合、各要素は異なる
          CHARACTERISTICを指定すること。そうすれば、フレームの*各*特性は
          DISPLAYに指定されたそのフレーム向けのVALUEの1つに一致するはず
          である。

標準フェイス`region'を`defface'で定義するとつぎのようになります。

     (defface region
              ((((class color) (background dark))
                (:background "blue"))
               (t (:background "gray")))
       "Used for displaying the region.")

内部的には`defface'は、`defface'に指定されたフェイス属性の記録にはシンボ
ルの属性`face-defface-spec'、カスタマイズバッファでユーザーが保存した属
性の記録には`saved-face'、説明文字列の記録には`face-documentation'を使い
ます。

 -- User Option: frame-background-mode
     このオプションが`nil'以外であると、フェイスの定義を解釈する際に用い
     る背景の型を指定する。これが`dark'であると、実際の背景色に関わらず
     Emacsはすべてのフレームの背景は暗いとみなす。これが`light'であると、
     Emacsはすべてのフレームの背景は明るいとみなす。



File: elisp-ja.info, Node: Merging Faces, Next: Face Functions, Prev: Defining Faces, Up: Faces

表示向けにフェイスを併合する
----------------------------

テキストの表示に使用するフェイスを指定する方法はつぎのとおりです。

   * デフォルトを使う。各フレームには"デフォルトのフェイス"があり、他の
     フェイスを指定していないすべてのテキストに使用される。（Emacsの将来
     の版では、すべてのテキスト向けのデフォルトに変更するかもしれない。）

   * テキスト属性を使う。文字は属性`face'を持てる。それがある場合、その
     フェイスで表示される。*Note Special Properties::。

     文字に属性`mouse-face'がある場合は、マウスが文字に『十分近い』とき
     には属性`face'のかわりにそれを使う。

   * オーバレイを使う。オーバレイは属性`face'や`mouse-face'を持てる。そ
     のオーバレイが覆うすべてのテキストに適用される。

   * 活性なリージョンを使う。暫定マーク（transient-mark）モードでは、リー
     ジョンを特定のフェイス（下記の`region-face'を参照）で強調表示する。

   * 特別な字形を使う。各字形では特定のフェイス番号を指定できる。*Note
     Glyphs::。

ある文字に対してこれらのさまざまな指定が1つより多くのフェイスを指定する
場合、Emacsは指定されたさまざまなフェイスの属性を併合します。特別な字形
のフェイスが最初です。適切ならば、つぎはリージョンの強調表示のフェイスで
す。そのつぎはオーバレイのフェイスの属性、さらにテキスト属性のフェイスが
続き、最後はデフォルトのフェイスです。

複数のオーバレイが1つの文字を覆う場合、高い優先順位のオーバレイが低いも
のに優先します。*Note Overlays::。

フォントや表示色のような属性がうえのどれでも指定されていない場合には、フ
レーム独自のフォントや表示色を使います。



File: elisp-ja.info, Node: Face Functions, Prev: Merging Faces, Up: Faces

フェイスを扱う関数
------------------

フェイスの属性で指定できるのは、フォント、前景色、背景色、下線です。フェ
イスでは値`nil'を指定することでこれらを未指定にできます。

以下は、フェイスを作成したり変更する基本関数です。

 -- Function: make-face NAME
     この関数は、すべての属性を`nil'としたNAMEという名前の新たなフェイス
     を定義する。NAMEという名前のフェイスが既存ならばなにもしない。

 -- Function: face-list
     この関数は、定義済みのすべてのフェイス名のリストを返す。

 -- Function: copy-face OLD-FACE NEW-NAME &optional FRAME NEW-FRAME
     この関数は、既存のOLD-FACEという名前のフェイスのコピーとしてフェイ
     スNEW-NAMEを定義する。NEW-NAMEが既存でなければ、フェイスNEW-NAMEを
     作成する。

     省略可能な引数フレームFRAMEを指定すると、この関数はそのフレームだけ
     に適用する。さもなければ、各フレームにおいて個別に、そのフレームの
     OLD-FACEの属性を同じフレームのNEW-FACEにコピーする。

     省略可能な引数フレームNEW-FRAMEを指定すると、`copy-face'はフレーム
     FRAMEのOLD-FACEの属性をフレームNEW-FRAMEのNEW-FACEにコピーする。

以下の関数を使って既存のフレームの属性を変更できます。フレームFRAMEを指
定すると、そのフレームだけに影響します。さもなければ、新たなフレームに適
用されるデフォルトに加えてすべてのフレームに影響します。

 -- Function: set-face-foreground FACE COLOR &optional FRAME
 -- Function: set-face-background FACE COLOR &optional FRAME
     これらの関数は、フェイスFACEの前景色（あるいは背景色）としてCOLORを
     設定する。引数COLORは、表示色名の文字列であること。

     白黒スクリーンでは、濃淡は点猫パターンで実現する。

 -- Function: set-face-stipple FACE PATTERN &optional FRAME
     この関数は、フェイスFACEの背景点猫パターンとしてPATTERNを設定する。
     引数PATTERNは、Xサーバーで定義された背景点猫パターンの名前であるこ
     と。あるいは、点猫を使わないことを意味する`nil'であること。

     白黒階調の特定の濃淡を扱うために自動的に点猫パターンを使うため、普
     通は点猫パターンに注意する必要はない。

 -- Function: set-face-font FACE FONT &optional FRAME
     この関数は、フェイスFACEのフォントを設定する。引数FONTは、読者のシ
     ステムの正しいフォント名かEmacsのフォントセット名（*Note Fontsets::）
     の文字列であること。フォントを明示的に設定するとつねに正確にそれを
     使うため、太字（bold）や斜体（italic）の属性の効果は消失することに
     注意。

 -- Function: set-face-bold-p FACE BOLD-P &optional FRAME
     この関数は、フェイスFACEの太字（bold）の属性を設定する。`nil'以外は
     太字あり、`nil'は太字なしを意味する。

 -- Function: set-face-italic-p FACE ITALIC-P &optional FRAME
     この関数は、フェイスFACEの斜体（italic）の属性を設定する。`nil'以外
     は斜体あり、`nil'は斜体なしを意味する。

 -- Function: set-face-underline-p FACE UNDERLINE-P &optional FRAME
     この関数は、フェイスFACEの下線の属性を設定する。`nil'以外は下線あり、
     `nil'は下線なしを意味する。

 -- Function: invert-face FACE &optional FRAME
     フェイスFACEの前景色と背景色を入れ換える。フェイスに前景色と背景色
     の両者が設定されていないと、その前景色と背景色にはデフォルトの背景
     色と前景色を設定する。

つぎの関数は、フェイスの属性を調べます。フレームFRAMEを指定しない場合、
新たなフレーム向けのデフォルトのデータを参照します。

 -- Function: face-foreground FACE &optional FRAME
 -- Function: face-background FACE &optional FRAME
     この関数は、フェイスFACEの前景色（あるいは背景色）を文字列で返す。

 -- Function: face-stipple FACE &optional FRAME
     この関数は、フェイスFACEの背景点猫パターンの名前を返す。なければ
     `nil'を返す。

 -- Function: face-font FACE &optional FRAME
     この関数はフェイスFACEのフォントの名前を返す。

 -- Function: face-bold-p FACE &optional FRAME
     この関数はフェイスFACEの太字（bold）属性を返す。

 -- Function: face-italic-p FACE &optional FRAME
     この関数はフェイスFACEの斜体（italic）属性を返す。

 -- Function: face-underline-p FACE &optional FRAME
     この関数はフェイスFACEの下線属性を返す。

 -- Function: face-id FACE
     この関数はフェイスFACEのフェイス番号を返す。

 -- Function: face-documentation FACE
     この関数はフェイスFACEの説明文字列を返す。なければ`nil'を返す。

 -- Function: face-equal FACE1 FACE2 &optional FRAME
     この関数は、フェイスFACE1とFACE2が表示上の同じ属性を持てば`t'を返す。

 -- Function: face-differs-from-default-p FACE &optional FRAME
     この関数は、フェイスFACEの表示がデフォルトのフェイスの表示と異なる
     場合には`t'を返す。フェイスの各属性がデフォルトフェイスの対応する属
     性に等しいか（デフォルトから継承すること意味する）`nil'であると、フェ
     イスはデフォルトのフェイスと『等しい』とみなす。

 -- Variable: region-face
     この変数の値は、リージョンが活性（暫定マーク（transient-mark）モー
     ドのみ）の場合にリージョン内の文字の表示に使用するフェイス番号を指
     定する。リージョン内の文字では、これが指定するフェイスがテキスト属
     性やオーバレイのすべてのフェイスに優先する。暫定マーク
     （transient-mark）モードについて詳しくは、*Note The Mark::。

     通常、値は`region'という名前のフェイスのフェイス番号である。

 -- Function: frame-update-face-colors FRAME
     この関数は、フレームFRAMEの前景色や背景色を変更後にフレームFRAME上
     のフェイスの表示を更新する。



File: elisp-ja.info, Node: Blinking, Next: Inverse Video, Prev: Faces, Up: Display

括弧を点滅する
==============

本節では、ユーザーが閉じ括弧を挿入したときにEmacsが対応する開き括弧を指
し示す機構について述べます。

 -- Variable: blink-paren-function
     この変数の値は、閉じ括弧構文の文字が挿入されるたびに呼び出される
     （引数なしの）関数であること。`blink-paren-function'の値が`nil'であ
     ると、なにもしない。

 -- User Option: blink-matching-paren
     この変数が`nil'であると、`blink-matching-open'はなにもしない。

 -- User Option: blink-matching-paren-distance
     この変数は、対応する括弧の走査を諦めるまでの最大距離を指定する。

 -- User Option: blink-matching-delay
     この関数は、対応する括弧にカーソルを留める秒数を指定する。秒未満を
     指定してもしばしば結果は良好であるが、デフォルトはすべてのシステム
     で動作する1である。

 -- コマンド: blink-matching-open
     この関数は、`blink-paren-function'のデフォルト値である。閉じ括弧構
     文の文字のうしろにポイントがあることを仮定し、カーソルを対応する開
     き括弧へ一時的に移動する。その文字がスクリーン上になければ、その文
     字が現れる文脈をエコー領域に表示する。遅れが大きくならないように、
     `blink-matching-paren-distance'文字より離れては探さない。

     つぎは、この関数を明示的に呼び出す例である。

          (defun interactive-blink-matching-open ()
            "Indicate momentarily the start of sexp before point."
            (interactive)
            (let ((blink-matching-paren-distance
                   (buffer-size))
                  (blink-matching-paren t))
              (blink-matching-open)))



File: elisp-ja.info, Node: Inverse Video, Next: Usual Display, Prev: Blinking, Up: Display

反転表示
========

 -- User Option: inverse-video
     この変数は、スクリーン上のすべてのテキストに反転表示を使うかどうか
     を制御する。`nil'以外は使うことを意味し、`nil'は使わないことを意味
     する。デフォルトは`nil'である。

 -- User Option: mode-line-inverse-video
     この変数は、モード行に反転表示を使うかどうかを制御する。`nil'以外で
     あると、モード行を反転表示する。さもなければ、テキストと同様にモー
     ド行を普通に表示する。デフォルトは`t'である。

     ウィンドウフレームでは、`modeline'という名前のフェイスを使ってモー
     ド行を表示する。このフェイスは、変更していなければ、デフォルトフェ
     イスの反転表示である。



File: elisp-ja.info, Node: Usual Display, Next: Display Tables, Prev: Inverse Video, Up: Display

通常の画面表示慣習
==================

通常の画面表示慣習は、各文字コードをどのように表示するかを定義します。表
示テーブル（*Note Display Tables::）を設定すれば、これらの慣習を無効にで
きます。通常の画面表示慣習をつぎに示します。

   * 文字コード32から126は、字形コード32から126に対応付ける。これは各文
     字をそのまま表示することを普通は意味する。

   * 文字コード9は水平タブである。`tab-width'で決定される位置まで空白と
     して表示する。

   * 文字コード10は改行である。

   * 0から31の範囲とコード127のコードすべてには、`ctl-arrow'の値に従って
     2つの表示方法の一方を使う。`ctl-arrow'が`nil'以外であると、これらの
     コードを2つの字形列に対応付け、最初の字形は`^'のASCIIコードである。
     （表示テーブルで`^'のかわりに使う字形を指定できる。）さもなければ、
     これらは128から255の範囲のコードと同様に対応付ける。

   * 文字コード128から255は、4つの字形列に対応付ける。つまり、最初の字形
     は`\'のASCIIコード、残りは文字コードを8進数表示した数字文字である。
     （表示テーブルで`\'のかわりに使う字形を指定できる。）

   * 256を越えるマルチバイト文字コードは、そのまま表示する。あるいは、端
     末に表示できない文字は、疑問符か白抜きの箱で表示する。

通常の画面表示慣習は、たとえ表示テーブルがあっても、活性な表示テーブルに
おいてその文字に対する項目が`nil'であるような文字すべてに適用されます。
したがって、表示テーブルを設定するときには、特別なふるまいをさせたい文字
だけを指定すればよいのです。

これらの変数は、特定の文字群のスクリーンへの表示方法に影響します。これら
は文字が占めるコラム数を変化させるので、字下げ関数にも影響します。これら
の変数は、モード行の表示方法にも影響します。新たな値を用いてモード行の再
表示を強制したいときには、関数`force-mode-line-update'（*Note Mode Line
Format::）を呼び出します。

 -- User Option: ctl-arrow
     このバッファローカルな変数は、コントロール文字の表示方法を制御する。
     `nil'以外であると、`^A'のようにカレットに続けて文字を表示する。
     `nil'であると、`\001'のようにバックスラッシュに続けて3桁の8進数字で
     表示する。

 -- Variable: default-ctl-arrow
     この変数の値は、`ctl-arrow'を書き換えていないバッファ向けの
     `ctl-arrow'のデフォルト値である。*Note Default Value::。

 -- User Option: tab-width
     この変数の値は、Emacsのバッファ内のタブ文字の表示に使うタブストップ
     の間隔である。デフォルトは8である。この機能は、コマンド
     `tab-to-tab-stop'で設定するユーザー設定可能なタブストップとはまった
     く独立であることに注意。*Note Indent Tabs::。



File: elisp-ja.info, Node: Display Tables, Next: Beeping, Prev: Usual Display, Up: Display

表示テーブル
============

"表示テーブル"（display table）機能を使って、すべての可能な文字コードの
スクリーンへの表示方法を制御できます。これは、ASCII文字集合にない文字を
用いるヨーロッパの言語を表示するのに有用です。

表示テーブルは、各文字コードを"字形"（glyph）の列に対応付けます。各字形
は、スクリーン上で1文字を占める像です。"字形テーブル"（glyph table）を使
えば、読者の端末に各字形を表示する方法を定義することもできます。

表示テーブルは、モード行の表示方法にも影響します。新たな表示テーブルを用
いてモード行の再表示を強制したいときには、関数`force-mode-line-update'
（*Note Mode Line Format::）を呼び出します。

* Menu:

* Display Table Format::	What a display table consists of.
* Active Display Table::	How Emacs selects a display table to use.
* Glyphs::			How to define a glyph, and what glyphs mean.



File: elisp-ja.info, Node: Display Table Format, Next: Active Display Table, Prev: Display Tables, Up: Display Tables

表示テーブルの書式
------------------

表示テーブルは、実際にはサブタイプが`display-table'である文字テーブル
（*Note Char-Tables::）です。

 -- Function: make-display-table
     表示テーブルを作成して返す。テーブルのすべての要素の初期値は`nil'で
     ある。

表示テーブルの通常の要素は、文字コードで添字付けします。添字Cの要素は、
文字コードCの表示方法を指定します。値は`nil'であるか、字形の値のベクトル
（*Note Glyphs::）です。要素が`nil'であると、その文字を通常の画面表示慣
習（*Note Usual Display::）に従って表示する指定です。

表示テーブルを使って改行文字の表示を変更すると、バッファ全体は長い1つの
『行』として表示されます。

表示テーブルには6つの『追加スロット』もあり、それらは特別な目的を果たし
ます。それらの意味をつぎに示します。スロットの内容が`nil'であると、その
スロットに対して以下に述べるデフォルトを使うことを意味します。

0
     切り詰めたスクリーン行の末尾に使う字形（デフォルトは`$'）。*Note
     Glyphs::。
1
     継続している行の末尾に使う字形（デフォルトは`\'）。
2
     文字を8進数文字コードで表示したことを表す字形（デフォルトは`\'）。
3
     コントロール文字を表す字形（デフォルトは`^'）。
4
     符可視な行があることを表す字形のベクトル（デフォルトは`...'）。
     *Note Selective Display::。
5
     左右に隣り合ったウィンドウの境界に使う字形（デフォルトは`|'）。
     *Note Splitting Windows::。

たとえば、`ctl-arrow'に`nil'以外の値を設定した効果を模倣する表示テーブル
の作成方法をつぎに示します。

     (setq disptab (make-display-table))
     (let ((i 0))
       (while (< i 32)
         (or (= i ?\t) (= i ?\n)
             (aset disptab i (vector ?^ (+ i 64))))
         (setq i (1+ i)))
       (aset disptab 127 (vector ?^ ??)))

 -- Function: display-table-slot DISPLAY-TABLE SLOT
     この関数は表示テーブルDISPLAY-TABLEの追加スロットSLOTの値を返す。引
     数SLOTは0から5までの数であるか、スロット名（シンボル）であること。
     正しいシンボルは、`truncation'、`wrap'、`escape'、`control'、
     `selective-display'、`vertical-border'である。

 -- Function: set-display-table-slot DISPLAY-TABLE SLOT VALUE
     この関数は表示テーブルDISPLAY-TABLEの追加スロットSLOTに値VALUEを保
     存する。引数SLOTは0から5までの数であるか、スロット名（シンボル）で
     あること。正しいシンボルは、`truncation'、`wrap'、`escape'、
     `control'、`selective-display'、`vertical-border'である。



File: elisp-ja.info, Node: Active Display Table, Next: Glyphs, Prev: Display Table Format, Up: Display Tables

活性な表示テーブル
------------------

各ウィンドウに表示テーブルを指定でき、各バッファにも表示テーブルを指定で
きます。バッファBがウィンドウWに表示されているとき、ウィンドウWに表示テー
ブルがあればそれを使って表示します。さもなければ、バッファBに表示テーブ
ルがあればそれを使います。それ以外では、標準の表示テーブルがあればそれを
使います。選択されている表示テーブルを"活性な"表示テーブルと呼びます。

 -- Function: window-display-table WINDOW
     この関数は、ウィンドウWINDOWの表示テーブルを返す。WINDOWに表示テー
     ブルが割り付けられていなければ`nil'を返す。

 -- Function: set-window-display-table WINDOW TABLE
     この関数は、ウィンドウWINDOWの表示テーブルとしてTABLEを設定する。引
     数TABLEは、表示テーブルであるか`nil'であること。

 -- Variable: buffer-display-table
     この変数はすべてのバッファで自動的にバッファローカルである。バッファ
     での値は、そのバッファに対して用いる表示テーブルを指定する。それが
     `nil'であると、バッファに表示テーブルを割り付けていないことを意味す
     る。

 -- Variable: standard-display-table
     この変数の値はデフォルトの表示テーブルであり、ウィンドウに表示テー
     ブルがなくそのウィンドウのバッファにも表示テーブルがない場合に使わ
     れる。この変数はデフォルトでは`nil'である。

特定のウィンドウにおいて使用する表示テーブルがない場合には、つまり、ウィ
ンドウで未指定であり、そのバッファでも未指定であり、
`standard-display-table'が`nil'である場合には、そのウィンドウ内のすべて
の文字コードには通常の画面表示慣習を使います。*Note Usual Display::。



File: elisp-ja.info, Node: Glyphs, Prev: Active Display Table, Up: Display Tables

字形
----

"字形"（glyph）は、文字を一般化したものです。スクリーン上で1文字を占める
像を表します。文字と同様に、字形はLispでは整数で表現します。

字形としての各整数の意味は、字形テーブルで定義されます。これは変数
`glyph-table'の値です。

 -- Variable: glyph-table
     この変数の値は、現在の字形テーブルである。これはベクトルであること。
     G番目の要素は、字形コードGを定義する。値がベクトルではなく`nil'であ
     ると、すべての字形は単純（下記参照）である。

字形テーブルの要素として可能な型はつぎのとおりです。

STRING
     この字形を出力するために端末へSTRINGの文字群を送出する。これは文字
     端末では使えるがウィンドウシステムでは使えない。

INTEGER
     この字形コードを字形コードINTEGERの別称として定義する。字形に対して
     フェイスコードを指定するために別称を使うことができる。下記参照。

`nil'
     この字形は単純である。通常の端末では、字形コード mod 524288 は出力
     すべき文字である。ウィンドウシステムでは、字形コード mod 524288 は
     出力すべき文字あり、字形コードを524288で除した値は出力中に使用すべ
     きフェイス番号（*Note Face Functions::）である。（524288は2**19。）
     *Note Faces::。

字形コードが字形テーブルの長さに等しいか大きいと、そのコードは自動的に単
純とします。



File: elisp-ja.info, Node: Beeping, Next: Window Systems, Prev: Display Tables, Up: Display

ベルを鳴らす
============

本節では、ユーザーの注意を引くためにEmacsにベルを鳴らせる（あるいはスク
リーンを点滅させる）方法について述べます。ベルを鳴らす頻度はなるべく控え
めにしてください。頻繁にベルが鳴るとわずらわしいものです。エラーを通知す
るほうがふさわしいときには、単にベルを鳴らさないように注意してください。
（*Note Errors::。）

 -- Function: ding &optional DO-NOT-TERMINATE
     この関数は、ベルを鳴らすかスクリーンを点滅する（下記の
     `visible-bell'を参照）。また、DO-NOT-TERMINATEが`nil'であると現在実
     行中のキーボードマクロを終了する。

 -- Function: beep &optional DO-NOT-TERMINATE
     `ding'の同義語。

 -- User Option: visible-bell
     この変数は、ベルを鳴らすかわりにスクリーンを点滅させるかどうかを決
     定する。`nil'以外であると点滅するを意味し、`nil'であると点滅しない
     を意味する。これは、ウィンドウシステムを用いている場合か、端末の
     termcapの定義にビジュアルベル機能（`vb'）がある文字端末で有効である。

 -- Variable: ring-bell-function
     これが`nil'以外であると、Emacsに『ベルを鳴らす』方法を指定する。こ
     の値は、引数なしの関数であること。



File: elisp-ja.info, Node: Window Systems, Prev: Beeping, Up: Display

ウィンドウシステム
==================

Emacsはいくつかのウィンドウシステムで、特にXウィンドウシステムで動作しま
す。EmacsもXも用語『ウィンドウ』を使いますが、用法は異なります。Emacsの1
つのフレームは、Xでは1つのウィンドウです。Emacsの個々のウィンドウについ
ては、Xはまったくわかりません。

 -- Variable: window-system
     この変数は、Emacsが動作しているウィンドウシステムの種類をLispプログ
     ラムに伝える。可能な値はつぎのとおりである。

     `x'
          Xを用いて表示している。
     `pc'
          MSDOSを用いて表示している。
     `w32'
          Windows NTかWindows 95を用いて表示している。
     `nil'
          文字ベースの端末を用いて表示している。

 -- Variable: window-setup-hook
     この変数は、Emacsが初期化ファイルを処理したあとに実行するノーマルフッ
     クである。読者のファイル`.emacs'、（あれば）デフォルトの初期化ファ
     イル、端末固有のLispコードをすべてロードし、フック`term-setup-hook'
     を実行し終えてから、このフック実行する。

     このフックは内部目的用であり、ウィンドウシステムとの通信を設定し、
     最初のウィンドウを作成する。ユーザーが干渉すべきではない。


File: elisp-ja.info, Node: Calendar, Next: Tips, Prev: Display, Up: Top

カレンダーと日誌のカスタマイズ
******************************

カレンダーや日誌を個人の好みに合わせるためのカスタマイズ項目がたくさんあ
ります。

* Menu:

* Calendar Customizing::   Defaults you can set.
* Holiday Customizing::    Defining your own holidays.
* Date Display Format::    Changing the format.
* Time Display Format::    Changing the format.
* Daylight Savings::       Changing the default.
* Diary Customizing::      Defaults you can set.
* Hebrew/Islamic Entries:: How to obtain them.
* Fancy Diary Display::    Enhancing the diary display, sorting entries, 
                             using included diary files.
* Sexp Diary Entries::     Fancy things you can do.
* Appt Customizing::	   Customizing appointment reminders.



File: elisp-ja.info, Node: Calendar Customizing, Next: Holiday Customizing, Prev: Calendar, Up: Calendar

カレンダーのカスタマイズ
========================

変数`view-diary-entries-initially'に`t'を設定しておくと、カレンダーを呼
び出すと現在の日に対する日誌記録を自動的に表示できます。その日がウィンド
ウで見える場合に限って日誌記録が表示されます。つぎの行、

     (setq view-diary-entries-initially t)
     (calendar)

を個人のファイル`.emacs'に入れておくと、Emacsを起動するたびに、カレンダー
と日誌の両者のウィンドウを表示します。

同様に、変数`view-calendar-holidays-initially'に`t'を設定しておくと、カ
レンダーに入ると自動的に3か月分の祝祭日一覧を表示します。祝祭日一覧は別
のウィンドウに現れます。

変数`mark-diary-entries-in-calendar'に`t'を設定すると、日誌に入れてある
日付に印を付けられます。カレンダーのウィンドウ内容を再計算するときにこの
効果が現れます。これらの日付に印を付ける方法は2つあります。ディスプレイ
で使えるならばフェイス（*Note Faces::）を変更するか、日付にプラス記号
（`+'）を付加します。

同様に、変数`mark-holidays-in-calendar'に`t'を設定すると、フェイスを変え
るかアスタリスク（`*'）を付加することで祝祭日に印を付けられます。

変数`calendar-holiday-marker'は、祝祭日の日付にどのように印を付けるかを
指定します。その値は、日付に付加する文字か日付の表示に使うフェイス名です。
同様に、変数`diary-entry-marker'は、日誌に入っている日付にどのように印を
付けるかを指定します。カレンダー（calendar）モードは、このような目的のた
めに`holiday-face'と`diary-face'という名前のフェイスを作成します。Emacs
が端末で複数のフェイスを扱える場合には、これらの変数のデフォルト値はこれ
らのシンボルです。

変数`calendar-load-hook'は、（カレンダーを実際に表示し始めるまえに）カレ
ンダーパッケージを初めてロードしたときに実行されるノーマルフックです。

カレンダーを開始するとノーマルフック`initial-calendar-window-hook'を実行
します。カレンダーの表示を再計算してもこのフックは実行されません。しかし、
コマンド`q'でカレンダーを抜けてから再度カレンダーに入るとこのフックを再
度実行します。

変数`today-visible-calendar-hook'は、今日の日付がウィンドウで見えるとき
にカレンダーバッファにカレンダーの準備を終えてから実行されるノーマルフッ
クです。このフックの1つの用途は、今日の日付をアスタリスクで置き換えるこ
とです。それにはフック関数`calendar-star-date'を使います。

     (add-hook 'today-visible-calendar-hook 'calendar-star-date)

他の標準的なフック関数は、フェイスを変更するかアスタリスクを付加すること
で現在の日付に印を付けます。つぎのように使います。

     (add-hook 'today-visible-calendar-hook 'calendar-mark-today)

変数`calendar-today-marker'は、今日の日付の印の付け方を指定します。その
値は、日付に付加する文字か日付の表示に使うフェイス名です。この目的のため
に`calendar-today-face'という名前のフェイスがあります。Emacsが端末で複数
のフェイスを扱える場合には、この変数のデフォルト値はこのシンボルです。

同様なノーマルフック`today-invisible-calendar-hook'は、現在の日付がウィ
ンドウで見え*ない*ときに実行されます。



File: elisp-ja.info, Node: Holiday Customizing, Next: Date Display Format, Prev: Calendar Customizing, Up: Calendar

祝祭日のカスタマイズ
====================

Emacsは、複数のリストの中の1つのリストに入っている項目群で定義される祝祭
日を把握しています。これらの祝祭日のリストに祝祭日を追加したり削除して個
人の目的に合うようにカスタマイズできます。Emacsが使用する祝祭日のリスト
は、一般祝祭日（`general-holidays'）、地域祝祭日（`local-holidays'）、キ
リスト教祝祭日（`christian-holidays'）、ヘブライ（ユダヤ教）祝祭日
（`hebrew-holidays'）、イスラム（回教徒）祝祭日（`islamic-holidays'）、
その他の祝祭日（`other-holidays'）です。

一般祝祭日は、デフォルトでは、合州国に共通の祝祭日です。これらの祝祭日を
削除するには、`general-holidays'に`nil'を設定します。

デフォルトの地域祝祭日はありません（サイトによってはある）。以下に述べる
ように、変数`local-holidays'に祝祭日の任意のリストを設定できます。

デフォルトでは、Emacsが承知している宗教のすべての祝祭日がEmacsに入ってい
るのではなく、世俗的なカレンダーに共通するものだけです。宗教上の祝祭日を
網羅的に入れるには、`all-christian-calendar-holidays'、
`all-hebrew-calendar-holidays'、`all-islamic-calendar-holidays'の変数の
いずれか（あるいは、すべて）に`t'を設定します。宗教上の祝祭日を削除する
には、対応する`christian-holidays'、`hebrew-holidays'、
`islamic-holidays'の変数のいずれか（あるいは、すべて）に`nil'を設定しま
す。

変数`other-holidays'には、祝祭日の任意のリストを設定できます。このリスト
は、普通は空ですが、個人的な使用を意図しています。

リスト（`general-holidays'、`local-holidays'、`christian-holidays'、
`hebrew-holidays'、`islamic-holidays'、`other-holidays'）のおのおのは、
祝祭日（あるいは祝祭日のリスト）を記述する"祝祭日形式"（holiday form）か
ら成るリストです。

可能な祝祭日形式の一覧をつぎに示します。月と日は1から数えますが、『曜日』
は日曜日を0と数えます。要素STRINGは、文字列で表した祝祭日の名称です。

`(holiday-fixed MONTH DAY STRING)'
     グレゴリオ暦の固定した日付。

`(holiday-float MONTH DAYNAME K STRING)'
     グレゴリオ暦のMONTH月のK番目の曜日DAYNAME。（日曜日はDAYNAME=0、…。）
     Kが負であると、月末から数える。

`(holiday-hebrew MONTH DAY STRING)'
     ヘブライ暦の固定した日付。

`(holiday-islamic MONTH DAY STRING)'
     イスラム暦の固定した日付。

`(holiday-julian MONTH DAY STRING)'
     ユリウス暦の固定した日付。

`(holiday-sexp SEXP STRING)'
     Lisp式SEXPで計算される日付。計算式では、年として変数`year'を使い、
     祝祭日の日付を返す。あるいは、その年に該当する祝祭日がなければ`nil'
     を返す。SEXPの値は、`(MONTH DAY YEAR)'の形のリストで表した日付であ
     ること。

`(if CONDITION HOLIDAY-FORM)'
     条件CONDITIONが真である場合にのみ祝祭日になる。

`(FUNCTION [ARGS])'
     引数ARGSで関数FUNCTIONを呼び出して計算される日付のリスト。

たとえば、フランスで7月14日に祝われる革命記念日（Bastille Day）を扱える
ようにするにはつぎのようにします。

     (setq other-holidays '((holiday-fixed 7 14 "Bastille Day")))

祝祭日形式 `(holiday-fixed 7 14 "Bastille Day")'は、7の月（7月）の14日目
を指定します。

多くの祝祭日は、特定の月の特定の週にあります。バージン諸島で4月の第4月曜
日に祝われるハリケーン祈願日（Hurricane Supplication Day）を記述する祝祭
日形式はつぎのようになります。

     (holiday-float 8 1 4 "Hurricane Supplication Day")

ここで、8は8月、1は月曜日（日曜日は0、火曜日は2といった具合）、4はその月
の4回目（1は最初、2は2回目、-1は最後、-2は最後の1つまえといった具合）を
意味します。

ヘブライ暦、イスラム暦、ユリウス暦の固定した日付の祝祭日も指定できます。
たとえば、

     (setq other-holidays
           '((holiday-hebrew 10 2 "Last day of Hanukkah")
             (holiday-islamic 3 12 "Mohammed's Birthday")
             (holiday-julian 4 2 "Jefferson's Birthday")))

は、ハヌカー祭の最終日（ヘブライ暦の月はニサンNisanを1と数える）、イスラ
ムが祝うモハメッドの誕生日（イスラム暦の月はムハラMuharramを1と数える）、
ユリウス暦の1743年4月2日のトーマスジェファーソンの誕生日を追加します。

条件付きの祝祭日を含めるには、Emacs Lispの`if'や`holiday-sexp'を使います。
たとえば、アメリカ大統領選挙は、4で割り切れる年の11月の第1月曜日のあとの
最初の火曜日に行われます。

     (holiday-sexp (if (= 0 (% year 4))
                        (calendar-gregorian-from-absolute
                         (1+ (calendar-dayname-on-or-before
                               1 (+ 6 (calendar-absolute-from-gregorian
                                       (list 11 1 year))))))
                   "US Presidential Election"))

あるいは、

     (if (= 0 (% displayed-year 4))
         (fixed 11
                (extract-calendar-day
                  (calendar-gregorian-from-absolute
                    (1+ (calendar-dayname-on-or-before
                          1 (+ 6 (calendar-absolute-from-gregorian
                                   (list 11 1 displayed-year)))))))
                "US Presidential Election"))

特別な計算を必要とする祝祭日は、これまでの形式にあてはまりません。そのよ
うな場合、計算を行うLisp関数を書く必要があります。たとえば、日食月食を含
めるには、`other-holidays'に`(eclipses)'を追加して、以下のような形でカレ
ンダーウィンドウの見えている範囲の期間内の対応するグレゴリオ暦の日付の
（空である可能性もある）リストを返すEmacs Lisp関数`(eclipses)'を書きます。

     (((6 27 1991) "Lunar Eclipse") ((7 11 1991) "Solar Eclipse") ... )



File: elisp-ja.info, Node: Date Display Format, Next: Time Display Format, Prev: Holiday Customizing, Up: Calendar

日付表示書式
============

日誌、モード行、メッセージに現れる日付の表示方法は、
`calendar-date-display-form'を設定することでカスタマイズできます。この変
数は、文字列で表した数字が入った`month'、`day'、`year'の各変数と、英字の
文字列が入った`monthname'と`dayname'の各変数を用いた式のリストを保持して
います。アメリカスタイルでは、このリストのデフォルト値はつぎのようになり
ます。

     ((if dayname (concat dayname ", ")) monthname " " day ", " year)

一方、ヨーロッパスタイルでは、この値のデフォルトはつぎのようになります。

     ((if dayname (concat dayname ", ")) day " " monthname " " year)

ISO規格の日付の表記法はつぎのとおりです。

     (year "-" month "-" day)

典型的なアメリカの書式はつぎのとおりです。

     (month "/" day "/" (substring year -2))



File: elisp-ja.info, Node: Time Display Format, Next: Daylight Savings, Prev: Date Display Format, Up: Calendar

時刻表示書式
============

カレンダーと日誌はデフォルトではアメリカスタイル、つまり、12時制で時刻を
表示します。ヨーロッパスタイルやアメリカ軍の24時制を好むならば、変数
`calendar-time-display-form'を変更します。この変数は、文字列で表した数字
が入った`12-hours'、`24-hours'、`minutes'の各変数と、英字の文字列が入っ
た`am-pm'と`time-zone'の各変数を用いた式のリストを保持しています。
`calendar-time-display-form'のデフォルト値はつぎのとおりです。

     (12-hours ":" minutes am-pm
               (if time-zone " (") time-zone (if time-zone ")"))

つぎの値では、ヨーロッパスタイルの時刻になります。

     (24-hours ":" minutes
               (if time-zone " (") time-zone (if time-zone ")"))



File: elisp-ja.info, Node: Daylight Savings, Next: Diary Customizing, Prev: Time Display Format, Up: Calendar

夏時間
======

Emacsは、標準時間と夏時間の違いを理解しています。つまり、日出入時刻、夏
至冬至、春分秋分、朔弦望ではその違いを考慮します。夏時間の規則は、地域ご
と、年ごとに変わりえます。正しく扱うためには、どの規則が適用されるかを
Emacsが知っている必要があります。

読者の居住地域に適用される規則を記録しているオペレーティングシステムもあ
ります。これらのシステム上では、Emacsは自動的にシステムから必要な情報を
得られます。この情報の一部やすべてが欠落していると、GNU世界の中心である
マサチューセッツ州ケンブリッジで現在使用している規則で補います。


デフォルトで選んだ規則が読者の地域に適切でないときには、変数
`calendar-daylight-savings-starts'と`calendar-daylight-savings-ends'に設
定してEmacsに伝えます。これらの値は、変数`year'を使ったLisp式である必要
があります。これらの式を評価すると、夏時間を開始／終了するグレゴリオ暦の
日付を表す`(MONTH DAY YEAR)'の形のリストになる必要があります。夏時間をと
らない場合には、値は`nil'であるべきです。

Emacsは、これらの式を用いて夏時間の開始と終了を判定し、祝祭日や太陽／月
に関する時刻を補正します。

マサチューセッツ州ケンブリッジに対する値は、つぎのとおりです。

     (calendar-nth-named-day 1 0 4 year)
     (calendar-nth-named-day -1 0 10 year)

つまり、指定された`year'年の4月の最初の日曜日とその年の10月の最後の日曜
日です。10月1日に夏時間を始めると変更したとすると、変数
`calendar-daylight-savings-starts'につぎのように設定します。

     (list 10 1 year)

より複雑な例として、ヘブライ暦のニサンの初日に夏時間が始まるとしましょう。
`calendar-daylight-savings-starts'には、つぎの値を設定します。

     (calendar-gregorian-from-absolute
       (calendar-absolute-from-hebrew
         (list 1 1 (+ year 3760))))

これは、ニサンはヘブライ暦の最初の月であり、ヘブライ暦年とグレゴリオ暦年
はニサンで3760年違うからです。

読者の地域で夏時間をとっていなかったり、つねに標準時間を望む場合には、
`calendar-daylight-savings-starts'と`calendar-daylight-savings-ends'に
`nil'を設定します。

変数`calendar-daylight-time-offset'は、夏時間と標準時間の分で計った差を
指定します。ケンブリッジに対する値は60です。

変数`calendar-daylight-savings-starts-time'と
`calendar-daylight-savings-ends-time'は、夏時間と標準時間との移行が行わ
れる地方時の真夜中の0時からの経過分を指定します。ケンブリッジでは、どち
らの変数の値も120です。



File: elisp-ja.info, Node: Diary Customizing, Next: Hebrew/Islamic Entries, Prev: Daylight Savings, Up: Calendar

日誌のカスタマイズ
==================

通常、日誌用バッファのウィンドウのモード行には、日誌記録の日付に一致する
祝祭日があれば表示されます。祝祭日を検査する処理には数秒を要するので、祝
祭日情報を含めると日誌用バッファの表示に遅れが生じます。祝祭日情報をなく
して日誌用バッファの表示を速くしたい場合には、変数
`holidays-in-diary-buffer'に`nil'を設定します。

変数`number-of-diary-entries'は、一度に表示する日誌記録の日数を制御しま
す。これは、`view-diary-entries-initially'が`t'であるときの最初の表示に
影響します。たとえば、デフォルト値は1で、現在の日付の日誌記録のみを表示
します。値が2であると、現在とつぎの日付の日誌記録を表示します。この値は7
要素のベクトルでもかまいません。たとえば、値が`[0 2 2 2 2 4 1]'であると、
日曜日には日誌記録をなにも表示せず、月曜日から木曜日には現在とつぎの日付
の日誌記録を表示し、金曜日には金曜日から月曜日の日誌記録を表示し、土曜日
にはその日だけの日誌記録を表示します。

変数`print-diary-entries-hook'は、日誌用バッファで現在見えている日誌記録
のみを収めた一時的なバッファの準備ができると実行されるノーマルフックです。
（他の関係ない日誌記録は一時的なバッファには入っていない。日誌用バッファ
ではそれらは隠されている。）このフックのデフォルト値は、コマンド
`lpr-buffer'で印刷します。別のコマンドで印刷したい場合には、単にこのフッ
クの値を変更します。別の用途は、たとえば、行を日付と時刻で並び替えること
です。

`diary-date-forms'に設定すれば、目的に合うように個人の日誌ファイル内の日
付の書式をアメリカスタイルやヨーロッパスタイルにカスタマイズできます。こ
の変数は、日付を認識するパターンのリストです。各パターンは、正規表現
（*Note Regular Expressions::）や`month'、`day'、`year'、`monthname'、
`dayname'のシンボルを要素とするリストです。これらの要素すべては、日誌ファ
イル内の特定種類のテキストに一致するパターンとして働きます。全体として日
付パターンとして一致するには、すべての要素が順に一致する必要があります。

日付パターンの正規表現は、`*'を単語構成文字に変更した標準の構文テーブル
を用いて通常どおりに一致をとります。

`month'、`day'、`year'、`monthname'、`dayname'のシンボルは、対象にしてい
る月、日、年、月の名前、曜日です。数に一致するシンボルは、数の先頭にある
0を許します。名前に一致するシンボルは、3文字の省略形や大文字で始まること
を許します。日誌記録では`*'は『任意の日』『任意に月』などを表し、対象と
する日付に関係なく一致するべきなので、すべてのシンボルは`*'に一致できま
す。

アメリカスタイルの`diary-date-forms'のデフォルト値はつぎのとおりです。

     ((month "/" day "[^/0-9]")
      (month "/" day "/" year "[^0-9]")
      (monthname " *" day "[^,0-9]")
      (monthname " *" day ", *" year "[^0-9]")
      (dayname "\\W"))

リスト内の日付パターンは、*互いに排他的*であり、日誌記録の日付と1つの白
文字以外には他の部分に一致してはいけません。互いに排他的であるためには、
パターンは日付を終える白文字を越えて日誌記録本文に一致する必要があります。
それには、日付パターンの最初の要素は`backup'である必要があります。これに
より、日付を認識する処理では、一致し終えてから日誌記録の現在の単語の先頭
に戻ります。たとえ`backup'を使ったとしても、日付パターンは日誌本体の最初
の単語を越えて一致してはいけません。ヨーロッパスタイルの
`diary-date-forms'のデフォルト値は、つぎのとおりです。

     ((day "/" month "[^/0-9]")
      (day "/" month "/" year "[^0-9]")
      (backup day " *" monthname "\\W+\\<[^*0-9]")
      (day " *" monthname " *" year "[^0-9]")
      (dayname "\\W"))

ここでは、3番目のパターンで`backup'を使っています。4番目のパターンと区別
するために、日付のつぎの単語の一部と一致する必要があるからです。



File: elisp-ja.info, Node: Hebrew/Islamic Entries, Next: Fancy Diary Display, Prev: Diary Customizing, Up: Calendar

ヘブライ暦日付やイスラム暦日付の日誌記録
========================================

日誌ファイルには、世界標準のグレゴリオ暦日付に加えて、ヘブライ暦日付やイ
スラム暦日付を入れることもできます。しかし、そのような記録の認識には時間
がかかり、ほとんどの人はそれらを使わないので、それらは明示的にオンにする
必要があります。日誌でヘブライ暦日付の日誌記録を認識できるように望むなら、
たとえば、つぎのようにする必要があります。

     (add-hook 'nongregorian-diary-listing-hook 'list-hebrew-diary-entries)
     (add-hook 'nongregorian-diary-marking-hook 'mark-hebrew-diary-entries)

イスラム暦日付の日誌記録を望むなら、つぎのようにします。

     (add-hook 'nongregorian-diary-listing-hook 'list-islamic-diary-entries)
     (add-hook 'nongregorian-diary-marking-hook 'mark-islamic-diary-entries)

ヘブライ暦日付やイスラム暦日付の日誌記録は、グレゴリオ暦日付と同じ形式で
すが、ヘブライ暦日付のまえには`H'、イスラム暦日付のまえには`I'がある点が
異なります。さらに、ヘブライ暦やイスラム暦の月は、最初の3文字で一意に決
まらないため、月の省略形は使えません。たとえば、ヘブライ暦日付Heshvan 25
の日誌記録はつぎのようになります。

     HHeshvan 25 Happy Hebrew birthday!

これはヘブライ暦日付Heshvan 25に対する任意の日誌に現れます。イスラム暦日
付Dhu al-Qada 25に一致する日誌記録はつぎのようになります。

     IDhu al-Qada 25 Happy Islamic birthday!

グレゴリオ暦日付の日誌記録では、ヘブライ暦日付とイスラム暦日付の記録は、
それらの前にアンパサンド（`&'）があると印付けされません。

ヘブライ暦やイスラム暦において指定した日付や似た日付に一致する日誌記録を
作成するためのカレンダーのコマンド一覧をつぎに示します。

`i h d'
     選択した日付に対応するヘブライ暦日付に日誌記録を追加する
     （`insert-hebrew-diary-entry'）。
`i h m'
     選択した日付に対応するヘブライ暦月の日に日誌記録を追加する
     （`insert-monthly-hebrew-diary-entry'）。この日誌記録は、選択した日
     付のヘブライ暦の月内の日と同じ任意の日付に一致する。
`i h y'
     選択した日付のヘブライ暦年の日に日誌記録を追加する
     （`insert-yearly-hebrew-diary-entry'）。この日誌記録は、選択した日
     付のヘブライ暦の月とその月内の日と同じ任意の日付に一致する。
`i i d'
     選択した日付に対応するイスラム暦日付に日誌記録を追加する
     （`insert-islamic-diary-entry'）。
`i i m'
     選択した日付に対応するイスラム暦の月内の日に日誌記録を追加する
     （`insert-monthly-islamic-diary-entry'）。
`i i y'
     選択した日付のイスラム暦年の日に日誌記録を追加する
     （`insert-yearly-islamic-diary-entry'）。

これらのコマンドは、日誌記録の対応する普通のコマンドと同様に働きます。カ
レンダーウィンドウにおいてポイントがある日付に作用し、日誌記録の日付に関
する部分のみを挿入します。日誌記録の本文は自分で入力する必要があります。



File: elisp-ja.info, Node: Fancy Diary Display, Next: Sexp Diary Entries, Prev: Hebrew/Islamic Entries, Up: Calendar

装飾日誌表示
============

日誌表示は、日誌用バッファを準備してからフック`diary-display-hook'を実行
することで動作します。このフックのデフォルト値（`simple-diary-display'）
は、関係ない日誌記録を隠してからバッファを表示します。しかし、つぎのよう
にフックを指定すると

     (add-hook 'diary-display-hook 'fancy-diary-display)

装飾日誌表示を行えます。日誌記録と祝祭日を表示専用の特別なバッファにコピー
して表示します。別のバッファにコピーするので、表示テキストが綺麗になるよ
うに変更できます。たとえば、日付順に記録をソートするなどです。

単純な日誌表示では、`print-diary-entries'でバッファ内容を印刷できます。1
週間分の毎日の日誌を印刷するには、その週の日曜日にポイントを置いて`7 d'
と打ってから`M-x print-diary-entries'を行います。祝祭日が入っていると表
示が遅くなりますが、変数`holidays-in-diary-buffer'に`nil'を設定すると速
くできます。

通常、装飾日誌用バッファでは、たとえ祝祭日であっても日誌記録がない日は表
示しません。そのような日を装飾日誌用バッファに表示するには、変数
`diary-list-include-blanks'に`t'を設定します。

装飾日誌表示を使うときには、ノーマルフック`list-diary-entries-hook'を使っ
て各日誌記録を時刻でソートできます。つぎのようにします。

     (add-hook 'list-diary-entries-hook 'sort-diary-entries t)

これは、各日ごとに認識できる時刻で始まる日誌記録をソートします。各日の先
頭には時刻のついていない日誌項目がきます。

装飾日誌表示には、取り込んだ日誌ファイルを処理する能力もあります。これに
より、グループのメンバは、グループに共通な行事を記述した日誌ファイルを共
有できます。つぎのような行を日誌ファイルに書きます。

     #include "FILENAME"

そうすると、ファイルFILENAMEから日誌記録を装飾日誌用バッファに取り込みま
す。取り込み機構は再帰的ですから、取り込んだファイル内で別のファイルを取
り込むことができます。もちろん、取り込みが循環しないように注意してくださ
い。取り込み機能をオンにするにはつぎのようにします。

     (add-hook 'list-diary-entries-hook 'include-other-diary-files)
     (add-hook 'mark-diary-entries-hook 'mark-included-diary-files)

通常の日誌表示は個人の日誌ファイルの記録を直接表示するため、取り込み機構
は装飾日誌表示でのみ動作します。



File: elisp-ja.info, Node: Sexp Diary Entries, Next: Appt Customizing, Prev: Fancy Diary Display, Up: Calendar

S式項目と装飾日誌表示
=====================

S式を使った日誌記録は、複雑な条件で適用される日誌記録を作る以上のことが
できます。装飾日誌表示を使っている場合には、S式日誌項目は、日付に依存し
た記録テキストを生成できます。たとえば、記念日の記録では、テキストに何回
目の記念日であるかを入れられます。したがって、つぎの日誌記録の`%d'は年齢
で置き換えられます。

     %%(diary-anniversary 10 31 1948) Arthur's birthday (%d years old)

つまり、装飾日誌用バッファでは、1990年10月31日の項目はつぎのようになりま
す。

     Arthur's birthday (42 years old)

日誌ファイルにつぎの項目が入っていると、

     %%(diary-anniversary 10 31 1948) Arthur's %d%s birthday

装飾日誌用バッファでは、1990年10月31日の項目はつぎのようになります。

     Arthur's 42nd birthday

同様に、周期的な日誌項目では繰り返し回数を計算できます。

     %%(diary-cyclic 50 1 1 1990) Renew medication (%d%s time)

は、1990年9月8日の装飾日誌表示ではつぎのようになります。

     Renew medication (5th time)

@noindent

当日の日誌項目としてだけでなく、それよりまえの日の日誌項目にも含めるため
のS式日誌項目があります。たとえば、記念日の1週間前に督促がほしいときには、
つぎのようにします。

     %%(diary-remind '(diary-anniversary 12 22 1968) 7) Ed's anniversary

すると、装飾日誌には、12月15日と12月22日にRuth & Ed's anniversary と表示
されます。

関数`diary-date'は、整数や整数のリストや`t'で指定した月、日、年の組み合
わせで表される日付に適用されます。たとえば、

     %%(diary-date '(10 11 12) 22 t) Rake leaves

により、装飾日誌には、各年の10月22日、11月22日、12月22日には

     Rake leaves

と表示されます。

関数`diary-float'により、11月の第3金曜日とか4月の最後の火曜日といった日
付に適用する日誌記録を記述できます。パラメータは、月MONTH、曜日DAYNAME、
添字Nです。日曜日をDAYNAME=0、月曜日をDAYNAME=1、…として、MONTH月のN番
目の曜日DAYNAMEに項目が現れます。Nが負であると、MONTH月の月末から数えま
す。MONTHは、月のリストでも、1つの月でも、全部の月を指定する`t'でもかま
いません。省略可能なパラメータDAYを指定して、MONTH月のN番目の曜日DAYNAME
の前後のDAY日を指定できます。Nが正だとDAYのデフォルトは1であり、Nが負だ
とDAYのデフォルトはMONTH月の月末です。たとえば、

     %%(diary-float t 1 -1) Pay rent

は、装飾日誌に各月の最後の月曜日に

     Pay rent

を表示します。

S式日誌項目の一般性により、アルゴリズムで日誌項目を指定できます。S式日誌
項目には、項目を当該日に適用するどうかを計算する式を含められます。その値
が`nil'以外であると、その項目を当該日に適用します。その式では、対象とす
る日付を知るために変数`date'を使えます。この変数の値は、グレゴリオ暦で表
したリスト`(MONTH DAY YEAR)'です。

毎月のウィークデイである21日か、21日が週末の場合にはそのまえの金曜日に給
料を支払われるとしましょう。そのような日付に一致するS式日誌項目はつぎの
ように書けます。

     &%%(let ((dayname (calendar-day-of-week date))
              (day (car (cdr date))))
           (or (and (= day 21) (memq dayname '(1 2 3 4 5)))
               (and (memq day '(19 20)) (= dayname 5)))
              ) Pay check deposited

以下のS式日誌項目は、日付に依存して変わるテキストを日誌項目に入れる機能
を（装飾日誌表示で）利用できます。

`%%(diary-sunrise-sunset)'
     今日の地方時での日出入時刻に対する日誌項目を作る。
`%%(diary-phases-of-moon)'
     月に朔弦望に対する日誌項目を作る。
`%%(diary-day-of-year)'
     年内の通算日数と残り日数で今日の日誌項目を作る。
`%%(diary-iso-date)'
     今日に対応するISO商用暦の日誌項目を作る。
`%%(diary-julian-date)'
     今日に対応するユリウス暦の日誌項目を作る。
`%%(diary-astro-day-number)'
     今日に対応する天文通算日（ユリウス日）の日誌項目を作る。
`%%(diary-hebrew-date)'
     今日に対応するヘブライ暦の日誌項目を作る。
`%%(diary-islamic-date)'
     今日に対応するイスラム暦の日誌項目を作る。
`%%(diary-french-date)'
     今日に対応するフランス革命暦の日誌項目を作る。
`%%(diary-mayan-date)'
     今日に対応するマヤ暦の日誌項目を作る。

したがって、

     &%%(diary-hebrew-date)

を含んだ日誌項目は、装飾日誌表示を使っていると、毎日の日誌表示に対応する
ヘブライ暦の日付を含めることになります。（単純な日誌表示では、行
`&%%(diary-hebrew-date)'はすべての日付の日誌に現れるが、特別なことはなに
もしない。）

つぎの関数は、ある標準的な方法でヘブライ暦に基づくS式日誌項目を構成する
ために使えます。

`%%(diary-rosh-hodesh)'
     各ヘブライ月の礼拝の始まりと終りを教える日誌項目を作る。
`%%(diary-parasha)'
     毎週のシナゴーグ朗読会を教える土曜日の日誌項目を作る。
`%%(diary-sabbath-candles)'
     安息日のたそがれの*地方時*を教える金曜日の日誌項目を作る。
`%%(diary-omer)'
     適切ならばオーメル (1) (*Note Sexp Diary Entries-Footnotes::) の回
     数を与える日誌項目を作る。
`%%(diary-yahrzeit MONTH DAY YEAR) NAME'
     命日に対応した日誌項目を作る。命日の日付は*グレゴリオ暦*で指定する。
     正しいヘブライ暦の追悼日とその前日に日誌項目が現れる。（ヨーロッパ
     スタイルでは、パラメータの順序をDAY、MONTH、YEARと変える。）


File: elisp-ja.info  Node: Sexp Diary Entries-Footnotes, Up: Sexp Diary Entries

(1) omer：過ぎ越しの祝い（Passover）の二日目から七週の祭（Shabuoth）
の前日までの49日間



File: elisp-ja.info, Node: Appt Customizing, Prev: Sexp Diary Entries, Up: Calendar

約束の警告表示のカスタマイズ
============================

Emacsにどのように約束の警告表示を行わせ、どの程度前から行わせるかは、つ
ぎの変数に設定することで正確に指定できます。

`appt-message-warning-time'
     約束の警告表示を開始する時間を分で表したもの。デフォルトは10分であ
     る。
`appt-audible'
     これが`nil'以外であると、Emacsは約束の警告表示として端末のベルを鳴
     らす。デフォルトは`t'。
`appt-visible'
     これが`nil'以外であると、Emacsは約束のメッセージをエコー領域に表示
     する。デフォルトは`t'。
`appt-display-mode-line'
     これが`nil'以外であると、Emacsは約束までの残り分数をモード行に表示
     する。デフォルトは`t'。
`appt-msg-window'
     これが`nil'以外であると、Emacsは約束のメッセージを別のウィンドウに
     表示する。デフォルトは`t'。
`appt-disp-window-function'
     この変数は、約束のメッセージを表示するウィンドウを作るための関数を
     保持する。
`appt-delete-window-function'
     この変数は、時間が過ぎたら約束のメッセージを表示したウィンドウを削
     除するための関数を保持する。
`appt-display-duration'
     約束のメッセージを表示する秒数。デフォルトは5秒である。






File: elisp-ja.info, Node: Tips, Next: GNU Emacs Internals, Prev: Calendar, Up: Top

ヒントと慣習
************

本章では、Emacs Lispの機能についてさらに述べることはしません。かわりに、
前章までに述べてきた機能を効率よく使うための助言やEmacs Lispプログラマが
従うべき慣習について述べます。

* Menu:

* Coding Conventions::        Conventions for clean and robust programs.
* Compilation Tips::          Making compiled code run fast.
* Documentation Tips::        Writing readable documentation strings.
* Comment Tips::	      Conventions for writing comments.
* Library Headers::           Standard headers for library packages.



File: elisp-ja.info, Node: Coding Conventions, Next: Compilation Tips, Prev: Tips, Up: Tips

Emacs Lispのコーディングの慣習
==============================

ここでは、読者が広く使われることを意図したEmacs Lispコードを書く場合に従
うべき慣習について述べます。

   * すべてのグローバル変数は同じ名前空間を共有し、すべての関数も別の名
     前空間を共有するため、読者のプログラムを別のLispプログラムと区別す
     るための短い単語を選ぶべきである。そして、すべてのグローバル変数、
     定数、関数の名前を選んでおいた接頭辞で始めるように注意する。

     Emacs Lispでは基本関数ではないがLispの伝統的な基本関数の名前にさえ
     もこの勧告は適用される。たとえ`copy-list'にさえもである。信じるかど
     うかは別にして、`copy-list'のもっともらしい定義方法は複数ある。安全
     であるためには、読者の接頭辞を付けて`foo-copy-list'や
     `mylib-copy-list'のような名前にする。

     読者が、`twiddle-files'のような特定の名前でEmacsに追加すべき関数を
     書いた場合には、読者のプログラムではその名前で呼ばないようにする。
     読者のプログラムでは`mylib-twiddle-files'としておき、Emacsに名前を
     追加するように提案するメイルを`bug-gnu-emacs@gnu.org'へ送る。われわ
     れがそのようにすることを決定したときには、名前をとても簡単に変更で
     きる。

     1つの接頭辞では不十分な場合には、意味がある限りは、2つか3つの共通す
     る別の接頭辞を読者のパッケージで使ってもよい。

     接頭辞とシンボル名の残りの部分とはハイフン`-'で分ける。これはEmacs
     自身やほとんどのEmacs Lispプログラムと一貫性がある。

   * プログラムに少なくとも複数の入り口がある場合には、各ライブラリプロ
     グラムに`provide'の呼び出しがあるとしばしば有用である。

   * 別のライブラリプログラムをあらかじめロードしておく必要があるファイ
     ルでは、ファイルの先頭のコマンドにそのように記述しておくこと。さら
     に、必要なものが確実にロードされておくように`require'を使う。

   * 別のファイルBARで定義されるマクロをファイルFOOで使っている場合には、
     FOOでそのマクロを始めて使うまえにFOOにつぎの式があること。

          (eval-when-compile (require 'BAR))

     （さらに、`require'が働くように、ライブラリBARには`(provide 'BAR)'
     があること。）この式により、FOOをバイトコンパイルするときにBARをロー
     ドすることになる。さもないと、必要なマクロをロードせずにFOOをコンパ
     イルする危険を侵し、正しく動作しないコンパイル済みコードを生成する
     ことになる。*Note Compiling Macros::。

     `eval-when-compile'を使うことで、FOOのコンパイル済みの版を*使う*と
     きにはBARをロードしない。

   * メジャーモードを定義するときには、メジャーモードの慣習に従うこと。
     *Note Major Mode Conventions::。

   * マイナモードを定義するときには、マイナモードの慣習に従うこと。*Note
     Minor Mode Conventions::。

   * 関数の目的が特定の条件を満たすかどうかを報告するのであれば、その関
     数には`p'で終る名前を付ける。名前が1単語である場合には`p'だけを付加
     する。複数の単語であれば`-p'を付加する。たとえば、`framep'や
     `frame-live-p'である。

   * 真偽の条件を記録するユーザーオプション変数には、`-flag'で終る名前を
     付ける。

   * 読者のメジャーモードでは、`C-c LETTER'をキーとして定義しないこと。
     これらのキー列はユーザー向けに予約済みである。それら*だけ*がユーザー
     向けに予約されたキー列であり、それらを禁止しないこと。

     かわりに、`C-c'のあとにコントロール文字か数字文字か特定の句読点文字
     が続くキー列を定義する。これらのキー列は、メジャーモード用に予約し
     てある。

     Emacsのすべてのモードをこの慣習に従うように変換するのはたいへんな作
     業量であった。この慣習を捨てさるとその作業をむだにしてしまい、ユー
     ザーにも不便である。

   * `C-c'のあとに`{'、`}'、`<'、`>'、`:'、`;'のいずれかが続くキー列もメ
     ジャーモード用に予約してある。

   * `C-c'のあとにこれら以外の句読点文字が続くキー列は、マイナモード用に
     割り当ててある。これらをメジャーモードで使うことは絶対禁止ではない
     が、これらを使うと、メジャーモードのバインディングがマイナモードで
     ときどき隠されてしまう。

   * 修飾キーを使わないファンクションキーF5からF9は、ユーザーが定義する
     ように予約してある。

   * （`C-c'を含む）任意のプレフィックス文字に続く`C-h'をバインドしない
     こと。`C-h'をバインドしなければ、これは自動的にプレフィックス文字の
     サブコマンド一覧を表示するヘルプ文字になる。

   * ESCに続くESC以外には、ESCで終るキー列をバインドしないこと。（つまり、
     `ESC ESC'で終るキー列をバインドするのはよい。）

     この規則の理由は、任意の文脈においてESCに対するプレフィックスでない
     バインディングがあることで、エスケープシーケンスをその文脈における
     ファンクションキーと認識することを防げる。

   * ユーザーが出入りできる一時的なモードや状態のように働くものでは、脱
     出手段として`ESC ESC'や`ESC ESC ESC'を定義する。

     Emacsの普通のコマンドを受け付ける状態、、あるいは、より一般的には
     ESCに続けてファンクションキーや矢印キーが意味を持つ可能性がある任意
     の状態では、ESCに続くエスケープシーケンスの認識を妨げる`ESC ESC'を
     定義するべきではない。そのような状態では、脱出手段として`ESC ESC
     ESC'を定義する。さもなければ脱出手段として`ESC ESC'を定義する。

   * アプリケーションでは、シフトキーを押し下げたボタン1関連のマウスイベ
     ントをバインドすべきではない。これらのイベントには、`S-mouse-1'、
     `M-S-mouse-1'、`C-S-mouse-1'などが含まれる。これらはユーザー向けに
     予約してある。

   * 読み出し専用のテキスト向けの特別なメジャーモードでは、普通、
     `mouse-2'とRETをテキスト内のある種の参照を辿るように再定義するべき
     である。dired、info、コンパイル（compilation）、出現（occur）などの
     モードはこのように再定義している。

   * Emacsの普通のふるまいを変更するようなパッケージでは、その機能をオン／
     オフするコマンドを含めるとよい。その機能をオン／オフする
     `WHATEVER-mode'という名前のコマンドを用意し、自動ロード（*Note
     Autoload::）するようにする。パッケージをロードしただけでは見ために
     は効果がない、つまり、その機能をオンにしないようにパッケージを設計
     すること。ユーザーはコマンドを起動してその機能をオンにする。

   * Emacsの基本関数の別名を定義することは悪い考えである。そのかわりに標
     準の名前を使う。

   * Emacsの基本関数を再定義（あるいはアドバイス）することは謹むべきであ
     る。特定のプログラムに対しては正しく動作するであろうが、他のプログ
     ラムがその結果どうなるかはわからない。

   * Emacsの標準の関数やライブラリプログラムを置き換えるようなファイルで
     は、そのファイルの先頭の目立つコメントにどの関数を置き換え元のふる
     まいとの相違点を記述すること。

   * 読者のEmacs Lispのソースファイルの名前は13文字以下にすること。こう
     すると、ファイルをコンパイルしても、コンパイル済みのファイル名は14
     文字以下になり、どんな種類のUNIXシステムにも収まるだけの短さである。

   * プログラムでは`next-line'や`previous-line'を使わないこと。ほとんど
     の場合、`forward-line'のほうがより便利であり、予測可能で堅牢でもあ
     る。*Note Text Lines::。

   * マークを設定することが読者のプログラムの意図した機能の一部でなけれ
     ば、マークを設定する関数は呼び出さないこと。マークはユーザーレベル
     の機能であり、ユーザーの便宜のために値を指定する以外には、マークを
     変更するのは正しくない。*Note The Mark::。

     特に、以下のいずれの関数も使わないこと。

        * `beginning-of-buffer', `end-of-buffer'
        * `replace-string', `replace-regexp'

     対話的なユーザー向けの他の機能を必要とせずに単にポイントを移動した
     り特定の文字列を置換するには、これらの関数は1行か2行の単純なLispコー
     ドで置き換えられる。

   * ベクトルを使う特別な理由がない限りは、ベクトルではなくリストを使う。
     Lispには、ベクトルに対するよりもリストを操作する機能のほうが多くあ
     り、リストを扱うほうが普通はより簡便である。

     （リストだけが許す）要素を挿入したり削除する必要がないのであれば、
     ある程度のサイズがあり（先頭から末尾に向けての探索ではなく）ランダ
     ムに参照する表にはベクトルのほうが適している。

   * エコー領域にメッセージを表示する推奨方法は、`princ'ではなく関数
     `message'を使うことである。*Note The Echo Area::。

   * エラー条件に出会ったときには、関数`error'（あるいは`signal'）を呼び
     出す。関数`error'は戻ってこない。*Note Signaling Errors::。

     エラーを報告するために、`message'、`throw'、`sleep-for'、`beep'は使
     わないこと。

   * エラーメッセージは大英文字で始め、ピリオドで終えないこと。

   * 実行に時間を要する多くのコマンドでは、開始時には`Operating...'のメッ
     セージを表示し、終了時にはそれを`Operating...done'と変える。これら
     のメッセージの形を同じにしておくこと。`...'の周りに空白は*なく*、末
     尾にピリオドも*ない*。

   * 再帰編集の使用は避けるように努めること。そのかわりにrmailのコマンド
     `e'のようにする。つまり、古いローカルキーマップに戻るためのコマンド
     を収めた新しいローカルキーマップを使う。あるいは、コマンド
     `edit-options'のようにする。別のバッファに切り替え、戻るのはユーザー
     に任せる。*Note Recursive Editing::。

   * 変数名を`*'で始めたり終える慣習があるシステムもある。Emacs Lispでは
     この慣習を使わないので、読者のプログラムでも使わないこと。（Emacsで
     は、特別な目的のバッファにのみそのような名前を使う。）すべてのライ
     ブラリで同じ慣習を使うと、ユーザーにはEmacsがより整合して見える。

   * 自由変数には`defvar'の定義を追加して、コンパイル時の未定義な自由変
     数に対する警告を避けるように努めること。

     ある関数で変数を束縛しその変数を別の関数で使ったり設定すると、その
     変数を定義しない限りコンパイラは後者の関数について警告を出す。しか
     し、しばしばこれらの変数は短い名前で、Lispパッケージでそのような変
     数名を定義すべきかどうか明らかでない。したがって、そのような変数の
     名前は、読者のパッケージの他の関数や変数に使っている接頭辞で始まる
     名前に改名すべきである。

   * デフォルトの字下げパラメータを使って、各関数を`C-M-q'
     （`indent-sexp'）で字下げすること。

   * 閉じ括弧だけの行にする癖をつけないこと。Lispプログラマはこれに当惑
     する。たまには、閉じ括弧が多数個連続するときにそれらを1つか2つの塊
     に分けることは意味がある。

   * コピーを配布する場合には、ファイルに著作権表示を入れること。つぎの
     ような文面を使う。

          ;; Copyright (C) YEAR NAME

          ;; This program is free software; you can redistribute it and/or
          ;; modify it under the terms of the GNU General Public License as
          ;; published by the Free Software Foundation; either version 2 of
          ;; the License, or (at your option) any later version.

          ;; This program is distributed in the hope that it will be
          ;; useful, but WITHOUT ANY WARRANTY; without even the implied
          ;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
          ;; PURPOSE.  See the GNU General Public License for more details.

          ;; You should have received a copy of the GNU General Public
          ;; License along with this program; if not, write to the Free
          ;; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
          ;; MA 02111-1307 USA

     読者がフリーソフトウェアファウンデーションに著作権を委譲する契約を
     結んでいるときには、NAMEとして`Free Software Foundation, Inc.'を使
     う。さもなければ読者自身の名前を使う。



File: elisp-ja.info, Node: Compilation Tips, Next: Documentation Tips, Prev: Coding Conventions, Up: Tips

コンパイル済みコードを速くするヒント
====================================

バイトコンパイルしたLispプログラムの実行速度を改良する方法を示します。

   * ライブラリ`profile'やライブラリ`elp'で、読者のプログラムを計測する。
     操作方法についてはファイル`profile.el'と`elp.el'を参照。

   * 可能な場合には再帰ではなく繰り返しを使う。コンパイル済みの関数が別
     のコンパイル済み関数を呼び出す場合であってもEmacs Lispでは関数呼び
     出しは遅い。

   * `memq'、`member'、`assq'、`assoc'のリスト探索基本関数を使うほうが明
     示的な繰り返しよりも速い。これらの探索基本関数の1つを使えるようにデー
     タ構造を変更する価値はある。

   * ある種の組み込み関数は、バイトコンパイル済みのコードでは普通の関数
     呼び出しを避けるように特別に扱われる。これらの関数を使うのはよいこ
     とである。コンパイラが関数を特別に扱うかどうかを調べるには、その属
     性`byte-compile'を調べる。属性が`nil'以外であれば、その関数は特別に
     扱われる。

     たとえば、つぎの入力は、`aref'が特別にコンパイルされることを示す
     （*Note Array Functions::）。

          (get 'aref 'byte-compile)
               => byte-compile-two-args

   * 読者のプログラムの実行時間のかなりの部分を小さな関数の呼び出しが占
     めるときには、その関数をインラインにする。これにより関数呼び出しの
     オーバヘッドを削除できる。関数をインラインにするとプログラム変更の
     柔軟性を減じるので、ユーザーが速度を気にするほど遅い部分の十分な速
     度向上が得られない限り、このようにしないこと。*Note Inline
     Functions::。



File: elisp-ja.info, Node: Documentation Tips, Next: Comment Tips, Prev: Compilation Tips, Up: Tips

説明文字列に関するヒント
========================

説明文字列を書くうえでのヒントや慣習を述べます。コマンド`M-x
checkdoc-minor-mode'を実行して、これらの慣習の多くを確認できます。

   * ユーザーが知っておくことを意図した各コマンド、関数、変数には、説明
     文字列を付けること。

   * Lispプログラムの内部変数やサブルーティンにも説明文字列を付ける。
     Emacsの初期の版では、説明文字列のかわりにコメントを使うと容量を節約
     できたが、今はこれはあてはまらない。

   * 説明文字列の最初の行は、1つか2つの完全な文であり、それだけで概要を
     表していること。`M-x apropos'は説明文字列の最初の行だけを表示するた
     め、それだけで十分に表せないと表示結果が悪くなる。特に、最初の行は
     大文字で始め、ピリオドで終えること。

     説明文字列には、関数や変数の使い方の詳細を述べる追加の行があってよ
     い。それらの行も完全な文から成るべきであるが、見ためをよくするため
     に適当に詰めてよい。

   * 一貫性があるように、関数の説明文字列の最初の文の動詞は『to』を省い
     た不定詞にする。たとえば、『Returns the cons of A and B.』ではなく
     『Return the cons of A and B.』とする。最初の行の残りの文についても
     同様にするとよい。以降の文節では適切な主語があるほうが一般にはよい。

   * 説明文字列は受動態ではなく能動態で書き、未来形ではなく現在形で書く。
     たとえば、『A list containing A and B will be returned.』ではなく
     『Return a list containing A and B.』と書く。

   * 不必要に単語『cause』（および同義語）を使わないこと。『Cause Emacs
     to display text in boldface,』ではなく単に『Display text in
     boldface.』と書く。

   * 説明文字列は、白文字で始めたり終えないこと。

   * 80コラムのスクリーン上のEmacsのウィンドウに収まるように説明文字列を
     整形する。ほとんどの行を60文字を越えないようにするとよい。必要な情
     報を入れるためならば最初の行が長くなってもよい。

     しかし、説明文字列全体を単純に整形するよりは、注意深く行分けすると
     読みやすくなる。説明文字列が長い場合には、話題ごとに空行で区切る。
 
   * ソースコード上で説明文字列の最初の行に揃えるために説明文字列の残り
     の行を字下げ*しないこと*。ソースコード上では見ためがよくても、ユー
     ザーが説明文字を見るときには奇妙に見える。文字列を始めるダブルクォー
     トのまえにある字下げは文字列の一部ではないことに注意！

   * ユーザーが禁止コマンドを実行しようとすると、Emacsは当該コマンドの説
     明文字列の最初の文節、つまり、最初の空行までを表示する。必要ならば、
     最初の空行のまえに入れるべき情報を選んで、このような表示が有用であ
     るようにする。

   * ユーザーが対話的に設定したがるような変数では、その変数の説明文字列
     は`*'で始める。変数の値が、長いリストや関数であるとき、あるいは、初
     期化ファイルでのみ設定するような変数であるときには、その説明文字列
     を`*'で始めないこと。*Note Defining Variables::。

   * yes/noのフラグを表す変数の説明文字列は『Non-nil means...』のような
     単語で始めて、`nil'以外の値はすべて同値であることを明らかにし、
     `nil'と`nil'以外の意味を明確に示すこと。

   * 関数の説明文字列でその引数について述べるときには、その引数の値を表
     す名前には大文字で書いた引数名を使う。したがって、関数`/'の説明文字
     列では、その第2引数の名前は`divisor'なので、`DIVISOR'と表す。

     また、リストやベクトルを（その一部が変化するかもしれない）構成部分
     に分解したものを示すときなどのメタ変数には、すべて大文字を使う。

   * 説明文字列でLispシンボルを参照するときには、それが表示されるとき
     （つまり普通はすべて小文字）のようにシングルクォートで囲って書く。
     たとえば、`lambda'である。これには2つ例外があり、tとnilはシングル
     クォートで囲まずに書く。（本書では、すべてのシンボルをシングルクォー
     トで囲む別の慣習を用いている。）

     ヘルプモードでは、説明文字列でシングルクォートで囲ったシンボルを使
     うと、そのシンボルに関数定義や変数定義があるときには自動的にハイパー
     リンクを作成する。この機能を利用するために特別なことをする必要はな
     い。しかし、シンボルに関数定義と変数定義の両方があり、どちらか一方
     のみを参照したい場合には、シンボルの名前のまえに`variable'、
     `option'、`function'、`command'のいずれかの単語を書くだけでどちらで
     あるかを指定できる。（これらの単語を認識するときには大文字小文字は
     区別しない。）たとえばつぎのように書くと、

          This function sets the variable `buffer-file-name'.

     ハイパーリンクは、変数`buffer-file-name'の説明文字列を指し、その関
     数の説明文字列は指さない。

     シンボルに関数定義や変数定義があっても、説明文字列でのシンボルの使
     い方には無関係な場合には、シンボルの名前のまえに単語`symbol'を書け
     ば、ハイパーリンクを作らないようにできる。たとえば、つぎのようにす
     ると、

          If the argument KIND-OF-RESULT is the symbol `list',
          this function returns a list of all the objects
          that satisfy the criterion.

     ここでは`list'の関数／変数定義は無関係なので、関数`list'の説明文字
     列を指すハイパーリンクは作られない。

   * 説明文字列に直接キー列を書き込まないこと。そのかわりに、それの標準
     的なキー列を作成する`\\[...]'の書き方を使う。たとえば、`C-f'と書く
     かわりに、`\\[forward-char]'と書く。Emacsが説明文字列を表示するとき
     に、`forward-char'に現在バインドされているキーにEmacsが置き換える。
     （普通は`C-f'であるが、ユーザーがキーバインディングを変更していれば、
     別の文字になる。）*Note Keys in Documentation::。

   * メジャーモードの説明文字列では、グローバルなキーマップではなくその
     モードのローカルなキーマップでのキーバインディングを参照したいだろ
     う。それには、使用するキーマップを指定する構文`\\<...>'を説明文字列
     の中に書く。最初に`\\[...]'を使うまえにこうしておくこと。`\\<...>'
     の内側のテキストは、メジャーモード向けのローカルキーマップを保持す
     る変数の名前であること。

     説明文字列の表示を遅くしてしまうので、`\\[...]'を何回も使うのは実用
     的ではない。したがって、読者のメジャーモードのもっとも重要なコマン
     ドの記述にこれを使い、モードのキーマップの残りを表示するには
     `\\{...}'を使う。



