Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Docs and Compilation, Next: Dynamic Loading, Prev: Compilation Functions, Up: Byte Compilation

説明文字列とコンパイル
======================

バイトコンパイルしたファイルからロードした関数や変数では、それらの説明文
字列は、必要に応じてそのファイルを動的に参照します。これはEmacs内のメモ
リを節約しロード処理も速くなります。というのは、ファイルのロード処理で説
明文字列を処理する必要がないからです。説明文字列を実際に参照するのは遅く
なりますが、普通、ユーザーをいらいらさせるほとではありません。

説明文字列を動的に参照することには欠点があります。

   * コンパイルしたファイルをロード後に削除したり移動したりすると、その
     ファイル内の関数や変数に対する説明文字列をEmacsから参照できなくなる。

   * コンパイルしたファイルを（新版をコンパイルするなどして）変更すると、
     それ以降にそのファイルから説明文字列を参照すると、無意味な結果にな
     る。

読者のサイトでEmacsを通常の手順でインストールした場合には、これらの問題
は普通起こらないはずです。新版のインストールには別のディレクトリを使いま
すから、旧版をインストールしてある限り、そのファイル群は意図した場所に無
変更で残っているはずです。

しかしながら、読者自身がEmacsを構築して、構築したディレクトリからEmacsを
使う場合、Lispファイルを編集して再コンパイルすると、しばしばこの問題を経
験するでしょう。そのような場合には、再コンパイルしたあとでファイルを再ロー
ドすれば問題を解決できます。

旧版ではこの機能を使えないので、Emacsの（19.29以降の）最近の版でバイトコ
ンパイルしたファイルは旧版ではロードできません。
`byte-compile-dynamic-docstrings'に`nil'を設定すれば、コンパイル時にこの
機能をオフにできます。Emacsの旧版にロードできるようにファイルをコンパイ
ルできるのです。すべてのファイルをこのようにコンパイルしたり、あるいは、
この変数をファイルにローカルな束縛に指定して1つのソースファイルだけをこ
のようにコンパイルしたりもできます。そのようにする1つの方法は、つぎの文
字列をファイルの先頭行に追加することです。

     -*-byte-compile-dynamic-docstrings: nil;-*-

 -- Variable: byte-compile-dynamic-docstrings
     これが`nil'以外であると、バイトコンパイラは、説明文字列を動的にロー
     ドするように設定したコンパイル済みファイルを生成する。

説明文字列を動的に扱う場合、コンパイル済みのファイルではLispリーダの特別
な構文`#@COUNT'を使います。この構文は後続のCOUNT文字を読み飛ばします。ま
た、`#$'という構文も使います。これは、『文字列としてのこのファイルの名前』
を表します。Lispのソースファイルでは、これらの構文を使わないのが最良です。
これらは人が読むファイル向けに設計したものではないからです。



File: elisp-ja.info, Node: Dynamic Loading, Next: Eval During Compile, Prev: Docs and Compilation, Up: Byte Compilation

個別関数の動的ロード
====================

ファイルをコンパイルするとき、"動的関数ロード"（dynamic function loading、
"遅延ロード"（lazy loading）ともいう）機能を指定できます。動的関数ロード
では、ロードするときにファイル内の関数定義をすべて読むわけではありません。
そのかわりに、各関数定義には、そのファイルを指す埋め草が入っています。そ
れぞれの関数を初めて呼び出したときに、その完全な定義をファイルから読み取
り、埋め草を置き換えます。

動的関数ロードの利点は、ファイルをロードするよりかなり速いことです。ユー
ザーが呼び出せる数多くの別々の関数を収めたファイルにおいては、それらの1
つだけを使って残りのものを使わないのであれば、これは有利なことです。キー
ボードコマンドを提供する特別なモードには、しばしばこのような使い方のパター
ンがあります。ユーザーがモードを起動しても、提供するコマンドの一部しか使
わないのです。

動的関数ロードの機能には、ある種の欠点もあります。

   * コンパイルしたファイルをロードしたあとにそのファイルを削除したり移
     動したりすると、未ロードの残りの関数定義をEmacsはロードできない。

   * コンパイルしたファイルを（新版をコンパイルするなどして）変更すると、
     未ロードの関数をロードすると、無意味な結果になる。

Emacsのファイル群をインストールした普通の状況では、このような問題は起き
ないはずです。しかし、Lispファイルを読者が変更すると起こりえます。これら
の問題を回避するもっとも簡単な方法は、再コンパイルするたびに新たにコンパ
イルしたファイルをただちに再ロードすることです。

バイトコンパイラは、コンパイル時に変数`byte-compile-dynamic'が`nil'以外
であれば、動的関数ロードの機能を使います。動的ロードは特定のファイルで必
要なだけですから、この変数をグローバルに設定しないでください。そのかわり
にファイルにローカルな変数束縛を使って特定のソースファイルだけでこの機能
をオンにします。たとえば、ソースファイルの先頭行につぎのテキストを書けば、
そのようにできます。

     -*-byte-compile-dynamic: t;-*-

 -- Variable: byte-compile-dynamic
     これが`nil'以外であると、バイトコンパイラは、動的関数ロードを使うよ
     うに設定したコンパイル済みのファイルを生成する。

 -- Function: fetch-bytecode FUNCTION
     FUNCTIONを完全にロードしていないと、バイトコンパイルしたファイルか
     らただちにFUNCTIONの定義をロードする。引数FUNCTIONは、バイトコード
     関数オブジェクトか関数名である。



File: elisp-ja.info, Node: Eval During Compile, Next: Byte-Code Objects, Prev: Dynamic Loading, Up: Byte Compilation

コンパイル時の評価
==================

プログラムのコンパイル時に評価されるようなコードを書くための機能です。

 -- Special form: eval-and-compile BODY
     このフォームは、コンパイルしたり実行したり（コンパイルしてあっても
     してなくても）するときにBODYを評価するように印を付ける。

     BODYを別のファイルに収め、そのファイルを`require'で参照しても同じ結
     果を得ることができる。BODYが大きい場合には、そのほうが好ましい。

 -- Special form: eval-when-compile BODY
     このフォームは、コンパイルしたプログラムをロードするときではなく、
     プログラムのコンパイル時にBODYを評価するように印を付ける。コンパイ
     ラが評価した結果は、コンパイルしたプログラム内に定数として現れる。
     ソースファイルをコンパイルせずにロードすると、BODYを普通どおり評価
     する。

     *Common Lispに関した注意：*` ' トップレベルでは、Common Lispの
     `(eval-when (compile eval) ...)'の常套句に似ている。それ以外の箇所
     では、Common Lispの`#.'リーダマクロは（解釈実行時ではなければ）
     `eval-when-compile'が行うことに近い。



File: elisp-ja.info, Node: Byte-Code Objects, Next: Disassembly, Prev: Eval During Compile, Up: Byte Compilation

バイトコード関数オブジェクト
============================

バイトコンパイルした関数は、特別なデータ型、"バイトコード関数オブジェク
ト"（byte-code function objects）です。

内部的には、バイトコード関数オブジェクトはベクトルによく似ています。しか
し、評価時にこのデータ型が呼び出すべき関数として現れると、特別に扱います。
バイトコード関数オブジェクトの表示表現はベクトルに似ていますが、開き角括
弧`['のまえに余分に`#'が付きます。

バイトコード関数オブジェクトには、少なくとも4つの要素が必要です。最大個
数に制限はありませんが、最初の6つ個の要素にだけ普通の用途があります。つ
ぎのとおりです。

引数リスト
     引数シンボルのリスト。

バイトコード
     バイトコード命令を収めた文字列。

定数群
     バイトコードが参照するLispオブジェクトのベクトル。関数名や変数名と
     して使われるシンボルを含む。

スタックサイズ
     この関数に必要なスタックサイズの最大値。

説明文字列
     （あれば）説明文字列。さもなければ`nil'。説明文字列がファイルに収め
     てあれば、値は数かリストである。実際の説明文字列を取得するには関数
     `documentation'を使う（*Note Accessing Documentation::）。

対話指定
     （あれば）対話指定。これは文字列かLisp式。対話的でない関数では`nil'。

バイトコード関数オブジェクトの例を表示表現でつぎに示します。

     #[(&optional arg)
       "^H\204^F^@\301^P\302^H[!\207"
       [arg 1 forward-sexp]
       2
       254435
       "p"]

バイトコードオブジェクトを作る基本的な方法は、`make-byte-code'を使うこと
です。

 -- Function: make-byte-code &rest ELEMENTS
     この関数は、ELEMENTSを要素とするバイトコード関数オブジェクトを作成
     し返す。

バイトコード関数の要素を自分で作ったりしないでください。それらに整合性が
ないと、その関数を呼び出すとEmacsがクラッシュすることもあります。これら
のオブジェクトの作成は、バイトコンパイラに任せるべきです。バイトコンパイ
ラは整合した要素を作成します（と期待する）。

バイトコードオブジェクトの要素は`aref'で参照できます。同じ要素群のベクト
ルを`vconcat'で作ることもできます。



File: elisp-ja.info, Node: Disassembly, Next: Simple Advice, Prev: Byte-Code Objects, Up: Byte Compilation

バイトコードの逆アセンブル
==========================

人間はバイトコードを書きません。それはバイトコンパイラの仕事です。しかし、
好奇心を満たすために逆アセンブラを用意してあります。逆アセンブラはバイト
コンパイルしたコードを人が読める形式に変換します。

バイトコードインタープリタは、単純なスタックマシンとして実装してあります。
値を自前のスタックに積み、計算に使うためにスタックから取り出し、計算結果
そのものはスタックにまた積みます。バイトコード関数から戻るときには、スタッ
クから値を取り出して関数値としてその値を返します。

スタックに加えて、変数とスタックのあいだで値を転送することで、バイトコー
ド関数は、普通のLisp変数を使ったり、束縛したり、値を設定できます。

 -- コマンド: disassemble OBJECT &optional STREAM
     この関数はOBJECTの逆アセンブルしたコードを出力する。STREAMを指定す
     ると、そこへ出力する。さもなければ、逆アセンブルしたコードはストリー
     ム`standard-output'へ出力する。引数OBJECTは関数名かラムダ式である。

     特別な例外として、この関数を対話的に使うと、`*Disassemble*'という名
     前のバッファへ出力する。

`disassemble'関数の使用例を2つ示します。バイトコードとLispソースとの対応
を取れるように特別なコメントを追加してありますが、これらは`disassemble'
の出力には現れません。これらの例は、最適化してないバイトコードです。現在、
バイトコードは、普通、最適化しますが、目的は果たせるので、例を書き換えて
ありません。

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          => factorial

     (factorial 4)
          => 24

     (disassemble 'factorial)
          -| byte-code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)

     0   constant 1              ; スタックに1を積む

     1   varref   integer        ; 環境から`integer'の値を取得し、 
                                 ; スタックに積む

     2   eqlsign                 ; スタックの先頭から2つの値を
                                 ; 取りさって比較し、
                                 ; 結果をスタックに積む

     3   goto-if-nil 10          ; スタックの先頭から値を取りさり
                                 ; 検査する。`nil'ならば10へ飛び、
                                 ; さもなければつぎへ進む

     6   constant 1              ; スタックに1を積む

     7   goto     17             ; 17へ飛ぶ（この場合、関数は1を返す）

     10  constant *              ; スタックにシンボル`*'を積む

     11  varref   integer        ; スタックに`integer'の値を積む

     12  constant factorial      ; スタックに`factorial'を積む

     13  varref   integer        ; スタックに`integer'の値を積む

     14  sub1                    ; スタックから`integer'を取りさり、
                                 ; 減した新たな値をスタックに積む

                                 ; スタックの現在の内容はつぎのとおり
                                 ; - `integer'を減らした値
                                 ; - `factorial' 
                                 ; - `integer'の値
                                 ; - `*'

     15  call     1              ; スタックの最初（先頭）要素を使って
                                 ; 関数`factorial'を呼び出す
                                 ; 戻り値をスタックに積む

                                 ; スタックの現在の内容はつぎのとおり
                                 ; - `factorial'の
                                 ;      再帰呼び出しの結果
                                 ; - `integer'の値
                                 ; - `*'

     16  call     2              ; スタックの最初の要素の2つ
                                 ; （先頭の2つ）を引数として
                                 ; 関数`*'を呼び出し
                                 ; 結果をスタックに積む

     17  return                  ; スタックの先頭要素を返す
          => nil

関数`silly-loop'は、少々複雑です。

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n)) 
                   0))
         (list t1 (current-time-string))))
          => silly-loop

     (disassemble 'silly-loop)
          -| byte-code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)

     0   constant current-time-string  ; `current-time-string'を
                                       ; スタックの先頭に積む

     1   call     0              ; 引数なしで`current-time-string'を
                                 ; 呼び出し、結果をスタックに積む

     2   varbind  t1             ; スタックから値を取りさり、
                                 ; `t1'に束縛する

     3   varref   n              ; 環境から`n'の値を取得し、
                                 ; 値をスタックに積む

     4   sub1                    ; スタックの先頭から1を引く

     5   dup                     ; スタックの先頭の値を複製する
                                 ; つまり、スタックの先頭の値を
                                 ; コピーして、それをスタックに積む

     6   varset   n              ; スタックの先頭から値を取りさり、
                                 ; 値を`n'に束縛する

                                 ; つまり、`dup varset'は
                                 ; スタックの先頭の値を取りさらずに
                                 ; `n'にコピーする

     7   constant 0              ; スタックに0を積む

     8   gtr                     ; スタックから2つの値を取りさり、
                                 ; Nが0より大きいか調べ、
                                 ; 結果をスタックに積む

     9   goto-if-nil-else-pop 17 ; `n' <= 0ならば17へ飛ぶ
                                 ; （whileループから抜ける）
                                 ; さもなければ、スタックの先頭から
                                 ; 値を取りさり、つぎへ進む

     12  constant nil            ; スタックに`nil'を積む
                                 ; （これはループの本体）

     13  discard                 ; ループの本体の結果を捨てる
                                 ; （whileループは副作用のために}
                                 ; つねに評価される

     14  goto     3              ; whileループの先頭へ飛ぶ

     17  discard                 ; スタックの先頭の値を取りさって、
                                 ; whileループの結果を捨てる。
                                 ; これは、9での飛び越しのために
                                 ; 取りさっていない値`nil'

     18  varref   t1             ; `t1'の値をスタックに積む

     19  constant current-time-string  ; `current-time-string'を 
                                       ; スタックに積む

     20  call     0              ; ふたたび`current-time-string'を
                                 ; 呼び出す

     21  list2                   ; スタックの先頭から2つの値を取りさり
                                 ; それらのリストを作り、
                                 ; リストをスタックに積む

     22  unbind   1              ; ローカルの環境の`t1'の束縛を解く

     23  return                  ; スタックの先頭の値を返す

          => nil




File: elisp-ja.info, Node: Advising Functions, Next: Debugging, Prev: Byte Compilation, Up: Top

Emacs Lisp関数のアドバイス
**************************

"アドバイス"（advice）機能により、関数の既存の定義に追加できます。これは、
Emacsの他の部分で定義された関数をライブラリにおいてカスタマイズする見通
しのよい方法です。関数全体を再定義するよりも見通しがよいのです。

各関数は、個別に定義した複数の"アドバイス断片"を持てます。それぞれのアド
バイス断片は、明示的に有効にしたり無効にできます。任意の関数の有効にした
アドバイス断片が実際にその効果を発揮するのは、当該関数のアドバイスを"活
性にした"ときか当該関数をのちに定義したり再定義したときです。

*使用上の注意：*` ' アドバイスは、既存関数の既存の呼び出しのふるまいを変
更するのに有用である。新たな呼び出しやキーバインドの新たなふるまいが必要
な場合には、既存関数を使う新たな関数（や新たなコマンド）を定義するほうが
見通しがよい。

* Menu:

* Simple Advice::           A simple example to explain the basics of advice.
* Defining Advice::         Detailed description of `defadvice'.
* Around-Advice::           Wrapping advice around a function's definition.
* Computed Advice::         ...is to `defadvice' as `fset' is to `defun'.
* Activation of Advice::    Advice doesn't do anything until you activate it.
* Enabling Advice::         You can enable or disable each piece of advice.
* Preactivation::           Preactivation is a way of speeding up the
                              loading of compiled advice.
* Argument Access in Advice:: How advice can access the function's arguments.
* Subr Arguments::          Accessing arguments when advising a primitive.
* Combined Definition::     How advice is implemented.



File: elisp-ja.info, Node: Simple Advice, Next: Defining Advice, Prev: Disassembly, Up: Advising Functions

単純なアドバイスの例
====================

コマンド`next-line'は、ポイントを垂直に複数行移動します。標準バインドは
`C-n'です。バッファの最終行で使うと、（`next-line-add-newlines'が`nil'以
外の場合）このコマンドは行を作るために改行を挿入し、その行に移動します。

同様な機能を`previous-line'に追加したいとします。つまり、バッファの先頭
に新たな行を挿入し、その行へ移動するのです。どのようにすればよいでしょう？

当該関数を再定義すればできますが、それではモジュール性がよくありません。
アドバイス機能が見通しのよい代替方法を提供します。既存の関数定義を実際に
変更したりその定義を参照することなく、関数定義に読者のコードを実質的に追
加できます。つぎのように行います。

     (defadvice previous-line (before next-line-at-end (arg))
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

この式は、関数`previous-line'に対する"アドバイス断片"を定義します。この
アドバイス断片には`next-line-at-end'という名前が付きます。シンボル
`before'により、`previous-line'の通常の定義を実行するまえに実行する"事前
アドバイス"（before-advice）であることを意味します。`(arg)'は、アドバイ
ス断片がどのように関数の引数を参照するかを指定します。

このアドバイス断片が実行されると、必要な場面では新たに行を作りますが、そ
の行へはポイントを移動しません。これはアドバイスを書く正しいやりかたです。
というのは、通常の定義がこのあとに実行され、新たに挿入した行へ移動します。

アドバイスを定義しても関数`previous-line'をただちには変更しません。つぎ
のようにアドバイスを"活性にする"と変わります。

     (ad-activate 'previous-line)

これにより、関数`previous-line'に対して定義してあるアドバイスを使い始め
ます。これ以降、`C-p'や`M-x'でユーザーが起動したのかLispから呼ばれたのか
に関わらず、この関数を起動すると、まずアドバイスを実行してから関数の通常
の定義を実行します。

この例は、アドバイスの1つの"クラス"である事前アドバイスの例であり、関数
の元定義のまえに実行されます。他に2つのアドバイスクラスがあります。元定
義のあとに実行される"事後アドバイス"（after-advice）と元定義の起動を包み
込む式を指定する"包囲アドバイス"（around-advice）です。



File: elisp-ja.info, Node: Defining Advice, Next: Around-Advice, Prev: Simple Advice, Up: Advising Functions

アドバイス定義
==============

アドバイス断片を定義するには、マクロ`defadvice'を使います。`defadvice'の
呼び出しはつぎのような構文です。`defun'や`defmacro'の構文を基にしていま
すが、追加部分があります。

     (defadvice FUNCTION (CLASS NAME
                              [POSITION] [ARGLIST]
                              FLAGS...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-FORM]
       BODY-FORMS...)

ここで、FUNCTIONはアドバイス対象となる関数（やマクロやスペシャルフォーム）
です。以後、アドバイスする対象を単に『関数』と書きますが、これにはつねに
マクロやスペシャルフォームを含みます。

CLASSはアドバイスの"クラス"を指定し、`before'、`after'、`around'のいずれ
かです。事前アドバイス（`before'）は関数そのもののまえに実行されます。事
後アドバイス（`after'）は関数そのもののあとに実行されます。包囲アドバイ
ス（`around'）は関数自身の実行を包み込みます。事後アドバイスと包囲アドバ
イスでは、`ad-return-value'に設定することで戻り値を変更できます。

 -- Variable: ad-return-value
     アドバイスを実行しているとき、関数の元定義の実行を完了したあとでは、
     この変数はその戻り値を保持する。すべてのアドバイスを完了すると、最
     終的には、この値を呼び出し側へ返す。事後アドバイスと包囲アドバイス
     では、この変数に別の値を設定することで戻り値を変更できる。

引数NAMEはアドバイスの名前であり、`nil'以外のシンボルです。アドバイス名
は、FUNCTIONの特定クラスのすべてのアドバイス断片から1つのアドバイス断片
を一意に識別します。名前でアドバイス断片を参照でき、それを再定義したり有
効にしたり無効にできます。

通常の関数定義の引数リストのかわりに、アドバイス定義では異なる情報を必要
とします。

省略可能なPOSITIONは、指定したCLASSの現在のアドバイスリストのどこに新た
なアドバイスを置くかを指定します。`first'、`last'、あるいは、0から数え始
める位置を指定する数である必要があります（`first'は0と等価）。位置を指定
しないとデフォルトは`first'です。当該クラスの既存位置の範囲を超えている
場合には、先頭か末尾のどちらか近いほうになります。既存のアドバイス断片を
再定義する場合には、値POSITIONは無視されます。

省略可能なARGLISTは、アドバイスが使う引数リストを定義するために使います。
これは、アドバイスを実行するために生成される結合定義（*Note Combined
Definition::）の引数リストになります。その結果、アドバイスの式では、引数
の値を参照するためにこのリストの引数変数を使えます。

この引数リストは、関数の実際の呼び出し方を扱えるように、もとの関数の引数
リストと互換性がある必要があります。2つ以上のアドバイス断片で引数リスト
を指定している場合、すべてのアドバイスクラスの中で最初のもの（位置が最小
のもの）を使います。

残りの要素FLAGSは、このアドバイス断片の使い方に関する情報を指定するシン
ボルです。正しいシンボルとそれらの意味はつぎのとおりです。

`activate'
     FUNCTIONに対するアドバイスをただちに活性にする。関数のアドバイスに
     対する変更は、当該関数のアドバイスを活性にすると効果を持つようにな
     る。このフラグは、FUNCTIONに対するこのアドバイス断片を定義した直後
     にそのようにすることを指示する。

     FUNCTIONが未定義（"未定義のアドバイス"（forward advice）と呼ぶ状況）
     であるとこのフラグにはなんの効果もない。というのは、未定義関数のア
     ドバイスは活性にできないからである。しかし、FUNCTIONを定義するとそ
     のアドバイスは自動的に活性にされる。

`protect'
     このアドバイス断片をそれよりまえに実行されるコードやアドバイスによ
     る非ローカル脱出やエラーに対して保護する。保護したアドバイス断片は、
     フォーム`unwind-protect'の中に後始末として置かれ、それよりまえに実
     行されるコードでエラーが発生したり`throw'を使っても実行される。
     *Note Cleanups::。

`compile'
     アドバイスの実行に使われる結合定義をコンパイルする。`activate'とと
     もに指定しないと、このフラグは無視する。*Note Combined Definition::。

`disable'
     このアドバイス断片を当初は無効にしておき、のちに明示的に有効にしな
     い限り使われない。*Note Enabling Advice::。

`preactivate'
     この`defadvice'をコンパイルしたりマクロ展開したときに、FUNCTIONに対
     するアドバイスを活性にする。これにより現在のアドバイスの状態に応じ
     たアドバイス定義をコンパイルし、必要に応じて使われるようになる。

     この`defadvice'をバイトコンパイルする場合にのみ意味を持つ。

省略可能なDOCUMENTATION-STRINGは、このアドバイス断片の説明文字列になりま
す。FUNCTIONに対するアドバイスが活性であると、（`documentation'が返す）
FUNCTIONの説明文は、関数の元定義の説明文字列とFUNCTIONのアドバイスすべて
の説明文字列の合成になります。

省略可能なINTERACTIVE-FORMは、元関数の対話的ふるまいを変更するために指定
します。2つ以上のアドバイス断片でINTERACTIVE-FORMを指定している場合、す
べてのアドバイスの中で最初のもの（位置が最小のもの）が優先します。

空リストでもかまわないBODY-FORMSは、アドバイスの本体です。アドバイスの本
体では、引数、戻り値、束縛環境を参照／変更したり、いかなる種類の副作用を
起こせます。

*警告：*` ' マクロをアドバイスする場合、マクロはプログラムのコンパイル時
に展開されるのであって、コンパイルしたプログラムの実行時に展開されるので
はないことに注意。アドバイスが使用するすべてのサブルーティンは、バイトコ
ンパイラがマクロを展開するときに必要になる。



File: elisp-ja.info, Node: Around-Advice, Next: Computed Advice, Prev: Defining Advice, Up: Advising Functions

包囲アドバイス
==============

包囲アドバイスにより、関数の元定義を包み込むLisp式を書けます。関数の元定
義を実行する場所を特別なシンボル`ad-do-it'で指定します。包囲アドバイスの
本体に現れたこのシンボルは、元定義（と内側の包囲アドバイス本体）のフォー
ムを含んだ`progn'で置き換えられます。例を示しましょう。

     (defadvice foo (around foo-around)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         ad-do-it))

これは、`foo'の元定義を実行するときに大文字小文字を区別しないで探索する
ことを保証します。

 -- Variable: ad-do-it
     これは実際には変数ではないが、包囲アドバイス内では変数のように用い
     る。関数の元定義と『より内側の』包囲アドバイスを実行する場所を指定
     する。

包囲アドバイスで`ad-do-it'を用いなければ、関数の元定義を実行しません。こ
れは、元定義を完全に無効にする手段です。（さらに、内側の包囲アドバイス断
片も無効にする。）



File: elisp-ja.info, Node: Computed Advice, Next: Activation of Advice, Prev: Around-Advice, Up: Advising Functions

計算アドバイス
==============

マクロ`defadvice'は`defun'に似ていて、アドバイスのコードやアドバイスに関
する他のすべての情報をソースコードで明示します。関数`ad-add-advice'を用
いると、その詳細を計算で求めたアドバイスを作成できます。

 -- Function: ad-add-advice FUNCTION ADVICE CLASS POSITION
     `ad-add-advice'を呼び出すと、関数FUNCTIONに対するクラスCLASSのアド
     バイス断片としてADVICEを追加する。引数ADVICEはつぎの形式である。

          (NAME PROTECTED ENABLED DEFINITION)

     ここで、PROTECTEDとENABLEDはフラグであり、DEFINITIONはアドバイスの
     動作を指定する式である。ENABLEDが`nil'であると、このアドバイス断片
     は当初は無効になる（*Note Enabling Advice::）。

     FUNCTIONに指定したクラスCLASSのアドバイス断片がすでにあると、
     POSITIONは新しいアドバイス断片をリストのどこに置くかを指定する。
     POSITIONの値は、`first'、`last'、あるいは、（リストの先頭を0から数
     えた）数である。範囲外の数は先頭か末尾のどちらか近いほうになる。

     FUNCTIONに同じ名前のアドバイス断片ADVICEがすでにあると、引数
     POSITIONは無視され、古いアドバイス断片を新しいもので置き換える。



File: elisp-ja.info, Node: Activation of Advice, Next: Enabling Advice, Prev: Computed Advice, Up: Advising Functions

アドバイスの活性化
==================

デフォルトでは、アドバイスを定義してもその効果は発揮されません。アドバイ
スした関数のアドバイスを"活性"にして始めて効果を発揮します。`defadvice'
でフラグ`activate'を指定すれば、関数にアドバイスを定義したときに活性にで
きます。しかし、普通は、関数`ad-activate'や以下の活性化コマンドを呼び出
すことで、関数のアドバイスを活性にします。

アドバイスの定義操作と活性化操作を区別することで、アドバイスを追加するた
びに関数を再定義することなる、関数に複数のアドバイス断片を効率よく追加で
きます。さらに重要なことは、関数を実際に定義するまえでも関数にアドバイス
を定義できることです。

関数のアドバイスを初めて活性にすると、関数の元定義を保存してから、関数に
対する有効なアドバイス断片すべてを元定義と結合して新たな定義を作り出しま
す。（現在無効にしてあるアドバイス断片は使用しない。*Note Enabling
Advice::。）この定義をインストールし、以下に述べる条件に応じてバイトコン
パイルする場合もあります。

アドバイスを活性にするコマンドすべてにおいて、COMPILEが`t'であると、アド
バイスを実装する結合定義をコンパイルします。

 -- コマンド: ad-activate FUNCTION &optional COMPILE
     このコマンドはFUNCTIONに対するアドバイスを活性にする。

関数のアドバイスがすでに活性になっているアドバイスを活性にしても意味があ
ります。当該関数のアドバイスを活性にしたあとでアドバイスを変更した場合、
その変更が効果を持つようにする操作になります。

 -- コマンド: ad-deactivate FUNCTION
     このコマンドはFUNCTIONのアドバイスを不活性にする。

 -- コマンド: ad-activate-all &optional COMPILE
     このコマンドはすべての関数に対するアドバイスを活性にする。

 -- コマンド: ad-deactivate-all
     このコマンドはすべての関数に対するアドバイスを不活性にする。

 -- コマンド: ad-activate-regexp REGEXP &optional COMPILE
     このコマンドはREGEXPに一致する名前のすべてのアドバイス断片を活性に
     する。より正確には、REGEXPに一致する名前のアドバイス断片を持つ任意
     の関数のすべてのアドバイスを活性にする。

 -- コマンド: ad-deactivate-regexp REGEXP
     このコマンドはREGEXPに一致する名前のすべてのアドバイス断片を不活性
     にする。より正確には、REGEXPに一致する名前のアドバイス断片を持つ任
     意の関数のすべてのアドバイスを不活性にする。

 -- コマンド: ad-update-regexp REGEXP &optional COMPILE
     このコマンドはREGEXPに一致する名前のアドバイス断片を活性にするが、
     すでにアドバイスが活性になっている関数に対するものだけである。

     関数に対するアドバイスの再活性化は、アドバイスを活性にしたあとに行っ
     た当該アドバイスの変更すべて（有効にしたり無効にしたアドバイス断片
     を含む。*Note Enabling Advice::）が効果を持つようにするのに便利であ
     る。

 -- コマンド: ad-start-advice
     関数を定義したり再定義したときにアドバイスを自動的に活性にする。こ
     のモードをオンにすると、アドバイスを定義するとただちに効果を持つよ
     うになる。

 -- コマンド: ad-stop-advice
     関数を定義したり再定義してもアドバイスを自動的には活性にしない。

 -- User Option: ad-default-compilation-action
     この変数は、関数に対するアドバイスを活性にした結果作られる結合定義
     をコンパイルするかどうか制御する。

『予約活性』（*Note Preactivation::）中にアドバイス定義を作成するとその
定義はすでにコンパイルされているはずです。というのは、`preactivate'フラ
グを指定した`defadvice'を含むファイルをバイトコンパイル中にそれが定義さ
れたはずだからです。



File: elisp-ja.info, Node: Enabling Advice, Next: Preactivation, Prev: Activation of Advice, Up: Advising Functions

アドバイスの有効化と無効化
==========================

各アドバイス断片には、それを有効にするか無効にするかを指定するフラグがあ
ります。アドバイス断片を有効にしたり無効にすることで、アドバイス断片を未
定義にしたり再定義することなくオン／オフできます。たとえば、関数`foo'に
対するアドバイス断片`my-advice'を無効にするには、つぎのようにします。

     (ad-disable-advice 'foo 'before 'my-advice)

この関数自身は、アドバイス断片の有効化フラグを変更するだけです。アドバイ
スした関数でこの変更の効果を発揮するには、`foo'のアドバイスを再度活性に
する必要があります。

     (ad-activate 'foo)

 -- コマンド: ad-disable-advice FUNCTION CLASS NAME
     このコマンドはFUNCTIONに対するクラスCLASS内のNAMEで指名したアドバイ
     ス断片を無効にする。

 -- コマンド: ad-enable-advice FUNCTION CLASS NAME
     このコマンドはFUNCTIONに対するクラスCLASS内のNAMEで指名したアドバイ
     ス断片を有効にする。

正規表現を用いて、さまざまな関数に対する多数のアドバイス断片を一度に無効
にすることもできます。この場合も、当該関数のアドバイスを再度活性にするこ
とで、その効果が発揮されます。

 -- コマンド: ad-disable-regexp REGEXP
     このコマンドは、すべての関数のすべてのクラスのREGEXPに一致するアド
     バイス断片すべてを無効にする。

 -- コマンド: ad-enable-regexp REGEXP
     このコマンドは、すべての関数のすべてのクラスのREGEXPに一致するアド
     バイス断片すべてを有効にする。



File: elisp-ja.info, Node: Preactivation, Next: Argument Access in Advice, Prev: Enabling Advice, Up: Advising Functions

予約活性
========

アドバイスを実行するための結合定義を作成することは、ある程度手間がかかり
ます。ライブラリで多数の関数をアドバイスしていると、ライブラリのロードが
遅くなります。そのような場合、あらかじめ適切な結合定義を作成する"予約活
性"（preactivation）を使えます。

予約活性を使うには、`defadvice'でアドバイスを定義するときにフラグ
`preactivate'を指定します。このような`defadvice'の呼び出しでは、（有効か
無効に関わらず）このアドバイス断片と当該関数に対して現在有効になっている
他のアドバイスを元定義に結合した定義を作成します。`defadvice'をコンパイ
ルすると、その結合定義もコンパイルします。

のちに関数のアドバイスを活性にしたとき、関数に対する有効にしたアドバイス
がこの結合定義の作成に使用したものに一致すると既存の結合定義を使います。
そのため、新たに結合定義を作成する必要がなくなります。したがって、予約活
性はけっしてまちがった結果を生じませんが、予約活性に用いたアドバイスと活
性にした有効なアドバイスが一致しないと利点はなくなります。

不一致のために予約活性が正しく動作していない兆候の例を示します。

   * アドバイスした関数の活性に通常より長くかかる。
   * アドバイスした関数を活性にするとバイトコンパイラがロードされる。
   * バイトコンパイラを意図して使っていないのに、`features'の値に
     `byte-compile'が含まれる。

関数自体が定義されるまえであってもコンパイル済みの予約活性したアドバイス
は正しく動作します。しかし、予約活性したアドバイスを*コンパイル*するとき
には関数は定義済みである必要があります。

予約活性したアドバイスが使われない理由を調べるよい方法はありません。でき
ることは、関数のアドバイスを活性にするまえに、（関数
`trace-function-background'で）関数`ad-cache-id-verification-code'をトレー
スすることです。活性にしたあと、当該関数に対して
`ad-cache-id-verification-code'が返した値を調べます。`verified'ならば予
約活性したアドバイスが使われています。これ以外の値は、アドバイスが不適切
と判断された理由に関する情報を与えます。

*警告：*` ' 予約活性が失敗する場合が1つ知られている。現在のアドバイスの
状態に一致しなくても、あらかじめ作成した結合定義を使ってしまう。これは、
同一関数に対する同じクラスの同一名称であるが異なるアドバイス断片を2つの
パッケージで定義している場合に発生する。このようなことは避けること。



File: elisp-ja.info, Node: Argument Access in Advice, Next: Subr Arguments, Prev: Preactivation, Up: Advising Functions

アドバイスからの引数の参照
==========================

アドバイス断片の本体からアドバイスする関数の引数を参照するもっとも簡単な
方法は、関数定義で用いているものと同じ名前を使うことです。これには、元関
数の引数の変数名を知る必要があります。

多くの場合、この単純な方法で十分ですが、欠点もあります。アドバイス内に引
数名を直接書き込むために、堅牢ではありません。関数の元定義が変更されると、
アドバイスは動作しません。

他の方法は、アドバイスそのものに引数リストを指定することです。これは関数
の元定義の引数名を知る必要はありませんが、制約もあります。関数に対するす
べてのアドバイスで同一の引数リストを使う必要があります。なぜなら、すべて
のアドバイスに実際に使われる引数リストは、当該関数のアドバイス断片の最初
のものだからです。

より堅牢な方法は、活性にするときに、つまり、アドバイスを結合した定義を作
成するときに適切なフォームに展開されるマクロを使うことです。参照用マクロ
は、関数の引数変数への実引数の分配方法に依存しない実引数の位置で参照しま
す。Emacs Lispにおいては、引数の意味は引数リスト内での位置で決まるため、
これは堅牢です。

 -- Macro: ad-get-arg POSITION
     位置POSITIONにある実引数を返す。

 -- Macro: ad-get-args POSITION
     位置POSITIONから始まる実引数のリストを返す。

 -- Macro: ad-set-arg POSITION VALUE
     位置POSITIONにある実引数の値を設定する。

 -- Macro: ad-set-args POSITION VALUE-LIST
     位置POSITIONから始まる実引数のリストにVALUE-LISTを設定する。

例を示します。関数`foo'の定義はつぎのとおりであり、

     (defun foo (x y &optional z &rest r) ...)

つぎのように呼ばれるとします。

     (foo 0 1 2 3 4 5 6)

そうすると、`foo'の本体では、Xは0、Yは1、Zは2、Rは`(3 4 5 6)'です。この
とき、`ad-get-arg'や`ad-get-args'は、つぎの値を返します。

     (ad-get-arg 0) => 0
     (ad-get-arg 1) => 1
     (ad-get-arg 2) => 2
     (ad-get-arg 3) => 3
     (ad-get-args 2) => (2 3 4 5 6)
     (ad-get-args 4) => (4 5 6)

この例では、引数に値を設定できます。

     (ad-set-arg 5 "five")

の効果は、6番目の引数を`"five"'に変更します。`foo'の本体を実行するまえに
このアドバイスが実行されると、本体内ではRは`(3 4 "five" 6)'になります。

つぎは引数リストを変更する例です。

     (ad-set-args 0 '(5 4 3 2 1 0))

`foo'の本体を実行するまえにこのアドバイスが実行されると、`foo'の本体内で
は、Xは5、Yは4、Zは3、Rは`(2 1 0)'になります。

これらの引数参照は、実際にはLispマクロとしての実装ではありません。アドバ
イス機構で特別に実装してあります。



File: elisp-ja.info, Node: Subr Arguments, Next: Combined Definition, Prev: Argument Access in Advice, Up: Advising Functions

subr引数リストの定義
====================

アドバイス機能が結合定義を作成するとき、元関数の引数リストを知る必要があ
ります。基本関数に対しては、これはつねに可能とは限りません。アドバイスが
引数リストを決定できないときには、`(&rest ad-subr-args)'を使います。これ
はつねに動作しますが、引数値のリストを作成するために効率的ではありません。
`ad-define-subr-args'を使って、基本関数に対する適当な引数名を宣言できま
す。

 -- Function: ad-define-subr-args FUNCTION ARGLIST
     この関数は、関数FUNCTIONの引数リストとしてARGLISTを使うことを指定す
     る。

たとえば、

     (ad-define-subr-args 'fset '(sym newdef))

は、関数`fset'の引数リストを指定します。



File: elisp-ja.info, Node: Combined Definition, Prev: Subr Arguments, Up: Advising Functions

結合定義
========

関数には、N個の事前アドバイス（before-advice）、M個の包囲アドバイス
（around-advice）、K個の事後アドバイス（after-advice）があるとします。保
護したアドバイス断片はないと仮定すると、関数のアドバイスを実装するために
作成される結合定義はつぎのようになります。

     (lambda ARGLIST
       [ [ADVISED-DOCSTRING] [(interactive ...)] ]
       (let (ad-return-value)
         before-0-body-form...
              ....
         before-N-1-body-form...
         around-0-body-form...
            around-1-body-form...
                  ....
               around-M-1-body-form...
                  (setq ad-return-value
                        apply original definition to ARGLIST)
               other-around-M-1-body-form...
                  ....
            other-around-1-body-form...
         other-around-0-body-form...
         after-0-body-form...
               ....
         after-K-1-body-form...
         ad-return-value))

マクロはマクロとして再定義します。つまり、結合定義の先頭に`macro'を追加
します。

元関数やアドバイス断片のどれかに対話宣言があれば、対話宣言フォームが入り
ます。対話的な基本関数をアドバイスした場合には、特別な方法を使います。つ
まり、基本関数を`call-interactively'で呼び出して、基本関数自身が引数を読
み取るようにします。この場合、アドバイスからは引数を参照できません。

各クラスのさまざまなアドバイスの本体フォームは、それらの指定された順に組
み立てられます。包囲アドバイスL（around-advice L）のフォーム群は、包囲ア
ドバイスL - 1（around-advice L - 1）のフォームの1つに入ります。

包囲アドバイスのもっとも内側では、

     元定義をARGLISTに適用

しますが、そのフォームは元関数の種類に依存します。変数`ad-return-value'
には、その戻り値が設定されます。この変数はすべてのアドバイス断片から見え
るので、アドバイスした関数から実際に戻るまえに、これを参照したり変更でき
ます。

保護したアドバイス断片を含むアドバイスした関数の構造も同じです。唯一の違
いは、フォーム`unwind-protect'により、アドバイス断片でエラーを起こしたり
非ローカル脱出を行っても、保護したアドバイスが実行されることを保証します。
包囲アドバイスを1つでも保護していると、その結果として、包囲アドバイス全
体が保護されます。



File: elisp-ja.info, Node: Debugging, Next: Read and Print, Prev: Advising Functions, Up: Top

Lispプログラムのデバッグ
************************

Emacs Lispプログラムの問題点を調べるには、問題が発生したときにどのように
プログラムを使っているかに依存して、3つの方法があります。

   * プログラムを実行したときに問題が発生した場合には、実行中に何が起こっ
     ているかを調べるためにLispデバッガを使える。通常のデバッガに加えて、
     Emacsにはソースレベルデバッガedebugもある。本章では両者について述べ
     る。

   * 構文的な問題があるためにLispがプログラムを読み取れないときには、
     EmacsのLisp編集機能を使ってその場所を特定する。

   * プログラムをバイトコンパイラでコンパイルするときに問題が発生すると
     きには、コンパイラの入力バッファの調べ方を知る必要がある。

* Menu:

* Debugger::            How the Emacs Lisp debugger is implemented.
* Edebug::		A source-level Emacs Lisp debugger.
* Syntax Errors::       How to find syntax errors.
* Compilation Errors::  How to find errors that show up in byte compilation.

他の有用なデバッグツールは、ドリブルファイルです。ドリブルファイルをオー
プンしてあると、Emacsはすべてのキーボード入力をこのファイルにコピーしま
す。あとでこのファイルを調べれば、どんな入力があったかわかります。*Note
Terminal Input::。

端末設定に関した問題を解決するには、関数`open-termscript'が有用です。
*Note Terminal Output::。



File: elisp-ja.info, Node: Debugger, Next: Edebug, Prev: Debugging, Up: Debugging

Lispデバッガ
============

通常の"Lispデバッガ"は、フォームの評価を一時停止する機能を提供します。評
価を一時停止しているあいだ（"ブレーク"（break）と呼ばれる状態）は、実行
時スタックを調べたり、ローカルやグローバル変数の値を調べたり、それらの値
を変更できます。ブレークは再帰編集なので、Emacsの通常の編集機能すべてを
使えます。デバッガを再帰的に起動するようなプログラムを実行することさえで
きます。*Note Recursive Editing::。

* Menu:

* Error Debugging::       Entering the debugger when an error happens.
* Infinite Loops::	  Stopping and debugging a program that doesn't exit.
* Function Debugging::    Entering it when a certain function is called.
* Explicit Debug::        Entering it at a certain point in the program.
* Using Debugger::        What the debugger does; what you see while in it.
* Debugger Commands::     Commands used while in the debugger.
* Invoking the Debugger:: How to call the function `debug'.
* Internals of Debugger:: Subroutines of the debugger, and global variables.



File: elisp-ja.info, Node: Error Debugging, Next: Infinite Loops, Prev: Debugger, Up: Debugger

エラーによるデバッガの起動
--------------------------

デバッガへ入るもっとも重要な時期は、Lispエラーが発生したときです。これに
より、エラーの直接原因を調べることができます。

しかし、デバッガに入るのは、エラーの通常の帰結ではありません。多くのコマ
ンドは（バッファの末尾で`C-f'を使うなどの）不適切に起動されるとしばしば
Lispエラーを生じますが、通常の編集ではそのたびにデバッガに入ったのではと
ても不便です。そのため、エラーによってデバッガに入りたい場合には、変数
`debug-on-error'に`nil'以外を設定します。（コマンド
`toggle-debug-on-error'はこれを簡単に行う。）

 -- User Option: debug-on-error
     この変数は、エラーが通知され処理されないときにデバッガを呼び出すか
     どうか決定する。`debug-on-error'が`t'であると、すべての種類のエラー
     （`debug-ignored-errors'に指定したものを除く）はデバッガを呼び出す。
     `nil'であるとデバッガを呼び出さない。

     その値はデバッガを呼び出すエラー条件のリストでもよい。たとえば、リ
     スト`(void-variable)'にすると、「値を持たない変数に関したエラー」の
     みがデバッガを起動する。

     この変数が`nil'以外であると、Emacsはプロセスのフィルタ関数や番兵に
     対してエラーハンドラを作成しない。したがって、これらの関数でのエラー
     もデバッガを起動する。*Note Processes::。

 -- User Option: debug-ignored-errors
     この変数は、デバッガに入らないエラーの種類を指定する。その値はエラー
     条件シンボルや正規表現のリストである。エラーにこれらの条件シンボル
     が含まれるかエラーメッセージが正規表現の1つに一致する場合には、
     `debug-on-error'の値に関わらず当該エラーではデバッガに入らない。

     この変数の通常の値は、編集ではしばしば発生するが、Lispプログラムの
     バグではほとんど発生しないようなエラー群のリストである。しかし、
     『ほとんど』は『けっして』ではない。このリストに一致するようなエラー
     で読者のプログラムが失敗する場合、エラーをデバッグするにはこのリス
     トを変更する必要がある。もっとも簡単な方法は、
     `debug-ignored-errors'に`nil'を設定することである。

 -- User Option: debug-on-signal
     通常、`condition-case'で捕捉したエラーは、たとえ`debug-on-error'が
     `nil'以外であっても、けっしてデバッガを起動しない。いいかえれば、デ
     バッガを起動するまえに、`condition-case'はエラー処理の機会を得るの
     である。

     `debug-on-signal'に`nil'以外の値を設定すると、各エラーごとにデバッ
     ガがまず機会を得る。`debug-on-error'と`debug-ignored-errors'の値で
     指定される条件に一致すれば、`condition-case'に関わらずエラーはデバッ
     ガを起動する。

     *警告：*` ' この変数は強力な処方である！` ' Emacsのさまざまな部分で
     は通常の動作としてエラーを処理し、読者にはエラーが発生したことさえ
     わからない。`debug-on-signal'に`nil'以外の値を設定するとそれらのエ
     ラーでデバッガに入る。

     *警告：*` ' `debug-on-error'が`nil'であると、`debug-on-signal'は意
     味を持たない。

ファイル`.emacs'をロード中に発生するエラーをデバッグするには、オプション
`--debug-init'を使います。これにより、`.emacs'のロード中は
`debug-on-error'を`t'に束縛し、初期化ファイルでのエラーを捕捉する
`condition-case'を迂回します。

読者のファイル`.emacs'で`debug-on-error'を設定しても、その効果は`.emacs'
のロードを終ると持続しません。（これはコマンド行オプション`--debug-init'
の実装における好ましくない特性である。）`.emacs'で`debug-on-error'を恒久
的に設定する最良の方法は、つぎのように、`after-init-hook'を用いることで
す。

     (add-hook 'after-init-hook
               '(lambda () (setq debug-on-error t)))



File: elisp-ja.info, Node: Infinite Loops, Next: Function Debugging, Prev: Error Debugging, Up: Debugger

無限ループのデバッグ
--------------------

プログラムが無限にループし戻ってこないときには、まず、ループを停止する必
要があります。ほとんどのオペレーティングシステムでは、中断を意味する
`C-g'を使います。

普通に中断したのでは、プログラムが無限ループした理由に関する情報は得られ
ません。より詳しい情報を得るには、変数`debug-on-quit'に`nil'以外を設定し
ます。`C-g'による中断はエラーとは扱わないため、`C-g'の処理に関して
`debug-on-error'はなんの効果もありません。同様に、`debug-on-quit'はエラー
に関してなんの効果もありません。

無限ループの途中でデバッガを起動できれば、デバッガでステップ実行コマンド
を使って先へ進めます。ループひとまわりをステップ実行すれば、問題を解決す
るに十分な情報を得られるはずです。

 -- User Option: debug-on-quit
     この変数は、`quit'が通知され処理されなかった場合に、デバッガを呼び
     出すかどうかを決定する。`debug-on-quit'が`nil'以外である場合、
     （`C-g'を打って）中断するとデバッガを呼び出す。`debug-on-quit'が
     `nil'であると、中断してもデバッガを呼び出さない。*Note Quitting::。



File: elisp-ja.info, Node: Function Debugging, Next: Explicit Debug, Prev: Infinite Loops, Up: Debugger

関数呼び出し時のデバッガの起動
------------------------------

プログラムの途中で発生する問題点を調べるための1つの有用な技法は、ある関
数を呼び出すたびにデバッガに入ることです。問題を生じる関数に対してこのよ
うにしておき、当該関数をステップ実行するか、あるいは、問題が発生する直前
に呼ばれる関数に対してこのようにしておき、その関数の呼び出しを終えてから、
呼び出し側をステップ実行します。

 -- コマンド: debug-on-entry FUNCTION-NAME
     この関数は、FUNCTION-NAMEが呼び出されるたびにデバッガを起動するよう
     にする。当該関数の定義の最初のフォームとしてフォーム`(debug
     'debug)'を挿入することでこれを行う。

     Lispコードで定義した任意の関数は、解釈実行コードであろうとコンパイ
     ル済みのコードであろうと、関数に入るときにブレークするようにできる。
     関数がコマンドであると、Lispから呼ばれたときや対話的に呼ばれたとき
     に（引数を読み取ってから）デバッガに入る。（Cで書いた）基本関数は、
     この方法ではデバッグできない。

     `debug-on-entry'を対話的に呼び出すと、ミニバッファでFUNCTION-NAMEを
     問い合わせる。その関数がすでに呼び出し時にデバッガを起動するように
     なっていると、`debug-on-entry'はなにもしない。`debug-on-entry'はつ
     ねにFUNCTION-NAMEを返す。

     *注意：*` ' `debug-on-entry'を使ったあとに当該関数を再定義すると、
     デバッガに入るためのコードがなくなる。実質的には、関数を再定義する
     と呼び出し時にブレークする機能を取り消すことになる。

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               => fact
          (debug-on-entry 'fact)
               => fact
          (fact 3)

          ------ Buffer: *Backtrace* ------
          Entering:
          * fact(3)
            eval-region(4870 4878 t)
            byte-code("...")
            eval-last-sexp(nil)
            (let ...)
            eval-insert-last-sexp(nil)
          * call-interactively(eval-insert-last-sexp)
          ------ Buffer: *Backtrace* ------

          (symbol-function 'fact)
               => (lambda (n)
                    (debug (quote debug))
                    (if (zerop n) 1 (* n (fact (1- n)))))

 -- コマンド: cancel-debug-on-entry FUNCTION-NAME
     この関数は、FUNCTION-NAMEに対する`debug-on-entry'の効果（呼び出し時
     にブレークする）を取り消す。対話的に呼び出すと、ミニバッファで
     FUNCTION-NAMEを問い合わせる。FUNCTION-NAMEが`nil'であったり空文字列
     であると、すべての関数について、呼び出し時にブレークすることを取り
     消す。

     呼び出し時にブレークする設定をしていない関数に対して
     `cancel-debug-on-entry'を呼び出してもなにもしない。つねに
     FUNCTION-NAMEを返す。



File: elisp-ja.info, Node: Explicit Debug, Next: Using Debugger, Prev: Function Debugging, Up: Debugger

デバッガの明示的な起動
----------------------

読者のプログラムに式`(debug)'を書くと、その箇所でデバッガを呼び出すこと
ができます。つまり、ソースファイルを訪問して適当な箇所にテキスト
`(debug)'を挿入し、`C-M-x'と打ちます。*警告：*` ' 一時的なデバッグ目的で
これを行う場合には、ファイルを保存するまえにこの挿入箇所をもとに戻すこと！

`(debug)'を挿入する箇所は、余分なフォームを評価してもその値を無視できる
場所でなければなりません。（`(debug)'の値が無視されないと、プログラムの
実行を変えてしまう！）もっとも適した一般的な場所は`progn'や暗黙の`progn'
の内側です（*Note Sequencing::）。



File: elisp-ja.info, Node: Using Debugger, Next: Debugger Commands, Prev: Explicit Debug, Up: Debugger

デバッガの使い方
----------------

デバッガに入ると、それまで選択していたバッファをあるウィンドウに、
`*Backtrace*'という名前のバッファを別のウィンドウに表示します。バックト
レースバッファでは、各行は現在実行中のLisp関数の各レベルです。このバッファ
の先頭には、デバッガを起動するに至った理由（エラーで起動されたときにはエ
ラーメッセージと関連データ）を表すメッセージがあります。

バックトレースバッファは読み出し専用であり、各文字をデバッガコマンドであ
ると定義した特別なメジャーモード、debuggerモードを使います。Emacsの通常
の編集コマンドも使えます。したがって、エラー発生時に編集していたバッファ
を調べるためにウィンドウを切り替えたり、バッファを切り替えたり、ファイル
を訪れたり、その他のどんな編集でもできます。しかし、デバッガは再帰編集レ
ベル（*Note Recursive Editing::）であるので、デバッグを終えるときには、
バックトレースバッファに戻ってからデバッガを（コマンド`q'で）終了するの
が賢い方法です。デバッガを終了すると、再帰編集から抜けバックトレースバッ
ファを削除します。

バックトレースバッファでは、実行中の関数とその引数の値を表示します。また、
スタックフレームを記述する行へポイントを移動することでスタックフレームを
指定できます。（スタックフレームとは、Lispインタープリタが関数の起動に関
する情報を記録しておく場所である。）ポイントがある行に対応するフレームを
"カレントフレーム"（current frame）と呼びます。デバッガのある種のコマン
ドはカレントフレームに作用します。

デバッガ自身はバイトコンパイルしたものを実行する必要があります。というの
は、デバッガ自身が使用するスタックフレームのサイズを仮定しているからです。
解釈実行だとこの仮定が成り立ちません。




File: elisp-ja.info, Node: Debugger Commands, Next: Invoking the Debugger, Prev: Using Debugger, Up: Debugger

デバッガコマンド
----------------

デバッガ内（debuggerモード）では、通常のカーソル移動コマンドに加えて以下
の特別なコマンドを使えます。（ウィンドウやバッファの切り替えなどのEmacs
の通常の機能も使えることに留意。）

デバッガコマンドのもっとも重要な使い方はステップ実行であり、これにより制
御の流れを調べることです。デバッガは、解釈実行版の関数の制御構造をステッ
プ実行できますが、バイトコンパイルした関数ではできません。バイトコンパイ
ルした関数をステップ実行したい場合には、同じ関数を解釈実行版の定義に置き
換える必要があります。（これには、関数のソースを訪れて、その定義内で
`C-M-x'と打つ。）

debuggerモードのコマンド一覧を以下に示します。

`c'
     デバッガを終了し実行を継続する。継続可能であれば、（デバッガ内で行っ
     た変数値やデータ構造に対する変更などの副作用を除いて）デバッガを起
     動しなかったかのようにプログラムの実行を再開する。

     継続が可能なのは、関数呼び出し時や終了時、明示的な起動、中断により
     デバッガに入った場合である。エラーが原因でデバッガが起動されたとき
     には継続できない。

`d'
     実行を継続するが、任意のLisp関数を呼び出すとデバッガに入る。これに
     より、式の部分式をステップ実行して部分式が計算する値やその動作を調
     べることができる。

     このようにしてデバッガを起動した関数呼び出しのスタックフレームには
     自動的に印が付き、そのスタックから抜けるとデバッガがふたたび呼び出
     される。この印を消すにはコマンド`u'を使う。

`b'
     フレームから抜けるとデバッガに入るようにカレントフレームに印を付け
     る。このように印を付けたフレームには、バックトレースバッファでは星
     印が付く。

`u'
     カレントフレームから抜けるときにデバッガに入らない。これは、当該フ
     レームに対するコマンド`b'を取り消す。視覚的にはバックトレースバッファ
     の当該行から星印が取られる。

`e'
     ミニバッファでLisp式を読み取り、それを評価し、その値をエコー領域に
     表示する。この操作の一環として、デバッガは重要なある種の変数やカレ
     ントバッファを変更する。`e'はそれらの値をデバッガの外側の値に一時的
     に復元するので、それらを調べたり変更したりできる。これによりデバッ
     ガは透過的になる。対照的に、`M-:'はデバッガ内で特別なことは行わない。
     デバッガ内での変数値を表示する。

`R'
     `e'と同様であるが、バッファ`*Debugger-record*'での評価結果も保存す
     る。

`q'
     デバッグ中のプログラムを終了する。Emacsのトップレベルのコマンド実行
     へ戻る。

     `C-g'でデバッガへ入ったが、実際には中断したいのであってデバッグはし
     たくない場合にはコマンド`q'を使う。

`r'
     デバッガから値を指定して戻る。その値は、ミニバッファで式を読み取り、
     それを評価して得る。

     （`b'で指定したり`d'でフレームに入ることで）Lispの呼び出しフレーム
     から抜けでたためにデバッガが起動された場合に、コマンド`r'は有用であ
     る。コマンド`r'で指定した値は、当該フレームの値として使われる。この
     コマンドは、`debug'を呼び出してその戻り値を使う場合にも有用である。
     さもなければ、`r'は`c'と同じ効果であり、指定した戻り値は関係ない。

     エラーでデバッガに入った場合には`r'は使えない。



File: elisp-ja.info, Node: Invoking the Debugger, Next: Internals of Debugger, Prev: Debugger Commands, Up: Debugger

デバッガの起動
--------------

ここでは、デバッガを起動するために使われる関数`debug'の詳細を述べます。

 -- Function: debug &rest DEBUGGER-ARGS
     この関数はデバッガに入る。`*Backtrace*'（あるいはデバッガの第2レベ
     ルに再帰的に入ると`*Backtrace*<2>'など）という名前のバッファに切り
     替え、Lisp関数の呼び出しスタックに関する情報でこのバッファを満たす。
     そして再帰編集に入りdebuggerモードのバックトレースバッファを表示す
     る。

     debuggerモードのコマンド`c'や`r'で再帰編集から抜けだし、`debug'はそ
     れ以前のバッファに切り替え`debug'を呼び出したところへ戻る。これは、
     関数`debug'が呼び出し側へ戻る唯一の手段である。

     DEBUGGER-ARGSの使い途は、`debug'が引数の残りをバッファ`*Backtrace*'
     の先頭に表示し、ユーザーが読めるようにすることである。以下に述べる
     場合を除いて、これがこれらの引数の*唯一*の用途である。

     `debug'の第1引数が特定の値を持つ場合、特別な意味がある。（通常、こ
     れらの値はEmacs内部で用いるだけであり、プログラマが`debug'を呼ぶと
     きには使わない。）以下にこれらの特別な値を示す。

     `lambda'
          第1引数が`lambda'であると、`debug-on-next-call'が`nil'以外であ
          るために関数に入るときに`debug'を呼び出したことを意味する。デ
          バッガはバッファの先頭にテキスト行`Entering:'を表示する。

     `debug'
          第1引数が`debug'であると、関数に入るときにデバッガを起動するよ
          うになっていたために`debug'を呼び出したことを示す。デバッガは、
          `lambda'の場合と同様に、`Entering:'を表示する。さらに、当該関
          数のスタックフレームに関数から戻るときにデバッガを起動するよう
          に印を付ける。

     `t'
          第1引数が`t'であると、`debug-on-next-call'が`nil'以外であると
          きにフォームの並びを評価したために`debug'を呼び出したことを示
          す。デバッガはバッファの先頭行につぎの行を表示する。

               Beginning evaluation of function call form:

     `exit'
          第1引数が`exit'であると、スタックフレームから抜けるときにデバッ
          ガを呼び出すように印を付けたスタックフレームから抜けたことを示
          す。この場合、`debug'の第2引数はフレームからの戻り値である。デ
          バッガはバッファの先頭行に`Return value:'に続けて戻り値を表示
          する。

     `error'
          第1引数が`error'であると、エラーや`quit'が通知されたが処理され
          ないためにデバッガに入ったことを示し、`Signaling:'に続けて通知
          されたエラーと`signal'の引数を表示する。たとえばつぎのとおり。

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: *Backtrace* ------
               Signaling: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

          エラーが通知されたときには、変数`debug-on-error'は`nil'以外で
          あるはずである。`quit'が通知されたときには、変数
          `debug-on-quit'は`nil'以外であるはずである。

     `nil'
          明示的にデバッガに入るときには、DEBUGGER-ARGSの先頭として`nil'
          を使う。DEBUGGER-ARGSの残りはバッファの先頭行に表示される。こ
          の機能を用いてメッセージを表示でき、たとえば、`debug'を呼び出
          した条件の覚え書きにする。



File: elisp-ja.info, Node: Internals of Debugger, Prev: Invoking the Debugger, Up: Debugger

デバッガの内部
--------------

本節では、デバッガが内部的に使用する関数や変数について述べます。

 -- Variable: debugger
     この変数の値は、デバッガを起動するために呼び出す関数である。その値
     は、可変個数の引数を取る関数（あるいは典型的には関数名）であること。
     その関数でなんらかのデバッガに入ると仮定する。この変数のデフォルト
     値は`debug'。

     Lispが関数に渡す最初の引数で、呼び出した理由を表す。引数の規約は
     `debug'に記述してある。

 -- コマンド: backtrace
     この関数は、現在活性なLisp関数呼び出しのトレースを表示する。これは、
     `debug'がバッファ`*Backtrace*'を満たすために用いる関数である。どの
     関数呼び出しが活性であるかを判断するためにスタックを参照する必要が
     あるためCで書いてある。戻り値はつねに`nil'。

     以下の例では、Lisp式で明示的に`backtrace'を呼び出す。これにより、バッ
     クトレースをストリーム`standard-output'に出力する。ここではバッファ
     `backtrace-output'に出力する。バックトレースの各行は、1つの関数呼び
     出しを表す。関数の引数値すべてが判ればそれらを行に表示する。それら
     が計算途中であれば、その旨を行に表示する。スペシャルフォームの引数
     は省略する。

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               => nil

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval-region(1973 2142 #<buffer *scratch*>)
            byte-code("...  for eval-print-last-sexp ...")
            eval-print-last-sexp(nil)
          * call-interactively(eval-print-last-sexp)
          ----------- Buffer: backtrace-output ------------

     文字`*'は、抜け出るときにデバッガを起動する印が付いているフレームを
     表す。


 -- Variable: debug-on-next-call
     この変数が`nil'以外であると、つぎに`eval'、`apply'、`funcall'を呼び
     出すまえにデバッガを呼び出すことを指定する。デバッガに入ると
     `debug-on-next-call'を`nil'に設定する。

     デバッガのコマンド`d'は、この変数を設定することで動作する。

 -- Function: backtrace-debug LEVEL FLAG
     この関数は、LEVELの深さのスタックフレームに値FLAGに応じてフレームか
     ら抜け出るときのデバッガ呼び出しの印を付ける。FLAGが`nil'以外である
     と、のちに当該フレームから抜けるとデバッガに入る。非ローカルな脱出
     で当該フレームから抜けるときにもデバッガに入る。

     この関数はデバッガのみが使用する。

 -- Variable: command-debug-status
     この変数は、現在の対話的コマンドのデバッグ状況を記録する。コマンド
     が対話的に呼び出されるたびに、この変数は`nil'に束縛される。デバッガ
     はこの変数に設定することで、同じコマンドの起動中にデバッガが将来起
     動された場合に備えて情報を残すことができる。

     デバッガにとっては、通常のグローバル変数ではなくこの変数を使う利点
     は、以降のコマンド起動にデータが繰り越さないことである。

 -- Function: backtrace-frame FRAME-NUMBER
     関数`backtrace-frame'は、Lispデバッガで使うことを意図している。深さ
     FRAME-NUMBERのスタックフレームで進行中の計算に関する情報を返す。

     当該フレームで引数の評価を完了していなければ（あるいはスペシャルフォー
     ム）、値は`(nil FUNCTION ARG-FORMS...)'。

     当該フレームで引数の評価を完了し関数を呼び出していれば、値は`(t
     FUNCTION ARG-VALUES...)'。

     戻り値において、FUNCTIONは評価したリストのCARであるか、マクロ呼び出
     しでは`lambda'式である。関数に引数`&rest'があれば、リストARG-VALUES
     の残りで表現される。

     FRAME-NUMBERが範囲外であると、`backtrace-frame'は`nil'を返す。






File: elisp-ja.info, Node: Edebug, Next: Syntax Errors, Prev: Debugger, Up: Debugging

edebug
======

edebugはEmacs Lispプログラムのソースレベルデバッガであり、つぎのことを行
えます。

   * 各式の前後で停止して評価をステップ実行する。

   * 条件付きブレークポイント、無条件ブレークポイントを設定する。

   * 指定した条件が真の場合に停止する（グローバルブレークイベント）。

   * 各停止位置や各ブレークポイントで停止し低速／高速トレースする。

   * edebugの外側であるかのように、式の結果を表示したり式を評価する。

   * edebugが表示を更新するたびに、自動的に式の並びを再評価しその結果を
     表示する。

   * 関数の出入りに関するトレース情報を出力する。

   * エラーが発生すると停止する。

   * edebug自身のフレームを省いて、バックトレースを表示する。

   * マクロや定義フォームに対して引数の評価を指定する。

   * 基本的なカバレッジテストや頻度数計測を行う。

以下の最初の3つの節では、edebugを使うのに十分な情報を与えます。

* Menu:

* Using Edebug::		Introduction to use of Edebug.
* Instrumenting::		You must instrument your code
				  in order to debug it with Edebug.
* Modes: Edebug Execution Modes. Execution modes, stopping more or less often.
* Jumping::			Commands to jump to a specified place.
* Misc: Edebug Misc.		Miscellaneous commands.
* Breakpoints::			Setting breakpoints to make the program stop.
* Trapping Errors::		trapping errors with Edebug.
* Views: Edebug Views.		Views inside and outside of Edebug.
* Eval: Edebug Eval.			Evaluating expressions within Edebug.
* Eval List::			Expressions whose values are displayed
				  each time you enter Edebug.
* Printing in Edebug::		Customization of printing.
* Trace Buffer::		How to produce trace output in a buffer.
* Coverage Testing::		How to test evaluation coverage.
* The Outside Context::		Data that Edebug saves and restores.
* Instrumenting Macro Calls::	Specifying how to handle macro calls.
* Options: Edebug Options.	Option variables for customizing Edebug.



File: elisp-ja.info, Node: Using Edebug, Next: Instrumenting, Prev: Edebug, Up: Edebug

edebugの使い方
--------------

edebugでLispプログラムをデバッグするには、デバッグしたいLispコードをまず
"処置"（instrument）しておく必要があります。これを行う簡単な方法は、関数
やマクロの定義にポイントを移動してから、`C-u C-M-x'（前置引数を指定した
`eval-defun'）を実行します。コードを処置する別の方法については、*Note
Instrumenting::。

関数をいったん処置しておけば、当該関数を呼び出すとedebugを活性にします。
edebugが活性になると実行を停止し、読者が選択したedebugの実行モードに応じ
て、関数をステップ実行したりデバッグコマンドを検査しながら表示を更新しつ
つ実行を継続します。デフォルトの実行モードはステップ実行であり、いったん
実行を停止します。*Note Edebug Execution Modes::。

edebugでは、デバッグ中のLispコードのソースを表示したEmacsバッファを読者
は見ます。このバッファを"ソースコードバッファ"と呼びます。このバッファは
一時的に読み出し専用です。

左端の矢印は、関数の実行中の行を表します。ポイントの初期位置は関数の実行
中の行にありますが、読者自身がポイントを移動すると変わります。

（以下の）`fac'の定義を処置してから`(fac 3)'を実行したとすると、つぎのよ
うになります。ポイントは`if'のまえの開き括弧にあります。

     (defun fac (n)
     =>-!-(if (< 0 n)
           (* n (fac (1- n)))
         1))

edebugが関数内で実行を停止できる箇所を"停止位置"（stop point）と呼びます。
これらは、リストである各部分式の前後と各変数参照のうしろにあります。関数
`fac'の中にある停止位置をピリオドで示します。

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac (1- n.).).).
         1).)

ソースコードバッファでは、Emacsのlispモードのコマンドに加えてedebugの特
別なコマンドを使えます。たとえば、つぎの停止位置まで実行するにはedebugコ
マンドSPCを打ちます。`fac'に入ったあとでSPCを1回打つと、つぎのような表示
になります。

     (defun fac (n)
     =>(if -!-(< 0 n)
           (* n (fac (1- n)))
         1))

式のうしろでedebugが実行を停止すると、式の値をエコー領域に値を表示します。

多用される他のコマンドには、停止位置にブレークポイントを設定する`b'、ブ
レークポイントに達するまで実行する`g'、edebugを終了してトップレベルのコ
マンドループへ戻る`q'があります。edebugのコマンド一覧を表示するには`?'を
打ちます。



File: elisp-ja.info, Node: Instrumenting, Next: Edebug Execution Modes, Prev: Using Edebug, Up: Edebug

edebug向けの処置
----------------

Lispコードのデバッグにedebugを使うためには、コードをまず"処置"する必要が
あります。コードを処置すると、適当な箇所でedebugを起動する追加のコードを
挿入します。

いったんedebugをロードすると、コマンド`C-M-x'（`eval-defun'）は再定義さ
れます。定義内で前置引数を指定して起動すると定義を評価するまえに処置する
ようになります。（ソースコード自体は変更しない。）変数`edebug-all-defs'
が`nil'以外であると、前置引数の意味を逆にします。つまり、前置引数を指定
し*ない限り*、`C-M-x'は関数定義を処置します。変数`edebug-all-defs'のデフォ
ルト値は`nil'です。コマンド`M-x edebug-all-defs'は変数`edebug-all-defs'
の値をトグルします。

`edebug-all-defs'が`nil'以外であると、コマンド`eval-region'、
`eval-current-buffer'、`eval-buffer'もそれらが評価する定義を処置します。
同様に、`edebug-all-forms'は、定義以外のフォームであっても`eval-region'
が*任意*のフォームを処置するかどうか制御します。これは、ミニバッファでの
ロードや評価には適用されません。コマンド`M-x edebug-all-forms'はこのオプ
ションをトグルします。

別のコマンド`M-x edebug-eval-top-level-form'は、`edebug-all-defs'と
`edebug-all-forms'の値に関わらず任意のトップレベルのフォームを処置するた
めに使えます。

edebugが動作中は、コマンド`I'（`edebug-instrument-callee'）で、ポイント
のうしろのフォームから呼ばれる関数やマクロの定義を処置済みでなければ処置
できます。これは、edebugが当該関数のソースを探せる場合にのみ可能です。
edebugをロード後には、`eval-region'は、処置していないものも含めて、評価
した各定義の位置を記録しています。関数を処置後に呼び出してステップ実行す
るコマンド`i'（*Note Jumping::）も参照してください。

edebugは、標準のスペシャルフォームすべて、式を引数とする`interactive'フォー
ム、無名ラムダ式、他の定義フォームをどのように処置するかわかっています。
edebugは、マクロ呼び出しを引数に持つユーザー定義マクロをどのように処置す
べきかわかりませんから、読者がそれを指示する必要があります。詳しくは、
*Note Instrumenting Macro Calls::。

edebugは、あるセッションで初めてコードを処置する場合、フック
`edebug-setup-hook'を実行してからそれに`nil'を設定します。これを利用する
と、読者が使用するパッケージに対応したedebug用仕様（*Note Instrumenting
Macro Calls::）をedebugを使用する場合にのみロードするようにできます。

定義から処置を取り除くには、処置しないような方法でその定義を単に再評価す
るだけです。けっして処置せずにフォームを評価する方法は2つあります。ファ
イルを`load'するか、ミニバッファで`eval-expression'（`M-:'）を使います。

edebugが処置中に構文エラーを検出すると、コードのエラー箇所にポイントを置
いて、エラー`invalid-read-syntax'を通知します。

edebugの内側で使える他の評価関数については*Note Edebug Eval::。



File: elisp-ja.info, Node: Edebug Execution Modes, Next: Jumping, Prev: Instrumenting, Up: Edebug

edebugの実行モード
------------------

edebugには読者がデバッグしているプログラムを実行するための実行モードが複
数あります。これらを"edebugの実行モード"と呼びます。これらをメジャーモー
ドやマイナモードと混同しないでください。edebugの実行モードは、停止するま
でにどの程度edebugが実行を継続するか、たとえば、各停止位置で停止するのか
つぎのブレークポイントまで継続するのか、また、停止するまでに評価の進行状
況をどの程度edebugが表示するのかを決定します。

通常、あるモードにおいて、プログラムを継続するコマンドを打つことでedebug
の実行モードを指定します。以下にそれらのコマンドの一覧を示します。`S'を
除くすべてのコマンドは、少なくともある程度プログラムの実行を再開します。

`S'
     停止：` 'プログラムをいっさい実行せずに、edebugコマンドの入力を待つ
     （`edebug-stop'）。

`SPC'
     ステップ実行：` 'つぎに出会う停止位置で止まる（`edebug-step-mode'）。

`n'
     つぎ：` '式のうしろでつぎに出会う停止位置で止まる
     （`edebug-next-mode'）。*Note Edebug Misc::の`edebug-forward-sexp'
     も参照。

`t'
     トレース：` 'edebugの各停止位置で1秒間休止する（`edebug-trace-mod
     e'）。

`T'
     高速トレース：` '各停止位置で表示を更新するが休止しない
     （`edebug-Trace-fast-mode'）。

`g'
     実行：` 'つぎのブレークポイントまで実行する（`edebug-go-mode'）。
     *Note Breakpoints::。

`c'
     継続：` '各ブレークポイントで1秒間休止してから継続する
     （`edebug-continue-mode'）。

`C'
     高速継続：` '各ブレークポイントへポイントを移動するが休止しない
     （`edebug-Continue-fast-mode'）。

`G'
     非停止実行：` 'ブレークポイントを無視する（`edebug-Go-nonstop-mod
     e'）。`S'や編集コマンドを打てば停止できる。

一般に、上記一覧の上にある実行モードほど下にあるものに比べるとプログラム
をゆっくり実行、つまり、早く停止します。

実行中やトレース中には、edebugコマンドをなにか打てば実行に割り込めます。
edebugはつぎの停止位置でプログラムを止め、読者が打ったコマンドを実行しま
す。たとえば、実行中に`t'を打てば、つぎの停止位置でトレースモードに切り
替わります。単に実行を停止するには`S'を使います。

読者の関数が入力を読み取る場合、実行に割り込むつもりで打った文字を関数が
読み取ってしまうかもしれません。読者のプログラムがいつ入力するかに注意し
ていれば、このような意図しない結果を避けることができます。

本節で述べたコマンドを含むキーボードマクロは動作しません。つまり、プログ
ラムを再開するためにedebugから抜けるとキーボードマクロの制御を失ってしま
います。これを修正するのは簡単ではありません。また、edebugの外側でキーボー
ドマクロを定義したり実行しても、edebug内のコマンドにはなんの影響もありま
せん。これは普通は利点です。しかし、オプション
`edebug-continue-kbd-macro' （*Note Edebug Options::）も参照してください。

edebugの新たなレベルに入ると、変数`edebug-initial-mode'の値を実行モード
の初期値とします。デフォルトでは、これはステップ実行モードを指定します。
処置した関数を1つのコマンドから複数回呼び出すなどしてedebugの同一レベル
に再度入ることができることに注意してください。




File: elisp-ja.info, Node: Jumping, Next: Edebug Misc, Prev: Edebug Execution Modes, Up: Edebug

ジャンプ
--------

本節で述べるコマンドは、指定した位置に達するまで実行します。`i'を除くす
べてのものは、停止する場所に一時的なブレークポイントを設定してから実行モー
ドに移行します。意図したブレークポイントより先に別のブレークポイントに達
しても実行を停止します。ブレークポイントについて詳しくは*Note
Breakpoints::。

非ローカル脱出は、読者が意図したプログラムの停止すべき一時的なブレークポ
イントを迂回するため、これらのコマンドは非ローカル脱出があると意図したよ
うに動作しません。

`h'
     ポイント位置付近の停止位置まで進む（`edebug-goto-here'）。

`f'
     プログラムの式1つ分先へ進む（`edebug-forward-sexp'）。

`o'
     囲んでいるS式の終りまでプログラムを実行する。

`i'
     ポイントのあとのフォームから呼ばれる関数やマクロへ進む。

コマンド`h'は、一時的なブレークポイントを使って、ポイント位置付近の停止
位置まで進みます。ブレークポイントについて詳しくは*Note Breakpoints::。

コマンド`f'は、プログラムの式1つ分先へ進みます。より正確には、`C-M-f'に
よる移動箇所へ一時的なブレークポイントを設定し、プログラムがブレークポイ
ントで停止するような実行モードで実行します。

前置引数Nを指定すると、ポイント位置からN個先のS式に一時的なブレークポイ
ントを設定します。囲んでいるリストの残り要素数がNより少なければ、囲んで
いる式の末尾で停止します。

`C-M-f'の移動先はプログラムが実際に停止するであろう箇所です。これが正し
くない場合もあり、たとえば、`cond'では正しくありません。

コマンド`f'は、柔軟性のために、停止位置ではなくポイント位置で
`forward-sexp'を使います。*現在の停止位置から*式1つだけ実行したい場合に
は、まず`w'と打ってポイントを停止位置に移動してから`f'を打ちます。

コマンド`o'は式から『出る』まで実行します。ポイントを含むS式の末尾に一時
的なブレークポイントを置きます。このS式が関数定義そのものである場合には、
`o'は定義の最後のS式の手前まで実行します。現在この箇所にいた場合には、関
数から戻ってから停止します。いいかえれば、最後のS式のあとに位置していな
い限り、このコマンドは現在実行中の関数から抜けません。

コマンド`i'は、ポイント位置のあとにあるリストフォームから呼ばれる関数や
マクロへ進み、最初に出会った停止位置で止まります。そのフォームはこれから
評価されるフォームである必要はありません。しかし、評価されるフォームが関
数呼び出しである場合には、引数を評価するまえにこのコマンドを使うことを覚
えておいてください。さもないとこのコマンドを使う時期が遅すぎます。

コマンド`i'は、呼び出す関数やマクロが処置されていないとそれらを処置しま
す。これは便利ですが、それらの関数やマクロは、明示的に処置を取り除かない
限り、処置したままになります。



File: elisp-ja.info, Node: Edebug Misc, Next: Breakpoints, Prev: Jumping, Up: Edebug

edebugのその他のコマンド
------------------------

edebugの他のコマンドを以下に示します。

`?'
     edebugのヘルプメッセージを表示する（`edebug-help'）。

`C-]'
     1つまえのレベルのコマンドレベルへ戻る（`abort-recursive-edit'）。

`q'
     エディタのトップレベルのコマンドループへ戻る（`top-level'）。edebug
     のすべての動作中のレベルを含めて、すべての再帰編集レベルから抜ける。
     しかし、フォーム`unwind-protect'や`condition-case'で保護した処置済
     みのコードがあるとデバッガを再開する。

`Q'
     `q'と同様であるが保護したコードでも停止しない（`top-level-nonstop'）。

`r'
     もっとも最近の式の既知の結果をエコー領域に再表示する
     （`edebug-previous-result'）。

`d'
     わかりやすいようにedebug自体の関数を除外してバックトレースを表示す
     る（`edebug-backtrace'）。

     edebugのバックトレースバッファでは、標準のデバッガのようにはデバッ
     ガのコマンドを使えない。

     実行を継続するとバックトレースバッファは自動的に削除される。

edebugの再帰編集から、edebugを再帰的に活性にするコマンドを起動できます。
edebugが活性であるときにはいつでも`q'でトップレベルへ戻るか、`C-]'で1つ
の再帰編集レベルを抜けることができます。保留している評価すべてのバックト
レースは`d'で表示できます。



