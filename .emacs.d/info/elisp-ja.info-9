Info file: elisp-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり、Emacs 20.3版に対応します。

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled "GNU General Public License" is included exactly as in
the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled "GNU General Public License" may be
included in a translation approved by the Free Software Foundation
instead of in the original English.






File: elisp-ja.info, Node: Breakpoints, Next: Trapping Errors, Prev: Edebug Misc, Up: Edebug

ブレークポイント
----------------

edebugのステップ実行モードは、つぎの停止位置に達すると実行を停止します。
edebugが実行を止める方法は3つあります。ブレークポイント、グローバルブレー
ク条件、ソースのブレークポイントです。

edebugを使用中には、読者がテスト中のプログラムに"ブレークポイント" 
（breakpoint）、つまり、実行を停止すべき箇所を設定できます。*Note Using
Edebug::で定義した任意の停止位置にブレークポイントを設定できます。ブレー
クポイントの設定や解除において対象となる停止位置は、ソースコードバッファ
のポイント位置かそのあとにある停止位置です。ブレークポイントに関する
edebugコマンドはつぎのとおりです。

`b'
     ポイント位置かそのうしろにある停止位置にブレークポイントを設定する
     （`edebug-set-breakpoint'）。前置引数を指定すると、一時的なブレーク
     ポイントになる（そこでプログラムが停止すると解除される）。

`u'
     ポイント位置かそのうしろにある停止位置の（あれば）ブレークポイント
     を解除する（`edebug-unset-breakpoint'）。

`x CONDITION RET'
     CONDITIONが`nil'以外の値に評価される場合にのみプログラムを停止する
     条件付きブレークポイントを設定する
     （`edebug-set-conditional-breakpoint'）。前置引数を指定すると、一時
     的なブレークポイントになる。

`B'
     現在の定義内にあるつぎのブレークポイントにポイント位置を移動する
     （`edebug-next-breakpoint'）。

edebug内では、`b'でブレークポイントを設定し、`u'で解除できます。まず目的
のedegugの停止位置にポイント位置を移動し、`b'を打ってその箇所にブレーク
ポイントを設定したり、`u'を打ってその箇所のブレークポイントを解除します。
設定されていないブレークポイントを解除しても、なにも起こりません。

定義を再評価したり再処置すると、その中のブレークポイントすべてを解除しま
す。

"条件付きブレークポイント"（conditional breakpoint）は、プログラムがこの
箇所に達するたびに条件を検査します。条件を評価中に発生するどんなエラーも
無視し、`nil'として扱います。条件付きブレークポイントを設定するには`x'を
使い、条件式はミニバッファで指定します。すでに条件付きブレークポイントを
設定してある停止位置に条件付きブレークポイントを設定し直すと、それまでの
条件式がミニバッファに入るので編集できます。

ブレークポイントを設定するコマンドに前置引数を指定すると、条件付き／無条
件ブレークポイントを"一時的"なものにできます。一時的ブレークポイントでプ
ログラムが停止すると、そのブレークポイントは自動的に解除されます。

edebugのモードが非停止実行でなければ、edebugはブレークポイントでつねに停
止するか休止します。非停止実行モードでは、ブレークポイントを完全に無視し
ます。

ブレークポイントの場所を確認するには、コマンド`B'を使います。同じ関数内
のポイント箇所のうしろにあるブレークポイントか、後続のものがなければ最初
のブレークポイントにポイント位置を移動します。このコマンドは実行を継続し
ません。バッファ内で単にポイントを移動するだけです。

* Menu:

* Global Break Condition::	Breaking on an event. 
* Source Breakpoints::  	Embedding breakpoints in source code.




File: elisp-ja.info, Node: Global Break Condition, Next: Source Breakpoints, Prev: Breakpoints, Up: Breakpoints

グローバルブレーク条件
......................

"グローバルブレーク条件"（global break condition）は、指定した条件が満た
されると、その場所に関わらず、実行を停止させます。edebugは各停止位置にお
いてグローバルブレーク条件を評価します。これが`nil'以外の値であると、ブ
レークポイントに達したかのように、実行モードに依存して実行を停止するか休
止します。条件の評価中にエラーが発生しても実行は停止しません。

条件式は`edebug-global-break-condition'に保存されます。コマンド`X'で新た
な条件式を指定できます（`edebug-set-global-break-condition'）。

グローバルブレーク条件は、読者のコードのどこでイベントが発生するかを調べ
るもっとも簡単な方法ですが、コードの実行速度をかなり遅くします。ですから、
使用しない場合には条件を`nil'に再設定すべきです。



File: elisp-ja.info, Node: Source Breakpoints, Prev: Global Break Condition, Up: Breakpoints

ソース上のブレークポイント
..........................

定義内のすべてのブレークポイントは、定義を処置し直すたびに失われます。ブ
レークポイントを失いたくない場合には、"ソース上のブレークポイント"
（source breakpoint）を指定できます。これはソースコード上で関数`edebug'
を呼び出すだけです。もちろん、条件付けして呼び出せます。たとえば、関数
`fac'において、引数がゼロの場合に停止するには、以下に示すように最初の行
を挿入します。

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

関数`fac'を処置してこの関数を呼び出すと、`edebug'の呼び出しはブレークポ
イントのように動作します。実行モードに応じて、edebugはその箇所で停止する
か休止します。

`edebug'を呼び出したコードが処置済みでなければ、この関数は`debug'を呼び
出します。



File: elisp-ja.info, Node: Trapping Errors, Next: Edebug Views, Prev: Breakpoints, Up: Edebug

エラーの捕捉
------------

Emacsは、通常、エラーが通知されても`condition-case'で処理されなかった場
合、エラーメッセージを表示します。edebugが活性であり処置済みのコードを実
行していると、edebugは処理されなかったエラーすべてに反応します。この動作
を`edebug-on-error'と`edebug-on-quit'でカスタマイズできます。*Note
Edebug Options::。

edebugがエラーに反応すると、エラーを起こすまえ出会った最後の停止位置を表
示します。この位置は、実際にエラーを起こした処置してない関数の呼び出し位
置である場合もあります。未束縛な変数のエラーでは、最後の停止位置は、当該
変数の参照位置からかなり離れている場合があります。そのような場合には、完
全なバックトレースを表示したいでしょう（*Note Edebug Misc::）。

edebugが活性なときに`debug-on-error'や`debug-on-quit'を変更しても、
edebugが不活性になったときにそれらの変更を取り消してしまいます。さらに、
edebugの再帰編集中は、これらの変数はedebugの外側での値に束縛されます。



File: elisp-ja.info, Node: Edebug Views, Next: Edebug Eval, Prev: Trapping Errors, Up: Edebug

edebugのビュー
--------------

これらのedebugのコマンドは、edebugに入るまえのバッファやウィンドウの状態
を調べるものです。外部ウィンドウ構成は、edebugの外側でのウィンドウの集ま
りや内容に関するものです。

`v'
     外部ウィンドウ構成を一時的に見る（`edebug-view-outside'）。

`p'
     edebugの外側でのカレントバッファと外側でのポイント位置を一時的に表
     示する（`edebug-bounce-point'）。前置引数Nは、かわりに休止秒数を指
     定する。

`w'
     ソースコードバッファで現在の停止位置にポイント位置を戻す
     （`edebug-where'）。

     同じバッファを表示している別のウィンドウでこのコマンドを使うと、そ
     れ以後、そのウィンドウに現在の定義が表示されるようになる。

`W'
     edebugが外部ウィンドウ構成を保存／復元するかどうかをトグルする
     （`edebug-toggle-save-windows'）。

     前置引数を指定すると選択したウィンドウだけの保存／復元をトグルする。
     ソースコードバッファを表示していないウィンドウを指定するには、グロー
     バルキーマップの`C-x X W'を使う必要がある。

`v'で外部ウィンドウ構成を見ることができます。あるいは、（edebugの外側で
の）カレントバッファが表示されていなくても`p'でカレントバッファのポイン
ト位置を見ることができます。ポイント位置を移動したら、`w'でソースコード
バッファの停止位置へ戻れます。

外部ウィンドウ構成を保存*しない*ように`W'を使うたびに、edebugは保存して
おいた外部ウィンドウ構成を破棄します。そのため、保存*する*ように戻しても、
（プログラムを続行することで）edebugを抜けると、現在のウィンドウ構成は変
更されません。しかし、`*edebug*'と`*edebug-trace*'の自動再表示は、十分な
ウィンドウが開いてないと、読者が見たいバッファと衝突するかもしれません。



File: elisp-ja.info, Node: Edebug Eval, Next: Eval List, Prev: Edebug Views, Up: Edebug

評価
----

edebugの内側では、edebugが動作していないがごとく式を評価できます。edebug
は、式の評価と表示に対して見えないようにします。edebugが明示的に保存／復
元する場合を除いて、副作用を持つ式の評価も期待どおり動作します。この処理
に関して詳しくは*Note The Outside Context::。

`e EXP RET'
     edebugの外側の文脈で式EXPを評価する（`edebug-eval-expression'）。つ
     まり、edebugは評価への干渉を最小限にとどめようとする。

`M-: EXP RET'
     edebug自身の文脈で式EXPを評価する。

`C-x C-e'
     edebugの外側の文脈でポイント位置のまえの式を評価する
     （`edebug-eval-last-sexp'）。

edebugは`cl.el'（版2.03以降）内の構文`lexical-let'、`macrolet'、
`symbol-macrolet'で作成されるレキシカル（テキスト上の）束縛を参照する式
の評価を扱えます。



File: elisp-ja.info, Node: Eval List, Next: Printing in Edebug, Prev: Edebug Eval, Up: Edebug

評価リストバッファ
------------------

`*edebug*'と呼ばれる"評価リストバッファ"を使って、式を対話的に評価できま
す。さらに、edebugが表示を更新するたびに自動的に評価される式の"評価リス
ト"を設定することもできます。

`E'
     評価リストバッファ`*edebug*'へ切り替える（`edebug-visit-eval-list'）。

バッファ`*edebug*'では、以下の特別なコマンドに加えてlisp対話モード
（*Note lisp対話バッファ: (emacs)Lisp Interaction.）のコマンドも使えます。

`C-j'
     外側の文脈でポイント位置のまえの式を評価し、その値をバッファに挿入
     する（`edebug-eval-print-last-sexp'）。

`C-x C-e'
     edebugの外側の文脈でポイント位置のまえの式を評価する
     （`edebug-eval-last-sexp'）。

`C-c C-u'
     バッファの内容から新たな評価リストを構築する
     （`edebug-update-eval-list'）。

`C-c C-d'
     ポイント位置にある評価リストグループを削除する
     （`edebug-delete-eval-item'）。

`C-c C-w'
     ソースコードバッファに切り替え現在の停止位置に戻る（`edebug-where'）。

`*scratch*'で行うのと同様に、評価リストウィンドウでは`C-j'や`C-x C-e'で
式を評価できますが、それらはedebugの外側の文脈で評価されます。

実行を継続すると、対話的に入力した式（やその結果）は破棄されますが、実行
を停止するたびに評価される式から成る"評価リスト"（evaluation list）を設
定できます。

これを行うには、評価リストバッファにて、1つ以上の"評価リストグループ"
（evaluation list group）を書きます。評価リストグループは、1つ以上のLisp
式から成ります。グループはコメント行で区切ります。

コマンド`C-c C-u'（`edebug-update-eval-list'）は、バッファを走査して各グ
ループの最初の式を使って評価リストを再構築します。（各グループの2番目の
式は計算結果を表示した値とみなす。）

edebugに入るたびに、各式に続けてその現在値をバッファに挿入することで評価
リストを再表示します。このとき、各式がそれぞれグループになるようにコメン
ト行も挿入します。したがって、バッファのテキストを変更せずに再度`C-c
C-u'と打つと、評価リストは実質的には変更されません。

評価リストの評価中にエラーが発生すると、エラーメッセージを評価結果とみな
して文字列で表示します。したがって、現在の文脈では不正な変数を式に使って
も読者のデバッグを遮ることはありません。

評価リストウィンドウに数個の式を追加したときのようすを以下に示します。

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

グループを削除するには、そこへポイントを移動して`C-c C-d'と打ちます。あ
るいは、グループのテキストを単に削除してから`C-c C-u'で評価リストを更新
します。評価リストに新たに式を追加するには、適切な位置に式を挿入し、新た
なコメント行を挿入します。（コメント行にマイナス記号を挿入する必要はない。
コメントの内容は関係ない。）そして、`C-c C-u'と打ちます

`*edebug*'を選択したあとは、`C-c C-w'でソースコードバッファへ戻れます。
読者が実行を継続するとバッファ`*edebug*'は削除され、つぎに必要なときに再
度作成されます。



File: elisp-ja.info, Node: Printing in Edebug, Next: Trace Buffer, Prev: Eval List, Up: Edebug

edebugでの出力
--------------

読者のプログラムの式が循環したリスト構造を含む値を作り出す場合、edebugが
それを出力しようとするとエラーになります。

循環構造を扱う1つの方法は、出力を切り詰めるために`print-length'や
`print-level'を設定することです。edebugが読者のためにこれを行います。そ
れらが`nil'であると、edebugは`print-length'と`print-level'を50に束縛しま
す。（実際は、edebugが使う値は`e-debug-print-length'と
`e-debug-print-level'が指定する。）*Note Output Variables::。

 -- User Option: edebug-print-length
     `nil'以外であると、edebugが結果を出力するときには、これを
     `print-length'に束縛する。デフォルト値は`50'。

 -- User Option: edebug-print-level
     `nil'以外であると、edebugが結果を出力するときには、これを
     `print-level'に束縛する。デフォルト値は`50'。

パッケージ`cust-print'を使えば、循環構造や要素を共有する構造をより的確に
出力することもできます。

`cust-print'をロードしてedebugでのみこの特別な出力を使うようにするには、
単にコマンド`M-x edebug-install-custom-print'を使うだけです。標準の出力
関数に戻すには、`M-x edebug-uninstall-custom-print'を使います。

循環構造を作るコードの例を示します。

     (setq a '(x y))
     (setcar a a)

特別な出力ではこれを`Result: #1=(#1# y)'と出力します。`#1='の記法は、こ
れに続く構造に`1'というラベルを付けます。また、`#1#'の記法はすでにラベル
付けした構造を参照します。この記法は、リストやベクトルの任意の共有された
要素に使われます。

 -- User Option: edebug-print-circle
     `nil'以外であると、edebugが結果を出力するときには、これを
     `print-circle'に束縛する。デフォルト値は`nil'。

他のプログラムでもこの特別な出力を使えます。詳しくは、`cust-print.el'を
参照してください。



File: elisp-ja.info, Node: Trace Buffer, Next: Coverage Testing, Prev: Printing in Edebug, Up: Edebug

トレースバッファ
----------------

edebugは、実行トレースを`*edebug-trace*'というバッファに保存することでそ
れらを記録できます。これは、関数名とそれらの引数、戻り値から成る関数呼び
出しとその戻りの記録です。トレース記録を有効にするには、`edebug-trace'に
`nil'以外の値を設定します。

トレースバッファを作成することとトレース実行モードとは同じではありません
（*Note Edebug Execution Modes::）。

トレース記録を有効にしていると、各関数へ入るときと出るときに、トレースバッ
ファに行が追加されます。関数へ入るときの記録は、`::::{'に関数名と引数値
が続きます。関数から出るときの記録は、`::::}'に関数名とその結果が続きま
す。

入るときの`:'の個数は、再帰の深さを表します。関数呼び出しの対応する開始
や対応する終了を探すためにトレースバッファでは中括弧を使えます。

関数`edebug-print-trace-before'と`edebug-print-trace-after'を再定義すれ
ば、関数へ入ったときと出るときのトレース記録をカスタマイズできます。

 -- Macro: edebug-tracing STRING BODY...
     このマクロはフォームBODYの周りにトレース情報を追加する。引数STRING
     は、トレースバッファに入れるテキストを指定する。すべての引数を評価
     する。`edebug-tracing'はBODYの最後のフォームの値を返す。

 -- Function: edebug-trace FORMAT-STRING &rest FORMAT-ARGS
     この関数はトレースバッファにテキストを挿入する。テキストは`(apply
     'format FORMAT-STRING FORMAT-ARGS)'で計算する。区切りとして改行も挿
     入する。

`edebug-tracing'と`edebug-trace'は、edebugが活性でない場合であっても呼ば
れるとトレースバッファに行を挿入します。トレースバッファにテキストを挿入
するとき、挿入した最後の行が見えるようにウィンドウをスクロールします。



File: elisp-ja.info, Node: Coverage Testing, Next: The Outside Context, Prev: Trace Buffer, Up: Edebug

カバレッジテスト
----------------

edebugでは、初歩的なカバレッジテストや実行頻度を表示できます。

カバレッジテストでは、各式の結果を以前の結果と比較します。現在のEmacsセッ
ションでカバレッジテストを始めて以降、プログラムの各フォームが異なる2つ
の値を返せば、当該フォームを『カバーした』とみなします。したがって、読者
のプログラムについてカバレッジテストを行うには、さまざまな条件でそれを実
行して正しく動作しているか注意します。読者が各フォームが異なる2つの値を
返すように試行し終れば、edebugはそのように通知します。

カバレッジテストは実行速度を遅くするので、`edebug-test-coverage'が`nil'
以外の場合にのみテストします。すべての処置済み関数の実行に関する頻度数計
測は、非停止実行モードであってもカバレッジテストのオン／オフに関わらず行
います。

ある定義に関するカバレッジテストと頻度数計測を表示するには`M-x
edebug-display-freq-count'を使います。

 -- コマンド: edebug-display-freq-count
     このコマンドは、現在の定義の各行について頻度数データを表示する。

     頻度数は、コードの各行のあとにコメント行として表示され、コマンド
     `undo'でそれらのコメント行の挿入をアンドゥできる。頻度数は、式のま
     えの`('や式のうしろの`)'の直下、あるいは、変数の最後の文字に表示さ
     れる。表示を簡素にするために、頻度数が同じ行のまえのほうの式の頻度
     数と同じであると表示しない。

     式の頻度数に続く文字`='は、その式を評価するたびに同じ値を返したこと
     を意味する。いいかえれば、カバレッジテストとしては、その式はまだ
     『カバーして』いないことになる。

     ある定義に関する頻度数計測とカバレッジデータをクリアするには、
     `eval-defun'で単に再処置すればよい。

たとえば、`edebug-test-coverage'を`t'とし、ソース上のブレークポイントを
設定して`(fac 5)'を評価すると、ブレークポイントに達したときの頻度数デー
タはつぎのようになります。

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      0 =5 
       (if (< 0 n)
     ;#5         = 
           (* n (fac (1- n)))
     ;#    5               0  
         1))
     ;#   0 

コメント行は、`fac'が6回呼ばれたことを表します。最初の`if'文は、5回とも
同じ結果を返したのです。2番目の`if'についても同じです。`fac'の再帰呼び出
しは1度も戻っていません。




File: elisp-ja.info, Node: The Outside Context, Next: Instrumenting Macro Calls, Prev: Coverage Testing, Up: Edebug

外側の文脈
----------

edebugは、読者がデバッグ中のプログラムに対しては透過であるように努めます
が、完全にうまくいくとは限りません。また、`e'で読者が式を評価するときや
評価リストバッファでも、外側の文脈を一時的に復元して透過であるように努め
ます。本節では、edebugが復元する文脈について正確に説明し、edebugが透過に
ならない場合についても説明します。

* Menu:

* Checking Whether to Stop::	When Edebug decides what to do.
* Edebug Display Update::	When Edebug updates the display.
* Edebug Recursive Edit::	When Edebug stops execution.



File: elisp-ja.info, Node: Checking Whether to Stop, Next: Edebug Display Update, Prev: The Outside Context, Up: The Outside Context

停止すべきかどうかの検査
........................

edebugに入ると、トレース情報を作るのかプログラムを停止するのかを決定する
まえであってもある種のデータを保存／復元する必要がつねにあります。

   * edebugがスタックに与える影響を軽減するために、`max-lisp-eval-depth'
     と`max-specpdl-size'を一度増加する。しかし、こうしてもedebugを使う
     ときにスタックを使い切ってしまうことがある。

   * キーボードマクロの実行状態を保存し復元する。edebugが活性であると、
     `executing-macro'は`edebug-continue-kbd-macro'に束縛される。





File: elisp-ja.info, Node: Edebug Display Update, Next: Edebug Recursive Edit, Prev: Checking Whether to Stop, Up: The Outside Context

edebugの表示の更新
..................

edebugが（トレースモードなどで）なにかを表示する必要があると、edebugの
『外側』の現在のウィンドウ構成を保存します（*Note Window
Configurations::）。（プログラムを続行して）edebugを抜けるときには、以前
のウィンドウ構成を復元します

Emacsは休止するときにのみ表示を更新します。通常、プログラムを続行しても、
休止したり入力を読むことなくブレークポイントやステップ実行によりedebugへ
戻ります。そのような場合、Emacsには（edebugの）『外側』のようすを再表示
する機会が与えられません。見かけ上、ウィンドウの表示は直前にedebugが活性
であったときと同じになります。

なにかを表示するためにedebugに入っても以下のデータを保存／復元しますが、
エラーや中断が起こると、故意に復元しないものもあります。

   * カレントであるバッファと、そのバッファ内のポイントとマークは保存／
     復元される。

   * `edebug-save-windows'が`nil'以外ならば、外側でのウィンドウ構成を保
     存／復元する（*Note Edebug Display Update::）。

     エラーや中断が起こるとウィンドウ構成は復元されない。しかし、
     `save-excursion'を使っていれば、エラーや中断が起こっても、外側で選
     択していたウィンドウは選択*される*。`edebug-save-windows'の値がリス
     トであると、リストに指定したウィンドウのみを保存／復元する。

     ソースコードバッファのウィンドウ開始位置やスクロールは復元しないが、
     これは、edebug内での表示が統一されるようにするためである。

   * `edebug-save-displayed-buffer-points'が`nil'以外であれば、表示され
     ている各バッファのポイント位置の値を保存／復元する。

   * 変数`overlay-arrow-position'と`overlay-arrow-string'は、保存／復元
     される。そのため、同じバッファで再帰編集からedebugを起動しても安全
     である。

   * カーソルがウィンドウに表示されるように、`cursor-in-echo-area'は
     `nil'にローカルに束縛する。



File: elisp-ja.info, Node: Edebug Recursive Edit, Prev: Edebug Display Update, Up: The Outside Context

edebugの再帰編集
................

edebugに入ってユーザーコマンドを読み取るとき、以下のデータを保存し（のち
に復元し）ます。

   * カレントマッチデータ。*Note Match Data::。

   * `last-command'、`this-command'、`last-command-char'、
     `last-input-char'、`last-input-event'、`last-command-event'、
     `last-event-frame'、`last-nonmenu-event'、`track-mouse'。edebug内で
     使ったコマンドは、edebugの外側でのこれらの変数には影響しない。

     `this-command-keys'が返すキー列はedebug内でコマンドを実行すると変更
     されてしまい、Lispからキー列を設定し直す方法はない。

     edebugは`unread-command-events'の値を保存／復元できない。この変数に
     変な値が入っているときにedebugに入ると、読者がデバッグするプログラ
     ムの実行に干渉することがある。

   * edebug内で実行された複雑なコマンドは変数`command-history'に追加され
     る。これにより実行結果を変更することはほとんどない。

   * edebug内での再帰の深さは、edebugの外側での深さより1だけ深い。自動的
     に更新される評価リストウィンドウではそうではない。

   * `recursive-edit'は`standard-output'と`standard-input'を`nil'に束縛
     するが、edebugは評価中にはそれらを一時的に復元する。

   * キーボードマクロ定義の状態は保存／復元する。edebuが活性であると、
     `defining-kbd-macro'は`edebug-continue-kbd-macro'に束縛される。



File: elisp-ja.info, Node: Instrumenting Macro Calls, Next: Edebug Options, Prev: The Outside Context, Up: Edebug

マクロ呼び出しの処置
--------------------

edebugがLispマクロを呼び出す式を処置するとき、それを正しく行うにはマクロ
に関する余分な情報を必要とします。マクロ呼び出しのどの部分式が評価される
フォームであるかを明確に判定する方法がないからです。（マクロ本体で明示的
に評価されるか、結果の展開形が評価されるときか、あるいは、さらにあと）

したがって、edebugが出会う各マクロについて、当該マクロの呼び出し形式を記
述するedebug用仕様を定義する必要があります。これには、`def-edebug-spec'
を使います。

 -- マクロ: def-edebug-spec MACRO SPECIFICATION
     マクロMACROの呼び出しのどの式が評価されるかを指定する。単純なマクロ
     では、SPECIFICATIONはマクロ定義の仮引数リストに似ているが、その指定
     はマクロ引数よりも汎用性がある。

     引数MACROはマクロ名だけでなく任意のシンボルでよい。

例題マクロ`for'（*Note Argument Evaluation::）のedebug用仕様の等価な定義
例2つを示します。

     (def-edebug-spec for
       (symbolp "from" form "to" form "do" &rest form))

     (def-edebug-spec for
       (symbolp ['from form] ['to form] ['do body]))

SPECIFICATIONに指定するものとその引数の処理方法は次表のとおりです。

`t'
     すべての引数を評価するように処置する。

`0'
     引数はいっさい処置しない。

シンボル
     edebug用仕様を持つシンボルをかわりに使う。この間接参照は別の種類の
     仕様を得るまで繰り返す。これにより、別のマクロから仕様を継承できる。

リスト
     リストの各要素は、呼び出しフォームの引数の型を記述する。仕様リスト
     の各要素については次節で述べる。

* Menu:

* Specification List::		How to specify complex patterns of evaluation.
* Backtracking::		What Edebug does when matching fails.
* Specification Examples::	To help understand specifications.




File: elisp-ja.info, Node: Specification List, Next: Backtracking, Prev: Instrumenting Macro Calls, Up: Instrumenting Macro Calls

仕様リスト
..........

マクロ呼び出しの引数のあるものは評価し別のものは評価しない場合には、
edebug用仕様に"仕様リスト"（specification list）が必要になります。複数の
引数に一致する仕様リストの要素もありますが、後続の要素の処理を修飾する要
素もあります。後者は"仕様キーワード"（specification keyword）と呼ばれ、
（`&optional'のように）`&'で始まるシンボルです。

仕様リストには、それ自体がリストである引数に一致する部分リストやグループ
化に使うベクトルを含んでもかまいません。部分リストやグループは仕様リスト
を階層に分けます。仕様キーワードはそれらを含む部分リストやグループの残り
に適用されます。

仕様リストに選択肢や繰り返しが含まれる場合、実際のマクロ呼び出しに一致さ
せるにはバックトラックが必要な場合もあります。詳しくは*Note
Backtracking::。

edebug用仕様では、正規表現による一致と文脈自由文法の構文を使えます。対応
した括弧に囲まれた部分リスト、フォームの再帰的処理、間接仕様による再帰で
す。

仕様リストの要素に指定できるものとそれらの意味を以下に示します。

`sexp'
     処置しない評価しない1つのLispオブジェクト。

`form'
     処置した評価する1つの式。

`place'
     Common Lispの`setf'構文のように値を格納する場所。

`body'
     `&rest form'の省略形。以下の`&rest'を参照。

`function-form'
     関数フォーム。クォートした関数シンボル、クォートしたラムダ式、ある
     いは、（関数シンボルやラムダ式に評価される）フォーム。これは、ラム
     ダ式である引数が、`function'ではなく`quote'でクォートされるときに有
     用である。というのは、ラムダ式の本体をいずれかの方法で処置するから
     である。

`lambda-expr'
     クォートしていないラムダ式。

`&optional'
     この仕様リスト内の後続の要素すべては省略可能。一致しないと、edebug
     はただちにこのレベルの一致を止める。

     数個の省略可能な要素に省略不可な要素を続けるには、`[&optional
     SPECS...]'を使う。数個の要素がすべて一致するかまったく一致しないこ
     とを指定するには、`&optional [SPECS...]'を使う。以下の`defun'の例を
     参照。

`&rest'
     この仕様リスト内の後続の要素すべてを0回以上繰り返す。最後の繰り返し
     では、仕様リストの要素すべてに一致するまえに式を使い尽くしても問題
     にはならない。

     数個の要素のみを繰り返すには`[&rest SPECS...]'を使う。各繰り返しで
     すべてが一致するような数個の要素を指定するには、`&rest [SPECS...]'
     を使う。

`&or'
     仕様リスト内の後続の各リストは選択肢を表す。選択肢の1つに一致しなけ
     れば、仕様`&or'は失敗。

     `&or'に続く各要素は1つの選択肢を表す。複数の要素を1つの選択肢として
     グループにまとめるには、それらを`[...]'で囲む。

`&not'
     `&or'を使ったかように後続の要素を選択肢として一致させるが、どれかが
     一致すると仕様は失敗。どれにも一致しなければ、仕様`&not'は成功。

`&define'
     仕様は定義フォームに対するものであることを表す。定義フォームそのも
     のは処置しない（つまり、edbugは定義フォームの前後で停止しない）が、
     この内側にあるフォームは典型的には処置される。キーワード`&define'は
     リスト仕様の最初の要素である必要がある。

`nil'
     現在の引数リストのレベルにおいて一致する引数がなければ成功する。さ
     もなければ失敗。部分リスト仕様と以下のバッククォートの例を参照。

`gate'
     いかなる引数とも一致しないが、このゲートを通ると、このレベルの仕様
     の残りの部分と一致を調べる際にはバックトラックを禁止する。これは主
     により詳しい構文エラーメッセージを生成するために使う。詳しくは*Note
     Backtracking::を参照。例については以下の`let'を参照。

`その他のシンボル'
     仕様リストのその他のシンボルは述語であるか間接仕様である。

     シンボルにedebug用仕様があれば、この"間接仕様"は、シンボルのかわり
     に使われる仕様リストであるか、引数を処理するために呼び出される関数
     であること。仕様は、マクロ向けに`def-edebug-spec'で定義した仕様であっ
     てもよい。以下の`defun'の例を参照。

     さもなければ、シンボルは述語であること。述語は引数で呼び出され、述
     語が`nil'を返すと仕様は失敗する。いずれの場合でも、当該引数は処置さ
     れない。

     適当な述語には、`symbolp'、`integerp'、`stringp'、`vectorp'、`atom'
     がある。

`[ELEMENTS...]'
     要素のベクトルは要素群を単一の"グループ仕様"にまとめる。この意味は
     ベクトルの意味とは関係ない。

`"STRING"'
     引数はSTRINGという名前のシンボルであること。この仕様は、SYMBOLの名
     前がSTRINGであるクォートとしたシンボル`'SYMBOL'と等価であるが、文字
     列のほうが望ましい。

`(vector ELEMENTS...)'
     引数は、仕様内のELEMENTSに一致するものを要素とするベクトルであるこ
     と。以下のバッククォートの例を参照。

`(ELEMENTS...)'
     その他のリストは"部分リスト仕様"であり、引数は仕様ELEMENTSに一致す
     るものを要素とするリストであること。

     部分リスト仕様はドット対リストでもよく、その場合、対応するリスト引
     数はドット対リストである。あるいは、ドット対リスト仕様の最後のCDRは
     （`(spec .  [(more specs...)])'などのグループや間接仕様を介した）別
     の部分リスト仕様であってもよいが、それらの要素はドット対ではないリ
     スト引数に一致する。これは、以下のバッククォートの例のような再帰仕
     様に有用である。このような再帰を終らせるうえの仕様`nil'も参照。

     `(specs .  nil)'や`(specs . (sublist-elements...))'のような部分リス
     ト仕様は`(specs sublist-elements...)'と等価であることに注意。


`&define'のうしろに追加できる仕様の一覧を以下に示します。以下の`defun'の
例を参照してください。

`name'
     引数はシンボルであり、定義フォームの名前である。

     定義フォームには単一の名前フィールドがある必要はなく、複数の名前フィー
     ルドを持っていてもよい。

`:name'
     この構造は引数には実際には一致しない。`:name'に続く要素はシンボルで
     あること。定義に対する追加の名前要素として使う。定義の名前に一意で
     静的な要素を追加するために使う。複数あってもよい。

`arg'
     引数はシンボルであり、定義フォームの引数の名前である。しかし、ラム
     ダリストキーワード（`&'で始まるシンボル）は許されない。

`lambda-list'
     ラムダリスト、すなわち、ラムダ式の引数リストに一致する。

`def-body'
     引数は、定義内のコード本体である。これは、上に述べた`body'に似てい
     るが、定義本体は定義に関連した情報を調べる異なるedebug呼び出しで処
     置する必要がある。定義内のフォームの最上位レベルのリストには
     `def-body'を使う。

`def-form'
     引数は、定義内の単一の最上位レベルのフォームである。これは
     `def-body'に似ているが、フォームのリストではなく単一のフォームに一
     致するものに使う。特別な場合として、`def-form'はフォームを実行した
     ときにトレース情報を出力しないことを意味する。以下の`interactive'の
     例を参照。



File: elisp-ja.info, Node: Backtracking, Next: Specification Examples, Prev: Specification List, Up: Instrumenting Macro Calls

仕様内でのバックトラック
........................

仕様の一致がある箇所で失敗しても、必ずしも構文エラーが通知されるとは限り
ません。そのかわりに、選択肢すべてを試し尽くすまで"バックトラック"します。
最終的に、引数リストの各要素は仕様内のいずれかの要素に一致する必要があり、
仕様内の各必須要素はいずれかの引数に一致する必要があります。
  
構文エラーを検出しても、より高いレベルの選択肢を使い切るまでは報告されず、
実際のエラー箇所から離れた箇所にポイントが置かれます。しかし、エラー発生
時にバックトラックが禁止されていれば、ただちにエラーが報告されます。さま
ざまな状況でバックトラックが自動的に再許可されることに注意してください。
`&optional'や`&rest'や`&or'で新たに選択肢が指定されたり、部分リストやグ
ループや間接仕様を処理し始めると、自動的に再許可されます。バックトラック
の許可／禁止の効果は、現在処理しているレベルやそれより低いレベルに限定さ
れます。

任意のフォーム仕様（つまり、`form'、`body'、`def-form'、`def-body'）の一
致処理中には、バックトラックを禁止します。これらの仕様は任意のフォームに
一致するので、エラーはより上のレベルではなくフォーム自身にあるはずです。

また、クォートしたシンボルや文字列の仕様に一致するとバックトラックを禁止
します。というのは、通常、これは構造を認識したことを意味するからです。し
かし、すべてが同一シンボルで始まる選択肢を指定する場合には、`["foo" &or
[first case] [second case] ...]'のように、そのシンボルを選択肢から括り出
せばバックトラックするようにできます。

多くの場合では、バックトラックを自動的に禁止するこれらの2つの方法で十分
ですが、仕様`gate'を使ってバックトラックを明示的に禁止すると有用な場合も
あります。上位の選択肢が適用できないとわかっている場合に有用です。仕様
`let'の例を参照してください。



File: elisp-ja.info, Node: Specification Examples, Prev: Backtracking, Up: Instrumenting Macro Calls

仕様の例
........

以下の例を参考にするとedebug用仕様を理解しやすいでしょう。

スペシャルフォーム`let'には束縛と本体の並びがあります。各束縛は、シンボ
ル、あるいは、シンボルと省略可能な式から成る部分リストです。以下のedebug
用仕様では、部分リストの内側にある`gate'で、部分リストを一度みつけるとバッ
クトラックを禁止していることに注意してください。

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

edebugは、`defun'と`defmacro'、および、対応する引数リストと仕様
`interactive'に対しては、以下のedebug用仕様を使います。式の引数は実際に
は関数本体の外側で評価されるので、対話宣言フォームを特別扱いする必要があ
ります。

     (def-edebug-spec defmacro defun) ; 仕様`defun'の間接参照
     (def-edebug-spec defun 
       (&define name lambda-list 
                [&optional stringp]   ; あれば、説明文字列に一致する
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; `def-form'を参照

以下のバッククォートに対する仕様は、ドット対リストの一致の仕方と再帰を終
らせる`nil'の使い方を示します。また、ベクトルの要素の一致の仕方も示しま
す。（edebugが実際に定義している仕様では、失敗の可能性がある非常に深い再
帰をもたらすためドット対リストを扱わない。）

     (def-edebug-spec ` (backquote-form))   ; わかりやすいように別名を付ける

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))




File: elisp-ja.info, Node: Edebug Options, Prev: Instrumenting Macro Calls, Up: Edebug

edebugのオプション
------------------

以下のオプションはedebugの動作に影響します。

 -- User Option: edebug-setup-hook
     edebugを使うまえに呼び出す関数群。新たな値に設定されるたびに、
     edebugはこれらの関数を呼び出し、そのあとで`edebug-setup-hook'を
     `nil'に再設定する。これを用いて、edebugを使用する場合にのみ、使用す
     るパッケージに対応するedebug用仕様をロードできる。*Note
     Instrumenting::。

 -- User Option: edebug-all-defs
     これが`nil'以外であると、`defun'や`defmacro'のような定義フォームを
     普通に評価すると、edebug用にそれらを処置する。これは、`eval-defun'、
     `eval-region'、`eval-buffer'、`eval-current-buffer'にも適用される。

     このオプションの値をトグルするにはコマンド`M-x edebug-all-defs'を使
     う。*Note Instrumenting::。

 -- User Option: edebug-all-forms
     これが`nil'以外であると、コマンド`eval-defun'、`eval-region'、
     `eval-buffer'、`eval-current-buffer'は、定義しないフォームの場合で
     あってもすべてのフォームを処置する。これは、ロードやミニバッファで
     の評価には適用されない。

     このオプションの値をトグルするにはコマンド`M-x edebug-all-forms'を
     使う。*Note Instrumenting::。

 -- User Option: edebug-save-windows
     これが`nil'以外であると、edebugはウィンドウ構成を保存／復元する。こ
     れには時間がかかるので、読者のプログラムがウィンドウ構成に依存しな
     いのならば、この変数は`nil'に設定しておくほうがよい。

     値がリストであると、リスト内のウィンドウのみを保存／復元する。

     edebugのコマンド`W'を使ってこの変数を対話的に変更できる。*Note
     Edebug Display Update::。

 -- User Option: edebug-save-displayed-buffer-points
     これが`nil'以外であると、edebugは表示されているすべてのバッファのポ
     イントを保存／復元する。

     選択していないウィンドウに表示されたバッファのポイントを変更するコー
     ドをデバッグ中には、別のバッファのポイントを保存／復元する必要があ
     る。edebugやユーザーが当該ウィンドウを選択すると、そのバッファのポ
     イントはウィンドウのポイント位置に移動する。

     すべてのバッファでポイントを保存／復元するには各ウィンドウを2度選択
     する必要があるため手間がかかる。そのため、必要な場合にのみこの機能
     を有効にする。*Note Edebug Display Update::。

 -- User Option: edebug-initial-mode
     この変数が`nil'以外であれば、edebugが初めて動作するときの初期の動作
     モードを指定する。可能な値は、`step'、`next'、`go'、`Go-nonstop',
     `trace'、`Trace-fast'、`continue'、`Continue-fast'。

     デフォルト値は`step'。*Note Edebug Execution Modes::。

 -- User Option: edebug-trace
     `nil'以外であると、関数へ入るときと出るときのトレースを表示すること
     を意味する。トレース出力は、`*edebug-trace*'という名前のバッファに、
     関数へ入るときと出るときを各行に再帰の深さで字下げして表示する。

     デフォルト値は`nil'。

     *Note Trace Buffer::の`edebug-tracing'も参照。

 -- User Option: edebug-test-coverage
     `nil'以外であれば、edebugはデバッグ対象のすべての式のカバレッジテス
     トを行う。*Note Coverage Testing::。

 -- User Option: edebug-continue-kbd-macro
     `nil'以外であれば、edebugの外側で実行するキーボードマクロを定義した
     り実行する。デバッグしないので注意してこのオプションを使うこと。

 -- User Option: edebug-on-error
     `debug-on-error'の以前の値が`nil'であると、edebugは`debug-on-error'
     にこの値を束縛する。*Note Trapping Errors::。

 -- User Option: edebug-on-quit
     `debug-on-quit'の以前の値が`nil'であると、edebugは`debug-on-quit'に
     この値を束縛する。*Note Trapping Errors::。

edebugが動作中に`edebug-on-error'や`edebug-on-quit'の値を変更しても、新
たなコマンドでedebugを*つぎに*起動するまではこれらの値は使用されない。

 -- User Option: edebug-global-break-condition
     `nil'以外であると、各停止位置で検査される式である。結果が`nil'以外
     であるとブレークする。エラーは無視する。*Note Global Break
     Condition::。



File: elisp-ja.info, Node: Syntax Errors, Next: Compilation Errors, Prev: Edebug, Up: Debugging

不正なLisp構文のデバッグ
========================

Lispリーダは不正な構文を報告しますが、どこに問題があるかは報告できません。
たとえば、式を評価中のエラー『End of file during parsing』（構文解析中に
ファイルの終り）は、開き括弧（あるいは開き角括弧）が多すぎることを表しま
す。Lispリーダは括弧が対応していないことをファイルの末尾で検出しますが、
どこに閉じ括弧があるべきかは判断できません。同様に、『Invalid read
syntax: ")"』（不正な構文：")"）は閉じ括弧が多すぎるか開き括弧が足りない
ことを表しますが、どこに括弧が足りないかは判断できません。それでは、どこ
を変更すべきかどのように調べるのでしょう？

問題が単純な括弧の非対応でなければ、各関数定義の先頭で`C-M-e'を試し、関
数定義の末尾に移動するかどうかをみるのは有用な技法です。正しく移動しなけ
れば、その関数に問題があります。

Lispによくある構文エラーは括弧の非対応なので、これらの場面について詳しい
助言を述べておきます。（さらに、対応括弧表示モードをオンにしてポイントを
移動すると非対応を探しやすい。）

* Menu:

* Excess Open::     How to find a spurious open paren or missing close.
* Excess Close::    How to find a spurious close paren or missing open.



File: elisp-ja.info, Node: Excess Open, Next: Excess Close, Prev: Syntax Errors, Up: Syntax Errors

開き括弧の過剰
--------------

最初の手順は、括弧が対応していない関数定義を探すことです。開き括弧が過剰
であれば、ファイルの末尾に閉じ括弧を挿入し`C-M-b'（`backward-sexp'）を打
ちます。こうすると、括弧が対応していない関数定義の先頭へ移動します。（そ
うしたら、`C-SPC C-_ C-u C-SPC'と打って、当該箇所にマークを設定してから
閉じ括弧の挿入を取り消し、最終的にマークへ戻る。）

つぎの手順は、なにが悪いか正確に判断することです。プログラムを調べる以外
にこれを確実に行う方法はありませんが、しばしば、既存の字下げが括弧のあり
かたを予想する鍵になります。これを利用するもっとも簡単な方法は`C-M-q'で
字下げし直し、どのようになるか見ることです。*まだやらないでください！*`
' まず読み進んてください。

これを行うまえに、関数定義に充分な数の閉じ括弧があることを確認してくださ
い。さもないと、`C-M-q'がエラーになったり、ファイルの末尾までを字下げし
直してしまいます。ですから、関数定義の末尾へ移動して閉じ括弧を挿入してお
きます。`C-M-e'を使って移動しないでください。というのは、関数定義の括弧
の対応が取れていないと失敗するからです。

関数定義の先頭へ移動して`C-M-q'を打ちます。通常、ある場所から関数の末尾
までの行が右へずれます。その場所の近くで、閉じ括弧が足りなかったり開き括
弧が多すぎるのです。（しかし、これが正しいと仮定してはならない。コードを
調べて確認すること。）不具合箇所がみつかったならば、意図した括弧に対して
は古い字下げが適しているでしょうから`C-_'で`C-M-q'をアンドゥします。

問題を解決できたと思ったら、再度`C-M-q'を使います。古い字下げが意図した
括弧の入れ子に対応していて、必要な括弧を挿入できているならば、`C-M-q'は
なにも変えないはずです。



File: elisp-ja.info, Node: Excess Close, Prev: Excess Open, Up: Syntax Errors

閉じ括弧の過剰
--------------

過剰な閉じ括弧に対処するには、まず、ファイルの先頭に開き括弧を挿入し、そ
の括弧のまえで`C-M-f'を打って、括弧が対応していない関数定義の末尾を探し
ます。（そして、`C-SPC C-_ C-u C-SPC'と打って、当該箇所にマークを設定し
て開き括弧の挿入をアンドゥし、最終的にマークへ戻る。）

その関数定義の先頭で`C-M-f'と打って、実際に対応している閉じ括弧を探しま
す。これにより、関数定義が終るべき場所より手前の箇所に移動するはずです。
この付近に余分な閉じ括弧がみつかることもあるでしょう。

その場所に問題がなければ、つぎにすべきことは、関数定義の先頭で`C-M-q'と
打つことです。ある範囲の行が左にずれるでしょう。もしそうならば、開き括弧
が足りないか余分な閉じ括弧は、そのような行の先頭付近にあるでしょう。（し
かし、これが正しいと仮定してはならない。コードを調べて確認すること。）不
具合箇所がみつかったならば、意図した括弧に対しては古い字下げが適している
でしょうから`C-_'で`C-M-q'をアンドゥします。

問題を解決できたと思ったら、再度`C-M-q'を使います。古い字下げが意図した
括弧の入れ子に対応していて、必要な括弧を挿入できているならば、`C-M-q'は
なにも変えないはずです。



File: elisp-ja.info, Node: Compilation Errors, Next: Streams Intro, Prev: Syntax Errors, Up: Debugging

コンパイル時の問題のデバッグ
============================

バイトコンパイル時にエラーが発生したときは、通常、読者がコンパイルしてい
るプログラムの不正な構文に原因があります。コンパイラはバッファ
`*Compile-Log*'に適切なエラーメッセージを表示してから停止します。メッセー
ジにはエラーとなった関数の名前があったりなかったりします。いずれにしても、
つぎのようにしてファイルのどこでエラーが生じたかを調べます。

まず、バッファ` *Compiler Input*'に切り替えます。（バッファ名が空白で始
まり、そのため、`M-x list-buffers'では表示されないことに注意。）このバッ
ファにはコンパイルしたプログラムが入っていて、ポイント位置はバイトコンパ
イラがどこまで読み取ったかを表します。

エラーの原因が不正なLisp構文であるならば、ポイント位置が不正構文を*検出
した*箇所を正確に表します。エラー原因が近くにあるとは限りません！` ' エ
ラーを探すために前節の方法を使ってください。

正しく読み取ったフォームのコンパイル中にエラーを検出したときには、ポイン
トはそのフォームの末尾に位置しています。この場合、この方法ではエラー箇所
を正確に判別できませんが、どの関数を確認すべきかを示しています。


File: elisp-ja.info, Node: Read and Print, Next: Minibuffers, Prev: Debugging, Up: Top

Lispオブジェクトの読み取りと表示
********************************

"表示"（printing）とはLispオブジェクトをテキスト表現へ変換する操作であり、
"読み取り"（reading）は逆の変換操作です。これには、*Note Lisp Data
Types::で述べた表示表現と入力構文を用います。

本章では、読み取りや表示を行うLisp関数について述べます。また、（読み取る
ときに）テキストをどこから得たり、（表示するときに）どこへ出すかを指定す
る"ストリーム"（stream）についても述べます。

* Menu:

* Streams Intro::     Overview of streams, reading and printing.
* Input Streams::     Various data types that can be used as input streams.
* Input Functions::   Functions to read Lisp objects from text.
* Output Streams::    Various data types that can be used as output streams.
* Output Functions::  Functions to print Lisp objects as text.
* Output Variables::  Variables that control what the printing functions do.



File: elisp-ja.info, Node: Streams Intro, Next: Input Streams, Prev: Compilation Errors, Up: Read and Print

読み取りと表示の概要
====================

Lispオブジェクトの"読み取り"とは、テキスト表現のLisp式を解析して対応する
Lispオブジェクトを生成することを意味します。これにより、プログラムはLisp
コードのファイルからLispへ取り込まれます。テキストをオブジェクトの"入力
構文"（read syntax）と呼びます。たとえば、テキスト`(a . 5)'は、CARが`a'
でありCDRが数5であるコンスセルの入力構文です。

Lispオブジェクトの"表示"とは、オブジェクトを表現するテキストを生成するこ
とを意味します。つまり、オブジェクトをその"表示表現" （*Note Printed
Representation::）に変換します。上に述べたコンスセルを表示するとテキスト
`(a . 5)'を生成します。

読み取りと表示は、多かれ少なかれ、逆操作です。与えられたテキスト断片を読
み取ることで得られたオブジェクトを表示すると、しばしば、同じテキストを生
成します。オブジェクトを表示することによって得られたテキストを読み取ると、
通常、似たようなオブジェクトを生成します。たとえば、シンボル`foo'を表示
するとテキスト`foo'を生成し、そのテキストを読み取るとシンボル`foo'が返さ
れます。要素が`a'と`b'であるリストを表示するとテキスト`(a b)'を生成し、
そのテキストを読み取ると要素が`a'と`b'である（もとと同じではないが）リス
トを生成します。

しかし、これら2つの操作は厳密には逆操作ではありません。3種類の例外があり
ます。

   * 表示では、読み取れないテキストを生成することがある。たとえば、バッ
     ファ、ウィンドウ、フレーム、サブプロセス、マーカは、`#'で始まるテキ
     ストとして表示されるが、これを読み取ろうとするとエラーになる。これ
     らのデータ型を読み取る方法は存在しない。

   * 1つのオブジェクトには複数のテキスト表現がありえる。たとえば、`1'と
     `01'は同じ整数を表し、`(a b)'と`(a . (b))'は同じリストを表す。読み
     取りではいずれの表現も受け付けるが、表示では1つの表現を選ぶ。

   * オブジェクトを読み取る途中にコメントが現れてもよく、しかも読み取り
     結果にはまったく影響しない。



File: elisp-ja.info, Node: Input Streams, Next: Input Functions, Prev: Streams Intro, Up: Read and Print

入力ストリーム
==============

テキストを読み取るほとんどのLisp関数は、"ストリーム"（stream）を引数とし
て受け付けます。入力ストリームは、読み取るべきテキストの文字をどこからど
のように得るのかを指定します。入力ストリームとして使える型は以下のとおり
です。

BUFFER
     入力文字はバッファBUFFERのポイント直後の文字から読み取られる。1文字
     読むごとにポイントを進める。

MARKER
     入力文字は、マーカMARKERがあるバッファのマーカ直後の文字から読み取
     られる。1文字読むごとにマーカ位置を進める。ストリームがマーカである
     ときには、バッファのポイント位置は影響しない。

STRING
     入力文字は文字列STRINGの先頭文字から必要な文字数だけ読み取られる。

FUNCTION
     入力文字は関数FUNCTIONが生成する。この関数は2種類の呼び出し方を扱え
     る必要がある。

        * 引数なしで呼ばれると、つぎの文字を返す。

        * 1つの（つねに文字である）引数で呼ばれると、FUNCTIONは引数を保
          存し、つぎに呼ばれたときにそれを返すように準備する。これを文字
          の"読み戻し"（unreading）と呼ぶ。これは、Lispリーダが1文字多く
          読みすぎたので『読み取った場所へ戻し』たいときに発生する。この
          とき、FUNCTIONが返す値はなんでもよい。

`t'
     ストリームとして`t'を使うと、ミニバッファから読み取ることを意味する。
     実際には、ミニバッファを表示しユーザーが指定したテキストから成る文
     字列を作り、それを入力ストリームとして使う。

`nil'
     入力ストリームとして`nil'を指定すると、`standard-input'の値をかわり
     に使うことを意味する。その値は"デフォルト入力ストリーム"であり、
     `nil'以外の入力ストリームであること。

SYMBOL
     入力ストリームとしてのシンボルは、そのシンボルの（あれば）関数定義
     と等価である。

バッファであるストリームからの読み取りの例を読み取り前後のポイント位置を
含めて示します。

     ---------- Buffer: foo ----------
     This-!- is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          => is
     (read (get-buffer "foo"))
          => the

     ---------- Buffer: foo ----------
     This is the-!- contents of foo.
     ---------- Buffer: foo ----------

最初の読み取りでは空白を読み飛ばしていることに注意してください。読み取り
では、意味あるテキストのまえにある白文字はいくつでも読み飛ばします。

つぎは、マーカをストリームとして読み取る例です。マーカの初期位置は下に示
したバッファの先頭にあります。読み取った値はシンボル`This'です。


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          => #<marker at 1 in foo>
     (read m)
          => This
     m
          => #<marker at 5 in foo>   ;; 最初の空白の直前

つぎは文字列の内容から読み取ります。

     (read "(When in) the course")
          => (When in)

以下の例は、ミニバッファから読み取ります。
プロンプトは`Lisp expression: 'です。
（ストリーム`t'から読むとつねにこのプロンプトが使われる。）
ユーザーの入力はプロンプトに続けて示してあります。

     (read t)
          => 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 RET
     ---------- Buffer: Minibuffer ----------

最後は、`useless-stream'という名前の関数をストリームにした例です。このス
トリームを使うまえに、変数`useless-list'を文字のリストで初期化します。そ
うすると、関数`useless-stream'を呼び出すたびにリスト内のつぎの文字を返す
か、リストの先頭に追加して文字を読み戻します。

     (setq useless-list (append "XY()" nil))
          => (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          => useless-stream

つぎのようにしてストリームを使って読み取ります。

     (read 'useless-stream)
          => XY

     useless-list
          => (40 41)

リストには開き括弧と閉じ括弧が残っていることに注意してください。Lispリー
ダが開き括弧に出会うとこれで入力を終えると決定し、それを読み戻すのです。
この時点で読み取りを試みると、`()'を読み取って`nil'を返します。

 -- Function: get-file-char
     この関数は、関数`load'で開いた入力ファイルから読み取るための入力ス
     トリームとして内部的に使われる。読者はこの関数を使ってはならない。



File: elisp-ja.info, Node: Input Functions, Next: Output Streams, Prev: Input Streams, Up: Read and Print

入力関数
========

本節では読み取りに関係するLisp関数や変数について述べます。

以下の関数では、STREAMは入力ストリーム（前節参照）を表します。STREAMが
`nil'であったり省略すると、`standard-input'の値をデフォルトにします。

読み取り中に閉じていないリストやベクトル、文字列に出会うと、エラー
`end-of-file'を通知します。

 -- Function: read &optional STREAM
     この関数はSTREAMから1つのLisp式のテキスト表現を読み取り、それをLisp
     オブジェクトとして返す。これは基本的なLisp入力関数である。

 -- Function: read-from-string STRING &optional START END
     この関数はSTRINGのテキストから先頭のLisp式のテキスト表現を読み取る。
     読み取った式をCAR、文字列に残っているつぎの文字（つまり読み取ってい
     ない最初の文字）の位置を表す整数をCDR とするコンスセルを返す。

     STARTが指定してあると、文字列のSTARTで添字付け（先頭文字の添字は0）
     されるところから読み始める。ENDを指定すると、その添字位置の直前で読
     み取りを終らせ、文字列には残りの文字がないかのように扱う。

     例：

          (read-from-string "(setq x 55) (setq y 5)")
               => ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               => ("A short string" . 16)

          ;; 最初の文字から読み始める
          (read-from-string "(list 112)" 0)
               => ((list 112) . 10)
          ;; 2番目の文字から読み始める
          (read-from-string "(list 112)" 1)
               => (list . 5)
          ;; 7番目の文字から読み始め、9番目の文字で読み終える
          (read-from-string "(list 112)" 6 8)
               => (11 . 8)

 -- Variable: standard-input
     この変数はデフォルトの入力ストリーム、つまり、引数STREAMが`nil'であ
     る場合に`read'が使うストリームを保持する。



File: elisp-ja.info, Node: Output Streams, Next: Output Functions, Prev: Input Functions, Up: Read and Print

出力ストリーム
==============

出力ストリームは表示で生成した文字群をどのように扱うかを指定します。ほと
んどの表示関数は省略可能な引数として出力ストリームを受け付けます。出力ス
トリームとして使える型は以下のとおりです。

BUFFER
     出力文字はバッファBUFFERのポイント位置に挿入される。文字が挿入され
     るたびにポイント位置は進められる。

MARKER
     出力文字はマーカMARKERがあるバッファのマーカ位置に挿入される。文字
     を挿入するたびにマーカ位置は進められる。ストリームがマーカであると
     きには、バッファのポイント位置は影響せず、この種の表示ではポイント
     を移動しない。

FUNCTION
     出力文字は関数FUNCTIONに渡され、この関数が文字の保存に責任を持つ。1
     つの文字を引数として出力する文字数の回数だけ呼び出され、読者の望む
     場所に文字を保存する責任を持つ。

`t'
     出力文字はエコー領域に表示される。

`nil'
     出力ストリームとして`nil'を指定すると、`standard-output'の値をかわ
     りに使うことを意味する。その値は"デフォルト出力ストリーム"であり、
     `nil'以外であること。

SYMBOL
     出力ストリームとしてのシンボルは、そのシンボルの（あれば）関数定義
     と等価である。

正当な出力ストリームの多くは、入力ストリームとしても正当です。入力ストリー
ムと出力ストリームの違いは、オブジェクト型の違いというよりは、読者がLisp
オブジェクトをどのように使うかです。

バッファを出力ストリームとして使った例を示します。ポイントの初期位置は以
下に示すように`the'の`h'の直前にあります。終了後でも、ポイントは同じ`h'
の直前に位置しています。

     ---------- Buffer: foo ----------
     This is t-!-he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          => "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     -!-he contents of foo.
     ---------- Buffer: foo ----------

つぎは、マーカを出力ストリームとして用いた例です。バッファ`foo'のマーカ
の初期位置は、単語`the'の`t'と`h'のあいだにあります。終了後には、マーカ
は挿入したテキストを越えて同じ`h'の直前に位置します。ポイント位置はなん
の影響もないことに注意してください。

     ---------- Buffer: foo ----------
     This is the -!-output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          => #<marker at 10 in foo>

     (print "More output for foo." m)
          => "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he -!-output
     ---------- Buffer: foo ----------

     m
          => #<marker at 34 in foo>

つぎは、エコー領域への出力の例です。

     (print "Echo Area output" t)
          => "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

最後は、関数を出力ストリームとして使った例を示します。関数`eat-output'は
与えられた文字を受け取り、それをリスト`last-output'の先頭にコンスします
（*Note Building Lists::）。終了後には、リストがすべての出力文字を保持し
ていますが逆順です。

     (setq last-output nil)
          => nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          => eat-output

     (print "This is the output" 'eat-output)
          => "This is the output"

     last-output
          => (10 34 116 117 112 116 117 111 32 101 104 
         116 32 115 105 32 115 105 104 84 34 10)

リストの順番を逆にすれば正しい順序の出力になります。

     (concat (nreverse last-output))
          => "
     \"This is the output\"
     "

`concat'を呼び出してリストを文字列に変換し、内容を読みやすいようにしまし
た。



File: elisp-ja.info, Node: Output Functions, Next: Output Variables, Prev: Output Streams, Up: Read and Print

出力関数
========

本節ではLispオブジェクトを表示する、つまり、オブジェクトを表示表現に変換
するLisp関数について述べます。

Emacsの表示関数のなかには、正しく読み取れるようにクォート文字を出力に追
加するものがあります。使用されるクォート文字は`"'と`\'です。これらは、文
字列とシンボルを区別したり、文字列やシンボル内の句読点文字を読み取るとき
に区切り文字として扱うことを防ぎます。詳しくは*Note Printed
Representation::。出力関数を選べば、クォートのありなしを指定できます。

テキストをLispシステムへ読み取る意図がある場合には、曖昧さを避けるために
クォート文字付きで表示するべきです。Lispプログラマに対してLispオブジェク
トを明確に記述する場合も同様です。しかし、人間向けの見やすい出力が目的で
あれば、クォートせずに表示するのが普通はよいでしょう。

Lispオブジェクトはそれ自身を参照できます。自己参照しているオブジェクトを
普通の方法で表示するには無限のテキストが必要であり、そのような試みは無限
再帰をもたらします。Emacsはそのような再帰を検出し、すでに表示したオブジェ
クトを再帰的に表示するかわりに`#LEVEL'を表示します。たとえば、`#0'は、現
在の表示操作においてレベル0のオブジェクトを再帰的に参照することを示しま
す。

     (setq foo (list nil))
          => (nil)
     (setcar foo foo)
          => (#0)

以下の関数では、STREAMは出力ストリームを表します。（出力ストリームについ
ては前節を参照。）STREAMが`nil'であったり省略すると、`standard-output'の
値をデフォルトにします。

 -- Function: print OBJECT &optional STREAM
     関数`print'は便利な表示方法である。オブジェクトOBJECTの表示表現をス
     トリームSTREAMに出力し、OBJECTの前後に改行を1つずつ表示する。クォー
     ト文字を使う。`print'はOBJECTを返す。たとえばつぎのとおり。

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               -| 
               -| The\ cat\ in
               -| 
               -| "the hat"
               -| 
               -| " came back"
               -| 
               => " came back"

 -- Function: prin1 OBJECT &optional STREAM
     この関数はオブジェクトOBJECTの表示表現をストリームSTREAMに出力する。
     `print'のようには出力を区切る改行を表示しないが、`print'と同様にクォー
     ト文字を用いる。OBJECTを返す。

          (progn (prin1 'The\ cat\ in) 
                 (prin1 "the hat") 
                 (prin1 " came back"))
               -| The\ cat\ in"the hat"" came back"
               => " came back"

 -- Function: princ OBJECT &optional STREAM
     この関数はオブジェクトOBJECTの表示表現をストリームSTREAMに出力する。
     OBJECTを返す。

     この関数は、`read'ではなく人が読みやすい出力を意図しており、クォー
     ト文字を挿入せず、文字列を囲むダブルクォートも出力しない。空白も追
     加しない。

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               -| The cat in the "hat"
               => " in the \"hat\""

 -- Function: terpri &optional STREAM
     この関数はストリームSTREAMに改行を出力する。関数名は『terminate
     print』の略。

 -- Function: write-char CHARACTER &optional STREAM
     この関数は文字CHARACTERをストリームSTREAMへ出力する。CHARACTERを返
     す。

 -- Function: prin1-to-string OBJECT &optional NOESCAPE
     この関数は同じ引数に対して`prin1'が表示するであろうテキストから成る
     文字列を返す。

          (prin1-to-string 'foo)
               => "foo"
          (prin1-to-string (mark-marker))
               => "#<marker at 2773 in strings.texi>"

     NOESCAPEが`nil'以外であると、出力にはクォート文字を使わない。（この
     引数は、Emacs 19版以降で使える。）

          (prin1-to-string "foo")
               => "\"foo\""
          (prin1-to-string "foo" t)
               => "foo"

     文字列としてのLispオブジェクトの表示表現を得るための別の方法につい
     ては、*Note String Conversion::の`format'を参照。

 -- Macro: with-output-to-string BODY...
     このマクロは、`standard-output'を文字列への出力と設定してフォーム
     BODYを実行する。そして、その文字列を返す。

     たとえば、カレントバッファの名前が`foo'であると

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))

     は`"The buffer is foo"'を返す。



File: elisp-ja.info, Node: Output Variables, Prev: Output Functions, Up: Read and Print

出力に影響する変数
==================

 -- Variable: standard-output
     この変数の値はデフォルトの出力ストリーム、つまり、引数STREAMが`nil'
     の場合に表示関数が用いるストリーム。

 -- Variable: print-escape-newlines
     この変数が`nil'以外であると、文字列内の改行文字を`\n'、ページ送り文
     字を`\f'と表示する。通常、これらの文字は実際の改行やページ送りとし
     て表示される。

     この変数は、クォート付きで表示する表示関数`prin1'や`print'に影響を
     与える。`princ'には影響しない。`prin1'を用いた例を示す。

          (prin1 "a\nb")
               -| "a
               -| b"
               => "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               -| "a\nb"
               => "a
          b"

     2番目の式では、`prin1'の呼び出し中には`print-escape-newlines'のロー
     カル束縛が有効であるが、結果を表示するときには有効ではない。

 -- Variable: print-escape-nonascii
     この変数が`nil'以外であると、クォート付きで表示する出力関数`prin1'
     や`print'は、文字列内のユニバイト非ASCII文字を無条件でバックスラッ
     シュ列として表示する。

     これらの関数は、出力ストリームがマルチバイトバッファやマルチバイト
     バッファのマーク位置であると、この変数の値に関係なくユニバイト非
     ASCII文字に対してバックスラッシュ列を用いる。

 -- Variable: print-escape-multibyte
     この変数が`nil'以外であると、クォート付きで表示する表示関数`prin1'
     や`print'は、文字列内のマルチバイト非ASCII文字を無条件でバックスラッ
     シュ列として表示する。

     これらの関数は、出力ストリームがユニバイトバッファやユニバイトバッ
     ファのマーク位置であると、この変数の値に関係なくマルチバイト非ASCII
     文字に対してバックスラッシュ列を用いる。

 -- Variable: print-length
     この変数の値は、任意のリスト、ベクトル、ブールベクトルを表示すると
     きの最大要素数である。表示するオブジェクトがこれより多くの要素を持
     つと、「…」で省略する。

     値が`nil'（デフォルト）であると無制限。

          (setq print-length 2)
               => 2
          (print '(1 2 3 4 5))
               -| (1 2 ...)
               => (1 2 ...)

 -- Variable: print-level
     この変数の値は、表示するときの括弧や角括弧の入れ子の最大の深さ。こ
     の制限を越える任意のリストやベクトルは「…」で省略する。値が`nil'
     （デフォルト）であると無制限。


File: elisp-ja.info, Node: Minibuffers, Next: Command Loop, Prev: Read and Print, Up: Top

ミニバッファ
************

"ミニバッファ"（minibuffer）は、単純な数値前置引数ではなく、より複雑な引
数を読み取るためにEmacsのコマンドが使う特別なバッファです。これらの引数
には、ファイル名、バッファ名、（`M-x'での）コマンド名があります。ミニバッ
ファは、エコー領域と同様に、フレームの最下行に表示されますが、引数を読み
取るときにのみ表示されます。

* Menu:

* Intro to Minibuffers::      Basic information about minibuffers.
* Text from Minibuffer::      How to read a straight text string.
* Object from Minibuffer::    How to read a Lisp object or expression.
* Minibuffer History::	      Recording previous minibuffer inputs
				so the user can reuse them.
* Completion::                How to invoke and customize completion.
* Yes-or-No Queries::         Asking a question with a simple answer.
* Multiple Queries::	      Asking a series of similar questions.
* Reading a Password::	      Reading a password from the terminal.
* Minibuffer Misc::           Various customization hooks and variables.



File: elisp-ja.info, Node: Intro to Minibuffers, Next: Text from Minibuffer, Prev: Minibuffers, Up: Minibuffers

ミニバッファの紹介
==================

ほとんどの意味において、ミニバッファはEmacsの普通のバッファです。
編集コマンドなどのバッファ*内*でのほとんどの操作は、
ミニバッファでも普通に動作します。
しかし、バッファを操作するコマンドの多くは、
ミニバッファには適用できません。
ミニバッファの名前はつねに`*Minibuf-NUMBER'という形式であって、
変更できません。
ミニバッファはミニバッファ専用の特別なウィンドウだけに表示されます。
これらのウィンドウはつねにフレームの最下行に現れます。
（ミニバッファを持たないフレームや、
ミニバッファ用ウィンドウのみの特殊なフレームもある。
*Note Minibuffers and Frames::を参照。）

ミニバッファ用のウィンドウは通常は1行だけです。ウィンドウサイズを変更す
るコマンドで一時的に大きさを変えられますが、ミニバッファから抜けると通常
サイズに戻ります。ミニバッファ用ウィンドウのサイズを恒久的に変更するには、
ミニバッファを使っていないときに、フレームの別のウィンドウにおいてウィン
ドウサイズを変更するコマンドを使います。ミニバッファだけを持つフレームの
場合、フレームのサイズを変更すればミニバッファのサイズを変更できます。

すでにミニバッファが活性であるときにコマンドがミニバッファを使用することを
"再帰ミニバッファ"と呼びます。
最初のミニバッファの名前は` *Minibuf-0*'です。
再帰ミニバッファは、名前の最後の数を増やして命名します。
（名前は空白で始まるため、通常のバッファの一覧には表示されない。）
再帰ミニバッファの中で、もっとも内側の（つまりもっとも再帰が深い）ものが
活性なミニバッファです。
これを単にミニバッファと呼びます。
変数`enable-recursive-minibuffers'を設定すれば、
再帰ミニバッファを許可したり禁止できます。
あるいは、コマンドシンボルにこの名前の属性を入れます
（*Note Minibuffer Misc::）。

他のバッファと同様に、ミニバッファは複数のローカルキーマップ（*Note
Keymaps::）を使うことがあります。これらには、さまざまな終了コマンドや補
完コマンド（*Note Completion::）が含まれます。

   * `minibuffer-local-map'は（補完なしの）普通の入力用。

   * `minibuffer-local-ns-map'も同様だが、RETと同様にSPCで抜ける。これは
     主にMocklisp互換用に使われる。

   * `minibuffer-local-completion-map'は弱い補完用。

   * `minibuffer-local-completion-map'は強い補完や慎重な補完用。



File: elisp-ja.info, Node: Text from Minibuffer, Next: Object from Minibuffer, Prev: Intro to Minibuffers, Up: Minibuffers

ミニバッファでのテキスト文字列の読み取り
========================================

多くの場合、テキストを文字列として読み取るためにミニバッファを使います。
Lispオブジェクトのテキスト表現を読み取るためにも使えます。ミニバッファで
の入力のもっとも基本的な関数は`read-from-minibuffer'であり、どちらの目的
にも使えます。

多くの場合、Lisp関数の途中でミニバッファの入力関数を呼ぶべきではありませ
ん。そのかわりに、`interactive'の指定で、コマンドの引数を読み取る操作の
一部としてすべてのミニバッファ入力を行います。*Note Defining Commands::。

 -- Function: read-from-minibuffer PROMPT-STRING &optional INITIAL-CONTENTS KEYMAP READ HIST DEFAULT INHERIT-INPUT-METHOD
     この関数は、ミニバッファから入力を得るもっとも汎用の方法である。デ
     フォルトでは、任意のテキストを受け取り文字列として返す。しかし、
     READが`nil'以外であれば、`read'を用いてテキストをLispオブジェクトへ
     変換する（*Note Input Functions::）。

     この関数がまず行うことは、ミニバッファを活性にし、プロンプト
     PROMPT-STRINGとともに表示することである。PROMPT-STRINGは文字列であ
     ること。これで、ユーザーはミニバッファでテキストを編集できるように
     なる。

     ユーザーがミニバッファを抜けるコマンドを打つと、
     `read-from-minibuffer'はミニバッファ内のテキストから戻り値を構築す
     る。通常、当該テキストを含む文字列を返す。しかし、READが`nil'以外で
     あると、`read-from-minibuffer'はテキストを読み取った結果であるLisp
     オブジェクトを評価せずに返す。（読み取りについては*Note Input
     Functions::。）

     引数DEFAULTは、履歴コマンドで使うデフォルト値を指定する。これは文字
     列か`nil'であること。READが`nil'以外である場合、ユーザーの入力が空
     であるときには、`read'への入力としてもDEFAULTを用いる。しかし、
     （READが`nil'である）通常の場合、ユーザーの入力が空のとき、
     `read-from-minibuffer'はDEFAULTを返さずに空文字列`""'を返す。この意
     味において、この関数は本章の他のミニバッファ用入力関数と異なる。

     KEYMAPが`nil'以外であると、ミニバッファのローカルキーマップとして用
     いる。KEYMAPを省略したり`nil'であると、`minibuffer-local-map'の値を
     キーマップとして用いる。キーマップを指定することは、補完などのさま
     ざまな応用向けにミニバッファをカスタマイズするもっとも重要な方法で
     ある。

     引数HISTは、ミニバッファでの入力を保存し履歴コマンドを使用可能にす
     るために用いる履歴リスト変数を指定する。デフォルトは
     `minibuffer-history'である。*Note Minibuffer History::。

     変数`minibuffer-allow-text-properties'が`nil'以外であると、返される
     文字列には、ミニバッファで指定されたテキスト属性が含まれる。さもな
     ければ、値を返すときにすべてのテキスト属性を取り除く。

     引数INHERIT-INPUT-METHODが`nil'以外であると、ミニバッファに入るまえ
     にどのバッファにいたかに関わらず、そのバッファから現在の入力方式
     （*Note Input Methods::）と`enable-multibyte-characters'（*Note
     Text Representations::）の設定を継承する。

     INITIAL-CONTENTSが文字列であれば、`read-from-minibuffer'は、ユーザー
     がテキスト編集を始めるまえに、この文字列をミニバッファに挿入しその
     末尾にポイントを置く。この文字列を初期内容とするミニバッファが現れ
     る。

     あるいは、INITIAL-CONTENTSは、`(STRING . POSITION)'という形式のコン
     スセルでもよい。これは、文字列STRINGをミニバッファに挿入し、ポイン
     トは末尾にではなく先頭からPOSITION番目の文字に置くことを意味する。

     *使用上の注意：*` ' 引数INITIAL-CONTENTSとDEFAULTは、多かれ少なかれ
     同じことを行う代替方法を提供する。`read-from-minibuffer'の1つの呼び
     出しにおいて、両者の機能を同時に使うことに意味はない。一般には、
     DEFAULTを使うことを勧める。というのは、ユーザーがデフォルト値を望む
     場合にはデフォルト値を挿入でき、それ以外の場合にはデフォルト値を削
     除しなくてもよいからである。

 -- Function: read-string PROMPT &optional INITIAL HISTORY DEFAULT INHERIT-INPUT-METHOD
     この関数はミニバッファから文字列を読み取り、それを返す。引数PROMPT
     とINITIALは、`read-from-minibuffer'と同様に使われる。使用するキーマッ
     プは`minibuffer-local-map'である。

     省略可能な引数HISTORYは、`nil'以外であると、履歴リストと（省略可能
     な）リスト内での初期位置を指定する。省略可能な引数DEFAULTは、ユーザー
     入力が空の場合に返されるデフォルト値であり、文字列であること。省略
     可能な引数INHERIT-INPUT-METHODは、カレントバッファの入力方式を継承
     するかどうかを指定する。

     この関数は関数`read-from-minibuffer'のインターフェイスを単純化した
     ものである。

          (read-string PROMPT INITIAL HISTORY DEFAULT INHERIT)
          ==
          (let ((value
                 (read-from-minibuffer PROMPT INITIAL nil nil
                                       HISTORY DEFAULT INHERIT)))
            (if (equal value "")
                DEFAULT
              value))

 -- Variable: minibuffer-allow-text-properties
     この変数が`nil'であると、`read-from-minibuffer'はミニバッファで指定
     されたすべてのテキスト属性を返すまえに取り除く。すべてのミニバッファ
     が`read-from-minibuffer'を使うので、この変数はすべてのミニバッファ
     入力に適用される。

     この変数の値に関わらず、補完関数は無条件にテキスト属性を廃棄するこ
     とに注意。

 -- Variable: minibuffer-local-map
     ミニバッファから読み取るときのデフォルトのローカルキーマップ。デフォ
     ルトでは、以下のバインディングである。

     `C-j'
          `exit-minibuffer'

     RET
          `exit-minibuffer'

     `C-g'
          `abort-recursive-edit'

     `M-n'
          `next-history-element'

     `M-p'
          `previous-history-element'

     `M-r'
          `next-matching-history-element'

     `M-s'
          `previous-matching-history-element'

 -- Function: read-no-blanks-input PROMPT &optional INITIAL INHERIT-INPUT-METHOD
     この関数はミニバッファから文字列を読み取るが、入力には白文字を許さ
     ず、白文字は入力を終らせる。引数PROMPT、INITIAL、
     INHERIT-INPUT-METHODは、`read-from-minibuffer'と同様に使われる。

     これは関数`read-from-minibuffer'のインターフェイスを単純化したもの
     であり、引数KEYMAPとして`minibuffer-local-ns-map'の値を渡す。キーマッ
     プ`minibuffer-local-ns-map'では`C-q'を再バインドしないため、クォー
     トすれば空白を文字列に含めることが*できる*。

          (read-no-blanks-input PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map)

 -- Variable: minibuffer-local-ns-map
     この組み込み変数は、関数`read-no-blanks-input'がミニバッファ用のロー
     カルキーマップとして使うキーマップである。デフォルトでは、
     `minibuffer-local-map'のバインディングに加えて以下のバインディング
     である。

     SPC
          `exit-minibuffer'

     TAB
          `exit-minibuffer'

     `?'
          `self-insert-and-exit'



File: elisp-ja.info, Node: Object from Minibuffer, Next: Minibuffer History, Prev: Text from Minibuffer, Up: Minibuffers

ミニバッファでのLispオブジェクトの読み取り
==========================================

本節では、ミニバッファでLispオブジェクトを読み取る関数について述べます。

 -- Function: read-minibuffer PROMPT &optional INITIAL
     この関数はミニバッファを用いてLispオブジェクトを読み取り、それを評
     価せずに返す。引数PROMPTとINITIALは、`read-from-minibuffer'と同様に
     使われる。

     これは関数`read-from-minibuffer'のインターフェイスを単純化したもの
     である。

          (read-minibuffer PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL nil t)

     初期入力として文字列`"(testing)"'を与えた例を示す。

          (read-minibuffer
           "Enter an expression: " (format "%s" '(testing)))

          ;; 以下のようにミニバッファが表示される

          ---------- Buffer: Minibuffer ----------
          Enter an expression: (testing)-!-
          ---------- Buffer: Minibuffer ----------

     デフォルトとして初期入力を使うには、ユーザーはただちにRETを打てばよ
     い。あるいは、入力を編集する。

 -- Function: eval-minibuffer PROMPT &optional INITIAL
     この関数はミニバッファを用いてLisp式を読み取り、それを評価してその
     結果を返す。引数PROMPTとINITIALは、`read-from-minibuffer'と同様に使
     われる。

     この関数は`read-from-minibuffer'のインターフェイスを単純化したもの
     である。

          (eval-minibuffer PROMPT INITIAL)
          ==
          (eval (read-minibuffer PROMPT INITIAL))

 -- Function: edit-and-eval-command PROMPT FORM
     この関数はミニバッファを用いてLisp式を読み取り、それを評価する。こ
     のコマンドと`eval-minibuffer'との違いは、初期フォームFORMを省略でき
     ないことであり、このフォームをテキスト文字列としではなく表示表現に
     変換するLispオブジェクトとして扱うことである。`prin1'を用いて表示す
     るので、これが文字列であると初期テキストにはダブルクォート文字（`"'）
     が現れる。*Note Output Functions::。

     `edit-and-eval-command'はまず、PROMPTをプロンプトとしてミニバッファ
     を活性にする。続いて、ミニバッファにFORMの表示表現を挿入し、ユーザー
     に編集させる。ユーザーがミニバッファから抜けると、編集後のテキスト
     を`read'で読み取り評価する。評価結果が`edit-and-eval-command'の値に
     なる。

     以下の例では、すでに正しいフォームである初期テキストの式をユーザー
     に提示する。

          (edit-and-eval-command "Please edit: " '(forward-word 1))

          ;; 上の式を評価後には、ミニバッファは以下のようになる 

          ---------- Buffer: Minibuffer ----------
          Please edit: (forward-word 1)-!-
          ---------- Buffer: Minibuffer ----------

     ただちにRETを打つと、ミニバッファから抜けて式を評価するので、ポイン
     トを1単語分先へ進めることになる。この例では、
     `edit-and-eval-command'は`nil'を返す。



