Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Date Formats, Next: Adding to Diary, Prev: Format of Diary File, Up: Diary

日付指定の形式
--------------

以下は日誌項目の例で、使用可能ないくつかの日付指定形式を示しています。
この例では日付をアメリカ形式（月、日、年）で指定していますが、カレンダー
（calendar）モードではオプションでヨーロッパ形式（日、月、年）も使用で
きます。

     4/20/93  新しい計算システムへ切換
     apr. 25  年ごとの計算開始 
     4/30     4月分の処理完了〆切
     */25     月ごとのサイクル完了
     Friday   ファイルのバックアップを忘れないこと

最初の項目は1993年4月20日に一度だけ表示されます。2番目と3番目は毎年指
定した日付に表示され、4番目は月の指定にワイルドカード（アスタリスク、
`*'）を使っているため、毎月25日に表示されます。最後の項目は毎週金曜日
に表示されます。

日付には、`MONTH/DAY'や`MONTH/DAY/YEAR'のように数字だけを使ってもかま
いません。この場合、あとに続く文字は数字であってはいけません。日付自体
のMONTH（月）とDAY（日）は1桁か2桁の数字です。YEAR（年）は省いてもかま
いませんが、これも数字で、最後の2桁だけに省略してもかまいません。つま
り、`11/12/1989'と書いても`11/12/89'と書いても同じです。

日付を、`MONTHNAME DAY'や`MONTHNAME DAY, YEAR'と書くこともできます。こ
こで、MONTHNAMEは英語の月の名前で3文字の省略形（ピリオドがあってもなく
てもよい）でもかまいません。大文字小文字は区別しません。

日付の指定は"総称的"であってもかまいません。つまり、特定しない部分があっ
てもかまいません。そうすると、その指定に一致するすべての日付にその項目
が適用されます。年を指定しなければ、それは総称的であり、その項目は毎年
に適用されます。あるいは、MONTH、DAY、YEARのそれぞれに`*'を指定できま
す。これは、それぞれ、任意の月、任意の日、任意の年に一致します。したがっ
て、`3/*/*'という日誌項目は、任意の年の3月のどの日にも一致します。
`march *'も同じことです。

もし、月のまえに日を書くヨーロッパ形式で日付を指定したいときには、カレ
ンダー中で`M-x european-calendar'と打ちます。あるいは、カレンダー／日
誌コマンドを使う*まえ*に変数`european-calendar-style'に`t'を設定します。
この状態では、日誌の中のすべての日付指定をヨーロッパ形式で解釈します。
また、日誌の日付を表示するときもヨーロッパ形式です。（ヨーロッパ形式で
は、MONTHNAMEのあとにはコンマは付けない。）（デフォルトの）アメリカ形
式の日付に戻るには、`M-x american-calendar'と打ちます。

ある曜日を指定する総称的な日付として曜日の名前を使えます。曜日の名前は
英語で綴り、3文字の省略形（ピリオドがあってもなくてもよい）でもかまい
ません。大文字小文字は問いません。



File: emacs-ja.info, Node: Adding to Diary, Next: Special Diary Entries, Prev: Date Formats, Up: Diary

日誌への追加コマンド
--------------------

カレンダー（calendar）モードの中には、日誌の項目を作成するコマンドがい
くつかあります。

`i d'
     選択した日に日誌項目を追加する（`insert-diary-entry'）。
`i w'
     選択した曜日に日誌項目を追加する（`insert-weekly-diary-entry'）。
`i m'
     選択した月の日に日誌項目を追加する（`insert-monthly-diary-entry'）。
`i y'
     選択した年の日に日誌項目を追加する（`insert-yearly-diary-entry'）。

カレンダーウィンドウ内で日を選択して`i d'コマンドを打てば、選択した日
に日誌項目を作成できます。このコマンドは、別のウィンドウに日誌ファイル
の末尾を表示し、日付を挿入します。そうしたら、日誌項目の残りの部分を打
ち込みます。

特定の曜日に日誌項目を作成したい場合には、その曜日を選択して（どの場所
でもよい）`i w'と打ちます。これで、総称的な日付として曜日名が挿入され
ます。そうしたら、日誌項目の残りの部分を打ち込みます。同様にして、月の
特定の日を選択してから`i m'コマンドを打って、項目の残りの部分を打ち込
みます。同じように、`i y'コマンドで、毎年の特定の日に項目を挿入できま
す。

これらのコマンドはすべて、デフォルトでは印付けされる項目を作成します。
印付け禁止の項目を作成するには、コマンドに数引数を指定します。たとえば、
`C-u i w'は毎週の印付け禁止項目を作ります。

日誌ファイルを修正したときには、Emacsを終了するまえにファイルを必ず保
存してください。



File: emacs-ja.info, Node: Special Diary Entries, Prev: Adding to Diary, Up: Diary

特別な日誌項目
--------------

カレンダーの日付に基づいて項目を追加する以外に、毎年の記念日などを表す
"S式項目"（sexp entries）を日誌ファイルに入れることができます。これら
の項目は、Emacsが日誌ファイルを読み込むときにLisp式（S式、sexp）を評価
することに基づいています。S式項目では日付のかわりに、`%%'に続けて括弧
で括ったLisp式があります。Lisp式が項目を適用する日付を決定します。

カレンダー（calendar）モードには、よく使われるS式項目を追加するコマン
ドがあります。

`i a'
     指定した日付の毎年の記念日の日誌項目を追加する
     （`insert-anniversary-diary-entry'）。
`i b'
     カレントリージョンに対してブロック日誌項目を追加する
     （`insert-block-diary-entry'）。
`i c'
     指定した日から始まる定期的に巡ってくる日誌項目を追加する
     （`insert-cyclic-diary-entry'）。

ある特定の日を毎年の記念日に指定したい場合には、その日付にポイントを移
動してから`i a'コマンドを使います。このコマンドは、別のウィンドウに日
誌ファイルの末尾を表示し、記念日を指定するS式を挿入します。そうしたら、
日誌項目の残りの部分を打ち込みます。以下はその例です。

     %%(diary-anniversary 10 31 1948) アーサーの誕生日

この項目は、1948年以降の毎年10月31日に適用されます。`10 31 1948'は日付
を指定します。（ヨーロッパ形式の日付を使っている場合には、`31'と`10'が
入れ替わる。）この式に開始年が必要なのは、日誌関数で経過年数の計算に使
うからです。

"ブロック"日誌項目は、指定した期間に適用されます。以下は、1990年6月24
日から1990年7月10日までに適用されるブロック日誌項目の例です。

     %%(diary-block 6 24 1990 7 10 1990) 休暇

`6 24 1990'は開始日付を表し、`7 10 1990'は終了日付を表します。（ヨーロッ
パ形式を使っている場合は、月と日が入れ替わる。）

ブロック項目を追加するには、ポイントとマークを期間の開始日付と終了日付
に設定してから`i b'と打ちます。このコマンドは、日誌ファイルの末尾を別
のウィンドウに表示して、ブロック項目指定を追加します。そうしたら、日誌
項目の残りの部分を打ち込みます。

"周期的"な日誌項目は、一定間隔で繰り返します。これを作るには、開始日を
選択して`i c'コマンドを使います。このコマンドは、間隔を聞いてきます。
そうしたら、項目を挿入します。以下のようになります。

     %%(diary-cyclic 50 3 1 1990) つぎの投薬

この項目は1990年3月1日から始まり、50日ごとに適用されます。`3 1 1990'は
この開始日を指定しています（ヨーロッパ形式を使っている場合は、月と日が
入れ替わる。）

これら3つのコマンドはいずれも印付けされる項目を作成します。印付け禁止
項目を挿入する場合には、コマンドに数引数を指定します。たとえば、`C-u i
a'は、印付け禁止の記念日の項目を作ります。

日誌のS式項目をカレンダーに印付けするのは*非常に*時間がかかります。な
ぜなら、カレンダーのウィンドウに見えているすべての日付について1つ1つ調
べる必要があるからです。したがって、S式項目を登録する際にはできる限り
（`&'を付けて）印付け禁止の日誌項目にするのがよいでしょう。

S式項目の別の利用方法には、"流動型"日誌項目があります。これは毎年定期
に起きることがらを日数や週数や月数のオフセットで表したものです。これは
`cron'プログラムが解釈するcrontabの項目と互換性があります。以下は、毎
年11月の最終木曜日に印付け禁止の流動型日誌項目を指定する例です。

     &%%(diary-float 11 4 -1) アメリカの感謝祭

この11は11月を表し、4は木曜（日曜を0として週の4番目の日）を表します。
-1は『最後』を表します
（1は『最初』、2は『2番目『、-2は『最後の1つまえ』などなど）。月の指定
は1個の月でも月のリストでもかまいません。たとえば、上の11を`'(1 2 3)'
に変更すると、1月、2月、3月の最終木曜日に適用する項目になります。月の
指定が`t'ならば、すべての月に適用されます。

もっとも一般的には、日誌のS式項目は適用する日付を決定するために、どん
な計算でもできます。*Note S式項目と装飾日誌表示: (elisp)Sexp Diary
Entries。



File: emacs-ja.info, Node: Appointments, Next: Daylight Savings, Prev: Diary, Up: Calendar/Diary

約束
====

日誌項目に約束が入っていて、Emacsが認識可能な形で時刻が指定されている
場合には、その予定の何分かまえに「約束がありますよ。」と警告を出す機能
があります。Emacsはモード行に約束がある旨の警告メッセージを表示します。

約束の警告表示を行わせるには、まずEmacsの時刻表示機能をオンにする必要
があります。`M-x display-time'（*Note Mode Line::）と打ちます。さらに、
関数`appt-make-list'を以下のようにして`diary-hook'に追加する必要があり
ます。

     (add-hook 'diary-hook 'appt-make-list)

個人の`.emacs'ファイルに以下のテキストを追加すれば、これまでのことを行
えます。

     (display-time)
     (add-hook 'diary-hook 'appt-make-list)
     (diary 0)

このように準備しておくと、（カレンダーのウィンドウで`d'コマンドを使う
か、`M-x diary'コマンドを使うかして）日誌を表示したときに、Emacsが認識
できる時刻指定のある約束をすべて取り込み、それらのおのおのについて指定
された時刻よりも少しまえに警告を表示します。

たとえば、日誌ファイルに以下のような項目があるとします。

     Monday
       9:30am 休憩
      12:00pm 昼食

すると、毎週月曜には、日誌を表示していると午前9時20分にもうすぐ休憩だ
と表示を出し、午前11時50分には昼食時間だと表示を出します。

時刻指定は、`9:00am'のようにam/pmスタイルでも（`12:00am'は夜中の12時、
`12:00pm'はお昼の12時を表す）、ヨーロッパや軍隊流の24時間制でもかまい
ません。また、一貫している必要もなく、日誌ファイルにこれらが混在してい
てもかまいません。

Emacsはこれらの約束リストを夜中の12時過ぎに更新します。変数
`appt-display-diary'に`nil'を設定していない限り、日誌用バッファにつぎ
の日の予定を表示します。

約束の警告表示を目覚し時計として利用することもできます。コマンド`M-x
appt-add'は、個人の日誌ファイルを変更せずに約束リストに項目を追加しま
す。`M-x appt-delete'は、約束リストから項目を削除します。

変数`appt-issue-message'に`nil'を設定すれば、約束の警告表示はいつでも
オフにできます。



File: emacs-ja.info, Node: Daylight Savings, Prev: Appointments, Up: Calendar/Diary

夏時間
======

Emacsは標準時と夏時間の違いを理解していて、日出入、夏至、冬至、春分、
秋分、朔弦望の時刻ではこれを補正しています。夏時間の規則は、地域によっ
ても、また、歴史的にもさまざまです。補正を正しく行うには、使用する規則
をEmacsに与えておく必要があります。

オペレーティングシステムのなかには、その設置場所で適用する規則を記録し
ているものもあります。このようなシステムでは、Emacsは自動的に必要な情
報をシステムから取得します。情報の一部や全部が欠けている場合には、現在
マサチューセッツ州ケンブリッジで使われている規則でEmacsは欠落部分を補
おうとします。その結果が正しくないならば、変数
`calendar-daylight-savings-starts'と`calendar-daylight-savings-ends'を
設定し、規則をEmacsに与える必要があります。

これらの変数の値は、変数`year'を参照するLisp式である必要があり、評価す
ると、グレゴリオ暦での夏時間の開始日や終了日を表す`(MONTH DAY YEAR)'と
いう形のリストになる必要があります。在住地方で夏時間を採用していない場
合には、これらの値は`nil'にしておきます。

Emacsはこれらの式を用いて夏時間の開始日を決定し、祝祭日一覧や太陽や月
に関する計算の時刻補正に使います。

マサチューセッツ州ケンブリッジの値は以下のとおりです。

     (calendar-nth-named-day 1 0 4 year)
     (calendar-nth-named-day -1 0 10 year)

`year'で指定される年の4月の最初の日曜日（0番目）から始まり、その年の10
月の最後の月曜まで続くことを表します。夏時間の開始日が10月1日に変更さ
れたならば、変数`calendar-daylight-savings-starts'には以下のように設定
します。

     (list 10 1 year)

読者の地方で夏時間を採用していなかったり、すべての時刻を標準時で扱いた
い場合には、変数`calendar-daylight-savings-starts'と変数
`calendar-daylight-savings-ends'には`nil'を設定してください。

変数`calendar-daylight-time-offset'は、夏時間と標準時の差を分単位で指
定します。マサチューセッツ州ケンブリッジでは60（分）です。

2つの変数`calendar-daylight-savings-starts-time'と変数
`calendar-daylight-savings-ends-time'は、夏時間の開始／終了が地方時の
真夜中の0時から何分ずれるかを指定します。マサチューセッツ州ケンブリッ
ジではどちらも120（分）です。


File: emacs-ja.info, Node: Gnus, Next: Shell, Prev: Calendar/Diary, Up: Top

gnus
====

gnusは主にネットニュースを読んだり投稿するためのEmacsパッケージです。
電子メイル、リモートディレクトリ、ダイジェストなどのネットニュース以外
のメッセージを読んだりそれらに応答するのにも使えます。

以下ではgnusについて紹介し、いくつかの基本的な機能について説明します。
詳しくは、*Note Gnus: (gnus)Topを参照してください。

gnusを起動するには、`M-x gnus RET'と打ちます。

* Menu:

* Buffers of Gnus::	The group, summary, and article buffers.
* Gnus Startup::	What you should know about starting Gnus.
* Summary of Gnus::	A short description of the basic Gnus commands.



File: emacs-ja.info, Node: Buffers of Gnus, Next: Gnus Startup, Up: Gnus

gnusのバッファ
--------------

ふつうのEmacsのパッケージと違って、gnusは多数の異なるバッファを使って
情報を提示したりユーザーのコマンドを受け取ります。ユーザーがもっとも多
くの時間を使うことになるバッファは、"グループバッファ"、"サマリバッファ
"、"記事バッファ"の3つです。

"グループバッファ"はニュースグループの一覧です。gnusが起動すると、まず
このバッファが表示されます。通常はユーザーが購読していて、かつ、未読記
事が存在するグループだけが表示されます。このバッファでグループを選択し
ます。

"サマリバッファ"は選択したグループ内の1つの記事につき1行の情報を表示し
ます。デフォルトでは、各記事の投稿者、題目、行数が表示されますが、gnus
のほとんどの表示内容と同様にこの表示内容はカスタマイズできます。グルー
プバッファでグループを選択するとサマリバッファが作られ、グループから出
ると削除されます。サマリバッファを使って記事を選択します。

"記事バッファ"は記事を表示します。gnusの普通の使い方では、このバッファ
を選択することはありません。記事を操作対象とするコマンド群はサマリバッ
ファで動作します。しかし、望むなら、記事バッファに切り替えて、そこで
gnusのコマンドを実行することも可能です。



File: emacs-ja.info, Node: Gnus Startup, Next: Summary of Gnus, Prev: Buffers of Gnus, Up: Gnus

gnusの起動時の動作
------------------

gnusが起動すると、個人のニュース初期化ファイル`.newsrc'を読み込み、ニュー
ス記事を蓄えているローカルのニュースサーバーと通信しようとします。ニュー
スサーバーは、ユーザーがログインしているマシンと同じである必要はありま
せん。

gnusを起動してニュースサーバーと通信したあとでもグループバッファにグルー
プが1つも表示されないときは、`L'や`A k'と打ってすべてのグループを表示
させます。つぎに各グループの行で`u'と打って個々のグループの購読／非購
読を切り替えます。

初めてgnusを起動したときは、ごく少数の選ばれたグループのみが購読状態に
あります。他のグループは"非購読グループ"（killed groups）になっていて、
`A k'を使うと表示されます。最初の起動以後にニュースサーバー上に追加さ
れたグループはすべて、"ゾンビグループ"（zombie groups）になっていて、
`A z'を使うと表示されます。`u'を使えばこれらのグループを購読状態にでき
ます。

`q'でgnusを終了すると、初期化ファイル`.newsrc'と`.newsrc.eld'にすべて
のグループの購読／非購読を自動的に記録します。通常はこれらのファイルを
手で編集すべきではありませんが、やりかたがわかっているならかまいません。



File: emacs-ja.info, Node: Summary of Gnus, Prev: Gnus Startup, Up: Gnus

gnusコマンドのまとめ
--------------------

ニュースを読むにはつぎの2つの段階を踏みます。

  1. グループバッファでグループを選択する。

  2. サマリバッファで記事を選択する。記事を選択すると、サマリバッファ
     の小さなウィンドウの下の大きめのウィンドウの中の記事バッファに選
     択した記事が表示される。

gnusの各バッファにはそれぞれ独自のコマンドがあります。しかし、gnusのさ
まざまなバッファのどんなキーの意味も、等価ではないにせよ、だいたい同じ
です。以下は、グループバッファとサマリバッファのコマンドです。

`q'
     グループバッファでは、初期化ファイル`.newsrc'を更新してgnusを終了
     する。

     サマリバッファでは、カレントグループから抜け出てグループバッファ
     に戻る。したがって、`q'を2回打つとgnusを終る。

`L'
     グループバッファでは、ニュースサーバーにある（非購読にしたもの以
     外の）すべてのグループを表示する。すごく長いリストになるかもしれ
     ないので注意！

`l'
     グループバッファでは、購読中で未読記事があるグループのみを表示す
     る。

`u'
     グループバッファでは、ポイントのある行のグループの購読／非購読を
     切り替える。`q'でgnusを終ると、gnusはこの状態を`.newsrc'ファイル
     に記録する。gnusは、通常、購読グループのみを表示するため、つぎに
     gnusを起動したときには非購読にしたグループは表示されない。

`C-k'
     グループバッファでは、ポイントのある行のグループを「抹消」する。
     すなわち、そのグループは以後`.newsrc'にも現れなくなる。このコマン
     ドの効果は、現在のgnusセッションだけでなく将来のgnusセッションに
     も影響する。

     `q'でgnusを終了すると、gnusはファイル`.newsrc'に抹消したグループ
     を除くすべてのグループの情報を書き出す。

`SPC'
     グループバッファでは、ポイントのある行に対応するグループを選択し、
     そのグループの最初の未読記事を表示する。

     サマリバッファでは、つぎのようになる。

        * 選択されている記事がなければ、ポイントのある行の記事を選択す
          る。

        * （選択されている記事があれば）その記事のテキストを1画面分進
          める。

        * 選択されている記事の末尾にいる場合は、つぎの未読記事を選択す
          る。

     すなわち、繰り返しSPCを打と、すべての記事を順に見ていくことができ
     る。

`DEL'
     グループバッファでは、ポイントを未読記事がある1つまえのグループに
     移動する。

     サマリバッファでは、記事のテキストを1画面分戻す。

`n'
     ポイントをつぎの未読グループに進めるか、または、つぎの未読記事を
     選択する。

`p'
     ポイントをまえの未読グループへ戻すか、または、まえの未読記事を選
     択する。

`C-n'
`C-p'
     既読であってもポイントを1つあと／まえの項目に移動する。ポイントが
     ある行の記事やグループを選択することはしない。

`s'
     サマリバッファでは、記事バッファに切り替えて`C-s'を打ったかのよう
     に、記事バッファのテキストに対してインクリメンタルサーチを行う。

`M-s REGEXP RET'
     サマリバッファでは、REGEXPに一致する記事がみつかるまで前向きに探
     索する。





File: emacs-ja.info, Node: Shell, Next: Emacs Server, Prev: Gnus, Up: Top

Emacsからシェルコマンドを実行する
=================================

Emacsには、1つのコマンド行を下位のシェルプロセスに渡して実行させる機能
があります。また、入出力を`*shell*'という名前のEmacsバッファに接続して
対話的にシェルを実行する機能もあります。

`M-! CMD RET'
     シェルコマンドCMDを実行し、その結果を表示する（`shell-command'）。
`M-| CMD RET'
     リージョンの内容を入力としてシェルコマンドCMDを実行する。場合によっ
     ては、リージョンをシェルコマンドの出力で置き換える。
     （`shell-command-on-region'）。
`M-x shell'
     入出力をEmacsバッファに接続してサブシェルを実行する。すると、対話
     的にコマンドを入力できる。

* Menu:

* Single Shell::           How to run one shell command and return.
* Interactive Shell::      Permanent shell taking input via Emacs.
* Shell Mode::             Special Emacs commands used with permanent shell.
* History: Shell History.  Repeating previous commands in a shell buffer.
* Options: Shell Options.  Options for customizing Shell mode.
* Remote Host::            Connecting to another computer.



File: emacs-ja.info, Node: Single Shell, Next: Interactive Shell, Up: Shell

単一のシェルコマンド
--------------------

`M-!'（`shell-command'）は、新たに作ったサブシェルにて、ミニバッファで
読み取った1行のテキストをシェルコマンドとして実行します。シェルコマン
ドの標準入力はnull装置（つまり空）です。シェルコマンドの出力があれば、
`*Shell Command Output*'という名前のEmacsバッファに入れて別のウィンド
ウに表示しますが、（カレントバッファには）選択しません。`M-1 M-!'のよ
うに数引数を指定すると、シェルコマンドの出力をカレントバッファに挿入し
ます。その場合、ポイントは（挿入された）出力の先頭に置かれ、マークは出
力の末尾に置かれます。

シェルコマンドの末尾が`&'になっていると、シェルコマンドは非同期に実行
されます。同期実行のシェルコマンドでは、Lispプログラムから呼ばれたとき
には、`shell-command'はコマンドの終了状態（0は成功を意味する）を返しま
す。

`M-|'（`shell-command-on-region'）は`M-!'と同様ですが、シェルコマンド
の標準入力は空ではなくリージョンの内容が引き渡されます。数引数を指定す
ると、それまでのリージョンは削除されシェルコマンドの出力で置き換わり新
たなリージョンになります。このコマンドは、Lispプログラムから呼ばれたと
きには、コマンドの終了状態を返します。

`M-!'も`M-|'も、使用するシェルは`shell-file-name'で指定します。この変
数は、Emacs起動時の環境変数`SHELL'をもとに初期設定されます。ファイル名
にディレクトリが指定されていなければ、`exec-path'に指定されているディ
レクトリ群を探索します。`exec-path'の値は、Emacs起動時の環境変数`PATH'
をもとに初期設定されます。個人のファイル`.emacs'でこれらの変数の初期値
を自由に変更してかまいません。

`M-!'も`M-|'もシェルコマンドの実行完了を待ち合わせます。待つのをやめた
い場合は、`C-g'で中断できます。この場合、シェルコマンドはシグナル
`SIGINT'で終了させられます。このシグナルは、シェルを使用中に`C-c'が普
通に送るシグナルと同じです。Emacsはシェルコマンドが実際に終了するまで
待ちます。シェルコマンドが（シグナル`SIGINT'を無視して）停止しない場合
は、再度`C-g'を打ちます。すると、無視できないシグナル`SIGKILL'をシェル
コマンドに送ります。

`M-!'や`M-|'で使用するコーディングシステムを指定するには、これらのコマ
ンドの直前にコマンド`C-x RET c'を使います。*Note Specify Coding::。

コマンドからのエラー出力は、通常、普通の出力と混ざり合ってしまいます。
変数`shell-command-default-error-buffer'にバッファ名の文字列を設定する
と、その名前のバッファのポイント位置のまえにエラー出力が挿入されます。



File: emacs-ja.info, Node: Interactive Shell, Next: Shell Mode, Prev: Single Shell, Up: Shell

対話的な下位のシェル
--------------------

サブシェルを対話的に実行し、その対話記録をEmacsバッファに残すには、
`M-x shell'を使います。このコマンドは、`*shell*'という名前のバッファを
作成（または再使用）し、このバッファに入出力するサブシェルを実行します。
つまり、サブシェルの『端末出力』はバッファに挿入されポイントを進め、サ
ブシェルの『端末入力』はバッファから取られます。サブシェルに入力を与え
るには、バッファの末尾へ移動して入力を打ち込み最後にRETを打ちます。

Emacsはサブシェルが何かするのを待つことはしません。シェルが待っていよ
うがシェルコマンドを実行していようが、ウィンドウやバッファを切り替えて
編集できます。サブシェルからの出力は、Emacsがそれを取り込む処理を実行
できるまで待たされます。取り込み処理は、Emacsがキーボード入力を待った
り、時間待ちに入ったときに行われます。

複数のサブシェルを使うには、バッファ`*shell*'の名前をコマンド`M-x
rename-uniquely'で別のものに変更します。そうしてから、再度`M-x shell'
と打ち込んで、新しいサブシェルを持つバッファ`*shell*'を新たに作ります。
このバッファの名前も同じように変えれば、さらに新しく作れます。すべての
サブシェルは独立かつ並行に実行されます。

サブシェルとして実行するファイル名は、変数`explicit-shell-file-name' 
の値が`nil'以外ならば、この変数の値で指定します。`nil'のときは、環境変
数`ESHELL'の値が使われますが、これが存在しない場合は環境変数`SHELL'の
値が使われます。指定されたファイル名が相対名の場合は、`exec-path'に指
定されているディレクトリ群を探索します。変数`exec-path'は、Emacs起動時
の環境変数`PATH'をもとに初期設定されます。個人のファイル`.emacs'でこれ
らの変数を自由に変更してかまいません。

シェルに対するコーディングシステムを指定するには、`M-x shell'の直前に
コマンド`C-x RET c'を使います。または、シェルを開始したあとにシェルバッ
ファで`C-x RET p'を使っても指定できます。*Note Specify Coding::。

SHELLNAMEをシェルのファイル名として、ファイル`~/.emacs_SHELLNAME'が存
在すると、Emacsはサブシェルを実行開始した直後に初期設定のために、この
ファイルの内容をシェルへの入力として送り込みます。たとえば、bashを使っ
ているのならファイル`~/.emacs_bash'の内容が送られます。

Emacsは、シェルコマンド、`cd'、`pushd'、`popd'がシェルへの入力として送
られるのを監視し、バッファ`*shell*'のデフォルトディレクトリとシェルの
カレントディレクトリが一致するようにします。これらのシェルコマンドは、
送られる入力行の文字列を構文的に調べて識別します。これらのシェルコマン
ドに別名を付けるのなら、Emacsにもその別名について教えておくことができ
ます。たとえば、変数`shell-pushd-regexp'の値がシェルへの入力行の先頭に
一致する場合は、その行は`pushd'コマンドであるとみなされます。`pushd'に
別名を付けたら、この変数の値を変更します。同様に、`shell-popd-regexp'
と`shell-cd-regexp'は、`popd'と`cd'を識別するのに使われます。これらの
コマンドはシェルへの入力行の先頭部分にあるときだけ正しく認識されます。

Emacsは、`cd'、`pushd'、`popd'のシェルコマンドだと思われるものを処理中
にエラーに遭遇すると、フック`shell-set-directory-err-hook'を実行します
（*Note Hooks::）。

Emacsがサブシェルのカレントディレクトリを正しく追従できていない場合は、
コマンド`M-x dirs'を使ってシェルにカレントディレクトリを問い合わせてく
ださい。このコマンドは一般的なコマンドの構文を持つシェルでは動作します。
ですが、とても変わったシェルでは動かないかもしれません。

`M-x dirtrack'を使うと、別のもっと積極的なやり方でカレントディレクトリ
の変更に追従する（しない）ようにもできます。

Emacsは、サブシェルの環境変数`EMACS'に`t'を設定します。シェルスクリプ
トでこの変数を検査すれば、Emacsのサブシェルとして動いているかどうか判
定できます。



File: emacs-ja.info, Node: Shell Mode, Next: Shell History, Prev: Interactive Shell, Up: Shell

シェルモード（Shellモード）
---------------------------

シェルバッファではシェル（shell）モードが使われ、プレフィックスキー
`C-c'を持つ特別なキーをいくつか定義しています。これらは、まず`C-c'を打
つことを除けば、Emacsの外でシェルを使うときの通常のコマンド行編集やジョ
ブ制御のキーに似せて定義してあります。以下は、シェル（shell）モードで
の特別なバインディングの一覧です。

`RET'
     バッファの末尾で打つと、1行分を入力としてシェルに送る。バッファの
     末尾以外では、現在行をバッファの末尾にコピーしてから、それを入力
     としてシェルに送る（`comint-send-input'）。行をコピーするとき、行
     の先頭部分の文字列で変数`shell-prompt-pattern'に一致する部分はコ
     ピーしない。この変数の値は、ユーザーのシェルがプロンプトとして用
     いる文字列に一致する正規表現であること。

`TAB'
     シェルバッファでポイントの直前にあるコマンド名やファイル名を補完
     する（`comint-dynamic-complete'）。TABは、履歴参照（*Note History
     References::）や環境変数名も補完できる。

     変数`shell-completion-fignore'には、シェル（shell）モードでの補完
     において無視したいファイル名の拡張子のリストを指定する。デフォル
     トの設定では、名前が、`~'、`#'、`%'で終るファイルを無視する。関連
     する他のcomintモードではかわりに変数`comint-completion-fignore'を
     使う。

`M-?'
     シェルバッファのポイントの直前にあるファイル名の可能な補完内容を
     一時的に表示する（`comint-dynamic-list-filename-completions'）。

`C-d'
     文字を削除するか、または、EOFを送る
     （`comint-delchar-or-maybe-eof'）。シェルバッファの末尾で`C-d'を
     打つとサブシェルにEOFを送る。バッファのそれ以外の位置では、`C-d'
     を打つと通常どおり1文字削除する。

`C-c C-a'
     行の先頭に行く。ただし、プロンプトがある場合にはプロンプトの直後
     に行く（`comint-bol'）。同じ行でこのコマンドを2回繰り返すと、2回
     目ではプロセスマークへ戻る。プロセスマークとは、サブシェルへまだ
     送っていない入力の開始位置のこと。（通常、これは同じ場所であり、
     プロセスマークはその行のプロンプトの終りにある。ただし、`C-c SPC'
     のあとでは、プロセスマークはまえの行にあるかもしれない。）

`C-c SPC'
     複数の入力行を溜めておき、まとめて送る。このコマンドは、ポイント
     のまえに改行を挿入するが、少なくともまだ、その行を入力としてサブ
     シェルへ送らない。RETを打つと、改行のまえの1行とあとの1行を（区切
     りの改行を含めて）まとめて送る。

`C-c C-u'
     バッファの末尾にある、まだシェルに送っていないテキストをすべてキ
     ルする（`comint-kill-input'）。

`C-c C-w'
     ポイントの直前の1語をキルする（`backward-kill-word'）。

`C-c C-c'
     シェル、または、あればサブジョブに割り込む
     （`comint-interrupt-subjob'）。また、このコマンドはシェルバッファ
     内のまだシェルに送っていないテキストもキルする。

`C-c C-z'
     シェル、または、あればサブジョブを中断する（`comint-stop-subjob'）。
     また、このコマンドはシェルバッファ内のまだシェルに送っていないテ
     キストもキルする。

`C-c C-\'
     シェル、または、あればサブジョブにシグナルQUITを送る
     （`comint-quit-subjob'）。また、このコマンドはシェルバッファ内の
     まだシェルに送っていないテキストもキルする。

`C-c C-o'
     直前のシェルコマンドからのひとまとまりの出力をキルする
     （`comint-kill-output'）。シェルコマンドが大量の出力を出してしまっ
     たときなどに有効。

`C-c C-r'
`C-M-l'
     直前のひとまとまりの出力がウィンドウの先頭にくるようにスクロール
     する。また、ポイントもそこへ動かす（`comint-show-output'）。

`C-c C-e'
     バッファの末尾がウィンドウの下端にくるようにスクロールする
     （`comint-show-maximum-output'）。

`C-c C-f'
     シェルコマンド1つ分だけ先へ進めるが、現在行の末尾より先へはいかな
     い（`shell-forward-command'）。変数`shell-command-regexp'には、シェ
     ルコマンドの終りの探し方（正規表現）を指定する。

`C-c C-b'
     シェルコマンド1つ分だけ手前へ戻るが、現在行の先頭よりまえへはいか
     ない（`shell-backward-command'）。

`C-c C-l'
     バッファのシェルコマンド履歴を別のウィンドウに表示する
     （`comint-dynamic-list-input-ring'）。

`M-x dirs'
     シェルにカレントディレクトリを問い合わせ、Emacs側のものをシェルに
     合わせる。

`M-x send-invisible RET TEXT RET'
     TEXTをエコーバックせずに読み取り、入力としてシェルへ送る。パスワー
     ドを問い合わせるようなプログラムを起動するシェルコマンドで役立つ。

     かわりに、つぎのようにして、Emacsにパスワードプロンプトを認識させ
     てエコーバックを抑制する方法もある。

          (add-hook 'comint-output-filter-functions
                    'comint-watch-for-password-prompt)

`M-x comint-continue-subjob'
     シェルプロセスを継続させる。これはまちがってシェルプロセスを休止
     させてしまった場合に役立つ。 (1) (*Note Shell Mode-Footnotes::)

`M-x comint-strip-ctrl-m'
     現在の一群のシェルの出力から復帰（コントロールM）文字を削除する。
     このコマンドのもっとも便利な使い方の1つは、サブシェルの出力を受け
     取ると自動的にこのコマンドが実行されるように設定しておくことであ
     る。そのためには、つぎのLisp式を評価すればよい。

          (add-hook 'comint-output-filter-functions
                    'comint-strip-ctrl-m)

`M-x comint-truncate-buffer'
     このコマンドは、変数`comint-buffer-maximum-size'で指定した大きさ
     にシェルバッファの行数を切り詰める。サブシェルから出力を受け取る
     たびにこれを自動的に行うにはつぎのようにする。

          (add-hook 'comint-output-filter-functions
                    'comint-truncate-buffer)

シェル（shell）モードでは段落コマンドにも修正を加えてあり、シェルプロ
ンプトでのみ新しい段落が始まるようになっています。つまり、シェルバッファ
では、1つの段落はシェルコマンドとその出力から成るのです。

シェル（shell）モードは、対話的なサブプロセスと通信するための汎用モー
ドであるcomintモードからの派生です。ここまでにあげてきたコマンドの名前
からもわかるように、シェル（shell）モードの数多くの機能は、実は、
comintモードからきています。シェル（shell）モードに固有な特別な機能は、
正規表現に基づくプロンプトの認識、カレントディレクトリの追跡、および、
少数のユーザーコマンドに限られます。

comintモードから派生したEmacsのほかの機能としては、GUD（*Note
Debuggers::）と`M-x run-lisp'（*Note External Lisp::）があります。

`M-x comint-run'を使うと、シェル（shell）モード固有の機能を持たない
comintモードで、任意のプログラムをサブプロセスとして実行できます。


File: emacs-ja.info  Node: Shell Mode-Footnotes, Up: Shell Mode

(1) シェルプロセスを休止すべきではない。シェルのサブジョブを休止
するのとはまったく別のことであり、こちらは普通に行ってよい。ただ
し、休止したサブジョブはシェルで再開させる必要がある。このコマン
ドでは再開できない。



File: emacs-ja.info, Node: Shell History, Next: Shell Options, Prev: Shell Mode, Up: Shell

シェルコマンド履歴
------------------

シェルバッファでは、以前に使ったシェルコマンドを再実行する方法が3つあ
ります。1つめは、ミニバッファと同じキーを使う方法です。すなわち、ミニ
バッファの場合と同様に、ポイントはつねにバッファの末尾にある状態で、以
前に使ったシェルコマンドをバッファに挿入できます。2つめは、バッファ内
で以前のシェルコマンドの箇所に移動して、それをそのまま再実行するかバッ
ファの末尾にコピーします。3つめは、`!'形式の履歴参照を使うことです。

* Menu:

* Ring: Shell Ring.             Fetching commands from the history list.
* Copy: Shell History Copying.  Moving to a command and then copying it.
* History References::          Expanding `!'-style history references.



File: emacs-ja.info, Node: Shell Ring, Next: Shell History Copying, Up: Shell History

シェル履歴リング
................

`M-p'
     今のものより1つまえの古いシェルコマンドを持ってくる。

`M-n'
     今のものより1つあとの古いシェルコマンドを持ってくる。

`M-r REGEXP RET'
`M-s REGEXP RET'
     REGEXPに一致する古いシェルコマンドを後向きまたは前向きに探索する。

`C-c C-x (Shell mode)'
     履歴からつぎのコマンドを持ってくる。

シェルバッファには、それまでに入力したシェルコマンドの履歴があります。
この履歴からシェルコマンドを再利用するには、編集コマンド、`M-p'、`M-n'、
`M-r'、`M-s'を使います。これらはミニバッファの履歴コマンドと同様に働き
ますが、（普通はシェルに送るテキストを挿入する）シェルバッファの末尾に
あるテキストに作用する点が異なります。

`M-p'は、1つまえのシェルコマンドをシェルバッファの末尾に持ってきます。
`M-p'を連続して使うと、次々にそれよりまえに実行したシェルコマンドを持っ
てきて、それまでのシェルへの入力用テキストを置き換えます。`M-n'も同様
ですが、次々にそれよりあとのシェルコマンドを持ってくる点が異なります。

履歴探索コマンド`M-r'と`M-s'は、正規表現を読み取り、それに一致するシェ
ルコマンドを履歴の中から探します。どのシェルコマンドを持ってくるかとい
う点を除けば、それらの働きは`M-p'や`M-n'と同じです。正規表現として空文
字列を入力すると、直前に使用した正規表現を再使用します。

再使用したいシェルコマンドを探したならば、RETを打ってそのシェルコマン
ドを再実行するか、必要なら編集してから実行します。

以前に連続して実行した一連のシェルコマンドをまとめて再実行できると便利
なことがあります。それには、まず、一連のシェルコマンドの最初のものを探
して再実行します。そうしてから`C-c C-x'と打ちます。これは、直前に再実
行したシェルコマンドの（履歴内で）つぎにあるシェルコマンドを持ってきま
す。RETと打って再実行します。このように、`C-c C-x RET'を繰り返し打てば
一連のシェルコマンドを再実行できます。

これらのコマンドは過去に実行したシェルコマンドを専用の履歴リストから持っ
てくるのであって、シェルバッファからとってくるのではありません。したがっ
て、シェルバッファを編集したり、その大部分をキルしたとしても、これらの
コマンドが参照する履歴には影響しません。

いくつかのシェルは、コマンド履歴をファイルに保管して以前のセッションの
履歴を引き継げるようになっています。Emacsは、自分の履歴リストを初期設
定するために、ユーザーが使うシェルの履歴ファイルを読み込みます。ファイ
ル名は、bashであれば`~/.bash_history'、kshであれば`~/.sh_history'、そ
の他のシェルであれば`~/.history'です。



File: emacs-ja.info, Node: Shell History Copying, Next: History References, Prev: Shell Ring, Up: Shell History

シェル履歴のコピー
..................

`C-c C-p'
     ポイントを1つまえのプロンプトへ移動する（`comint-previous-promp
     t'）。

`C-c C-n'
     ポイントを1つあとのプロンプトへ移動する（`comint-next-prompt'）。

`C-c RET'
     ポイントがあるところの入力コマンドをバッファの末尾にコピーする
     （`comint-copy-old-input'）。このコマンドはポイントを古いシェルコ
     マンドへ移動したときに役立つ。シェルコマンドをコピーしたら、RETで
     それを（シェルへ）送る。必要ならシェルコマンドを修正してから送っ
     てもよい。

ポイントをまえの入力箇所に移動してから`C-c RET'でコピーしても、`M-p'を
必要な回数使って履歴リストからまえのコマンドを持ってきたのと（バッファ
の内容が同じという意味で）同じ結果になります。ただし、`C-c RET'はバッ
ファからテキストをコピーするので、シェルへ送ったあとでそれをバッファ上
で編集した場合には、履歴リストにあるものとは異なることもあります。



File: emacs-ja.info, Node: History References, Prev: Shell History Copying, Up: Shell History

シェル履歴の参照
................

cshやbashをはじめ多くのシェルは、`!'や`^'で始まる"履歴参照"の機能を提
供しています。シェル（shell）モードでもこれらの指定を理解し、履歴置換
を行えます。履歴参照を入力してTABを打つと、履歴リストから一致するシェ
ルコマンドを探し、必要なら置換を行い、履歴参照をその結果で置き換えます。
たとえば、`mv'で始まるいちばん最近のシェルコマンドを持ってくるには`! m
v TAB'と打ちます。必要ならシェルコマンドを編集し、RETと打ってシェルへ
送ります。

履歴参照は、シェルプロンプトのあとでのみ効果を持ちます。変数
`shell-prompt-pattern'でシェルプロンプトと認識するものを指定します。
comintモード一般には、変数`comint-promt-regexp'でプロンプトの探し方を
指定します。シェル（shell）モードでは、`shell-prompt-pattern'を使って
`comint-prompt-regexp'のローカルな値を設定します。

シェル（shell）モードでは、シェルに送る際にバッファ内で履歴参照を展開
するようにも指定できます。それには、変数`compint-input-autoexpand'に
`input'を設定します。

SPCをコマンド`comint-magic-space'にバインドすれば、SPCで履歴展開が行え
るようになります。



File: emacs-ja.info, Node: Shell Options, Next: Remote Host, Prev: Shell History, Up: Shell

シェルモードのオプション
------------------------

変数`comint-scroll-to-bottom-on-input'が`nil'以外の場合には、挿入およ
びヤンクコマンドは、選択されているウィンドウを末尾までスクロールしてか
ら挿入します。

`comint-scroll-show-maximum-output'が`nil'以外の場合、出力に伴うスクロー
ルでは、最後の行ができるだけウィンドウのいちばん下にくるようにし、なる
べく多くの有用なテキストが見えるようにします（これは多くの端末のスクロー
ル動作の真似）。デフォルトは`nil'です。

`comint-scroll-to-bottom-on-output'を設定すると、ポイントがどこにあろ
うと、出力が到着するたびにバッファの末尾へポイントがジャンプするように
設定できます。この変数の値が`this'であれば、ポイントは選択されたウィン
ドウでジャンプします。値が`all'であれば、comintバッファを表示している
各ウィンドウでポイントはジャンプします。値が`other'であれば、カレント
バッファを表示しているすべての選択されていないウィンドウでポイントはジャ
ンプします。デフォルトは`nil'ですから、ポイントはジャンプしません。

変数`comint-input-ignoredups'は、連続する同一の入力を履歴に格納するか
どうかを制御します。値が`nil'以外のときは、直前の入力と同じ入力は履歴
に格納しません。デフォルトは`nil'ですから、直前と同じ入力でもすべて履
歴に格納します。

3つの変数でファイル名の補完をカスタマイズします。変数
`comint-completion-addsuffix'は、ファイル名やディレクトリ名を補完する
とき、名前を完全に補完できたことを示すために末尾に空白やスラッシュを挿
入するかどうかを指定します（`nil'以外のとき、空白やスラッシュを挿入）。
`comint-completion-recexact'は、その値が`nil'以外の場合、Emacsの通常の
補完アルゴリズムで1文字も追加できないときにはTABで可能なもっとも短い補
完文字列を挿入するようにします。`comint-completion-autolist'は、その値
が`nil'以外の場合、補完が完全でないときに可能な補完候補の一覧を表示す
ることを指定します。

コマンド`comint-dynamic-complete-variable'は、Emacs中で設定されている
環境変数を用いて変数名の補完を行います。ファイル名の補完を制御する上述
の変数群も変数名の補完を制御します。このコマンドは、通常、メニューバー
から使えます。

コマンド補完は、通常、実行可能なファイルだけを対象とします。
`shell-command-execonly'を`nil'にすると、実行可能でないファイルも対象
となります。

`pushd'の動作をカスタマイズできます。引数が与えられないと`cd'と同様に
ふるまう（`shell-pushd-tohome'）、数引数を指定すると`pop'ではなく巡回
する（`shell-pushd-dextract'）、ディレクトリスタックにないディレクトリ
だけをディレクトリスタックに加える（`shell-pushd-dunique'）を制御でき
ます。これらの値は当然、使っているシェルの動作と一致するように設定すべ
きです。



File: emacs-ja.info, Node: Remote Host, Prev: Shell Options, Up: Shell

リモートホストのシェル
----------------------

Emacsには、他のホストにログインしてEmacsバッファ経由で通信するコマンド
が2つあります。

`M-x telnet RET HOSTNAME RET'
     ホストHOSTNAMEにtelnet経由で接続する。
`M-x rlogin RET HOSTNAME RET'
     ホストHOSTNAMEにrlogin経由で接続する。

他のホストにtelnet経由で接続するには、`M-x telnet'を使います（telnetは
リモートログイン用のInternetの標準プロトコル）。このコマンドは、接続先
のホスト名を引数としてミニバッファで読みます。いったん接続が確立すると、
他のホストとのやりとりはサブシェルとのやりとりと同様にして行えます。通
常のEmacsコマンドで入力を編集でき、RETで相手側に送信します。相手側から
の出力は（同じ）Telnetバッファに挿入されます。

rlogin接続を行うには、`M-x rlogin'を使います。rloginは本質的にはtelnet
プロトコルとよく似たリモートログイン用の通信プロトコルですが、telnetと
の互換性はなく、ある種のシステムでだけ使えます。rloginの利点は、2つの
マシン間で頻繁に通信する場合にユーザー名やパスワードを毎回打ち込まない
ですむように設定できることと、8ビットを透過的に使う接続が可能なことで
す。（Emacsでこれを行うには、rloginを開始するまえに
`rlogin-explicit-args'に`("-8")'を設定する。）

`M-x rlogin'は、相手側とFTP経由でファイルをやりとりするためにEmacsバッ
ファのデフォルトディレクトリを設定し（*Note File Names::）、シェル
（shell）モードと同様にカレントディレクトリを変更するシェルコマンドを
監視します。

rloginバッファでディレクトリを追跡する方法は2つあります。リモートディ
レクトリ名`/HOST:DIR/'を使うか、ローカルファイル名を使います。（後者は
『相手側のホスト』がローカルホストとファイルシステムを共有している場合
にのみ使える）。コマンド`rlogin-directory-tracking-mode'を使って、これ
らの2つのモードを相互に切り替えられます。引数なしではリモートディレク
トリ名を使う状態にし、正の数を引数にするとローカル名を使う状態にします。
負の数を引数にするとディレクトリの追跡機能を止めます。



File: emacs-ja.info, Node: Emacs Server, Next: Hardcopy, Prev: Shell, Up: Top

Emacsをサーバーとして使う
=========================

`mail'を始めとする多くのプログラムは、送信メッセージなどのテキストを編
集するためにユーザーが指定したエディタを起動します。これらのプログラム
は、習慣として、環境変数`EDITOR'で指定されたエディタを起動します。
`EDITOR'に`emacs'を設定しておけばEmacsが起動しますが、新たに別のEmacs
プロセスが開始されるので不便です。というのは、新しいEmacsプロセスは既
存のEmacsプロセスとバッファを共有しないからです。

EmacsクライアントとEmacsサーバーを用いて、`mail'などのプログラムが既存
のEmacsプロセスをエディタとして使うようにできます。以下のようにします。

まずは準備です。Emacsの中で関数`server-start'を呼び出します。（個人の
ファイル`.emacs'に式`(server-start)'を書いておけば、これを自動的に行え
る。）つぎに、Emacsの外で環境変数`EDITOR'に`emacsclient'を設定します。
（プログラムによっては別の環境変数を使う。たとえば、TeXに`emacsclient'
を使わせるには、環境変数`TEXEDIT'に`emacsclient +%d %s'と設定する。）

こうすると、どのプログラムが`EDITOR'に指定されたプログラムをエディタと
して起動しても、結果としては、訪れるべきファイルを伝えるメッセージが現
在動いているEmacsに送られます。（これが`emacsclient'の役割。）Emacsは
ただちにバッファを表示し、ユーザーはすぐに編集を開始できます。

そのバッファの編集が終ったら、`C-x #'と打ちます（`server-edit'）。これ
により、ファイルが保存され、終了せよとのメッセージを`emacslient'に送り
返します。`EDITOR'を参照したプログラムは『エディタ』（実際には
`emacsclient'）が終了するのを待ちます。`C-x #'は複数のファイルに対する
外部からの編集要求で他に残っているものがないかどうかも検査し、もしあれ
ばつぎのファイルを訪問します。

望むなら手でサーバーバッファに切り替えてもかまいません。必ず`C-x #'を
使わなければならないということはありません。ただし、`C-x #'はサーバー
バッファの編集が終ったということを告げる唯一の方法です。

変数`server-window'にウィンドウやフレームを設定してあれば、`C-x #'はサー
バーバッファをそのウィンドウやフレームに表示します。

`mail'やその他のアプリケーションが`emacsclient'の終了を待っているあい
だ、`emacsclient'は端末入力を読みません。したがって、`mail'が使ってい
る端末は、そのあいだ実質的にブロックされた状態にあります。サーバーとし
て使うEmacsで編集をするためには、その（ブロックしている）端末を使わず
に行う必要があります。それには2つの方法があります。

   * ウィンドウシステムを使い、`mail'とEmacsとを別のウィンドウで動かす。
     `mail'が`emacsclient'を待っているあいだ、`mail'が動いてるウィンド
     ウはブロックされるが、他のウィンドウに切り替えればEmacsを使える。

   * Emacsのシェル（shell）モードを使って`mail'などのプログラムを動か
     す。こうすれば、`emacsclient'はEmacsの下で動いているサブシェルの
     みをブロックするので、Emacsを使ってファイルを編集するのは通常どお
     り行える。

プログラムによっては、エディタで編集するための作業ファイルを作成します。
ユーザーが作業ファイルを編集し終ると、プログラムはそのファイルを読み込
んでから消去します。Emacsサーバーがあとで同じ名前のファイルを編集する
ように告げられた場合、それはたまたまファイル名が一致しただけで、内容は
まえのファイルと何ら関係ないものと考えなければなりません。このため、サー
バーはファイルを編集し終ると作業ファイルのバッファを削除します。変数
`server-temp-file-regexp'を使って、どのようなファイルがここでいう意味
での作業ファイルであるか指定します。この変数の値は、作業ファイルである
ようなファイルの名前に一致する正規表現である必要があります。

オプション`--no-wait'を指定して`emacsclient'を起動すると、Emacs上でバッ
ファを編集し終るのを待たずにただちに終了します。



File: emacs-ja.info, Node: Hardcopy, Next: Postscript, Prev: Emacs Server, Up: Top

印刷
====

印刷用のEmacsコマンドには、バッファ全体ないしその一部を、ページヘッダ
付き／なしのどちらででも出力する機能があります。dired（*Note Misc File
Ops::）とdiary（*Note Diary Commands::）の印刷機能についても参照してく
ださい。

`M-x print-buffer'
     カレントバッファの内容を、ファイル名とページ番号を記したページヘッ
     ダ付きで印刷する。
`M-x lpr-buffer'
     カレントバッファの内容を、ページヘッダなしで印刷する。
`M-x print-region'
     `print-buffer'と同様だが、現在のリージョンのみを印刷する。
`M-x lpr-region'
     `lpr-buffer'と同様だが、現在のリージョンのみを印刷。

（Postscriptコマンドを除く）印刷コマンドは、`lpr-switches'の値をもとに
追加オプションを`lpr'に渡します。この変数の値は文字列のリストであり、
各文字列は`-'で始まるオプションである必要があります。たとえば、Emacsか
ら行う印刷で1行を80文字に設定するには、`lpr-switches'をつぎのように設
定します。

     (setq lpr-switches '("-w80"))

変数`printer-name'を設定すれば、使うプリンタを指定できます。

変数`lpr-command'は、実行すべきプリンタプログラムを指定します。デフォ
ルトの値はオペレーティングシステムに依存します。多くのシステムでは、デ
フォルトは`"lpr"'です。変数`lpr-headers-switches'も同様に、ページヘッ
ダを作るための追加オプションを指定します。変数`lpr-add-switches'は、プ
リンタプログラムに（`lpr'には適した）オプション`-T'とオプション`-J'を
指定するかどうか制御します。この変数の値が`nil'ならこれらのオプション
を指定しません。プリンタプログラムが`lpr'と互換性がないなら、変数
`lpr-add-switches'は`nil'にすべきです。



File: emacs-ja.info, Node: Postscript, Next: Postscript Variables, Prev: Hardcopy, Up: Top

Postscriptの印刷
================

これらのコマンドは、バッファの内容をPostscriptに変換し、プリンタへ送る
か他のEmacsバッファに入れます。

`M-x ps-print-buffer'
     カレントバッファをPostscript形式で印刷する。
`M-x ps-print-region'
     現在のリージョンをPostscript形式で印刷する。
`M-x ps-print-buffer-with-faces'
     カレントバッファをPostscript形式で印刷するが、テキストで用いてい
     るフェイスをPostscriptの機能で表示する。
`M-x ps-print-region-with-faces'
     現在のリージョンをPostscript形式で印刷するが、テキストで用いてい
     るフェイスも表示する。
`M-x ps-spool-buffer'
     カレントバッファのテキストをPostscriptに変換する。
`M-x ps-spool-region'
     現在のリージョンをPostscriptに変換する。カレントバッファを
     Postscriptに変換するが、使われているフェイスも表示する。
`M-x ps-spool-region-with-faces'
     現在のリージョンをPostscriptに変換するが、使われているフェイスも
     表示する。

Postscriptコマンド`ps-print-buffer'および`ps-print-region'はバッファの
内容をPostscript形式で出力します。前者はバッファ全体を出力しますが、後
者はリージョンのみです。これらに対応した`-with-faces'コマンドである
`ps-print-buffer-with-faces'および`ps-print-region-with-faces'は、出力
するテキストのテキスト属性のフェイス（フォントと表示色）をPostscriptの
機能を用いて再現します。

カラーディスプレイを使っている場合、バッファでフォントロック
（font-lock）モードを使って色付けしたプログラムコードを
`ps-print-buffer-with-faces'で（そのまま）印刷できます。

コマンド名が`print'のかわりに`spool'であるものは、変換したPostscript出
力をプリンタに送るかわりにEmacsバッファに置きます。

つぎの節では、これらのコマンドをカスタマイズする変数について説明します。



File: emacs-ja.info, Node: Postscript Variables, Next: Sorting, Prev: Postscript, Up: Top

Postscriptの印刷を制御する変数
==============================

すべてのPostscriptの印刷コマンドは、出力をどのように印刷するかを変数
`ps-lpr-command'と`ps-lpr-switches'で指定できます。`ps-lpr-command'に
は印刷のため実行するシェルコマンド、`ps-lpr-switches'にはそのシェルコ
マンドに指定するオプション、`ps-printer-name'にはプリンタを指定します。
始めの2つの変数を設定しなかった場合は、`lpr-command'と`lpr-switches'に
基づいて初期値が設定されます。`ps-printer-name'が`nil'だと
`printer-name'を使います。

変数`ps-print-header'は、これらのコマンドが各ページにヘッダをつけるか
どうかを制御します。`nil'だとヘッダを付けません。`ps-print-color-p'を
`nil'にするとカラー処理を行いません。

変数`ps-paper-type'は、印刷用紙サイズを指定します。指定できる値は、
`a4'、`a3'、`a4small'、`b4'、`b5'、`executive'、`ledger'、`legal'、
`letter'、`letter-small'、`statement'、`tabloid'です。デフォルトは
`letter'です。変数`ps-page-dimensions-database'を変更すれば別の用紙サ
イズを定義できます。

変数`ps-landscape-mode'は用紙の向きを指定します。デフォルトは`nil'で、
『縦づかい』（ポートレート）です。`nil'以外の値を指定すると『横づかい』
（ランドスケープ）です。

変数`ps-number-of-columns'は段数を指定します。縦づかいでも横づかいでも
有効で、デフォルトは1です。

変数`ps-font-family'は、通常のテキストの印刷に使うフォントファミリを指
定します。指定できる値は、`Courier'、`Helvetica'、`NewCenturySchlbk'、
`Palatino'、`Times'です。変数`ps-font-size'は、通常のテキスト印刷に使
うフォントのサイズを指定します。デフォルトは8.5ポイント (1) (*Note
Postscript Variables-Footnotes::)です。

これらのコマンドには他にも多くのカスタマイズ可能な変数があり、それらは
Lispファイル`ps-print.el'で定義されています。


File: emacs-ja.info  Node: Postscript Variables-Footnotes, Up: Postscript Variables

(1) 【訳注】印刷機の長さの単位。1ポイントは約1/72インチ（0.35mm）



File: emacs-ja.info, Node: Sorting, Next: Narrowing, Prev: Postscript Variables, Up: Top

テキストのソート
================

Emacsには、バッファ中のテキストをソートするコマンドがいくつかあります。
すべてはリージョン（ポイントとマークのあいだのテキスト）に働きます。こ
れらのコマンドは、リージョン中のテキストを多数の"ソートレコード"にわけ、
各レコードについて"ソートキー"を識別し、一連のレコードをソートキーによっ
て定まる順序に並べ替えます。レコードはキーのアルファベット（辞書）順に
も、また数値に基づく数値順にも並べられます。アルファベット順の場合は、
ASCII文字の順序に基づいてすべての大文字「A」〜「Z」は小文字「a」よりま
えにきます。

各種のソートコマンドの違いは、テキストをソートレコードに分ける方法と、
各レコードのどの部分をソートキーに使うかです。ほとんどのコマンドは各行
をソートレコードとして扱いますが、段落やページをソートレコードとして扱
うコマンドもあります。ほとんどのソートコマンドは各ソートレコード全体を
それ自身のソートキーとして扱いますが、ソートレコードの一部分だけをソー
トキーとして扱うコマンドもあります。

`M-x sort-lines'
     リージョンを行の並びとみなし、行全体のテキストを比較して（昇順に）
     ソートする。数引数を指定すると降順にソートする。

`M-x sort-paragraphs'
     リージョンを段落の並びとみなし、（先頭の空行を除く）段落全体のテ
     キストを比較して（昇順に）ソートする。数引数を指定すると降順にソー
     トする。

`M-x sort-pages'
     リージョンをページの並びとみなし、（先頭の空行を除く）ページ全体
     のテキストを比較して（昇順に）ソートする。数引数を指定すると降順
     にソートする。

`M-x sort-fields'
     リージョンを行の並びとみなし、行の1つの欄を比較して（昇順に）ソー
     トする。欄は白文字で区切られる。つまり、行の始めにある白文字でな
     い文字の並びが第1欄、そのつぎの空白でない文字の並びが第2欄、とい
     うようになる。

     どの欄をキーとしてソートするかは、1を指定すれば第1欄、というよう
     に数引数で指定する。負の値を指定したときは左からでなく右から欄を
     数える。つまり、-1は最後の欄でソートする。複数の行において欄の値
     が同一の場合、バッファ上のもとの順序が保存される。

`M-x sort-numeric-fields'
     `M-x sort-fields'と同様だが、指定した欄を行ごとに数値に変換し、そ
     の数値同士を比較する。`10'はアルファベット順では`2'よりまえにくる
     が、数値として見れば`2'よりあとにくる。

`M-x sort-columns'
     `M-x sort-fields'と同様だが、行の比較に使うテキストは固定文字位置
     からとる。以下の説明を参照のこと。

`M-x reverse-region'
     リージョン内の行の順番を逆にする。欄や文字位置でソートするコマン
     ドは降順にはソートできないので、昇順にソートしたあと降順に並べ替
     えるのに役立つ。

たとえば、バッファにつぎのような内容が入っていたとします。

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

バッファ全体に`M-x sort-lines'を適用すると、つぎのようになります。

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

ここで、`O'は大文字なのですべての小文字よりまえにきます。上記のかわり
に`C-u 2 M-x sort-filelds'を使ったとすると、結果はつぎのようになります。

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

この例ではソートキーは、`Emacs'、`If'、`buffer'、`systems'、`the'だっ
たわけです。

`M-x sort-columns'には少々説明が必要です。文字位置の範囲を指定するには、
ポイントを文字位置の一方に、マークを他方の文字位置に置きます。このため、
ポイントやマークをソートしたい最初の行の先頭に置くことができませんから、
このコマンドでは変わった「リージョン」の定義を用います。ポイントがある
行全体はリージョンに含まれ、同様に、マークがある行全体もリージョンに含
まれ、この2つの行のあいだにある行はすべてリージョンに含まれるとみなす
のです。

たとえば、ある表を10文字目から15文字目までの情報をもとにソートする場合、
表の最初の行の10文字目にマークを置き、表の最後の行の15文字目にポイント
を置き、そして`sort-column'を実行します。あるいは、マークを最初の行の
15文字目、ポイントを最後の行の10文字目に置いても同じことです。

これは、ポイントとマークで指定された矩形領域をソートするものと考えられ
ます。ただし、矩形領域の右側や左側にある各行のテキストも一緒に移動しま
す。

`sort-fold-case'が`nil'以外の場合、ソートコマンドのほとんどは比較に際
して大文字小文字を区別しません。



File: emacs-ja.info, Node: Narrowing, Next: Two-Column, Prev: Sorting, Up: Top

ナロイング
==========

"ナロイング"（narrowing）とは、バッファのある部分だけに焦点を当て、残
りの部分を一時的に参照できなくすることです。扱える部分のことを"参照可
能範囲"と呼びます。ナロイングを取り消して、バッファ全体を参照できるよ
うに戻すことを"ワイドニング"（widening）と呼びます。

ナロイングすると、他の部分に煩わされることなく、1つのサブルーチンや段
落などに集中できます。また、置換コマンドやキーボードマクロの適用範囲を
制限するのにも利用できます。

`C-x n n'
     ポイントとマークのあいだにナロイングする（`narrow-to-region'）。
`C-x n w'
     再度バッファ全体を参照可能にする（`widen'）。
`C-x n p'
     現在のページにナロイングする（`narrow-to-page'）。
`C-x n d'
     現在の関数定義にナロイングする（`narrow-to-defun'）。

バッファの一部分へナロイングすると、その部分だけしかないように見えます。
残りの部分は見えませんし、そこへポイントを移動することもできません（移
動コマンドは参照可能範囲から外へ出られない）し、見えない部分はどのよう
にしても変更できません。しかし、その部分がなくなったわけではないので、
ファイルに保存すれば参照できないテキストも保存されます。ナロイングして
いるあいだは、モード行に`Narrow'と表示されます。

主要なナロイングコマンドは`C-x n n'（`narrow-to-region'）です。現在の
リージョンだけが参照可能で、その前後のテキストは参照できないようにカレ
ントバッファに制限を課します。ポイントとマークは変化しません。

別のやり方として、`C-x n p'（`narrow-to-page'）は現在のページだけが見
えるようにナロイングします。ページの定義については、*Note Pages::。
`C-x n d'（`narrow-to-defun'）はポイントを含む関数定義の範囲にナロイン
グします（*Note Defuns::）。

ナロイングを取り消すには、`C-x n w'でワイドニングします。これによって
バッファ中の全テキストが再度参照可能になります。

バッファ中のどの部分にナロイングしているかは、コマンド`C-x ='で調べる
ことができます。*Note Position Info::。

ナロイングは、それについて知らないユーザーを簡単に混乱させますので、
`narrow-to-region'は、通常、使用禁止コマンドになっています。このコマン
ドを使おうとすると、Emacsは確認を求めてきて、コマンドを使えるようにす
るかどうか問い合わせてきます。コマンドを利用可能にすると、それ以後は確
認は必要なくなります。*Note Disabling::。



File: emacs-ja.info, Node: Two-Column, Next: Editing Binary Files, Prev: Narrowing, Up: Top

2段組み編集
===========

2段組み（two-column）モードは、左右の段に分けたテキストを編集するのに
便利です。このモードでは、左右に並んだ2つのウィンドウを使用し、それぞ
れに別のバッファを表示します。

2段組み（two-column）モードに入るには、3つの方法があります。

`F2 2' または `C-x 6 2'
     カレントバッファを左側に、カレントバッファの名前に基づいた名前の
     バッファを右側にして2段組み（two-column）モードに入る
     （`2C-two-columns'）。右側のバッファがまだ存在しなければ空のバッ
     ファで始まり、カレントバッファの内容は変化しない。

     このコマンドはカレントバッファが空か、または1段目の内容だけを持っ
     ていて、これから2段目を作成しようとするときに使う。

`F2 s' または `C-x 6 s'
     2段組みテキストを含んでいるカレントバッファの内容を2つのバッファ
     に分割し、それらを左右に並べて表示する（`2C-split'）。カレントバッ
     ファは左側のバッファになるが、右側の段の内容は右側のバッファに移
     される。分割位置はポイントのある文字位置で指定する。現在行からバッ
     ファの末尾を分割する。

     このコマンドはバッファにすでに2段組みのテキストが入っていて、一時
     的に左右の段を分けて編集したいときに用いる。

`F2 b BUFFER RET'
`C-x 6 b BUFFER RET'
     カレントバッファを左側のバッファ、BUFFERを右側のバッファとして2段
     組み（two-column）モードに入る（`2C-associate-buffer'）。

`F2 s'と`C-x 6 s'は、各行を2つの段に分ける文字列である「段区切り文字列」
を探します。段区切り文字列の文字数は、`F2 s'への数引数で指定できます。
ポイントの直前のその文字数分の文字列が段区切り文字列になります。デフォ
ルトでは幅は1ですから、ポイントの直前の文字が段区切り文字列になります。

各行の正しい位置に段区切り文字列があれば、`F2 s'は各行の段区切り文字列
のうしろの文字列を右側のバッファに移し、段区切り文字列を削除します。段
区切り文字列が正しい位置にない行は分割されずに左側のバッファに残り、対
応する右側のバッファの内容は空行になります。（これは、『2段組み
（two-column）モードで両側の段にまたがった行』の書き方。つまり、左側の
バッファにそのような行を書き、右側のバッファは空行にしておく）。

コマンド`C-x 6 RET'や`F2 RET' （`2C-newline'）は、左右の2つのバッファ
の対応する位置に改行を挿入します。バッファを分割して編集しているときに
2段組みテキストに新しい行を追加するにはこれがもっとも簡単な方法です。

左右のバッファを望むように編集し終えたら、それらを`F2 1'または`C-x 6
1'（`2C-merge'）で再度併合します。右側バッファの内容を左側バッファに第
2段目としてコピーします。再度2段組み編集に戻るには、`F2 s'を使います。

2つのバッファ間の関連を解消するには、`F2 d'または`C-x 6 d'
（`2C-dissociate'）を使います。コマンドを入力したときにカレントバッファ
でない側のバッファが空であれば、そのバッファは削除します。



File: emacs-ja.info, Node: Editing Binary Files, Next: Saving Emacs Sessions, Prev: Two-Column, Up: Top

バイナリファイルの編集
======================

バイナリファイルを編集するための特別なメジャーモード、hexlモードがあり
ます。このモードを使うには、ファイルを訪問する`C-x C-f'のかわりに`M-x
hexl-find-file'を使います。このコマンドはファイルの内容を16進数表現に
変換し、変換したものを編集するようにします。ファイルを保存すると自動的
にバイナリに戻されます。

`M-x hexl-mode'を使えば、既存のバッファを16進数表現に変換できます。普
通にファイルを訪問してみたら、実はバイナリファイルだとわかった場合に便
利です。

hexlモードでは通常のテキスト文字は上書きします。これはファイル中のデー
タの配置をまちがって壊してしまう危険を減らすためです。特別な挿入コマン
ドがあります。以下は、hexlモードで使えるコマンドの一覧です。

`C-M-d'
     10数進で入力したコードのバイトを挿入する。

`C-M-o'
     8数進で入力したコードのバイトを挿入する。

`C-M-x'
     16数進で入力したコードのバイトを挿入する。

`C-x ['
     1kバイト単位の『ページ』の先頭へ移動する。

`C-x ]'
     1kバイト単位の『ページ』の末尾へ移動する。

`M-g'
     16進数で指定したアドレス位置へ移動する。

`M-j'
     10進数で指定したアドレス位置へ移動する。

`C-c C-c'
     hexlモードを抜け、`hexl-mode'実行前のこのバッファのメジャーモード
     に戻る。



File: emacs-ja.info, Node: Saving Emacs Sessions, Next: Recursive Edit, Prev: Editing Binary Files, Up: Top

Emacsセッションの保存
=====================

デスクトップ（desktop）ライブラリを使うと、セッションからセッションへ
Emacsの状態を保存できます。状態を保存するというのは、以前のEmacsセッショ
ンで使っていたのと同じバッファ群、メジャーモード、バッファ内の位置の状
態でEmacsが始まるという意味です。

デスクトップ機能を使うには、カスタマイズバッファ（*Note Easy
Customization::）を使って`desktop-enable'に`nil'以外の値を設定するか、
個人の`.emacs'ファイルの末尾に以下のような行を追加します。

     (desktop-load-default)
     (desktop-read)

ユーザーが最初にEmacsセッションの状態を保存するときは、`M-x
desktop-save'で陽に状態を保存する必要があります。一度これを行っておけ
ば、Emacsを終わるときに（現在のセッションだけでなく、それ以降のセッショ
ンでも）自動的に状態を保存します。また、Emacsを終わらせることなく任意
の時点で状態を保存するには、`M-x desktop-save'を使います。

Emacsがまえのセッションの状態を引き継ぐためには、まえのセッションを開
始したときと同じカレントディレクトリでEmacsを起動する必要があります。
これは、`desktop-read'が読み込むファイルをカレントディレクトリで探すか
らです。つまり、異なるディレクトリごとに別のセッションを保存できること
を意味します。Emacsを起動するディレクトリで、保存したどのセッションを
使うか制御できます。

変数`desktop-files-not-to-save'は、状態保存から除外するファイルを制御
します。この変数の値は、除外したいファイルに一致する正規表現です。デフォ
ルトでは、（ftpで取ってきた）リモートファイルを除外します。これはリモー
トファイルを再度取ってくるとセッションの開始が遅くなるからです。リモー
トファイルも状態保存に含めるには、`desktop-files-not-to-save'に`"^$"'
と設定します。*Note Remote Files::。



File: emacs-ja.info, Node: Recursive Edit, Next: Emulation, Prev: Saving Emacs Sessions, Up: Top

再帰編集レベル
==============

"再帰編集"とは、あるEmacsコマンドの実行途中で任意のEmacsコマンドを使っ
て編集を行う状況をいいます。たとえば、`query-replace'の途中で`C-r'を打
つと、再帰編集に入りカレントバッファを自由に変更できます。再帰編集から
抜けると、`query-replace'の続きに戻ります。

再帰編集から"脱出"するとは、実行途中のコマンドに戻ってその続きを行うこ
とを意味します。脱出のためのコマンドは`C-M-c'（`exit-recursive-edit'）
です。

再帰編集を"アボート"することもできます。これは脱出と似ていますが、実行
途中だったコマンドも一緒に中断します。アボートするには、`C-]'
（`abort-recursive-edit'）を使います。*Note Quitting::。

再帰編集中は、モード行のメジャー／マイナモード名を囲む丸括弧の外側に中
括弧`[...]'が表示されます。各ウィンドウのモード行すべてにこのように表
示されます。というのは、特定のウィンドウやバッファではなくEmacs全体が
再帰編集に入っているからです。

再帰編集中にさらに再帰編集に入ることもできます。たとえば、
`query-replace'の途中で`C-r'を打ってからデバッガを起動するコマンドを打っ
たとします。すると、`C-r'による再帰編集の中でさらにデバッガのための再
帰編集に入ることになります。モード行には、現在の再帰編集レベルの数だけ
中括弧の対が表示されます。

内側の再帰編集を（たとえばデバッガのコマンド`c'で）脱出すると、1つ上の
レベルでのコマンドが再開されます。そのコマンドが終わったところで
`C-M-c'を使うとそのレベルの再帰編集を脱出する、というようにして再帰編
集を終わらせていくことができます。脱出はつねにもっとも内側のレベルに対
して起こります。また、アボートも1つのレベルの再帰編集から脱出し、1つま
えの再帰編集のコマンドレベルに戻ります。必要ならそこでつぎの再帰編集レ
ベルをアボートする、というように続けることができます。

あるいは、コマンド`M-x top-level'ですべてのレベルの再帰編集をアボート
し、ただちにトップレベルのコマンド入力に戻ることができます。

再帰編集の中で編集しているテキストはトップレベルで編集しているテキスト
と同じであるとは限りません。再帰編集の目的によって変わってきます。再帰
編集を起動するコマンドがまず別のバッファに切り替えるものなら、そのバッ
ファを再帰的に編集することになるでしょう。いずれにせよ、再帰編集の内側
でも（バッファを切り替えるキーが再定義されていない限り）通常どおりバッ
ファを切り替えることができます。残りの編集作業をすべて再帰編集の内側で
やってしまい、別のファイルを訪問したりもできます。しかしそのようなこと
をすると、ときどき（スタックオーバーフローなどの）痛い目に合う可能性が
あります。ですから、再帰編集が不要になったら忘れずに脱出かアボートして
ください。

一般に、GNU Emacsでは再帰編集レベルを最小限に抑えるように努めています。
というのは、再帰編集では特定の順、つまり、最内側レベルからトップレベル
に向かう順で戻るように強いられるからです。このため、別の作業は別のバッ
ファでするようにして、ユーザーがそれらの間を自由に行き来できるようにし
ています。たとえば、あるコマンドは新しいメジャーモードに切り替えますが、
もとのモードに戻るコマンドを用意しておきます。このようにしたほうが、や
りかけの作業に戻る順番を自由に選べ、柔軟性を提供できます。



File: emacs-ja.info, Node: Emulation, Next: Dissociated Press, Prev: Recursive Edit, Up: Top

エミュレーション
================

GNU Emacsは、他のほとんどのエディタの（程度の差はありますが）エミュレー
ト（真似を）するようにプログラムできます。標準の機能では、以下のものを
エミュレートできます。

EDT（DECのVMSエディタ）
     `M-x edt-emulation-on'でEDTエミュレーションに入る。`M-x
     edt-emulation-off'で通常のEmacsのバインディングに戻る。

     EDTエミュレーションコマンドの大部分はキーパッドのキーであり、大部
     分のEmacsのキーバインディングはそのまま使える。EDTエミュレーショ
     ンのバインディング変更はグローバルキーマップに対して行われ、EDTエ
     ミュレーションの状態でバッファやメジャーモードを切り替えても問題
     ない。

vi （バークレー エディタ）
     viperは最新のviエミュレータである。viperでは複数レベルのエミュレー
     ションを実装している。レベル1がもっともviに近く、レベル5はviとい
     くらか違うところもあるが、そのかわりEmacsの機能も活かせるようになっ
     ている。viperを起動するには、`M-x viper-mode'と打つ。すると、使い
     方のガイドを表示し、どのレベルのエミュレーションにするかを尋ねて
     くる。*Note Viper: (viper)Top。

vi （もう1つのエミュレータ）
     `M-x vi-mode'はそれまでのメジャーモードにかわってviメジャーモード
     に入る。viの『入力』モードに入るコマンドはすべて、それまでのメジャー
     モードに戻る動作になっている。つまり、viの『入力』モードとして普
     通のEmacsが使えるのである。

     viエミュレーションはメジャーモードとして動くので、エミュレーショ
     ン中にバッファを切り替えることはできない。バッファを切り替えたけ
     れば、まず通常のEmacsに戻る。

     viエミュレーションを多用するつもりなら、`vi-mode'コマンドにキーを
     バインドしたほうがよいだろう。

vi （また別のエミュレータ）
     `M-x vip-mode'は、`M-x vi-mode'よりもっとviに酷似しているといわれ
     る別のviエミュレータを起動する。このエミュレータでは『入力』モー
     ドも通常のEmacsとは変わっていて、ESCでviコマンドモードに戻る。vi
     コマンドモードのエミュレーションから通常のEmacsに戻るには`C-z'と
     打つ。

     このエミュレータはメジャーモードとして動くのではないので、エミュ
     レータを動かしたままさまざまな方法でバッファを切り替えることがで
     きる。`vi-mode'のようにコマンド`vi-mode'で入力モードを終了するの
     ではないので、`vip-mode'にキーを割り当てる必要はない。

     より詳しくは*Note VIP: (vip)Top。



File: emacs-ja.info, Node: Dissociated Press, Next: Amusements, Prev: Emulation, Up: Top

まぜこぜ新聞（Dissociated Press）
=================================

`M-x dissociated-press'はテキストを、単語単位、または、文字単位で混ぜ
合わせるコマンドです。普通の英語をバッファに入れた状態でこれを実行する
と、きわめておもしろい結果が生成されます。入力はカレントバッファから取
り、出力は`*Dissociation*'というバッファに書き込みます（およそ2、3行生
成するごとにバッファが再表示されるので、生成内容を順次読めます）。

`M-x dissociated-press'は定期的にもっと出力を続けるかどうか聞いてきま
す。`n'と答えると生成をやめます。また、`C-g'を打てばいつでも止められま
す。出力はバッファ`*Dissociation*'に残っていますから、必要ならどこへで
もコピーできます。

`M-x dissociated-press'はバッファ中のある箇所からランダムに別の箇所に
ジャンプすることを繰り返していきます。ただのゴミではなくおもしろい出力
が得られるように、ある一連の単語列からつぎの一連の単語列に移る際に、そ
れらのあいだに一定の重複があるようにします。つまり、たとえばpresident 
と出力したところで別の場所にジャンプすることに決めたら、最後にあった
entと同じ文字列のある単語、たとえばpentagonのところに飛んでそこから続
けるので、結果としてpregidentagon (1) (*Note Dissociated
Press-Footnotes::) というのが生成されるわけです。元テキストが長いとた
いへんおもしろい結果を得られます。

`M-x dissociated-press'に正の数引数を渡すと文字単位で動作し、その数値
は重複する文字数を指定します。また、負の数引数を渡すと単語単位で動作し、
その数値（の絶対値）で重複する単語数を指定します。引数を指定しないと
「2」を指定したのと同じになります。繰り返しますが、出力はつねにバッファ
`*Dissociation*'に現れます。もとのバッファは変更されません。

`M-x dissociated-press'は、入力テキストから頻度表を作ってマルコフ連鎖
を適用したのに近い結果をもたらしますが、それ自体はきわめてオリジナルな
発明です。というのは、マルコフ連鎖では単に乱数に基づいて文字や語を選ぶ
だけなのに対し、このコマンドでは乱数に基づいて連続した文字や語をコピー
してくるからです。このため、より高速な実行が可能ですし、読んでおもしろ
い結果が得られます。

`M-x dissociated-press'の使いすぎは仕事に差し支え、場合によっては重大
な障碍となりますから注意しましょう。また、ユーザーに受け入れてもらうた
めにも、マニュアルにこのコマンドの出力を利用するのはやめたほうがよいで
す。でも、せいぜい楽しんで、よかったらバグの提案もよろしく。 (2)
(*Note Dissociated Press-Footnotes::)


File: emacs-ja.info  Node: Dissociated Press-Footnotes, Up: Dissociated Press

(1) この合成語は、ベトナム戦争中にまさにそれにぴったりの意味で実際に使
われたことがある。

(2) 【訳注】 この段落自体、`M-x dissociated-press'で生成したような
ものなので、原文を掲載しておく。 
 It is a mustatement that too much
use of Dissociated Press can be a developediment to your real work.
Sometimes to the point of outragedy.  And keep dissociwords out of
your documentation, if you want it to be well userenced and
properbose.  Have fun.  Your buggestions are welcome.



File: emacs-ja.info, Node: Amusements, Next: Customization, Prev: Dissociated Press, Up: Top

その他の娯楽
============

退屈なときは、`M-x hanoi'を試してください。ひどく退屈なら、数引数を指
定してください。ものすごく、ひどく退屈なら、「9」を指定するとよいでしょ
う。まあやってみてください。

もう少し積極的に何かしたいなら、`M-x gomoku'を試してください。これは五
目並べのプログラムです。

`M-x blackbox'と`M-x mpuz'は2種類のパズルです。`blackbox'は箱の中の物
の位置を当てるゲームです。`mpuz'は掛け算の覆面算で、英字に対応している
数字を当てるゲームです。英字を打ってからその英字に対応していると思う数
字を打ち込みます。

`M-x dunnet'はアドベンチャー風の探検ゲームで、大きなパズルだと思えばよ
いでしょう。

いらいらするときは、有名なElizaプログラムを試してみてください。`M-x
doctor'と打つだけです。1つの入力の終りにはRETを2回打ちます。

奇妙な感じがするときは、`M-x yow'と打ってみてください。


File: emacs-ja.info, Node: Customization, Next: Quitting, Prev: Amusements, Up: Top

カスタマイズ
************

本章では、Emacsの動作を（あまり大幅でなく）カスタマイズする方法につい
て説明します。もっと大幅な変更を行いたい場合には`The Emacs Lisp
Reference Manual'を参照してください。

カスタマイズは、Emacsの1つのセッションの中だけで効果を持ちます。Emacs
を終了するとカスタマイズの効果は失われますし、同時にあるいはあとで別の
Emacsを立ち上げた場合にも何の影響も及ぼしません。あるEmacsのセッション
がセッションを超えて影響するためには、ファイルに書くしかありません。特
に、カスタマイズを『恒久化』したい場合には、個人の`.emacs'ファイルやそ
の他の関連するファイルに適切な内容を書き込んでおき、セッションごとにカ
スタマイズが行われるようにします。*Note Init File::。

* Menu:

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single
			  command. 
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Keyboard Translations::
                        If your keyboard passes an undesired code
			   for a key, you can tell Emacs to
			   substitute another code. 
* Syntax::		The syntax table controls how words and
			   expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file. 



File: emacs-ja.info, Node: Minor Modes, Next: Variables, Up: Customization

マイナモード（minor mode）
==========================

マイナモードは、個別にオン／オフ可能な機能です。たとえば、マイナモード
である自動詰め込み（auto-fill）モードをオンにすると、SPCで自動的に（単
語の切れ目で）行分けします。すべてのマイナモードは互いに独立ですし、ど
のメジャーモードとも独立です。ほとんどのマイナモードは、それがオンであ
ることをモード行に表示します。たとえば、モード行に`Fill'と表示されてい
れば、自動詰め込み（auto-fill）モードがオンであることを意味します。

マイナモード名のうしろに`-mode'を付け加えると、そのモードをオン／オフ
するコマンド関数の名前になります。したがって、自動詰め込み（auto-fill）
モードをオン／オフするコマンドは`M-x auto-fill-mode'ということになりま
す。これらのコマンドは通常`M-x'を使って起動しますが、どれかのキーにバ
インドすることもできます。引数を指定しないと、これらのコマンドはモード
がオフのときはオンに、オンのときはオフに切り替えます。これを"トグルす
る"と呼びます。これに対し、正の引数を指定するとつねにモードをオンにし
ますし、明示的に0の引数を指定するか、または負の引数を指定するとつねに
モードをオフにします。

いくつかのマイナモードのオン／オフは、カレントバッファに対してのみ適用
され、他のバッファには影響しません。つまり、あるバッファであるモードを
オンにし、別のバッファではそのモードをオフにできるわけです。このような、
バッファごとにオン／オフできるマイナモードとしては、略語（abbrev）モー
ド、自動詰め込み（auto-fill）モード、自動保存（auto-save）モード、フォ
ントロック（font-lock）モード、ISOアクセント（iso-sccents）モード、ア
ウトライン（outline）マイナモード、上書き（overwrite）モード、バイナリ
上書き（binary-overwrite）モードがあります。

略語（abbrev）モードでは、略語を打ち込むと自動的に展開されるような略語
を定義できます。たとえば、`amd'を`abbrev mode'と展開させます。詳しくは、
*Note Abbrevs::。

自動詰め込み（auto-fill）モードでは、いちいち改行で行分けしなくてもテ
キストを詰め込んで入力できます。行が長くなりすぎないようにEmacsが適宜
改行を挿入します。*Note Filling::。

自動保存（auto-save）モードはバッファの内容を定期的に保存することで、
システムクラッシュが起きたとき紛失してしまう作業の量を少なくします。
*Note Auto Save::。

エンリッチ（enriched）モードは、整形済みテキストの編集を可能にします。
*Note Formatted Text::。

フライスペル（flyspell）モードは、綴りに誤りのある単語を自動的に強調表
示します。

フォントロック（font-lock）モードは、コメント、文字列、定義中の関数名
などのプログラム中の決まった単位を自動的に強調表示します。これには、複
数のフォントを表示できるウィンドウシステムが必要です。*Note Faces::。

水平スクロール（hscroll）モードは、ポイントが画面内に留まるように、自
動的に水平スクロールを行います。*Note Horizontal Scrolling::。

ISOアクセント（iso-accents）モードは、``'、`''、 `"'、`^'、`/'、`~'と
これらに続くつぎの文字を結合して、ISO Latin-1文字集合のアクセント付き
文字を作り出します。*Note Single-Byte European Support::。

アウトラインマイナ（outline-minor）モードは、メジャーモードであるアウ
トライン（outline）モードと同じ機能を提供します。しかし、マイナモード
なので任意のメジャーモードと一緒に使えます。*Note Outline Mode::。

上書き（overwrite）モードでは、入力された図形文字は既存の文字を右に押
しやるかわりにその文字を置き換えます。たとえば、ポイントが`FOOBAR'の
`B'のまえにあるときに`G'を打つと`FOOGAR'となります。通常のモードであれ
ば`FOOGBAR'となります。上書き（overwrite）モードでコマンド`C-q'を打つ
と、そのつぎの文字が何であっても（数字であっても）その文字を挿入します。
つまり、上書き（overwrite）モードの中で文字を挿入するにはこの方法を使
います。

バイナリ上書き（binary-overwrite）モードは上書き（overwrite）モードの
変形で、バイナリファイル編集用です。このモードでは、改行やタブも他の文
字と同じに扱われるので、他の文字をこれらの文字で上書きすることも、これ
らの文字を他の文字で上書きすることもできます。

以下で説明するマイナモードは、すべてのバッファに一斉に適用されます。た
だし、これらは変数の値に応じてオン／オフされますから、その変数をバッファ
にローカルな変数にすれば、バッファごとに独立にオン／オフすることも可能
です。*Note Locals::。

補完示唆（icomplete）モードは、ミニバッファで入力中に補完機能が働いて
いるとき、どのような補完候補があるかを表示します。*Note Completion
Options::。

行番号（line-number）モードは、ポイントのある行の行番号を絶えずモード
行に表示します。*Note Mode Line::。

ミニバッファリサイズ（resize-minibuffer）モードは、打ち込んだテキスト
量に応じて自動的にミニバッファを広げます。*Note Minibuffer Edit::。

スクロールバー（scroll-bar）モードは、各ウィンドウにスクロールバーを付
けます（*Note Scroll Bars::）。メニューバー（menu-bar）モードは、各フ
レームにメニューバーを付けます（*Note Menu Bars::）。どちらのモードも、
Xウィンドウシステムを使っているときはデフォルトでオンになっています。

暫定マーク（transient-mark）モードでは、バッファの内容を変更するとマー
クは『不活性』になるので、そのあとでリージョンを対象とするコマンドを使
うとエラーになります。つまり、リージョンを対象とするコマンドを使うまえ
に、改めてマークを設定するか、不活性になったマークを『再度活性』にしま
す。暫定マーク（transient-mark）モードの利点は、（今のところXウィンド
ウシステムを使っているときのみ）Emacsがリージョンを強調表示することで
す。*Note Setting Mark::。

ほとんどのマイナモードには、コマンド名と同じ名前の変数があり、その変数
でモードを直接制御しています。つまり、その変数の値が`nil'以外ならモー
ドはオンであり、各マイナモードコマンドは変数の値を設定する動作をします。
たとえば、コマンド`outline-minor-mode'は、変数`outline-minor-mode'の値
を設定する動作を行います。つまり、この変数が、直接、上書き（overwrite）
モードをオン／オフしているのです。あるマイナモードがこのように動作する
かどうかは、`C-h v'を使ってその変数の説明文字列を参照してください。

これらのマイナモード変数は、Lispプログラムからモードをオン／オフするの
に有用です。また、ファイルのローカル変数リストとして指定するのも便利で
す。ただし、ローカル変数リストで設定する場合には、よく考えてください。
というのは、ほとんどのマイナモードはユーザーの好みの問題であり、同じファ
イルを編集する別のユーザーは好みが違うかもしれません。



