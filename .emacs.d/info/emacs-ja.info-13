Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Variables, Next: Keyboard Macros, Prev: Minor Modes, Up: Customization

変数
====

"変数"は値を持つLispシンボル（記号）です。そのシンボルの名前のことを、
変数名とも呼びます。変数名はファイルに入れられるどのような文字でも含む
ことができますが、習慣的には、変数名は英単語をハイフンでつなげたもので
す。変数には、その変数がどのような値を持ち、どのように使われるかを記述
した説明文字列を持たせることができます。

Lispではどの変数にどのような値でも格納できますが、Emacsの中ではほとん
どの変数はどのような値を持つかが決まっています。たとえば、ある変数はつ
ねに文字列である、別の変数は数値であるといった具合です。また、「これこ
れの機能はこの変数が`nil'以外のときにオンになる」といういい方もします。
その場合は、その変数に`nil'が格納されているときはその機能はオフですが、
それ以外の*どんな*値が格納されているときでもその機能はオンになります。
ですが、ある機能をオンにするために使う値として何か選ばなければなりませ
んから、`t'という値を使うのが習慣です。

Emacsは一般のLispプログラムと同様、内部で情報を保持するために数多くの
変数を使いますが、ユーザーにとって特に興味深い変数というのは、もっぱら
カスタマイズ向けに用意された変数だといえます。Emacsは（通常は）そのよ
うな変数の値を変更しません。かわりに、ユーザーが値を設定すると、その値
に応じてさまざまなEmacsコマンドのふるまいを変更したり制御したりできる
のです。これらの変数のことを"ユーザーオプション"といいます。ほとんどの
ユーザーオプションはこのマニュアルに記載してありますし、変数索引
（*Note Variable Index::）にも記載してあります。

ユーザーオプションであるような変数の例として`fill-column'があります。
この変数は、詰め込みコマンド（*Note Filling::）が使う右端の桁位置を
（左端から何文字右かを表す数値として）保持します。

* Menu:

* Examining::	        Examining or setting one variable's value.
* Easy Customization::
                        Convenient and easy customization of variables.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.



File: emacs-ja.info, Node: Examining, Next: Easy Customization, Up: Variables

変数の設定と参照
----------------

`C-h v VAR RET'
     変数VARの値と説明文字列を表示する（`describe-variable'）。
`M-x set-variable RET VAR RET VALUE RET'
     変数VARの値をVALUEに変更する。

特定の変数の値を見るには、`C-h v'（`describe-variables'）を使います。
このコマンドは、ミニバッファで補完機能付きで変数名を読み取ります。変数
の値と説明文字列の双方を表示します。たとえば、

     C-h v fill-column RET

とすると、つぎのように表示されます。

     fill-column's value is 75

     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

説明文の先頭にある`*'は、この変数がユーザーオプションであることを示し
ます。`C-h v'は、ユーザーオプションに限らず任意の変数を扱えます。

ユーザーオプションを設定するいちばん簡単な方法は`M-x set-variable'を使
うことです。このコマンドは、まずミニバッファで（補完機能付きで）変数名
を読み取り、つぎにミニバッファで変数に設定するLisp式を読み取ります。た
とえば、

     M-x set-variable RET fill-column RET 75 RET

とすると、`fill-column'に75を設定します。

`M-x set-variable'はユーザーオプションに対してだけ使えます。これに対し、
`setq'を使えばどの変数にでも値が設定できます。たとえば、`setq'を使って
`fill-column'に設定するにはつぎのようにします。

     (setq fill-column 75)

このような式を実行するには、`*scratch*'バッファにいき、式を打ち込んで
から`C-j'を打ちます。*Note Lisp Interaction::。

変数を設定することは、特記していない限り、他のカスタマイズ方法と同様に、
現在のEmacsセッションだけに影響します。



File: emacs-ja.info, Node: Easy Customization, Next: Hooks, Prev: Examining, Up: Variables

簡便なカスタマイズ方法
----------------------

変更したいユーザーオプション変数をみつけて値を変更する便利な方法は、
`M-x customize'を使うことです。このコマンドは"カスタマイズバッファ"を
作成し、そのバッファ内では論理的な順序に並べたEmacsのユーザーオプショ
ンを眺めてまわることができますし、さらに値を編集して設定できます。また、
カスタマイズバッファを使えば設定を恒久的なものとして保存もできます。
（まだこの機能で扱えないユーザーオプションもあるが、それらも扱えるよう
に現在作業中。）

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.



File: emacs-ja.info, Node: Customization Groups, Next: Changing an Option, Up: Easy Customization

カスタマイズグループ
....................

カスタマイズのために、ユーザーオプションを"グループ"にまとめてみつけや
すくしてあります。グループはさらに大きなグループにまとめられていて、い
ちばん大きな（すべてのグループを含む）グループは`Emacs'という名前です。

`M-x customize'は、トップレベルの`Emacs'グループおよびその直下の（第2
レベルの）グループを表示したカスタマイズバッファを作成します。その表示
はつぎのようになります。

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].

     Editing group: [Go to Group] 
     Basic text editing facilities.

     External group: [Go to Group] 
     Interfacing to external utilities.

     MORE SECOND-LEVEL GROUPS

     \- Emacs group end ------------------------------------------------/


この表示の先頭部分は、このバッファが`Emacs'グループの内容を表示してい
ることを記しています。残りのグループが表示されるのは、それらが`Emacs'
グループに含まれているからです。ただし、それらは字下げや「-」なしで表
示されていて、表示にはそれらのグループの内容が含まれては*いない*ことを
示しています。各グループの表示には1行の説明文字列が付随しています。ま
た、`Emacs'グループについては`[State]'行が付随しています。

カスタマイズバッファ内のテキストのほとんどは変更できませんが、一部分は
"編集可能フィールド"になっていて、変更できます。また、"アクティブフィー
ルド"という、その場所を"起動"するとなんらかの動作を行うような場所もあ
ります。アクティブフィールドを起動するには、`Mouse-1'でそこをクリック
するか、またはそこにポイントを持っていってRETを打ちます。

たとえば、第2レベルグループ中の`[Go to Group]'と記された部分はアクティ
ブフィールドです。`[Go to Group]'のフィールドを起動すると、そのグルー
プとそのグループの内容を表示する新しいカスタマイズバッファが作られ、そ
のグループと中身が表示されます。このフィールドは他のグループへのハイパー
テキストリンクの一種です。

`Emacs'グループそのものはユーザーオプションを1つも含んでいませんが、他
のグループにはあります。さまざまなグループを眺めてみると、興味を持って
カスタマイズしてみようと思うような機能に属するオプションやフェイスをみ
つけることができるでしょう。

カスタマイズグループ群の構造を概観するには、`M-x customize-browse'を使
います。このコマンドは、グループ名（とオプションやフェイス）とそれらの
構造だけを表示する特別なカスタマイズバッファを作ります。

このバッファ中では、グループの中身を見るには`[+]'のところを起動します。
グループの中身が見えるようになると、このボタンは`[-]'に変わります。こ
れを起動すると中身を（もとどおり）隠します。

各グループ、オプション、フェイスにはそれぞれ`[Group]'、`[Option]'、
`[Face]'と記されたアクティブフィールドがあります。それらを起動すると、
そのグループ／オプション／フェイスのみを表示した通常のカスタマイズバッ
ファが作成されます。そのバッファで値を設定します。



File: emacs-ja.info, Node: Changing an Option, Next: Face Customization, Prev: Customization Groups, Up: Easy Customization

オプションの変更
................

カスタマイズバッファでユーザーオプションがどのように見えるか、例をあげ
ましょう。

     Kill Ring Max: [Hide] 30
        [State]: this option is unchanged from its standard setting.
     Maximum length of kill ring before oldest elements are thrown away.

`[Hide]'に続くテキスト、つまり、`30'がオプションの現在の値を示していま
す。`[Hide]'ではなく`[Show]'と表示されていれば、値は隠されています。カ
スタマイズバッファでは、複数行にわたるような値は最初は隠されていて、
`[Show]'を起動すると表示されます。

オプション名に続く行はオプションの"カスタマイズ状態"を示しています。上
の例では、まだ変更していないと表示されています。行頭の`[State]'のとこ
ろがアクティブフィールドで、ここを`Mouse-1'かRETで起動するとさまざまな
操作を示すメニューが表示されます。これらの操作は変数をカスタマイズする
うえでとても重要です。

`[State]'のつぎの行には、そのオプションの説明文字列の先頭部分が表示さ
れます。1行に収まらない場合には、行末に`[More]'と表示されます。これを
起動すると説明文字列全体が表示されます。

`Kill Ring Max'に新しい値を設定するには、ポイントを値の位置へ持っていっ
て直接文字列を変更します。たとえば、`M-d'で現在の値を削除してから、設
定する数値を打ち込めばよいのです。

文字列を変更し始めると、`[State]'行の表示が変わって、値が編集されてい
ることを示すようになります。

     [State]: you have edited the value as text, but not set the option.

文字列を変更しただけでは、まだオプション変数の値は設定されません。値を
"設定する"には、`[State]'のところを起動して、`Set for Current Session'
を選択します。

値を設定すると、オプションの状態表示も対応して変わります。

     [State]: you have set this option, but not saved it for future sessions.

正しくない値を設定してしまう心配はありません。というのは、オプションの
設定時には、値の正しさを検査して、正しくない値は設定できないようになっ
ています。

ディレクトリ名、ファイル名、コマンド名である値やフィールドを編集すると
き、および、その他何であれ補完が定義されているものを編集するときは、
`M-TAB'（`widget-complete'）を打てば補完できます。

いくつかのオプションでは、正しい値としては決まった少数のものだけを使え
ます。そのようなオプションは、テキストとしては編集できません。かわりに
`[Value Menu]'というアクティブフィールドが値のまえに現れます。『オンか
オフ』だけの真偽値を持つオプションでは、アクティブフィールドは
`[Toggle]'と表示されていて、そこを起動するたびに値を反転できます。
`[Value Menu]'も`[Toggle]'もバッファを変更するだけです。値が実際に設定
されるのは`Set for Current Session'を起動したときです。

いくつかのオプションは、込み入った構造の値を持ちます。たとえば、
`load-path'は値としてディレクトリのリストを持ちます。これをカスタマイ
ズバッファに表示すると、つぎのようになります。

     Load Path:
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/leim
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp/gnus
     [INS]
        [State]: this item has been changed outside the customization buffer.
     List of directories to search for files to load....

リスト中の各ディレクトリがそれぞれ別の行に表示され、各行にはいくつかの
編集可能／アクティブフィールドがあります。

どのディレクトリ名も直接編集できます。リストからディレクトリを削除する
には、その行の`[DEL]'を起動します。リストに新しいディレクトリを追加す
るには、挿入したい箇所の`[INS]'を起動します。

`[Current dir?]'を起動すると、パスに特定のディレクトリを含めるのか、ま
たは、`nil'を含めるのかを切り替えられます。（探索パスにおける`nil'は、
『カレントディレクトリを探せ』という意味。）

2つの特別なコマンド、TABと`S-TAB'は、カスタマイズバッファ内での移動に
役立ちます。TAB（`widget-forward'）はつぎのアクティブ／編集可能フィー
ルドへ移動します。`S-TAB'（`widget-backward'）は、1つまえのアクティブ／
編集可能フィールドへ移動します。

編集可能フィールドでRETを打つと、TABと同様につぎのフィールドへ進みます。
なぜそうなっているかというと、編集可能フィールドを編集し終えると最後に
RETを打つ人が多いからです。編集可能フィールドに改行文字を入るには、
`C-o'か`C-q C-j'と打ちます。

オプションを設定すると、その値は現在のEmacsセッションだけに有効です。
その値を"保存"すると、将来のセッションでも有効になります。保存を行うと、
個人の`~/.emacs'ファイルにコードが追加されて、つぎにEmacsを起動したと
きにオプション変数の値を設定するようになります。オプションを保存するに
は、`[State]'を起動して`Save for Future Sessions'を選びます。

オプションを標準値に戻したければ、`[State]'を起動して`Reset to
Standard Settings'を選びます。実際にはつぎの3種類のリセット操作があり
ます。

`Reset'
     なんらかの修正を行ったが、まだオプションを設定していなければ、こ
     の操作により、カスタマイズバッファ上のテキストをオプションの現在
     値と一致させられる。

`Reset to Saved'
     この操作では、オプションの値を最後に保存した値に戻し、カスタマイ
     ズバッファ上のテキストもその値に合わせる。

`Reset to Standard Settings'
     この操作では、オプションを標準値に設定し、カスタマイズバッファ上
     のテキストもその値に合わせる。さらに、以前にそのオプションについ
     て保存した値もすべてもとに戻されるので、将来のEmacsセッションでも
     すべて標準値が使われるようになる。

グループの`[State]'はそのグループに属するもののどれかが編集された／設
定された／保存されたことを示します。`Set for Current Session'、`Save
for Future Sessions'、および各種の`Reset'をグループ全体に対して適用で
きます。これらの操作はグループおよびそのサブグループに属するすべてのオ
プションに対して適用されます。

カスタマイズバッファの先頭付近には、いくつかのアクティブフィールドを含
んだつぎのような行があります。

      [Set for Current Session] [Save for Future Sessions]
      [Reset] [Reset to Saved] [Reset to Standard]   [Bury Buffer]

`[Bury Buffer]'を起動すると、カスタマイズバッファを消します。他のフィー
ルドは、そのバッファに含まれている項目それぞれについてそれぞれ、設定、
保存、リセットを（それらの操作が適用可能なら）実行します。



File: emacs-ja.info, Node: Face Customization, Next: Specific Customization, Prev: Changing an Option, Up: Easy Customization

フェイスのカスタマイズ
......................

いくつかのカスタマイズグループは、ユーザーオプションに加えてフェイスも
含みます。グループの内容を表示したとき、オプションとフェイスの両方がカ
スタマイズバッファに現れます。フェイスの見え方は、たとえばつぎのように
なります。

     Custom Changed Face: (sample)
        [State]: this face is unchanged from its standard setting.
     Face used when the customize item has been changed.
     Attributes: [ ] Bold: [toggle] off
                 [X] Italic: [toggle] on
                 [ ] Underline: [toggle] off
                 [ ] Inverse-Video: [toggle] on
                 [ ] Foreground: black (sample)
                 [ ] Background: white (sample)
                 [ ] Stipple:  

フェイスの各属性はそれぞれが1行を占めます。属性のまえの`[X]'というフィー
ルドは、その属性が"オンになっている"かどうかを表示しています。`X'が表
示されていればオンになっています。そのフィールドを起動することでオン／
オフを反転できます。属性がオンになっている場合は、その属性の値をオプショ
ンと同様にして変更できす。

白黒ディスプレイでは、背景に設定可能な表示色は`black'、`white'、`gray'、
`gray1'、`gray3'のいずれかです。Emacsは表示色のかわりにドットパターン
で灰色の階調を表します。

フェイスを設定／保存／リセットするのは、オプションと同様にしてできます
（*Note Changing an Option::）。

フェイスでは、ディスプレイの種別ごとに異なる見え方を指定できます。たと
えば、あるフェイスをカラーディスプレイでは赤で表示し、白黒ディスプレイ
ではかわりにボールド体で表示するようにできます。あるフェイスに複数の見
え方を指定するには、`[State]'メニューを表示させて`Show Display Types'
を選びます。

フェイスの属性を設定するもっと基本的な方法は、`M-x modify-face'を使う
ことです。このコマンドは、まずフェイスの名前を聞いてきて、続いて属性を
1つずつ順に聞いてきます。表示色やパターンの属性では、その属性の現在の
値がデフォルトになっています。これらを変更したくなければ、単に、RETを
打てばよいのです。属性を空にしたければ`none'と打ちます。



File: emacs-ja.info, Node: Specific Customization, Prev: Face Customization, Up: Easy Customization

特定項目のカスタマイズ
......................

グループ構造を1段ずつ降りていって目指すオプションを探すかわりに、カス
タマイズしたいオプション／フェイス／グループの名前を直接に指定すること
もできます。

`M-x customize-option RET OPTION RET'
     指定したオプションOPTIONだけを含むカスタマイズバッファを開く。
`M-x customize-face RET FACE RET'
     指定したフェイスFACEだけを含むカスタマイズバッファを開く。
`M-x customize-group RET GROUP RET'
     指定したグループGROUPだけを含むカスタマイズバッファを開く。
`M-x customize-apropos RET REGEXP RET'
     指定した正規表現REGEXPに一致するすべてのオプション／フェイス／グ
     ループを含むカスタマイズバッファを開く。
`M-x customize-changed-options RET VERSION RET'
     EmacsのバージョンVERSION以降に意味が変更されたすべてのオプション／
     フェイス／グループを含むカスタマイズバッファを開く。
`M-x customize-saved'
     カスタマイズバッファで保存したすべてのオプションとフェイスを含む
     カスタマイズバッファを開く。
`M-x customize-customized'
     カスタマイズしたが、まだ保存していないすべてのオプションとフェイ
     スを含むカスタマイズバッファを開く。

名前のわかっているオプション変数をカスタマイズバッファで変更したい場合
は、コマンド`M-x customize-option'で直接名前を指定します。これにより、
そのオプションだけを含むカスタマイズバッファが現れます。編集／設定／保
存はこれまで説明したとおりに行いますが、設定の対象になるのは指定したオ
プションだけです。

同様にして、`M-x customize-face'ではフェイス名を指定して変更できます。

同様に、`M-x customize-group'ではグループ名を指定してカスタマイズバッ
ファを開くことができます。そのカスタマイズバッファには、指定したグルー
プに直接含まれているオプション、フェイス、他の（下位の）グループが現れ
ます。ただし、サブグループの内容は最初は隠されています。それらを表示し
たい場合は、通常どおり`[Show]'を起動します。

`M-x customize-apropos'を使うと、カスタマイズするものをもっと細かく制
御できます。このコマンドでは引数として正規表現を指定し、それに一致する
すべてのオプション／フェイス／グループを含んだカスタマイズバッファが現
れます。空の正規表現を指定すると、*すべての*オプション／フェイス／グルー
プを含むカスタマイズバッファができます（ただしすごく時間がかかる）。

Emacsの新版へ更新したときには、新しいオプション、意味やデフォルト値が
変更されたオプションをカスタマイズしたいはずです。それには、`M-x
customize-changed-options'を使い、ミニバッファで以前の版のEmacsのバー
ジョン番号を指定します。すると、指定したバージョン以降に定義が変更され
たすべてのオプション（とグループ）を含んだカスタマイズバッファを作りま
す。

オプションを変更したあとでまちがったと気づいたときは、変更したものを再
検討するために2つのコマンドが使えます。保存してしまったオプションにつ
いては`customize-saved'を、変更したけれどまだ保存していないオプション
については`M-x customize-customized'を使います。



File: emacs-ja.info, Node: Hooks, Next: Locals, Prev: Easy Customization, Up: Variables

フック
------

"フック"とはある特定の状況で既存のプログラムから呼び出される関数／関数
群を格納しておく変数をいいます。Emacsには、カスタマイズ用のフックが数
多くあります。

Emacs中のほとんどのフックは"ノーマルフック"です。これらの変数は、引数
なしで呼び出される関数のリストを保持します。ほとんどのフックがノーマル
フックなのは、それらを統一的に扱えるからです。Emacsでは、`-hook'で終わ
る名前の変数はすべてノーマルフックです。

ほとんどのメジャーモードは初期設定の最終段階でフックを実行します。モー
ドが設定したローカル変数をフックで変更すればよいので、モードのふるまい
をユーザーがカスタマイズすることが容易になります。しかし、フックはそれ
以外の場面でも使われます。たとえば、`suspend-hook'は、Emacsが休止する
直前に実行されます（*Note Exiting::）。

ノーマルフックにフック関数を追加するお勧めのやり方は、`add-hook'を呼ぶ
ことです。フック関数としては任意のLisp関数を使えます。たとえば、テキス
ト（text）モードやテキスト（text）モードを基にしているモードにおいて、
自動的に自動詰め込み（auto-fill）モードをオンにするにはつぎのようにし
ます

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

つぎの例は、Cコードの字下げをカスタマイズするのにフックを使う方法を示
します。（誰でも字下げには独自の好みがある）。ここでは、フック関数は名
前のないラムダ式です。

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
     		       empty-defun-braces
     		       defun-close-semi))
         (c-offsets-alist . ((arglist-close . c-lineup-arglist)
     			(substatement-open . 0)))))

     (add-hook 'c-mode-common-hook
       (function (lambda ()
         (c-add-style "my-style" my-c-style t))))

どの順番で実行されても大丈夫なようにフック関数を設計するのが最良です。
実行順序に依存するのは、『事故を呼び込む』ようなものです。しかし、順番
は予測できます。もっとも最近に追加したフック関数ほど先に実行されます。



File: emacs-ja.info, Node: Locals, Next: File Variables, Prev: Hooks, Up: Variables

ローカル変数
------------

`M-x make-local-variable RET VAR RET'
     変数VARがカレントバッファでローカルに値を持つようにする。
`M-x kill-local-variable RET VAR RET'
     変数VARがカレントバッファではグローバル値を使うようにする。
`M-x make-variable-buffer-local RET VAR RET'
     変数VARを、値を設定したときにその時点のカレントバッファでローカル
     に値を持つようにする。

ほとんどの変数はEmacsバッファに対して"ローカル"にできます。つまり、そ
の変数のバッファ中での値は他のバッファでの値とは独立になります。いくつ
かの変数はつねにすべてのバッファにおいてローカルです。それ以外の変数は
すべて、"グローバル"な値、つまりその変数をローカルにしていないすべての
バッファにおいて共有される値を持ちます。

`M-x make-local-variable'は変数名を受け取り、その変数をカレントバッファ
においてローカルにします。それ以降、このバッファ内でその変数を変更して
も他のバッファには影響しませんし、その変数のグローバルな値を変更しても
このバッファ内での値には影響しません。

`M-x make-variable-buffer-local'は、変数名を受け取り、値が設定されると
その変数が自動的にローカルになるようにします。もっと正確にいえば、この
ように特別な印を変数に付けておくと、通常の方法で変数に値を設定するとき
にはつねにまず`make-local-variable'が実行されるようになるのです。この
ような変数を"バッファごとの変数"と呼びます。

メジャーモード（*Note Major Modes::）では、変数を設定するまえにつねに
ローカルにします。このため、あるバッファでメジャーモードを変更しても他
のバッファには影響が及びません。マイナモード（*Note Minor Modes::）も
同様で、通常、マイナモードごとにオン／オフを制御する変数があり、その変
数が`nil'以外のときにそのマイナモードはオンになります。ほとんどのマイ
ナモードでは、その制御用変数はバッファごとの変数です。

Emacsには、つねにバッファごとの変数であるような変数が数多くあります。
`abbrev-mode'、`auto-fill-function'、`case-fold-search'、
`comment-column'、`ctl-arrow'、`fill-column'、`fill-prefix'、
`indent-tabs-mode'、`left-margin'、`mode-line-format'、
`overwrite-mode'、`selective-display-ellipses'、`selective-display'、
`tab-width'、`truncate-lines'がそのような変数です。これ以外にもつねに
各バッファでローカルな変数はありますが、それらは内部作業用の変数です。

いくつかの変数はディスプレイに対してローカルになっているため、バッファ
に対してローカルにはできません（*Note Multiple Displays::）。これらの
変数をバッファにローカルにしようとすると、エラーメッセージが表示されま
す。

`M-x kill-local-variable'は、変数名を受け取り、その変数をカレントバッ
ファに対してローカルでなくします。それ以降そのバッファでは、その変数の
グローバルな値が使われます。メジャーモードを設定すると、"つねにローカ
ル"と印が付いた少数の特別な変数を除いて、そのバッファにローカルなすべ
ての変数をローカルでなくします。

ある変数がカレントバッファでローカルか否かに係わらずその変数のグローバ
ルな値を設定したければ、`setq-default'を使います。これは`setq'のように
使われますが、（たとえローカルな値があったとしても）つねにグローバルな
値のほうを設定します。その変数がローカルな値を持っている場合、新たに設
定したグローバルな値は別のバッファに切り替えるまでは参照できません。以
下に例をあげます。

     (setq-default fill-column 75)

`setq-default'は、`make-variable-buffer-local'で印を付けた変数のグロー
バルな値を設定する唯一の方法です。

Lispプログラム中では、変数のデフォルト値を参照するためには
`default-value'を使えます。この関数はシンボルを引数とし、その変数のデ
フォルト値を返します。引数は評価されるので、普通は引数をクォートします。
たとえば、`fill-column'のデフォルト値を取得するにはつぎのようにします。

     (default-value 'fill-column)



File: emacs-ja.info, Node: File Variables, Prev: Locals, Up: Variables

ファイルにローカルな変数
------------------------

Emacsでファイルを編集する際に、そのファイルに対応したローカル変数とそ
の値を指定することができます。Emacsはファイルを訪問すると、ローカル変
数指定の有無を検査し、あれば指定された変数を自動的にバッファにローカル
にして、その値をファイルで指定された値に設定します。

ローカル変数とその値を設定するには2つの方法があります。1つはファイルの
先頭行に書くことで、もう1つはローカル変数リストを書くことです。先頭行
に書く場合は、たとえばつぎのようにします。

     -*- mode: MODENAME; VAR: VALUE; ... -*-

変数とその値を「:」で区切った対を「;」で区切って並べ、いくつでも指定で
きます。`mode: MODENAME;'はメジャーモードを指定するもので、行の最初に
ある必要があります。VALUEは評価されずに書かれているとおりのまま使われ
ます。以下は、Lispモードで2つの変数に数値を設定する例です。

     ;; -*-mode: Lisp; fill-column: 75; comment-column: 50; -*-

この方法では、ファイルのコーディングシステムも指定できます。つまり、
`coding'という名前の『変数』に値を指定すればよいのです。『値』は、
Emacsが認識できるコーディングシステム名である必要があります。*Note
Coding Systems::。

一方、"ローカル変数リスト"はファイルの末尾（最後のページ）に置きます。
（最後のページにはローカル変数リストだけを置くというのを勧めます。）ロー
カル変数リストは`Local Variables:'という内容を含む行で始まり、`End:'と
いう内容を含む行で終ります。これらの行のあいだに、1つの変数につき1行ず
つ、`VARIABLE: VALUE'という形で変数の名前と値を指定します。VALUEは評価
されずにファイルに書かれたとおりにそのまま使われます。ファイルにローカ
ル変数リストと`-*-'の行が両方含まれていた場合には、Emacsはまず`-*-'の
行を*すべて*処理してから、続いてローカル変数リストの内容を*すべて*処理
します。

以下にローカル変数リストの例を示します：

     ;;; Local Variables: ***
     ;;; mode:lisp ***
     ;;; comment-column:0 ***
     ;;; comment-start: ";;; "  ***
     ;;; comment-end:"***" ***
     ;;; End: ***

上の例では、各行は`;;;'で始まり`***'で終っています。Emacsはこれらの接
頭辞と接尾辞をリストの最初の内容に基づいて認識します。つまり、特別な文
字列`Local Variables:'の前後の文字列を、それぞれ、接頭辞、接尾辞とみな
し、それ以降の行についてはこの接頭辞と接尾辞を無視します。

接頭辞と接尾辞を使う主な理由は、ローカル変数リストをコメントの中に入れ
ることで、そのファイルを読み込む他のプログラムを困惑させないようにする
ことです。上の例では、コメントが`;;;'で始まり`***'で終るような言語を想
定しています。変数`comment-start'と`comment-end'のローカルな値で、この
ような変な構文に対処するようにEmacsをカスタマイズするのです。必要ない
のであれば、接頭辞（と接尾辞）は使わないでください。

ローカル変数リストにおいては、2つの変数名が特別な意味を持ちます。変数
`mode'に対する値は、実際にはメジャーモードを設定します。変数`eval'に対
する値は、式として評価されますが、その結果は捨てられます。`mode'と
`eval'は本当の変数ではなく、他の状況でこれらの名前の変数に値を設定して
もなんら特別な意味を持ちません。メジャーモードを設定するために`mode'を
指定する場合は、ローカル変数リストの先頭に書く必要があります。

仮想的な『変数』`mode'は、メジャーモードだけでなくマイナモードを設定す
るのにも使えます。実は、この指定は2回以上使うことができて、最初はメジャー
モードを設定し、それ以降は（それぞれ）マイナモードを設定します。しかし、
マイナモードはユーザーの好みに応じて選ぶものですから、普通はファイルで
マイナモードを指定するべきではないでしょう。

たとえば、ローカル変数リストで自動詰め込み（auto-fill）モードをオンに
したいと思うかもしれませんが、それはまちがいです。自動詰め込みにするか
どうかは、個人の好みの問題であり、ファイルの中身によって決まるものでは
ないからです。ある種別のファイルでいつも自動詰め込みにしたければ、個人
の`.emacs'ファイルで（状況に応じて）自動詰め込み（auto-fill）モードを
オンにするようなメジャーモードのフックを設定してください（*Note Init
File::）。ローカル変数リストで他人に好みを押し付けてはいけません。

ローカル変数リストは、ファイルの末尾から3000文字以内にある必要があり、
ファイルがページに分かれている場合には最後のページにある必要があります。
これらが守られていないと、Emacsはローカル変数リストがあることを認識し
ません。これらの規則の目的は、最後ではないページに偶然`Local
Variables:'があってもEmacsが誤認しないようにすることと、全体が1ページ
でローカル変数リストを持たない長いファイルを訪問するときでもファイル全
体を探さなくてもすむようにするためです。

バッファのローカル変数やメジャーモードを、ローカル変数リストがあるとき
にはそれによる指定も含めて、ファイル名とファイルの内容に基づいたものに
リセットしたければ、`normal-mode'コマンドを使ってください。*Note
Choosing Modes::。

変数`enable-local-variables'は、ファイル中のローカル変数指定を処理する
か否かを制御します。つまり、ローカル変数指定を無視するようにもできます。
デフォルトは`t'で、ファイル中のローカル変数指定を処理します。値を`nil'
にすると、ファイル中のローカル変数指定を無視します。これら以外の値の場
合は、ファイル中にローカル変数指定があると、その内容を表示して処理する
かどうか問い合わせます。

仮想的な『変数』`eval'といくつかの（実在する）変数に対する指定は、ある
種の危険性をもたらします。他人のファイルを訪問したとき、そこに書かれて
いるローカル変数指定によってあなたが使っているEmacsのふるまいがどのよ
うにでも変更できるからです。このため、オプション`enable-local-eval'に
より、変数`eval'、さらに、`-hook'、`-hooks'、`-function'、`-functions'
という名前で終る変数、および、他のいくつかの変数に対するローカル変数指
定を処理するかどうか制御できるようになっています。
`enable-local-variables'と同じように指定できる値は3種類あって、`t'、
`nil'、これら以外です。デフォルトは`maybe'で、これは`t'でも`nil'でもあ
りませんから、Emacsはこれらのローカル変数指定があるときは確認を求めて
きます。



File: emacs-ja.info, Node: Keyboard Macros, Next: Key Bindings, Prev: Variables, Up: Customization

キーボードマクロ
================

"キーボードマクロ"は、ユーザーが一連のキー操作に基づいて定義したコマン
ドです。たとえば、`C-n C-d'という打鍵を40回繰り返す必要があるとわかっ
たら、`C-n C-d'を実行するキーボードマクロを定義し、それを40回繰り返す
指定をして呼び出すと迅速に作業できます。

`C-x ('
     キーボードマクロの定義を開始する（`start-kbd-macro'）。
`C-x )'
     キーボードマクロの定義を終了する（`end-kbd-macro'）。
`C-x e'
     もっとも最近のキーボードマクロを実行する（`call-last-kbd-macro'）。
`C-u C-x ('
     もっとも最近のキーボードマクロを再実行したうえで、その定義にキー
     を追加する。
`C-x q'
     キーボードマクロの実行中にこの場所に到達したら、実行の確認を求め
     る（`kbd-macro-query'）。
`M-x name-last-kbd-macro'
     もっとも最近に定義したキーボードマクロに（現在のEmacsセッションだ
     けで有効な）コマンド名を与える。
`M-x insert-kbd-macro'
     キーボードマクロの定義をLispコードとしてバッファに挿入する。
`C-x C-k'
     まえに定義したキーボードマクロを編集する（`edit-kbd-macro'）。
`M-x apply-macro-to-region-lines'
     リージョン内の各行に対して、最後に定義したキーボードマクロを実行
     する。

キーボードマクロは、それがLispではなくEmacsのコマンド言語で記述されて
いるという点で、通常のEmacsコマンドとは違っています。このため、キーボー
ドマクロは初心者でも簡単に作れ、間に合わせとして定義するのにも向いてい
ます。しかし、Emacsのコマンド言語は、プログラム言語として知的で汎用的
な動作を記述できるほど強力ではありません。そういう場合には、Lispを使っ
てください。

キーボードマクロは、定義内容のコマンド列を実際に実行しながら定義できま
す。いいかえれば、キーボードマクロを定義しているときに、その定義の第1
回目の実行が行われることになります。ですから、コマンドがどのように動作
するかを目で見ながら確認でき、頭の中だけで動作を考えるよりも楽に定義で
きます。コマンド列の最後まできてキーボードマクロを定義し終ると、第1回
目の実行も終ったことになります。そのあとは、マクロを呼び出すことで何回
でもそのコマンド列全体を実行できます。

* Menu:

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Making keyboard macros do different things each time.



File: emacs-ja.info, Node: Basic Kbd Macro, Next: Save Kbd Macro, Up: Keyboard Macros

基本的な使い方
--------------

キーボードマクロの定義を開始するには、`C-x ('コマンド
（`start-kbd-macro'）を打ってください。それ以降打鍵するものは通常どお
り実行されますが、それと同時にキーボードマクロの定義として取り込まれま
す。モード行にもそのことを表す`Def'という表示が現れます。定義の終りま
できたら、`C-x )'（`end-kbd-macro'）を打ち込むとキーボードマクロの定義
が完了します（`C-x )'はマクロの内容には含まれません！）。たとえば、

     C-x ( M-f foo C-x )

のように打鍵すると、1単語分ポイントを前進させ文字列`foo'をバッファに挿
入する、キーボードマクロを定義できます。

定義し終えたキーボードマクロは、コマンド`C-x e'（`call-last-kbd-macro'）
で再実行できますし、数引数として反復回数を指定することで多数回実行する
こともできます。`C-x )'にも引数として反復回数を指定でき、その場合は定
義完了とともにただちに指定した回数だけキーボードマクロを実行しますが、
定義しているとき（実行しているので）を1回目の実行として数えます。です
から、`C-u 4 C-x )'と打つと、キーボードマクロをただちに3回実行します。
`C-x e'や`C-x )'に反復回数0を指定すると、キーボードマクロを無限回、つ
まり、エラーが発生するか、`C-g'（MS-DOSでは`C-BREAK'）が打鍵されるまで、
繰り返し実行します。

テキスト上の規則的にとびとびの位置に対して操作を行いたい場合には、キー
ボードマクロを定義するときに、つぎに適用したい位置までポイントを移動す
るコマンドを含めておきます。たとえば、各行について変更を行いたければ、
ポイントを行頭に置いてからキーボードマクロを定義し始め、最後にポイント
をつぎの行の行頭に置いたところで定義を終えます。キーボードマクロを繰り
返し実行すると、次々と連続する行に対して操作を実行できます。

キーボードマクロの定義を完了してしまったあとでも、`C-u C-x ('を打ち込
めば、その定義の末尾に内容を追加できます。このコマンドは、`C-x ('に続
いて現在のキーボードマクロの定義内容全体を打鍵したのと同じ効果を持ちま
す。その結果、定義されたとおりにマクロを再実行します。

キーボードマクロの中で、通常のキーと同様にファンクションキーを使うこと
もできます。マウスイベントを使うことさえできますが、その場合は注意して
ください。キーボードマクロはマウスイベントを再現しますが、マウス位置と
しては最初にキーボードマクロを定義したときの位置がそのまま使われます。
その結果は予想し難いものになります。（現在のマウス位置を使っても、結果
はさらに予想し難いものになる。）

キーボードマクロの中で必ずうまくいくとは限らないことの1つに、`C-M-c'
（`exit-recursive-edit'）コマンドがあります。このコマンドがマクロの中
で開始させた再帰編集を終らせる場合には、期待どおりに動くでしょう。しか
し、このコマンドがキーボードマクロを起動するまえに入っていた再帰編集を
終らせるとすると、その終了処理の過程でキーボードマクロの実行も終らせて
しまいます。

定義済みのキーボードマクロを編集するには、`C-x C-k'（`edit-kbd-macro'）
と打ちます。このコマンドに続けてマクロを起動する打鍵、つまり、`C-x e'
や`M-x NAME'などのキー列を入れます。すると、キー列に対応するキーボード
マクロの内容が整形されて特別な編集用メジャーモードのバッファに入ります。
そのバッファ中で`C-h m'と打つと編集方法が表示されます。編集し終えたら
`C-c C-c'と打ちます。

コマンド`M-x apply-macro-to-region-lines'は最後に定義されたキーボード
マクロを現在のリージョンの各行に対して実行します。つまり、各行について、
行頭にポイントを置いてからキーボードマクロを実行します。



File: emacs-ja.info, Node: Save Kbd Macro, Next: Kbd Macro Query, Prev: Basic Kbd Macro, Up: Keyboard Macros

キーボードマクロの命名と保存
----------------------------

新たにつぎのキーボードマクロを定義したあとでも現在のキーボードマクロを
使いたいなら、`M-x name-last-kbd-macro'でキーボードマクロに名前を付け
ておく必要があります。このコマンドは、ミニバッファで名前を読み取り、そ
の名前でキーボードマクロを実行できるように定義します。マクロ名はLispシ
ンボルであり、このように定義されているので、`M-x'で呼び出したり
`global-set-key' （*Note Keymaps::）でキーに対応付けたりできる有効なコ
マンド名になります。その名前にキーボードマクロ以外のものがすでに定義さ
れていると、エラーメッセージが表示され何の変更も起こりません。

キーボードマクロにコマンド名を付けると、その定義をファイルに保存できま
す。そうすると、別の編集セッションで使えるようになります。まず、定義を
保存したいファイルを訪問してから、つぎのコマンドを使ってください。

     M-x insert-kbd-macro RET MACRONAME RET

このコマンドは、実行するとそのキーボードマクロと同じ動作を行うLispコー
ドをバッファに挿入します。（`insert-kbd-macro'がLispコードの生成を代行
するので、Lispコードを理解する必要はない。）そうしたら、このファイルを
保存します。`load-file'（*Note Lisp Libraries::）でファイルをロードで
きます。保存するファイルとして`~/.emacs'（*Note Init File::）を使えば、
Emacsを起動するとつねにそのマクロが定義されます。

`insert-kbd-macro'に数引数を指定すると、さらに（もしあれば）キーボード
マクロに割り当てたキーを記録するLispコードが追加されるので、ファイルを
ロードしたときに同じキーがマクロに割り当てられます。



File: emacs-ja.info, Node: Kbd Macro Query, Prev: Save Kbd Macro, Up: Keyboard Macros

変化のあるマクロの実行
----------------------

`C-x q'（`kbd-macro-query'）を使うと、`query-replace'と同様に変更する
かどうか尋ねてくるキーボードマクロを作れます。キーボードマクロを定義し
ているときに、問い合わせが起きてほしい箇所で`C-x q'を打ちます。マクロ
の定義中は`C-x q'は何の動作もしませんが、あとでマクロを実行させたとき
には`C-x q'の箇所で処理を続けるかどうか尋ねてくるようになります。

`C-x q'の問い合わせに対する有効な応答は、SPC（または`y'）、DEL（または
`n'）、RET（または`q'）、`C-l'、`C-r'です。これらの意味は
`query-replace'と同じですが、`query-replace'のすべての応答が意味を持つ
とは限りません。

SPCは続行、DELはこの回の反復の残りを飛ばしてただちにつぎの反復に進むと
いう意味になります。RETではこの回の反復の残りも以後の反復もすべて取り
消します。`C-l'は画面を再描画し、再度どうするかを問い合わせてきます。

`C-r'で再帰編集レベルに入るので、そこでキーボードマクロにはない編集を
行えます。`C-M-c'で再帰編集から抜けると、再度どうするかを聞いてきます。
ここでSPCを打つと、キーボードマクロの残りの部分が実行されます。キーボー
ドマクロの残りの部分が望みどおりの動作をする状態にポイントやテキストを
保っておくのは、ユーザーの責任です。

`C-u C-x q'、つまり、数引数を指定した`C-x q'は、まったく違った動作をし
ます。キーボードマクロの定義中でも実行中でも、キーボードから入力を受け
付ける再帰編集に入ります。定義中の場合、再帰編集の中で行った操作はマク
ロの一部にはなりません。実行中の場合、再帰編集の中で各反復ごとに個別の
編集を行う機会が得られます。*Note Recursive Edit::。



File: emacs-ja.info, Node: Key Bindings, Next: Keyboard Translations, Prev: Keyboard Macros, Up: Customization

キーバインディングのカスタマイズ
================================

本節では、コマンドをキーに対応付ける"キーバインディング"と、キーバイン
ディングを記録する"キーマップ"について説明します。また、キーバインディ
ングをカスタマイズする方法についても説明します。

コマンドとは、対話利用向けに定義されたLisp関数であることを思い出してく
ださい。コマンドには、他のLisp関数と同様、通常、英小文字とハイフンから
成る関数名前が付いています。

* Menu:

* Keymaps::             Generalities.  The global keymap.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major and minor modes have their own keymaps.
* Minibuffer Maps::     The minibuffer uses its own local keymaps.
* Rebinding::           How to redefine one key's meaning conveniently.
* Init Rebinding::      Rebinding keys with your init file, `.emacs'.
* Function Keys::       Rebinding terminal function keys.
* Named ASCII Chars::   Distinguishing TAB from `C-i', and so on.
* Non-ASCII Rebinding:: Rebinding non-ASCII characters such as Latin-1.
* Mouse Buttons::       Rebinding mouse buttons in Emacs.
* Disabling::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.



File: emacs-ja.info, Node: Keymaps, Next: Prefix Keymaps, Up: Key Bindings

キーマップ
----------

キー列とコマンド関数との対応は"キーマップ"と呼ばれるデータ構造に保持さ
れています。Emacsには数多くのキーマップがあり、それぞれが特定の場面で
使われます。

"キー列"（または単に"キー"）とは、ひとまとまりの意味を持つ"入力イベン
ト"の並びをいいます。入力イベントは、文字、ファンクションキー、マウス
ボタン、つまり、端末から計算機に送ることができるすべての入力から成りま
す。キー列の意味付けは、どのコマンドを実行するかを表す"バインディング"
によって決まります。キーマップの役割は、これらのバインディングを保持す
ることです。

"グローバル"キーマップはもっとも重要なキーマップですが、それはグローバ
ルキーマップがつねに有効だからです。グローバルキーマップは基本
（fundamental）モードのキーを定義します。つまり、そこに含まれる定義の
大部分は、ほとんどまたはすべてのメジャーモードに共通のものです。各メ
ジャー／マイナモードは、グローバルキーマップの定義の一部を置き換えるよ
うな独自のキーマップを持つことができます。

たとえば、`g'のような自己挿入文字を打つとその文字がバッファに挿入され
るのは、グローバルキーマップでこれらのキーが`self-insert-command'に対
応付けられているからです。また、`C-a'のような標準の編集コマンドも、そ
の意味付けはグローバルキーマップに書かれています。`M-x global-set-key'
のようなバインディングを変更するコマンド群は、グローバルキーマップの適
切な箇所に新しいバインディングを書き込みます。

メタ文字はやや違った動作になります。Emacsでは、メタ文字はESCで始まる文
字列に変換されます。ですから、`M-a'という入力はつねにEmacsの中では`ESC
a'に置き換えられて処理されます。つまり、メタ文字は単一の入力イベントで
すが、キーバインディングの観点では2つのイベントとして扱われます。こう
なっている理由は歴史的なもので、将来は変わる可能性もあります。

最近のほとんどのキーボードには、文字キーの他にファンクションキーがあり
ます。ファンクションキーは文字キーと同様に入力イベントを送出し、キーマッ
プはそれに対応するバインディングを保持することができます。

多くの端末では、ファンクションキーを打つとコンピュータには一連の文字列
が送られます。具体的にどのファンクションキーがどんな文字列を送るかは端
末によってまちまちです。（多くの場合、文字列は`ESC ['で始まる。）Emacs
が使用中の端末種別を正しく認識していれば、キー列（の先頭でだけでなく）
に現れるファンクションキーに対応した文字列を正しく判別できます。ですか
ら、多くの場合、ファンクションキーの打鍵も1つの入力イベントとして直接
Emacsに送られているとみなして、文字列としての表現形式は無視してかまい
ません。

マウスボタンも入力イベントを発生させます。これらのイベントには、追加デー
タ、つまり、ボタンを押したり放したりしたときのウィンドウとその中での位
置、時刻が付属しています。ただし、キーバインディングに関しては、どのボ
タンが使われたかだけが問題となります。残りの情報は、コマンドがこれらの
情報を参照する場合だけ意味を持ちます。（通常、マウスから起動できるコマ
ンドは、これらの情報を参照する。）

キーマップは1つのイベントに対する定義のみを保持します。複数キーの列か
ら成る複数のイベントの解釈には、キーマップの連鎖が使われます。最初のキー
マップが最初のイベントの定義を保持し、その定義がつぎのキーマップになっ
ていて、2番目のイベントの定義を保持し、というようになっています。

キー列にはファンクションキーと文字キーとが混ざっていてもかまいません。
たとえば、`C-x SELECT'というのも許されます。SELECTをプレフィックスキー
として定義しておけば、`SELECT C-n'というのも許されます。マウスイベント
とキーボードイベントを混ぜることさえ可能ですが、そうすると打ち込むのが
面倒ですからお勧めしません。

ユーザーはどんなキー列でも再定義して利用できますが、`C-c'に続けて1文字
というキー列だけを使うのが最善です。このキー列は『ユーザー定義のために
予約』されていて、正しく設計されたEmacsの各種拡張とは衝突しないように
なっているからです。F5からF9までのファンクションキーもユーザー定義のた
めに予約してあります。これ以外のキー列を再定義すると、同じキーを再定義
する拡張やメジャーモードによってあなたの定義が上書きされてしまう可能性
があります。



File: emacs-ja.info, Node: Prefix Keymaps, Next: Local Keymaps, Prev: Keymaps, Up: Key Bindings

プレフィックスキーマップ
------------------------

`C-x'やESCのようなプレフィックスキーはそれぞれ専用のキーマップを持って
いて、そこにはそのプレフィックスキーに続くイベントの定義が保持されてい
ます。

プレフィックスキーの定義は、通常、それに続くイベントの定義を検索するた
めのキーマップです。あるいは、プレフィックスキーの定義がLispシンボルで
あって、その関数の定義がキーマップというのもあります。どちらでも効果は
同じですが、後者では、プレフィックスキーにコマンド名を与えてその用途を
示すことができます。このため、`C-x'にバインドされているのはシンボル
`Ctl-X-Prefix'であり、その関数定義は`C-x'コマンド群に対応するキーマッ
プです。`C-c'、`C-x'、`C-h'、ESCはグローバルマップでプレフィックスキー
として定義されていますから、これらはつねにプレフィックスキーとして使用
できます。

通常のプレフィックスキーに加えて、メニューバーを表す『仮想的なプレフィッ
クスキー』があります。メニューバーのキーバインディングに関する特別な点
については*Note メニューバー: (elisp)Menu Barを参照してください。ポッ
プアップメニューを表示させるマウスボタンイベントもまた、プレフィックス
キーです。こちらの詳細については*Note メニューキーマップ: (elisp)Menu
Keymapsを参照してください。

決まった変数に格納されているプレフィックスキーマップもあります。

   * `ctl-x-map'は`C-x'に続くキーを探すためのマップを納めた変数名。
   * `help-map'は`C-h'に続くキーを探すためのマップを納めた変数名。
   * `esc-map'はESCに続くキーを探すためのマップを納めた変数名。つまり、
     すべてのメタ文字は実際にはこのマップで定義されている。
   * `ctl-x-4-map'は`C-x 4'に続くキーを探すためのマップを納めた変数名。
   * `mode-specific-map'は`C-c'に続くキーを探すためのマップを納めた変
     数名。



File: emacs-ja.info, Node: Local Keymaps, Next: Minibuffer Maps, Prev: Prefix Keymaps, Up: Key Bindings

ローカルキーマップ
------------------

これまではグローバルキーマップの諸側面について説明しました。メジャーモー
ド固有のキーバインディングを"ローカルキーマップ"に定義することで、各メ
ジャーモードはEmacsの動作を変更します。たとえば、Cモードでは、TABをCの
コードの現在行を字下げする機能に差し替えます。バッファ内の一部のテキス
トで、そのバッファのメジャーモードのかわりとなる固有のキーマップを指定
することもできます。

マイナモードもローカルキーマップを持てます。その場合、マイナモードが生
きているときには、そのキーマップがメジャーモードのローカルキーマップや
グローバルキーマップに優先します。

Lispモードおよびその他のいくつかのメジャーモードのローカルキーマップは、
そのモードを使っていないときでもつねに存在します。これらのキーマップは、
`lisp-mode-map'などの変数に格納されています。さほど頻繁に使われないメ
ジャーモードの場合は、そのモードがセッションの中で初めて起動されたとき
にローカルキーマップが作られます。これは、メモリを節約するためです。こ
のようなモードのキーマップを変更したい場合には、当該メジャーモードの"
モードフック"を使う必要があります（以下を参照）。

すべてのマイナモードのキーマップは、あらかじめ作られています。マイナモー
ドのキーマップ作成をそのマイナモードが最初に起動されるまで遅延させる方
法はありません。

ローカルキーマップでは、その中のあるキーの定義をプレフィックスキーマッ
プとすることで、そのキーをローカルなプレフィックスキーとして再定義でき
ます。そのキーがグローバルにもプレフィックスキーであると定義されている
なら、ローカルキーマップとグローバルキーマップの内容は実質的に統合され、
プレフィックスキーに続くイベントは両方のキーマップで検索されます。した
がって、あるモードのローカルキーマップが`C-c'を別のキーマップとして定
義し、そのキーマップでは`C-z'をコマンドとして定義すると、これらによっ
て`C-c C-z'のローカルな意味が与えられます。しかし、これは`C-c'で始まる
他のキー列には影響しません。あるキー列が独自のローカルなバインディング
を持たなければ、グローバルなバインディングが意味を持つからです。

いいかえれば、Emacsが複数イベントから成るキー列を扱う方法は、複数のキー
マップから1つずつ、キー列全体に一致するバインディングを探すのです。ま
ず、マイナモードが生きていればそのキーマップを検索し、つぎにメジャーモー
ドのキーマップを検索し、最後にグローバルキーマップを検索します。これは
厳密にはキーの検索動作とは違いますが、通常の状況でどうなるか理解するに
は十分です。

メジャーモードのローカルバインディングを変更するには、そのモードのロー
カルキーマップを変更する必要があります。通常、そのためにはそのモードが
最初に使われるまで待つ必要があります。というのは、ほどんどのメジャーモー
ドは使われるまでキーマップを作成しないからです。ですから、個人の
`~/.emacs'ファイルでメジャーモードのバインディングを変更したければ、そ
のモードのモードフックを使ってそのモードが最初に使われるまで（変更を）
遅らせる必要があります。

たとえば、texinfoモードを選択する`texinfo-mode'コマンドはフック
`texinfo-mode-hook'を実行します。このフックを使って`C-c n'と`C-c p'に
対する（有益ではないですが）ローカルバインディングをtexinfoモードに追
加するには、つぎのようにします。

     (add-hook 'texinfo-mode-hook
               '(lambda ()
                  (define-key texinfo-mode-map
                              "\C-cp"
                              'backward-paragraph)
                  (define-key texinfo-mode-map
                              "\C-cn"
                              'forward-paragraph)
                  ))

*Note Hooks::。



File: emacs-ja.info, Node: Minibuffer Maps, Next: Rebinding, Prev: Local Keymaps, Up: Key Bindings

ミニバッファのキーマップ
------------------------

ミニバッファも一群の専用ローカルキーマップを持っています。それらには各
種の補完や脱出コマンドが定義されています。

   * `minibuffer-local-map'は通常の入力に使われる（補完なし）。
   * `minibuffer-local-ns-map'も同様。ただし、SPCは、RETと同様に、脱出
     動作である。これは主にMocklispとの互換性のために使われる。
   * `minibuffer-local-completion-map'は弱い補完に使われる。
   * `minibuffer-local-must-match-map'は強い補完と慎重な補完に使われる。



File: emacs-ja.info, Node: Rebinding, Next: Init Rebinding, Prev: Minibuffer Maps, Up: Key Bindings

キーバインディングの対話的な変更
--------------------------------

Emacsのキーを再定義するには、キーマップの対応する項目を変更すればよい
のです。グローバルキーマップを変更すると、その変更は（同じキーに対して
独自のローカルな定義をしているメジャーモードを除く）すべてのメジャーモー
ドに影響します。あるいは、カレントバッファのローカルマップを変更すると、
同じメジャーモードを使っているすべてバッファに影響が及びます。

`M-x global-set-key RET KEY CMD RET'
     CMDを実行するようにKEYをグローバルに定義する。
`M-x local-set-key RET KEY CMD RET'
     CMDを実行するようにKEYを（現在のメジャーモードで）ローカルに定義
     する。
`M-x global-unset-key RET KEY'
     KEYをグローバルマップで未定義にする。
`M-x local-unset-key RET KEY'
     KEYを（現在のメジャーモードで）ローカルに未定義にする。

たとえば、Emacsを休止してログインシェルでコマンドを実行するかわりに、
Emacsバッファ内のサブシェルでコマンドを実行したいとします。通常、（Xウィ
ンドウシステムを使っていない場合）`C-z'は関数`suspend-emacs'にバインド
されていますが、つぎのようにこのキーを`shell'にバインドすれば、このキー
でEmacs内の対話的サブシェルを起動するように変更できます。

     M-x global-set-key RET C-z shell RET

`global-set-key'はキー列に続けてコマンド名を読み取ります。使いたいキー
を打鍵すると、どのキーをバインドしたいのかを確認するつぎのようなメッセー
ジが表示されます。

     Set key C-z to command: 

同じ手順で、ファンクションキーやマウスイベントを再定義できます。バイン
ドすべきキーを指定するときに、キーのかわりにファンクションキーを押した
りマウスボタンをクリックしてください。

複数イベントから成るキーも単一イベントのキーと同様にして再定義できます。
Emacsは再定義すべきキー列が完成するまで（つまりプレフィックスキーでは
ないキーが出てくるまで）イベントを読み続けます。たとえば、KEYとして
`C-f'を打てばそれで終りですから、ミニバッファはただちにCMDを読む状態に
なります。一方、`C-x'を打つとさらにその先のキーを読みます。そこで`4'を
打つと、さらにその先のキーが読まれる、というようになります。たとえば、

     M-x global-set-key RET C-x 4 $ spell-other-window RET

では、`C-x 4 $'を（実在しない）コマンド`spell-other-window'にバインド
します。

`C-c'に続けて英字という2文字のキー列は、ユーザーのカスタマイズ用に予約
されています。Lispプログラムはこれらのキー列を定義しないことになってい
ますから、これらのキー列のバインディングはどのメジャーモードでも使え、
いかなる機能とも干渉しないはずです。

`global-unset-key'でキーのグローバルな定義を取り除けます。そのキーは"
未定義"になります。未定義のキーを打つと、Emacsはベルを鳴らします。同様
に、`local-unset-key'は現在のメジャーモードでキーを未定義にしますから、
グローバルな定義（あるいはグローバルでの未定義状態）が現在のメジャーモー
ドでふたたび有効になります。

キーを再定義（または未定義に）して、あとでもとに戻したいと思った場合、
キーを未定義にしてももとには戻りません。キーの標準定義を設定し直す必要
があります。キーの標準定義を調べるには、基本（fundamental）モードのバッ
ファにいって`C-h c'を使います。本書のキーの説明にもコマンド名を掲載し
てあります。

まちがって、あるコマンドを実行することを防ぎたければ、キーを未定義にす
るのでなく、コマンドを使用禁止にするのがよいでしょう。必要になったとき
に使用禁止コマンドを起動するのは造作もありません。



File: emacs-ja.info, Node: Init Rebinding, Next: Function Keys, Prev: Rebinding, Up: Key Bindings

初期化ファイルでのキーの変更
----------------------------

いつでもあるキーバインディングを設定しておきたければ、その指定を個人の
`.emacs'ファイルにLispのコードとして書いておきます。

これを行うもっとも簡単な方法は、ASCII文字とメタ修飾付きのASCII文字に対
してのみ使えます。たとえば、`C-z'を`shell'にバインドするにはつぎのよう
にします。

     (global-set-key "\C-z" 'shell)

この例では1つの文字`C-z'から成る文字列定数を指定しています。コマンド名
`shell'のまえのクォート「'」は、`shell'を変数ではなく定数シンボルとし
て扱う印です。クォートがないと、Emacsは`shell'を変数としてその値をただ
ちに評価しようとします。すると、望んでいることではなく、エラーになりま
す。

つぎは、2文字のキー列をバインドする例です。

     (global-set-key "\C-xl" 'make-symbolic-link)

キー列にファンクションキーやマウスボタンイベントが含まれていたり、
`C-='や`H-a'などの非ASCII文字が含まれているなら、文字列よりもっと一般
的な指定方法であるベクタを使った指定を使う必要があります。

Emacs Lispでのベクタの書き方は、その要素を中括弧（`[...]'）で囲みます。
要素は空白で区切ります。要素がシンボルであれば、単にその名前だけを書け
ばよく、区切り記号などは不要です。要素が文字であれば、Lispの文字定数と
して、つまり`?'に続けてその文字が文字列中に現れるのと同じ書き方で、書
いてください。

ベクタを使って`C-='（ASCIIの範囲にないコントロール文字）、`H-a'（ハイ
パー文字。ASCIIにはハイパー文字は含まれない）、F7（ファンクションキー）、
`C-Mouse-1'（キーボード修飾付きのマウスボタン）をバインドする例を示し
ます。

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [f7] 'make-symbolic-link)
     (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な（文字列ですむ）場合にベクタを使ってもかまいません。先の2つの例
をベクタを使うように書き直すとつぎのようになります。

     (global-set-key [?\C-z] 'shell)

     (global-set-key [?\C-x ?l] 'make-symbolic-link)



File: emacs-ja.info, Node: Function Keys, Next: Named ASCII Chars, Prev: Init Rebinding, Up: Key Bindings

ファンクションキーの再定義
--------------------------

キー列には通常の文字以外にもファンクションキーを含めることができます。
キーボードの文字がLispの文字（実は整数です）で表されるのに対し、ファン
クションキーはLispシンボルで表されます。ファンクションキーに単語のラベ
ルが付いているなら、その単語が対応するLispシンボルの名前になります。た
とえば普通に見られるファンクションキーとLispシンボルの対応はつぎのとお
りです。

`left', `up', `right', `down'
     カーソル矢印キー。

`begin', `end', `home', `next', `prior'
     その他のカーソル移動キー。

`select', `print', `execute', `backtab'
`insert', `undo', `redo', `clearline'
`insertline', `deleteline', `insertchar', `deletechar'
     その他のファンクションキー。

`f1', `f2', ... `f35'
     （キーボードの上端に並んでいる）番号の付いたファンクションキー。

`kp-add', `kp-subtract', `kp-multiply', `kp-divide'
`kp-backtab', `kp-space', `kp-tab', `kp-enter'
`kp-separator', `kp-decimal', `kp-equal'
     （普通のキーボードの右側にまとまっている）キーパッドのキーで、名
     前や句読点が印字されているもの。

`kp-0', `kp-1', ... `kp-9'
     キーパッドの数字キー

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     キーパッドのPFキー。

これらの名前は習慣的なものですが、システムによっては（とりわけXウィン
ドウシステムを使っている場合は）、別の名前になっている場合があります。
あるファンクションキーにどのシンボルが対応しているか調べるには、`C-h
c'に続いてそのキーを打鍵してください。

ファンクションキーのシンボルを含むキー列（あるいは、ASCII以外の文字を
含むもの）は文字列ではなくベクタで指定してください。ベクタの構文では要
素と要素のあいだは空白で区切り、全体を中括弧``[...]''で囲みます。たと
えば、ファンクションキー`f1'をコマンド`rmail'にバインドするには、つぎ
のようにします。

     (global-set-key [f1] 'rmail)

右矢印キーをコマンド`fowared-char'にバインドするには、つぎのようにしま
す。

     (global-set-key [right] 'forward-char)

これは、シンボル`right'を要素とするベクタのLisp構文です。（このバイン
ディングはEmacsのデフォルト設定に入っている。）

ベクタを用いたキーの再定義ついてより詳しくは、*Note Init Rebinding::。

キー列の中でファンクションキーと文字を混ぜることができます。以下の例は、
`C-x NEXT'をコマンド`forward-page'にバインドしています。

     (global-set-key [?\C-x next] 'forward-page)

ここで、`?\C-x'はLispの文字定数で、文字`C-x'を表します。ベクタのもう1
つの要素である`next'は、シンボルですから`?'は不要です。

ファンクションキーに対して、修飾キーCTRL、META、HYPER、SUPER、ALT、
SHIFTを指定できます。これらの修飾キーを指定するには、シンボル名のまえ
に`C-'、`M-'、`H-'、`s-'、`A-'、`S-'を付けてください。たとえば、
`Hyper-Meta-RIGHT'で1語先へ移動するにはつぎのように指定します。

     (global-set-key [H-M-right] 'forward-word)



File: emacs-ja.info, Node: Named ASCII Chars, Next: Non-ASCII Rebinding, Prev: Function Keys, Up: Key Bindings

名前の付いたASCIIコントロール文字
---------------------------------

TAB、RET、BS、LFD、ESC、DELはもともとASCIIの特定のコントロール文字に対
応していたのですが、よく使われるため別にそれ専用のキーを持つようになり
ました。のちに人々はEmacsでこれらのキーとそれらと『同じ』文字をCTRLキー
と組み合わせて打鍵した場合とを区別できると便利だと気がつきました。

EmacsではXウィンドウシステムを使っている場合、これら2種類の入力を区別
します。つまり、キーボード上の特殊キーの方は`tab'、`return'、
`backspace'、`linefeed'、`escape'、`delete'という名前のファンクション
キーとして扱うのです。これらのファンクションキーは、*もし*それ固有のバ
インディングが指定されていなければ、自動的に対応するASCII文字に変換さ
れます。その結果、特にこの2種類を区別したいと思わない限りは、ユーザー
もLispプログラムもこれらの区分について気にする必要はありません。

（たとえば）TABと`C-i'を区別したくないなら、ASCII文字TAB（8進コード011）
に対応するバインディング1つだけを指定してください。区別したいのなら、
このASCII文字に対するバインディングに加えて、『ファンクションキー』
`tab'に対するバインディングも指定します。

通常のASCII端末では、TABと`C-i' （および上記の対応する組のそれぞれ）を
区別する方法はありません。というのは、端末はどちらが押されても同じ文字
を送出するからです。



File: emacs-ja.info, Node: Non-ASCII Rebinding

キーボード上の非ASCII文字
-------------------------

アクセント付き文字などの非ASCII文字を送出するキーがあるキーボードでは、
それらのキーの再定義には、少々トリックが必要です。2つの解決方法があり
ます。1つめは、`set-keyboard-coding-system'（*Note Specify Coding::）
を使って、キーボードのコーディングシステムを指定することです。そうすれ
ば、つぎのように書いて、通常の方法でそれらのキーを再定義できます。

     (global-set-key [?CHAR] 'some-function)

ただし、CHARを挿入するには、定義したいキーを打ちます。

キーボードのコーディングシステムを指定しないと、上のようにはできません。
そのかわりに、端末が実際に送出するコードを調べる必要があります。Emacs
でこれを簡単に行うには、`C-x b temp RET'で空バッファを作成し、`M-x
toggle-enable-multibyte-characters RET'でユニバイトにしてから、このバッ
ファに文字を挿入するキーを打ちます。

文字のまえにポイントを移動して、`C-b C-x ='と打ちます。8進数、10進数、
16進数の3通りで表した文字コードを括弧で括ったメッセージがミニバッファ
に表示されます。定義するには、3つの数字の2番目、つまり、10進数をベクタ
の中に書きます。

     (global-set-key [DECIMAL-CODE] 'some-function)



File: emacs-ja.info, Node: Mouse Buttons, Next: Disabling, Prev: Non-ASCII Rebinding, Up: Key Bindings

マウスボタンの再定義
--------------------

Emacsではマウスボタンを表すのにもLispシンボルを使います。Emacsのもっと
も一般的なマウスイベントは"クリック"（click）イベントです。これはマウ
スボタンを押して、マウスを移動せずにボタンを放したときに発生します。ボ
タンを押した状態でマウスを移動すると"ドラッグ"（drag）イベントになりま
す。そして最後にマウスボタンを放したときにも、やはり"ドラッグ"イベント
が発生します。

基本的なクリックイベントに対応するシンボルは、左ボタンに対しては
`mouse-1'、左から2番目のボタンに対しては`mouse-2'、などとなっています。
2番目のボタンをクリックしたときカレントウィンドウを分割するには、つぎ
のように設定します。

     (global-set-key [mouse-2] 'split-window-vertically)

ドラッグイベントについても同様ですが、イベント名の`mouse'のまえに
`drag-'が付きます。たとえば、第1ボタンを押したままドラッグすると
`drag-mouse-1'イベントが発生します。

マウスボタンが押されたときに発生するイベントに対してバインディングを指
定することもできます。これらのイベントは`drag-'のかわりに`down-'で始ま
ります。これらのイベントはキーバインディングが定義されているときだけ生
成されます。`down-'イベントのあとには、必ず、対応するクリック／ドラグッ
イベントが発生します。

必要ならば、シングルクリック／ダブルクリック／トリプルクリックを区別す
ることもできます。ダブルクリックとは、ほぼ同じ位置でマウスボタンを2回
クリックすることです。最初のクリックで通常のクリックイベントが発生しま
す。最初のクリックから十分短い時間内に2回目のクリックが起こると、クリッ
クイベントではなくダブルクリックイベントが発生します。ダブルクリックイ
ベントは、`double-'で始まります。たとえば、`double-mouse-3'です。

つまり、同じ場所で2回クリックがあったとき、2回目のクリックに特別な意味
を与えることはできますが、ただし最初のクリックで発生する通常のシングル
クリックに対して定義された動作も実行されることを前提としなければなりま
せん。

このような制限のため、ダブルクリックで行えることが制約されますが、ユー
ザーインターフェイスデザイナは、よいユーザーインターフェイスがつねにそ
のような制約に従うべきだとの考えを述べています。つまり、ダブルクリック
はシングルクリックと類似した動作をすべきであり、『それよりいくらか多く』
の動作をするのがよい、ということです。そして、ダブルクリックイベントに
対応するコマンドがその「いくらか多く」のぶんの動作を行うべきだというこ
とです。

ダブルクリックイベントに対してバインディングが定義されていなければ、ダ
ブルクリックは2つのシングルクリックとして扱われます。その結果、シング
ルクリックに対応するコマンドが2回実行されることになります。

Emacsではさらにトリプルクリックイベントも使えます（その場合、名前は
`triple-'で始まる）。しかし4重クリックをイベントタイプとして区別しませ
ん。ですから、3回目以降の連続したクリックは、すべてトリプルクリックイ
ベントとして報告されます。ただし、連続したクリックの回数はイベントリス
トに記録されていますから、本当に4重以上のクリックを区別したければそう
することもできます。4重以上のクリックに特別な意味を与えるのはお勧めで
きませんが、4回だと1回と同じ、5回だと2回と同じというように3つの選択肢
のあいだで巡回できるようにするのは場合によっては有効かもしれません。

Emacsはまた、ドラッグやボタンイベントでも複数回の押し下げを記録します。
たとえば、ボタンを2回押してからそのままマウスを移動した場合、Emacsは
`double-drag-'で始まるイベントを生成します。ドラッグでなくボタンを押し
下げただけの場合は同様に、`double-down-'で始まるイベントを生成します
（ただし、他のボタンイベントと同様に、そのイベントに対するバインディン
グがなければ無視される）。

変数`double-click-time'は、どれくらいの時間間隔内であれば2つの隣接する
クリックをダブルクリックとみなすかを指定します。単位はミリ秒です。値が
`nil'であれば、ダブルクリックを検出しません。値が`t'であれば、時間間隔
の上限はないものとして扱います。

マウスイベントに対応するシンボルにはさらに、`C-'、`M-'、`H-'、`s-'、
`A-'、`S-'の各プレフィックスで、修飾キーの情報も組み込めます。順番は、
プレフィックスに続いて`double-'や`triple-'があり、そのあとが`drag-'や
`down-'ということになります。

フレームには、モード行やスクロールバーなどのバッファ中のテキストを表示
する以外の部分もあります。マウスイベントがこれらの特別な部分で発生した
ものかどうかを調べるために、ダミーの「プレフィックスキー」があります。
たとえば、マウスがモード行でクリックされた場合、まず`mode-line'という
プレフィックスキーが送られ、続いて通常のマウスボタンに対応したイベント
が送られます。ですから、モード行で第1ボタンがクリックされたときに
`scroll-up'を実行するにはつぎのようにします。

     (global-set-key [mode-line mouse-1] 'scroll-up)

ダミーのプレフィックスキーとその意味はつぎのとおりです。

`mode-line'
     マウスがウィンドウのモード行にある。
`vertical-line'
     マウスが横に隣接するウィンドウ間の境界線上にある。（スクロールバー
     を表示させると、境界線のかわりにスクロールバーが現れる。）
`vertical-scroll-bar'
     マウスが縦スクロールバー上にある。（Emacsで使えるスクロールバーは、
     現在のところ縦スクロールバーのみ。）

1つのキー列の中に2つ以上のマウスボタンイベントを含めることもできますが、
普通はあまりしないでしょう。



File: emacs-ja.info, Node: Disabling, Prev: Mouse Buttons, Up: Key Bindings

使用禁止コマンド
----------------

コマンドを使用禁止にすると、コマンドの実行にはユーザーの確認が必要にな
ります。コマンドを使用禁止にする目的は、初心者がそのコマンドをまちがっ
て実行してしまい、混乱するのを防ぐためです。

Emacs上で使用禁止コマンドを対話的に実行しようとすると、コマンド名、説
明文、とりあえずどうすべきかの指示を表示したウィンドウが現れます。つぎ
にEmacsはコマンドを実行するか、使用禁止を解除してから実行するか、実行
を取り消すかを問い合わせてきます。コマンドの使用禁止を解除することを選
ぶと、Emacsさらに、以後恒久的にそうするのか、または現在のセッション内
だけそうするのかも問い合わせてきます。恒久的に使えるようにすると、自動
的に個人の`.emacs'ファイルを編集します。

コマンドを使用禁止にする機構は、コマンドに対応するLispシンボルの属性
`disabled'に`nil'以外の値を設定することです。これを行うLispプログラム
はつぎのようになります。

     (put 'delete-region 'disabled t)

属性`disabled'の値が文字列であれば、コマンドを使用しようとしたときに表
示されるメッセージにその文字列も含まれるようになります。

     (put 'delete-region 'disabled
          "It's better to use `kill-region' instead.\n")

コマンドを使用禁止にするには、`.emacs'ファイルを直接編集するか、かわっ
てこのファイルを編集するコマンド`M-x disable-command'を使います。同様
に、コマンド`M-x enable-command'は、`.emacs'ファイルを編集してコマンド
を恒久的に使える状態にします。*Note Init File::。

コマンドが使用禁止であるかどうかは、そのコマンドを起動するキー列には無
関係です。したがって、`M-x'でそのコマンドを起動してもEmacsはその可否を
問い合わせてきます。Lispプログラムからコマンドを関数として呼び出す場合
には使用禁止にしても何の効果もありません。



File: emacs-ja.info, Node: Keyboard Translations, Next: Syntax, Prev: Key Bindings, Up: Customization

キーボード変換
==============

キーボードの機種によっては、Emacsが使用するすべての特殊文字を送ってく
れないものがあります。もっともよくある問題は、DEL文字に関するものです。
いくつかのキーボードでは、このきわめて重要な文字を簡単に打ち込む手段が
ありません。それは、削除には`C-h'を使うことを前提としているからです。
そのようなキーボードで削除のためのキーを打つと、Emacsはそれをプレフィッ
クス文字`C-h'として解釈し、どのヘルプ機能を使うか問い合わせてきてしま
います。それはユーザーがしたかったことではありません。

Emacs内でこの問題を回避するには、`C-h'をDELに、DELを`C-h'に変換するキー
ボード変換を以下のように設定することで回避できます。

     ;; C-hをDELに変換する。
     (keyboard-translate ?\C-h ?\C-?)

     ;; DELをC-hに変換する。
     (keyboard-translate ?\C-? ?\C-h)

キーボード変換はキーマップによるキーバインディング（*Note Keymaps::）
と同じではありません。Emacsには状況ごとに使い分けられる多数のキーマッ
プがあるのに対し、キーボード変換は一式だけしかなく、Emacsが端末から読
むすべての文字に対してその変換が適用されます。キーボード変換は入力処理
のいちばん下位のレベルで行われ、キーマップ上の検索はキーボード変換を施
した結果に対して行われます。

XウィンドウシステムではDELETEというキーはファンクションキーであり、
ASCII文字DELとは別ものです。*Note Named ASCII Chars::。キーボード変換
はASCII文字入力だけに適用され、ファンクションキーとは無関係ですから、X
ウィンドウシステムでは上の例はDELETEキーに対して効果をもたらしません。
しかし、Xウィンドウシステムでは上のようなキーボード変換そのものが不要
です。というのは、EmacsはXウィンドウシステムではBACKSPACEキーと`C-h'も
区別でき、通常、BAKSPACEをDELとして扱うからです。

キーボード変換の使い方に関する詳しい情報は、*Note 入力イベントの変換:
(elisp)Translating Inputを参照してください。



File: emacs-ja.info, Node: Syntax, Next: Init File, Prev: Keyboard Translations, Up: Customization

構文テーブル
============

単語や対応した括弧の対を認識するEmacsコマンドはすべて、"構文テーブル"
（syntax table）によって制御されます。構文テーブルは、どの文字が開き括
弧で、どの文字が単語の中身で、どの文字がシングルクォートかといったこと
を記述しています。各メジャーモードにはそれぞれ専用の構文テーブルがあり
（ただし、互いに関係のあるメジャーモードが1つの構文テーブルを共用する
ことはある）、各バッファごとにそのときのメジャーモードの構文テーブルが
使われます。カレントバッファに設定されている構文テーブルはすべてのコマ
ンドが使うので、以下ではこれを『現在の』構文テーブルと呼びます。構文テー
ブルは文字テーブル（char-table）型のLispオブジェクトであり、その要素は
数値です。

現在の構文テーブルの内容に関する記述を表示するには、`C-h s'
（`descirbe-syntax'）を使います。記述の表示には各文字ごとに、その文字
の現在の構文を設定するために`modify-syntax-entry'に渡すべき文字列、お
よび、その文字列の英語での説明が含まれます。

構文テーブルに関する詳しい情報については、*Note 構文テーブル:
(elisp)Syntax Tablesを参照してください。



File: emacs-ja.info, Node: Init File, Prev: Syntax, Up: Customization

初期化ファイル`~/.emacs'
========================

Emacsが実行を開始するとき、通常はユーザーのホームディレクトリにあるファ
イル`.emacs'や`.emacs.el'からLispプログラムをロードします。このファイ
ルがEmacsの初期化の仕方を指定するので、このファイルのことを"初期化ファ
イル"（init file）と呼びます。コマンド行オプション`-q'で、Emacsに初期
化ファイルを読まないことを指示したり、`-u'（あるいは`--user'）で、別の
ユーザーの初期化ファイルを指定できます（*Note Entering Emacs::）。

"デフォルトの初期化ファイル"もあります。これは`default.el'という名前の
ライブラリファイルで、Emacsはライブラリ探索パスをとおしてその場所を探
します。Emacsの配布には`default.el'は含まれていません。ローカルなカス
タマイズのためにサイトで`default.el'を用意することもあります。このファ
イルがあれば（`-q'を指定したときを除いて）Emacsを開始するときつねにロー
ドされます。しかし、あるならば個人の初期化ファイルが最初にロードされま
す。その中で`inhibit-default-init'に`nil'以外の値を設定すると、
`default.el'はロードされません。

各サイトには"サイトスタートアップファイル"があるかもしれません。あるな
らば、このファイルの名前は`site-start.el'です。Emacsはユーザーの初期化
ファイルを読むまえにこのファイルもロードします。このファイルのロードを
抑止するには、オプション`-no-site-file'を指定します。

`.emacs'に大量のコードがある場合には、`~/.emacs.el'と改名してバイトコ
ンパイルしておくべきです。Emacs Lispプログラムのコンパイルについてより
詳しくは、*Note バイトコンパイル: (elisp)Byte Compilation。

単なるカスタマイズを超えるような実際のEmacsプログラムを書くのであれば、
`The Emacs Lisp Reference Manual' (1) (*Note Init File-Footnotes::)を
読むべきです。*Note Emacs Lisp: (elisp)Top。

* Menu:

* Init Syntax::	        Syntax of constants in Emacs Lisp.
* Init Examples::       How to do some things with an init file.
* Terminal Init::       Each terminal type can have an init file.
* Find Init::	        How Emacs finds the init file.


File: emacs-ja.info  Node: Init File-Footnotes, Up: Init File

(1) 【訳注】日本語訳：『Emacs Lispリファレンスマニュアル』、アスキー出
版局、ISBN4-7561-3414-9




File: emacs-ja.info, Node: Init Syntax, Next: Init Examples, Up: Init File

初期化ファイルの構文
--------------------

ファイル`.emacs'にはLispの関数呼び出し式を書きます。関数呼び出しは、関
数名に続けて引数リストを並べ、全体を括弧で囲みます。たとえば、`(setq
fill-column 60)'は、関数`setq'によって、変数`fill-column'（*Note
Filling::）に60を設定します。

`setq'の2番目の引数は変数の新しい値を表す式です。これは、定数でも、変
数でも、関数呼び出し式でもかまいません。`.emacs'ファイルでは定数を使う
ことがもっとも多いでしょう。定数にはつぎのものがあります。

数値：
     数値は10進表記し、先頭にマイナス符号があってもよい。

文字列：
     Lispの文字列の構文はCの文字列の構文とほぼ同じだが、多少違うところ
     もある。文字列定数の始まりと終りにはダブルクォートを使う。

     文字列の中には、改行や特殊文字をそのまま入れることができる。しか
     し、バックスラッシュで始まる形式、つまり、改行は`\n'、バックスペー
     スは`\b'、復帰は`\r'、タブは`\t'、ページ送りは`\f'（コントロール
     L）、エスケープは`\e'、バックスラッシュは`\\'、ダブルクォートは
     `\"'、8進コードOOOの文字は`\OOO'で表すことができ、そのほうが読み
     やすい。バックスラッシュとダブルクォートの2つだけは、文字列に含め
     るのに必ずこのような形で書き表す必要がある。

     `\C-'はコントロール文字を表すプレフィックスとして使用できる。たと
     えば、`\C-s'でASCIIのコントロールSを表す。同様に、`\M-'はメタ文字
     を表すプレフィックスとして使用できる。たとえば、`\M-a'で`Meta-A'、
     `\M-\C-a'で`Control-Meta-A'を表す。

文字：
     Lispの文字定数は、`?'に続けて文字または`\'で始まるエスケープシー
     ケンスを書いたもの。たとえば、`?x'、`?\n'、`?\)'などは文字定数。
     Lispでは文字と文字列は別ものなので注意すること。ある場面では文字
     列が必要であり、別の場面では文字が必要である。

真：
     `t'は「真」を表す。

偽：
     `nil'は「偽」を表す。

その他のLispオブジェクト：
     シングルクォートに続けてそのLispオブジェクトを書く。



File: emacs-ja.info, Node: Init Examples, Next: Terminal Init, Prev: Init Syntax, Up: Init File

初期化ファイルの例
------------------

以下にはよく使われるLispの式の例をあげておきます。

   * Cモードにおいて、行の途中でTABが押されたときにはタブ文字を挿入す
     るように設定する。

          (setq c-tab-always-indent nil)

     変数の値を「真」にするには`t'を設定し、逆に「偽」にするには`nil'
     を設定する。

   * 探索をデフォルトで大文字小文字を区別するように設定する（ただし、
     違う設定に変更しているバッファは除く）。

          (setq-default case-fold-search nil)

     ここでは`setq-default'で変数のデフォルト値を設定し、その変数に対
     してローカルな値を設定していないすべてのバッファで有効である。
     `setq'で`case-fold-search'に値を設定すると、カレントバッファのロー
     カルな値だけに影響し、初期化ファイルで記述したいこととは異なるだ
     ろう。

   * Emacsが自動的にメイルアドレスを割り出せない場合に備え、この変数に
     自分のメイルアドレスを指定する。

          (setq user-mail-address "coon@yoyodyne.com")

     メイルアドレスを必要とする多くのEmacsパッケージは、
     `user-mail-address'の値を使う。

   * 新たに作ったバッファのデフォルトのモードをテキストモードにする。

          (setq default-major-mode 'text-mode)

     `text-mode'を指定しているのは、これがテキストモードに入るためのコ
     マンドだから。コマンド名のまえのシングルクォートは、シンボルを定
     数として扱うため。さもないと`text-mode'という変数を参照することに
     なってしまう。

   * 西ヨーロッパのほとんどの言語を扱えるLatin-1文字集合をデフォルトと
     する (1) (*Note Init Examples-Footnotes::)。

          (set-language-environment "Latin-1")

   * テキストモードやそれに関連するモードでは、自動詰め込みモードをオ
     ンにする。

          (add-hook 'text-mode-hook
            '(lambda () (auto-fill-mode 1)))

     これはノーマルフック変数（*Note Hooks::）にフック関数を追加する例。
     ここでは関数として`lambda'で始まるリストを指定し、シングルクォー
     トを前置して式ではなく定数として扱わせる。

     Lispの関数について説明するのは本書の範囲外だが、この例を理解する
     には、テキストモードに入るときに`(auto-fill-mode 1)'が実行される
     のだと考えておけば十分。この式を別の式に変えたり、式を複数並べて
     もかまわない。

     Emacsには`turn-on-auto-fill'という関数が用意されており、その定義
     は`(lambda () (auto-fill-mode 1))'になっている。したがって、上の
     例をもっと簡単に書くとつぎのようになる。

          (add-hook 'text-mode-hook 'turn-on-auto-fill)

   * あらかじめ用意してあるLispライブラリ`foo' （実際には標準Emacsディ
     レクトリに置かれたファイル`foo.elc' または`foo.el'）をロードする。

          (load "foo")

     `load'に渡す引数が相対ファイル名、つまり、`/'や`~'で始まらない場
     合には、`load'は`load-path'（*Note Lisp Libraries::）のディレクト
     リ群を順に探索する。

   * 自分のホームディレクトリにあるコンパイル済みのLispファイル
     `foo.elc'をロードする。

          (load "~/foo.elc")

     ここでは絶対ファイル名が使われているので、探索は行わない。

   * キー`C-x l'で関数`make-symbolic-link'が実行されるようにバインディ
     ングを設定する。

          (global-set-key "\C-xl" 'make-symbolic-link)

     または

          (define-key global-map "\C-xl" 'make-symbolic-link)

     ここでもシンボル`make-symbolic-link'を変数としての値ではなく定数
     とするためにシングルクォートが使われていることに注意。

   * 上と同じだが、Lispモードの中だけでのバインディングを設定する。

          (define-key lisp-mode-map "\C-xl" 'make-symbolic-link)

   * 基本（fundamental）モードで`next-line'を実行するようになっている
     すべてのキーを、かわりに`forward-line'を実行するように直す。

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * `C-x C-v'を未定義にする。

          (global-unset-key "\C-x\C-v")

     キーを未定義にする必要のある場合の1つとして、そのキーをプレフィッ
     クスにしたい場合がある。たとえば、`C-x C-v ANYTHING'を定義すると、
     `C-x C-v'は自動的プレフィックスになるが、しかしそのまえに`C-x
     C-v'の通常の（プレフィックスではない）定義を未定義に戻しておく必
     要がある。

   * `$'をテキスト（text）モードでの区切り文字にする。`$'を文字定数と
     して指定していることに注意。

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * コマンド`narrow-to-region'を確認なしに使えるようにする。

          (put 'narrow-to-region 'disabled nil)


