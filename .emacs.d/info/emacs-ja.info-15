Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Antinews, Next: MS-DOS, Prev: Command Arguments, Up: Top

Emacs 19逆向きニュース
**********************

過去に暮す方々のために、Emacsバージョン19への格下げ情報です。Emacs 20
のある種の機能の欠落による大いなる簡潔さを甘受されることを願って。

   * マルチバイト文字対応と行末変換機能は完全に除去してある。（これを
     とてつもない進歩ととらえる人もいる。）文字コードは0から255の範囲
     に限られる。また、UNIX流のシステムに持ち込んだファイルでは、
     MS-DOG型のファイルを扱っていることを警告するために、各行の末尾に
     ^Mがあることがある。

   * 同様に、フォントセット、コーディングシステム、入力方式も除去した。

   * どのエディタを使っているか忘れないように、通常、モード行には
     `Emacs'と表示する。

   * スクロールバーはつねにウィンドウの右側にある。これで、ウィンドウ
     内のテキストとはっきり区別できる。

   * `M-x customize'の機能は、とても簡潔な機能の`M-x edit-options'に置
     き換えた。これで*すべて*のユーザーオプションを先頭から眺めること
     ができ、あちこち探しまわる必要はないだろう。また、これには`s'や
     `x'のようにユーザーオプションを設定するコマンドもいくつかある。

   * Emacs19では、マウスでリージョンを選択したあとにDELETEキーを使って
     も特別なことは何も起こらない。マウスを操作していないときと同じよ
     うに動作し、単に直前の1文字を削除する。

   * `C-x C-w'は、新しいファイル名に合わせてメジャーモードを変更しない。
     モードを変更するには、`M-x normal-mode'を使う。

   * 暫定（transient-mark）マークモードでは、どのウィンドウにおいても
     ウィンドウ内にリージョンがある限りそれを強調表示する。

   * アウトライン（outline）モードでは、上書き属性を使わない。かわりに、
     まえにある改行文字をコード015に変更して行を隠す。たとえこのままファ
     イルに保存しても、ファイル内では文字コード015は改行に戻っている。

   * `enable-recursive-minibuffers'が`nil'であっても、ミニバッファを再
     帰的に利用する賢い方法がある。ミニバッファ以外の*ウィンドウに切り
     替え*てから、ミニバッファコマンドを使うだけでよい。このようにすれ
     ば何段でもミニバッファのレベルを積み重ねられるが、`M-x top-level'
     でもとに戻ってしまう。

   * ミニバッファ履歴リストの長さの制限を取り除いた。このリストは、セッ
     ション開始時から入力したすべてのミニバッファ引数を保持する。

   * 動的略語展開では、とても簡潔にかつ素直に大文字小文字変換を扱う。
     大文字小文字を保存するように指定してあると、打ち込んだ略語の大文
     字小文字のパターンと同じになるように展開する。

   * コマンド`compose-mail'はなくなった。現在、`C-x m'は`mail'を直接実
     行する。

   * 特殊文字を含むファイル名をクォートする方法はない。見た目とおりの
     ものを得る。つまり、リモートにあるように見える名前のものはリモー
     トにある。

   * `grep'がなくなることはないので、`M-x grep-find'は除去した。


   * diredのコマンドを若干再配置した。つまり、2文字列のコマンドは軽快
     な1文字のコマンドに置き換えた。

        * `dired-mark-executables'は`*'
        * `dired-mark-directories'は`/'
        * `dired-mark-symlinks'は`@'
        * `dired-change-marks'は`c'
        * `dired-unmark-all-files'は`C-M-?'
        * `dired-unmark-all-marks'は`C-M-? RET'

     ただし、`dired-flag-garbage-files'は`&'と打つので、この場合には過
     去にひたっていられなくなる。

   * Cモードでは、ブロックコメントに好きなスタイルを指定できる。たとえ
     ば、

          /*       
          blah     
          blah     
          */       

     というスタイルを利用するには、変数`c-block-comments-indent-p'を
     `t'にする。

   * フォントロック（font-lock）モードが使用するフェイスをカスタマイズ
     するには、変数`font-lock-face-attributes'を使う。詳しくは、この変
     数の説明文字列を参照。

   * 効率のために、フォントロック（font-lock）モードは、選択したメジャー
     モード用の飾りとしては最小限のものをデフォルトで使用する。

   * バッファを消去すると、そのバッファ内の位置を保持していたレジスタ
     の値は、牢獄を指すようになる。

   * 関数`set-frame-font'は`set-default-font'と改名した。

   * 変数`tex-main-file'はなくなった。もちろん、値を設定すればこの変数
     を作成できるが、特に何をするわけでもない。

   * 変数`scroll-preserve-screen-position'とこの変数で制御していた機能
     は除去した。

   * 関数`add-untranslated-filesystem'と関数
     `remove-untranslated-filesystem'は除去し、より簡潔な関数
     `using-unix-filesystems'で置き換えた。

   * コンピュータの記憶容量が減少し続けるため、Emacs 19では他の数多く
     の関数やファイルも除去した。それらをすべてここで取り上げる必要は
     あるまい。それらのどれかを使うと、「undefined（未定義）」とか
     「unbound（未束縛）」というエラーメッセージが出る。


File: emacs-ja.info, Node: MS-DOS, Next: Manifesto, Prev: Antinews, Up: Top

EmacsとMS-DOS
*************

ここでは、（『MS-DOG』とも呼ばれる）MS-DOS『オペレーティングシステム』
で稼働するEmacsの癖について簡単にふれます。MS-DOS用に作成したEmacsのバ
イナリは、Windows 3.x、Windows NT、Windows 9X、OS-2上でDOSアプリケーショ
ンとしても動作します。MS-DOS用に作成したEmacsを使っている限り、本章の
情報はこれらすべてのシステムにあてはまります。

Windows NTやWindows 9Xに専用のEmacsを作ることも可能です。その場合には、
本章のほとんどは関係ありません。長いファイル名、複数のフレーム、スクロー
ルバー、マウスメニュー、サブプロセスの利用を含めて、本書の他の部分で説
明した動作に近い動作をします。しかし、テキストファイルとバイナリファイ
ルに関する節は適用できます。また、本章の最後の2つの節は、Windows NTと
9Xだけに適用できます。

* Menu:

* Input: MS-DOS Input.         Keyboard and mouse usage on MS-DOS.
* Display: MS-DOS Display.     Fonts, frames and display size on MS-DOS.
* Files: MS-DOS File Names.    File name conventions on MS-DOS.
* Text and Binary::            Text files on MS-DOS use CRLF to separate lines.
* Printing: MS-DOS Printing.   How to specify the printer on MS-DOS.
* I18N: MS-DOS and MULE.       Support for internationalization on MS-DOS.
* Processes: MS-DOS Processes. Running subprocesses on MS-DOS.
* Windows Processes::          Running subprocesses on Windows.
* Windows System Menu::        Controlling what the ALT key does.



File: emacs-ja.info, Node: MS-DOS Input, Next: MS-DOS Display, Up: MS-DOS

MS-DOSのキーボードとマウス
==========================

PCのキーボードの左側のALTキーは、METAキーに割り当てられます。SUPERキー
とHYPERキーのエミュレーションには、選択肢が2つあります。変数
`dos-hyper-key'と`dos-super-key'を1にすれば、右側のCTRLキーを選びます。
変数`dos-hyper-key'と`dos-super-key'を2にすれば、右側のALTキーを選びま
す。`dos-super-key'と`dos-hyper-key'のいずれも1でなければ、デフォルト
で右側のALTキーもMETAに割り当てられます。しかし、MS-DOSの国際化キーボー
ド用プログラム`KEYB.COM'をインストールしてある場合は、右側のALTをMETA
には割り当て*ません*。 というのは、米国配列のキーボードでない場合、右
側のALTは`~'や`@'として使われるからです。この場合には、左側のALTのみを
METAとして使えます。

変数`dos-keypad-mode'は、数字キーパッド上のキーが返すキーコードを制御
する変数です。ファイル`_emacs'につぎの行を入れておけば、ENTERキーが
`C-j'として働くように定義できます。

     ;; 数字キーパッドのEnterキーをC-jとして動作させる。
     (define-key function-key-map [kp-enter] [?\C-j])

（ほとんどのワークステーションでの呼称から）EmacsでDELと呼ばれるキーは、
PCではBS（バックスペース）です。このため、PC特有の端末初期化においては、
BSキーはDELとして動作するようにしています。同じ理由から、DELキーは C-d
として動作するようにしてあります。

MS-DOS用のEmacsでは、`C-BREAK'を`C-g'のような中断文字として認識します。
これは、Emacsが入力を読もうとしないと`C-g'が打鍵されたことを検出できな
いからです。そのため、動作中のコマンドを止めるために`C-g'を使えません
（*Note Quitting::）。対照的に、`C-BREAK'は（他のシステムでの`C-g'のよ
うに）打鍵するとすぐに検出*される*ので、動作中のコマンドを停止したり緊
急脱出したりするために使えます（*Note Emergency Escape::）。

MS-DOS用Emacsは、（デフォルトの端末だけで）マウスを使えます。メニュー
やメニューバー（*Note Menu Bar::）の利用を含めて、マウスコマンドはドキュ
メントどおりに動作します。MS-DOS用Emacsではスクロールバーは使えません。
PCのマウスには、通常、2つのボタンしかありません。これらは`Mouse-1'と
`Mouse-2'として動作しますが、2つのボタンを同時に押せば`Mouse-3'として
動作します。

MS-DOS用EmacsがWindows上で動作している場合には、クリップボードの操作を
利用できます。キルリングにテキストを置いたり、キルリングからテキストを
ヤンクしたりするコマンドでは、Xウィンドウシステムの場合と同様に、まず
Windowsのクリップボードを調べます（*Note Mouse Commands::）。Windows上
のMS-DOS用Emacsは、一次セレクションとカットバッファのみを利用し、二次
セレクションはつねに空です。

Windowsで実装されているクリップボードの参照方法のため、クリップボード
に置けるテキストの長さは、Emacsが利用できるDOSの空きメモリ量に制限され
ます。通常、620Kバイトまでのテキストをクリップボードに置けますが、この
上限はシステムの設定に依存し、他のプログラムのサブプロセスとしてEmacs
を実行しているときには少なくなります。削除したテキストがクリップボード
に入りきらなければ、Emacsはその旨のメッセージを出力して、テキストをク
リップボードへ置きません。

Windowsのクリップボードにはナル文字を入れられません。キルしたテキスト
にナル文字が含まれる場合には、Emacsはそのようなテキストをクリップボー
ドへ置きません。さらに、エコー領域には、その旨、メッセージを表示します。

変数`dos-display-scancodes'の値が`nil'以外のときには、キーを打つたびに、
Emacsは各キーのASCII（コードの）値とキーボードスキャンコードを出力しま
す。この機能は、デバッグ用のコマンド`view-lossage'を補佐します。



File: emacs-ja.info, Node: MS-DOS Display, Next: MS-DOS File Names, Prev: MS-DOS Input, Up: MS-DOS

MS-DOSの画面
============

MS-DOSの画面では、ボールド体（太字体）やイタリック体（斜体）などのフォ
ントの変種を使えませんが、個々に前景色と背景色を指定できるフェイスを複
数個使えます。したがって、関連するフェイスに異なる表示色を定義すれば、
（`font-lock'、エンリッチ（enriched）モードなどの）フォントを用いる
Emacsのパッケージの全機能を利用できます。コマンド`list-colors-display'
（*Note Frame Parameters::）とコマンド`list-faces-display'（*Note
Faces::）を使えば、利用可能なフェイスと表示色、それらの見え方を知るこ
とができます。

本章の*Note MS-DOS and MULE::では、DOSの画面に組み込まれたフォントでは
表せない字形や文字をEmacsがどのように表示するかを説明します。

MS-DOSでも複数のフレーム（*Note Frames::）を利用できます。しかし、それ
らはすべて重なっているので、一度には1つのフレームしか見ることができま
せん。見えている1つのフレームが画面全体を覆います。MS-WindowsのDOSボッ
クスでEmacsを実行しているときには、見えているフレームを画面全体より小
さくはできますが、それでも、一度に1つのフレームしか表示できません。

コマンド`mode4350'は43行表示と50行表示を切り替えますが、ハードウェアに
依存します。コマンド`mode25'は、デフォルトの80x25の画面サイズに切り替
えます。

デフォルトでは、Emacsは80桁で、25行、28行、35行、40行、43行、50行の画
面サイズしか知りません。しかし、ビデオアダプタに別の画面サイズに切り替
える特別なビデオモードがあれば、Emacsでもそれらを利用できます。Emacsに
フレームサイズをN行M桁に切り替える指示をすると、
`screen-dimensions-NxM'という変数があるかどうか調べます。変数があれば、
その値（整数である必要がある）を切り替え先のビデオモードとして使います。
（Emacsは、`screen-dimensions-NxM'の値をレジスタ`AL'に入れ、BIOSの関数
`Set Video Mode'を呼び出し、ビデオモードを切り替えます。）たとえば、ビ
デオモードを85にすると66x80の画面に切り替わるアダプタがあるとします。
`_emacs'につぎの行を加えれば、Emacsでこの画面サイズを使えるようになり
ます。

     (setq screen-dimensions-66x80 85)

MS-DOS用Emacsでは、フレームサイズは利用可能な特定のサイズにしか設定で
きませんから、フレームサイズの変更要求すべてに答えられるわけではありま
せん。使えないサイズが要求されると、Emacsは指定されたサイズのつぎに大
きいサイズを選びます。たとえば、36x80のフレームを要求すると、かわりに、
40x80になります。

変数`screen-dimensions-NxM'は、指定サイズに正確に一致するときだけ使わ
れます。利用可能なつぎに大きなサイズの候補を探すときには無視します。上
述の例では、VGAで38x80を使えて、変数`screen-dimensions-38x80'に適切な
値を定義したとしても、36x80のフレームを要求した場合には、40x80の画面に
なってしまいます。このような場合に38x80のサイズにしたければ、変数
`screen-dimensions-36x80'にも`screen-dimensions-38x80'と同じビデオモー
ドの値を入れます。

MS-DOSでは、フレームサイズを変更すると、他のすべてのフレームのサイズも
変更してしまいます。



File: emacs-ja.info, Node: MS-DOS File Names, Next: Text and Binary, Prev: MS-DOS Display, Up: MS-DOS

MS-DOSにおけるファイル名
========================

他のシステムではファイル名の構成要素の区切りにはスラッシュを使いますが、
MS-DOSでは、普通、バックスラッシュ`\'を使います。MS-DOS用Emacsでは、ス
ラッシュもバックスラッシュも使えて、さらに、ファイル名に含まれるドライ
ブ名も理解します。

MS-DOSでは、ファイル名に大文字小文字の区別はなく8文字に制限されますが、
ピリオドとさらに3文字を付加できます。Emacsは他のシステム向けのファイル
名を扱ううえで、これらの制限を熟知しています。たとえば、ドット`.'で始
まるファイル名は、MS-DOSでは正しくないので、Emacsはそれを透過的に下線
`_'に変換します。したがって、デフォルトの初期化ファイル（*Note Init
File::）は、MS-DOSでは`_emacs'と呼ばれます。ピリオドの前後の文字数制限
を越えた部分は、通常、MS-DOSが無視します。したがって、ファイル
`LongFileName.EvenLongerExtension'を訪れると、実際には`longfile.eve'を
訪れることになりますが、モード行にはもとの長い名前が表示されます。これ
以外には、MS-DOSにおいて正しいファイル名を指定するのは、ユーザーの責任
です。上述した透過的な変換は、Emacsに組み込まれたファイル名にのみに作
用します。

MS-DOSでの上述のファイル名の制限のために、もとのファイル名の文字をいく
つか捨てずにバックアップファイル（*Note Backup Names::）の名前を構成す
ることは不可能です。たとえば、バックアップを1つしか使っていなくても、
`docs.txt'のバックアップファイルの名前は`docs.tx~'となります。

Windows 9x上のDOSアプリケーションとしてEmacsを実行する場合には、長いファ
イル名の使用を有効にできます。そうすると、Emacsは、ファイル名を切り詰
めたり小文字に変換したりせずに、指定したとおりのファイル名をそのまま使
います。長いファイル名の使用を有効にするには、Emacsを起動するまえに、
環境変数`LFN'に`y'と設定します。残念ながら、Windows NTではDOSプログラ
ムから長いファイル名を使えませんので、MS-DOS用Emacsからは短い8+3の別名
しか見えません。

MS-DOSにはホームディレクトリという概念がないので、MS-DOS用Emacsでは、
Emacsをインストールしてあるディレクトリを環境変数`HOME'の値であるとい
うことにします。つまり、Emacsのバイナリ`emacs.exe'がディレクトリ
`c:/utils/emacs/bin'に置いてあるとすれば、Emacsは、環境変数`HOME'が
`c:/utils/emacs'と設定されているかのようにふるまいます。特に、ここが初
期化ファイル`_emacs'を探す場所となります。このことを心に留めておけば、
UNIXでのように、ホームディレクトリの別名としてファイル名に`~'を使えま
す。Emacsを起動するまえに環境変数`HOME'を設定することもでき、その場合
には、上述のデフォルトのふるまいに優先します。

DJGPPのエミュレーションライブラリの機能では入出力装置はディレクトリ
`/dev'に置かれていると仮定するので、MS-DOS用Emacsはディレクトリ名
`/dev'を特別扱いします。いかなるディスク上でも`/dev'というディレクトリ
名を使わないように忠告しておきます。



File: emacs-ja.info, Node: Text and Binary, Next: MS-DOS Printing, Prev: MS-DOS File Names, Up: MS-DOS

テキストファイルとバイナリファイル
==================================

GNU Emacsでは、テキスト行の区切りとして改行文字を使います。これは、GNU
Emacsが開発されたUNIXでの習慣であり、UNIXをモデルとしたGNUシステムでの
習慣でもあります。

MS-DOSとMS-Windowsでは、テキスト行の区切りとして、通常、復帰・行送りの
2文字列を使います。（行送りは改行と同じ文字です。）したがって、Emacs 
において典型的なファイルを便利に編集するには、これらの行末
（end-of-line、EOL）文字列を変換する必要があります。Emacsは通常つぎの
ようにします。ファイルを読み込むときには復帰・行送りを改行に変換し、ファ
イルを書き出すときには改行を復帰・行送りに変換します。国際文字コードの
変換を扱う機構でもこの変換を行います（*Note Coding Systems::）。

ほとんどのファイルにおけるこの特別な書式変換のために、Emacsが報告する
文字位置（*Note Position Info::）は、オペレーティングシステム上でのファ
イルサイズ情報と食い違います。

内容がテキストではないある種のファイルは、変換すべきではありません。し
たがって、MS-DOS用Emacsは、ある種のファイルを"バイナリファイル"として
区別して、そのまま読み書きします。（この区別はMS-DOSのものではなく、
Emacsがもたらすものです。）これらには、実行プログラム、圧縮したアーカ
イブなどが含まれます。Emacsはファイル名を用いて、バイナリファイルとし
て扱うべきかどうか決定します。変数`file-name-buffer-file-type-alist'に
は、バイナリファイルを表すファイル名のパターンを定義しておきます。
`file-name-buffer-file-type-alist'に指定したバイナリファイルのパターン
にファイル名が一致すると、Emacsは行末変換だけでなく*すべて*の符号変換
を抑制するコーディングシステム（*Note Coding Systems::）
`no-conversion'を使います。

さらに、Emacsは、ファイルの内容から行区切りとして復帰・行送りでなく改
行を用いていると判断すると、ファイルの読み書きにおいて変換を行いません。
したがって、特に努力しなくても、UNIXやGNUシステムからのファイルを
MS-DOS上で読んだり編集でき、それらのファイルの行末はUNIX流の行末のまま
です。

コマンド`find-file-text'やコマンド`find-file-binary'を用いると、ファイ
ルをテキストとして扱うかバイナリとして扱うかを指定して訪れることができ
ます。行末変換はコーディングシステムの一般的な変換機構の一部なので、コー
ディングシステムを指定するコマンド（*Note Specify Coding::）によってファ
イルをテキストとして扱うかバイナリとして扱うかを指定することもできます。
たとえば、`C-x RET c undecided-unix RET C-x C-f foobar.txt' とすれば、
行末変換をせずにファイル`foobar.txt'を訪れることができます。

モード行にはカレントバッファで行末変換を行ったかどうか表示されます。モー
ド行の始めのほうにあるコーディングシステムを表す文字のうしろには、通常、
コロンが表示されます。バッファでMS-DOSの行末変換を使っている場合には、
この文字はバックスラッシュに変わります。

NFSやSambaを用いてUNIXやGNUシステムを使ったコンピュータ上のファイルシ
ステムを参照するとき、これらのファイルシステム上のどのファイルに対して
は、新規作成時でなくても、Emacsは行末変換を行うべきではありません。こ
うするためには、該当するファイルシステムを"無変換"のファイルシステムと
指定するために、関数`add-untranslated-filesystem'を呼びます。この関数
は、ファイルシステム名である引数を1つとりますが、これにはドライブ名や
ディレクトリ名を含めることもできます。たとえば、

     (add-untranslated-filesystem "Z:")

は、ドライブZを無変換のファイルシステムとして指定しますし、

     (add-untranslated-filesystem "Z:\\foo")

は、ドライブZ上のディレクトリ`\foo'を無変換のファイルシステムとして指
定します。

個人の`_emacs'ファイルやサイトの全ユーザーに便利なように
`site-start.el'の中で、`add-untranslated-filesystem'を使うことが多いで
しょう。

`add-untranslated-filesystem'の効果を取り消すには、関数
`remote-untranslated-filesystem'を使います。この関数は、まえに
`add-untranslated-filesystem'に使ったのと同じ文字列を引数としてとりま
す。



File: emacs-ja.info, Node: MS-DOS Printing, Next: MS-DOS and MULE, Prev: Text and Binary, Up: MS-DOS

印刷とMS-DOS
============

`lpr-buffer'（*Note Hardcopy::）や`ps-print-buffer'（*Note
Postscript::）のような印刷コマンドは、UNIX流のプログラム`lpr'がない場
合には、プリンタポートに直接出力を送ればMS-DOSやMS-Windowsでも動作しま
す。このふるまいは、UNIX上の`lpr'での印刷（*Note Hardcopy::、*Note
Postscript Variables::）を制御する変数と同じ変数で制御されますが、
MS-DOSやMS-Windows上でのこれらの変数のデフォルト値は、UNIX上での値と同
じではありません。

DOS流の通常の印刷のように、ローカルのプリンタを使いたい場合には、Lisp
変数`lpr-command'に`""'（デフォルト値）を設定し、`printer-name'にはプ
リンタポートの名前を設定します。たとえば、ローカルのプリンタポートなら
ば（デフォルト値の）`"PRN"'や`"LPT2"'、シリアルプリンタならば`"COM1"'
です。`printer-name'にはファイル名も設定できます。その場合には、『印刷』
結果は、そのファイルに追加書きされます。`printer-name'に`"NUL"'を設定
すると、印刷結果は（システムの空デバイスに送られて）黙って捨てられます。

MS-Windowsでは、Windowsのネットワークソフトウェアをインストールしてあ
れば、`printer-name'に、他のマシンとの共用プリンタのUNC共用名（たとえ
ば`"//joes_pc/hp4si"'）を設定すれば、そのプリンタを利用することもでき
ます。（スラッシュでもバックスラッシュでもかまいません。）共用プリンタ
の名前を調べるには、DOSコマンドプロンプトで`net view'を実行してサーバー
一覧を取得してから、`net view SERVER-NAME'を実行してサーバーが共有する
プリンタ（とディレクトリ）の名前を調べます。

`printer-name'にファイル名を設定するときには、絶対ファイル名を使うのが
最良です。Emacsは、カレントバッファのデフォルトディレクトリに応じて作
業ディレクトリを変更します。`printer-name'のファイル名が相対的であると、
印刷を行ったバッファのディレクトリごとに、そのような名前のファイルがで
きてしまいます。

コマンド`print-buffer'や`print-region'は、各印刷ページに見出しを付ける
ために、`pr'プログラムを呼び出したり、`lpr'プログラムに対して特別なフ
ラグを使います。MS-DOSやMS-Windowsには、通常、これらのコマンドはありま
せんから、デフォルトでは、変数`lpr-headers-switches'は、ページ見出しを
付ける要求を無視するように設定してあります。したがって、`print-buffer'
や`print-region'は、それぞれ、`lpr-buffer'や`lpr-region'と同じ出力にな
ります。（たとえばGNU Textutilsなどの）適当な`pr'プログラムがあるなら
ば、`lpr-headers-switches'に`nil'を設定します。すると、Emacsはページ見
出しを付けるために`pr'を呼び出し、`printer-name'の指定に従って出力結果
を印刷します。

`lpr'と同じ動作をする`lpr'がある場合には、変数`lpr-command'に`"lpr"'と
設定できます。すると、他のシステムと同様に、Emacsは`lpr'を使って印刷し
ます。（プログラム名が`lpr'でない場合には、`lpr-command'にはプログラム
を探す場所を設定する。）`lpr-command'が`""'以外の場合には、変数
`lpr-switches'には標準的な意味があります。変数`printer-name'の値が文字
列である場合には、UNIXの場合と同様に、`lpr'のオプション`-P'の値として
使われます。

同様の一連の変数、`ps-lpr-command'、`ps-lpr-switches'、
`ps-printer-name'（*Note Postscript Variables::）は、PostScriptファイ
ルの印刷方法を定義します。これらの変数は、上に述べた非PostScript印刷用
の対応する変数と同じように使われます。つまり、`ps-printer-name'の値は、
非PostScript印刷での`printer-name'の使い方と同様に、PostScript出力の送
り先の装置（やファイル）の名前として使われます。（つまり、別々の2つの
ポートに2台のプリンタを接続してあり、その一方がPostScriptプリンタの場
合、異なる2組の変数群を使える。）

変数`ps-lpr-command'のデフォルト値は`""'であり、PostScript出力を
`ps-printer-name'で指定するプリンタポートへ送ることを意味します。しか
し、`ps-lpr-command'には、PostScriptファイルを受理するプログラムの名前
を設定してもかまいません。つまり、非PostScriptプリンタがある場合、この
変数に（Ghostscriptなどの）PostScriptインタープリタプログラムの名前を
設定できます。インタープリタプログラムに渡す必要があるオプションは、
`ps-lpr-switches'を用いて指定します。（`ps-printer-name'の値が文字列の
場合、その値は、オプション`-P'の値として、オプション列に付加される。こ
れは、`lpr'を使う場合にだけ有用であろう。というのは、インタープリタを
使う場合、典型的には、`ps-printer-name'には文字列以外を設定して無視さ
せる。）

たとえば、ポート`LPT2'に接続したEpsonプリンタに印刷するために
Ghostscriptを使うには、つぎの内容を個人のファイル`_emacs'に入れます。

     (setq ps-printer-name t)  ; Ghostscriptは -P を理解しない
     (setq ps-lpr-command "c:/gs/gs386")
     (setq ps-lpr-switches '("-q" "-dNOPAUSE"
     			"-sDEVICE=epson"
     			"-r240x72"
     			"-sOutputFile=LPT2"
     			"-Ic:/gs"))

（この例では、ディレクトリ`"c:/gs"'にGhostscriptをインストールしてある
と仮定。）

MS-DOSとMS-Windowsでは、後方互換のために、`dos-printer'（や
`dos-ps-printer'）の値を設定してあると、`printer-name'（や
`ps-printer-name'）の値を上書きします。




File: emacs-ja.info, Node: MS-DOS and MULE, Next: MS-DOS Processes, Prev: MS-DOS Printing, Up: MS-DOS

MS-DOSでの国際化対応
====================

MS-DOS上のEmacsは、UNIXや他のプラットフォーム上と同じ国際化文字集合を
扱えます（*Note International::）。これには、異なる文字集合のあいだの
変換を行うコーディングシステムも含みます。しかしながら、
MS-DOS/MS-WindowsとUNIXとの非互換性に起因するDOSに固有な特色があり、ユー
ザーは理解しておく必要があります。本節では、これらの特色について述べま
す。

`M-x dos-codepage-setup'
     Emacs画面とコーディングシステムをカレントDOSコードページに適した
     ものに設定する。

`M-x codepage-setup'
     特定のDOSコードページ用のコーディングシステムを作成する。

MS-DOSは、一度には256文字から成る単一の文字集合を扱えるように設計され
ていますが、さまざまな文字集合から選択できます。代替文字集合は、"DOSコー
ドページ"と呼ばれます。各コードページは、128個の全ASCII文字を含みます
が、残りの128文字（コード128〜255）は、コードページごとに異なります。
各DOSコードページは、850や862などの3桁の数字で識別します。

同時に複数のフォントを使えるXウィンドウに比べると、MS-DOSでは1つのセッ
ションでは複数のコードページを使えません。MS-DOSはシステムブート時に単
一のコードページをロードします。コードページを変更するにはMS-DOSをリブー
トする必要があります (1) (*Note MS-DOS and MULE-Footnotes::)。
MS-Windowsなどの他のシステムでDOSプログラムを実行する場合にも、同様の
制約が課せられます。

MS-DOS上でオプション`--unibyte' （*Note Initial Options::）を指定して
Emacsを起動すると、Emacsは、いかなる変換も非ASCII文字には行いません。
非ASCII文字はそのまま読み書きし、画面には8ビットコードをそのまま送りま
す。つまり、MS-DOS上のユニバイトEmacsは、なんであれカレントコードペー
ジを使いますが、それ以外の文字を表現することはできません。

MS-DOS上でのマルチバイト操作には、Emacsは、選択されているDOSコードペー
ジで表示できる文字群を知っておく必要があります。そのため、起動後、選択
しているコードページ番号をシステムに問い合わせ、変数`dos-codepage'にそ
の番号を保存します。実際に使っているコードページとは異なっていても、カ
レントコードページのデフォルト値437を返すシステムもあります。（典型的
には、ディスプレイ装置に組み込まれたコードページを使用すると発生する。）
個人の初期化ファイルで変数`dos-codepage'を設定すれば、Emacsが使うコー
ドページ（番号）を別のものに指定できる。

マルチバイトEmacsは、特定のDOSコードページだけを扱えます。これらには、
日本語用コードページ932のような極東の文字を表示できものや、単一のISO
8859文字集合を符号化できるものが含まれます。

極東用コードページは、それらの国々用のMULE文字集合の1つを直接表示でき
ますから、Emacsは、コードページで扱える適切な端末コーディングシステム
を設定するだけです。本節の残りで述べる特別な機能は、ISO 8859文字集合を
符号化するコードページに関することです。

ISO文字集合の1つに対応したコードページに対しては、Emacsはコードページ
番号に基づいた文字集合名を知っています。Emacsは、カレントコードページ
を用いたファイルの読み書きを扱うコーディングシステムを自動的に作成し、
デフォルトでこのコーディングシステムを使います。コードページ番号をNNN 
とすると、このようなコーディングシステムの名前は`cpNNN'です。 (2)
(*Note MS-DOS and MULE-Footnotes::)

すべての`cpNNN'コーディングシステムは、モード行の表示に（『DOS』の）文
字`D'を使います。端末コーディングシステムとファイル入出力用のデフォル
トのコーディングシステムは、起動時に、正しく`cpNNN'コーディングシステ
ムに設定されますから、MS-DOSでは、モード行は普通`-DD\-'で始まります。
*Note Mode Line::。極東用DOS端末は、`cpNNN'コーディングシステムを使用
せず、そのため、初期のモード行はUNIXのようになります。

コードページ番号は、使用する文字群を指定しますから、Emacsは、その文字
群用の言語環境を選択するために`set-language-environment'を自動的に実行
します（*Note Language Environments::）。

バッファ内に異なるISO 8859文字集合に属する文字、すなわち、選択している
DOSコードページで扱えない文字が含まれる場合、Emacsはその文字をASCII文
字の列で表示します。たとえば、カレントコードページに文字``o' （アクサ
ングレーブ付きの小文字の`o'）の字形がないときには、中括弧で囲って1文字
であることを表して、`{`o}'と表示します。（このようにすると、ギリシャ文
字やヘブライ文字などの非Latin文字のなかには、とても見難くなるのもがあ
るが、その言語を知っている人には少なくとも読める。）1文字でも画面上は
数桁を占めますが、実際には単一の文字であり、Emacsのすべてのコマンドも1
文字として扱います。

DOSコードページ内のすべての文字がISO 8859文字に対応するわけではなく、
箱を描くための文字や他の図形用文字もあります。Emacs内部ではこれらの文
字を表現できませんので、これらの文字を含んだファイルを読み込むと、これ
らの文字は、変数`dos-unsupported-character-glyph'で指定した特定の文字
コードに変換されます。

Emacsは、ISO 8859以外の他の多く文字集合を扱えますが、それらをMS-DOS上
では表示できません。そのようなマルチバイト文字がバッファ内にあると、
MS-DOS上のEmacsは、変数`dos-unsupported-character-glyph'の指定どおりに
表示します。デフォルトでは、その字形は、白抜きの三角形です。コマンド
`C-u C-x ='を使って、そのような文字の実際の文字コードと文字集合を表示
してください。*Note Position Info::。

デフォルトでは、Emacsはカレントコードページを扱えるコーディングシステ
ムを定義します。（他国のDOSマシンで書いたファイルを訪問するなどの）他
のコードページ用のコーディングシステムを定義するには、コマンド`M-x
codepage-setup'を使います。これは、3桁のコードページ番号を問い合わせて
きますが、補完を使えます。そして、指定したコードページ用のコーディング
システムを作成します。これで、新たなコーディングシステムを使ってファイ
ルを読み書きできますが、このコーディングシステムを使うには、ファイルコ
マンドで明示する必要があります（*Note Specify Coding::）。

これらのコーディングシステムは、DOSコードページで符号化したファイルを
他のオペレーティングシステム上のEmacsで訪問する場合にも利用できます。


File: emacs-ja.info  Node: MS-DOS and MULE-Footnotes, Up: MS-DOS and MULE

(1) 通常、1つの特定のコードページはディスプレイメモリに組み込んであり、
他のコードページは、`CONFIG.SYS'などのシステム設定ファイルを変更
してリブートするとインストールできる。

(2) ISO 8859用のEmacsの標準コーディングシステムは、この目的には正しく
ない。というのは、典型的なDOSコードページは、標準のISO文字集合に一致し
ない。たとえば、文字`c,'（セディーユ付きの`c'）は、標準の
Latin-1文字集合ではコード231であるが、対応するDOSコードページ850ではこ
の文字はコード135である。



File: emacs-ja.info, Node: MS-DOS Processes, Next: Windows Processes, Prev: MS-DOS and MULE, Up: MS-DOS

サブプロセス（MS-DOS）
======================

MS-DOSはシングルプロセスの『オペレーティングシステム』なので、非同期な
サブプロセスは利用できません。特に、シェル（shell）モードやその派生モー
ドは動きません。綴りの修正やGUDなどの非同期のサブプロセスを用いたEmacs
の機能のほとんどは、MS-DOSでは動きません。疑うならば試してみてください。
動作不能なコマンドは、「非同期サブプロセスを使えない」旨のエラーメッセー
ジを出力します。

MS-DOS用Emacsでも、`M-x compile'によるコンパイル、`M-x grep'によるファ
イルの探索、`M-x diff'によるファイルの比較は動作しますが、これらは下位
プロセスを同期して走らせます。つまり、下位プロセスが終了するまではいっ
さい編集はできません。

対照的に、Windows専用にコンパイルしたEmacsでは、非同期プロセスを使えま
す。*Note Windows Processes::。

`lpr-buffer'（*Note Hardcopy::）や`ps-print-buffer'（*Note
Postscript::）のような印刷コマンドは、MS-DOSではプリンタポートの1つに
出力を送ることで動作します。*Note MS-DOS Printing::。

MS-DOSで同期的にサブプロセスを動かす場合には、プログラムが確実に終了し、
しかも、キーボードからまったく入力しないことを確認してください。MS-DOS
にはプロセスを終了させる一般的な方法がないので、プログラムがみずから終
了できない場合には、それを終了させることができなくなります。このような
場合、`C-c'や`C-BREAK'を押すと助かる場合もあります。

MS-DOSでは、他のマシンのファイルを参照することはできません。MS-DOSにネッ
トワーク機能が組み込まれていなければ、メイルの送信、Webの閲覧、リモー
トログインなどのネットワーク向けのコマンドも使えません。

MS-DOSでのdiredは、他のシステムではシステムの`ls'コマンドを使う場面で
パッケージ`ls-lisp'を使います。したがって、MS-DOSのdiredでは変数
`dired-listing-switches'に設定できるオプションは限られます。使えるオプ
ションは、`-A'、`-a'、`-c'、`-i'、`-r'、`-S'、`-s'、`-t'、`-u'です。



File: emacs-ja.info, Node: Windows Processes, Next: Windows System Menu, Prev: MS-DOS Processes, Up: MS-DOS

サブプロセス（Windows 95、NT）
==============================

（DOS版と対比して）Windows専用にコンパイルしたEmacsでは、非同期のサブ
プロセスを完全に使えます。Windows版では、32ビットのWindowsアプリケーショ
ンを実行している限りは、同期であれ非同期であれサブプロセスはうまく動作
します。しかし、サブプロセスでDOSアプリケーションを実行すると、アプリ
ケーションの実行に問題を生じたり実行できなかったりします。さらに、2つ
のDOSアプリケーションを同時に2つのサブプロセスで実行すると、システムを
リブートしなければならなくなります。

Windows 95の標準のコマンドインタープリタ（および、ほとんどのコマンド行
ユーティリティ）はDOSアプリケーションなので、この種のシステムを使う場
合には上記の問題は重要になります。しかし、これに関してわれわれにできる
ことは何もなく、Microsoftだけが修正できるのです。

DOSアプリケーションのサブプロセスを1つだけ実行するならば、『行儀がよく』
て、しかも、画面を直接操作するなどの非標準的な動作をしない限りは、サブ
プロセスは予想どおりに動作するはずです。CPUモニタ（監視）アプリケーショ
ンを使うと、DOSアプリケーションが停止しているときでさえも、マシンは
100%ビジーになりますが、これはCPUモニタがプロセッサの負荷を調べる方法
に起因します。

別のサブプロセスでDOSアプリケーションを実行する場合には、まえもってDOS
アプリケーションを終了しておく必要があります。Emacsは、DOSのサブプロセ
スに割り込んだり停止させることができません。このようなサブプロセスを終
了する唯一の方法は、そのプログラムに終了を指示するコマンドを与えること
です。

別々のサブプロセスにおいて2つのDOSアプリケーションを同時に実行しようと
すると、一方あるいは両方が非同期であるとしても、2番目に起動したものは
最初のものが終了するまで休止してしまいます。

最初のサブプロセスを操作できて終了を指示できるならば、2番目のサブプロ
セスは正常に実行を継続するはずです。しかし、2番目が同期サブプロセスで
あれば、最初のサブプロセスが終了するまではEmacs自体が固まってしまいま
す。ユーザー入力なしに終了できない場合には、Windows 95を使っている限り
リブート以外の選択はありません。Windows NTであれば、プロセスを調べるア
プリケーションを使って、適当なntvdmを終了させます（するとDOSの2つのサ
ブプロセスも終了します）。

このような状況でWindows 95をリブートすることが必要になったときには、
`Start'メニューの中の`Shutdown'コマンドを使ってはいけません。たいてい
の場合、システムが固まってしまいます。かわりに、`CTL-ALT-DEL'を打鍵し
て`Shutdown'を選びます。処理に数分かかる場合もありますが、多くの場合、
機能してくれます。



File: emacs-ja.info, Node: Windows System Menu, Prev: Windows Processes, Up: MS-DOS

Windowsのシステムメニューの利用
===============================

Windows専用にコンパイルしたEmacsでは、ALTキーを押してWindowsのメニュー
を立ち上げる機能を切ってあります。これは、EmacsではALTはMETAの働きをす
るからです。Emacsを利用しているときには、ユーザーはしばしばいったん
METAキーを押してから何もせずに放します。この動作でWindowsのメニューが
立ち上がってしまうと、以降のコマンドの意味が変ってしまいます。多くのユー
ザーにはこれでは邪魔でしょう。

`w32-pass-alt-to-system'に`nil'以外の値を設定すれば、ALTキーを押したと
きの処理はWindowsのデフォルトに戻ります。



File: emacs-ja.info, Node: Manifesto, Prev: MS-DOS, Up: Top

GNU宣言
*******

     GNU宣言（GNU Manifesto）（以下参照）は、GNUプロジェクトの初期の頃
     に、Richard Stallmanが参加とサポートを求めるために書いたものであ
     る。当初2〜3年間は、開発について説明するために参考として用いつつ
     更新していたが、現在では、人々がよく目にするので変更しないでおく
     ことが最善であると考えている。

     その時以来、我々は、いくつかの表現をわかりやすくしたつもりだがよ
     く誤解を招く点があることがわかった。そこで、そのような点を明確に
     するべく、1993年に脚注として追記した。

     現在配布可能なGNUソフトウェアに関する最新情報は、GNU's Bulletin
     （[訳注]日本語版であれば「GNUダイジェスト」）の最新号をご覧いただ
     きたい。ここに引用するには情報量が多すぎるので。


GNUとは何か？ GnuはUnixではない（Gnu's Not Unix）！
===================================================

GNUとはGnu's Not Unixの略であり、誰もがフリーに使えるよう (1) (*Note
Manifesto-Footnotes::)、私が今作成しているUnixと完全互換のソフトウェア・
システムの名称である。何人ものプログラマが私を手伝ってくれている。時間
やお金、プログラム、機器の寄付を大いに必要としている。

既に我々のもとには、エディタ・コマンド記述用のLispを備えているEmacsと
いうテキスト・エディタや、ソース・レベル・デバッガ、yacc互換の構文解析
部生成ツール、リンカ、その他約35個のユーティリティがある。シェル（コマ
ンド・インタープリタ）はほぼ完成している。移植性の良い新しい最適化Cコ
ンパイラは自分自身をコンパイルできるようになり、今年中にはリリースでき
るだろう。初期段階のカーネルはあるが、Unixをエミュレートするためにはもっ
と多くの機能が必要である。カーネルとコンパイラが完成すれば、プログラム
開発にふさわしいGNUシステムを配布できるだろう。テキスト処理にはTeXを採
用するつもりだが、nroff関連の作業も進行中である。また、フリーで移植性
の良いX Window Systemも採用する。そのあとは、移植性の良いCommon Lispや、
Empireゲーム、スプレッドシート、その他数多くのものを、オンライン・ドキュ
メントと共に追加していく。最終的には、Unixシステムに標準で付いている有
用なツール全てに加えて、さらにはそれ以上のものを提供したいと考えている。

GNUは、Unixのプログラムを実行できるようにするつもりだが、Unixとは同一
のものにはならない。他のオペレーティング・システムでの我々の経験を基に、
より使いやすくなるよう、全面的に改良していくからである。特に、長いファ
イル名の使用やファイルのバージョン番号、耐クラッシュ性に優れたファイル・
システム、ファイル名の補完機能（[訳注]ファイル名を途中まで指定しただけ
でそのあとはシステムが完全なファイル名を追加してくれる機能）、端末に依
存しない表示のサポート、おそらく最終的には、いくつかのLispプログラムと
通常のUnixプログラムが1つの画面を共有できるようなLispベースのウィンド
ウ・システムを作る予定である。システム・プログラミング言語としては、C
言語とLispの両方が使用可能になるだろう。通信用には、UUCP、MIT Chaosnet、
Internetの各プロトコルをサポートしようと考えている。

GNUでは、最初は68000/16000（[訳注]モトローラ68000とナショナル・セミコ
ンダクタの16000）クラスの仮想記憶を備えたマシンを対象とする。というの
は、GNUを最も実行しやすいマシンだからである。もっと能力の小さなマシン
上でGNUを動作させるための努力は、そのマシン上で使いたい人の手に委ねる
ことにする。

とんでもない誤解を避けるために、このプロジェクトの名称としての「GNU」
の場合は、「G」を発音していただきたい。（[訳注]もともと普通名詞のGnuは
ヌーという動物であり、その発音を採用するとGNU projectはヌー・プロジェ
クトになりnew projectと間違われる可能性もある。）


なぜGNUを作成しなければならないのか？
=====================================

もし私の好きなプログラムを他の人も好きであれば、私はその人とプログラム
を分かち合わなくてはならない、という黄金律（[訳注]自分の欲することは他
の人にも為すという考え方）を考案した。ソフトウェア販売会社は、ユーザ1
人1人に他人と共有しない契約をさせることによって、ユーザを分離し支配し
ようとしている。そのような方法で他のユーザとの連帯意識を壊すことは私は
嫌である。機密保持契約やソフトウェア・ライセンス契約へのサインは良心か
らできない。何年もの間、私はそういった傾向やその他の冷遇に抵抗するため
に、AIラボ内で活動してきたが、最後にはその傾向や冷遇は度を越していった。
私に対してAIラボが行なった事は私の意志に反するので、そこに留まることが
できなくなった。

信念を曲げることなくコンピュータを使い続けるために、フリーでないソフト
ウェアがなくてもうまくやっていけるようなフリー・ソフトウェアのしっかり
した団体を組織することを決意した。私がGNUを配布することをMITが合法的に
阻止するのを拒否するために、私はAIラボを辞職した。


なぜGNUはUnix互換なのか？
=========================

Unixは私の理想とするシステムではないが、それほど悪いシステムでもない。
Unixの基本的な機能は良いものなので、それらを生かしつつ、Unixに欠けてい
るものを補っていけるだろうと考えている。また、Unix互換のシステムであれ
ば、GNUを採用する他の多くの人々にとっても有用であろう。


GNUをどうやって配布するか？
===========================

GNUはパブリック・ドメインには置かない。それにより、誰もがGNUを修正して
再配布でき、配布者が再配布することを禁止されることもない。つまり、独占
的な修正はできないのである。私は、あらゆるバージョンのGNU （[訳注]誰で
もソース・コードをアクセスできるという意味で）が確実にフリーであり続け
て欲しいのである。


なぜ他の多くのプログラマが協力してくれるのか？
==============================================

私は、他の数多くのプログラマがGNUに熱狂し、そして協力したがっているこ
とを知った。

多くのプログラマが、システム・ソフトウェアの営利化に不満を抱いている。
その営利化とは、プログラマに金儲けをさせる代わりに、他の一般のプログラ
マを仲間ではなく競争相手として見るよう仕向けるからである。プログラマ間
の友情を示す基本的な行為は、プログラムの共有である。現在の典型的な市場
の取り決めは、プログラマが他のプログラマを友人として接することを根本的
に禁じてしまっている。ソフトウェアの購入者は、友情をとるか、法律に従う
かを選択しなくてはならない。当然、友情のほうが大切であると考える人のほ
うが多いだろう。しかし、法律に従うべきであると考える人のなかには、この
ようなことが簡単に選択できない人が多い。そういう人は人の誠意を信じない
人間になっており、プログラミングは単なる金儲けの一手段でしかないと考え
ているからである。

独占的なプログラムではなくGNUに関する作業を行ない、GNUを使っていれば、
誰に対しても排斥的ではなくなり法を守ることもできる。さらに、GNUは共有
という点において、激励するための一例となり、人々が我々に参加すべく結集
するための旗印となる。これにより、もし我々がフリーでないソフトウェアを
使っていては得られないある種の和の感情を抱くことができる。私が対話した
プログラマのうちの約半数が、これはお金には換えられない大切な幸福である
と言っている。


あなたはどのようにしたら貢献できるか？
======================================

私は、コンピュータ・メーカにはマシンとお金の寄付を求めている。個人に対
してはプログラムと労働の寄付を求めている。

マシンの寄付を受けた場合は、その見返りの1つとして、GNUが近いうちにその
マシン上で動作するようになるだろう。マシンは完成していてシステムが使え
る状態であり、住宅区域で使用可能で、特殊な冷却や電力を必要としないもの
でなくてはならない。

私は非常に多くのプログラマがGNUのためにパートタイムで作業する熱意があ
ることを知った。ほとんどのプロジェクトでは、そういったパートタイムでの
分散した作業をまとめていくことは非常に困難だろう。しかし、Unixを置き換
えるというこの特定の作業に関しては、そのような問題はない。完全なUnixシ
ステムには数百ものユーティリティ・プログラムがあり、その1つ1つには別個
にドキュメントが付いている。たいていのインタフェース仕様は、Unixとの互
換性の観点から決定されている。プログラマ各人が単一のUnixユーティリティ
と互換の代替品を作成できれば、そのようなユーティリティをひとまとめにし
ても正しく動作するはずである。マーフィーの例で言えば、いくつか予期せぬ
問題が生じたとしても、これらの構成要素をまとめることは可能な作業であろ
う。（カーネル作業には、より緊密なコミュニケーションが必要なので、少人
数で密接なグループでの作業となる。）

お金の寄付を受けた場合は、フルタイムかパートタイムで2〜3人を雇えるだろ
う。給料はプログラマの標準収入ほど高くはないが、お金を稼ぐことと同じよ
うに共同体精神を築くことは重要だと考えている人を私は捜している。私は、
この給料とは、プログラマが別の方法で生計を立てなくても、GNU作業に全力
投球できるようにするための一手段としてとらえている。


なぜ全てのコンピュータ・ユーザが恩恵をうけるのか？
==================================================

いったんGNUが作成されれば、誰もが良質のシステム・ソフトウェアを無料で
入手できるようになる。 (2) (*Note Manifesto-Footnotes::)

これは、Unixライセンスの価格を誰もが節約できることだけではなく多くのこ
とを意味する。つまり、非常に無駄となるシステム・プログラミングの重複を
避けることができる。代わりに、その労力は現在の技術水準の進歩に向けるこ
とができる。

完全なシステム・ソースは誰に対しても配布可能になる。そのため、システム
に変更を施さなくてはならないユーザは、自分でいつでも自由にそれを行なっ
たり、あるいは、自分の代わりにそれを行なってくれるプログラマや企業を雇
うことができるようになる。ユーザはもはや、ソース・コードを所有するプロ
グラマや企業のなすがままになることはなく、変更を施すことに関しては独立
した存在でいられる。

大学側は、学生にシステム・コードを学習し、改良するよう奨めることにより、
はるかに良い教育環境の提供が可能になる。ハーバード大学のコンピュータ研
究所では、ソース・コードを公開して見れないようなプログラムは一切、シス
テムにインストールしないという方針が習慣であり、特定のプログラムをイン
ストールすることを実際に拒否することを支持した。このことに私は非常に勇
気づけられた。

最後に、システム・ソフトウェアを誰が所有しているのかを、それを使ってやっ
ていいことといけないことを考慮することのオーバーヘッドが解消されるだろ
う。

人々にプログラムの使用料を支払わせる契約（複製のライセンスを含む）は常
に、人がいくら（つまり、どのプログラムに）支払わなくてはならないかを理
解するのに欠くことのできない厄介な機構を通じて、社会は多大なコストを被っ
ている。そして、警察国家でもなければ、そのような機構に全ての人を従わせ
ることはできない。例えば、多大なコストをかけて空気を製造しなくてはなら
ない宇宙ステーションのことを考えてみよう。空気1リットルごとの息継ぎに
課金すれば公平かもしれないが、たとえ皆が空気料金を支払う余裕があったと
しても、そのために一日中メータ付きの空気マスクを付けるとなれば耐え難い
ことである。まして、マスクを外したかどうかをTVカメラが至る所で見張って
いるなどというのは、全くとんでもないことである。それよりは、料金を頭割
りにした税金で空気工場を維持して、マスクを外すほうがましである。

プログラムの一部または全てを複写することは、プログラマにとって呼吸する
のと同じくらい自然なことであり生産的なものである。だから、プログラムは
フリーであるべきである。


GNUの目標への異議と、簡単にできる反証
=====================================

     『プログラムがフリーであれば誰もそれを使わないだろう。なぜならば、
     無料ということは、サポートを当てにできないからである。』

     『サポートを提供するために料金をプログラムに課す必要がある。』

人々が、サービスのない無料のGNUよりも、サービス付きの有料のGNUのほうに
支払うというのであれば、GNUを無料で入手した人々に対して、サービスだけ
を提供する企業は利益を得て当然である。 (3) (*Note
Manifesto-Footnotes::)

本当のプログラミング作業を行なうサポートと、単なる支援とは区別すべきで
ある。前者は、ソフトウェア業者からのサポートを当てにできない種類のもの
である。もしあなたの問題が多くの人々の問題になっていなかった場合には、
ソフトウェア業者は邪魔しないでほしいと言うだろう。

あなたのビジネスがサポートに頼らざるをえない場合は、必要なソース・コー
ドとツールを全て自分で抱えるしかない。そうすれば、あなたの問題点を直し
てもらうための人を雇うことができる。人に翻弄されることはない。Unixを使
う場合、ソース・コードが高価なので、ほとんどのビジネスではこのようなこ
とはできない。GNUを使えば、これは簡単に実現する。有能な人材がいなかっ
たとしても可能であり、しかも、問題点を修正できないのは配布規定のせいで
は断じてない。GNUは、世界中の全ての問題ではなく、その一部のみを取り除
いている。

一方、コンピュータについて何も知らないユーザには支援が必要である。自分
で容易に処理できる範疇であっても、その方法を知らない場合に支援が必要な
のである。

そのようなサービスは、単なる指導や修理サービスだけを行なっている企業が
請け負うことができるだろう。ユーザがお金を支払ってもサービス付きの製品
を購入するほうが良いと考えているのであれば、無料の製品に対するサービス
にも喜んでお金を払うだろう。サービス会社は、品質と価格の面で競争するこ
とになり、ユーザは特定のサービス会社にこだわる必要がなくなる。一方、サー
ビスを必要としない我々等などであれば、サービスへの対価を支払わなくても、
プログラムを使うことができる。

     『広告なしでは多くの人々に知らせることは無理であり、その費用だけ
     でもプログラムに料金を課すべきである。』

     『誰もが無料で入手できるようなプログラムを宣伝しても仕方がない。』

GNU等の情報を、多くのコンピュータ・ユーザに知らせられるような無料また
はきわめて安価な広告媒体がいろいろとある。しかし、宣伝すれば、より多く
のマイクロコンピュータ・ユーザに知らせられるというのも事実かもしれない。
本当にそうであれば、GNUを無料で複写したり配布するサービスを宣伝するビ
ジネスは、その広告費用にかかった以上の成功をおさめるはずである。この方
法は、宣伝によって利益を得るユーザだけが広告料を払うものである。

他方では、多くの人々が友人からGNUを入手するので、上記のような企業が成
功しないというのであれば、その宣伝がGNUを広める上で、本当に必要なもの
ではないということである。なぜ自由市場擁護者は、このことを自由市場に決
めさせたくないのだろうか？ (4) (*Note Manifesto-Footnotes::)

     『私の会社は、競争の頂点に立つために独占的なオペレーティング・シ
     ステムが必要である。』

GNUにより、オペレーティング・システム・ソフトウェアは競争の世界から取
り除かれることになるだろう。このオペレーティング・システム・ソフトウェ
アの分野では、あなたは競争の頂点に立つことはできないし、競争相手もそう
なることはできない。この分野では、あなたとその競争相手は互いに利益を受
け、競い合うのは他の分野でということになる。あなたのビジネスがオペレー
ティング・システムの販売であった場合には、GNUは好ましくなく、あなたに
とって厳しい状況になるだろう。あるいは他の種類のビジネスならば、オペレー
ティング・システムの販売といった高価なビジネスにあなたが強要されないよ
う、GNUがあなたを救うことができる。

私は、多くのメーカやユーザからの寄付に支えられてGNUが発展し、そのよう
な人々の個々のコストが軽減されていくのをこの目で見たいと思う。 (5)
(*Note Manifesto-Footnotes::)

     『プログラマは自分の創造性に対して報酬を受けるに値しないのではな
     いか？』

何事にも報酬があるとしたら、それは社会的貢献である。創造性は社会的貢献
となりうるが、それは社会がその成果を自由に使用できる場合に限られる。も
しプログラマが、革新的なプログラムを作成したことで報酬を得るとしたら、
そのようなプログラムの利用を制限した場合にも同じ理由で罰に値する。

     『プログラマは、自分の創造性に対して報酬を要求してはいけないので
     はないか？』

仕事に対して支払いを求めたり、自分の収入を最大に増やすよう求めることは、
破壊的な手段を使わない限り、何ら悪いことではない。しかし、今日のソフト
ウェア分野で習慣となっている手段は、破壊的行為に基づいている。

プログラムの使用を制限してプログラムのユーザからお金をとることは、その
制限のせいで、使用できるプログラムの種類や方法が減ってしまうので、破壊
的行為となる。これは、人類がプログラムから得られる富の量を減らしてしま
う。故意に制限すると決定したときには、意図的な破壊という有害な結果をも
たらすだろう。

善良な市民がそのような破壊的手段を用いないのは、そうしないことこそが裕
福であると思っているからである。もし誰もが破壊的手段を用いたとしたら、
我々は互いの破壊行為によってさらに貧しくなっていくばかりであろう。これ
がカント哲学の倫理、または黄金律である。皆が情報を隠し持った結果として
生じる結末を私は好まないので、そうすることは悪いことであると考えざるを
得ない。明確に言えば、自分の創造性が報われたいという欲望は、その創造性
の全部または一部を、一般の世の中から奪う言い訳にはならない。

     『プログラマは飢えてしまわないだろうか？』

プログラマに強要できる者はいないということは言える。我々の大半は、街に
立ってしかめ面をしてもどうにもお金を稼ぐことはできない。しかし、結果的
には、我々がしかめ面をしながらひもじい思いをしつつ街に立って一生を過ご
すことになったとしても、それを厳しく非難されはしない。我々には他にする
ことがあるからである。

しかし、これは、質問者の暗黙の仮定、つまり、ソフトウェアの所有権がなけ
れば、プログラマは一銭たりとも収入を得ることはできないという仮定を受け
入れているので間違った答えである。おそらく、一か八かということなのだろ
う。

プログラマが飢えてしまわない本当の理由は、単に今ほどの額ではないだけで
あって、プログラミングに対しては支払われる可能性が依然としてあるからで
ある。

複写を制限することだけが、ソフトウェアにおけるビジネスの唯一の基礎では
ない。それが最も多くのお金をもたらすので、一番の共通基盤になっているだ
けである。もし顧客のほうから複写の制限を禁じたり拒絶すれば、ソフトウェ
ア・ビジネスの組織の土台は、今ではあまり多くは使用されていないような別
の種類ものへと変わるだろう。

おそらく、新しい基盤のもとではプログラミングは現在と同じくらいの利益に
しかならないだろう。しかし、それだからといって変化に反対する理由にはな
らない。販売員が今と同じ給料を得ることが不公平だというのではない。プロ
グラマも同様に今と同じ給料を得たとしても、不公平にはならないだろう。
（実際、プログラマは給料以上のことを行なうだろうから。）

     『人々には自分の創造性がどのように使用されるのかを制御する権利が
     あるのではないか？』

『自分のアイデアの使用を制御すること』は実は、他人の人生を制御し、一般
にその人の人生をもっと困難にするために用いられる性質のものである。

（弁護士のように）知的所有権の問題を勉強した人によれば、知的所有物には
本来の権利もないと言っている。政府が認めている推定上の知的所有権の類は、
特定の目的のための特定の法律によって作り出されたものである。

例えば、特許制度は、発明家がその発明の細部を公開するよう促進するために
制定された。その目的は、発明家を保護するというよりは、社会を保護するこ
とにあった。当時、17年という特許の保護期間は、技術水準の進歩に比べて短
いものであった。特許は製造業者の間だけの問題なので、ライセンス契約のコ
ストや手間が製品作りの準備に比べれば少ないような人々にとっての特許とは、
さほどの損害にはならない場合が多い。特許製品を使用するたいていの個人を
妨害してはいない。

著作権という概念は、著者がノンフィクション作品の中に他の著者から長々と
頻繁に真似ていた古代には存在しなかった。この習慣は役に立っていたし、現
在でも多くの著者の作品に部分的に生き続けている習慣である。著作権制度は、
著述業を明白に促進するために作られた。その制度が作られた分野として本が
あるが、これは印刷するだけで安く複製できるのでほとんど損害を与えること
はなく、何よりも本を読む個人を妨害することはなかった。

全ての知的所有権は、社会が認めるライセンスにすぎない。というのは、良き
につけ悪しきにつけ、知的所有権を認めることにより社会全体が利益を得ると
考えられたからである。しかし、どのような特殊な状況においても、我々には
問直さなければならないことがある。「我々はそのようなライセンスを認める
ことで本当により裕福になるのか？」、「我々はどのような種類の行為を人に
許可しているというだろうか？」と。

今日のプログラム事情は、100年前の書物のときとは全く異なっている。例え
ば、プログラムを複写するときの最も簡単な方法は、隣の人からさらに隣の人
へと順にまわしていくという事実や、プログラムにはソース・コードとオブジェ
クト・コードがあってそれぞれ別のものであるという事実、プログラムは読ん
だり楽しむものではなく使用されるものであるという事実が混ぜ合わされて、
著作権を押し通す人が、物質的にも精神的にも社会全体に害を及ぼしている状
況を作り出しているのである。つまり、法的に著作権の強要が可能かどうかに
かかわらず、人はそのようなことをすべきではないということである。

     『競争が物事をより良くしていく。』

競争の典型はレースである。勝者には報酬が与えられるので、誰もがもっと速
く走ろうと努力する。資本主義が本当にこの方法で機能すればよいが、資本主
義の擁護者は、この方法で常に機能することを前提としている点が間違ってい
る。例えば、なぜ報酬が与えられるのかを走者が忘れてしまい、手段を選ばず
勝つことのみに執着したとすれば、他の走者を攻撃するといった他の作戦をと
るかもしれない。走者達が真っ先に殴り合いをしてしまえば、皆のゴールイン
が遅れてしまうだろう。

ソフトウェアの占有と秘密は、真っ先に殴り合う走者と道義的には同じである。
悲しいことに、我々の唯一の審判でさえ、殴り合いに反対していないように見
える。ただ走者を（『10ヤード走るごとに1発殴ってもよい』というふうにし
て）規制するだけである。審判は本来、そのような走者達の中に分け入って、
暴力を働こうとした走者を罰してしかるべきである。

     『金銭的な刺激がなくなっては誰もプログラミングなどしないのではな
     いか？』

実際には、多くの人々が金銭的刺激が皆無であってもプログラムを書いている
だろう。プログラミングには、一部の人にとってはたまらないほどの魅力があ
り、そういう人こそプログラミングに最も向いている。音楽で生計を立てる望
みがないからといって、プロの音楽家がいなくなることはない。

しかし、この疑問は実際、よく提起されるのだが、現実に即してはいない。プ
ログラマへの支払いは少なくなっても、無くなることはない。したがって、正
しい質問は、『金銭的な魅力が減っても人はプログラムを書くか？』となる。
私の経験がそれを語っている。

10年以上もの間、世界中の多くの最優秀プログラマが、よそでならもっと収入
を得られたはずにも関わらず、AIラボで働いてきた。彼らは、金銭ではない報
酬、例えば、名声や感謝といったものを得てきた。そして、創造は楽しくもあ
り、それ自体が自分への報償であった。

やがて、彼らの大半は、多くの給料をもらいながら引き続き興味ある同じ仕事
ができる機会を与えられて去っていった。

この事実は、人は金持ちになること以外の理由でもプログラムを書くというこ
とを示している。しかし、より多くのお金を得る機会があれば、人はそれを期
待し求めもするだろう。給料が少ない組織は、多いところと競争すれば劣勢に
はなるが、給料の多い組織が息詰まっても、少ないほうまで悪くなるわけでは
ない。

     『我々は絶望的になってプログラマを必要としているのではないか。我々
     の隣人を助けるのをやめるようプログラマが我々に要求すれば、我々は
     それに従わざるを得ない。』

あなたは、そういった要求に従うほど決して絶望的ではない。忘れないでいた
だきたい。そのような要求に従わなければ数百万ドルの価値となるが、従えば
1セントもの賛辞には値しないのである！

     『プログラマは何とかして生計を立てなくてはならない。』

短い目で見ればこれは当てはまる。だが、プログラマが、プログラムの使用権
を売らずに生計を立てていける方法はいくらでもある。この方法は、他に生計
を立てる手立てがないからではなく、プログラマやビジネスマンに多額のお金
をもたらすので、今では慣習的となっている。他の方法を見つけようと思えば
簡単に見つかる。その例をいくつか示しておく。

新しいコンピュータを導入している製造業者は、新しいハードウェアにオペレー
ティング・システムを移植する作業に対して支払うだろう。

プログラミングに関する教育や指導、保守といったサービスをビジネスとする
場合にもプログラマを雇うことができるだろう。

新しいアイデアを持った人は、プログラムをフリーウェアとして配布し、それ
に満足したユーザに寄付を求めたり、簡単な指導サービスをビジネスにするこ
とができるだろう。私は、この方法を既に実践して成功した人々を知っている。

似たような要求があるユーザ同士は、ユーザ・グループを組織し、会費を払う。
グループでは、ソフトウェア業者と契約して、メンバーが使いたいプログラム
を作成してもらう。

あらゆる種類の開発が、以下に示す「ソフトウェア税」で積み立てることがで
きる。

     コンピュータを買う人は誰でも、ソフトウェア税として、その価格のxパー
     セントを支払うようにする。政府は、これを、ソフトウェア開発のため
     にNSF （[訳注]米国科学財団、National Science Foundation）のような
     機関に与える。

     ただし、コンピュータの購入者がソフトウェア開発に寄付する場合には、
     相当額の税金控除となる。自分で選んだプロジェクトへ寄付することが
     できる。ほとんどは、プロジェクトの成果を利用したいような所を選ぶ
     だろう。本来支払うべき税金の合計を上限として、寄付金の額に応じて
     控除することができる。

     全体の税率は、課税額に応じて重み付けをし、納税者の投票によって決
     定可能とする。

     その結果、

        * コンピュータを使用するコミュニティはソフトウェア開発を支援す
          る。
        * そのコミュニティは、どの程度のサポートが必要なのかを決定する。
        * 自分達の負担したものがどのプロジェクトに費されるかに関心のあ
          るユーザは、自分で（[訳注]立ち上げて欲しい）プロジェクトを選
          ぶことができる。

長い目で見た場合には、プログラムをフリーにすることは、欠乏の無い世界へ
の第一歩であり、そこでは誰も生計を立てるためだけにあくせく働く必要はな
いだろう。人々は、週に10時間の課せられた仕事、例えば、法律の制定や、家
族との相談、ロボットの修理、小惑星の試掘といった必要な仕事をこなしたあ
とは、プログラミングといった楽しめる活動に自由に専念することになるだろ
う。もはやプログラミングで生計を立てる必要はなくなる。

我々は既に、社会全体が実質的生産のためにしなければならない作業量を大幅
に減らしてきたが、そのうちのほんのわずかが労働者の娯楽に変わっただけで
ある。というのは、生産活動に伴い多くの非生産活動が必要とされるからであ
る。その主な原因は、官僚主義と競争に対する差の無い骨折りである。フリー・
ソフトウェアは、ソフトウェア生産の分野でこれらの乱費流出を大幅に減らす
だろう。生産における技術的利得が我々にとっての労働の軽減になるよう、我々
はこれを行なっていかなければならないのである。


File: emacs-ja.info  Node: Manifesto-Footnotes, Up: Manifesto

(1) ここの言葉遣いは不注意であった。意図することは、誰もGNUシステムを
使う*許可*のために支払う必要はない、という意味である。しかし、こ
れでも明確になっていないし、GNUの複写は常にほとんどまたは全くの無料で
配布されるべきであると言われていると解釈している人が多い。後述で、この
宣言では、利益のために配布サービスを提供している企業の可能性について述
べているように、これは意図した意味では決してない。その後、私は、自由と
いう意味の『フリー』と価格という意味の『無料』を注意深く区別するように
なった。フリー・ソフトウェアとは、配布する自由と変更する自由をユーザが
持っているソフトウェアのことである。無料でコピーを入手するかもしれない
ユーザもいれば、コピーの入手に支払うユーザもいるかもしれない。また、集
まったお金がソフトウェアの改良支援となればますます良いことである。重要
なことは、コピーを持っている人は誰でも、そのコピーの使用にあたり、他人
と協力するための自由があるという点である。

(2) これは、2種類の意味を持つ『フリー』について私が注意深く区別するの
を怠ったもう1つの箇所である。この文は文字どおりの意味である。つまり、
GNUソフトウェアのコピーを友人やネット経由で無料で入手することができる、
という意味である。ただし、間違った考え方を提示してしまっている。

(3) そのような企業は現に数社存在する。

(4) Free Software Foundationは企業ではなく慈善団体ではあるが、配布サー
ビスで資金の大半を調達している。FSFへの注文によってコピーを入手する人
がいなくなると、作業ができなくなるだろう。しかし、これは独占的制限によっ
てユーザに支払いを強要することが正しいという意味ではない。たとえ小さな
注文であってもユーザ全てがFSFへコピーを発注してくれれば、それだけでFSF
は借金をしないで済む。あなたなりに何か貢献しているのか？

(5) コンピュータ企業が数社集まって、GNU Cコンパイラの保守をサポートす
るための資金を最近共同出資した。


File: emacs-ja.info, Node: Glossary, Next: Key Index, Prev: Intro, Up: Top

用語集
******

略語（Abbrev）
     略語とは、バッファ内では別のテキスト文字列に展開されるテキスト文
     字列のこと。たとえば、頻繁に挿入する長い句に対して数個の文字から
     成る略語を定義する。*Note Abbrevs::。

アボート（Aborting）
     アボートとは、再帰編集《参照》から脱出すること。コマンド`C-]' (1)
     (*Note Glossary-Footnotes::) や`M-x top-level'はこのために使う。
     *Note Quitting::。

アルト（Alt）
     アルトは、キーボードからの入力文字に付く修飾ビットの名前である。
     アルト文字にするには、ALTキーを押し下げたまま文字を打ち込む。この
     ような文字は、`Alt-'（普通は縮めて`A-'）で始まる名前になる。（多
     くの端末にはALTと刻印したキーがあるが、実際にはMETAキーとして働
     く。）*Note Alt: User Input.。

ASCII文字（ASCII character）
     ASCII文字は、ASCIIコントロール文字かASCII印字文字のいずれかである。
     *Note User Input::。

ASCIIコントロール文字（ASCII control character）
     ASCIIコントロール文字は、大文字のコントロール版か、文字`@[\]^_?'
     のコントロール版のいずれかである。

ASCII印字文字（ASCII printing character）
     ASCII印字文字には、アルファベット、数字、空白、`!@#$%^&
     *()_-+=|\~` {}[]:;"' <>,.?/'などの区切り文字が含まれる。

自動詰め込みモード（Auto Fill Mode）
     自動詰め込み（auto-fill）モードはマイナモードであり、挿入したテキ
     ストは固定幅の行に収まるように自動的に分割される。*Note Filling::。

自動保存（Auto Saving）
     自動保存とは、Emacsバッファの内容を特別な名前のファイルに保存する
     行為のことであり、システムのエラーやユーザーのエラーでバッファが
     失われても、情報が消えないようにする。*Note Auto Save::。

バックアップファイル（Backup File）
     バックアップファイルは、現在の編集作業を始めるまえのファイルの内
     容を記録している。Emacsは、後悔した場合に備えて、変更を見直したり
     取り消すために自動的にバックアップファイルを作成する。*Note
     Backup::。

括弧の対応付け（Balance Parentheses）
     Emacsは手動でも自動でも括弧を対応付けられる。手動対応付けは、対応
     した式のあいだを移動するコマンドで可能である（*Note Lists::）。自
     動対応付けは、挿入した括弧に対応するものを点滅したり、強調表示す
     ることで可能である（*Note Matching Parens: Matching.）。

バインド（Bind）
     キー列をバインド（束縛）するとは、キー列にバインディング《参照》
     を与えることである。*Note Rebinding::。

バインディング（Binding）
     Emacsにおいてキー列が意味を持つには、バインディング、つまり、その
     キー列を打ち込むと実行されるLisp関数であるコマンド《参照》が与え
     られる必要がある。*Note Binding: Commands.。カスタマイズでは、文
     字に別のコマンド関数をリバインド（再束縛）することがよく行われる。
     すべてのキー列のバインディングはキーマップ《参照》に記録される。
     *Note Keymaps::。

空行（Blank Lines）
     空行は白文字だけを含む行である。Emacsには、バッファ内の空行を操作
     するコマンドがある。

バッファ（Buffer）
     バッファは基本的な編集単位である。1つのバッファは編集中の1つのテ
     キストに対応する。複数のバッファを使えるが、ある時点で編集できる
     のはたった1つの『選択した』バッファのみである。しかし、複数のウィ
     ンドウ《参照》を使えば、同時に複数のバッファを眺めることもできる。
     ほとんどのバッファはファイルを訪問《参照》したものである。*Note
     Buffers::。

バッファ選択履歴（Buffer Selection History）
     Emacsは、各バッファがどの程度最近に選択されたかをバッファ選択履歴
     に記録する。この記録は、選択するバッファを選ぶのに使われる。*Note
     Buffers::。

ボタン押し下げイベント（Button Down Event）
     ボタン押し下げイベントは、マウスボタンが押されるとただちに発生す
     る入力イベントの一種である。*Note Mouse Buttons::。

`C-'
     文字の名前の`C-'は、コントロール（Control）の略である。*Note C-:
     User Input.。

`C-M-'
     文字の名前の`C-M-'は、コントロール・メタ（Control-Meta）の略であ
     る。*Note C-M-: User Input.。

大文字小文字変換（Case Conversion）
     大文字小文字変換とは、テキストの大文字を小文字に変換すること、あ
     るいは、その逆に変換することである。大文字小文字変換のコマンドに
     ついては、*Note Case::。

文字（Character）
     文字はEmacsバッファの内容を構成する。*Note Text Characters::。ま
     た、キー列《参照》は、（他の入力イベントを含むこともあるが）通常、
     文字から成る。*Note User Input::。

文字集合（Character Set）
     Emacsでは、特定のアルファベットや文書を表現する多くの文字集合を使
     える。*Note International::。

クリックイベント（Click Event）
     クリックイベントとは、マウスボタンを押し下げて移動せずに放したと
     きに生成される入力イベントの一種である。*Note Mouse Buttons::。

コーディングシステム（Coding System）
     コーディングシステムとは、ファイルや情報ストリームにおいてテキス
     ト文字を表現するための符号化である。Emacsには、ファイルの読み書き
     時に、さまざまなコーディングシステム間でテキストを変換する機能が
     ある。*Note Coding Systems::。

コマンド（Command）
     コマンドとは、Emacsにおいてキーバインディングとなりうるように特別
     に定義されたLisp関数である。キー列《参照》を打ち込むと、実行すべ
     きコマンドを決定するために、適切なキーマップ《参照》からキー列の
     バインディング《参照》を探す。*Note Commands::。

コマンド名（Command Name）
     コマンド名とは、コマンド（*Note Commands::）であるLispシンボルの
     名前である。`M-x'を使えば任意のコマンドを名前で起動できる。
     （*Note M-x::）。

コメント（Comment）
     コメント（注釈）とは、プログラムを読む人間だけを対象としたプログ
     ラム内のテキストであり、プログラムをロードしたりコンパイルすると
     きには無視するように特殊な印が付いている。Emacsには、コメントを作
     成、整列、キルするコマンドがある。*Note Comments::。

コンパイル（Compilation）
     コンパイルとは、ソースコードから実行プログラムを作成する処理であ
     る。Emacsには、Emacs Lispコード（*Note バイトコンパイル:
     (elisp)Byte Compilation.）やCなどの他の言語で書いたプログラムのファ
     イルをコンパイルするコマンドがある。（*Note Compilation::）。

完結キー（Complete Key）
     完結キーとは、Emacsが実行する1つの動作を完全に指定するキー列であ
     る。たとえば、 `X'、`C-f'、`C-x m'は完結キーである。完結キーは、
     コマンド《参照》にバインド《参照》されていることでその意味が与え
     られる。したがって、`X'は、通常、バッファに`X'を挿入するコマンド
     にバインドされている。`C-x m'は、通常、メイルメッセージを作成する
     コマンドにバインドされている。*Note Keys::。

補完（Completion）
     補完とは、省略された名前からEmacsが自動的に完全な名前に補うことで
     ある。入力として正しいものが既知の場合には、ミニバッファ《参照》
     引数に対して補完が行われる。たとえば、コマンド名、バッファ名、ファ
     イル名である。TAB、SPC、RETを打ち込むと補完が行われる。*Note
     Completion::。

継続行（Continuation Line）
     テキスト行がウィンドウの幅より長いと、表示すると画面上では1行を越
     える。このようなテキスト行は継続しているといい、テキスト行に対応
     する表示行の2行目以降のすべての表示行を継続行と呼ぶ。*Note
     Continuation: Basic.。

コントロール文字（Control Character）
     コントロール文字とは、CTRLキーを押し下げたまま打ち込んだ文字のこ
     とである。コントロール文字のなかには独自のキーを持つものもあり、
     それらはCTRLを使わずに打ち込める。たとえば、RET、TAB、ESC、DELは
     コントロール文字である。*Note User Input::。

Copyleft
     copyleft（コピーレフト）とは、プログラムやその他の創作結果を再配
     布することを合法的に公に許可を与える旨の告示である。自由と協調を
     推進する左派のプログラマはcopyleftを使い、他人に権力を振いたい右
     派のプログラマはcopyright（コピーライト）を使う。

     GNUプロジェクトで用いているcopyleftは、GNU一般公有使用許諾書（GNU
     General Public License）と呼ばれる。*Note Copying::。

カレントバッファ（Current Buffer）
     Emacsのカレントバッファとは、ほとんどの編集コマンドが実行される
     Emacsバッファのことである。任意のEmacsバッファをカレントバッファ
     として選択できる。*Note Buffers::。

現在行（Current Line）
     ポイント（*Note Point::）がある行。

現在の段落（Current Paragraph）
     ポイントがある段落。段落のあいだにポイントがある場合には、現在の
     段落はポイントのうしろにあるものである。*Note Paragraphs::。

現在の関数定義（Current Defun）
     ポイントがある関数定義（defun）《参照》。関数定義のあいだにポイン
     トがある場合には、現在の関数定義はポイントのうしろにあるものであ
     る。*Note Defuns::。

カーソル（Cursor）
     カーソルとは、挿入や削除が行われるポイント《参照》と呼ばれる位置
     を表す画面上の矩形である。カーソルは、ポイントのうしろにある文字
     の前景か背景にある。「ポイント」のことを意味して「カーソル」とい
     うことが多い。*Note Cursor: Basic.。

カスタマイズ（Customization）
     カスタマイズとは、Emacsの動作を少々変更することである。変数
     （*Note Variables::）を設定したり、キー列をリバインド（再束縛）す
     る（*Note Keymaps::）ことでカスタマイズを行うことが多い。

デフォルト引数（Default Argument）
     引数のデフォルトとは、特に指定しないときに仮定される値のことであ
     る。引数を読むのにミニバッファを使うとき、RETだけを打ち込むとデフォ
     ルト引数が使われる。*Note Minibuffer::。

デフォルトディレクトリ（Default Directory）
     `/'や`~'で始まらないファイル名を指定すると、それはカレントバッファ
     のデフォルトディレクトリ相対に解釈される。*Note Default
     Directory: Minibuffer File.。

関数定義（Defun）
     defunは、プログラムのトップレベルにある括弧構造のリストである。こ
     の名称は、Lispプログラムにおいてこのようなリストが、（関数を定義
     する）Lisp関数defunの呼び出しになっていることに由来する。*Note
     Defuns::。

DEL
     DELは、テキストの1文字を削除するコマンドを実行する文字である。
     *Note DEL: Basic.。

削除（Deletion）
     削除とは、キルリング《参照》へコピーせずにテキストを除去すること
     である。他の手段にはキル《参照》がある。*Note Deletion: Killing.。

ファイルの削除（Deletion of Files）
     ファイルの削除とは、それをファイルシステムから除去することである。
     *Note Misc File Ops::。

メッセージの削除（Deletion of Messages）
     メッセージの削除とは、メイルファイルから除去する旨の印（削除印）
     を付けることである。rmailファイルを抹消（expunge）《参照》しない
     限り、削除したメッセージを復元できる。*Note Rmail Deletion::。

ウィンドウの削除（Deletion of Windows）
     ウィンドウの削除とは、画面からウィンドウを除去することである。空
     いた場所を埋めるように他のウィンドウが延びる。削除したウィンドウ
     は二度ともとに戻らないが、それで実際のテキストが失われるわけでは
     ない。*Note Windows::。

ディレクトリ（Directory）
     ファイルディレクトリとは、ファイルシステムにおいて名前が付けられ
     た集まりであり、その中にはファイルやサブディレクトリを置くことが
     できる。*Note Directories::。

Dired
     diredとは、ファイルディレクトリの中身を表示し、ディレクトリ内のファ
     イルを操作して『ディレクトリの編集』を可能にするEmacsの機能である。
     *Note Dired::。

使用禁止コマンド（Disabled Command）
     使用禁止コマンドとは、特別な確認なしには実行できないコマンドであ
     る。コマンドを使用禁止にしておくのは、そのコマンドが初心者を困惑
     させるからである。*Note Disabling::。

押し下げイベント（Down Event）
     「ボタン押し下げイベント」の略。

ドラッグイベント（Drag Event）
     ドラッグイベントとは、入力イベントの一種であり、マウスボタンを押
     し下げたままマウスを動かしてからボタンを放すと発生する。*Note
     Mouse Buttons::。

ドリブルファイル（Dribble File）
     ユーザーがキーボードから打ち込んだすべての文字を書き込むファイル。
     ドリブルファイルは、Emacsのバグのデバッグ用の記録を作るために使わ
     れる。指示しない限りEmacsはドリブルファイルを作成しない。*Note
     Bugs::。

エコー領域（Echo Area）
     エコー領域は、画面の最後の行であり、コマンドの引数を表示したり、
     問い合わせたり、（エラーメッセージを含む）簡素なメッセージの表示
     に使われる。メッセージはバッファ`*Messages*'に保存されるので、あ
     とから見ることもできる。*Note Echo Area::。

エコー（Echoing）
     エコーとは、（エコー領域に）表示することでコマンドを受理したこと
     を伝えることである。Emacsは1文字のキー列をけっしてエコーしない。2
     文字以上のキー列の場合、打ち込みに間を置くとエコーする。

エレクトリック（Electric）
     通常は自己挿入《参照》と定義されていて、現在のメジャーモード《参
     照》では別のものにも再定義されているような文字を、エレクトリック
     であるという。たとえば、プログラム言語用のメジャーモードでは、特
     定の区切り文字を自己挿入に加えて、行を字下げし直したり、空行を挿
     入するように定義する。

エラー（Error）
     現在の状況ではEmacsコマンドを実行できないときに、エラーが起きる。
     エラーが起きると、コマンドの実行は（コマンドが何か別のことをする
     ようにプログラムされていない限り）止まり、Emacsはエラーメッセージ
     《参照》を表示してエラーを報告する。すでに打ち込んだ文字は捨てら
     れる。そして、Emacsは他の編集コマンドを読める状態になる。

エラーメッセージ（Error Message）
     エラーメッセージとは、ユーザーが（バッファの最後にポイントがある
     のに、ポイントよりうしろのテキストをキルするなどの）実行不可能な
     ことを要求したときに、Emacsが表示する1行のメッセージである。エラー
     メッセージはエコー領域に表示されベルが鳴る。

ESC
     ESCは、METAキーがないキーボードで、メタ文字を入力するためのプレ
     フィックスとして利用する文字である。（SHIFTキーのようにキーを押し
     下げたまま別の文字を打ち込む）METAキーと違い、普通の文字キーを打
     ち込むようにESCキーを打ち込むと、つぎに打ち込んだ文字に（ESCキー
     が）適用される。

抹消（Expunging）
     rmailファイルやdiredバッファにおける抹消とは、事前に削除の印を付
     けたメッセージやファイルを実際に捨て去る操作である。

ファイルロック（File Locking）
     Emacsは、異なる2人のユーザーが同時に1つのファイルを編集し始めたと
     きに、そのことを告知するためにファイルロックを利用する。*Note
     Interlocking::。

ファイル名（File Name）
     ファイル名とはファイルを指す名前である。ファイル名は相対的か絶対
     的である。相対ファイル名の意味はカレントディレクトリに依存するが、
     一方、絶対ファイル名は現在どのディレクトリにいるかに関係なくつね
     に同じファイルを指す。GNUやUNIXシステムでは、絶対ファイル名は（ルー
     トディレクトリである）スラッシュや（ホームディレクトリである）
     `~/'や`~USER/'で始まる。

     ファイル名のかわりに『パス名』という用語を使う人もいるが、本書で
     は使わない。単語『パス』は『探索パス』《参照》という用語にしか使
     わない。

ファイル名の構成要素（File-Name Component）
     ファイル名の構成要素は、あるディレクトリ内のファイルを直接指名す
     る。GNUやUNIXシステムでは、ファイル名とはファイル名の構成要素をス
     ラッシュで区切った列である。たとえば、`foo/bar'は2つの構成要素、
     `foo'と`bar'から成り、カレントディレクトリ内の`foo'という名前のディ
     レクトリ内の`bar'というファイルを指す。

詰め込み接頭辞（Fill Prefix）
     詰め込み接頭辞とは、詰め込みが完了したときに、各行の先頭にあるべ
     き文字列のことである。これは詰め込むべきテキストの一部としてはみ
     なされない。*Note Filling::。

詰め込み（Filling）
     テキストの詰め込みとは、すべての行がほぼ同じ長さになるように、連
     続した行のテキストの配置を変えることである。*Note Filling::。

整形済みテキスト（Formatted Text）
     整形済みテキストとは、編集中に整形情報に従って表示されるテキスト
     である。整形情報には、フォント、表示色、左右端などがある。*Note
     Formatted Text::。

フレーム（Frame）
     フレームとは、Emacsウィンドウの長方形の集まりである。Emacsは1つの
     フレームで始めるがいくつでも作成できる。各フレームはEmacsウィンド
     ウ《参照》に分割できる。Xウィンドウシステムを利用している場合には、
     すべてのフレームを同時に眺めることができる。*Note Frames::。

ファンクションキー（Function Key）
     ファンクションキーは、どの文字にも対応しない入力を送出するキーボー
     ドのキーである。*Note Function Keys::。

グローバル（Global）
     グローバル（大域的）というのは、「現在の環境とは独立であり、実質
     的にEmacs全体に適用する」ということである。これは、ローカル（局所
     的）《参照》とは反対の概念である。「グローバル」の典型的な利用例
     は以下にある。

グローバル略語（Global Abbrev）
     略語《参照》のグローバルな定義は、ローカル《参照》な定義に同じ略
     語がないすべてのメジャーモードにおいて有効である。*Note Abbrevs::。

グローバルキーマップ（Global Keymap）
     グローバルキーマップ《参照》は、メジャーモードのローカルキーマッ
     プ《参照》によりローカルキーバインドが優先する場合を除いて有効に
     なるキーバインドを保持する。*Note Keymaps::。

グローバルマークリング（Global Mark Ring）
     グローバルマークリングには、最近にマークを置いたバッファの系列を
     記録する。多くの場合、今までに編集したバッファやタグを探したバッ
     ファを辿り直すのにこのリングを使える。*Note Global Mark Ring::。

グローバル置換（Global Substitution）
     グローバル置換とは、長大なテキストにおいて、ある文字列を他の文字
     列で置き換えることである。*Note Replace::。

グローバル変数（Global Variable）
     変数《参照》のグローバルな値は、バッファ独自に変数のローカルな値
     を持たないすべてのバッファに影響する。*Note Variables::。

図形文字（Graphic Character）
     図形文字とは、名称だけでなく絵的な像も割り当てられた文字である。
     メタ《参照》でないすべての文字は、コントロール《参照》文字を除い
     て図形文字である。アルファベット、数字、区切り文字、空白が含まれ
     るが、RETやESCは含まれない。Emacsでは、（通常の編集モードでは）図
     形文字を打ち込むとその文字が挿入される。*Note Basic Editing:
     Basic.。

強調表示（Highlighting）
     テキストを強調表示するとは、バッファ内の他のテキストに比してめだ
     つように前景色や背景色を変えて表示することである。

ハードコピー（Hardcopy）
     ハードコピーとは、印刷した出力のことである。Emacsには、Emacsバッ
     ファ内のテキストを印刷するコマンドがある。*Note Hardcopy::。

HELP
     HELPとは、`C-h'やF1を指すEmacsの名前である。どのような選択枝があ
     るかを調べたり、コマンドが何をするかを調べるには、いつでもHELPを
     押せばよい。*Note Help::。

ハイパー（Hyper）
     ハイパーは、キーボードからの入力文字に付く修飾ビットの名前である。
     ハイパー文字にするには、HYPERキーを押し下げたまま文字を打ち込む。
     このような文字は、`Hyper-'（普通は縮めて`H-'）で始まる名前になる。
     *Note Hyper: User Input.。

Inbox
     inboxとは、オペレーティングシステムが配達するメイルを収めるファイ
     ルである。rmailは、inboxからrmailファイル《参照》にメイルを移動す
     る。rmailファイル内のメイルは、明示的に消さない限り、恒久的に保存
     される。

字下げ（Indentation）
     字下げとは、行の始めにある空白のことである。ほとんどのプログラム
     言語では、プログラムの構造を明らかにするために字下げを使う習慣が
     ある。Emacsには、字下げを調整する特別なコマンドがある。*Note
     Indentation::。

間接バッファ（Indirect Buffer）
     間接バッファとは、ベースバッファと呼ばれる別のバッファとテキスト
     を共有するバッファである。*Note Indirect Buffers::。

入力イベント（Input Event）
     Emacsにおいて、入力イベントはユーザーが端末で行った1つの操作を表
     す。入力イベントには、文字の打ち込み、ファンクションキーの打ち込
     み、マウスボタンを押したり放したりすること、Emacsフレームの切り替
     えがある。

入力方式（Input Method）
     入力方式とは、ASCII文字《参照》の列を打ち込んで非ASCIIのテキスト
     文字を入力する方法である。*Note Input Methods::。

挿入（Insertion）
     挿入とは、キーボードやEmacs内の他の場所からバッファにテキストをコ
     ピーすることである。

相互ロック（Interlocking）
     相互ロックとは、すでに誰かが編集しているファイルを変更しようとす
     ると警告する機能である。*Note Simultaneous Editing: Interlocking.。

行揃え（Justification）
     行揃えとは、指定した幅にちょうど収まるようにテキスト行に余分な空
     白を加えることである。*Note Justification: Filling.。

キーボードマクロ（Keyboard Macro）
     キーボードマクロとは、Lispプログラムを書かずに、既存のコマンド列
     から新たなEmacsコマンドを定義する方法である。*Note Keyboard
     Macros::。

キー列（Key Sequence）
     キー列（縮めてキー）とは、1つの単位として意味がある入力イベント
     《参照》の列である。キー列が1つの動作を特定するのに十分な長さがあ
     れば、それは完結キー《参照》である。十分でなければプレフィックス
     キー《参照》である。*Note Keys::。

キーマップ（Keymap）
     キーマップとは、コマンドを起動するキー列のバインディング《参照》
     を記録したデータ構造である。たとえば、グローバルキーマップでは、
     文字`C-n'をコマンド関数`next-line'にバインド（束縛）する。*Note
     Keymaps::。

キーボード変換表（Keyboard Translation Table）
     キーボード変換表とは、端末からの入力文字コードをキー列を構成する
     文字コードへ変換する配列である。*Note Keyboard Translations::。

キルリング（Kill Ring）
     キルリングとは、最近にキルしたすべてのテキストを保存する場所であ
     る。リングの中にあるキルしたテキストは、いつでも再度挿入できる。
     これをヤンク《参照》するという。*Note Yanking::。

キル（Killing）
     キルとは、テキストを取り去り、あとでヤンク《参照》できるようにキ
     ルリングに保存することである。他のシステムではこれを『カット』と
     呼ぶ。テキストを取り去るほとんどのEmacsコマンドは、削除《参照》で
     はなくキルを行う。*Note Killing::。

ジョブの強制終了（Killing Jobs）
     （Emacsの起動などの）ジョブを強制終了するとは、ジョブの存続を終ら
     せることである。ジョブ内のデータは、ファイルに保存していなければ
     失われる。*Note Exiting::。

言語環境（Language Environment）
     言語環境を選ぶと、入力方式《参照》とコーディングシステム《参照》
     のデフォルトが指定される。*Note Language Environments::。これらの
     デフォルトは、非ASCIIのテキストを編集する人に関係ある。（*Note
     International::）。

リスト（List）
     リストとは、おおざっぱにいえば、開き括弧で始まり対応する閉じ括弧
     で終るテキスト文字列である。Cモードや他のLisp以外のモードでは、言
     語にとって適切な対応をとる中括弧などの区切り文字で囲んだものもリ
     ストとみなす。Emacsには、リストにさまざまな操作を行う特別なコマン
     ドがある。*Note Lists::。

ローカル（Local）
     ローカル（局所的）とは、「特定の文脈だけに影響する」という意味で
     ある。特定の文脈とは、関数の実行、バッファ、メジャーモードなどで
     ある。これは、グローバル（大域的）《参照》とは反対の概念である。
     Emacsにおける「ローカル」の用法の例は以下ある。

ローカル略語（Local Abbrev）
     ローカル略語の定義は、特定のメジャーモードが選ばれているときだけ
     有効である。そのメジャーモードでは、同じ略語のグローバルな定義に
     優先する。*Note Abbrevs::。

ローカルキーマップ（Local Keymap）
     ローカルキーマップは、特定のメジャーモードで使われる。現在のロー
     カルキーマップのキーバインド《参照》は、同じキー列に対するグロー
     バルなバインドに優先する。*Note Keymaps::。

ローカル変数（Local Variable）
     1つのバッファのみに適用される変数《参照》のローカルな値。*Note
     Locals::。

`M-'
     文字の名前の中の`M-'は、METAの省略形であり、任意の文字に付くこと
     が可能な修飾キーの1つである。*Note User Input::。

`M-C-'
     文字の名前の中の`M-C-'は、コントロール・メタ（Control-Meta）の略
     であり、`C-M-'と同じ意味である。METAキーがない端末では、コントロー
     ル・メタ文字を打ち込むには、ESCを打ち込んでから該当するコントロー
     ル文字を打ち込む。*Note C-M-: User Input.。

`M-x'
     `M-x'は、Emacsコマンドを名前で呼び出すために用いるキー列である。
     これにより、キー列にバインド（束縛）されていないコマンドを実行で
     きる。*Note M-x::。

メイル（Mail）
     メイルとは、コンピュータシステムを介してあるユーザーが他のユーザー
     へ送ったメッセージであり、受け手の都合のよいときに読んでもらう。
     Emacsには、メイルを書いて送ったり、受け取ったメイルを読んだり編集
     するコマンドがある。*Note Sending Mail::。メイルの読み方は、*Note
     Rmail::。

メイル作成方法（Mail Composition Method）
     メイル作成方法とは、メイルメッセージを編集したり送ったりするため
     のEmacs内で実行できるプログラムである。Emacsでは何種類かのメイル
     作成方法を選択できる。*Note Mail Methods::。

メジャーモード（Major Mode）
     Emacsのメジャーモードとは、互いに排他的なオプションの集まりであり、
     各メジャーモードは特定種類のテキストを編集するためにEmacsの設定を
     変更する。理想的には、各プログラム言語ごとに独自のメジャーモード
     がある。*Note Major Modes::。

マーク（Mark）
     マークは、テキスト内の位置を指し示す。マークでリージョン《参照》
     の端を指し、ポイントでもう一方の端を指す。ポイントからマークまで
     のテキスト全体を操作するコマンドが数多くある。各バッファにはそれ
     ぞれ独自のマークがある。*Note Mark::。

マークリング（Mark Ring）
     マークリングは、以前のマークへ戻りたくなった場合に備えて、最近の
     数個のマークの位置を保持する。各バッファには独自のマークリングが
     ある。さらに、グローバルマークリング《参照》が1つある。*Note Mark
     Ring::。

メニューバー（Menu Bar）
     メニューバーはEmacsフレームの最上段にある。これには、マウスでクリッ
     クしてメニューを出すための単語が並んでいる。メニューバーの機能は、
     X上でのみ利用できる。*Note Menu Bars::。

メッセージ（Message）
     「メイル」を参照。

メタ（Meta）
     メタは、コマンド文字に付きうる修飾ビットの名前である。METAを押し
     下げたまま打ち込んだ文字に付く。そのような文字は、`Meta-'（普通は
     縮めて`M-'）で始まる名前になる。たとえば、`M-<'は、METAを押し下げ
     たまま（ほとんどの端末では、SHIFTを押し下げたまま`,'を打ち）`<'を
     打ち込む。*Note Meta: User Input.。

メタ文字（Meta Character）
     メタ文字とは、メタビットが立っている文字コードである。

ミニバッファ（Minibuffer）
     ミニバッファは、必要なときにエコー領域《参照》に現れ、コマンドの
     引数を読み取るのに使われる。*Note Minibuffer::。

ミニバッファ履歴（Minibuffer History）
     ミニバッファ履歴は、それまでにミニバッファ引数に指定したテキスト
     を記録するもので、同じテキストを再利用するのに便利である。*Note
     Minibuffer History::。

マイナモード（Minor Mode）
     マイナモードとは、他のすべての機能とは独立にオン／オフできるEmacs
     のオプションの機能である。各マイナモードには、機能をオン／オフす
     るコマンドがある。*Note Minor Modes::。

マイナモードキーマップ（Minor Mode Keymap）
     マイナモードに属するキーマップのことであり、マイナモードがオンの
     ときに使われる。ローカルキーマップがグローバルキーマップに優先す
     るように、マイナモードキーマップはバッファのローカルキーマップに
     優先する。*Note Keymaps::。

モード行（Mode Line）
     モード行とは、各ウィンドウ《参照》のいちばん底にある行であり、ウィ
     ンドウに表示中のバッファの状態に関する情報を与える。*Note Mode
     Line::。

変更したバッファ（Modified Buffer）
     バッファを保存してから（あるいは、新規作成）以降にテキストを変更
     した（あるいは、一度も保存していない）場合、バッファは変更された
     という。*Note Saving::。

テキストの移動（Moving Text）
     テキストの移動とは、ある場所からテキストを取り去り、別の場所へ挿
     入することである。テキストを移動するもっとも普通の方法は、キル
     《参照》してからヤンク《参照》することである。*Note Killing::。

MULE（ミュール）
     MULEとは、マルチバイト文字《参照》の機能を用いて非ASCIIテキストを
     編集するEmacsの機能を指す。*Note International::。

マルチバイト文字（Multibyte Character）
     マルチバイト文字とは、バッファの数個の場所を占める文字である。非
     ASCII文字の個数は256を大幅に超えるので、非ASCII文字のテキストを表
     現するためにマルチバイト文字を使う。*Note International Intro::。

名前付きマーク（Named Mark）
     名前付きマークとは、レジスタ《参照》であり、その場所へポイントを
     移動できるようにテキスト内の場所を記録する役割がある。*Note
     Registers::。

ナロイング（Narrowing）
     ナロイングとは、カレントバッファのテキストの一部分のみが編集対象
     となるように制限《参照》を設けることである。境界を広げない限り、
     境界の外側にあるテキストを参照することはできないが、テキストは存
     続しているのでファイルへ保存するとバッファの内容すべてが保存され
     る。*Note Narrowing::。

改行（Newline）
     バッファ内の文字Control-Jは、テキストの行の終りなので、改行と呼ば
     れる。*Note Newline: Text Characters.。

数引数（Numeric Argument）
     数引数は数であり、コマンドよりまえに指定してコマンドの効果を変え
     る。多くの場合、数引数は反復回数を指定する。*Note Arguments::。

上書きモード（Overwrite Modes）
     上書き（overwrite）モードは、マイナモードである。このモードが有効
     であると、普通のテキスト文字は、ポイント直後に押し込まれるのでは
     なく、ポイント直後の既存のテキストを置き換える。*Note Minor
     Modes::。

ページ（Page）
     ページは、テキストの1つの単位であり、行の先頭のページ送り文字
     （ASCIIのコントロールL、コードは014）で区切られる。Emacsには、ペー
     ジ間を移動したり、ページを操作するコマンドがある。*Note Pages::。

段落（Paragraph）
     段落とは、英文テキストの中程度の大きさの塊である。段落間を移動し
     たり段落を操作する専用のEmacsコマンドがある。*Note Paragraphs::。

構文解析（Parsing）
     Emacsコマンドの中には、編集中のテキストを単語や式として構文解析す
     るものがある。実際には、単語や式の端をみつける方法を知っている程
     度である。*Note Syntax::。

ポイント（Point）
     ポイントとは、挿入や削除を行うバッファ内の場所である。ポイントは、
     2つの文字のあいだにあると考えられ、どちらかの文字にあるのではない。
     端末のカーソル《参照》はポイントの位置を示す。*Note Point: Basic.。
	
前置引数（Prefix Argument）
     「数引数」を参照。

プレフィックスキー（Prefix Key）
     プレフィックスキーとは、より長いキー列の導入部としてのみ機能する
     キー列である。`C-x'は、プレフィックスキーの例である。したがって、
     `C-x'で始まる2文字のキー列は正当なキー列である。*Note Keys::。

主rmailファイル（Primary Rmail File）
     主rmailファイルとは、ホームディレクトリにある`RMAIL'という名前の
     ファイルである。別のファイル名を指定しない限り、rmailが届いたメイ
     ルを保存する場所である。*Note Rmail::。

一次セレクション（Primary Selection）
     一次セレクションとは、Xのセレクション《参照》の一種であり、アプリ
     ケーション間でテキストを転送するためにXの数多くのアプリケーション
     が用いるセレクションである。

     Emacsのキルコマンドは、一次セレクションを設定し、ヤンクコマンドは、
     適切ならば、一次セレクションを用いる。*Note Killing::。

プロンプト（Prompt）
     プロンプトとは、ユーザーに入力を促すために表示されるテキストであ
     る。プロンプトを表示することをプロンプティングという。Emacsのプロ
     ンプトは、つねにエコー領域《参照》に現れる。プロンプトを出す例は
     引数を読むためにミニバッファ（*Note Minibuffer::）を使う場合であ
     る。長いキー列を打ち込む途中で間を置いたときに起きる表示も、プロ
     ンプトの一種である。（*Note Echo Area::）。

中断（Quitting）
     中断とは、`C-g'（MS-DOSでは`C-BREAK'）を使って、打鍵途中のコマン
     ドや実行中のコマンドを取り消すことである。*Note Quitting::。

クォート（Quoting）
     クォートとは、文字が通常有する特別な意味を奪うことである。Emacsに
     おいてもっとも一般的なクォートは、`C-q'を使う。何が特別な意味とな
     るかは、文脈や約束事に依存する。たとえば、Emacsのコマンドとしての
     『普通』の文字は、その文字自身を挿入する。したがって、この文脈に
     おいては、特別な文字とは、（たとえば、DELなどの）文字自身を挿入し
     ない文字のことであり、クォートすると、特別な文字ではないとして、
     文字自身を挿入する。どんな文脈でもクォートが許されるとは限らない。
     *Note Quoting: Basic.。

ファイル名のクォート（Quoting File Names）
     ファイル名をクォートすると、`$'、`~'、`:'などの構成要素の特別な意
     味を抑える。*Note Quoted File Names::。

読み出し専用バッファ（Read-Only Buffer）
     読み出し専用バッファとは、変更が許されないテキストを持つバッファ
     である。通常、Emacsにとって重要な意味を持ったテキストを含むバッファ
     は読み出し専用になる。たとえば、diredバッファである。書き込み禁止
     のファイルを訪れても、バッファは読み出し専用になる。*Note
     Buffers::。

矩形領域（Rectangle）
     矩形領域は、与えられた範囲の行の与えられた範囲の桁のテキストから
     成る。通常、矩形領域を指定するには、一方の角にポイントを置き、対
     角にマークを置く。*Note Rectangles::。

再帰編集レベル（Recursive Editing Level）
     再帰編集レベルとは、コマンドの実行過程において、ユーザーにテキス
     ト編集を依頼した状態のことである。このテキストは、コマンドを適用
     したテキストと同じかもしれないし、違うかもしれない。モード行には、
     角括弧（`['と`]'）で再帰編集レベルが示される。*Note Recursive
     Edit::。

再表示（Redisplay）
     再表示とは、編集中のテキストの変更に対応するように、画面上の表示
     を修正する処理のことである。*Note Redisplay: Screen.。

Regexp
     「正規表現」を参照。

リージョン（Region）
     リージョンとは、ポイント《参照》とマーク《参照》のあいだにあるテ
     キストである。数多くのコマンドがリージョンのテキストを操作する。
     *Note Region: Mark.。

レジスタ（Registers）
     レジスタとは、あとで使えるように、テキスト、バッファの位置、矩形
     領域を保持できる名前が付いた場所である。*Note Registers::。

正規表現（Regular Expression）
     正規表現とは、さまざまなテキスト文字列に一致可能なパターンである。
     たとえば、`l[0-9]+'は、`l'のうしろに1個以上の数字が続いた文字列に
     一致する。*Note Regexps::。

反復回数（Repeat Count）
     「数引数」を参照。

置換（Replacement）
     「グローバル置換」を参照。

制限（Restriction）
     バッファの制限とは、バッファの先頭や末尾で一時的に参照不可になっ
     ているテキスト量のことである。バッファにゼロでない制限を課すこと
     を、ナロイング《参照》と呼ぶ。*Note Narrowing::。

RET
     RETは、Emacsにおいて、テキストに改行を挿入するコマンドを実行する
     文字である。ミニバッファ《参照》においては、ほとんどの引数読み取
     りの完了にも使う。*Note Return: User Input.。

rmailファイル（Rmail File）
     rmailファイルは、rmailがメイルを保存するために使用する特別な形式
     のテキストを収めたファイルである。*Note Rmail::。

保存（Saving）
     バッファを保存するとは、そのバッファで訪問《参照》したファイルへ
     バッファのテキストをコピーすることである。こうすることで、Emacsで
     の編集結果が実際にファイル内のテキストに反映される。*Note
     Saving::。

スクロールバー（Scroll Bar）
     スクロールバーは、ウィンドウの端に現れる細長い中空の箱である。ウィ
     ンドウをスクロールするには、スクロールバー内でマウスコマンドを使
     う。スクロールバーの機能はXだけで使える。*Note Scroll Bars::。

スクロール（Scrolling）
     スクロールとは、Emacsウィンドウ内のテキストを動かして、バッファの
     別の部分が見えるようにすることである。*Note Scrolling: Display.。

探索（Searching）
     探索とは、指定した文字列のつぎの出現位置、あるいは、指定した正規
     表現のつぎの一致位置へポイントを動かすことである。*Note Search::。

探索パス（Search Path）
     探索パスとは、ディレクトリ名のリストであり、ある目的に使うファイ
     ルを探すために利用される。たとえば、変数`load-path'は、Lispのライ
     ブラリファイルを探すための探索パスを保持する。*Note Lisp
     Libraries::。

二次セレクション（Secondary Selection）
     二次セレクションとは、Xのセレクションの一種である。Xのアプリケー
     ションには、他のアプリケーションとテキストを転送するために二次セ
     レクションを使うものがある。Emacsには、二次セレクションを使ってテ
     キストを転送する特別なマウスコマンドがある。*Note Secondary
     Selection::。

選択する（Selecting）
     バッファを選択するとは、そのバッファをカレントバッファ《参照》と
     することである。*Note Selecting: Buffers.。

セレクション（Selection）
     Xウィンドウシステムでは、アプリケーションプログラムがテキストを値
     とする名前付きのセレクションを指定できる。プログラムは、他のプロ
     グラムが設定したセレクションを読むこともできる。これは、ウィンド
     ウアプリケーションのあいだでテキストを転送するもっとも基本的な方
     法である。Emacsには、一次セレクション《参照》と二次セレクション
     《参照》に対処するコマンドがある。

セルフドキュメント（Self-Documentation）
     セルフドキュメントとは、コマンドが何をするものか教えたり、指定し
     た話題に関係するすべてのコマンドの一覧を提示するEmacsの機能である。
     ヘルプ文字`C-h'でセルフドキュメントを読むことができる。*Note
     Help::。

自己挿入文字（Self-Inserting Character）
     打ち込んだ文字自身がバッファに挿入される場合、その文字は自己挿入
     である。Emacsでは、特定のメジャーモードを除いて、普通の印字文字や
     白文字は自己挿入文字である。

節（Sentences）
     Emacsには、節単位に移動したり削除するコマンドがある。*Note
     Sentences::。

S式（Sexp）
     S式（sexpは「s-expression」の短縮形）とは、Lispのテキスト形式にお
     ける基本的な文法単位であり、リストかLispのアトムである。Emacsには、
     S式を操作する数多くのコマンドがある。「sexp」という用語は、Lisp以
     外の言語に対しても一般化され、構文則で認識可能な式を意味する。
     *Note Sexps: Lists.。

同時編集（Simultaneous Editing）
     同時編集とは、同じファイルを一度に2人のユーザーで編集することを意
     味する。同時編集を検知できないと、一方のユーザーの作業結果が失わ
     れる危険性がある。Emacsは、同時編集が起こるすべての状況を検知し、
     一方のユーザーに注意を促す。*Note Simultaneous Editing:
     Interlocking.。

文字列（String）
     文字列とは、Lispのデータオブジェクトの一種であり、文字の列を持つ。
     Emacsの数多くの変数は、値として文字列をとることを意図している。文
     字列を表すLispの構文では、文字列の始めに`"'があり、文字列の終りに
     `"'がある。文字列に`"'を含めるには`\"'と書き、 文字列に`\'を含め
     るには`\\'と書く。改行を含む他のすべての文字は、文字列に含めて書
     けばよい。なお、改行を表す`\n'、8進文字コードを表す`\241'のような
     Cのバックスラッシュ表現も許される。

文字列置換（String Substitution）
     「グローバル置換」を参照。

構文テーブル（Syntax Table）
     構文テーブルは、単語を構成する文字、括弧のような互いに釣り合う文
     字などを、Emacsに教える。*Note Syntax::。

スーパー（Super）
     スーパーは、キーボードからの入力文字に付く修飾ビットの名前である。
     スーパー文字にするには、SUPERキーを押し下げたまま文字を打ち込む。
     このような文字は、`Super-'（普通は縮めて`s-'）で始まる名前になる。
     *Note Super: User Input.。

タグテーブル（Tags Table）
     タグテーブルとは、複数のファイルに定義された関数の索引の役割を果
     たすファイルである。*Note Tags::。

termscriptファイル（Termscript File）
     termscriptファイルには、Emacsが端末に送ったすべての文字が記録され
     る。Emacsの再表示のバグを追跡するために使う。指示しない限り
     termpscriptファイルは作成されない。*Note Bugs::。

テキスト（Text）
     2つの意味がある（*Note Text::）

        * 文字の列から成るデータであり、2進数、画像、図形コマンド、実
          行ファイルなどと対比される。Emacsバッファの内容は、この意味
          においてつねにテキストである。
        * 自然言語で書かれたデータであり、プログラム、自然言語の文体を
          変換したのもと対比される。

トップレベル（Top Level）
     トップレベルとは、Emacsの通常の状態であり、この状態において訪れた
     ファイルを編集している。再帰編集レベル《参照》やミニバッファ《参
     照》に入っていない、コマンドの実行途中でないならば、トップレベル
     にいる。アボート《参照》したり中断《参照》すると、トップレベルに
     戻ることができる。*Note Quitting::。

転置（Transposition）
     テキストの2つの塊を転置するとは、それぞれをもう一方が占めていた場
     所へ置くことである。Emacsには、連続した文字、単語、S式《参照》、
     行を転置するコマンドがある。（*Note Transpose::）。

切り捨て（Truncation）
     表示画面においてテキスト行を切り捨てるとは、テキストを表示するウィ
     ンドウの右端に収まらない部分を無視することである。「継続行」も参
     照。*Note Truncation: Basic.。

アンドゥ（Undoing）
     アンドゥとは、編集過程で（時間的に）まえに存在していたテキストを
     もとに戻して、以前に行った編集の効果を逆向きにすることである。
     *Note Undo::。

ユーザーオプション（User Option）
     ユーザーオプションとは、新たな値を設定してEmacsのカスタマイズを可
     能にする変数《参照》である。*Note Variables::。

変数（Variable）
     変数とは、任意の値を格納できるLispオブジェクトである。Emacsには、
     内部目的の変数もあれば、値を設定してEmacsのふるまいを制御する
     （「ユーザーオプション」《参照》として知られる）変数もある。読者
     の関心を引くようなEmacsの変数の一覧は、本書の変数索引にある。変数
     についての情報は、*Note Variables::。

版管理（Version Control）
     版管理（バージョンコントロール）システムは、ソースファイルの複数
     の版の記録を取っておく。バックアップファイル《参照》を取っておく
     よりもずっと強力な方法を提供する。*Note Version Control::。

訪問（Visiting）
     ファイルを訪問する（訪れる）とは、その内容を編集できるようにバッ
     ファ《参照》に読み込むことである。*Note Visiting::。

白文字（Whitespace）
     白文字とは、連続した整形用の文字（空白（スペース）、タブ、改行、
     バックスペース）である。

ワイドニング（Widening）
     ワイドニングとは、カレントバッファの制限《参照》を取り去ることで
     ある。ナロイング《参照》の反対である。*Note Narrowing::。

ウィンドウ（Window）
     Emacsでは、フレーム《参照》を複数のウィンドウに分割し、各ウィンド
     ウにはつねに1つのバッファ《参照》の内容を表示できる。Emacsの画面
     の利用法に関する基本的なことがらについては、*Note Screen::。ウィ
     ンドウの使用法を制御するコマンドについては、*Note Windows::。

単語の略語（Word Abbrev）
     「略語」の同義語。

単語探索（Word Search）
     単語探索とは、単語の区切りを無視して単語の列を探索することである。
     *Note Word Search::。

WYSIWYG
     WYSIWYGは、「What you see is what you get」（見たとおりを得る）の
     略語である。Emacsでは、一般に、文字ファイルの編集にはWYSIWYGを提
     供する。エンリッチ（enriched）モード（*Note Formatted Text::）で
     は、テキスト整形情報を含むファイルの編集にもWYSIWYGを提供する。

ヤンク（Yanking）
     ヤンクとは、以前にキルしたテキストを再挿入することである。誤った
     キルを取り消したり、テキストの移動やコピーに利用できる。他のシス
     テムでは『ペースト』と呼ぶ。*Note Yanking::。



