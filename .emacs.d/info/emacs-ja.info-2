Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Mode Line, Next: Menu Bar, Prev: Echo Area, Up: Screen

モード行
========

テキストウィンドウの最後の行は"モード行"（mode line）で、そのウィンド
ウで何が進行しているか表示します。テキストウィンドウが1つしかない場合、
モード行はエコー領域のすぐ上に表示されます。フレーム上では最後から2番
目の行になります。端末に反転表示機能があれば、モード行は反転表示されま
す。モード行の表示内容は、ダッシュで始まりダッシュで終ります。

通常、モード行はつぎのように表示されます。

     -CS:CH  BUF      (MAJOR MINOR)--LINE--POS------

これから、ウィンドウに表示中のバッファに関する情報を得られます。バッファ
の名前、どのメジャーモードやマイナモードを使っているか、バッファのテキ
ストが変更されたかどうか、バッファ全体のどのあたりを現在表示しているか
です。

CHは、バッファのテキストが編集されている（つまりバッファが『変更』され
ている）場合には星印2個`**'になり、バッファが編集されていない場合には
`--'になります。読み出し専用のバッファの場合には、バッファが編集されて
いる場合には`%*'になり、バッファが編集されていない場合には`%%'となりま
す。

BUFは、ウィンドウに表示されている"バッファ"の名前です。ほとんどの場合、
編集中のファイル名と同じです。*Note Buffers::。

（カーソルがある）選択されたウィンドウに表示されたバッファは、Emacsの
選択されたバッファでもあり、編集はこのバッファで行われます。コマンドが
『バッファ』に何かを行うといったとき、現在選択されているバッファを指し
ています。

LINEは、`L'のあとに現在ポイントがある行の番号が続いたものです。これは、
行番号（line-number）モードがオンである（通常はオン）場合に表示されま
す。なお、桁番号（column-number）モードをオンにすると、現在の桁番号も
表示できます（多少時間がかかるので、このモードはデフォルトではオフ）。
*Note Optional Mode Line::。

POSは、ウィンドウの最上部より上や最下部より下にさらにテキストがあるか
どうかを示します。バッファが小さくて、すべてがウィンドウに収まっている
場合には、POSは`All'となります。そうでない場合、バッファの先頭が表示さ
れていれば`Top'、バッファの末尾が表示されていれば`Bot'、あるいは、
`NN%'となります。ここで、NNはウィンドウの最上部より上にあるバッファの
割合を百分率で示します。

MAJORは、そのバッファの"メジャーモード"（major mode）の名前です。各バッ
ファはつねに必ず1つのメジャーモードになっています。使用可能なメジャー
モードには、基本（fundamental）モード（もっとも特殊化されていないモー
ド）、テキスト（text）モード、Lisp モード、Cモード、texinfoモード、そ
の他にも数多くあります。各モードの相違や選択方法についての詳細は、
*Note Major Modes::。

メジャーモードには、メジャーモード名のあとに付加的な情報を表示するもの
もあります。たとえば、rmailバッファでは、現在のメッセージ番号とメッセー
ジ総数を表示します。コンパイルバッファやシェルバッファでは、サブプロセ
スの状態を表示します。

MINORは、ウィンドウの選択されたバッファにおいて、その時点でオンになっ
ている"マイナモード" （minor mode）の一覧の一部を示します。たとえば、
`Fill'は、自動詰め込み（auto-fill）モードがオンであることを意味します。
`Abbrev'は、略語（abbrev）モードがオンであることを意味します。`Ovwrt'
は 、上書き（overwrite）モードがオンであることを意味します。詳しくは、
*Note Minor Modes::。`Narrow'は、表示中のバッファが、そのテキストの一
部のみを編集するように制限されていることを示します。これは、実際にはマ
イナモードではありませんが、そのようなものです。*Note Narrowing::。
`Def'は、キーボードマクロを定義中であることを示します。*Note Keyboard
Macros::。

さらに、Emacsが、現在、再帰編集レベルにあるときには、モードを囲んでい
る括弧の周りに角括弧（`[...]'）が現れます。再帰編集レベルの中で別の再
帰編集レベルに入っていると、角括弧は2重になるというふうになります。再
帰編集レベルは、特定のバッファにだけ関係するものではなく、Emacs全体に
影響するので、角括弧はすべてのウィンドウのモード行に表示される、あるい
は、まったく表示されないのどちらかです。*Note Recursive Edit::。

ウィンドウを表示できない端末では、一度には、単一のEmacsフレームしか表
示できません（*Note Frames::）。そのような端末では、モード行のCHのあと
に、選択しているフレームの名前が表示されます。初期フレームの名前は、
`F1'です。

CSは、編集中のファイルで使用しているコーディングシステムを表します。ダッ
シュ（`-'）はデフォルトの状態、つまり、ファイルの内容に応じて行末変換
は行うが、コード変換は行わないことを示します。`='の場合、コード変換を
まったく行わないことを意味します。単純ではないコード変換をさまざま文字
で示します。たとえば、`1'は、ISO Latin-1を表します。詳しくは、*Note
Coding Systems::。入力方式を使っている場合には、CSの先頭に`I>'の形式の
文字列が付加されます。ここで、Iは入力方式を表します。（`>'のかわりに、
`+'や`@'を表示する入力方式もある。）*Note Input Methods::。

（ウィンドウシステムではなくて）文字端末を使っている場合、CSは3文字に
なり、それぞれ、キーボード入力のコーディングシステム、画面出力のコーディ
ングシステム、編集中のファイルのコーディングシステムです。

マルチバイト文字が使用不可の場合、CSはまったく表示されません。*Note
Enabling Multibyte::。

CSのあとのコロンは、特定の場面では別の文字列に変わることがあります。
Emacsは、バッファ内の行区切りとして改行を使います。ファイルによっては、
行区切りとして別の慣習を用いるものもあります。復帰改行（MS-DOSの慣習）、
あるいは、復帰のみ（Macintoshの慣習）です。バッファのファイルが復帰改
行を使っている場合には、オペレーティングシステムに依存して、コロンはバッ
クスラッシュ（`\'）か`(DOS)'に変わります。ファイルが復帰のみを使ってい
る場合には、コロンはスラッシュ（`/'）か`(Mac)'に変わります。システムに
よっては、行区切りとして改行を使っているファイルであっても、Emacsはコ
ロンのかわりに`(Unix)'を表示します。

各種行末形式のモード行への表示は、各変数、`eol-mnemonic-unix'、
`eol-mnemonic-dos'、`eol-mnemonic-mac'、`eol-mnemonic-undecided'にユー
ザーにとって適切な任意の文字列を設定することでカスタマイズできます。変
数の設定方法については、*Note Variables::。

ポイント位置の桁番号、現在時刻、新着メイルの有無などのお手ごろ情報をモー
ド行へ追加する機能については、*Note Optional Mode Line::。



File: emacs-ja.info, Node: Menu Bar, Prev: Mode Line, Up: Screen

メニューバー
============

各Emacsフレームには、通常、最上部に"メニューバー"（menu bar）があり、
よく使われる操作を実行するのに使えます。読者自身で簡単に確かめられます
から、ここではそれらを列挙する必要はないでしょう。

ウィンドウシステムを使っているのであれば、マウスを使ってメニューバーか
らコマンドを選べます。メニュー項目のあとにある右向き矢印は、その項目に
サブメニューがあることを示します。項目の最後に`...'がある場合は、コマ
ンドを実際に実行するまえに、コマンドがキーボードから引数を読み取ること
を意味します。

メニュー項目の完全なコマンド名や説明文を見るには、`C-h k'と打ってから、
通常どおりにマウスでメニューバーを選択します（*Note Key Help::）。

マウスのない文字端末でも、`M-`'やF10（これらは`tmm-menubar'を起動する）
を打てば、メニューバーを利用できます。このコマンドは、キーボードからメ
ニュー項目を選択するモードに入ります。エコー領域には、仮の選択項目が表
示されます。左矢印キーや右矢印キーでメニューの中を移動して別の項目を選
べます。選択を確定するにはRETキーを打ちます。

各メニュー項目には、その項目を指定する1個の文字や数字も割り当てられて
います。通常、それらは項目名の単語の頭文字です。これらの文字や数字は、
項目名と`=>'で分離されています。項目の文字や数字を打てばその項目を選べ
ます。

メニューバーにあるコマンドの中には、キーバインディングを持つものもあり
ます。その場合、項目自身のあとの括弧の中に等価なキーバインドを表示しま
す。



File: emacs-ja.info, Node: User Input, Next: Keys, Prev: Screen, Up: Top

ユーザー入力の種類
==================

GNU Emacsは、キーボード入力に対しては拡張ASCII文字集合を使います。また、
ファンクションキーやマウスボタン操作のような文字以外の入力イベントも受
け付けます。

ASCIIは、128の文字コードから成ります。これらのコードの中には、`a'や`='
のような図形記号に割り当てられているものもあります。それ以外は、
`Control-a'のようなコントロール文字です（通常、`C-a'と略記）。`C-a'の
名前は、CTRLキーを押し下げたまま`a'を押すことからきています。

ASCIIコントロール文字の中には、特別な名前が付いたものもあります。多く
の端末では、コントロール文字を打つための特別なキーを備えています。たと
えば、RET、TAB、DEL、ESCがそうです。空白文字は、以下では普通SPCと表記
します。厳密にいえば、表示した図形が空白である図形文字です。`C-j'に対
する別名である『linefeed』（ラインフィード） (1) (*Note User
Input-Footnotes::)というラベルが付いたキーを備えたキーボードもあります。


Emacsでは、数千の印字文字（*Note International::）、追加のコントロール
文字、任意の文字と組み合わせ可能な修飾子を導入して、ASCII文字集合を拡
張しています。

ASCII端末では、利用可能なコントロール文字は32個しかありません。これら
は、英字と`@[]\^_'のコントロール変種です。さらに、コントロール文字では、
シフトキーは意味を持ちません。つまり、`C-a'と`C-A'は同じ文字であり、
Emacsは区別できません。

しかし、Emacsの文字集合自体には、すべての印字文字にコントロール変種を
用意する余地があり、`C-a'と`C-A'を区別できます。Xウィンドウシステムで
は、これらすべての文字を入力できます。たとえば、`C--'（コントロールマ
イナス）と`C-5'は、Xウィンドウシステム上では意味を持つEmacsコマンドで
す。

Emacsの文字集合に対するもう1つの拡張は、修飾ビットの追加です。通常は1
ビットの修飾ビットだけを使い、このビットをメタ（Meta）と呼びます。すべ
ての文字にはメタ変種があります。たとえば、`Meta-a'（通常は`M-a'と略記）
や`M-A'（`M-a'とは異なる文字だが、Emacsでは通常、同じ意味）、`M-RET'、
`M-C-a'です。伝統的な理由で、通常、`M-C-a'よりむしろ`C-M-a'と書きます。
論理的には、2つの修飾キーCTRLとMETAの順序は関係ありません。

端末の中にはMETAキーを備えたものもあり、このキーを押し下げることでメタ
文字を打てます。たとえば、`Meta-a'は、METAを押し下げたまま`a'を押して
入力します。METAキーはSHIFTキーと同じように働きます。しかし、このよう
なキーのラベルがつねにMETAであるとは限りません。というのは、この機能は、
別の主目的を持つキーとするための特別なオプションであることがままあるか
らです。

METAキーがなくても、ESCで始まる2文字列を使ってメタ文字を入力できます。
つまり、`M-a'を入力するには、`ESC a'と打ちます。`C-M-a'を入力するには、
`ESC C-a'と打ちます。この方法に慣れているのであれば、METAがある端末で
も、ESCを使ってかまいません。
  
Xウィンドウシステムには、他にもいくつかの修飾キーがあり、すべての入力
文字に適用できます。これらは、SUPER、HYPER、ALTと呼ばれます。文字にこ
れらの修飾子が付いていることを示す意味で、`s-'、`H-'、`A-'と書きます。
つまり、`s-H-C-x'は、`Super-Hyper-Control-x'を省略したものです。すべて
のX端末に、実際にこれらの修飾子用のキーがあるわけではありません。実際、
ALTとラベルされているにも関わらず、実はMETAとして機能するキーを持つ端
末が多くあります。Emacsの標準キーバインディングには、これらの修飾子が
付いた文字はありません。しかし、Emacsをカスタマイズして、それらに独自
の意味を割り当てることができます。

キーボード入力には、ファンクションキーや矢印キーのような文字以外のキー
も含まれます。マウスボタンも文字の範囲には入りません。これらのイベント
も、修飾キーCTRL、META、SUPER、HYPER、ALTを使って、キーボード文字と同
じように修飾できます。

文字入力と非文字入力の両者を合わせて、"入力イベント"（input events）と
呼びます。より詳しくは、*Note 入力イベント: (elisp)Input Events。Lisp
のプログラミング抜きに、文字イベントや非文字イベントの意味を再定義した
い場合には、*Note Customization::を参照してください。

ASCII端末では、ASCII文字だけしかコンピュータに送れません。これらの端末
では、文字の並びを使って各ファンクションキーを表現します。ただし、キー
ボード入力ルーチンがこれらの特別な文字の並びを認識して、Emacsの他の部
分に渡すまえにファンクションキーイベントに変換してしまうので、これらの
文字の並びがEmacsユーザーの目にふれることはありません。


File: emacs-ja.info  Node: User Input-Footnotes, Up: User Input

(1) 【訳注】同じ意味で、改行（newline）も使う。



File: emacs-ja.info, Node: Keys, Next: Commands, Prev: User Input, Up: Top

キー
====

"キー列"（key sequence）（"キー"と略記）は、一塊で『1つのコマンド』と
しての意味を持つ入力イベントの列です。Emacsのコマンド列の中には、1文字
のみ、つまり、1イベントのみであるものもあります。たとえば、`C-f'はポイ
ントを1文字先へ進めます。しかし、なかには、起動に2つ以上のイベントを必
要とするコマンドもあります。

あるイベント列が1つのコマンドを起動するのに十分である場合、それらを"完
結キー"（complete key）と呼びます。完結キーの例としては、`C-a'、`X'、
RET、NEXT（ファンクションキーの1つ）、DOWN（矢印キー）、`C-x C-f'、
`C-x 4 C-f'があります。完結するほど十分に長くないイベント列を、"プレ
フィックスキー"（prefix key）と呼びます。上の例では、`C-x'や`C-x 4'が、
プレフィックスキーです。すべてのキー入力列は、完結キーかプレフィックス
キーのどちらかです。

Emacs標準のコマンド割り当てでは、ほとんどの1文字は完結キーです。残りの
少数はプレフィックスキーです。プレフィックスキーは、後続の入力イベント
と結び付いて、それ自体が完結キーやプレフィックスキーとなる、さらに長い
キーの列を作ります。たとえば、`C-x'はプレフィックスキーなので、`C-x'に
続く入力イベントと結び付いて2文字のキー列を作ります。`C-x C-f'や`C-x
b'を含めて、これらのキー列のほとんどは完結キーになります。`C-x 4'や
`C-x r'のように、いくつかのキー列はそれ自体がプレフィックスキーとなり、
3文字のキー列を作ります。キー列の長さに制限はありませんが、実用上は4文
字を超える長さのキー列を使うことはめったにありません。

これに対して、完結キーには入力イベントを付け加えることができません。た
とえば、2文字の列`C-f C-k'はキーではありません。というのは、`C-f'がそ
れ自体で完結キーだからです。`C-f C-k'にコマンドとしての独立した意味付
けをすることは不可能です。`C-f C-k'は、2つのキー列であって、1つのキー
列ではありません。

Emacsのプレフィックスキーは、`C-c'、`C-h'、`C-x'、
`C-x RET'、`C-x @'、`C-x a'、`C-x n'、
`C-x r'、`C-x v'、`C-x 4'、`C-x 5'、
`C-x 6'、ESC、`M-g'、`M-j'です。
しかし、これらは固定されているわけではなく、
Emacsのキー割り当ての標準設定となっているだけです。
Emacsをカスタマイズすれば、新しいプレフィックスキーを設定したり、
これらを解除したりできます。
*Note Key Bindings::。

プレフィックスキーを設定したり解除したりすると、可能なキー列の集合を変
えることになります。たとえば、`C-f'をプレフィックスキーとして再定義す
ると、`C-f C-k'は自動的に（これをさらにプレフィックスとして定義しない
限り完結した）キーになります。逆に、`C-x 4'をプレフィックスでなくする
と、`C-x 4 f' （または`C-x 4 ANYTHING'）は、もはやキーではなくなります。

プレフィックスキーのあとにヘルプ文字（`C-h'やF1）を打つと、そのプレフィッ
クスで始まるコマンド一覧を表示できます。歴史的な背景から、`C-h'が機能
しないプレフィックス文字も存在します。これらの文字では、`C-h'が別の意
味に割り当てられていて、容易には変更できないのです。しかし、F1はすべて
のプレフィックスに対して使えるはずです。
  


File: emacs-ja.info, Node: Commands, Next: Text Characters, Prev: Keys, Up: Top

キーとコマンド
==============

本書は、特定のキーの機能を詳しく説明したページばかりです。しかし、
Emacsは直接キーに意味を与えてはいません。そのかわりに、Emacsは名前を付
けた"コマンド"（commands）に意味を持たせ、キーとコマンドを"バインディ
ング"（binding、結び付ける）することによって、キーに意味を与えています。

すべてのコマンドには、プログラマが選んだ名前が付いています。その名前は、
たいていダッシュで区切った数語の英単語です。たとえば、`next-line'や
`forward-word'がそうです。コマンドは、Lispプログラムである"関数定義" 
（function definition、defun）を持ちます。これが、コマンドが行うべきこ
とを行えるようにしています。Emacs Lispでは、コマンドは実際には特別な種
類の関数です。つまり、引数の読み取り方や対話的な呼び出し方が規定された
Lisp関数です。コマンドと関数に関してより詳しくは、*Note 関数とは何か:
(elisp)What Is a Functionを参照してください。（本書での定義は少々簡易
化してある。）

キーとコマンドのバインディングは、"キーマップ"（keymaps）という表に記
録されています。*Note Keymaps::。

『`C-n'は垂直方向に1行下がる』という表現では、Emacsのカスタマイズ方法
を理解するうえでは非常に重要であっても、普段の使い方では意味のない「区
別」をあえて無視しています。下がるようにプログラムされているのは
`next-line'というコマンドです。`C-n'がそのコマンドにバインドされている
ので、そのような効果を発揮するのです。`C-n'をコマンド`forward-word'に
バインドし直すと、`C-n'は、かわりに1単語ずつ先へ進むようになります。キー
の再バインディングは、カスタマイズの一般的な方法です。

本書では、今後、話を単純にするために、普段はこの違いを無視することにし
ます。カスタマイズに必要な情報を示す場合、コマンドを実行するキーを記し
たあとに、実際にその動作を行うコマンドの名前を括弧に括って示します。た
とえば、『コマンド`C-n'（`next-line'）は、ポイントを下向きに移動する』
という表現では、下向きに移動するコマンドは`next-line'であり、標準では
キー`C-n'にバインドされていることを意味します。

これまでカスタマイズに関して述べてきましたので、"変数"についてふれてお
く時期でしょう。コマンドの説明では、『これを変更するには、変数
`mumble-foo'を設定する』と記述することがあります。変数とは、値を記憶し
ておくために使う名前のことです。本書に記載された変数の大部分は、カスタ
マイズのために使われます。いくつかのコマンドやEmacsの他の部分では、変
数を調べて設定された値に従ってそのふるまいを変えていきます。カスタマイ
ズに興味が出てくるまでは、変数に関する記述は無視してかまいません。カス
タマイズしてみたいと思ったら、変数に関する基礎を読んでください。そうす
れば、個々の変数に関する情報を理解できるでしょう。*Note Variables::。



File: emacs-ja.info, Node: Text Characters, Next: Entering Emacs, Prev: Commands, Up: Top

テキスト用の文字集合
====================

Emacsバッファ内のテキストは、1バイト8ビットのバイトの列です。各バイト
で、1つのASCII文字を表現できます。ASCIIコントロール文字（8進数000〜037、
0177）とASCII印字文字（8進数040〜0176）の両方を使えます。しかし、非
ASCIIコントロール文字はバッファには現れません。メタのようなキーボード
入力で用いられるその他の修飾フラグもバッファ内では許されません。

いくつかのASCIIコントロール文字は、テキスト中では特別な目的のために用
いられていて、特別な名前が付いています。たとえば、改行文字（8進数012）
は、バッファ内の1行の終りに使われます。また、タブ文字（8進数011）は、
つぎのタブストップ位置（通常8桁ごと）までテキストを字下げするために使
われます。*Note Text Display::。

非ASCII印字文字もバッファ内に存在できます。マルチバイト文字を使用可に
してあれば、Emacsが扱える任意の非ASCII印字文字を使えます。それらの文字
の文字コードは256（8進で0400）から始まり、各文字は2バイト、あるいはそ
れ以上のバイト列として表現されます。*Note International::。

マルチバイト文字を使用不可にしている場合、非ASCII文字のうちの1種類のア
ルファベットだけを使えますが、それらはすべて1バイトに収まるものです。
文字コードは0200から0377を使います。*Note Single-Byte European
Support::。


File: emacs-ja.info, Node: Entering Emacs, Next: Exiting, Prev: Text Characters, Up: Top

Emacsの起動と終了
*****************

Emacsを起動する普通の方法は、シェルコマンドの`emacs'です。Emacsは、画
面をクリアし、初期ヘルプメッセージとコピーライトを表示します。オペレー
ティングシステムによっては、Emacsが起動するまでに先打ちした入力をすべ
て破棄してしまうことがあります。Emacs側ではこれを防ぐことはできません。
したがって、編集コマンドを打ち始めるまえに、Emacsが画面をクリアするま
で待つように推奨します。

Xウィンドウシステム上のシェルウィンドウからEmacsを起動するのであれば、
`emacs&'のようにバックグラウンドで実行するようにしましょう。こうすれば、
Emacsがシェルウィンドウを拘束することがないので、Emacsが専用のXのウィ
ンドウで動作中でも、別のシェルコマンドを実行できます。キーボード入力を
Emacsのフレームに向ければ、ただちにEmacsコマンドを打ち始められます。

Emacsが動き始めると、`*scratch*'という名前のバッファを作ります。ユーザー
はこのバッファから始めます。バッファ`*scratch*'は、Lisp対話
（lisp-interaction）モードですから、Lisp式を打ち込んでそれを評価できま
すし、あるいは、この機能を無視して単なる落書用として使ってもかまいませ
ん。（個人の初期化ファイル中で変数`initial-major-mode'を設定すれば、こ
のバッファに別のメジャーモードを指定できる。*Note Init File::。）

シェルのコマンド行でEmacsに引数を与えて、訪問するファイル、ロードする
Lispファイル、呼び出す関数を指定できます。*Note Command Arguments::。
ただし、これはお勧めしません。この機能は、主に、他のエディタとの互換性
のためにあるのです。

他のエディタの多くは、編集を行うたびに新たに起動するように設計されてい
ます。1つのファイルを編集し終えると、エディタを終了します。つぎに別の
ファイルや同じファイルを編集したければ、再度、エディタを起動する必要が
あります。これらのエディタでは、コマンド行の引数で編集するファイルを指
定する意味があります。

しかし、別のファイルを編集するたびに新たにEmacsを起動するのはナンセン
スです。1つには、起動はじれったいほど遅いでしょう。また、このようにす
ると、1つの編集セッションで複数のファイルを扱えるEmacsの利点を活かせま
せん。さらに、レジスタやアンドゥ履歴、マークリングといった、それまでに
蓄積した内容も失ってしまいます。

GNU Emacsの推奨される使い方は、ログイン後に1度だけEmacsを起動して、す
べての編集を同じEmacsセッションで行うことです。別のファイルを編集する
には、既存のEmacsでそのファイルを訪問します。そうすると、ついには、多
くのファイルをすぐに編集できる状態で保持することになります。通常、ログ
アウトするまで、Emacsを終了する必要はありません。複数のファイルを訪問
することに関して詳しくは、*Note Files::。



File: emacs-ja.info, Node: Exiting, Next: Basic, Prev: Entering Emacs, Up: Top

Emacsの終了
===========

Emacsの抜け方には、"休止"（suspending）する、"終了"（killing）するの2
種類があるので、Emacsを抜けるコマンドも2つあります。

"休止"（suspending）は、一時的にEmacsを止めて、親プロセス（通常はシェ
ル）に制御を戻します。こうすると、同じバッファ、同じキルリング、同じア
ンドゥ履歴を保持したままの同じEmacsジョブをあとで再開できます。これが
通常の抜け方 (1) (*Note Exiting-Footnotes::)です。

"終了"（killing）は、Emacsジョブの破壊を意味します。あとでまたEmacsを
起動できますが、新たなEmacs環境です。終了したあとでは、同じ編集セッショ
ンを再開する方法はありません。

`C-z'
     Emacsを休止する、あるいは、フレームをアイコン化する
     （`iconify-or-deiconify-frame'）。
`C-x C-c'
     Emacsを終了する（`save-buffers-kill-emacs'）。

Emacsを休止するには、`C-z'（`suspend-emacs'）と打ちます。すると、Emacs
を起動したシェルに戻ります。ほとんどの一般的なシェルでは、シェルコマン
ド`%emacs'でEmacsを再開できます。

プログラムを休止できないシステムでは、`C-z'は、端末と直接やりとりする
下位シェルを起動します。Emacsは、ユーザーがこのサブシェルから抜け出る
まで待ちます。（普通、`C-d'や`exit'でサブシェルを終了するはずだが、使っ
ているシェルに依存する。）このようなシステムでは、Emacsを起動したシェ
ルに（たとえばログアウトのために）戻るには、Emacsを終了する以外に方法
はありません。

プログラムを休止できるシステムであっても、プログラムを休止できないシェ
ル上で実行しているEmacsは休止できません。このような場合、変数
`cannot-suspend'に`nil'以外の値を設定して、`C-z'に下位シェルの実行を強
制できます。（適切なジョブ制御をできないEmacsの親シェルを『下位』と呼
ぶこともできるが、これは好みの問題。）

EmacsがXサーバーと直接通信して専用のXのウィンドウを作っている場合には、
`C-z'は別の意味になります。専用のXのウィンドウを持つアプリケーションを
休止しても、あまり意味がありませんし、便利なわけでもありません。そのか
わり、`C-z'は、選択されているEmacsフレーム（*Note Frames::）を一時的に
閉じるコマンド`iconify-or-deiconify-frame'を実行します。シェルウィンド
ウに戻るには、ウィンドウマネージャの機能を使います。

Emacsを終了するには、`C-x C-c' （`save-buffers-kill-emacs'）と打ちます。
これを2文字のキーにしてあるのは、少々打ちづらく (2) (*Note
Exiting-Footnotes::)するためです。このコマンドは、まず、変更したバッファ
を保存するかどうか聞いてきます。未保存のものがあるとそれらを永久に失う
ことになるので、Emacsを終了するまえに`yes'での再確認を求めてきます。
Emacsを終了するとサブプロセスもただちに終了されられてしまうため、サブ
プロセスが走っている場合にも、それらに関して確認を求めてきます。


一度Emacsを終了してしまうと、Emacsセッションを再開する方法はありません。
しかしながら、終了時に訪問していたファイルなどの特定のセッション情報を
記録するようにEmacsに指示しておけば、つぎにEmacsを起動し直したときに、
同じファイルを訪問するなどを試みるようになります。*Note Saving Emacs
Sessions::。

オペレーティングシステムは、通常、実行中のプログラムを終了させたり休止
させたりする特定の特殊文字を監視しています。Emacsを使っているときには、
オペレーティングシステムのこの機能はオフになっています (3) (*Note
Exiting-Footnotes::) 。Emacsのキーとしての`C-z'や`C-x C-c'の意味は、い
くつかのオペレーティングシステムでプログラムを休止させたり終了させたり
するために用いる文字、`C-z'と`C-c'にヒントを得たものですが、オペレーティ
ングシステムとの関係はそれだけです。これらのキーで好きなコマンドを実行
するようにカスタマイズできます（*Note Keymaps::）。



File: emacs-ja.info  Node: Exiting-Footnotes, Up: Exiting

(1) 【訳注】これは、画面端末を使っている場合の話。

(2) 【訳注】簡単に終了してしまっては、困るので。

(3) 【訳注】Emacsが専用のXのウィンドウを使っている場合は関係ない。


File: emacs-ja.info, Node: Basic, Next: Minibuffer, Prev: Exiting, Up: Top

基本編集コマンド
****************

テキストの入力、修正、ファイルへの保存といった基本操作について説明しま
す。これらに接するのが初めてという読者は、手を動かしながら学ぶチュート
リアルを実行したほうが、もっと簡単に習得できる思います。チュートリアル
を利用するには、Emacsを起動して`Control-h t'と打ちます。 (1) (*Note
Basic-Footnotes::)

画面をクリアして再表示するには、`C-l'（`recenter'）と打ちます。

* Menu:


* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        How to move the cursor to the place where you want to
			  change something.
* Erasing::	        Deleting and killing text.
* Undo::	        Undoing recent changes in the text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* Blank Lines::	        Commands to make or delete blank lines.
* Continuation Lines::  Lines too wide for the screen.
* Position Info::       What page, line, row, or column is point on?
* Arguments::	        Numeric arguments for repeating a command.
* Repeating::           A short-cut for repeating the previous command.


File: emacs-ja.info  Node: Basic-Footnotes, Up: Basic

(1) 【訳注】Emacsのインストールの仕方によっては、きちんと日本語のチュー
トリアルが表示される。そうでなければ、`M-x
set-language-environment RET Japanese RET'（あるいは、
`C-x RET l Japanese RET'）と打ってから、改めて
`Control-h t'と打つ。日本語以外にもいくつかの言語のチュートリアル
がある。



File: emacs-ja.info, Node: Inserting Text, Next: Moving Point, Up: Basic

テキストを挿入する
==================

編集中のテキストに印字文字を挿入するには、単にその文字を打ちます。こう
すると、打鍵した文字がバッファのカーソル位置（すなわち"ポイント"位置。
*Note Point::）に挿入されます。カーソルは右（前向き）に移動して、それ
にあわせてカーソル以降のすべてのテキストも右（前向き）に移動します。バッ
ファ内のテキストが`FOOBAR'であって、カーソルが`B'に重なっているとする
と、`XX'と打つとカーソルは`B'に重なったままで、`FOOXXBAR'となります。

挿入したばかりのテキストを"削除"（delete）するには、DELキーを使います。
DELキーは*カーソルのまえ*の文字を削除します（カーソルが重なっている文
字ではない。その文字はカーソルのうしろにある）。カーソルとカーソル以降
のすべてのテキストは左（後向き）に移動します。つまり、図形文字を1つ打っ
た直後にDELを打つと、挿入を取り消したことになります。

行を終えて新たな行を打ち始めるには、RETを打ちます。これにより、バッファ
に改行文字が挿入されます。ポイントが行の途中にある場合、RETは行を分割
します。カーソルが行頭にあるときにDELを打つと、直前の改行文字が削除さ
れて直前の行と連結されます。

"自動詰め込み"（auto-fill）モードと呼ばれる特別なマイナモードをオンに
しておくと、行が長くなりすぎたときにEmacsが自動的に行を分割します。自
動詰め込み（auto-fill）モードの使い方は、*Note Filling::。

既存のテキストを右に押しやるのではなく、テキストを順次置き換える（上書
きする）のが好みならば、マイナモードの1つである上書き（overwrite）モー
ドをオンにします。*Note Minor Modes::。

印字文字とSPCは直接挿入できますが、それ以外の文字は編集コマンドとして
機能して、それ自体を挿入しません。コントロール文字や8進で0200を超える
文字コードの文字を挿入したい場合には、まず`Control-q'（`quoted-insert'）
と打って、それらの文字を"クォート"（quote） (1) (*Note Inserting
Text-Footnotes::) する必要があります。（`Control-q'は、通常、`C-q'と略
す。）`C-q'の使い方には、つぎの2つがあります。

   * `C-q'に続く非図形文字（`C-g'でさえも）を挿入する。

   * `C-q'に続く8進数字列は、8進数字列で指定されるコードの文字を挿入す
     る。8進数字の桁数はいくつでもかまわず、8進数字以外で数字列は終る。
     終端の文字がRETであれば、単に数字列を終らせるだけ。それ以外の非数
     字は、数字列を終らせるだけでなく、その文字自身も入力として扱われ
     る。（普通の上書き（overwrite）モードでは、上書きのかわりに挿入を
     簡単に行う手段としているため、この8進数字列は使えない。）

マルチバイト文字が使用可ならば、8進コード0200から0377までは正しい文字
ではありません。この範囲のコードを指定すると、`C-q'はISO Latin-N文字集
合の利用を意図しているとみなして、指定したコードを対応するEmacs文字コー
ドに変換します。*Note Enabling Multibyte::。言語環境の選択（*Note
Language Environments::）を介して、ISO Latin文字集合を1つ選びます。

8進数のかわりに10進数や16進数を使うには、変数`read-quoted-char-radix'
に10や16を設定します。基数が10を超える場合には、`a'から始まるいくつか
の英字は文字コードの一部として数字の桁と同じように扱われます。

`C-q'に数引数を指定すると、クォートした文字を何個挿入するかを指定しま
す（*Note Arguments::）。

カスタマイズ情報：` ' ほとんどのモードでは、DELはコマンド
`delete-backward-char'を実行します。RETはコマンド`newline'を実行します。
自己挿入の図形文字はコマンド`self-insert'を実行します。`self-insert'は、
これを起動した文字が何であってもその文字を挿入します。いくつかのメジャー
モードでは、DELを別のコマンドにバインドし直しています。


File: emacs-ja.info  Node: Inserting Text-Footnotes, Up: Inserting Text

(1) 【訳注】なんらの解釈もせずに、単なる文字として扱う。



File: emacs-ja.info, Node: Moving Point, Next: Erasing, Prev: Inserting Text, Up: Basic

ポイント位置を移動する
======================

文字の挿入以外のことを行うには、ポイント（*Note Point::）の移動方法を
知っておく必要があります。もっとも簡単な方法は、矢印キーを使うか、移動
先の箇所でマウスの左ボタンをクリックします。

カーソル移動のためのコントロール文字やメタ文字もあります。一部は矢印キー
と同等です（これらは、矢印キーを備えた端末が現れるまえからあった。矢印
キーがない端末では便利）。他のものは、こったことをします。

`C-a'
     行頭に移動する（`beginning-of-line'）。
`C-e'
     行末に移動する（`end-of-line'）。
`C-f'
     前向き（右）に1文字移動する（`forward-char'）。
`C-b'
     後向き（左）に1文字移動する（`backward-char'）。
`M-f'
     前向きに1語移動する（`forward-word'）。
`M-b'
     後向きに1語移動する（`backward-word'）。
`C-n'
     垂直に1行下へ移動する（`next-line'）。このコマンドは行内での横方
     向の位置を保とうとする。したがって、行の途中で使うと、つぎの行の
     途中に移動する。テキストの最終行である場合には、`C-n'は新たな行を
     作り、その行へ移動する。
`C-p'
     垂直に1行上へ移動する（`previous-line'）。
`M-r'
     ポイントをウィンドウの縦方向の中央位置で左端に移動する
     （`move-to-window-line'）。テキストは画面上を移動しない。

     数引数は、画面上の何行目にポイントを移動するかを指定する。行数は、
     ウィンドウ上端（0行目）から下向きに数える。負の引数では、ウィンド
     ウの下端（-1行）から数える。
`M-<'
     バッファの先頭に移動する（`beginning-of-buffer'）。数引数Nを指定
     すると、先頭から全体のN/10の行にポイントを移動する。数引数の詳細
     については、*Note Arguments::。
`M->'
     バッファの末尾に移動する（`end-of-buffer'）。
`M-x goto-char'
     数値Nを読み取り、バッファのN番目の文字にポイントを移動する。バッ
     ファの先頭が位置1。
`M-x goto-line'
     数値Nを読み取り、N行目にポイントを移動する。バッファの先頭が第1行。
`C-x C-n'
     現在ポイントがある桁を`C-n'や`C-p'の"半恒久的な目標桁"として設定
     する。このあと、これらのコマンドは、移動先の各行でこの桁位置に、
     あるいは、行の内容によっては可能な限りこの桁に近い位置にポイント
     を移動する。この目標桁は取り消すまで有効。
`C-u C-x C-n'
     目標桁を取り消す。これ以後、`C-n'や`C-p' は、通常のように横方向の
     位置を保とうとする。

変数`track-eol'に`nil'以外を設定すると、行末にポイントがある場合の
`C-n'や`C-p'は、移動先の行でも行末にポイントを移動します。通常、
`track-eol'は`nil'です。`track-eol'のような変数の設定方法については、
*Note Variables::。

通常、バッファの最終行での`C-n'は、新しい行を追加します。変数
`next-line-add-newlines'が`nil'である場合、`C-n'は新規の行を追加せずに
（先頭行での`C-p'と同様に）エラーになります。



File: emacs-ja.info, Node: Erasing, Next: Undo, Prev: Moving Point, Up: Basic

テキストの消去
==============

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）。
`C-d'
     ポイントの直後の文字を削除する（`delete-char'）。
`C-k'
     行末までをキルする（`kill-line'）。
`M-d'
     つぎの語の末尾までを前向きにキルする（`kill-word'）。
`M-DEL'
     まえの語の先頭までを後向きにキルする（`backward-kill-word'）。

ポイントの直前（つまり、カーソルの直前）の文字を削除するDELキーについ
てはすでに知っていますね。`Control-d'（`C-d'と略記）は、ポイントの直後
の文字（つまり、カーソルが重なっている文字）を削除します。すると、残り
のテキストは左に移動します。行末で`C-d'を打つと、その行とつぎの行が連
結されます。

大量のテキストを消去するには、`C-k'を使います。`C-k'は1行を一度にキル
します。行頭や行の途中で`C-k'を打つと、行末までのすべてのテキストをキ
ルします。行末で`C-k'を打つと、その行とつぎの行を連結します。

より柔軟なテキストのキルについての詳細は、*Note Killing::。



File: emacs-ja.info, Node: Undo, Next: Basic Files, Prev: Erasing, Up: Basic

変更をアンドゥする（もとに戻す）
================================

バッファのテキストに対する変更は、ある時点まで遡って、すべてアンドゥ
（もとに戻すことが）できます。各バッファでは個々の変更をそれぞれ記録し
ていて、アンドゥコマンドは、つねにカレントバッファに作用します。通常、
各編集コマンドはアンドゥ記録に別々の項目を作成しますが、
`query-replace'のようなコマンドは一度に多くの項目を作りますし、自己挿
入文字のように非常に単純なコマンドは、もとに戻すのを単純にするために、
まとめられます。

`C-x u'
     一塊の変更をもとに戻す。普通、1つのコマンドに相当する（`undo'）。
`C-_'
     同じ。
`C-u C-x u'
     リージョン内で、一塊の変更をもとに戻す。

変更をもとに戻すには、コマンド、`C-x u'や`C-_'を使います。始めにこのコ
マンドを実行すると、直前の変更をもとに戻します。ポイントは、もとに戻さ
れたコマンドを実行するまえの位置に戻ります。

`C-_'や`C-x u'を連続して実行すると、アンドゥ情報の限界に達するまで、次々
に以前の変更をもとに戻していきます。記録されているすべての変更をもとに
戻してしまうと、アンドゥコマンドはその旨エラーメッセージを表示します。

アンドゥコマンド以外の他のコマンドを実行すると、アンドゥコマンドの連続
実行系列が断ち切られます。これ以後、これよりまえのアンドゥコマンドの実
行自体が、もとに戻すことが可能な一般の変更として扱われます。したがって、
もとに戻してしまった変更をやはりそのとおりに変更しておきたい場合には、
`C-f'と打つか、あるいは、無害なコマンドを実行してアンドゥの連続実行系
列を断ち切ってから、さらにアンドゥコマンドを打ちます。

普通のアンドゥは、カレントバッファにおけるすべての変更に作用します。カ
レントリージョン内に制限した"選択的なアンドゥ"（selective undo）を行う
こともできます。これには、リージョンを設定してから、数引数（値は関係な
い）を指定して`undo'コマンドを、つまり、`C-u C-x u'や`C-u C-_'を実行し
ます。これにより、リージョン内のもっとも最近の変更がもとに戻ります。同
じリージョン内の変更をさらにもとに戻すには、`undo'コマンドを繰り返しま
す（これには数引数は必要ない）。暫定マーク（transient-mark）モードでは、
リージョンが活性のときに`undo'を使うと選択的なアンドゥを行います。つま
り、数引数は必要ありません。

バッファを誤って変更してしまった場合、もとに戻すもっとも簡単な方法は、
モード行の先頭部分から星印が消えるまで`C-_'を繰り返し打つことです。そ
うすれば、すべての修正を取り消したことになります。アンドゥコマンドによ
りモード行から星印が消えた場合はつねに、バッファの内容がファイルを訪問
したときと同じであるか、最後に保存したときと同じであることを意味します。

意図してバッファを変更したかどうかあやふやなときは、一度だけ`C-_'を打
ちます。もとに戻すことで最後の変更箇所がわかりますから、それが意図した
変更かどうか判断できるでしょう。意図した変更でなければ、もとに戻したま
まにしておきます。意図した変更であったなら、上記の方法で変更し直します。

すべてのバッファでアンドゥ情報を記録するわけではありません。空白で始ま
る名前のバッファでは記録しません。これらのバッファは、Emacsやその拡張
部分が内部的に使用するもので、ユーザーが通常見たり編集したりしないテキ
ストを保持しています。

単なるカーソル移動はアンドゥできません。バッファの内容を変更したときだ
けアンドゥ情報が保存されます。ただし、いくつかのカーソル移動コマンドは
マークを設定しますから、これらのコマンドをときどき使えば、マークリング
（*Note Mark Ring::）から取り出しながら、通ってきたそれぞれの箇所へ戻
ることができます。

バッファに関するアンドゥ情報が大きくなると、Emacsはもっとも古いアンドゥ
情報から順に（ガベッジコレクション中に）破棄していきます。保持すべきア
ンドゥ情報の量を指定するには、2つの変数`undo-limit'と
`undo-strong-limit'を設定します。これらの変数の値は、保存領域のバイト
数です。

変数`undo-limit'は緩い限界（soft limit）を設定します。Emacsは、このサ
イズに達するまでのコマンド分のアンドゥデータを保持します。データ量がこ
のサイズを超える場合もありますが、このデータ量を超えるような古いコマン
ド分のデータは保持しません。デフォルトは、20000です。変数
`undo-strong-limit'は、厳密な限界（stricter limit）を設定します。この
量を超えるデータに対応するコマンドのデータは破棄します。初期値は30000
です。

これらの変数の値に関わらず、最新の変更を破棄することはありませんので、
意図しない大きな変更を加えてしまった直後にガベッジコレクションが発生し
ても、その変更をアンドゥできないというようなことはありません。

アンドゥコマンドを実行するキーが`C-x u'と`C-_'と2つある理由は、1文字キー
にするほど重要なのですが、どうやって`C-_'を打つか自明でないキーボード
もあるからです。`C-x u'は、どの端末でも素直に打てる代替手段なのです。



File: emacs-ja.info, Node: Basic Files, Next: Basic Help, Prev: Undo, Up: Basic

ファイル
========

Emacsバッファ内でテキストを作成したり変更したりするには、これまでに説
明したコマンドで十分なはずです。より高度なEmacsコマンドといっても、こ
れらの操作を容易にするだけです。しかし、テキストを恒久的なものとするに
は、"ファイル"（file）に保存する必要があります。ファイルとは、オペレー
ティングシステムが保存するために名前を付けたテキストの一塊であり、あと
でその名前で取り出せます。Emacsでファイルを編集する場合を含めて、ファ
イルの内容を眺めたり利用したりするには、ファイル名を指定する必要があり
ます。

`/usr/rms/foo.c'という名前のファイルがあるとしましょう。このファイルを
編集し始めるには、Emacsではつぎのように打ちます。

     C-x C-f /usr/rms/foo.c RET

ここで、ファイル名は、コマンド`C-x C-f'（`find-file'）に対する"引数"
（argument）として与えます。このコマンドは引数を読むために"ミニバッファ
"を使います。引数の入力を終えるには、RETを打ちます（*Note Minibuffe
r::）。

Emacsはコマンドに従い、ファイルを"訪問"（visiting）します。つまり、バッ
ファを作成し、ファイルの内容をそのバッファにコピーし、ユーザーが編集で
きるようにそのバッファを表示します。テキストを変更したら、`C-x C-s'
（`save-buffer'）と打てば、新しいテキストをファイルに"保存"（save）で
きます。これにより、バッファの変更した内容をファイル`/usr/rms/foo.c'に
コピーし戻したので、変更は恒久的になります。ユーザーが保存するまでは、
変更はEmacs内部のみに存在するだけで、ファイル`foo.c'自体は未変更のまま
です。

ファイルを作成するには、そのファイルが既存であるかのように、`C-x C-f'
でファイルを訪問するだけです。これにより、空のバッファが作られ、ファイ
ルに収めたいテキストを挿入できるようになります。`C-x C-s'でバッファを
保存したときに、ファイルが実際に作成されます。

もちろん、ファイルについてはもっと知っておく必要があります。*Note
Files::。



File: emacs-ja.info, Node: Basic Help, Next: Blank Lines, Prev: Basic Files, Up: Basic

ヘルプ
======

キーの機能を忘れてしまった場合には、ヘルプ文字`C-h'（あるいは`C-h'の別
名であるF1）を使って、調べられます。`C-h k'と打ってから、調べたいキー
を続けて打ちます。たとえば、`C-h k C-n'は、`C-n'が何をするか教えてくれ
ます。`C-h'はプレフィックスキーです。`C-h k'は、`C-h'の1つのサブコマン
ド（コマンド`describe-key'）です。`C-h'には他にもサブコマンドがあり、
それぞれ異なる種類のヘルプを表示します。`C-h'を2回打てば、ヘルプ機能自
体の説明を見ることができます。*Note Help::。



File: emacs-ja.info, Node: Blank Lines, Next: Continuation Lines, Prev: Basic Help, Up: Basic

空行
====

空行の挿入と削除に関する特別なコマンドや技法を紹介します。

`C-o'
     カーソルの直後に1行以上の空行を挿入する（`open-line'）。
`C-x C-o'
     連続する空行を1行だけ残してすべて削除する（`delete-blank-lines'）。

既存の行のまえに新たに1行を挿入するには、
新しい行のテキストを打ってからRETを打つこともできます。
しかし、まず空行を作ってから、
そこに希望のテキストを挿入するほうが何をしているのかがわかりやすいでしょう。
キー`C-o'（`open-line'）を使えば簡単です。
これはポイントの直後に改行を挿入して、
ポイントは改行の直前に置かれたままとなります。
`C-o'に続けて、新しい行のテキストを打ちます。
`C-o F O O'は、ポイントの最終的な位置を除けば、
`F O O RET'と同じ効果を持ちます。

複数の空行を作るには、`C-o'を数回打つか、作りたい空行の個数を指定する
数引数を指定します。数引数の指定方法は、*Note Arguments::。詰め込み接
頭辞を設定してある場合、行の先頭で`C-o'コマンドを使うと、このコマンド
は新しい行に詰め込み接頭辞を挿入します。*Note Fill Prefix::。

余分な空行を削除するには、コマンド`C-x C-o'（`delete-blank-lines'）を
使います。連続する複数の空行の中で`C-x C-o'を実行すると、1行を残してす
べての空行を削除します。空行が1行だけの場合、その空行自体を削除します。
空行でない行にポイントがある場合、その行に続くすべての空行を削除します。



File: emacs-ja.info, Node: Continuation Lines, Next: Position Info, Prev: Blank Lines, Up: Basic

継続行
======

RETで分割せずに1行に文字を加え続けると、その行は画面上で2行以上を占め
るようになります。このとき、そのような行の最後の行を除くすべての行の右
端には、`\'が表示されます。この`\'は、画面上の後続の行はテキスト内の独
立した行ではなく、画面に収まりきらない長い行が"継続"（continuation）し
ていることを意味します。この継続を、"折り返し"（wrapping）とも呼びます。

行が長くなりすぎたときにEmacsが自動的に改行を挿入すると便利なことがあ
ります。画面上での継続は、このようには機能しません。自動的に改行するよ
うにするには、自動詰め込み（auto-fill）モード（*Note Filling::）を使い
ます。

継続のかわりの方法として、Emacsは長い行を"切り捨て"（truncation）て表
示することもできます。つまり、画面やウィンドウの幅に収まりきらない文字
は表示しません。もちろん、一時的に見えないだけで、バッファ内には存在し
ています。切り捨てていることを示すために、`\'ではなく`$'を右端に用いま
す。

水平スクロールを使っていたり、ウィンドウを左右に並べていると、継続のか
わりに切り捨て表示します（*Note Windows::）。特定のバッファの変数
`truncate-lines'に`nil'以外を設定すると、そのバッファを切り捨て表示に
できます（*Note Variables::）。変数`truncate-lines'の値を変更すると、
この変数はカレントバッファにローカルになります。そうするまでは、デフォ
ルト値が使われます。デフォルトの初期値は`nil'です。*Note Locals::。

テキストの表示方法に影響する変数については、*Note Display Vars::。



File: emacs-ja.info, Node: Position Info, Next: Arguments, Prev: Continuation Lines, Up: Basic

カーソル位置の情報
==================

バッファのある部分の大きさや位置に関する情報を得るコマンドや行を数える
コマンドを紹介します。

`M-x what-page'
     ポイントがあるページの番号とそのページ内での行番号を表示する。
`M-x what-line'
     ポイントがある行のバッファ内での行番号を表示する。
`M-x line-number-mode'
     現在行の自動行番号表示をオン／オフする。
`M-='
     カレントリージョンの行数を表示する（`count-lines-region'）。リー
     ジョンに関しては、*Note Mark::。
`C-x ='
     ポイントの直後にある印字文字の文字コード、ポイントの文字位置、ポ
     イントの桁位置を表示する（`what-cursor-position'）。

行番号に関するコマンドは2つあります。`M-x what-line'は現在行の行番号を
計算して、エコー領域に表示します。指定した行番号の行へ移動するには、
`M-x goto-line'を使います。このコマンドは、行番号を聞いてきます。これ
らの行番号は、バッファの先頭を1行目と数えます。

モード行で現在行の行番号を知ることもできます。*Note Mode Line::。バッ
ファをナロイングしてある場合、モード行中の行番号は参照可能な範囲内での
相対的なものになります（*Note Narrowing::）。対照的に、`what-line'は、
ナロイングされた範囲内での行番号と、バッファ全体での行番号の両方を表示
します。

これに対し、`M-x what-page'は、ファイルの先頭からページを数え、さらに
ページ内での行番号も数えて、両方を表示します。*Note Pages::。

この話題に関連して、`M-='（`count-lines-region'）も説明しておきましょ
う。これは、リージョンの行数を数えて表示します（*Note Mark::）。カレン
トページの行数を数えるコマンド`C-x l'については、*Note Pages::。

コマンド`C-x ='（`what-cursor-position'）は、カーソルがある箇所の桁位
置を求めたり、ポイントに関するその他の種々の情報を得るために使います。
エコー領域につぎのように表示します。

     Char: c (0143, 99, 0x63)  point=21044 of 26883(78%)  column 53 

（これは、例の中の`column'のまえにポイントがあるときの実際の出力。）

`Char:'のあとの4つの値は、ポイントの直後の文字を表していて、文字そのも
の、続いて、文字コードの8進表示、10進表示、16進表示です。非ASCIIのマル
チバイト文字に対しては、バッファのコーディングシステムにおいて当該文字
をまちがいなく、かつ、単一バイトで符号化できる場合には、`ext'とバッファ
のコーディングシステムで表した文字コードの16進表示が続きます（*Note
Coding Systems::）。文字の符号が1バイトより長い場合には、Emacsは`ext
...'を表示します。

`point='のあとは、ポイント位置を文字単位に数えたものです。バッファの先
頭を位置1、つぎの1文字を2、というように数えます。つぎの大きな数字はバッ
ファ内の総文字数です。続く括弧の中は、ポイント位置の全サイズに対する百
分率です。

`column'に続くものは、ウィンドウの左端からの桁数で表したポイントの水平
位置です。

バッファをナロイングしていて、バッファの先頭と末尾のテキストの一部が表
示されていない場合、`C-x ='は、現在参照可能な範囲に関する情報も表示し
ます。たとえばつぎのようになります。

     Char: C (0103, 67, 0x43)  point=252 of 889(28%) <231 - 599>  column 0 

ここで、新たに追加された2つの数字が、ポイントを設定できる文字位置の下
限と上限を示します。これら2つの位置のあいだの文字が参照可能な文字です。
*Note Narrowing::。

ポイントがバッファの末尾（あるいは参照可能な部分の末尾）にある場合、
`C-x ='は、ポイントの直後の文字に関する情報は表示しません。
出力はつぎのようになります。

     point=26957 of 26956(100%)  column 0 

`C-u C-x ='は、バッファ内の位置と桁位置のかわりに、文字に関する追加情
報、つまり、文字集合名とその文字集合内でその文字を識別するコードを表示
します。ASCII文字は、文字集合`ASCII'に属するものと識別します。さらに、
文字を完全に符号化するのに単一バイトより多く必要な場合であっても、
`ext'のあとに文字コードを表示します。コーディングシステムが
iso-2022-7bitであるバッファ内にあるLatin-1のアクサングレーブ付きの文字
Aの例を示します。 (1) (*Note Position Info-Footnotes::)

     Char: `A (04300, 2240, 0x8c0, ext ESC , A @) (latin-iso8859-1 64)


File: emacs-ja.info  Node: Position Info-Footnotes, Up: Position Info

(1) Latin-1文字を表示できる端末であれば、`Char:'のあとに表示され
る文字は、実際に、アクサングレーブ付きの文字Aになる。



File: emacs-ja.info, Node: Arguments, Next: Repeating, Prev: Position Info, Up: Basic

数引数
======

数学や計算機の用語では、"引数"（argument）という単語は『関数や操作に与
えるデータ』を意味します。Emacsのすべてのコマンドには、"数引数"
（numeric argument）（"前置引数"（prefix argument）とも呼ぶ）を指定で
きます。コマンドによっては、引数を反復回数として解釈します。たとえば、
引数10を`C-f'に指定すると、カーソルを通常の1文字ではなく、10文字分前向
きに移動します。これらのコマンドでは、引数を指定しないと引数1を指定し
たのと同等になります。この種のコマンドの多くでは、負の引数を指定すると、
逆向きの移動や逆の操作を指示することになります。

端末のキーボードにMETAキーがある場合、数引数を入力するもっとも簡単な方
法は、METAキーを押し下げたままで、数字やマイナス記号を打ちます。たとえ
ば、M-5 C-n は、カーソルを5行下に移動します。`Meta-1'、`Meta-2'、
`Meta--'などの文字がこのように動作するのは、これらのキーが、後続のコマ
ンドに引数を与えるように定義されたコマンド（`digit-argument'と
`negative-argument'）にバインドされているからです。コントロールやコン
トロールとメタで修飾した数字と`-'も、同様に数引数を指定します。

引数を指定する別の方法は、`C-u'（`universal-argument'）コマンドに続け
て引数の数字を入力することです。`C-u'では、修飾キーを押し下げ続けるこ
となく引数の数字を打てます。`C-u'はすべての端末で使えます。負の引数を
指定するには、`C-u'のあとにまずマイナス記号を打ちます。マイナス記号だ
けだと-1を意味します。

`C-u'のあとに数字でもマイナス記号でもない文字を打つと、『4倍する』とい
う特別な意味になります。つまり、後続のコマンドに渡す引数を4倍します。
`C-u'を2回打つと、引数を16倍します。したがって、`C-u C-u C-f'は、カー
ソルを前向きに16文字分移動します。16文字は通常の画面で約1/5行に相当す
るので、カーソルを『速く』移動させたい場合に便利な方法です。便利な他の
組み合せは、`C-u C-n'や`C-u C-u C-n'（画面の下方への移動に便利）、`C-u
C-u C-o'（『数多く』の空行を作る）、`C-u C-k'（4行キルする）です。

コマンドによっては、引数の値ではなく、引数の有無だけを問題にします。た
とえば、コマンド`M-q'（`fill-paragraph'）に引数を指定しないとテキスト
の詰め込みのみを行います。引数を指定すると、さらに幅揃えも行います。
（`M-q'に関する詳細は、*Note Filling::。）`C-u'だけを使えば、このよう
なコマンドに簡単に引数を指定できます。

引数の値を反復回数として使うにも関わらず、引数がないと特別な動作をする
コマンドもあります。たとえば、`C-k'（`kill-line'）に引数Nを指定すると、
行区切りの改行も含めてN行をキルします。これに対し、引数を指定しない場
合は特別な動作となります。つまり、つぎの改行文字までのテキストをキルす
るか、行末にポイントがある場合は改行そのものをキルします。したがって、
引数を指定せずに`C-k'を2回実行すると、引数1を指定した`C-k'と同様に、空
行でない1行をキルします。（`C-k'の詳細については、*Note Killing::。）

いくつかのコマンドは、`C-u'だけの引数を通常の引数とは異なるものとして
扱います。また、マイナス記号のみの引数を-1と区別するコマンドもあります。
これらの例外については、必要になったときに説明します。これらの例外は、
それぞれのコマンドを使いやすくするためにあります。

数引数を使って、文字のコピーを複数個挿入することもできます。この操作は、
数字以外の文字ならば簡単です。たとえば、`C-u 6 4 a'で、文字`a'を64個挿
入できます。しかし、数字では機能しません。`C-u 6 4 1'は、引数が641であ
ることを意味し、何も挿入しません。引数と挿入したい数字を区切るには、も
う1つ`C-u'を打ちます。たとえば、`C-u 6 4 C-u 1'で、数字`1'を64個挿入で
きます。

コマンドのまえに引数を打つということを強調するために、また、コマンドの
あとのミニバッファ引数と区別するために、『数引数』と同様に用語『前置引
数』を使います。



File: emacs-ja.info, Node: Repeating, Prev: Arguments, Up: Basic

コマンドを繰り返す
==================

コマンド`C-x z'（`repeat'）は、Emacsコマンドを何回も反復する別の方法で
す。このコマンドは、直前のEmacsコマンドが何であっても、それを繰り返し
ます。繰り返されるコマンドは、まえと同じ引数を使います。毎回、新たに引
数を読むことはしません。

コマンドを2回以上繰り返すには、`z'を追加して打ちます。1つの`z'で、コマ
ンドを1回繰り返します。`z'以外の文字を打つか、マウスボタンを押すと、繰
り返しを終了します。

たとえば、20文字削除するために`C-u 2 0 C-d'と打ったとしましょう。`C-x
z z z'と打てば、（引数を含めて）削除コマンドをさらに3回繰り返し、全部
で80文字削除できます。始めの`C-x z'でコマンドを1回繰り返し、そのあとの
それぞれの`z'で1回ずつ繰り返します。



File: emacs-ja.info, Node: Minibuffer, Next: M-x, Prev: Basic, Up: Top

ミニバッファ
************

"ミニバッファ"は、単純な数よりも複雑な引数をEmacsコマンドが読み取るた
めに用いる機構です。ミニバッファ引数は、ファイル名、バッファ名、Lisp関
数名、Emacsコマンド名、Lisp式など、引数を読み取るコマンドに応じて多種
多様です。ミニバッファでは、通常のバッファと同様の編集機能を用いて引数
のテキストを編集できます。

ミニバッファが使われているときには、ミニバッファはエコー領域に表示され
て、端末のカーソルもエコー領域に移動します。ミニバッファの行の先頭には
"プロンプト"（prompt）が表示されます。プロンプトにより、何を入力しそれ
がどのように使われるかを知ることができます。プロンプトは、引数を要求し
ているコマンドの名前から導かれることが多いです。プロンプトは通常コロン
で終ります。

コロンのあとの括弧の中に"デフォルト引数"（default argument）が表示され
ることもあります。これもプロンプトの一部です。（たとえば、RETだけを打っ
て）空の引数を入力したときには、デフォルトが引数として使われます。たと
えば、バッファ名を読み取るコマンドは、つねに、デフォルトを表示しますが、
それはRETだけを打ったときに使われるバッファ名です。

ミニバッファ引数を入力するもっとも簡単な方法は、目的のテキストを入力し
てから、ミニバッファから抜けるRETで終えることです。`C-g'を打てば、引数
を必要とするコマンドを取り消して、ミニバッファを抜けることができます。

ミニバッファは画面のエコー領域を使うため、習慣的にエコー領域を使用する
Emacsの機能と衝突する可能性があります。Emacsは、そのような衝突を以下の
ように扱います。

   * ミニバッファを使用中にコマンドがエラーを起こしても、ミニバッファ
     を取り消すことはない。しかしながら、エラーメッセージを表示するた
     めにエコー領域が必要なので、しばらくのあいだミニバッファを隠す。
     数秒経過するか、何かを打つと、ただちにミニバッファを表示する。

   * `C-x ='のように、エコー領域にメッセージを表示するコマンドをミニバッ
     ファで実行すると、メッセージは通常どおり表示して、しばらくのあい
     だミニバッファを隠す。数秒経過するか、何かを打つと、ただちにミニ
     バッファを表示する。

   * ミニバッファを使用中は、キー入力をエコーしない。

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::		  Re-executing commands that used the minibuffer.



File: emacs-ja.info, Node: Minibuffer File, Next: Minibuffer Edit, Up: Minibuffer

ファイル名入力用のミニバッファ
==============================

最初からテキストを伴って始まるミニバッファもあります。たとえば、ファイ
ル名を指定しなければならない場合、ミニバッファはスラッシュで終る"デフォ
ルトディレクトリ" （default directory）を含んでいます。これにより、ディ
レクトリを指定しなくても、どのディレクトリからファイルを探すかわかりま
す。

たとえば、ミニバッファがつぎのような内容で始まったとしましょう。

     Find File: /u2/emacs/src/

ここで、`Find File: 'がプロンプトです。`buffer.c'と打てば、ファイル
`/u2/emacs/src/buffer.c'を指定したことになります。付近のディレクトリの
ファイルを指定するには、`..'を使います。したがって、
`../lisp/simple.el'と打てば、`/u2/emacs/lisp/simple.el'という名前のファ
イルになります。あるいは、不要なディレクトリ名であれば、`M-DEL'でキル
できます（*Note Words::）。

デフォルトディレクトリをまったく使いたくない場合は、`C-a C-k'と打って
キルできます。しかし、デフォルトをキルする必要はありません。単に無視す
ればよいのです。スラッシュやティルダで始まる絶対ファイル名を挿入します。
たとえば、ファイル`/etc/termcap'を指定するには、そのファイル名を挿入し
て、ミニバッファがつぎの内容になるようにします。

     Find File: /u2/emacs/src//etc/termcap

GNU Emacsでは、（普通は意味のある書き方ではない）連続した2個のスラッシュ
に特別な意味を与えています。『2番目のスラッシュよりまえの文字はすべて
無視する』という意味になります。したがって、先の例では、
`/u2/emacs/src/'は無視され、`/etc/termcap'というファイル名になります。

`insert-default-directory'に`nil'を設定すると、ミニバッファにはデフォ
ルトディレクトリを挿入しません。つまり、ミニバッファは空で始まります。
しかし、入力したファイル名が相対的なものであれば、同じデフォルトディレ
クトリ相対に解釈されます。



File: emacs-ja.info, Node: Minibuffer Edit, Next: Completion, Prev: Minibuffer File, Up: Minibuffer

ミニバッファでの編集
====================

ミニバッファは（少々特殊だが）普通のEmacsバッファなので、通常のEmacsコ
マンドを使って、入力中の引数のテキストを編集できます。

ミニバッファでは、RETはミニバッファから抜けるように定義されているので、
ミニバッファで改行を挿入するためにRETを使うことはできません。改行を挿
入するには、`C-o'や`C-q C-j'とします。（改行とは実は文字「コントロール
J」。）

ミニバッファには独自のウィンドウがあり、そのウィンドウは画面上の場所を
占有しています。しかし、ミニバッファが使われていないときには、あたかも
何もないかのようにふるまいます。ミニバッファが使われているときは、その
ウィンドウは他のウィンドウと同様になります。ミニバッファで引数を入力し
終えるまでは、`C-x o'で他のウィンドウに切り替えて、そこでテキストを編
集したり他のファイルを訪問したりもできます。他のウィンドウでテキストを
キルしてから、ミニバッファウィンドウに戻ってそのテキストをヤンクして引
数として使うこともできます。*Note Windows::。

しかし、ミニバッファウィンドウの使用にはいくつかの制限があります。ミニ
バッファウィンドウではバッファを切り替えられません。ミニバッファとその
ウィンドウは恒久的に結び付いています。また、ミニバッファウィンドウを分
割したり消去したりすることもできません。しかし、`C-x ^'を使う通常の方
法で、ウィンドウの高さを大きくすることは可能です。ミニバッファリサイズ
（resize-minibuffer）モードをオンにしておくと、ミニバッファに入力した
テキストを表示するのに必要なだけ、ミニバッファウィンドウは縦に広がりま
す。`M-x resize-minibuffer-mode'を使って、このマイナモードをオン／オフ
します（*Note Minor Modes::）。

ミニバッファウィンドウではスクロールは特殊な動きをします。ミニバッファ
がちょうど1行分の高さで、画面に収まらないほど長い1行のテキストが入って
いるときには、スクロールするときに継続行のあいだでは何文字かを自動的に
重複して表示します。変数`minibuffer-scroll-overlap'で、重複させる文字
数を指定します。デフォルトは20です。

ミニバッファの中で別のウィンドウにある種のヘルプテキストを表示するよう
なコマンドを実行したときには、`C-M-v'を使ってミニバッファの中からヘル
プテキストをスクロールできます。これは、ミニバッファを抜けるまで有効で
す。この機能は、補完をしているミニバッファが、補完候補を別のウィンドウ
に表示するような場合に特に便利です。*Note Other Window::。

Emacsでは、通常、ミニバッファを使っている最中には、ミニバッファを用い
るコマンドの多くを実行できないようにしています。これは、再帰的なミニバッ
ファの使用で初心者が混乱するのを避けるためです。このようなコマンドをミ
ニバッファから利用できるようにするには、変数
`enable-recursive-minibuffers'に`nil'以外を設定します。



File: emacs-ja.info, Node: Completion, Next: Minibuffer History, Prev: Minibuffer Edit, Up: Minibuffer

補完
====

ある種の引数では、引数の値の入力に"補完"（completion）を利用できます。
補完とは、引数の一部分を打つと、Emacsがその残りの部分をすべて、あるい
は既存の入力部分から決定可能な限り残りの部分を補う機能です。

補完を使えるときには、TAB、RET、SPCの各キーは、ミニバッファ内の既存の
テキストをそれを含むより長い文字列に補完するように再定義してあります。
補完は、引数を読み取るコマンドが用意した"補完候補"群（completion
alternatives）に対して入力されたテキストとの一致をとることで行われます。
`?'キーは、入力から補完可能な候補一覧を表示するように定義してあります。

たとえば、`M-x'がコマンド名を読み取るためにミニバッファを使っている場
合、`M-x'は、補完に備えて、使用可能なすべてのEmacsコマンド名の一覧を用
意します。補完キーは、ミニバッファ内のテキストをすべてのコマンド名に照
らし合わせて、ミニバッファの既存の名前から導かれる名前の追加文字列を探
し出して、その文字列をそれまでに入力してあるテキストに付け加えます。こ
れにより、`M-x insert-buffer RET'と打つかわりに、`M-x ins SPC b RET'と
打つことが可能になるのです。

補完では、大文字小文字を区別します。というのは、補完対象となる名前（バッ
ファ名、ファイル名、コマンド名）のほとんどでは、大文字小文字を区別して
いるからです。したがって、`fo'を、`Foo'とは補完しません。大文字小文字
を区別しない引数に対しては、補完も両者を区別しません。

* Menu:

* Example: Completion Example.
* Commands: Completion Commands.
* Strict Completion::
* Options: Completion Options.



File: emacs-ja.info, Node: Completion Example, Next: Completion Commands, Up: Completion

補完の例
--------

具体的な例で考えてみましょう。`M-x au TAB'と打つと、TABは`au'で始まる
候補（この場合はコマンド名）を探します。`au'で始まるものには、
`auto-fill-mode'と`auto-save-mode'を含めていくつかありますが、どれも少
なくとも`auto-'までは同じです。そこで、ミニバッファ内の`au'は`auto-'に
変わります。

ここでただちにTABをもう一度打っても、つぎにくる文字の候補が複数、つま
り、`cfilrs'のどれかなので、さらに文字が追加されることはありません。そ
のかわり、TABは補完候補の一覧を別のウィンドウに表示します。

続けて`f TAB'と打つと、今度のTABは文字列`auto-f'を探します。`auto-f'か
ら始まるコマンド名は`auto-fill-mode'だけなので、補完は残りの部分を補い
ます。これで、`au TAB f TAB'と打つだけで、ミニバッファには
`auto-fill-mode'が入ります。TABキーがこのような効果を持つのは、このキー
がミニバッファ内ではコマンド`minibuffer-complete'にバインドしてあるか
らだということに注意してください。



File: emacs-ja.info, Node: Completion Commands, Next: Strict Completion, Prev: Completion Example, Up: Completion

補完コマンド
------------

補完を使えるミニバッファでは、つぎのような補完コマンドを定義してありま
す。

`TAB'
     ミニバッファのテキストを可能な限り補完する（`minibuffer-complet
     e'）。
`SPC'
     ミニバッファのテキストを1語だけ補完する
     （`minibuffer-complete-word'）。
`RET'
     可能な限り補完したあと、ミニバッファのテキストを引数として渡す
     （`minibuffer-complete-and-exit'）。
`?'
     ミニバッファのテキストから補完可能な候補の一覧を表示する
     （`minibuffer-list-completions'）。

SPCはTABとほぼ同じように補完しますが、つぎのハイフンや空白を超えて補完
することはありません。ミニバッファの文字が`auto-f'であるとしましょう。
ここでSPCを打つと、SPCは`auto-fill-mode'に補完できることを探しだします
が、`fill-'までで補完を止めます。その結果、`auto-fill-'となります。こ
こでもう一度SPCを打つと、今度は`auto-fill-mode'まで完全に補完します。
補完を行えるミニバッファ内では、SPCはコマンド
`minibuffer-complete-word'を実行します。

補完候補一覧を表示しているウィンドウから補完を選ぶには、つぎのコマンド
を使えます。

`Mouse-2'
     補完候補一覧の候補上でマウスボタン2をクリックすると、その補完を選
     択する（`mouse-choose-completion'）。通常は、ポイントがミニバッファ
     内にあるときにこのコマンドを使うだろうが、ミニバッファではなく候
     補一覧でクリックする必要がある。

`PRIOR'
`M-v'
     ミニバッファで、PRIOR、PAGE-UP、`M-v'のいずれかを打つと、補完候補
     一覧のバッファを表示しているウィンドウを選択できる
     （`switch-to-completions'）。この機能は、以下のコマンドの利用を簡
     単にする。（通常の方法でもそのウィンドウを選択できるが、この方法
     のほうが便利であろう。）

`RET'
     *補完候補一覧のバッファで*RETを打つと、ポイント位置にある補完かポ
     イントに続く補完を選択する（`choose-completion'）。このコマンドを
     使う場合、補完候補一覧を表示しているウィンドウにまず移動する必要
     がある。

`RIGHT'
     *補完候補一覧のバッファで*右向き矢印キーRIGHTを打つと、ポイントは
     つぎの補完候補に移動する（`next-completion'）。

`LEFT'
     *補完候補一覧のバッファで*左向き矢印キーLEFTを打つと、ポイントは
     まえの補完候補に移動する（`previous-completion'）。



File: emacs-ja.info, Node: Strict Completion, Next: Completion Options, Prev: Completion Commands, Up: Completion

強い補完
--------

ミニバッファでの補完において、RETは引数の使われ方に依存して3種類の異な
る動作を示します。

   * "強い"補完（strict completion）は、既知の補完候補以外を引数に与え
     ると意味がない場合に使われる。たとえば、`C-x k'が削除するバッファ
     名を読み取るとき、既存のバッファ名以外を与えても意味がない。強い
     補完では、ミニバッファのテキストを補完して候補の1つに完全に一致し
     ないとRETで終了できない。

   * "慎重な"補完（cautious completion）は、強い補完に似ているが、テキ
     ストがすでに完全に一致していて補完の必要がない場合にのみ、RETで終
     了できる点が異なる。テキストが完全に一致していない場合は、RETは終
     了せずにテキストを補完する。完全に一致すれば、2度目のRETで終了で
     きる。

     慎重な補完は、既存でなければならないファイルの名前を読み取るよう
     な場合に使われる。

   * "弱い"補完（permissive completion）は、どんな文字列でも意味を持つ
     ような場合に使われ、補完候補一覧は単なる目安でしかない。たとえば、
     `C-x C-f'が訪問するファイル名を読み取るとき、新規作成ならばどんな
     ファイル名でも許される。弱い補完では、RETはミニバッファのテキスト
     を補完することなく、そのまま受理する。

補完コマンドは、つぎにくる文字として複数の可能性がある場合、補完可能な
全候補一覧をウィンドウに表示します。また、`?'と打てば、このような一覧
を表示できます。補完候補一覧が長いときには、`C-M-v'でスクロールできま
す（*Note Other Window::）。



File: emacs-ja.info, Node: Completion Options, Prev: Strict Completion, Up: Completion

補完のオプション
----------------

ファイル名の補完を行う場面では、ある種のファイル名を通常無視します。変
数`completion-ignored-extensions'は、文字列のリストを保持します。これ
らの文字列の1つで終る名前のファイルは、補完候補としては無視します。こ
の変数の標準値には、`".o"'、`".elc"'、`".dvi"'、`"~"'が含まれます。こ
の効果は、たとえば、`foo'は、`foo.o'が存在したとしても、`foo.c'に補完
されます。ただし、補完候補の*すべて*が無視すべき文字列で終るものである
場合には、これらの候補を無視しません。無視した拡張子を持つものが補完候
補一覧に入ることはありません。一覧にはつねに補完可能な候補のすべてを表
示します。

通常、補完コマンドは、つぎにくる文字を自動的に決定できない場合には、す
べての補完候補一覧を表示します。変数`completion-auto-help'に`nil'が設
定されていると、一覧を表示しません。補完候補を表示するには、`?'を打つ
必要があります。

`complete'ライブラリは、一度に複数の単語を補完できる、より強力な補完機
能を提供します。たとえば、`p-b'と省略されたコマンド名を`print-buffer'
と補完できます。というのは、頭文字が`p'と`b'である2つの単語で始まるコ
マンドが他にはないからです。このライブラリを使うには、個人の`~/.emacs'
ファイルに`(load "complete")'を入れておきます（*Note Init File::）。

補完示唆（icomplete）モードでは、それまでに入力したテキストから補完で
きるものを常時更新して表示します。このマイナモードをオン／オフするコマ
ンドは`M-x icomplete-mode'です。



File: emacs-ja.info, Node: Minibuffer History, Next: Repetition, Prev: Completion, Up: Minibuffer

ミニバッファ履歴
================

ミニバッファで入力した引数はすべて"ミニバッファ履歴リスト" 
（minibuffer history list）に保存され、あとで別の引数中で使うことがで
きます。特別のコマンドで、以前に使った引数のテキストをミニバッファに入
れます。これらは、ミニバッファの古い内容を破棄するので、過去の引数の履
歴の中を動き廻っていると考えることができます。

`UP'
`M-p'
     ミニバッファ履歴中の1つまえ（古い）の引数文字列に移動する
     （`previous-history-element'）。
`DOWN'
`M-n'
     ミニバッファ履歴中の1つつぎ（新しい）の引数文字列に移動する
     （`next-history-element'）。
`M-r REGEXP RET'
     ミニバッファ履歴中の引数文字列を古いほうへ遡ってREGEXPに一致する
     ものに移動する（`previous-matching-history-element'）。
`M-s REGEXP RET'
     ミニバッファ履歴中の引数文字列を新しいほうへ辿ってREGEXPに一致す
     るものに移動する（`next-matching-history-element'）。

履歴リストに保存されている引数を再利用するもっとも簡単な方法は、履歴リ
ストの中を1つ1つ移動していくことです。ミニバッファの中では、1つまえ
（古い）のミニバッファの入力内容に『移動する』には`M-p'
（`previous-history-element'）を、1つあと（新しい）の入力内容に移動す
るには`M-n'（`next-history-element'）を打ちます。

ミニバッファの内容は、履歴から持ってきた以前の入力内容で完全に置き換え
られます。この内容を引数として使うには、通常と同じようにRETでミニバッ
ファを抜けます。引数として再使用するまえに、テキストを編集してもかまい
ません。編集してもミニバッファに『持ってきた』履歴のもともとの要素は変
更されません。ただし、当然、新しい引数は履歴リストの最後に追加されます。

多くのミニバッファ引数には、デフォルト値があります。ミニバッファ履歴操
作コマンドが、これらのデフォルト値を知っている場合もあります。その場合、
`M-n'で履歴中の『未来』へ移動する (1) (*Note Minibuffer
History-Footnotes::) ことで、このデフォルト値をテキストとしてミニバッ
ファに挿入できます。将来的には、ミニバッファにデフォルト値がある場合に
は、つねにこの機能を利用できるようにしたいと考えています。

履歴の中を前向きや後向きに探索するコマンドもあります。これらのコマンド
は、ミニバッファで指定した正規表現に一致する履歴要素を探索します。
`M-r'（`previous-matching-history-element'）は、履歴のより古い要素を探
します。一方、`M-s'（`next-matching-history-element'）は、より新しい要
素を探します。特例なのですが、これらのコマンドは、コマンドを呼び出す時
点ですでにミニバッファに入っているにも関わらず、ミニバッファから引数を
読み取ります。インクリメンタルサーチの場合と同様に、正規表現に大文字を
使うと、大文字小文字を区別して探索します（*Note Search Case::）。


ミニバッファを使えば入力は必ず履歴リストに記録されますが、引数の種類ご
とに別々の履歴リストがあります。たとえば、ファイル名に関する履歴リスト
は、ファイル名を読み取るすべてのコマンドで使われます。（特別な機能とし
て、この履歴リストには、絶対ファイル名を入力しなくても絶対ファイル名が
記録される。）

特定目的用の履歴リストがいくつかあります。`M-x'が読むコマンド名用、バッ
ファ名用、`query-replace'のようなコマンドの引数用、`compile'が読むコン
パイルコマンド用などです。さらに、ほとんどのミニバッファ引数が利用する
『その他』の履歴リストも1つあります。

変数`history-length'は、ミニバッファ履歴リストの最大長を指定します。履
歴リストが設定された長さに達すると、そのあとは、新しい要素を追加するた
びに最古の要素を削除します。ただし、変数`history-length'の値が`t'であ
ると、長さの制限はなくなり要素を削除しません。


File: emacs-ja.info  Node: Minibuffer History-Footnotes, Up: Minibuffer History

(1) 【訳注】履歴として残っている文字列データの最後尾よりさらに先に移動
すること。



File: emacs-ja.info, Node: Repetition, Prev: Minibuffer History, Up: Minibuffer

ミニバッファコマンドの繰り返し
==============================

ミニバッファを少なくとも1回使ったコマンドは、その引数の値とともにすべ
て特別な履歴リストに記録されますから、コマンド全体を繰り返すことができ
ます。特に、`M-x'はコマンド名を読み取るためにミニバッファを使うので、
必ず履歴に記録されます。

`C-x ESC ESC'
     最近のミニバッファコマンドを再実行する（`repeat-complex-command'）。
`M-x list-command-history'
     `C-x ESC ESC'で繰り返せるすべてのコマンドを新しいものから順に並べ
     たコマンド履歴全体を表示する。

`C-x ESC ESC'は、ミニバッファを利用した最近のコマンドを再度実行します。
引数を指定しなければ、そのような最後のコマンドを繰り返します。数引数は、
どのコマンドを繰り返すかを指定します。1は最後のコマンドを指し、大きい
数ほどより以前のコマンドを指します。

`C-x ESC ESC'は、過去のコマンドをLisp式に変換し、その式のテキストで初
期化したミニバッファに入ります。RETだけを打てば、コマンドは以前とまっ
たく同様に繰り返されます。Lisp式を編集してコマンドを変更してもかまいま
せん。最終的な式が何であれ、その式を実行します。繰り返したコマンドは、
履歴リスト内に既存の最後に実行したコマンドと同一でない限り、コマンド履
歴の先頭に追加されます。

Lisp構文が理解できないとしても、繰り返しのためにどのコマンドが表示され
たか、たぶんわかるでしょう。テキストを変更しなければ、以前とまったく同
じに繰り返されます。

`C-x ESC ESC'でいったんミニバッファに入ってしまえば、ミニバッファ履歴
リストコマンド（`M-p'、`M-n'、`M-r'、`M-s'、*Note Minibuffer History::）
を使って、保存されたすべてのコマンドの履歴リストの中を動き廻れます。目
的のコマンドを捜しあてたら、通常の方法でその式を編集できますし、これも
通常と同じようにRETを打てば実行できます。

ミニバッファを使った過去のコマンド一覧は、Lispのリストとして変数
`command-history'に格納されます。各要素はそれぞれ1つのコマンドとその引
数を表すLisp式です。Lispプログラムからは、`command-history'の要素を引
数として`eval'を呼べばコマンドを再実行できます。


File: emacs-ja.info, Node: M-x, Next: Help, Prev: Minibuffer, Up: Top

名前でコマンドを実行する方法
****************************

使用頻度の高いコマンドや素早い打鍵が必要なEmacsコマンドは、使い勝手を
よくするために、キー（文字の短い列）にバインドしてあります。短縮する必
要のないその他のEmacsコマンドはキーにバインドしてありません。これらの
コマンドを実行するには、コマンド名を使う必要があります。

慣習として、コマンド名は1単語かハイフンで区切った2語以上の単語です。た
とえば、`auto-fill-mode'や`manual-entry'です。たとえ打鍵文字数が多くなっ
たとしても、（意図が）不明瞭な文字数個をキーとして使うよりも、英単語を
コマンド名として使うほうが覚えやすいのです。

コマンドをその名前で実行するには、`M-x'で始めて、コマンド名を打ち込み、
RETで終えます。`M-x'は、コマンド名を読むためにミニバッファを使います。
RETキーはミニバッファを抜けてコマンドを実行します。このとき、"プロンプ
ト"として文字列`M-x'をミニバッファの先頭に表示して、実行するコマンド名
を入力しなければならないことをユーザーに示します。ミニバッファの詳細に
ついては、*Note Minibuffer::。

コマンド名の入力には、補完を使えます。たとえば、つぎのように打って、コ
マンド`forward-char'を起動できます。

     M-x forward-char RET

あるいは、

     M-x forw TAB c RET

とします。ここで、`forward-char'は、`C-f'キーで起動されるコマンドと同
じです。コマンドがキーにバインドしてあるかどうかに関わらず、`M-x'です
べてのEmacsコマンドを名前で起動できます。

コマンド名を入力中に`C-g'を打つと、`M-x'コマンドを取り消してミニバッファ
から抜け出し、最終的にはトップレベルに戻ります。

`M-x'で起動するコマンドに数引数を渡すには、`M-x'を打つまえに、数引数を
指定します。`M-x'は、実行する関数に引数を渡します。引数の値は、コマン
ド名を読み込んでいるあいだ、プロンプトに表示されます。

入力したコマンドに専用のキーバインドがある場合には、Emacsはその旨エコー
領域に表示します。この表示は、コマンドの実行が終了したあと、2秒間表示
されます（すぐに何かを打てば、この限りではない）。たとえば、コマンド
`M-x forward-word'を入力した場合、`M-f'と打ったほうが簡単に同じコマン
ドを実行できるという意味のメッセージが表示されます。
`suggest-key-bindings'に`nil'を設定すれば、これらのメッセージ表示をオ
フにできます。

本書では、名前で実行するコマンドの説明において、名前を終えるために必要
なRETを省略します。つまり、`M-x auto-fill-mode RET'ではなく、`M-x
auto-fill-mode'とします。コマンド名に続く引数も示す場合のように、RETが
必要なことを強調する場合にのみ、RETを書きます。

`M-x'は、`execute-extended-command'を実行することで動作します。
`execute-extended-command'は、他のコマンドの名前を読み取って、それを実
行する役割を担うコマンドです。


File: emacs-ja.info, Node: Help, Next: Mark, Prev: M-x, Up: Top

ヘルプ機能
**********

Emacsには、`C-h'のたった1文字で呼び出せる高度なヘルプ機能があります。
`C-h'は、説明文表示コマンドのためだけに使われるプレフィックスキーです。
`C-h'のあとに打つ文字（列）を"ヘルプオプション"（help options）と呼び
ます。`C-h'もヘルプオプションの1つであって、`C-h'の使い方を調べること
ができます。途中で取り消すには、`C-g'を打ちます。ファンクションキーF1
は、`C-h'と等価です。

`C-h C-h'（`help-for-help'）は、利用可能なヘルプオプションの一覧を簡素
な説明とともに表示します。ヘルプオプションを打つまでは、SPCやDELで一覧
をスクロールできます。

`C-h'やF1は、他のさまざまな状況でも『ヘルプ』を意味します。たとえば、
`query-replace'の実行中には、今一致している文字列に対して適用可能な操
作を説明します。プレフィックスキーに続けて`C-h'やF1を打つと、そのプレ
フィックスキーに続けることができるキーの一覧を表示します。（`C-h'に独
自の意味を定義しているプレフィックスキーもあり、そのような場合には
`C-h'を使えない。しかし、F1はすべてのプレフィックスキーで使える。）

ほとんどのヘルプバッファでは、特別なメジャーモードであるヘルプ（help）
モードを使います。ヘルプ（help）モードでは、SPCとDELで画面を簡単にスク
ロールできます。

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in Emacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Help Mode::           Special features of Help mode and Help buffers.
* Misc Help::		Other help commands.



File: emacs-ja.info, Node: Help Summary, Next: Key Help, Up: Help

ヘルプのまとめ
==============

定義されているヘルプコマンドを以下にまとめておきます。

`C-h a REGEXP RET'
     正規表現REGEXPに一致する名前を持つコマンドの一覧を表示する
     （`apropos-command'）。
`C-h b'
     現在有効なすべてのキーバインドの一覧を、マイナモードのバインディ
     ング、メジャーモードのバインディング、グローバルバインディングの
     順に表示する（`describe-bindings'）。
`C-h c KEY'
     KEYが実行するコマンドの名前を表示する（`describe-key-briefly'）。
     ここで、`c'は『character』（文字）のcのこと。KEYのさらに詳しい情
     報を得るには、`C-h k'を使う。
`C-h f FUNCTION RET'
     Lisp関数FUNCTIONの説明文を表示する（`describe-function'）。コマン
     ドはLisp関数なので、コマンド名も使える。
`C-h h'
     さまざまな文字集合の例文を例示する`hello'ファイルを表示する。
`C-h i'
     ドキュメントファイルを閲覧するプログラム、infoを起動する（`info'）。
     infoでは、完全なEmacsマニュアルをオンラインで見ることができる。
`C-h k KEY'
     KEYが実行するコマンドの名前と説明文を表示する（`describe-key'）。
`C-h l'
     これまでに打鍵した最後の100文字を表示する（`view-lossage'）。
`C-h m'
     現在のメジャーモードの説明文を表示する（`describe-mode'）。
`C-h n'
     Emacsの変更点に関する説明を最新のものから順に表示する
     （`view-emacs-news'）。
`C-h p'
     トピックのキーワードで、一致するパッケージを探す
     （`finder-by-keyword'）。
`C-h s'
     現在の構文テーブルとその意味の説明を表示する（`describe-syntax'）。
     *Note Syntax::。
`C-h t'
     Emacsの対話型のチュートリアルに入る（`help-with-tutorial'）。
`C-h v VAR RET'
     Lisp変数VARの説明文を表示する（`describe-variable'）。
`C-h w COMMAND RET'
     コマンドCOMMANDを実行するキーを表示する（`where-is'）。
`C-h C CODING RET'
     コーディングシステムCODINGを説明する（`describe-coding-system'）。
`C-h C RET'
     現在使用中のコーディングシステムを説明する。
`C-h I METHOD RET'
     入力方式を説明する（`describe-input-method'）。
`C-h L LANGUAGE-ENV RET'
     言語環境LANGUAGE-ENVにおいて使われる、文字集合、コーディングシス
     テム、入力方式を説明する（`describe-language-environment'）。
`C-h C-c'
     GNU Emacsのコピーライトを表示する。
`C-h C-d'
     GNU Emacsの新版の入手方法に関する情報を表示する。
`C-h C-f FUNCTION RET'
     infoに入って、Emacsの関数FUNCTIONを説明しているノードに移動する
     （`Info-goto-emacs-command-node'）。
`C-h C-k KEY'
     infoに入って、キー列KEYを説明しているノードに移動する
     （`Info-goto-emacs-key-command-node'）。
`C-h C-p'
     GNUプロジェクトに関する情報を表示する。
`C-h TAB SYMBOL RET'
     編集中のプログラム言語に応じて、シンボルSYMBOLに関するinfoドキュ
     メントを表示する（`info-lookup-symbol'）。



File: emacs-ja.info, Node: Key Help, Next: Name Help, Prev: Help Summary, Up: Help

キーに関する説明
================

`C-h'のもっとも基本的なオプションは、
`C-h c'（`describe-key-briefly'）と
`C-h k'（`describe-key'）です。
`C-h c KEY'は、
KEYにバインドしてあるコマンド名をエコー領域に表示します。
たとえば、`C-h c C-f'と打てば`forward-char'と表示されます。
コマンド名はそのコマンドが何をするかを表すように選んでありますから、
キーKEYが何をするかをちょっと調べたい場合に、よい方法です。

`C-h k KEY'も同様ですが、より多くの情報を表示します。つまり、コマンド
の名前だけでなく、説明文も表示します。その内容はエコー領域に表示するに
は多すぎるため、ウィンドウに表示します。

`C-h c'や`C-h k'は、ファンクションキーやマウスイベントも含めた、あらゆ
るキー列に適用できます。



File: emacs-ja.info, Node: Name Help, Next: Apropos, Prev: Key Help, Up: Help

コマンド名や変数名によるヘルプ表示
==================================

`C-h f'（`describe-function'）は、ミニバッファでLisp関数の名前を読み取
り、その関数の説明文字列をウィンドウに表示します。コマンドはLisp関数で
すから、名前を知っているコマンドであれば、その説明文を得ることができま
す。たとえば、

     C-h f auto-fill-mode RET

とすると、`auto-fill-mode'の説明文字列を表示できます。どのキーにもバイ
ンドしていない（つまり、通常`M-x'で起動する）コマンドの説明文字列を見
るには、この方法しかありません。

`C-h f'はまた、Lispプログラムの中で使おうと考えているLisp関数に対して
も有益です。たとえば、式`(make-vector len)'を書いたとしましょう。
`make-vector'を正しく使っているかどうか調べたいときには、`C-h f
make-vector RET'と打ちます。`C-h f'は、コマンド名だけでなく、すべての
関数名に適用できるので、普段`M-x'で使えている省略形が`C-h f'では使えな
いかもしれません。ある省略形がコマンド名としては一意であったとしても、
他の関数名を含めてみると一意ではない場合もあります。

ミニバッファでRETだけを打ってミニバッファが空の場合、`C-h f'に与えられ
る関数名にはデフォルト値があります。デフォルト値は、バッファ内のポイン
ト周辺でもっとも内側のLisp式で呼び出される関数ですが、それが定義された
正しいLisp関数の名前である場合に*限ります*。たとえば、`(make-vector
(car x)'というテキストの直後にポイントがあると、ポイントを含むもっとも
内側のリストは`(make-vector'から始まる部分なので、デフォルトは関数
`make-vector'です。

`C-h f'は、関数名の綴りが正しことを単に確認するためだけにも役立ちます。
`C-h f'がバッファ内の名前をデフォルトとして表示すれば、その名前はLisp
関数として定義されているはずです。これだけを確認したいのであれば、
`C-g'を打って`C-h f'コマンドを取り消して、編集を続けます。

`C-h w COMMAND RET'は、どのキーをCOMMANDにバインドしてあるかを表示しま
す。キーの一覧をエコー領域に表示します。どのキーにも割り当てられていな
いと表示された場合は、そのコマンドは`M-x'で起動する必要があります。
`C-h w'はコマンド`where-is'を実行します。

`C-h v'（`describe-variable'）は`C-h f'に似ていますが、Lisp関数ではな
くLisp変数を説明する点が異なります。デフォルトはポイント周辺またはポイ
ントの直前のLispシンボルですが、既知のLisp変数に限ります。*Note
Variables::。



