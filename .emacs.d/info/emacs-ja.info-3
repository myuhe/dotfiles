Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Apropos, Next: Library Keywords, Prev: Name Help, Up: Help

アプロポス
==========

より洗練された質問方法としては、『ファイルを扱うコマンドは？』というの
があります。このように質問するには、`C-h a file RET'と打ちます。すると、
`copy-file'や`find-file'といった、`file'を名前に含むすべてのコマンドの
一覧が表示されます。各コマンドには、使い方の簡単な説明やそのコマンドを
起動するキーが表示されます。たとえば、`find-file'を起動するには`C-x
C-f'と打つ、といった具合です。`C-h a'の`a'は「Apropos」（「適切な」の
意味）を表していて、`C-h a'はコマンド`apropos-command'を実行します。こ
のコマンドは、通常、コマンド（対話的な関数）のみを調べます。前置引数を
指定すれば、非対話的な関数も調べます。

`C-h a'は指定した文字列を名前に含む関数しか調べませんので、文字列の指
定には工夫が必要です。後向きに文字をキルするコマンドを探そうとして、
`C-h a kill-backwards RET'で何も表示されなくてもあきらめないでください。
`kill'のみ、あるいは`backwards'のみ、もしくは`back'のみを試して、続け
てください。柔軟性を増すために、引数として正規表現も使えます（*Note
Regexps::）。

以下に、`C-h a'に指定する引数のうち、Emacsコマンドの多くの種類を網羅す
るものをあげておきます。というのは、Emacsコマンドの標準の命名法には強
い慣行があるからです。命名法の慣行を理解してもらえば、適切な
（`apropos'）文字列を拾い出す技法の向上の手助けにもなるでしょう。

     char、line、word、sentence、paragraph、region、page、sexp、list、
     defun、rect、buffer、frame、window、face、file、dir、register、
     mode、beginning、end、forward、backward、next、previous、up、down、
     search、goto、kill、delete、mark、insert、yank、fill、indent、
     case、change、set、what、list、find、view、describe、default。

正規表現に一致するすべてのユーザー変数を表示するには、コマンド`M-x
apropos-variable'を使います。このコマンドは、デフォルトでは、ユーザー
変数とカスタマイズオプションだけを表示します。すべての変数を調べるには、
前置引数を指定します。

コマンドとして定義されているものだけでなく、正規表現に一致するすべての
Lispシンボルを表示するには、`C-h a'のかわりに`M-x apropos'を使います。
このコマンドは、デフォルトでは、キーバインドを調べません。キーバインド
を調べるには、前置引数を指定します。

`apropos-documentation'コマンドは`apropos'に似ていますが、指定した正規
表現に一致するシンボル名だけでなく、説明文字列も探索する点が異なります。

`apropos-value'コマンドは`apropos'に似ていますが、指定した正規表現に一
致するシンボルの値を探す点が異なります。このコマンドは、デフォルトでは、
関数定義や属性リストを調べません。それらも調べるには、前置引数を指定し
ます。

変数`apropos-do-all'が`nil'以外ならば、上に述べたコマンドはすべて、前
置引数を指定したものとして動作します。

アプロポス（apropos）バッファに表示された関数定義、変数、属性リストに
ついて詳しく知りたいときには、`Mouse-2'ボタンでクリックするか、その箇
所へ移動してRETを打ちます。



File: emacs-ja.info, Node: Library Keywords, Next: Language Help, Prev: Apropos, Up: Help

Lispライブラリに対するキーワード探索
====================================

`C-h p'コマンドで、標準Emacs Lispライブラリをトピックのキーワードで検
索できます。利用可能なキーワードの一部を以下に示します。

     abbrev -- 略語操作、短縮入力、マクロ。
     bib -- 参考、参照プロセッサ支援`bib'。
     c -- C言語あるいはC++支援。
     calendar -- 日付および時間管理支援。
     comm -- 通信、ネットワーク、ファイルのリモートアクセス。
     data -- データファイルの編集支援。
     docs -- Emacsドキュメントに関する支援。
     emulations -- 他のエディタのエミュレーション。
     extensions -- Emacs Lisp言語の拡張。
     faces -- フェイス（フォントや表示色、*Note Faces::）に関する支援。
     frames -- Emacsフレームやウィンドウシステムに対する支援。
     games -- ゲーム、ジョーク、娯楽。
     hardware -- 外部ハードウェアとのインターフェイス支援。
     help -- オンラインヘルプシステム支援。
     hypermedia -- テキストあるいは他メディア内でのリンク支援。
     i18n -- 国際化、代替文字集合支援。
     internal -- Emacs内部コード、構築手順、デフォルト。
     languages -- プログラム言語編集用の特殊モード。
     lisp -- Lisp利用支援（Emacs Lispも含む）。
     local -- サイトにローカルなライブラリ。
     maint -- Emacs開発グループ向けの管理用。
     mail -- 電子メイル操作用のモード。
     matching -- 探索、一致。
     news -- ネットニュースの購読、投稿支援。
     non-text -- 非テキストファイル編集支援。
     oop -- オブジェクト指向プログラミング支援。
     outlines -- 階層アウトライン。
     processes -- プロセス、サブシェル、コンパイル、ジョブ制御支援。
     terminals -- 端末タイプ支援。
     tex -- TeXによる文書整形支援。
     tools -- プログラミングツール。
     unix -- UNIX機能のフロントエンド／アシスタントあるいはエミュレーション。
     vms -- VMS支援コード。
     wp -- ワープロ。



File: emacs-ja.info, Node: Language Help, Next: Help Mode, Prev: Library Keywords, Up: Help

多言語支援に関するヘルプ
========================

コマンド`C-h L'（`describe-language-environment'）を使うと、特定の言語
環境向けに、どのような支援があるかを把握できます。*Note Language
Environments::。このコマンドは、今の言語環境がどの言語向けなのかを示し、
一緒に使われる文字集合、コーディングシステム、入力方式も表示します。ま
た、字体を例示するためのサンプルテキストもいくつか表示します。

コマンド`C-h h'（`view-hello-file'）は、ファイル`etc/HELLO'を表示しま
す。このファイルには、いろいろな国の言葉で書いた『hello』を収めてあり
ます。

コマンド`C-h I'（`describe-input-method'）は、指定した入力方式、あるい
は、デフォルトとして今使っている入力方式についての情報を表示します。
*Note Input Methods::。

コマンド`C-h C'（`describe-coding-system'）は、指定したコーディングシ
ステム、あるいは、デフォルトとして今使っているコーディングシステムにつ
いての情報を表示します。*Note Coding Systems::。



File: emacs-ja.info, Node: Help Mode, Next: Misc Help, Prev: Language Help, Up: Help

ヘルプモードのコマンド
======================

ヘルプバッファには、閲覧（view）モード（*Note Misc File Ops::）のコマ
ンドに加えて、独自の特別なコマンドもいくつかあります。

`SPC'
     前向きにスクロールする。
`DEL'
     後向きにスクロールする。
`RET'
     ポイント位置の相互参照を辿る。
`TAB'
     つぎの相互参照へ進む。
`S-TAB'
     まえの相互参照へ戻る。
`Mouse-2'
     クリックした相互参照を辿る。

説明文に現れるコマンド名（*Note M-x::）や変数名（*Note Variables::）は
通常、引用符（`''）で囲まれています。その名前を`Mouse-2'でクリックした
り、あるいは、そこへポイントを移動してRETを打つと、そのコマンドや変数
の説明文字列を表示できます。もとの場所に戻るには`C-c C-b'を使います。

ヘルプテキスト内の相互参照にポイントを移動する便利なコマンドがあります。
TAB（`help-next-ref'）は、ポイントをつぎの相互参照箇所へ進めます。ポイ
ントをまえの相互参照箇所へ戻すには`S-TAB'（`help-previous-ref'）を使い
ます。



File: emacs-ja.info, Node: Misc Help, Prev: Help Mode, Up: Help

その他のヘルプコマンド
======================

`C-h i'（`info'）はinfoプログラムを実行します。infoは構造化されたドキュ
メントファイルを閲覧するプログラムです。Emacsの完全なマニュアルもinfo
で読むことができます。将来的には、GNUシステムのすべてのドキュメントが
読めるようになるでしょう。infoの使い方についてのチュートリアルを起動す
るには、infoに入ってから`h'と打ちます。

数引数を指定すると、`C-h i'はドキュメントファイルの名前を聞いてきます。
こうすれば、トップレベルのinfoメニューに記載されていないファイルでも閲
覧できます。

infoを介してEmacsドキュメントを参照するための特別なヘルプコマンドが2つ
あります。`C-h C-f FUNCTION RET'は、infoに入ってただちにEmacsの関数
FUNCTIONのドキュメントに移動します。`C-h C-k KEY'は、infoに入ってただ
ちにキーKEYのドキュメントに移動します。これら2つのキーは、それぞれ、
`Info-goto-emacs-command-node'、`Info-goto-emacs-key-command-node'を実
行します。

プログラム言語のinfo版のマニュアルがあれば、プログラムの編集中にコマン
ド`C-h C-i'を使って、マニュアルドキュメントのシンボル（キーワード、関
数、変数）に関する箇所を参照できます。コマンドの細かい動作は、メジャー
モードに依存します。

予期しなかったことが起きたり、入力したコマンドがわからなくなってしまっ
たときは、`C-h l'（`view-lossage'）を使ってください。`C-h l'は、それま
でに打鍵した最後の100個のコマンド文字を表示します。知らないコマンドが
表示されたら、`C-h c'でその機能を知ることができます。

Emacsには数多くのメジャーモードがあり、各メジャーモードでは、いくつか
のキーを再定義し、編集動作も少々変更しています。`C-h m'
（`describe-mode'）は、使用中のメジャーモードについての説明文を表示し
ます。これには、通常、モード内で変更してあるすべてのコマンドについての
記述があります。

`C-h b'（`describe-bindings'）と`C-h s'（`describe-syntax'）は、Emacs
の現在のモードに関するその他の情報を与えてくれます。`C-h b'は、現在有
効なすべてのキーバインドの一覧を表示します。マイナモードで定義されてい
るローカルバインディングから始めて、現在のメジャーモードで定義されてい
るローカルバインディング、最後にグローバルバインディングを表示します
（*Note Key Bindings::）。`C-h s'は、各文字の構文の説明を付けて構文テー
ブルの内容を表示します（*Note Syntax::）。

プレフィックスキーに続けて`C-h'を打てば、特定のプレフィックスキーにつ
いて同様な一覧を表示できます。（この方法では表示できないプレフィックス
キーも存在する。それらのキーでは、`C-h'に対しては独自のバインディング
がある。ESCは、そのようなものの1つ。`ESC C-h'は、実際には`C-M-h'であり、
関数定義（defun）をマークする。）

`C-h'の他のオプションは、有益な情報を収めたさまざまなファイルを表示し
ます。`C-h C-w'は、GNU Emacsがまったく無保証であることに関する全詳細を
表示します。`C-h n'（`view-emacs-news'）は、ファイル`emacs/etc/NEWS'を
表示します。このファイルには、Emacsの変更に関する記述を時間順に収めて
あります。`C-h F'（`view-emacs-FAQ'）は、Emacsの「よくある質問集」を表
示します。`C-h t'（`help-with-tutorial'）は、「操作しながらEmacsを学ぶ」
チュートリアルを表示します。`C-h C-c'（`describe-copying'）は、ファイ
ル`emacs/etc/COPYING'を表示します。このファイルには、Emacsを配布する場
合に従うべき条件を記述してあります。`C-h C-d'（`describe-distribution'）
は、ファイル`emacs/etc/DISTRIB'を表示します。このファイルには、Emacsの
最新版の注文方法を述べてあります。`C-h C-p'（`describe-project'）は、
GNUプロジェクトに関する一般情報を表示します。


File: emacs-ja.info, Node: Mark, Next: Killing, Prev: Help, Up: Top

マークとリージョン
******************

Emacsの数多くのコマンドは、カレントバッファの任意の連続領域を操作しま
す。このようなコマンドに操作対象となるテキストを指定するには、その一方
の端に"マーク"（mark）を置き、もう一方の端にポイントを移動します。ポイ
ントとマークに挟まれたテキストを"リージョン"（region）と呼びます。暫定
マーク（transient-mark）モードをオンにすると、リージョンが存在すれば
Emacsはつねにそのリージョンを強調表示します（*Note Transient Mark::）。

リージョンの境界を調整するには、ポイントやマークを移動します。時間的に
どちらを先に設定したとか、テキスト内でどちらが先にあるかとかは関係あり
ません。いったんマークを設定すると、他の箇所に再設定するまで、その位置
情報はそのまま変わりません。各Emacsバッファには個別にマークがあります
から、以前に選択したバッファへ戻ったときには、以前と同じままのマークが
残っています。

`C-y'（`yank'）や`M-x insert-buffer'などのテキストを挿入するコマンドの
多くは、挿入したテキストの両端にポイントとマークを置いて、挿入したテキ
ストがリージョンに含まれるようにします。

リージョンの境界を定めること以外に、あとで戻る可能性のある箇所を覚えて
おくためにもマークを使えます。この機能をより使いやすくするために、各バッ
ファでは、それまでに設定した16個のマーク位置を"マークリング"（mark
ring）に記録しています。

* Menu:

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region--
			  when there is one.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.



File: emacs-ja.info, Node: Setting Mark, Next: Transient Mark, Up: Mark

マークを設定する
================

マークを設定するコマンドはつぎのとおりです。

`C-SPC'
     ポイント位置にマークを置く（`set-mark-command'）。
`C-@'
     上と同様。
`C-x C-x'
     マークとポイントを入れ換える（`exchange-point-and-mark'）。
`Drag-Mouse-1'
     ドラッグしたテキストの周囲にポイントとマークを設定する。
`Mouse-3'
     ポイント位置にマークを設定し、クリックした箇所にポイントを移動す
     る（`mouse-save-then-kill'）。

たとえば、コマンド`C-x C-u'（`upcase-region'）を使って、バッファのある
部分をすべて大文字に変換したいとしましょう。このコマンドは、リージョン
中のテキストに作用します。まず、大文字に変換したいテキストの先頭に移動
し、`C-SPC'と打ってマークを設定します。続いてテキストの終端に移動して
`C-x C-u'と打ちます。あるいは、先にテキストの終端にマークを設定して、
テキストの始点に移動してから`C-x C-u'と打ちます。

マークを設定するもっとも一般的な方法は、`C-SPC'コマンド
（`set-mark-command'）を使うことです。このコマンドは、ポイント位置にマー
クを設定します。そうすれば、マークを置いたままで、ポイントを移動できま
す。

マウスを使ったマークの設定方法は2つあります。テキストのある範囲でマウ
スボタン1をドラッグします。マウスボタンを離した位置にポイントが置かれ、
ドラッグを開始した箇所にマークが設定されます。あるいは、マウスボタン3
をクリックします。これは（`C-SPC'と同様に）ポイント位置にマークを設定
してから、ポイントを（`Mouse-1'のように）移動します。両者は、マークを
設定するだけでなく、リージョンをキルリングにコピーします。これは、他の
ウィンドウアプリケーションの動作と一貫性を持たせるためです。キルリング
を変更したくなければ、キーボードコマンドを使ってマークを設定する必要が
あります。*Note Mouse Commands::。

普通の端末にはカーソルは1つしかありませんから、Emacsにはマークを置いた
位置を表示する術はありません。ユーザーがその位置を覚えておく必要があり
ます。この問題に対する通常の解決方法は、マークを設定したら、忘れてしま
うまえにただちにそれを利用することです。あるいは、`C-x C-x'
（`exchange-point-and-mark'）コマンドを使って、マーク位置を確認します。
このコマンドは、ポイント位置にマークを置き、マークのあった位置にポイン
トを置きます。リージョンの範囲は変わらずに、カーソルとポイントは以前マー
クのあった箇所に移動します。暫定マーク（transient-mark）モードでは、こ
のコマンドはマークを再度活性にします。

ポイント位置を変えずに、リージョンのもう一方の端（マークの位置）を移動
させたい場合にも、`C-x C-x'は便利な方法です。まず、`C-x C-x'でポイント
をリージョンの一方の端に移して、その端を移動します。必要ならば、もう1
度`C-x C-x'を使って新しい位置にマークを置き、ポイントをもとの位置に戻
します。

ASCIIには、`C-SPC'という文字は存在しません。CTRLを押し下げながらSPCを
打つと、ほとんどの普通の端末では文字`C-@'になります。このキーは、実際
に`set-mark-command'にバインドしてあります。ただし、幸運にも`C-SPC'で
`C-@'を送出する端末を使っているのであれば、`C-@'を`C-SPC'とみなしてか
まいません。Xウィンドウシステムでは、`C-SPC'は実際には別の文字として認
識されますが、そのバインドはやはり`set-mark-command'です。



File: emacs-ja.info, Node: Transient Mark, Next: Using Region, Prev: Setting Mark, Up: Mark

暫定マークモード（transient-markモード）
========================================

Xウィンドウシステムを使っているのであれば、Emacsはカレントリージョンを
強調表示できます。ただし、通常はリージョンを強調表示しません。なぜでしょ
うか？

実は、もともとのEmacsではリージョンの強調表示をうまくできないのです。
いったんマークを設定してしまうと、そのバッファ内には*つねに*リージョン
が存在することになるからです。リージョンを強調表示し続けても迷惑なだけ
でしょう。

暫定マーク（transient-mark）モードをオンにすると、リージョンの強調表示
機能をオンにできます。暫定マーク（transient-mark）モードは、リージョン
が一時的にしか『存続』しない、通常よりきびしい操作モードです。ユーザー
は、リージョンを使うコマンドごとにリージョンを設定する必要があります。
暫定マーク（transient-mark）モードでは、ほとんどの期間、リージョンは存
在しません。それゆえ、リージョンが存在するときにリージョンを強調表示し
ても邪魔になりません。

暫定マーク（transient-mark）モードをオンにするには、`M-x
transient-mark-mode'と打ちます。このコマンドはモードのオン／オフを切り
替えますから、モードをオフにしたいときにはコマンドをもう1度繰り返しま
す。

暫定マーク（transient-mark）モードの詳細を以下に示します。

   * マークを設定するには、`C-SPC'（`set-mark-command'）と打つ。この操
     作はマークを活性にする。ポイントを移動するたびに、強調表示された
     リージョンが広がったり狭まったりする。

   * マークを設定するマウスコマンドも、マークを活性にする。`M-@'、
     `C-M-@'、`M-h'、`C-M-h'、`C-x C-p'、`C-x h'などのリージョンを設定
     するためのキーボードコマンドもマークを活性にする。

   * マークが活性ならば、キル、字下げ、ファイルへの書き出しなどのリー
     ジョンを操作するコマンドを実行できる。

   * 文字の挿入や削除といったバッファに対する変更は、マークを不活性に
     する。つまり、これ以降にリージョンを操作するコマンドを実行すると
     エラーとなり、実行は拒否される。リージョンを再度活性にするには、
     `C-x C-x'と打つ。

   * `M->'や`C-s'のような、本来の目的を達成したあとに『マークを残す』
     種類のコマンドは、新しいマークを活性にしない。このような新しいリー
     ジョンを活性にするには、`C-x C-x'（`exchange-point-and-mark'）を
     実行する。

   * マークが活性であるときには、`C-s'はマークを変更しない。

   * `C-g'で中断すると、マークを不活性にする。

リージョンの強調表示には、`region'フェイスを使います。このフェイスを変
更すれば、リージョンの強調表示方法をカスタマイズできます。

複数のウィンドウで同じバッファを表示しているときには、それぞれのウィン
ドウで別の部分を表示できます。というのは、（マーク位置は共有されるが）
各ウィンドウごとに別々にポイントの値があるからです。通常、選択されたウィ
ンドウでのみ、リージョンを強調表示します（*Note Windows::）。しかし、
変数`highlight-nonselected-windows'に`nil'以外を設定すると、（暫定マー
ク（transient-mark）モードがオンであり、かつ、ウィンドウのバッファのマー
クが活性である場合に限り）各ウィンドウでそれぞれのリージョンを強調表示
します。

暫定マーク（transient-mark）モードがオフであると、マークを設定するすべ
てのコマンドはマークを活性にし、マークを不活性にするものは何もありませ
ん。

暫定マーク（transient-mark）モードにおいて、変数
`mark-even-if-inactive'が`nil'以外であると、マークが不活性であってもコ
マンドはマークやリージョンを利用できます。通常の暫定マーク
（transient-mark）モードと同様に、リージョンが強調表示されたりされなかっ
たりしますが、強調表示されていなくてもマークが本当になくなることはあり
ません。

暫定マーク（transient-mark）モードは『zmacsモード』としても知られてい
ます。というのも、MITのLispマシン上で動作していたZmacsエディタが同じよ
うにマークを扱っていたからです。



File: emacs-ja.info, Node: Using Region, Next: Marking Objects, Prev: Transient Mark, Up: Mark

リージョンに対する操作
======================

いったんリージョンを設定しマークを活性にすれば、以下のようにリージョン
を操作できます。

   * `C-w'コマンドでキルする（*Note Killing::）。
   * `C-x r s'でレジスタに保存する（*Note Registers::）。
   * バッファやファイルに保存する（*Note Accumulating Text::）。
   * `C-x C-l'や`C-x C-u'で大文字小文字を変換する（*Note Case::）。
   * `C-x TAB'や`C-M-\'で字下げする（*Note Indentation::）。
   * `M-x fill-region'でテキストを詰め込む（*Note Filling::）。
   * `M-x print-region'でハードコピーを印刷する（*Note Hardcopy::）。
   * `M-x eval-region'でLispコードとして評価する（*Note Lisp Eval::）。

リージョン内のテキストを操作するコマンドの多くは、その名前に`region'と
いう単語を含みます。



File: emacs-ja.info, Node: Marking Objects, Next: Mark Ring, Prev: Using Region, Up: Mark

テキストオブジェクトをマークするコマンド
========================================

単語、リスト、段落、ページといったテキストのまとまりにポイントやマーク
を置くコマンドがあります。

`M-@'
     つぎの語の末尾にマークを設定する（`mark-word'）。このコマンドとつ
     ぎのコマンドはポイントを移動しない。
`C-M-@'
     つぎのLisp式の末尾にマークを設定する（`mark-sexp'）。
`M-h'
     現在の段落を囲むリージョンを設定する（`mark-paragraph'）。
`C-M-h'
     現在のLisp関数定義（defun）を囲むリージョンを設定する
     （`mark-defun'）。
`C-x h'
     バッファ全体をリージョンとする（`mark-whole-buffer'）。
`C-x C-p'
     現在のページを囲むリージョンを設定する（`mark-page'）。

`M-@'（`mark-word'）がつぎの語の末尾にマークを設定するのに対し、
`C-M-@'（`mark-sexp'）はつぎのLisp式の末尾にマークを設定します。これら
のコマンドは、`M-f'や`C-M-f'と同様に引数を扱います。

その他のコマンドは、ポイントとマークの両方を設定して、バッファ内で対象
物を区切ります。たとえば、`M-h'（`mark-paragraph'）は、ポイントを囲む
あるいはポイントに続く段落の先頭にポイントを移動し、その段落の末尾にマー
クを置きます（*Note Paragraphs::）。このようにリージョンを設定するので、
段落全体を字下げしたり、大文字小文字を変換したり、キルしたりできます。

`C-M-h'（`mark-defun'）も同様に、現在の関数定義や後続の関数定義の先頭
にポイントを置き、その末尾にマークを置きます（*Note Defuns::）。`C-x
C-p'（`mark-page'）は、現在のページの先頭にポイントを置き、その末尾に
マークを置きます（`mark-page'）。マークはページ区切りの直後に設定され
（リージョンに含まれる）、一方、ポイントはページ区切りの直後に置かれま
す（リージョンに含まれない）。数引数で、現在のページのかわりに（正なら
ば）後続のページや、（負ならば）先行するページを指定できます。

最後に紹介する`C-x h'（`mark-whole-buffer'）は、バッファ全体にリージョ
ンを設定します。つまり、ポイントをバッファの先頭に置き、マークをバッファ
の末尾に置きます。

暫定マーク（transient-mark）モードでは、これらのコマンドはすべて、マー
クを活性にします。



File: emacs-ja.info, Node: Mark Ring, Next: Global Mark Ring, Prev: Marking Objects, Up: Mark

マークリング
============

マークには、リージョンを区切る以外にも、あとで戻る可能性のある箇所を記
録するという便利な使い方があります。この機能をより便利にするために、各
バッファでは以前の16箇所のマーク位置を"マークリング"（mark ring）に記
録しています。マークを設定するコマンドは、古いマークをこのマークリング
に入れます。マークを設定していた箇所に戻るには、`C-u C-SPC'（または
`C-u C-@'）を使います。これは、`set-mark-command'コマンドに数引数を指
定したものです。このコマンドは、マークがあった箇所にポイントを移動し、
それ以前のマークを収めたマークリングからマークを復元します。したがって、
このコマンドを繰り返すと、マークリング上にある過去のマークのすべてを1
つ1つ遡って移動できます。このように辿ったマーク位置は、マークリングの
うしろに付け加えられるので、なくなってしまうことはありません。

各バッファには独自のマークリングがあります。すべての編集コマンドは、カ
レントバッファのマークリングを使います。特に、`C-u C-SPC'は、つねに同
じバッファに留まります。

`M-<'（`beginning-of-buffer'）のような長距離を移動するコマンドの多くは、
まずマークを設定して、古いマークをマークリングに保存してから動作を開始
します。このようにして、あとで簡単に戻れるようにしておきます。探索コマ
ンドは、ポイントを移動するときにはマークを設定します。コマンドがマーク
を設定したかどうかは、エコー領域に`Mark Set'と表示されるのでわかります。

何度も同じ場所に戻りたい場合には、マークリングでは不十分でしょう。この
ような場合には、あとで使うために位置情報をレジスタに記録できます
（*Note RegPos::）。

変数`mark-ring-max'は、マークリングに保存する最大項目数を指定します。
すでに多くの項目が存在していて、さらにもう1つ押し込むときには、リスト
内の最古の項目を捨てます。`C-u C-SPC'を繰り返し実行すると、いまマーク
リングに入っている位置を巡回することになります。

変数`mark-ring'は、最新のマーカオブジェクトを先頭にして、マーカオブジェ
クトのリストとしてマークリングを保持します。この変数は各バッファにロー
カルです。



File: emacs-ja.info, Node: Global Mark Ring, Prev: Mark Ring, Up: Mark

グローバルマークリング
======================

個々のバッファごとの普通のマークリングに加えて、Emacsには"グローバルマー
クリング"（global mark ring）が1つあります。グローバルマークリングは、
最近マークを設定したバッファの系列を記録しますから、それらのバッファに
戻ることができます。

マークを設定すると、つねにカレントバッファのマークリングに項目を作りま
す。マークを設定した以降にバッファを切り替えていると、新しくマークを設
定するとグローバルマークリングにも項目を作成します。その結果、グローバ
ルマークリングには訪れていたバッファの系列が記録され、各バッファではマー
クを設定した箇所が記録されます。

コマンド`C-x C-SPC'（`pop-global-mark'）は、グローバルマークリングの最
新の項目が示すバッファの位置に移動します。グローバルマークリングも巡回
されるので、`C-x C-SPC'を繰り返し使用すると、1つずつまえのバッファに移
動できます。




File: emacs-ja.info, Node: Killing, Next: Yanking, Prev: Mark, Up: Top

削除とキル
==========

バッファからテキストを消しさるコマンドのほとんどは、そのテキストをキル
リングにコピーしておくので、バッファの他の部分にそのテキストを移動した
りコピーしたりできます。これらのコマンドを、"キル"（kill）コマンドと呼
びます。それ以外の『テキストを消すコマンド』は、テキストをキルリングに
保存しません。これらを"削除"（delete）コマンドと呼びます。（両者を区別
するのは、バッファ内のテキストを消す場合だけ。）キルコマンドや削除コマ
ンドを誤って実行してしまった場合には、`C-x u'（`undo'）コマンドを使っ
て、もとに戻すことができます。

削除コマンドには、一度に1つの文字だけを削除する`C-d'（`delete-char'）
やDEL（`delete-backward-char'）、空白や改行だけを削除するコマンドがあ
ります。単純ではないデータをかなりの分量で破壊する可能性のあるコマンド
は、一般にキルを行います。コマンド名や個々の説明では、そのコマンドがど
ちらの働きをするかによって、`キル'（kill）と`削除'（delete）を使い分け
ています。

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences. 



File: emacs-ja.info, Node: Deletion, Next: Killing by Lines, Up: Killing

削除
----

`C-d'
     つぎの文字を削除する（`delete-char'）。
`DEL'
     まえの文字を削除する（`delete-backward-char'）。
`M-\'
     ポイントの周りの空白とタブを削除する（`delete-horizontal-space'）。
`M-SPC'
     ポイントの周りの空白とタブを削除し、空白を1個だけ残す
     （`just-one-space'）。
`C-x C-o'
     現在行の周りの空行を削除する（`delete-blank-lines'）。
`M-^'
     行間の改行とそれに続く字下げを削除して2行を繋げる
     （`delete-indentation'）。

もっとも基本的な削除コマンドは、`C-d'（`delete-char'）とDEL
（`delete-backward-char'）です。`C-d'はポイントの直後の文字、つまり、
カーソルが重なっている文字を削除します。このコマンドでは、ポイントは動
きません。DELはカーソルの直前の文字を削除して、ポイントを1つまえに移動
します。バッファ内の他の文字と同様に、改行も削除できます。改行を削除す
ると、2つの行が繋がります。実際には、`C-d'とDELがつねに削除コマンドで
あるわけではありません。引数を指定するとキルコマンドとなり、同じ方法で
2文字以上を消すことができます。

他の削除コマンドは、空白、タブ、改行といった白文字だけを削除します。
`M-\'（`delete-horizontal-space'）は、ポイントの前後にあるすべての空白
とタブ文字を削除します。`M-SPC'（`just-one-space'）も同様に削除します
が、今ある空白の個数に関係なく（たとえ0個でも）、ポイントの直後に空白
を1個だけ残します。

`C-x C-o'（`delete-blank-lines'）は、現在行に続くすべての空行を削除し
ます。現在行が空行である場合には、（空行である現在行だけを残して）先行
する空行も同様にすべて削除します。

`M-^'（`delete-indentation'）は、改行とその周りの空白を削除して、通常
は空白を1個残して現在行と先行する行を繋げます。*Note M-^: Indentation。



File: emacs-ja.info, Node: Killing by Lines, Next: Other Kill Commands, Prev: Deletion, Up: Killing

行単位のキル
------------

`C-k'
     行の残りの部分、あるいは、行全体を1行以上キルする（`kill-line'）。

もっとも単純なキルコマンドは`C-k'です。行の先頭で使うと、その行のすべ
てのテキストをキルして、空行にします。空行で使うと、改行を含めてその行
を完全にキルします。空行でない行を完全にキルするには、行頭で`C-k'を2回
打ちます。

一般に、`C-k'は、行末でなければ、ポイントからその行の末尾までをキルし
ます。行末では、ポイントのうしろの改行をキルするので、現在行と後続の行
が繋がります。どちらの動作をするか決めるときには、行末にあって見にくい
空白やタブを無視しますから、ポイントが行末にあるように見えていれば、
`C-k'で改行がキルされると考えてください。

`C-k'に正の引数を指定すると、その個数の行とそれらに続く改行をキルしま
す（ただし、現在行のポイントよりまえのテキストは残す）。負の引数-Nを指
定すると、`C-k'は現在行に先行するN行（と現在行のポイント位置よりまえの
テキストを含めて）を削除します。つまり、ポイントが行頭にある状態で`C-u
- 2 C-k'とすれば、先行する2行をキルします。

`C-k'に引数0を指定すると、現在行のポイントよりまえのテキストをキルしま
す。

変数`kill-whole-line'が`nil'以外の場合、行頭で`C-k'を使うと、行末の改
行も含めて行全体をキルします。この変数は、通常、`nil'です。



File: emacs-ja.info, Node: Other Kill Commands, Prev: Killing by Lines, Up: Killing

他のキルコマンド
----------------

`C-w'
     リージョン（ポイントからマークまで）をキルする（`kill-region'）。
`M-d'
     単語をキルする（`kill-word'）。*Note Words::。
`M-DEL'
     単語を後向きにキルする（`backward-kill-word'）。
`C-x DEL'
     文の先頭までを後向きにキルする（`backward-kill-sentence'）。*Note
     Sentences::。
`M-k'
     文の末尾までをキルする（`kill-sentence'）。
`C-M-k'
     S式をキルする（`kill-sexp'）。*Note Lists::。
`M-z CHAR'
     つぎにCHARが現れる箇所までをキルする（`zap-to-char'）。

汎用的なキルコマンドといえば`C-w'（`kill-region'）です。このコマンドは、
あらかじめ連続領域をポイントとマークで囲んでおけば、どんな連続領域でも
キルできます。

探索と組み合わせた便利なキルの仕方もあります。`M-z'（`zap-to-char'）は
1文字を読み取り、ポイントからバッファ内でその文字がつぎに現れる箇所ま
でを（その文字も含めて）キルします。数引数を指定した場合は、反復回数を
意味します。負の引数の場合は、ポイント位置から逆方向に探索し、ポイント
の直前までをキルします。

他の構文単位でもキルできます。`M-DEL'や`M-d'（*Note Words::）で単語を、
`C-M-k'（*Note Lists::）でS式を、`C-x DEL'や`M-k'（*Note Sentences::）
で文をキルできます。

読み出し専用のバッファでもキルできます。実際にはバッファに変更を加える
ことはありませんし、ベルを鳴らしてその旨警告を発しますが、キルしようと
したテキストはキルリングにコピーされます。ですから、別のバッファにその
テキストをヤンクできます。ほとんどのキルコマンドは、このようにコピーす
るテキストを越えてポイントを進めますから、連続してキルコマンドを実行し
てもキルリングに入る項目は通常どおり1個だけです。



File: emacs-ja.info, Node: Yanking, Next: Accumulating Text, Prev: Killing, Up: Top

ヤンク
======

"ヤンク"（yank）とは、以前にキルしたテキストをバッファにふたたび挿入す
ることです。他のシステムでは『ペースト』と呼ぶこともあります。テキスト
を移動したりコピーしたりする普通の方法は、そのテキストをいったんキルし
てから、別の場所に（1回以上）ヤンクすることです。

`C-y'
     最後にキルしたテキストをヤンクする（`yank'）。
`M-y'
     たった今ヤンクしたテキストをそれより以前にキルした一塊のテキスト
     で置き換える（`yank-pop'）。
`M-w'
     リージョンを実際にはキルせずに、最後にキルしたテキストとして保存
     する（`kill-ring-save'）。
`C-M-w'
     つぎのキルを、最後にキルした一塊のテキストに付け加える
     （`append-next-kill'）。

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.



File: emacs-ja.info, Node: Kill Ring, Next: Appending Kills, Up: Yanking

キルリング
----------

すべてのキルされたテキストは、キルされたテキストの塊をリストとする"キ
ルリング"（kill ring）に記録されています。キルリングはたった1つしかな
くて、すべてのバッファで共有しています。ですから、あるバッファでキルし
たテキストは、別のバッファでヤンクできます。普通、このようにして、ある
ファイルから別のファイルへテキストを移動します。（別の方法については、
*Note Accumulating Text::。）

コマンド`C-y'（`yank'）は、最後にキルしたテキストをふたたび挿入します。
カーソルは挿入したテキストの末尾に置かれます。マークは挿入したテキスト
の先頭に置かれます。*Note Mark::。

`C-u C-y'は、テキストのまえにカーソルを置き、うしろにマークを置きます。
引数として`C-u'だけを指定した場合に限り、こうなります。`C-u'と数字を含
めた他の引数を指定すると、いくつまえのキル内容をヤンクするかを意味しま
す（*Note Earlier Kills::）。

一塊のテキストをコピーする場合は、`M-w'（`kill-ring-save'）を使うとよ
いでしょう。このコマンドは、バッファからリージョンをキルせずに、リージョ
ンをキルリングにコピーします。このコマンドは、`C-w'に続けて`C-x u'を実
行するのとほぼ同等ですが、`M-w'はアンドゥ履歴を変更しませんし、一時的
にせよ画面表示も変わりません。



File: emacs-ja.info, Node: Appending Kills, Next: Earlier Kills, Prev: Kill Ring, Up: Yanking

キルしたテキストの追加
----------------------

通常、各キルコマンドは、キルリングに新たな項目を押し込みます。しかし、
連続したキルコマンドでは、それぞれでキルしたテキストを1つの項目にまと
めます。そのため、1回の`C-y'で、キルするまえの状態に、それらのテキスト
をひとまとめにヤンクできます。

したがって、テキストを一塊でヤンクしたい場合でも、1つのコマンドでそれ
らをキルする必要はありません。すべてをキルするまで、1行ずつ、あるいは、
1単語ずつキルしていっても、一括してもとに戻すことができます。

ポイント位置から前向きにキルするコマンドでは、
直前にキルしたテキストの末尾に付け加えます。
ポイント位置から後向きにキルするコマンドでは、
テキストの先頭に付け加えます。
このように、前向き／後向きの両方のキルコマンドをどのように混ぜて実行しても、
キルしたテキストの順番を崩すことなく
1つの項目としてキルリングに記録されます。
数引数を指定しても、このような追加系列が途切れることはありません。
たとえば、バッファにつぎのテキストが入っていて、
-!-の位置にポイントがあるとしましょう。

     This is a line -!-of sample text.

`M-d M-DEL M-d M-DEL'と打って、前向き／後向きと交互にキルしても、キル
リングには1つの項目として`a line of sample'が入り、バッファには`This
is text.'が残ります。（空白が2個残っていることに注意。これらは`M-SPC'
や`M-q'で一掃できる。）

同じようにテキストをキルするもう1つの方法は、`M-b M-b'で後向きに2語移
動してから、`C-u M-d'で前向きに4語キルします。こうしても、バッファとキ
ルリングの中身は、先の例とまったく同じ結果になります。`M-f M-f C-u
M-DEL'としても、後向きに同じテキストをキルします。これでもやはり同じ結
果が得られます。キルリングの項目内のテキストの順序は、キルするまえのバッ
ファ内での順序と同じです。

キルコマンドと最後のキルコマンドのあいだに（単なる数引数ではない）他の
コマンドが入ると、キルリングには新たな項目が作られます。しかし、キルコ
マンドを打つ直前にコマンド`C-M-w'（`append-next-kill'）を打っておけば、
既存の項目へ追加するように強制できます。`C-M-w'は、つぎがキルコマンド
であれば、新たな項目を作成するかわりにキルしたテキストを以前にキルした
テキストに付け加えるよう指示します。`C-M-w'を使うことで、まとめて1か所
にヤンクできるように、離れた場所にあるいくつかのテキスト断片をキルして
集めておけます。

`M-w'に続くキルコマンドでは、`M-w'がキルリングにコピーしたテキストには
付け加えません。



File: emacs-ja.info, Node: Earlier Kills, Prev: Appending Kills, Up: Yanking

以前にキルしたテキストのヤンク
------------------------------

直前にキルしたものではないテキストを取り出すには、`M-y'コマンド
（`yank-pop'）を使います。`M-y'は、直前にヤンクしたテキストをそれ以前
にキルしたテキストで置き換えます。たとえば、最後から2つめのキルテキス
トを取り出すには、まず`C-y'で最後にキルしたテキストをヤンクしてから、
`M-y'で1つまえのものに置き換えます。`M-y'は`C-y'や他の`M-y'の直後でし
か使えません。

キルリング内の項目を指す『最終ヤンク』ポインタを考えると、`M-y'の動作
を理解しやすいでしょう。キルするたびに、『最終ヤンク』ポインタは、リン
グの先頭に新たに作られた項目を指します。`C-y'は、『最終ヤンク』ポイン
タが指す項目をヤンクします。`M-y'は、『最終ヤンク』ポインタを別の項目
へ移動し、それに合わせてバッファのテキストを変更します。`M-y'コマンド
を繰り返せばリング内のどの項目へもポインタを移動できるので、どの項目で
もバッファに取り込めます。ポインタがリングの最後に達すると、つぎの
`M-y'はポインタをふたたびリングの先頭の項目に移動します。

`M-y'は、リング内で『最終ヤンク』ポインタを移動しますが、リング内の項
目の順番を変えることはありません。つねに、最後にキルしたものが先頭にあ
り、記録に残っている最古のものが最後尾にあります。

`M-y'には数引数を指定できて、『最終ヤンク』ポインタをいくつ進めるかを
指定します。負の引数では、ポインタをリングの先頭に向けて移動します。リ
ングの先頭からは最後の項目へ移動し、そこから先頭に向けて移動します。

目的のテキストがバッファに入ったならば、`M-y'コマンドの繰り返しを止め
れば、みつけたテキストが残ります。そのテキストはキルリングの項目のコピー
なので、バッファ内で編集してもリング内の項目は変わりません。新たにキル
しない限り、『最終ヤンク』ポインタはキルリング内の同じ場所を指していま
すから、`C-y'を繰り返すと、直前に取り込んだものと同じキル内容のコピー
をヤンクできます。

目的のテキストを引き出すのに`M-y'コマンドを何回使えばよいのかわかって
いる場合には、数引数を指定して`C-y'を使えば、一発で目的のテキストをヤ
ンクできます。`C-y'に数引数を指定すると、キルリング内でその個数分だけ
遡った項目のテキストを取り込みます。たとえば、`C-u 2 C-y'は最後から2番
目にキルしたテキストを取り込みます。つまり、`C-y M-y'とするのと等価で
す。数引数を指定した`C-y'は、『最終ヤンク』ポインタの場所から数え始め、
ヤンクする項目にポイントを移動します。

キルリングの長さは、変数`kill-ring-max'で制御します。この個数以上のキ
ルテキストは保存しません。

キルリングの実際の内容は、`kill-ring'という名前の変数に入っています。
キルリングの全内容は、コマンド`C-h v kill-ring'で見ることができます。



File: emacs-ja.info, Node: Accumulating Text, Next: Rectangles, Prev: Yanking, Up: Top

テキストの蓄積
==============

通常、テキストをコピーしたり移動したりするにはキルとヤンクで行います。
しかし、一塊のテキストを何か所にもコピーしたり、多くの箇所に分散したテ
キストを1か所にコピーしたりするのに便利な方法が他にもあります。一塊の
テキストを何か所にもコピーするには、そのテキストをレジスタに保存します
（*Note Registers::）。ここでは、何か所かに分散したテキストをバッファ
やファイルに蓄積するためのコマンドを説明します。

`M-x append-to-buffer'
     リージョンを指定したバッファの内容の末尾に付加する。
`M-x prepend-to-buffer'
     リージョンを指定したバッファの内容の先頭に付加する。
`M-x copy-to-buffer'
     リージョンを指定したバッファにコピーするが、そのバッファの古い内
     容は削除する。
`M-x insert-buffer'
     指定したバッファの内容をカレントバッファのポイント位置に挿入する。
`M-x append-to-file'
     リージョンを指定したファイルの内容の末尾に付加する。

テキストをバッファに蓄積するには、`M-x append-to-buffer'を使います。こ
れは、バッファ名を読み取り、リージョンのコピーを指定したバッファに挿入
します。存在しないバッファを指定した場合、`append-to-buffer'はバッファ
を作成します。テキストは、そのバッファ内のポイント位置に挿入されます。
バッファを編集用に使っている場合には、そのバッファ内のテキストのあいだ、
その時点のポイント位置にコピーしたテキストを挿入します。

コピー先のバッファ内では、ポイントはコピーされたテキストの末尾に置かれ
ます。したがって、連続して`append-to-buffer'を使うと、コピーした順序で
バッファにテキストが蓄積されます。厳密には、`append-to-buffer'は、バッ
ファ内の既存のテキストに追加するとは限りません。そのバッファの末尾にポ
イントがある場合に限り、追加します。しかし、バッファを変更するコマンド
が`append-to-buffer'だけならば、ポイントはつねに末尾に置かれています。

`M-x prepend-to-buffer'は`append-to-buffer'にとてもよく似ていますが、
コピー先のバッファ内のポイントは、コピーしたテキストの直前に置かれる点
が異なります。つまり、続けてこのコマンドを使うと、テキストは逆順に追加
されていきます。`M-x copy-to-buffer'も同様ですが、指定したバッファ内の
既存のテキストを削除します。したがって、バッファには新たにコピーしたテ
キストだけが残ります。

別のバッファに蓄積したテキストを取り出すには、コマンド`M-x
insert-buffer'を使います。このコマンドも引数としてBUFFERNAMEを必要とし
ます。バッファBUFFERNAME内のテキストのコピーを選択しているバッファに挿
入します。あるいは、そのバッファを選択して編集し、場合によってはキルし
てそのバッファからテキストを移動することもできます。バッファに関する背
景情報は、*Note Buffers::。

テキストをEmacsのバッファに蓄積するかわりに、`M-x append-to-file'を使っ
て、テキストを直接ファイルに追加できます。このコマンドは引数として
FILENAMEを必要とします。リージョンのテキストを指定したファイルの末尾に
追加します。ファイルはディスク上でただちに更新されます。

このコマンドに指定するファイルは、Emacsで訪問して*いない*ファイルだけ
に限るべきです。Emacsで編集中のファイルを指定すると、Emacsに隠れてファ
イルを変更することになり、編集内容の一部を失うことにもなりかねません。



File: emacs-ja.info, Node: Rectangles, Next: Registers, Prev: Accumulating Text, Up: Top

矩形領域
========

矩形領域コマンドはテキストの矩形領域を操作します。矩形領域のテキストと
は、2つの行の範囲内にある2つの桁位置のあいだにある文字すべてを指します。
矩形領域をキルする、キルした矩形領域をヤンクする、矩形領域をクリアする、
矩形領域を空白やテキストで充填する、矩形領域を削除する、といったコマン
ドがあります。矩形領域コマンドは、複数段に組んだテキストを操作したり、
テキストをそのように組んだり戻したりする場合に便利です。

コマンドで操作する矩形領域を指定するには、一方の隅にマークを設定し、そ
の対角にポイントを置きます。このように設定した矩形領域を"矩形リージョ
ン" （region-rectangle）と呼びます。というのも、リージョンの制御と似た
方法で矩形領域を制御できるからです。しかし、ポイントとマークの組は、そ
れを使うコマンドに依存して、リージョンとして解釈される、あるいは、矩形
領域として解釈されることに注意してください。

ポイントとマークが同じ桁位置にある場合、それらが切り分ける矩形領域は空
です。同じ行上にある場合は、矩形領域の高さは1行です。桁と行の扱い方が
非対称であるのは、ポイント（同様にマーク）は2つの桁のあいだにあるのに
対し、行ではその中にあるからです。

`C-x r k'
     矩形リージョンのテキストをキルし、その内容を『最後にキルした矩形
     領域』として保存する（`kill-rectangle'）。
`C-x r d'
     矩形リージョンのテキストを削除する（`delete-rectangle'）。
`C-x r y'
     最後にキルした矩形領域をポイント位置を左上隅としてヤンクする
     （`yank-rectangle'）。
`C-x r o'
     空白で埋めた矩形リージョンを挿入する（`open-rectangle'）。矩形リー
     ジョンの直前の内容は右に押しやられる。
`M-x clear-rectangle'
     矩形リージョンのすべてのテキストを空白で置き換えて、内容をクリア
     する。
`M-x delete-whitespace-rectangle'
     指定した矩形領域の各行において、矩形領域の左端から白文字を削除す
     る。
`C-x r t STRING RET'
     指定した矩形領域の各行にSTRINGを挿入する（`string-rectangle'）。

矩形操作は2種類に分類できます。矩形領域を削除したり挿入したりするコマ
ンドと、空白の矩形領域を扱うコマンドです。

矩形領域内のテキストを消すには、2つの方法があります。テキストを捨てる
（削除する）か、『最後にキルした』矩形領域として保存するかです。これら
の機能を実現するコマンドは、`C-x r d'（`delete-rectangle'）と`C-x r k'
（`kill-rectangle'）です。どちらも、矩形領域の内側にある各行の部分を削
除し、それより右側にテキストがあれば、隙間を埋めるようにそれらを左へ移
動します。

矩形領域の『キル』は普通の意味でのキルではない、ということに注意してく
ださい。矩形領域はキルリングには保存されませんが、最後にキルした矩形領
域を1つだけ記録できる特別な場所に保存されます。というのは、矩形領域を
ヤンクすることは、線形のテキストのヤンクとは大きく異なり、特別なヤンク
コマンドが必要だったり、ヤンクしたテキストの入れ換え操作が意味をなさな
かったりするからです。

最後にキルした矩形領域をヤンクするには、`C-x r y'（`yank-rectangle'）
と打ちます。矩形領域のヤンクは矩形領域のキルの逆です。ポイントは矩形領
域の左上隅の位置を指定します。その場所には矩形領域の1行目が挿入され、
矩形領域の2行目はそのつぎの行にというように挿入されます。影響される行
数は、保存されている矩形領域の高さで決まります。

矩形領域のキルとヤンクを使うと、1段組みの一覧表を2段組の一覧表に変換で
きます。一覧表の後半を矩形領域としてキルして、一覧表の第1行の隣にヤン
クすればよいのです。

また、`C-x r r R'や`C-x r i R'を使えば、矩形領域をレジスタにコピーした
り、レジスタから矩形領域をコピーしたりできます。*Note Rectangle
Registers: RegRect。

空白の矩形領域を作るコマンドは2つあります。`M-x clear-rectangle'は既存
のテキストを空白で置き換え、`C-x r o'（`open-rectangle'）は空白の矩形
領域を挿入します。矩形領域をクリアすることは、矩形領域を削除してから同
じ大きさの空白の矩形領域を挿入するのと同じことです。

コマンド`M-x delete-whitespace-rectangle'は、特定の桁位置から始まる横
に並んだ白文字を削除します。矩形領域内の各行に作用し、桁位置は矩形領域
の左端です。矩形領域の右端はこのコマンドには関係ありません。

コマンド`C-x r t'（`M-x string-rectangle'）は、矩形領域を指定した文字
列で置き換えます。文字列の幅は、矩形領域の幅と同じである必要はありませ
ん。文字列の幅が足りなければ、矩形領域の右側にあるテキストは左へ移動し
ます。文字列の幅が広ければ、矩形領域の右側にあるテキストは右へ移動しま
す。


File: emacs-ja.info, Node: Registers, Next: Display, Prev: Rectangles, Up: Top

レジスタ
********

Emacsの"レジスタ"（registers）は、あとで使うためにテキストやポイント位
置を保存するための場所です。テキストや矩形領域をレジスタにいったん保存
すれば、何度でもバッファにコピーできます。また、レジスタに保存した位置
には何度でもポイントを移動できます。

各レジスタには1文字の名前が付いています。レジスタには、テキストの一部、
矩形領域、位置、ウィンドウの構成情報、ファイル名を保存できますが、1度
にはそのうちの1つしか保存できません。レジスタに保存した内容は、そのレ
ジスタに他のものを保存するまでは保持され続けます。レジスタRに何が入っ
ているか調べるには、`M-x view-register'を使います。

`M-x view-register RET R'
     レジスタRの内容を表示する。

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.



File: emacs-ja.info, Node: RegPos, Next: RegText, Up: Registers

レジスタに位置を保存する
========================

位置を保存するとは、あとで戻ってこられるようにバッファ中の位置を記録す
ることです。保存した位置に移動すると、そのバッファに切り替えてからポイ
ントをその位置に移動します。

`C-x r SPC R'
     ポイント位置をレジスタRに保存する（`point-to-register'）。
`C-x r j R'
     レジスタRに保存した位置に移動する（`jump-to-register'）。

ポイントの現在位置をレジスタに保存するには、名前Rを選んでから、`C-x r
SPC R'と打ちます。他のものを保存するまで、レジスタRはこうして保存した
位置を保持し続けます。

コマンド`C-x r j R'は、レジスタRに記録した位置にポイントを移動します。
レジスタは変わらず、同じ位置を記録し続けます。何度でも保存した位置に移
動できます。

`C-x r j'を使って保存位置に移動しようとしたとき、その対象となるバッファ
がすでに消去されていた場合には、`C-x r j'は同じファイルを訪問するバッ
ファを作成し直そうとします。もちろん、これはファイルを訪問したバッファ
に対してのみ働きます。



File: emacs-ja.info, Node: RegText, Next: RegRect, Prev: RegPos, Up: Registers

レジスタにテキストを保存する
============================

テキストの同じ部分のコピーを頻繁に挿入する場合、キルリングからヤンクす
るのは便利ではないでしょう。というのは、キルするごとに、必要な部分がリ
ングの下方に徐々に移動してしまうからです。別の手段としては、レジスタに
テキストを保存しておき、レジスタから取り込むという方法があります。

`C-x r s R'
     レジスタRにリージョンをコピーする（`copy-to-register'）。
`C-x r i R'
     レジスタRからテキストを挿入する（`insert-register'）。

`C-x r s R'は、リージョンのテキストのコピーをRという名前のレジスタに保
存します。`C-x r s R'に数引数を指定すると、保存すると同時にバッファか
らテキストを削除します。

`C-x r i R'はレジスタRからテキストをバッファに挿入します。通常、テキス
トの直前にポイントを置き、直後にマークを置きます。しかし、数引数
（`C-u'）を指定すると、テキストの直後にポイントを置き、直前にマークを
置きます。



File: emacs-ja.info, Node: RegRect, Next: RegConfig, Prev: RegText, Up: Registers

レジスタに矩形領域を保存する
============================

レジスタには、連続したテキスト以外にも、矩形領域を保持できます。矩形領
域は、文字列のリストとして表されます。バッファ内での矩形領域の指定方法
に関する基礎情報については、*Note Rectangles::。

`C-x r r R'
     矩形領域をレジスタRにコピーする（`copy-rectangle-to-register'）。
     数引数を指定すると、コピー後に矩形領域を削除する。
`C-x r i R'
     レジスタRに保存した矩形領域（が存在すればそれ）を挿入する
     （`insert-register'）。

`C-x r i R'コマンドは、レジスタにテキストが入っていれば、そのテキスト
の文字列を挿入しますし、矩形領域があれば矩形領域を挿入します。

コマンド`sort-columns'も参照してください。このコマンドは矩形領域をソー
トすると考えられます。*Note Sorting::。



File: emacs-ja.info, Node: RegConfig, Next: RegNumbers, Prev: RegRect, Up: Registers

レジスタにウィンドウ構成を保存する
==================================

選択したフレームのウィンドウ構成をレジスタに保存したり、すべてのフレー
ムのすべてのウィンドウ構成を保存したりできて、しかも、あとでその構成に
戻せます。

`C-x r w R'
     選択したフレームのウィンドウの状態をレジスタRに保存する
     （`window-configuration-to-register'）。
`C-x r f R'
     全フレームの状態を、各フレームのすべてのウィンドウを含めて、レジ
     スタRに保存する（`frame-configuration-to-register'）。

ウィンドウやフレームの構成をもとに戻すには、`C-x r j R'を使います。こ
れは、カーソル位置を復元するコマンドと同じです。フレームの構成を復元す
ると、構成情報に含まれていない既存のフレームは隠れた状態になります。こ
れらのフレームを削除したければ、`C-u C-x r j R'を使います。



File: emacs-ja.info, Node: RegNumbers, Next: RegFiles, Prev: RegConfig, Up: Registers

レジスタに数値を保持する
========================

レジスタに数値を保存しておき、数値を10進数でバッファに挿入してから数値
を増やすコマンドがあります。これらのコマンドは、キーボードマクロで役立
ちます（*Note Keyboard Macros::）。

`C-u NUMBER C-x r n REG'
     数値NUMBERをレジスタREGに保存する（`number-to-register'）。
`C-u NUMBER C-x r + REG'
     レジスタREG内の数値をNUMBERだけ増やす（`increment-register'）。
`C-x r g REG'
     レジスタREGの数値をバッファに挿入する。

`C-x r g'は、レジスタの数値以外の内容をバッファに挿入するために使うコ
マンドと同じです。



File: emacs-ja.info, Node: RegFiles, Next: Bookmarks, Prev: RegNumbers, Up: Registers

レジスタにファイル名を保持する
==============================

特定のファイル名を頻繁に訪問する場合には、これらの名前をレジスタに置い
ておくと、より簡単にファイルを訪問できます。ファイル名をレジスタに置く
Lispコードをつぎに示します。

     (set-register ?R '(file . NAME))

たとえば、

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

とすると、上に示したファイル名をレジスタ`z'に保存します。

レジスタRに入れた名前のファイルを訪問するには、`C-x r j R'と打ちます。
（このコマンドは、保存位置に移動したりフレーム構成を復元するために使う
コマンドと同じ。）



File: emacs-ja.info, Node: Bookmarks, Prev: RegFiles, Up: Registers

ブックマーク
============

"ブックマーク"（bookmarks）とは、移動先の位置を記録しておくためのレジ
スタのようなものです。レジスタと違って、長い名前を付けることができて、
自動的につぎのEmacsセッションに引き継がれます。ブックマークの典型的な
使い方は、各ファイルの『どこを読んでいるか』を記録しておくことです。

`C-x r m RET'
     訪問先のファイルのポイント位置にブックマークを設定する。

`C-x r m BOOKMARK RET'
     ポイント位置に、BOOKMARKという名前のブックマークを設定する
     （`bookmark-set'）。

`C-x r b BOOKMARK RET'
     名前がBOOKMARKであるブックマークに移動する（`bookmark-jump'）。

`C-x r l'
     すべてのブックマークを一覧表示する（`list-bookmarks'）。

`M-x bookmark-save'
     現在のすべてのブックマークの値をデフォルトのブックマークファイル
     に保存する。

ブックマークの典型的な使い方は、各ファイルごとに現在のポイント位置を保
存しておくことです。ブックマークを設定するコマンド`C-x r m'は、訪問先
のファイルの名前をブックマーク名のデフォルトとして使います。ブックマー
クが指すファイルをもとにブックマークの名前を付ければ、`C-x r b'で任意
のファイルを再訪問して、同時にブックマーク位置に移動するという操作を楽
に行えます。

設定したすべてのブックマークの一覧を別のバッファに表示するには、`C-x r
l'（`list-bookmarks'）と打ちます。そのバッファに切り替えれば、ブックマー
クの定義を編集したり、ブックマークに注記を付けたりできます。このバッファ
で使える特別な編集コマンドについての情報を得るには、このバッファで`C-h
m'と打ちます。

内容を変更したブックマークがある場合、Emacsを終了する時点で、Emacsはブッ
クマークの値をデフォルトのブックマークファイル`~/.emacs.bmk'に保存する
かどうか聞いてきます。`M-x bookmark-save'コマンドを使っても、変更した
ブックマークをいつでも保存できます。ブックマークコマンドは、個人のデフォ
ルトのブックマークファイルを自動的に読み込みます。これらの保存と読み込
みによって、ブックマークの内容をつぎのEmacsセッションに引き継げるので
す。

変数`bookmark-save-flag'に1を設定しておくと、ブックマークを設定する各
コマンドは、ブックマークの保存も行います。こうしておけば、Emacsがクラッ
シュした場合でも、ブックマークデータを失わなくてすみます。（この変数の
値が数値であれば、ブックマークを何回変更したら保存するという意味。）

ブックマークの位置情報は、その周辺の文脈情報と一緒に保存されるので、ファ
イルが少し変更されていたとしても、`bookmark-jump'は正しい位置をみつけ
だせます。変数`bookmark-search-size'で、ブックマーク位置の前後何文字分
の内容を保存するかを指定します。

ブックマークを用いるコマンドには、以下のものもあります。

`M-x bookmark-load RET FILENAME RET'
     ブックマークデータのリストを収めたFILENAMEという名前のファイルを
     ロードする。デフォルトのブックマークファイル以外のブックマークデー
     タを収めたファイルに対しても、コマンド`bookmark-write'と同じく、
     このコマンドを使える。

`M-x bookmark-write RET FILENAME RET'
     現在設定されているブックマークデータをファイルFILENAMEに保存する。

`M-x bookmark-delete RET BOOKMARK RET'
     BOOKMARKという名前のブックマークを削除する。

`M-x bookmark-insert-location RET BOOKMARK RET'
     ブックマークBOOKMARKが指しているファイルの名前をバッファに挿入す
     る。

`M-x bookmark-insert RET BOOKMARK RET'
     ブックマークBOOKMARKが指すファイルの*内容*をバッファに挿入する。


File: emacs-ja.info, Node: Display, Next: Search, Prev: Registers, Up: Top

画面の制御
**********

大きなバッファの一部しかウィンドウには収まりませんから、Emacsは必要そ
うな部分を表示しようとします。画面制御コマンドを使って、テキストのどの
部分を表示したいのか、また、どのように表示するか指定できます。

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Display Vars::           Information on variables for customizing display.



File: emacs-ja.info, Node: Scrolling, Next: Horizontal Scrolling, Up: Display

スクロール
==========

バッファを表示しているウィンドウに全部を表示するには大きすぎるテキスト
が入っているバッファでは、Emacsはテキストの連続する一部分を表示します。
表示する部分にはつねにポイントが入っています。

"スクロール"（scroll）とは、ウィンドウ内でテキストを上下に動かして、テ
キストの異なる部分を表示することです。前向きのスクロールでは、テキスト
を上へ移動して、新たなテキストがウィンドウの最下端から現れます。後向き
のスクロールでは、テキストを下に移動して、新たなテキストがウィンドウの
最上端から現れます。

ポイントをウィンドウの下端や上端を超えて移動すると、自動的にスクロール
します。本節で紹介するコマンドを使って、明示的にスクロールすることもで
きます。

`C-l'
     画面をクリアして再表示し、選択されたウィンドウではポイントが縦方
     向の中央に位置するようにスクロールする（`recenter'）
`C-v'
     （ウィンドウ1面分か指定した行数だけ）前向きにスクロールする
     （`scroll-up'）。
`NEXT'
     同様に前向きにスクロールする。
`M-v'
     後向きにスクロールする（`scroll-down'）。
`PRIOR'
     同じく後向きにスクロールする。
`ARG C-l'
     ポイントがARG行目にくるようにスクロールする（`recenter'）。
`C-M-l'
     有益な情報が画面上にくるように発見的方法でスクロールする
     （`reposition-window'）。

もっとも基本的なスクロールコマンドは、引数を指定しない`C-l'
（`recenter'）です。このコマンドは、画面全体をクリアして、すべてのウィ
ンドウを再表示します。さらに、ポイントがウィンドウの中央の行に位置する
ように、選択されているウィンドウをスクロールします。

スクロールコマンド`C-v'と`M-v'は、ウィンドウ内の全テキストを上下に何行
か移動します。`C-v'（`scroll-up'）に引数を指定すると、`C-l'と同じよう
にテキストとポイントを一緒に上へ移動して、追加分（引数分）の行をウィン
ドウの下部に表示します。`C-v'に負の引数を指定した場合は、ウィンドウの
上端に追加分の行を表示します。`M-v'（`scroll-down'）は`C-v'に似ていま
すが、スクロール方向が逆です。ファンクションキーのNEXTとPRIORは、`C-v'
と`M-v'に等価です。

スクロールコマンドの名前は、ウィンドウ内でテキストを動かす向きに基づい
ています。したがって、前向きにスクロールするコマンドは、画面上ではテキ
ストを上へ移動するため、`scroll-up'と呼ばれます。

一度にウィンドウ1面分のバッファを読んでいくには、引数を指定せずに`C-v'
を使います。ウィンドウの下端2行を上端に持っていき、それに続けてこれま
で表示されていなかったほぼウィンドウ1面分の行を表示します。ポイントが
ウィンドウの上端より上に出てしまう場合には、ポイントはウィンドウの新た
な上端の行に移動します。引数を指定しない`M-v'も同様に、テキストを重複
させながら、後向きに移動します。`C-v'や`M-v'で重複させる行数は、変数
`next-screen-context-lines'で制御します。デフォルトでは2です。

画面上でのポイント位置を保ったまま1画面分のスクロールを行うコマンドを
好むユーザーもいます。このようにするには、変数
`scroll-preserve-screen-position'に`nil'以外を設定します。このモードは、
1画面分ずつスクロールしながらファイルを閲覧するような場合に便利です。
スクロールを始めた画面に戻ると、ポイントは開始時の行位置に戻ります。し
かし、つぎの画面に移動して、そこに表示されているテキストにポイントを移
動するような使い方にはむいていません。

スクロールのもう1つの方法は、数引数を指定した`C-l'を使うことです。引数
を指定すると、`C-l'は画面をクリアしません。選択されているウィンドウだ
けをスクロールします。正の引数Nを指定すると、ポイント位置が上端からN行
目にくるように、テキストの位置を変更します。引数として0を指定すると、
ポイント位置は最上端の行になります。ポイントがテキストに対して動くわけ
ではなくて、テキストとポイントは一緒に画面上を動きます。`C-l'に負の引
数を指定すると、ポイントはウィンドウの下端から指定行数にきます。たとえ
ば、`C-u - 1 C-l'とするとポイントは最下行になり、`C-u - 5 C-l'とすれば
下から5行目にポイントがきます。`C-u C-l'のように`C-u'だけを引数に指定
すると、ポイントが画面中央にくるようにスクロールします。

`C-M-l'コマンド（`reposition-window'）は、有益な情報を画面上に持ってく
るようにように設計された発見的手法で、カレントウィンドウをスクロールし
ます。たとえば、Lispファイルでは、このコマンドは、可能であれば現在の関
数定義（defun）全体を画面上にもってこようとします。

表示の際、ポイントがテキストの表示部分から飛び出してしまうと、自動的に
スクロールします。通常、この自動スクロールでは、ポイントがウィンドウ縦
方向の中央に位置するように画面を移動します。しかし、
`scroll-conservatively'に小さな数Nを設定しておくと、ポイントが画面から
少しだけ（N行未満）はみだすと、Emacsはポイントを画面内に戻すのに必要な
分だけスクロールします。デフォルトでは、`scroll-conservatively'は0です。

変数`scroll-margin'は、ポイントをウィンドウの上端や下端にどれだけ近づ
けられるかを制限します。その値は画面上での行数です。ポイントがウィンド
ウの上端や下端からその行数以内にくると、Emacsはウィンドウを中央に位置
付けし直します。デフォルトでは、`scroll-margin'は0です。



File: emacs-ja.info, Node: Horizontal Scrolling, Next: Follow Mode, Prev: Scrolling, Up: Display

水平スクロール
==============

"水平スクロール"（horizontal scrolling）とは、すべての行をウィンドウ内
で横方向に動かすことです。これにより、左端近くのテキストは表示されなく
なります。

`C-x <'
     カレントウィンドウのテキストを左にスクロールする（`scroll-left'）。
`C-x >'
     右にスクロールする（`scroll-right'）。

ウィンドウが水平方向にスクロールされているときには、テキスト行を継続
（*Note Continuation Lines::）しないで切り捨てます。テキストの左側を切
り捨てているときは最初の桁に`$'を表示し、右側を切り捨てているときには
最後の桁に`$'を表示します。

コマンド`C-x <'（`scroll-left'）は、選択されたウィンドウを引数Nの桁数
だけ左にスクロールします。各行の最初の部分はウィンドウの左端から出てし
まいます。引数を指定しないと、ほぼウィンドウ幅（正確には2桁少ない桁数）
だけスクロールします。

`C-x >'（`scroll-right'）は、同様に右にスクロールします。
ウィンドウが（各行がウィンドウの左端から始まっている）通常の表示をしていると、
それ以上はスクロールできません。
スクロールさせようとしても何も起こりません。
つまり、`C-x >'に与える引数を正確に計算する必要はないのです。
十分に大きな引数を指定すれば、通常の表示に戻せます。

水平スクロール（hscroll）モードをオンにすると、自動的に水平スクロール
を行います。このモードがオンであると、ポイントが左右端から離れすぎない
場所に見えるようにEmacsが水平方向にウィンドウをスクロールします。この
モードのオン／オフを切り替えるコマンドは、`M-x hscroll-mode'です。



File: emacs-ja.info, Node: Follow Mode, Next: Selective Display, Prev: Horizontal Scrolling, Up: Display

追従モード
==========

"追従（follow）モード"は、同じバッファを表示している2つのウィンドウを、
1つの『仮想ウィンドウ』としてスクロールするマイナモードです。追従
（follow）モードを使うには、ウィンドウが1つだけのフレームに移動して、
`C-x 3'を使って左右に並んだ2つのウィンドウに分割してから、`M-x
follow-mode'と打ちます。これ以後、いずれのウィンドウのバッファでも編集
できますし、どちらをスクロールしてもかまいません。もう一方のウィンドウ
は他方に追従します。

追従（follow）モードをオフにするには、もう一度`M-x follow-mode'を打ち
ます。



File: emacs-ja.info, Node: Selective Display, Next: Optional Mode Line, Prev: Follow Mode, Up: Display

選択的な表示
============

Emacsには、（指定した）桁数以上字下げしてある行を隠す機能があります。
プログラムの一部を概観するのにこの機能を使えます。

行を隠すには、数引数Nを指定して`C-x $' （`set-selective-display'）と打
ちます。これにより、N桁以上字下げしてある行は画面から消えます。1行以上
の不可視行に先行する可視行の末尾には、3つのドット（`...'）を表示します。
この印が不可視行の存在を示す唯一のものです。

コマンド`C-n'や`C-p'は、不可視行が存在しないかのように不可視行を飛び越
えて移動します。

不可視行は依然としてバッファ内に存在しています。たいていの編集コマンド
はそれらを通常と同じように扱うので、隠蔽されたテキスト内にポイントを移
動してしまうことも起こりえます。このような場合、カーソルは先行する行の
末尾の3つのドットの直後に表示されます。ポイントが可視行の行末の改行文
字の直前にあるときには、3つのドットの直前にカーソルが現れます。

すべての行をふたたび表示するには、引数を指定せずに`C-x $'を打ちます。

変数`selective-display-ellipses'に`nil'を設定すると、不可視行に先行す
る可視行の末尾には3つのドットを表示しなくなります。すると、不可視行の
存在を示すものは何もありません。この変数を設定すると、自動的にローカル
になります。



File: emacs-ja.info, Node: Optional Mode Line, Next: Text Display, Prev: Selective Display, Up: Display

モード行の付加機能
==================

行番号（line-number）モードがオンであると、ポイントの現在の行番号をモー
ド行に表示します。このモードのオン／オフを切り替えるには、コマンド`M-x
line-number-mode'を使います。通常はオンです。行番号は、バッファの百分
率を示すPOSのまえに、行番号であること示す文字`L'とともに表示されます。
マイナモードやこのコマンドの使用方法について詳しくは、*Note Minor
Modes::。

バッファが非常に大きい（`line-number-display-limit'の値以上に大きい）
場合には、この行番号を表示しません。計算が非常に遅くなるので、バッファ
が大きい場合にはEmacsは行番号を計算しません。バッファをナロイング
（*Note Narrowing::）してある場合、表示される行番号はバッファの参照可
能な部分に対するものです。

桁番号（column-number）モードをオンにすると、現在の桁番号も表示できま
す。このモードでは、`C'に続けて現在の桁番号を表示します。このモードの
オン／オフを切り替えるには、`M-x column-number-mode'と打ちます。

Emcasでは、すべてのモード行に、時刻とシステムの負荷状況を表示できます。
この機能をオンにするには、`M-x display-time'と打ちます。このときモード
行に追加される情報は、通常は、バッファ名のあと、括弧で囲まれたモード名
のまえに表示されます。その表示はつぎのようになります。

     HH:MMpm L.LL

ここで、HHとMMは、時分を表し、つねに`am'か`pm'が続きます。L.LLは、シス
テム全体で実行中のプロセスの個数の最近の平均数です。（オペレーティング
システムが情報を提供しなければ、いくつかの内容が消えていることもある。）
時刻を24時間表示したければ、変数`display-time-24hr-format'に`t'を設定
します。

負荷レベル表示に続く語`Mail'は、未読のメイルがある場合に表示されます。



File: emacs-ja.info, Node: Text Display, Next: Display Vars, Prev: Optional Mode Line, Up: Display

テキストの表示方法
==================

Emacsバッファ内のASCII印字文字（8進コードで040から0176）は、それぞれの
図形で表示されます。非ASCIIのマルチバイトの印字文字（8進コード0400以上）
も同様です。

ASCIIコントロール文字の中には、特別な方法で表示されるものもあります。
改行文字（8進コード012）は、新たな行を始めるという形で表示されます。タ
ブ文字（8進コード011）は、つぎのタブストップ位置（通常は8桁ごと）まで
移動するという形で表示されます。

その他のASCIIコントロール文字は、通常、カレット（`^'）に続けてコントロー
ル変種でない文字で表示されます。つまり、control-Aは`^A'のように表示さ
れます。

0200から0377までの非ASCII文字は、8進のエスケープシーケンスで表示されま
す。たとえば、文字コード0243（8進）は、`\243'と表示されます。しかし、
ヨーロッパ向けの表示をオンにしていると、これらのたいていの文字は非
ASCII印字文字として扱われ、（端末がこれらの文字を表示できると仮定して）
それぞれの図形で表示されます。*Note Single-Byte European Support::。



File: emacs-ja.info, Node: Display Vars, Prev: Text Display, Up: Display

表示を制御する変数
==================

本節は、カスタマイズに関する情報のみです。初心者の方は読み飛ばしてくだ
さい。

変数`mode-line-inverse-video'は、（端末が反転表示を扱えると仮定して）
モード行を反転表示するかどうかを制御します。`nil'は反転表示しないこと
を意味します。*Note Mode Line::。`modeline'フェイスに前景色を指定して
いて、しかも、`mode-line-inverse-video'が`nil'以外であれば、`modeline'
フェイスのデフォルトの背景色は通常の前景色です。*Note Faces::。

変数`inverse-video'が`nil'以外である場合、Emacsは画面上のすべての行を
通常の状態から反転表示します。

変数`visible-bell'が`nil'以外の場合、Emacsは、通常は端末のベルを鳴らす
場面では、画面全体を点滅します。端末に画面を点滅する機能がなければ、こ
の変数は何の効果もありません。

Emacsを休止したあとで再開した場合、通常Emacsは画面をクリアし、画面全体
を再表示します。ページメモリを複数個備えた端末では、termcapの定義を変
更して、（それぞれ、Emacsを起動するときと抜けるときに端末に出力される）
文字列`ti'と`te'でページメモリを切り替えて、1ページをEmacs用に使い、も
う1ページを他の出力用に使うようにできます。そして、変数
`no-redraw-on-reenter'に`nil'以外を設定します。こうすると、Emacsは、再
開時には最後に出力した内容が画面ページに入っているものと仮定します。

変数`echo-keystrokes'は、複数個の文字キーのエコーを制御します。設定す
る値は、エコーを開始するまでの待機時間の秒数です。ゼロを指定するとエコー
しません。*Note Echo Area::。

変数`ctl-arrow'に`nil'を設定すると、改行とタブを除いて、バッファ内のコ
ントロール文字を8進のエスケープシーケンスで表示します。変数`ctl-arrow'
の値を変更すると、この変数はカレントバッファにローカルになります。それ
までは、デフォルトの値が使われます。デフォルトの初期値は`t'です。*Note 
表示テーブル: (elisp)Display Tables。

通常、バッファ内のタブ文字は、つぎのタブストップ位置までの空白として表
示され、タブストップは8個分の空白と同じ間隔です。タブ1個あたりの空白の
文字数は、変数`tab-width'で制御します。この変数も`ctl-arrow'と同様に、
変更するとバッファにローカルになります。バッファ内のタブ文字をどのよう
に表示するかと、コマンドとしてのTABの定義とは無関係であることに注意し
てください。変数`tab-width'の値は1以上1000以下の整数である必要がありま
す。

変数`truncate-lines'に`nil'以外を設定すると、テキストの各行は表示上は
画面の1行を占有します。テキスト行が長すぎる場合は、画面に収まる範囲だ
けを表示します。一方、`truncate-lines'に`nil'を設定すると、長いテキス
ト行は、画面上では2行以上にわたってテキスト行の表示に必要なだけの行数
で表示されます。*Note Continuation Lines::。変数`truncate-lines'の値を
変更すると、カレントバッファにローカルになります。それまでは、デフォル
トが使われます。デフォルトの初期値は`nil'です。

変数`truncate-partial-width-windows'に`nil'以外を設定すると、画面やフ
レームの幅に満たないウィンドウでは、テキストの表示方法は
`truncate-lines'の値とは無関係に、継続行ではなく切り捨てて表示します。
左右に並べたウィンドウに関しては、*Note Split Window::。*Note Emacsの
画面表示: (elisp)Displayも参照してください。

変数`baud-rate'は、Emacsにとっての端末の出力速度を保持します。この変数
の値を設定したとしても、実際のデータ転送速度を変更できるわけではなく、
この値はパディングの計算などに用いられます。さらに、ウィンドウシステム
を使用している場合であっても、画面の一部をスクロールするのか、再表示す
るのかの決定にも影響します。（ウィンドウシステムには正しい『出力速度』
がないにしても、スクロール／再表示を調整できるようにこのように設計して
ある。）

どんな文字コードの表示方法も、表示テーブルを用いてカスタマイズできます。
*Note 表示テーブル: (elisp)Display Tables。


File: emacs-ja.info, Node: Search, Next: Fixit, Prev: Display, Up: Top

探索と置換
**********

他のエディタと同様に、Emacsにも文字列を探索するコマンドがあります。主
な探索コマンドが"インクリメンタル"（incremental）であるという点で、普
通とは違います。探索したい文字列全体を入力し終えなくても、探索を始めま
す。他のエディタの探索コマンドのように、インクリメンタルでない探索コマ
ンドもあります。

指定した文字列の出現すべてを探し出して別の文字列に置換する、普通の置換
コマンド`replace-string'に加えて、Emacsにはより高級な、出現箇所をみつ
けるたびに置換するかどうか対話的に尋ねる問い合わせ型置換コマンド
`query-replace'もあります。

* Menu:

* Incremental Search::	   Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::		   Search for sequence of words.
* Regexp Search::	   Search for match for a regexp.
* Regexps::		   Syntax of regular expressions.
* Search Case::		   To ignore case while searching, or not.
* Replace::		   Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.



File: emacs-ja.info, Node: Incremental Search, Next: Nonincremental Search, Prev: Search, Up: Search

インクリメンタルサーチ
======================

インクリメンタルサーチでは、探索文字列の最初の文字を打つとただちに探索
を開始します。探索文字列を入力するたびに、Emacsは（それまでに入力した）
文字列がどこでみつかるか表示します。目的の箇所を特定するのに十分なだけ
の文字を打ってしまえば、そこで終りにできます。つぎに何をするかにもより
ますが、RETで探索を陽に終了する必要がある場合もあります。

`C-s'
     前向きにインクリメンタルサーチする（`isearch-forward'）。
`C-r'
     後向きにインクリメンタルサーチする（`isearch-backward'）。

`C-s'はインクリメンタルサーチを始めます。`C-s'はキーボードから文字を読
み取り、打った文字が最初に現れる位置までカーソルを移動します。たとえば、
`C-s'に続けて`F'を打つと、カーソルは最初に現れる`F'の直後に移動します。
さらに`O'を打つと、カーソルは最初に現れる`FO'の直後に移動します。さら
に`O'を打つと、探索を開始した場所以降で最初に現れる`FOO'の直後にカーソ
ルが移動します。各段階において、反転表示できる端末では、探索文字列に一
致するバッファ内のテキストを強調表示します。また、各段階において、エコー
領域に表示した現在の探索文字列も更新します。

探索する文字列を打ちまちがえたときには、DELで取り消せます。DELを1回押
すごとに、探索文字列の最後の文字を取り消していきます。ただし、Emacsが
つぎの入力文字を受け付け可能になるまで、この取り消し操作は実行できませ
ん。つまり、取り消そうと思っている文字をみつけるか、もしくはみつけられ
なかったことが確定する必要があります。それまで待てないなら、以下に説明
するように`C-g'を使ってください。

目的の箇所まで移動できたら、RETを打ちます。すると、探索を終了しカーソ
ルはその箇所に留まります。また、探索に関係ないコマンドを打っても、探索
を終了し、そのコマンドを実行します。したがって、`C-a'と打てば、探索を
終了し、カーソルを行頭に移動します。RETが必要な場面は、つぎに入力した
いコマンドが、印字文字、DEL、RET、および、探索で特別な意味を持つその他
の各種コントロール文字（`C-q'、`C-w'、`C-r'、`C-s'、`C-y'、`M-y'、
`M-r'、`M-s'）である場合だけです。

`FOO'を探してそれがみつかった場合でも、予期していた`FOO'ではないことも
あるでしょう。最初の`FOO'以降に、2つめの`FOO'があることを忘れていたよ
うな場合です。このようなときには、さらに`C-s'を打てば、探索文字列のつ
ぎの出現箇所に移動できます。この操作は何度でも繰り返せます。行き過ぎて
しまったときには、DELで`C-s'の操作を取り消せます。

探索を終了したあとでも、単に`C-s C-s'と打てば、ふたたび同じ文字列を探
索できます。つまり、最初の`C-s'がインクリメンタルサーチを起動して、つ
ぎの`C-s'が『再探索』を意味します。

以前に探索した文字列を再利用するには、"探索リング"（search ring）を使
います。コマンド`M-p'と`M-n'でリング内を移動して、再利用する文字列を取
り出します。これらのコマンドは、探索リング内の選択した要素をミニバッファ
に置きますから、編集することも可能です。`C-s'や`C-r'を打てば、文字列の
編集を終了して探索を開始できます。

探している文字列がまったくみつからなかった場合には、エコー領域に
`Failing I-Search'と表示されます。カーソルは、指定した文字列に可能な限
り一致する箇所の直後にあります。たとえば、`FOOT'を探索しようとしたのに
`FOOT'がなければ、カーソルは`FOOL'の`FOO'の直後にあります。この時点で
できることはいくつかあります。文字列を打ちまちがえたのならば、それを消
去して訂正します。その箇所でよいのなら、『探索したものを受理する』ため
に、RETか他のEmacsコマンドを打ちます。あるいは、`C-g'を打てば、探索文
字列からみつけられなかった文字（`FOOT'中の`T'）を取り除き、みつけた文
字列（`FOOT'中の`FOO'）はそのままにしておくこともできます。ここで、さ
らに`C-g'を打つと、探索全体を取り止めて、探索を開始した位置に戻ります。

探索文字列に大文字を指定すると、大文字小文字を区別（case-sensitive）し
て探索します。探索文字列から大文字を削除すると、この効果は消えます。
*Note Search Case::。

探索に失敗したときに、さらに`C-s'を打って探索の続行を指示すると、バッ
ファの先頭からもう一度探索し始めます。後向きの探索に失敗したときに再度
`C-r'を打つと、バッファの末尾から探索を再開します。これらの操作は"巻き
直し"（wrapping around）と呼ばれます。巻き直しが起こると、探索のプロン
プトには`Wrapped'が表示されます。もともとの探索開始位置を通過してなお
探索を続けると、表示が`Overwrapped'に変わります。これは、探索文字列に
すでに一度一致した箇所を再度探索していることを意味します。

『中断』文字`C-g'は、探索中には特別な意味があり、その機能は探索の状態
に依存します。指定したものがみつかり入力待ちの状態にあると、`C-g'は探
索全体を取り消します。カーソルは探索開始位置に戻ります。Emacsが探索中
であったり探索に失敗したために、探索文字列内に未発見の文字がある場合に
`C-g'を打つと、探索文字列から未発見の文字を消去します。そうすると、こ
れで探索が成功したことになるので、入力待ちになります。続けて`C-g'を打
つと、探索全体を取り消します。

改行を探索するには、`C-j'を打ちます。コントロールSや改行などのコントロー
ル文字を探索するには、まず`C-q'を打ってクォートする必要があります。
`C-q'のこの機能は、挿入時の利用法に似ています（*Note Inserting Text::）。
このコマンドは、あとに続く文字を、同じ文脈における『普通の』文字と同様
に扱うようにします。文字を8進コードで指定することもできて、`C-q'に続け
て8進数字列を入力します。

`C-r'を使えば、後向き探索に変更できます。ファイルのうしろのほうで探索
し始めたために探索に失敗したのであれば、これを試してください。`C-r'を
繰り返し打つと、後向きにさらに探索を続けます。`C-s'は、ふたたび前向き
探索を再開します。探索中の`C-r'はDELで取り消せます。

始めから後向きで探索するのであれば、`C-s'のかわりに`C-r'を使って探索を
始めます。`C-r'は、後向きに探索するコマンド`isearch-backward'を起動し
ます。前向き探索が開始位置よりうしろにある一致箇所をみつけるのと同様に、
後向き探索は開始位置よりまえにある一致箇所をみつけだします。

インクリメンタルサーチ中には、文字`C-y'と`C-w'を使って、バッファから探
索文字列へテキストを取り込むことができます。この機能は、ポイント位置に
あるテキストの出現箇所を探すときに便利です。`C-w'は、ポイント以降の単
語を探索文字列の一部としてコピーし、ポイントをその単語の末尾に進めます。
探索を繰り返す意味で`C-s'を打つと、その単語を含んだ文字列を探索します。
`C-y'も`C-w'に似ていますが、現在行の残りの部分をすべて探索文字列にコピー
します。大文字小文字を区別しない探索では、`C-y'と`C-w'はともに、コピー
するテキストを小文字だけに変換します。

文字`M-y'は、キルリングから探索文字列にテキストをコピーします。これに
は、ヤンクコマンド`C-y'がヤンクするのと同じテキストを用います。*Note
Yanking::。

インクリメンタルサーチを終了すると、探索開始前にポイントが*あった*位置
にマークを置きます。これにより容易にその位置に戻れます。暫定マーク
（transient-mark）モードでは、マークが不活性のときに限って、インクリメ
ンタルサーチが設定するマークも不活性です。

インクリメンタルサーチ中に用いる特別な文字をカスタマイズするには、キー
マップ`isearch-mode-map'中のバインディングを変更します。バインディング
一覧は、`C-h f isearch-mode RET'を使って`isearch-mode'に関する説明文を
参照してください。


低速端末でのインクリメンタルサーチ
----------------------------------

速度の遅い端末でのインクリメンタルサーチでは、表示時間が少なくてすむよ
うに設計された表示形式を使います。みつけた箇所でバッファを再表示するか
わりに、新たに1行分のウィンドウを作ってそこにみつけた行を表示します。
この1行分のウィンドウは、探索することでポイントが画面に表示中のテキス
トから飛び出た時点で使われます。

探索を終了すると、この1行分のウィンドウは消えます。そして、Emacsは探索
を完了したウィンドウを再表示して、新たなポイント位置を示します。


低速向けの表示形式を使うのは、端末のボーレートが変数
`search-slow-speed'の値以下である場合で、その初期値は1200です。

低速向けの表示形式に使う表示用ウィンドウの行数は、変数
`search-slow-window-lines'で制御します。通常の値は1です。



File: emacs-ja.info, Node: Nonincremental Search, Next: Word Search, Prev: Incremental Search, Up: Search

一括型探索
==========

Emacsでは、従来方式の一括型探索コマンドもあります。探索を開始するまえ
に探索文字列全体を打っておく必要があります。

`C-s RET STRING RET'
     STRINGを探索する。
`C-r RET STRING RET'
     STRINGを後向きに探索する。

一括型探索を実行するには、まず`C-s RET'と打ちます。すると、探索文字列
を読み取るためにミニバッファに移動します。文字列をRETで終えると、探索
を開始します。文字列がみつからなければ、探索コマンドはエラーになります。

`C-s RET'はつぎのように動作します。まず、`C-s'がインクリメンタルサーチ
を起動します。インクリメンタルサーチは、特別な場合として、引数が空であっ
たときには一括型探索を起動するようにプログラムしてあります。（さもなけ
れば、そのような空の引数に意味はない。）`C-r RET'もこのように動作しま
す。

しかし、`C-s RET'で実行される一括型探索は、`search-forward'をただちに
呼び出すわけではありません。まず、つぎの文字が単語探索を指示する`C-w' 
であるかどうか調べます。*Note Word Search::。

前向き／後向きの一括型探索は、コマンド`search-forward'と
`search-backward'で実装されています。これらのコマンドは通常と同じよう
にキーにバインドできます。インクリメンタルサーチコマンドから呼び出せる
ようになっているのは、歴史的な理由、および、これらの機能にふさわしいキー
列を選ぶ労力を削減できるという理由からです。



File: emacs-ja.info, Node: Word Search, Next: Regexp Search, Prev: Nonincremental Search, Up: Search

単語探索
========

単語探索は、単語の区切られ方を無視して、単語の列を探索します。より正確
には、空白1個で区切った数個の単語を打ち込むと、単語と単語のあいだに複
数個の空白／改行／句読点があったとしても、それらの文字列をみつけだすこ
とができます。

単語探索は、テキスト清書系で整形済みの文書を編集する場合に便利です。整
形した印刷出力を見ながら編集する場合、ソースファイルのどこで行が区切ら
れているのかわかりません。単語探索を使えば、単語の区切られ方を知らなく
ても探索できます。

`C-s RET C-w WORDS RET'
     句読点などの詳細は無視して、WORDSを探索する。
`C-r RET C-w WORDS RET'
     句読点などの詳細は無視して、後向きにWORDSを探索する。

単語探索は、一括型探索の特別な場合であって、`C-s RET C-w'で起動します。
この入力に続いて、探索文字列を入力し、文字列はつねにRETで終えます。一
括型であるため、単語探索も引数を入力し終えるまで探索を開始しません。単
語探索は、正規表現を構築し、その正規表現で探索を行うことで動作します。
*Note Regexp Search::。

後向きの単語探索には`C-r RET C-w'を使います。

前向き／後向きの単語探索は、それぞれ、コマンド`word-search-forward'と
`word-search-backward'で実装されています。これらのコマンドは通常どおり
キーに割り当てることができます。インクリメンタルサーチコマンドから呼び
出せるようになっているのは、歴史的な理由、および、これらの機能にふさわ
しいキー列を選ぶ労力を削減できるという理由からです。



