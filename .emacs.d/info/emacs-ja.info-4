Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Regexp Search, Next: Regexps, Prev: Word Search, Up: Search

正規表現探索
============

"正規表現"（regular expression、"regexp"と略す）とは、一致する可能性が
ある一連の（無限個でもよい）文字列を表現するパターンです。GNU Emacsで
は、インクリメンタルサーチでも一括型探索でも、正規表現を用いてつぎの一
致箇所を探索できます。

正規表現によるインクリメンタルサーチを実行するには、`C-M-s'
（`isearch-forward-regexp'）と打ちます。このコマンドは、`C-s'と同様に、
探索文字列を逐次読み取ります。ただし、探索文字列をバッファのテキストに
対して正確に照合するためのものとみなすのではなく、正規表現として扱いま
す。探索文字列にテキストを追加するごとに、正規表現は長くなり、新たな正
規表現を探索します。（値は関係ない）前置引数を指定して`C-s'を起動して
も、前向きに正規表現の探索を始められます。後向きに正規表現を探索するに
は、`C-M-r'（`isearch-backward-regexp'）を使うか、前置引数を指定して
`C-r'を使います。

通常のインクリメンタルサーチにおいて特別な機能を持つコントロール文字は、
正規表現のインクリメンタルサーチでも同じ機能を持ちます。探索の開始直後
に`C-s'や`C-r'を打つと、最後のインクリメンタルサーチに用いた正規表現を
再度使います。つまり、正規表現を用いる探索とそうでない探索とには、それ
ぞれ独立のデフォルトがあるのです。`M-p'と`M-n'で参照できる探索リングも
それぞれ別々です。

正規表現のインクリメンタルサーチでSPCを打つと、改行を含めた任意個の白
文字に一致します。ちょうど1個の空白に一致させたいのであれば、`C-q SPC'
と打ちます。

正規表現のインクリメンタルサーチ中に正規表現に文字を加えると、カーソル
をもとに戻して探索し直すことがあります。たとえば、`foo'を探索し終えた
ときに`\|bar'を追加したとします。最初の`bar'が最初の`foo'に先行する場
合には、カーソルはまえに戻ります。

正規表現の一括型探索は、関数`re-search-forward'と`re-search-backward'
で行われます。これらは、`M-x'で呼び出したり、キーに割り当てたり、ある
いは、`C-M-s RET'や`C-M-r RET'として正規表現のインクリメンタルサーチの
方法で起動したりできます。

正規表現のインクリメンタルサーチコマンドに前置引数を指定すると、
`isearch-forward'や`isearch-backward'のように、普通の文字列探索を行い
ます。*Note Incremental Search::。



File: emacs-ja.info, Node: Regexps, Next: Search Case, Prev: Regexp Search, Up: Search

正規表現の構文
==============

正規表現には、特別な使い方をする少数の文字とその他の"普通の"文字から成
る構文があります。普通の文字は、同じ文字だけに一致してそれ以外には一致
しない単純な正規表現です。特別な文字は、`$'、`^'、`.'、`*'、`+'、`?'、
`['、`]'、および、`\'です。`\'が先行する場合を除いて、正規表現に現れる
これら以外の文字は普通の文字です。

たとえば、`f'は特別な文字ではなく、通常の文字ですから、文字列`f'に一致
してそれ以外の文字列には一致しない正規表現です。（これは、文字列`ff'に
は一致し*ない*。）同様に、`o'は、`o'だけに一致する正規表現です。（大文
字小文字を区別しない場合、これらの正規表現は`F'や`O'にも一致するが、こ
れらは例外というよりは、『同じ文字列』の一般化として捉える。）

任意の2つの正規表現AとBを連結できます。その結果は、Aが文字列の始めの適
当な部分に一致して、かつ、Bが文字列の残りの部分に一致する場合に、文字
列に一致するような正規表現です。

簡単な例として、正規表現`f'と`o'を連結すると、正規表現`fo'を得ますが、
これは文字列`fo'だけに一致します。簡単ですね。多少とも複雑なことを行う
には、特別な文字を使う必要があります。以下にその一覧をあげます。

`. （ピリオド）'
     特別な文字であり、改行以外の任意の1文字に一致する。連結を使って
     `a.b'のような正規表現を作れる。これは、`a'で始まり`b'で終る任意の
     3文字の文字列に一致する。

`*'
     単独では構成要素ではない。直前の正規表現を可能な限り反復すること
     を意味する後置演算子である。すなわち、（`o'が存在しない場合も含め
     て）`o*'は任意個の`o'に一致する。

     `*'はつねに先行する*最小*の正規表現に適用される。したがって、
     `fo*'は`fo'を繰り返すのではなく、`o'を繰り返す。この正規表現は`f'、
     `fo'、`foo'などに一致する。

     `*'を用いた構成は、一致を処理するときには、ただちに得られる限りの
     反復回数に展開される。そうしてから、残りのパターンを処理する。一
     致に失敗すると、バックトラック（後戻り）が発生して、`*'を用いた構
     成の反復回数を減らして、パターンの残りの部分が一致するようにする。
     たとえば、文字列`caaar'に対して`ca*ar'を一致させることを考えてみ
     る。始めに、`a*'を3つの`a'すべてに一致させようとする。しかし、残
     りのパターンが`ar'なのに`r'しか残っていないため、この試みは失敗す
     る。そこで、つぎは`a*'を`a'2つだけに一致させる。こうすると、残り
     の正規表現も正しく一致する。

`+'
     `*'に似た後置演算子だが、直前の正規表現に1回以上一致する必要があ
     る。たとえば、`ca+r'は、文字列`car'や`caaaar'には一致するが、文字
     列`cr'には一致ない。`ca*r'の場合は、上記の3つすべてに一致する。

`?'
     `*'に似た後置演算子だが、直前の正規表現に1回だけ一致するか、ある
     いは、1回も一致しない。たとえば、`ca?r'は、`car'や`cr'に一致する
     が、他のものには一致しない。

`[ ... ]'
     `['で始まり`]'で終る"文字集合"を表す。もっとも単純な場合は、この2
     つの中括弧のあいだにある文字の1つ1つがこの文字集合に一致する。

     したがって、`[ad]'は、`a'1文字か`d'1文字のどちらにも一致する。
     `[ad]*'は、`a'と`d'だけから成る（空の文字列を含む）任意の文字列に
     一致する。このことから、`c[ad]*r'は、`cr'、`car'、`cdr'、
     `caddaar'などに一致することがわかる。

     文字集合には、文字範囲の指定を含めることもでき、始めの文字と終り
     の文字のあいだに`-'を書く。つまり、`[a-z]'はすべてのASCII小文字に
     一致する。範囲指定と個々の文字を自由に織り混ぜてよく、`[a-z$%.]'
     のように書ける。これは、任意のASCII小文字、`$'、`%'、ピリオドに一
     致する。

     文字集合の内側では、正規表現の通常の特別な文字を特別扱いしないこ
     とに注意。文字集合の内側では、まったく別の特別な文字、`]'、`-'、
     および、`^'が存在する。

     文字集合に`]'を含めるには、`]'を最初の文字として指定する必要があ
     る。たとえば、`[]a]'は、`]'や`a'に一致する。`-'を含めるのであれば、
     `-'を文字集合の最初の文字か最後の文字として指定して、範囲指定のあ
     とに置く。したがって、`[]-]'は、`]'と`-'の両方に一致する。

     文字集合に`^'を含めるには、`^'を文字集合の2番目以降に置く。

     大文字小文字を区別する探索で文字範囲を指定するときは、範囲の両端
     を、大文字だけ、小文字だけ、あるいは、英字以外だけで書くべきであ
     る。`A-z'のような大文字小文字を混ぜた文字範囲の動作は、定義が明確
     ではなく、将来のEmacsでは変更するかもしれない。

`[^ ... ]'
     `[^'は"文字の補集合"の始まりを意味し、指定した文字を除く任意の文
     字に一致する。すなわち、`[^a-z0-9A-Z]'は、英文字と数字を*除く*す
     べての文字に一致する。

     `^'は先頭になければ文字集合では特別な意味を持たない。`^'に続く文
     字は先頭にあるものとして扱われる（いいかえれば、ここでは`-'や`]'
     は特別な意味を持たない）。

     文字の補集合は、一致しない文字として改行を指定しない限り、改行に
     も一致する。この点は、`grep'のようなプログラムでの正規表現の扱い
     方と対照的。

`^'
     空の文字列に一致する特別な文字で、テキスト行の先頭のみに一致する。
     それ以外では、一致に失敗する。したがって、`^foo'は、行頭にある
     `foo'に一致する。

`$'
     `^'と似ていて、行末のみに一致する。したがって、`x+$'は、行末にあ
     る1文字以上の`x'から成る文字列に一致する。

`\'
     2つの機能がある。（`\'を含む）特別な文字をクォートする（意味を抑
     える）ことと、特別な構成を導入すること。

     `\'は特別な文字をクォートするので、`\$'は文字`$'だけに一致する正
     規表現、`\['は文字`['だけに一致する正規表現、というようになる。

注意：` '従来との互換性のために、特別な文字が、それらの特別な意味をな
しえない文脈で使われた場合には、普通の文字として扱われます。たとえば、
`*foo'では、`*'の対象となる正規表現が直前にないため、`*'は普通の文字と
して扱われます。このようなふるまいに依存することはよい習慣ではありませ
ん。特別な文字を書く位置に関係なく特別な文字はクォートするべきです。

多くの場合、任意の文字を伴う`\'はその文字だけに一致します。しかし、い
くつか例外があって、`\'で始まる2文字列が特別な意味を持つ場合があります。
2文字目にくる文字は、単独で使った場合には普通の文字として扱われるもの
です。以下に`\'の構成を列挙します。

`\|'
     選択肢を指定する。`\|'をあいだに伴った2つの正規表現AとBは、AかBの
     いずれかに一致する文字列に一致する正規表現となる。

     したがって、`foo\|bar'は、`foo'か`bar'に一致するが、それ以外の文
     字列には一致しない。

     `\|'は、周囲にある適用しうる正規表現の中でも最大のものに適用され
     る。`\|'によるグループ化を制限するのは、これを囲む`\( ... \)'によ
     るグループ化だけ。

     何度`\|'を使っても処理できるだけの十分なバックトラック能力がある。

`\( ... \)'
     以下の3つの目的を果たすグループ化のための構成。

       1. 他の操作に使うために一連の選択肢`\|'を括る。したがって、
          `\(foo\|bar\)x'は、`foox'か`barx'のいずれかに一致する。

       2. 後置演算子、`*'、`+'、`?'を適用できるように、複雑な正規表現
          を括る。したがって、`ba\(na\)*'は、`bananana'のように、（0個
          以上の）任意個の文字列`na'に一致する。

       3. あとで参照できるように、一致した部分文字列を記録する。

     最後の使い方は、括弧によるグループ化という考え方から派生したもの
     ではない。同一の`\( ... \)'構成に与えた2つめの別の機能である。実
     用上、これら2つの意味が混同されることはない。

`\D'
     D番目に現れた`\( ... \)'に一致したテキストと同じテキストに一致す
     る。

     一致を処理するときには、`\( ... \)'構成の末尾に達すると、この構成
     に一致したテキストの始めと終りを記録する。そして、正規表現のそれ
     よりうしろでは、『D番目に現れた`\( ... \)'に一致したテキスト』と
     いう意味で`\'に続けて数字Dを使える。

     1つの正規表現内に現れる最初の9個の`\( ... \)'に一致する文字列には、
     正規表現中で開き括弧が現れた順に、1から9までの番号を割りふる。そ
     のため、`\1'から`\9'で、対応する`\( ... \)'に一致したテキストを参
     照できる。

     たとえば、`\(.*\)\1'は、改行を含まない文字列で、かつ、前半と後半
     が同一である文字列に一致する。`\(.*\)'は前半部分に一致し、それは
     どのようなものでもかまわない。一方、それに続く`\1'は、前半部分と
     まったく同じテキストに一致しなければならない。

     ある`\( ... \)'が、（直後に`*'がある場合などに簡単に起こりえる）
     複数回一致する場合には、最後に一致したものだけを記録する。

`\`'
     空の文字列に一致するが、一致対象であるバッファや文字列の先頭に限
     る。

`\''
     空の文字列に一致するが、一致対象であるバッファや文字列の末尾に限
     る。

`\='
     空の文字列に一致するが、ポイント位置に限る。

`\b'
     同じく空の文字列に一致するが、単語の先頭や末尾に限る。したがって、
     `\bfoo\b'は、単語として独立して現れる`foo'に一致する。
     `\bballs?\b'は、単語として独立して現れる`ball'や`balls'に一致する。

     `\b'は、バッファの先頭や末尾にあるテキストとは無関係に、バッファ
     の先頭や末尾にも一致する。

`\B'
     空の文字列に一致するが、単語の先頭や末尾*以外*に限る。

`\<'
     空の文字列に一致するが、単語の先頭に限る。`\<'は、単語構成文字が
     続く場合に限って、バッファの先頭にも一致する。

`\>'
     空の文字列に一致するが、単語の末尾に限る。`\>'は、単語構成文字で
     終了している場合に限って、バッファの末尾にも一致する。

`\w'
     任意の単語構成文字に一致する。エディタの構文テーブルによってこの
     文字が決まる。*Note Syntax::。

`\W'
     単語構成文字以外の文字に一致する。

`\sC'
     構文がCである文字だけに一致する。ここで、Cは構文コードを表す文字。
     たとえば、`w'は単語構成要素を、`-'は白文字を、`('は開き括弧を表す
     といった具合。（改行を含む）白文字は、`-'や空白で表す。

`\SC'
     構文がCでない任意の文字に一致する。

単語や構文に関連する構成要素は、構文テーブル（*Note Syntax::）の設定で
制御されます。

複雑な正規表現を以下に示します。これは、任意個の白文字がうしろに続く文
末を認識するためにEmacsが使うものです。空白とタブ文字を区別できるよう
に、Lispの構文で示してあります。Lisp構文では、文字列定数はダブルクォー
トで始まり、ダブルクォートで終ります。`\"'は正規表現の一部としてのダブ
ルクォートを表し、`\\'は正規表現の一部としてのバックスラッシュを表しま
す。`\t'はタブ文字、`\n'は改行文字を表します。

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この正規表現は4つの部分が繋がってできています。ピリオド、`?'、`!'のい
ずれかに一致する文字集合。閉じ中括、2種類の引用符、括弧に一致する文字
集合の任意回数の繰り返し。バックスラッシュ付きの括弧で括った、行末、タ
ブ、空白2つのいずれかに一致する選択肢。白文字に一致する文字集合の任意
回数の繰り返し。

これと同じ正規表現を対話的に入力するときには、タブを入力するにはTABを
打ち、改行を入力するには`C-j'を打ちます。また、Lisp構文上ではバックス
ラッシュを2つ続けてますが、対話的に入力するには、1つのバックスラッシュ
だけを打ちます。



File: emacs-ja.info, Node: Search Case, Next: Replace, Prev: Regexps, Up: Search

探索と大文字小文字の区別
========================

Emacsのインクリメンタルサーチでは、小文字だけで探索文字列を指定すると、
探索対象のテキストの大文字小文字の違いを通常無視します。したがって、
`foo'を探索するように指定すると、`Foo'にも`foo'にも一致します。正規表
現、特に文字集合の場合でも同様です。`[ab]'は、`a'、`A'、`b'、`B'のいず
れにも一致します。

インクリメンタルサーチする探索文字列のどこかに大文字があると、大文字小
文字を区別して探索します。したがって、`Foo'の探索では、`foo'や`FOO'を
みつけだせません。このことは、文字列の探索だけでなく正規表現の探索にも
あてはまります。探索文字列から大文字を消去すれば、この効果はなくなりま
す。

変数`case-fold-search'に`nil'を設定すれば、大文字小文字の違いを含めて、
すべての文字はそのとおりに一致するようになります。これは、バッファごと
の変数です。変数を変更してもカレントバッファだけに影響しますが、変更可
能なデフォルトの値があります。*Note Locals::。この変数は、置換コマンド
（*Note Replace::）やミニバッファの履歴探索コマンド（*Note Minibuffer
History::）が行う探索を含む、一括型探索にも適用されます。



File: emacs-ja.info, Node: Replace, Next: Other Repeating Search, Prev: Search Case, Up: Search

置換コマンド
============

大域的な探索置換操作は、他のエディタ (1) (*Note Replace-Footnotes::) 
で必要なほどEmacsでは必要はありませんが、Emacsでも使えます。多くのエディ
タにあるような単純なコマンド`M-x replace-string'の他にも、パターンの各
出現ごとに置換するかどうか尋ねてくる`M-x query-replace'コマンドがあり
ます。

置換コマンドは、通常、ポイントからバッファの末尾までのテキストを操作し
ます。しかし、暫定マーク（transient-mark）モードでは、マークが活性であ
る場合にはリージョンを操作します。置換コマンドはどれも、1つの文字列
（や正規表現）を1つの置換文字列に置き換えます。コマンド
`expand-region-abbrevs'（*Note Expanding Abbrevs::）を使って、いくつか
の置き換えを並行に行うことができます。

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: emacs-ja.info  Node: Replace-Footnotes, Up: Replace

(1) エディタの中には、テキストに1か所の修正を加える場合でさえ、探索置
換操作が唯一の手段であるものもある。



File: emacs-ja.info, Node: Unconditional Replace, Next: Regexp Replace, Prev: Replace, Up: Replace

無条件置換
----------

`M-x replace-string RET STRING RET NEWSTRING RET'
     STRINGのすべての出現をNEWSTRINGで置換する。
`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するものすべてをNEWSTRINGで置換する。

ポイント以降にある`foo'のすべての出現を`bar'で置き換えるには、2つの引
数`foo'と`bar'を指定したコマンド`M-x replace-string'を使います。置換は
ポイント以降でのみ実施されますから、バッファ全体に対して置換を行いたい
ときには、まずバッファの先頭に移動しておく必要があります。バッファの末
尾までに現れるすべての出現を置換します。バッファの一部に置換を限定した
いときには、置換を実行するまえに、バッファの当該部分にナロイングしてお
きます（*Note Narrowing::）。暫定マーク（transient-mark）モードにおい
ては、リージョンが活性のときには、置換はリージョン内に限定されます。

`replace-string'を終了すると、ポイントは最後に置換した出現箇所に置かれ
ます。マークは（`replace-string'コマンドを起動したとき）以前のポイント
位置に設定されます。その位置に戻るには`C-u C-SPC'を使います。

数引数を指定すると、単語区切りで囲まれた出現だけを置換対象とします。引
数の値は関係ありません。



File: emacs-ja.info, Node: Regexp Replace, Next: Replacement and Case, Prev: Unconditional Replace, Up: Replace

正規表現による置換
------------------

`M-x replace-string'コマンドは、1つの文字列に正確に一致するものだけを
置き換えます。これに類似したコマンド`M-x replace-regexp'は、指定したパ
ターンに一致する任意のものを置き換えます。

`replace-regexp'では、NEWSTRINGが定数である必要はありません。REGEXPに
一致したものの全体あるいはその一部を参照できます。NEWSTRINGの中の`\&'
は、置換対象の文字列全体（つまり、REGEXPに一致したものの全体）を表しま
す。NEWSTRINGの中の`\D'（Dは数字）は、REGEXPの中のD番目の括弧のグルー
プ化部分に一致した部分を表します。置き換えるテキスト内に`\'を含めるに
は、`\\'と入力する必要があります。

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

たとえばこの例は、`cadr'を`cadr-safe'で、`cddr'を`cddr-safe'で置換しま
す。

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

この例は、逆の置換を行います。



File: emacs-ja.info, Node: Replacement and Case, Next: Query Replace, Prev: Regexp Replace, Up: Replace

置換コマンドと大文字小文字の区別
--------------------------------

置換コマンドの第1引数がすべて小文字である場合、`case-fold-search'が
`nil'以外であるときには、大文字小文字を区別せずに置換対象を探索します。
`case-fold-search'が`nil'であるときには、すべての探索において大文字小
文字を区別します。

さらに、引数NEWSTRINGが、すべて小文字、あるいは、一部が小文字のときに
は、置換コマンドは、各置換対象の大文字小文字のパターンを保存しようとし
ます。つまり、コマンド

     M-x replace-string RET foo RET bar RET

は、小文字の`foo'を小文字の`bar'に、すべて大文字の`FOO'を`BAR'に、大文
字で始まる`Foo'を`Bar'に置換します。（`replace-string'が区別できるのは、
これら3つの選択肢、つまり、小文字のみ、すべて大文字、大文字で始まるだ
け。）

置換文字列に大文字を使ったときには、これを挿入するときは大文字は大文字
のままです。第1引数に大文字を使ったときには、第2引数では大文字小文字を
変換せずにつねに指定どおりに置き換えます。同様に、`case-replace'や
`case-fold-search'に`nil'を設定すると、大文字小文字を変換せずに置換し
ます。



File: emacs-ja.info, Node: Query Replace, Prev: Replacement and Case, Up: Replace

問い合わせ型置換
----------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     STRINGのいくつかの出現をNEWSTRINGで置換する。
`C-M-% REGEXP RET NEWSTRING RET'
`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するもののいくつかをNEWSTRINGで置換する。

`foo'のすべての出現ではなく、そのうちのいくつかだけを`bar'に変更したい
ときには、通常の`replace-string'を使うことはできません。かわりに、
`M-%'（`query-replace'）を使います。このコマンドは`foo'の出現をみつけ
るたびに、その出現を表示し、置換するかどうか聞いてきます。
`query-replace'に数引数を指定すると、単語区切り文字で区切られた出現だ
けを対象とします。通常どおり`case-replace'が`nil'以外であれば、
`replace-string'と同じく、このコマンドも大文字小文字の違いを保存します。

問い合わせることを除けば、`query-replace'は`replace-string'と同様に動
作し、`query-replace-regexp'は`replace-regexp'と同様に動作します。この
コマンドは、`C-M-%'で実行できます。

STRINGの出現やREGEXPに一致したものが表示されたときに打てる文字はつぎの
とおりです。


`SPC'
     出現をNEWSTRINGで置換する。

`DEL'
     この出現を置換せずにつぎの出現箇所に進む。

`, （カンマ）'
     この出現を置換し、結果を表示する。そして、つぎに何をするか指示す
     る文字を聞いてくる。置換自体はすでに完了しているので、この状況で
     はDELとSPCは等価であり、つぎの出現箇所へ移動するという意味。

     この時点では、`C-r'（下記参照）を打って、置換したテキストを変更で
     きる。また、`C-x u'と打って、置換をアンドゥする（もとに戻す）こと
     もできるが、そうすると、`query-replace'を終了してしまう。さらに先
     の置換を行いたいときには、`C-x ESC ESC RET'を使って再開する必要が
     ある（*Note Repetition::）。

`RET'
     これ以上何も置換しないで終了する。

`. （ピリオド）'
     この出現を置換してから、これ以上探索せずに終了する。

`!'
     これ以降、問い合わせずに残りの出現すべてを置換する。

`^'
     誤って変更してしまった場合などに、1つまえの出現箇所（あるいは置換
     してしまった出現箇所）に戻る。これは、マークリングから位置を取り
     出して動作する。`query-replace'は直前の1つの置換位置だけを記録す
     るため、`^'を続けて入力しても意味はない。

`C-r'
     単にNEWSTRINGで置換するだけでなく、この出現を編集する必要がある場
     合などに、再帰編集レベルに入る。編集し終えて`C-M-c'で再帰編集を抜
     けると、つぎの出現箇所に移動する。*Note Recursive Edit::。

`C-w'
     出現を削除してから、`C-r'と同様に再帰編集レベルに入る。再帰編集を
     使って、削除したSTRINGの出現を置き換えるテキストを挿入する。編集
     し終えて`C-M-c'で再帰編集を抜けると、つぎの出現箇所に移動する。

`C-l'
     画面を再表示する。そうしたら、この出現に対して何を行うかを指示す
     る別の文字を打つ必要がある。

`C-h'
     これらのオプションの要約メッセージを表示する。そうしたら、この出
     現に対して何を行うかを指示する別の文字を打つ必要がある。

上記のコマンドの別名である文字が他にもいくつかあります。`y'、`n'、`q'
は、それぞれ、SPC、DEL、RETに等価です。

これ以外の文字は`query-replace'を終了し、その文字はキー列の一部になり
ます。したがって、`C-k'と打つと、`query-replace'を終了してから、行末ま
でをキルします。

一度抜けた`query-replace'を再開するには、`C-x ESC ESC'を使います。この
コマンドは`query-replace'を繰り返します。というのは、`query-replace'は
ミニバッファで引数を読み取るからです。*Note C-x ESC ESC: Repetition。

ファイル名に対して正規表現に一致する部分を置換することで、ファイルの改
名、コピー、リンクを行うdiredコマンドについては、*Note Transforming
File Names::も参照してください。



File: emacs-ja.info, Node: Other Repeating Search, Prev: Replace, Up: Search

他の探索繰り返しコマンド
========================

正規表現に一致するものをみつけるコマンドは、他にもいくつかあります。そ
れらは、ポイント位置からバッファの末尾までを操作対象とします。さらに、
パターンに大文字が含まれていないときや、`case-fold-search'が`nil'以外
であるときには、大文字小文字の違いを無視して一致を探します。


`M-x occur RET REGEXP RET'
     REGEXPに一致するものを含むバッファ内の各行の一覧を表示する。数引
     数で、一致した各行の前後何行を表示するか指定する。デフォルトは0行。
     バッファの一部に探索を制限するには、その部分にナロイングする
     （*Note Narrowing::）。

     出力を表示したバッファ`*Occur*'は、もとの文脈での出現位置を探すた
     めのメニューとして機能する。`*Occur*'に表示された出現を`Mouse-2'
     でクリックするか、あるいは、ポイントをそこに置いてRETを打つ。この
     操作により、探索を行ったバッファに切り替え、選択した出現のもとの
     位置にポイントを移動する。

`M-x list-matching-lines'
     `M-x occur'と同じ。

`M-x count-matches RET REGEXP RET'
     ポイント以降でREGEXPに一致するものの個数を表示する。

`M-x flush-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含む各行を削除する。

`M-x keep-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含ま*ない*各行を削除す
     る。

さらに、Emacsから`grep'を使って、一連のファイルに対して正規表現に一致
するものを探して、一致するものを含むファイルを順番に、あるいは、任意の
順に訪問できます。*Note Grep Searching::。


File: emacs-ja.info, Node: Fixit, Next: Files, Prev: Search, Up: Top

打ちまちがい訂正用コマンド
**************************

本章では、入力直後にテキストのまちがいに気づいたとき、あるいは、テキス
トを作成中に気が変わったときに特に便利なコマンドを説明します。

まちがった編集を訂正するもっとも基本的なコマンドは、アンドゥコマンド、
`C-x u'や`C-_'です。このコマンドは、（通常）1つのコマンド、コマンドの
一部分（`query-replace'の場合）、いくつかの連続した自己挿入文字をアン
ドゥします。`C-_'や`C-x u'を連続して繰り返すと、アンドゥ情報がある限り、
次々と以前の変更をアンドゥします。より詳しくは、*Note Undo::。

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.



File: emacs-ja.info, Node: Kill Errors, Next: Transpose, Up: Fixit

誤りの訂正
==========

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）。
`M-DEL'
     ポイントの直前の単語をキルする（`backward-kill-word'）。
`C-x DEL'
     ポイントから文の先頭までをキルする（`backward-kill-sentence'）。

DEL文字（`delete-backward-char'）はもっとも重要な訂正コマンドです。ポ
イントの直前にある文字を削除します。自己挿入文字のコマンドに続けてDEL
を打つと、そのコマンドを取り消すと考えることができます。しかし、コマン
ドを取り消す一般的な方法はDELであるなどと誤解しないでください。

まちがいが数文字よりも長いときには、`M-DEL'や`C-x DEL'を使うほうが便利
でしょう。`M-DEL'は直前の単語の先頭までをキルし、`C-x DEL'は直前の文の
先頭までをキルします。文を書いている途中で気が変わったときには、`C-x
DEL'が特に便利です。`M-DEL'と`C-x DEL'は、キルしたテキストを`C-y'や
`M-y'で戻せるように保存します。*Note Yanking::。

何を打とうとしているのか混乱したりわからなくなったりしたときには、打ち
まちがいがたとえ数文字であっても`M-DEL'はとても便利です。このような場
合、画面を見ながらでないとDELでは訂正できません。`M-DEL'ならば、ほとん
ど何も考えずに単語全体をキルして、入力を再開できます。



File: emacs-ja.info, Node: Transpose, Next: Fixing Case, Prev: Kill Errors, Up: Fixit

テキストの入れ替え
==================

`C-t'
     2つの文字を入れ替える（`transpose-chars'）。
`M-t'
     2つの単語を入れ替える（`transpose-words'）。
`C-M-t'
     釣り合っている2つの式を入れ替える（`transpose-sexps'）。
`C-x C-t'
     2つの行を入れ替える（`transpose-lines'）。

2つの文字を入れ替えてしまうというよくあるまちがいは、それらが隣接して
いるならば、`C-t'コマンド（`transpose-chars'）で直せます。通常、`C-t'
は、ポイントの両側にある文字を入れ替えます。行末では、行末の文字と改行
文字を入れ替えるという役に立たないことではなくて、`C-t'はその行の最後
の2文字を入れ替えます。よって、入れ替えまちがいにすぐに気づいたなら、
`C-t'だけで訂正できます。まちがいにすぐに気づかなかったときには、2つの
入れ替わっている文字のあいだにカーソルを移動する必要があります。空白と
そのまえの単語の最後の文字とを入れ替えてしまったときには、単語移動コマ
ンドでその場所へ戻るのがよいでしょう。それ以外の場合には、後向き探索
（`C-r'）が最良であることがままあります。*Note Search::。


`M-t'（`transpose-words'）は、
ポイントの直前の単語とポイントの直後の単語を入れ替えます。
ポイントは単語を1つ前向きに横断し、
ポイントの直前の単語かポイントを含む単語を前向きに引きずっていきます。
単語のあいだにある句読点文字は動きません。
たとえば、`FOO, BAR'は`BAR FOO,'ではなくて、
`BAR, FOO'と入れ替わります。

`C-M-t'（`transpose-sexps'）は、2つの式（*Note Lists::）を入れ替えるコ
マンドです。また、`C-x C-t'（`transpose-lines'）は、行を入れ替えます。
これらのコマンドは`M-t'に似た動作をしますが、テキストを構文単位に分け
る点が異なります。

入れ替えコマンドに数引数を指定すると、反復回数になります。ポイントの直
前やポイントを含む文字（単語、S式、行）をいくつ先の文字（単語、S式、行）
へ移動するか指定します。たとえば、`C-u 3 C-t'は、ポイントの直前の文字
を3文字先の文字へ移動します。つまり、`f-!-oobar'を`oobf-!-ar'にします。
これは `C-t'を3回繰り返したのと同じことです。`C-u - 4 M-t'は、ポイント
の直前の単語を4つまえの単語へ移動します。`C-u - C-M-t'は、引数を指定し
ない`C-M-t'の効果を打ち消します。

数引数0には特別な意味があります（さもないと、コマンドを0回繰り返しても
何もしない）。ポイントの直後の文字（単語、S式、行）とマークの直後の文
字（単語、S式、行）を入れ替えます。



File: emacs-ja.info, Node: Fixing Case, Next: Spelling, Prev: Transpose, Up: Fixit

大文字小文字変換
================

`M-- M-l'
     ポイントの直前の単語を小文字に変換する。`Meta--'はメタ・マイナス。
`M-- M-u'
     ポイントの直前の単語をすべて大文字に変換する。
`M-- M-c'
     ポイントの直前の単語を最初の文字だけ大文字にして残りを小文字にす
     る。

とてもよくあるまちがいは、単語を打つときに大文字小文字をまちがうことで
す。このため、単語の大文字小文字を変換するコマンド、`M-l'、`M-u'、
`M-c'に負の引数を指定すると、カーソル（ポイント）を移動しないという特
別な機能があります。単語を打ちまちがえたとすぐに気づいたときには、単に
大文字小文字を変換して、入力を続けられます。*Note Case::。



File: emacs-ja.info, Node: Spelling, Prev: Fixing Case, Up: Fixit

綴りの検査と訂正
================

本節では、1つの単語やバッファのある部分の綴りを検査するコマンドを説明
します。これらのコマンドは、Emacsの一部ではない綴り検査プログラム（ス
ペルチェッカ）ispellを使って動作します。*Note Ispell: (ispell.info)Top。

`M-x flyspell-mode'
     フライスペル（flyspell）モードをオンにする。綴り誤りのあるすべて
     の単語を強調表示する。
`M-$'
     ポイント位置にある単語の綴りを検査し訂正する（`ispell-word'）。
`M-TAB'
     綴り辞書に基づいてポイントの直前の単語を補完する
     （`ispell-complete-word'）。
`M-x ispell-buffer'
     バッファ内の各単語の綴りを検査し訂正する。
`M-x ispell-region'
     リージョン内の各単語の綴りを検査し訂正する。
`M-x ispell-message'
     引用部分を除いて、メイルメッセージの草稿の各単語の綴りを検査し訂
     正する。
`M-x ispell-change-dictionary RET DICT RET'
     辞書としてDICTを使ってispellプロセスを再起動する。
`M-x ispell-kill-ispell'
     ispellプロセスを終了させる。

フライスペル（flyspell）モードは、Emacsで編集しているときに全自動で綴
り検査をする方法です。単語を変更したり挿入したりするたびにその単語を検
査します。認識できない単語をみつけると、その単語を強調表示します。これ
はユーザーの編集には干渉しませんが、ある単語が強調表示されたら、その単
語へ移動して訂正できます。カレントバッファでこのモードをオン／オフする
には、`M-x flyspell-mode'と打ちます。

フライスペル（flyspell）モードがある単語を綴りまちがいであると強調表示
したときには、その単語を`Mouse-2'でクリックできます。すると、訂正候補
やどんな操作を行えるか表示されます。単語を手動で編集して好きなように訂
正してもかまいません。

Emacsの他の綴り検査機能は、明示的にコマンドを実行したときに単語の検査
を行います。バッファ全体やその一部分の綴りを検査する機能は、Emacsセッ
ション以外で作成した綴り誤りを含むかもしれないテキストには有益です。

ポイントの周りかポイントのつぎにある単語の綴りを検査し、場合によっては
訂正するには、`M-$'（`ispell-word'）コマンドを使います。単語が正しくな
いときには、その単語についてどうするかのさまざまな選択肢を提示します。

カレントバッファ全体を検査するには、`M-x ispell-buffer'を使います。カ
レントリージョンだけを検査するには、`M-x ispell-region'を使います。書
きかけの電子メイルメッセージの綴りを検査するには、`M-x ispell-message'
を使います。これは、バッファ全体を検査しますが、字下げしてある部分や他
のメッセージからの引用と思われる部分は検査しません。

これらのコマンドは、正しくない単語に出会うたびに、どうするか聞いてきま
す。通常、検査した単語に似ている『近い』単語をいくつか含めた選択肢一覧
を表示します。そうしたら、文字を打たなくてはなりません。以下に有効な返
答をあげます。

`SPC'
     この単語をスキップする。この単語は正しくないとしておくが、ここで
     は変更しない。

`r NEW RET'
     （今回だけは）NEWで置き換える。

`R NEW RET'
     単語をNEWで置き換える。さらに、バッファの他の箇所でも置き換えられ
     るように`query-replace'を実行する。

`DIGIT'
     （今回だけは）この単語を『近い』単語の1つで置き換える。『近い』単
     語にはそれぞれ数字が付いているので、その数字を打つ。

`a'
     正しくない単語を容認する。この編集セッションに限って、正しいかの
     ように扱う。

`A'
     正しくない単語を容認する。この編集セッションのこのバッファに限っ
     て、正しいかのように扱う。

`i'
     この単語を個人辞書ファイルに入れ、ispellは今後のセッションを含め
     てこれ以降この単語を正しいものとして扱う。

`u'
     この単語を小文字に変換して個人辞書ファイルに入れる。

`m'
     `i'と同様だが、辞書の補完情報も記録できる。

`l WORD RET'
     WORDに一致する単語を辞書から探す。みつかった単語は、新たな『近い』
     単語一覧となり、数字を打って置き換える単語を選べる。WORDには、ワ
     イルドカード`*'を使うこともできる。

`C-g'
     対話的な綴り検査を終了する。`C-u M-$'で、あとで再開できる。

`X'
     `C-g'と同じ。

`x'
     対話的な綴り検査を終了し、綴り検査を始めた箇所へポイントを戻す。

`q'
     対話的な綴り検査を終了し、ispellプロセスを終了させる。

`C-l'
     画面を再描画する。

`C-z'
     このキーは普通のコマンドの意味（Emacsを休止する、あるいは、このフ
     レームをアイコン化する）。

テキスト（text）モードやその関連したモードでは`M-TAB'キーにバインドし
てあるコマンド`ispell-complete-word'は、綴り訂正に基づいた補完一覧を提
示します。単語の始めの部分を挿入してから`M-TAB'と打つと、補完一覧ウィ
ンドウを表示します。補完一覧から1つを選ぶには、候補のうえで`Mouse-2'を
クリックするか、カーソルを補完ウィンドウの単語の箇所に移動してからRET
と打ちます。*Note Text Mode::。


一度綴り検査を行うと、ispellプロセスは（何かすることを待って）動き続け
ます。ですから、つぎに綴り検査コマンドを使うと、より早く実行を完了しま
す。ispellプロセスを取り除きたいときには、`M-x ispell-kill-ispell'を使
います。ispellプロセスは綴り訂正をしているとき以外には何もしないので、
通常はこのコマンドを使う必要はありません。

ispellは2つの辞書を使います。標準辞書と個人辞書です。変数
`ispell-dictionary'は、使用すべき標準辞書のファイル名を指定します。こ
の値が`nil'ならば、デフォルトの辞書を使います。`M-x
ispell-change-dictionary'コマンドはこの変数を設定して、設定した辞書を
使うようにispellサブプロセスを再起動します。



File: emacs-ja.info, Node: Files, Next: Buffers, Prev: Fixit, Up: Top

ファイルの扱い方
****************

オペレーティングシステムは、データを指定した"ファイル"（file）に恒久的
に保存します。ですから、Emacsで編集するテキストの多くはファイルから取
り込み、最終的にはファイルに格納されます。

ファイルを編集するには、Emacsに対してファイルを読むように指示して、ファ
イルの内容のコピーを入れたバッファを用意させる必要があります。これを、
ファイルを"訪問する／訪れる"（visiting）といいます。編集コマンドはバッ
ファ内のテキストに直接作用します。つまり、Emacs内にあるコピーを操作し
ます。バッファをファイルに"保存"（save）した場合に限り、変更はファイル
そのものに反映されます。

ファイルを訪問したり保存したりすることに加えて、Emacsは、ファイルを、
削除したり、コピーしたり、名前を変更したり、別のファイルへ追加したり、
複数の版を保持したり、ファイルディレクトリを操作したりできます。

* Menu:

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Version Control::     Version control systems (RCS, CVS and SCCS).
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* Remote Files::        Accessing files on other sites.
* Quoted File Names::   Quoting special characters in file names.



File: emacs-ja.info, Node: File Names, Next: Visiting, Up: Files

ファイル名
==========

ファイルを操作するほとんどのEmacsコマンドには、ファイル名を指定する必
要があります。（保存と復元の操作を除く。バッファはこれらの操作に対して
使うファイル名を記録している。）ファイル名は、ミニバッファを使って入力
します（*Note Minibuffer::）。長いファイル名の指定を簡単にする補完も使
えます。*Note Completion::。

多くの操作には、"デフォルトファイル名"があり、RETだけを打って空の引数
を指定した場合に使われます。通常、デフォルトファイル名は、カレントバッ
ファで訪問したファイルの名前です。こうすることで、Emacsのファイルコマ
ンドで当該ファイルを操作するのが簡単になります。

各バッファにはデフォルトディレクトリがあります。通常は、そのバッファの
訪問先のファイルのディレクトリと同じです。ディレクトリを指定しないでファ
イル名を入力すると、デフォルトディレクトリを使います。スラッシュ（`/'）
で始まらない相対的なディレクトリを指定すると、デフォルトディレクトリ相
対に解釈します。デフォルトディレクトリは変数`default-directory'に保持
されていて、バッファごとに別々の値を持ちます。

たとえば、デフォルトファイル名が`/u/rms/gnu/gnu.tasks'ならば、デフォル
トディレクトリは`/u/rms/gnu/'です。ディレクトリを指定しないで`foo'とだ
け打つと、`/u/rms/gnu/foo'を意味します。`../.login'は、`/u/rms/.login'
を意味します。`new/foo'は、ファイル名`/u/rms/gnu/new/foo'を意味します。

コマンド`M-x pwd'は、カレントバッファのデフォルトディレクトリを表示し、
コマンド`M-x cd'は、それを（ミニバッファで読んだ値に）設定します。バッ
ファのデフォルトディレクトリは、`cd'コマンドを使ったときだけ変更されま
す。ファイルを訪問しているバッファのデフォルトディレクトリは、訪問した
ファイルのディレクトリに初期化されます。`C-x b'で作ったバッファのデフォ
ルトディレクトリは、その時点のカレントバッファのデフォルトディレクトリ
と同じです。

デフォルトディレクトリは、ミニバッファでファイル名を読むときに、実際に
ミニバッファに表示されます。これには2つの目的があります。デフォルトが
何であるかを*示す*ことで、相対ファイル名を打ち込めるようにし、しかも、
その意味を確実に知ることができるようにします。もう1つは、デフォルトディ
レクトリを*編集*して、別のディレクトリを指定できるようにします。変数
`insert-default-directory'を`nil'に設定すると、デフォルトディレクトリ
を挿入しません。

ミニバッファで入力するとき、テキストの一部として入っているデフォルトディ
レクトリを無視して、絶対ファイル名を打っても何の問題もありません。最終
的なミニバッファの内容は不正なように見えても、そうではありません。たと
えば、ミニバッファには`/usr/tmp/'が入っていて`/x1/rms/foo'を追加すると、
`/usr/tmp//x1/rms/foo'となります。Emacsは連続した2個のスラッシュの始め
のスラッシュまでをすべて無視するので、結果として`/x1/rms/foo'となりま
す。*Note Minibuffer File::。

ファイル名の中の`$'は環境変数で置き換えられます。たとえば、シェルコマ
ンド`export FOO=rms/hacks'で、環境変数`FOO'を設定してあるとします。そ
うすると、`/u/rms/hacks/test.c'の略称として`/u/$FOO/test.c'や
`/u/${FOO}/test.c'を使えます。環境変数の名前は、`$'のうしろにある英数
字全部です。あるいは、`$'のうしろにある括弧で囲まれたものです。シェル
コマンドで設定した環境変数がEmacsに影響を及ぼすのは、Emacsを起動するま
えに設定したものに限ります。

名前の中に`$'があるファイルを参照するには、`$$'と打ちます。1個の`$'に
対して変数の置き換えを行うときに、この2個の`$'は1個の`$'に変換されます。
あるいは、ファイル名全体を`/:'でクォートします（*Note Quoted File
Names::）。

（変数の）置き換えを行うLisp関数は`substitute-in-file-name'です。置き
換えは、ミニバッファで読んだファイル名だけに適用されます。

変数`file-name-coding-system'に`nil'以外を設定すると、ファイル名に非
ASCIIを含めることができます。*Note Specify Coding::。



File: emacs-ja.info, Node: Visiting, Next: Saving, Prev: File Names, Up: Files

ファイルを訪問する
==================

`C-x C-f'
     ファイルを訪問する（`find-file'）。
`C-x C-r'
     ファイルを眺めるために訪問し、変更を許さない
     （`find-file-read-only'）。
`C-x C-v'
     最後に訪問したファイルのかわりに、別のファイルを訪問する
     （`find-alternate-file'）。
`C-x 4 f'
     別のウィンドウでファイルを訪問する（`find-file-other-window'）。
     選択されているウィンドウに表示されている内容は変化しない。
`C-x 5 f'
     新たなフレームでファイルを訪問する（`find-file-other-frame'）。選
     択されているフレームに表示されている内容は変化しない。
`M-x find-file-literally'
     ファイルの内容をいっさい変換せずに訪問する。

ファイルを"訪問する／訪れる"とは、ファイルの内容のコピーを編集できるよ
うにEmacsバッファに入れることです。Emacsは、訪問する各ファイルごとに新
たにバッファを作ります。バッファ名は、ディレクトリ部分を取りさったファ
イル名から作ります。たとえば、ファイル名`/usr/rms/emacs.tex'のバッファ
名は`emacs.tex'となります。その名前のバッファがすでに存在するならば、
まだ使われていない名前になるようなもっとも小さい数を使って、`<2>',
`<3>'などを付加して唯一の名前を作ります。

各ウィンドウのモード行にはウィンドウ内に表示しているバッファ名が示され
ているので、編集しているバッファが何かいつでもわかります。

編集コマンドによる変更は、Emacsバッファに対して行われます。バッファを"
保存"するまでは、変更は、訪問先のファイルや他のどんな恒久的なものにも
影響しません。バッファを保存するとは、バッファの現在の内容をそのバッファ
の訪問先のファイルに書き出すことです。*Note Saving::。

バッファに未保存の変更がある場合、バッファは"変更されている"といいます。
バッファを保存しないと変更内容が失われてしまうので、これは重要なことで
す。モード行の左端近くに2個の星印を表示して、バッファが変更されている
ことを示します。

ファイルを訪問するには、コマンド`C-x C-f'（`find-file'）を使います。こ
のコマンドに、訪問したいファイル名を続けてRETで終えます。

ファイル名はミニバッファ（*Note Minibuffer::）で読まれ、このときデフォ
ルトや標準的な方法の補完を使えます（*Note File Names::）。ミニバッファ
内で`C-g'と打てば、`C-x C-f'をアボートできます。

`C-x C-f'が正しく完了したことは、画面上に新たに現れるテキストとモード
行に現れる新たなバッファ名で確認できます。指定したファイルが存在せず作
成もできない場合や読めない場合には、エコー領域にエラーメッセージが表示
されます。

すでに訪問しているファイルを再度訪問すると、`C-x C-f'は別のコピーを作
らずに、そのファイルを入れた既存のバッファを選択します。しかし、そうす
るまえに、訪問してから、あるいは、保存してから以降にファイルが変更され
たかどうか検査します。ファイルが変更されていると警告メッセージを表示し
ます。*Note Interlocking::。

新たにファイルを作りたいときにはどうするのでしょう？` ' 単に訪問すれば
よいのです。Emacsはエコー領域に`(New File)'と表示しますが、それ以外に
関しては、あたかも空のファイルが存在するかのようにふるまいます。変更し
てから保存すれば、ファイルを作成できます。

Emacsはファイルの内容から、行区切りの方法、すなわち、（GNU/LinuxやUNIX
で使われる）改行、（Microsoftシステムで使われる）復帰改行、
（Machintoshで使われる）復帰のみを認識します。さらに、Emacsの通常の方
法、つまり、改行文字で行を区切るように内容を自動的に変換します。これは、
コーディングシステム変換（*Note Coding Systems::）の一般的な機能の一部
であり、さまざまの異なるオペレーティングシステムから持ってきたファイル
を同一の方法で編集できるようにします。テキストを変更してファイルに保存
すると、Emacsは逆変換を行い、必要ならば、改行を復帰改行や復帰のみに戻
します。

指定したファイルが実際にはディレクトリならば、`C-x C-f'はEmacsのディレ
クトリブラウザであるdiredを起動するので、ディレクトリの内容を『編集』
できます（*Note Dired::）。diredは、ディレクトリ内のファイルを、消去し
たり、眺めたり、操作するのに便利です。しかし、変数 
`find-file-run-dired'が`nil'ならば、ディレクトリを訪問しようとするとエ
ラーになります。

指定したファイル名にワイルドカード文字が含まれていると、Emacsは一致す
るすべてのファイルを訪問します。ワイルドカード文字そのものを含む名前の
ファイルを訪問するには、*Note Quoted File Names::。

オペレーティングシステムが変更を許さないファイルを訪問すると、Emacsは
バッファを読み出し専用に設定するので、修正できなかったり、修正できても
あとで保存に手間取ります。`C-x C-q'（`vc-toggle-read-only'）で、バッファ
を書き込み可能にできます。*Note Misc Buffer::。

ときには、自分でまちがって変更しないように、ファイルを読み出し専用で訪
問したい場合があります。そういう場合には、コマンド`C-x C-r'
（`find-file-read-only'）でファイルを訪問します。

（ファイル名をまちがって打ったりして）存在しないファイルを意図せずに訪
問してしまったときには、`C-x C-v'コマンド（`find-alternate-file'）を使っ
て本当の目的のファイルを訪問します。`C-x C-v'は`C-x C-f'と同様ですが、
（バッファが変更されていればまず保存するかどうか聞いてから）カレントバッ
ファを消去します。訪問するファイル名を読むときには、ミニバッファにデフォ
ルトファイル名全体を挿入し、ディレクトリ部分の直後にポイントを置きます。
これは、ファイル名をほんの少しまちがって入力したときに便利です。

存在するのに読めないファイルを訪問すると、`C-x C-f'はエラーを通知しま
す。

`C-x 4 f'（`find-file-other-window'）は、別のウィンドウで、指定したファ
イルを入れたバッファを選択することを除けば、`C-x C-f'と同じです。`C-x
4 f'を実行するまえに選択されていたウィンドウは、同じバッファを表示した
ままです。ウィンドウを1つだけ表示しているときにこのコマンドを使うと、
そのウィンドウを2つに分けて、一方のウィンドウにはまえと同様に同じバッ
ファを表示しますが、もう一方には新たに指示したファイルを表示します。
*Note Windows::。

`C-x 5 f'（`find-file-other-frame'）も同様ですが、新たなフレームを開く
か、捜しているファイルを表示している既存のフレームを見えるようにします。
ウィンドウシステムを使っているときだけ、この機能を利用できます。*Note
Frames::。

特別な符号化や変換をせずにファイルを文字の列として編集したいときには、
`M-x find-file-literally'コマンドを使います。このコマンドは、`C-x C-f'
のようにファイルを訪問しますが、形式変換（*Note Formatted Text::）、文
字コード変換（*Note Coding Systems::）、（圧縮を）自動展開（*Note
Compressed Files::）といったことをしません。（そのままの文字の列として
ではなく）普通の方法で同じファイルをすでに訪問している場合には、このコ
マンドは、そのままの文字の列として訪問するかどうか聞いてきます。

2つの特別なフック変数で、ファイルを訪問する操作を修正して拡張できます。
存在しないファイルを訪問すると、`find-file-not-found-hooks'のリスト内
の関数群を実行します。この変数は関数のリストを保持していて、呼び出した
関数の中のどれかが`nil'以外を返すまで1つ1つ順に呼び出します。ファイル
が存在するかどうかに関わらず、どんなファイルを訪問するときでも
`find-file-hooks'には関数のリストが入っていると仮定され、それらの1つ1
つを順にすべて呼び出します。いずれの場合でも、関数は引数を受け取りませ
ん。2つの変数のうち、先に`find-file-not-found-hooks'を使います。これら
の変数はノーマルフックではありま*せん*。これらの名前が`-hook'ではなく
て`-hooks'で終っていることで、その事実を表しています。*Note Hooks::。

編集するファイルに対して自動的にメジャーモード（*Note Choosing Modes::）
を設定し、そのファイルに対して特別なローカル変数（*Note File
Variables::）を定義する方法がいくつかあります。



File: emacs-ja.info, Node: Saving, Next: Reverting, Prev: Visiting, Up: Files

ファイルを保存する
==================

Emacsにおいてバッファを"保存"するとは、バッファの内容をそのバッファの
訪問先のファイルへ書き戻すことです。

`C-x C-s'
     カレントバッファを訪問先のファイルに保存する（`save-buffer'）。
`C-x s'
     任意のバッファかすべてのバッファをそれぞれの訪問先のファイルに保
     存する（`save-some-buffers'）。
`M-~'
     カレントバッファを変更していないことにする（`not-modified'）。
`C-x C-w'
     カレントバッファを指定したファイルに保存する（`write-file'）。
`M-x set-visited-file-name'
     カレントバッファを保存するファイルの名前を変更する。

ファイルを保存して変更を恒久的なものとするには、`C-x C-s'
（`save-buffer'）と打ちます。保存を完了すると`C-x C-s'はつぎのようなメッ
セージを表示します。

     Wrote /u/rms/gnu/gnu.tasks

選択されているバッファが変更されていなければ（バッファを作って以降、あ
るいは、最後に保存して以降に、変更されていない）、保存しても何もならな
いので実際には保存しません。かわりに、`C-x C-s'はつぎのようなメッセー
ジをエコー領域に表示します。

     (No changes need to be saved)

コマンド`C-x s'（`save-some-buffers'）は、変更された任意のバッファやす
べてのバッファを保存できるようにします。各バッファについて、何をするか
聞いてきます。このとき選べる返答は、`query-replace'に対するものに似て
います。

`y'
     このバッファを保存し、残りのバッファについても質問する。
`n'
     このバッファを保存しないが、残りのバッファについては質問する。
`!'
     このバッファを保存し、残りのすべてのバッファについても質問せずに
     保存する。
`RET'
     何も保存せずに`save-some-buffers'を終了する。
`.'
     このバッファを保存し、他のバッファについては何も聞かずに
     `save-some-buffers'を終える。
`C-r'
     質問対象のバッファを閲覧する。閲覧（view）モードから抜けると、
     `save-some-buffers'に戻りふたたび質問する。
`C-h'
     これらのオプションについてのヘルプメッセージを表示する。

Emacsから抜けるキー列`C-x C-c'は、`save-some-buffers'を起動するので、
同じ質問をしてきます。

バッファを変更したけれども変更を保存したくないならば、それを避けるため
の処置をすべきでしょう。そうしないと、`C-x s'や`C-x C-c'を使うたびに、
まちがってバッファを保存してしまいがちです。1つの方法は、`M-~'
（`not-modified'）と打つことです。これは、バッファが変更されていること
を示すフラグを消します。こうしておくと、保存コマンドはバッファを保存す
る必要がないと結論します。（`~'は「否定」（not）を意味する数学記号とし
てしばしば使われる。よって`M-~'は、メタ付き「否定」。）
`set-visited-file-name'（下記参照）を使って、別のファイルを訪問してい
るバッファである旨の印を付けることもできます。このときファイル名には、
重要でない使っていないものを指定します。あるいは、ファイルからテキスト
を再度読み直して、ファイルを訪問したり保存したりした以降のすべての変更
を取り消します。これを"復元"（reverting）といいます。*Note Reverting::。
すべての変更がもとに戻るまでアンドゥコマンド`C-x u'を繰り返し使って、
変更しなかったことにもできます。しかし、復元のほうが簡単です。

`M-x set-visited-file-name'は、カレントバッファで訪問しているファイル
の名前を変更します。このコマンドは、ミニバッファで新たなファイル名を読
み取ります。そして、訪問先ファイル名を設定し直し、それに従って（新しい
名前が使われていなければ）バッファ名も変更します。
`set-visited-file-name'は、新たに指定した訪問先のファイルへはバッファ
を保存しません。あとで保存する場合に備えて、Emacs内部の記録を変更する
だけです。また、バッファには『変更された』旨の印を付け、`C-x C-s'がそ
のバッファを保存*しようとする*ようにします。

別のファイルを訪問しているという旨の印をバッファに付けて、ただちに保存
したい場合には、`C-x C-w'（`write-file'）を使います。このコマンドは、
`set-visited-file-name'に続けて`C-x C-s'を実行するのと等価です。ファイ
ルを訪問していないバッファに対して`C-x C-s'を使うことは、`C-x C-w'と同
じ効果があります。つまり、ファイル名を読み取り、バッファにはそのファイ
ルを訪問しているという印を付け、バッファをそのファイルに保存します。ファ
イルを訪問していないバッファのデフォルトのファイル名は、バッファのデフォ
ルトディレクトリとバッファ名を組み合わせて作ります。

新しいファイル名がメジャーモードを示唆するものであれば、`C-x C-w'は、
多くの場合、そのメジャーモードに切り替えます。コマンド
`set-visited-file-name'もそのようにします。*Note Choosing Modes::。

Emacsがファイルを保存しようとするときに、ディスク上の最新版の日付が
Emacsが最後に読み書きしたものと合わなかったら、Emacsはそのことを通知し
ます。というのは、同時に編集したために引き起こされた問題である可能性が
あるので、ユーザーにただちに知らせる必要があるからです。*Note
Interlocking::。

変数`require-final-newline'が`nil'以外だと、Emacsはファイルを保存する
たびに、ファイルの末尾に改行がなければ改行を挿入します。デフォルトは
`nil'です。

* Menu:

* Backup::              How Emacs saves the old version of your file.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.



File: emacs-ja.info, Node: Backup, Next: Interlocking, Up: Saving

バックアップファイル
--------------------

多くのオペレーティングシステムでは、ファイルを書き換えるとファイルに入っ
ていたそれまでの記録は自動的に破棄されます。したがって、Emacsでファイ
ルを保存すると、ファイルの古い内容は捨てられます。しかし、実際に保存す
るまえに、古い内容を"バックアップ"ファイルと呼ばれる別のファイルに
Emacsが注意深くコピーすれば、古い内容は破棄されません。

ほとんどのファイルでは、バックアップファイルを作るかどうかは変数
`make-backup-files'で決まります。多くのオペレーティングシステムでは、
この変数のデフォルト値は`t'であり、Emacsはバックアップファイルを作りま
す。

版管理システム（*Note Version Control::）が管理するファイルに対しては、
バックアップファイルを作るかどうかは変数`vc-make-backup-files'で決まり
ます。デフォルトは`nil'です。というのは、すべての古い版を版管理システ
ムに保管してあるので、バックアップファイルは冗長だからです。*Note VC
Workfile Handling::。

変数`backup-enable-predicate'のデフォルト値は、`/tmp'にあるファイルの
バックアップファイルを作らないようにします。

Emacsでは、単一のバックアップファイルを保持することも、編集した各ファ
イルごとに一連の番号付きバックアップファイルを保持することもできます。

Emacsがファイルのバックアップファイルを作るのは、バッファからそのファ
イルへ最初に保存したときだけです。たとえ何度ファイルを保存したとしても、
そのバックアップファイルは、ファイルを訪問する以前の内容を保持し続けま
す。通常これは、今の編集セッションを始める以前の内容をバックアップファ
イルが保持していることを意味します。しかしながら、バッファを消去してか
ら再度ファイルを訪問すると、それ以降に保存するときには新たにバックアッ
プファイルを作ります。

少なくとも一度は保存したとしても、バッファからもう1つバックアップファ
イルを作るように明示的に指示することもできます。`C-u C-x C-s'でバッファ
を保存すると、このとき保存した版は、バッファを再度保存するときにはバッ
クアップファイルになります。`C-u C-u C-x C-s'もバッファを保存しますが、
まずファイルの古い内容をバックアップファイルにします。`C-u C-u C-u C-x
C-s' はその両方を行います。ファイルの以前の内容からバックアップファイ
ルを作り、さらに、バッファを再度保存するとこのとき保存した版からもう1
つバックアップファイルを作るように準備します。

* Menu:

* Names: Backup Names.		How backup files are named;
				  choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.



File: emacs-ja.info, Node: Backup Names, Next: Backup Deletion, Up: Backup

単一バックアップファイルと番号付きバックアップファイル
......................................................

単一バックアップファイルを作ることを選択すると（デフォルト）、バックアッ
プファイルの名前は、編集しているファイルの名前に`~'を付加したものにな
ります。したがって、`eval.c'のバックアップファイルは`eval.c~'となりま
す。

番号付きの一連のバックアップファイルを作ることを選択すると、バックアッ
プファイルの名前は、もとのファイル名に`.~'と数字ともう1つ`~'を付加した
ものになります。したがって、`eval.c'のバックアップファイルは、
`eval.c.~1~'、`eval.c.~2~'、…、`eval.c.~259~'というようにどこまでも続
きます。

保護機構のために普通の名前でバックアップファイルを書けなくなると、ユー
ザーのホームディレクトリの`%backup%~'にバックアップファイルを書きます。
そのファイルはたった1つしか存在できないので、最新のバックアップにしか
利用できません。

単一バックアップか番号付きバックアップかの選択は、変数
`version-control'で制御されます。この変数に設定できる値はつぎのとおり
です。

`t'
     番号付きバックアップを作る。
`nil'
     ファイルに対して番号付きバックアップファイルがすでにあるならば番
     号付きバックアップを作る。さもなければ、単一バックアップを作る。
`never'
     どんな場合にも番号付きバックアップを作らない。つねに単一バックアッ
     プを作る。

各バッファではローカルに`version-control'を設定できるので、そのバッファ
のファイルに対するバックアップの作成方法を制御できます。たとえば、
rmailモードでは、rmailファイルのバックアップを1個だけに限定するために、
`version-control'にはローカルに`never'を設定します。*Note Locals::。

環境変数`VERSION_CONTROL'を設定すると、さまざまなGNUユーティリティにど
のようにバックアップファイルを扱うか指示できます。Emacsも環境変数に従っ
て動作し、開始時にそれに一致するようにLisp変数`version-control'を設定
します。環境変数の値が`t'か`numbered'なら、`version-control'は`t'にな
ります。環境変数の値が`nil'か`existing'なら、`version-control'は`nil'
になります。環境変数の値が`never'か`simple'なら、`version-control'は
`never'になります。



File: emacs-ja.info, Node: Backup Deletion, Next: Backup Copying, Prev: Backup Names, Up: Backup

バックアップの自動削除
......................

ディスク容量を無限に浪費することを避けるために、Emacsは番号付きバック
アップの版を自動的に削除できます。一般には、Emacsは始めの数個と最新の
数個のバックアップを残して、そのあいだのものをすべて削除します。これは、
新たにバックアップを作るごとに行われます。

2つの変数`kept-old-versions'と`kept-new-versions'は、このような削除を
制御します。それらの値は、それぞれ、新たにバックアップを作るときに、保
持すべき最古（番号が最小）のバックアップの個数、保持すべき最新（番号が
最大）のバックアップの個数です。それらの値は、バックアップの新版を作っ
た直後に使われることに注意してください。新たに作ったバックアップも、
`kept-new-versions'の数に含まれます。デフォルトでは、どちらの変数も2で
す。

`delete-old-versions'が`nil'以外ならば、何もいわずに余分な中間の版を削
除します。デフォルト値である`nil'ならば、余分な中間の版を削除するかど
うかを聞いてきます。

diredの`.'（ピリオド）コマンドも古い版を削除するために使えます。*Note
Dired Deletion::。



File: emacs-ja.info, Node: Backup Copying, Prev: Backup Deletion, Up: Backup

コピーと改名
............

バックアップファイルは、古いファイルをコピーする、あるいは、それを改名
することで作ります。古いファイルに複数の名前があると、これには違いが出
てきます。古いファイルを改名してバックアップファイルにすると、（古いファ
イルの）別の名前もバックアップファイルを指します。古いファイルをコピー
した場合には、（古いファイルの）別の名前は編集しているファイルを指し続
け、その名前で参照される内容も新しい内容になります。

バックアップファイルを作る方法は、元ファイルの所有者とグループにも影響
します。コピーするならば、何も変更されません。改名すると、ファイルの所
有者はあなたになり、ファイルのグループはデフォルトになります（オペレー
ティングシステムごとにグループのデフォルトは異なる）。

所有者を変更することは、多くの場合、よいことです。というのは、所有者が
つねに最後にファイルを編集した人を表すからです。同様に、バックアップの
所有者はその版を作った人を表します。ときには、ファイルの所有者を変更す
べきでないファイルがあります。そのようなファイルについては、
`backup-by-copying-when-mismatch'をローカルに設定するローカル変数リス
トをファイルに入れておくのがよいです。

改名するかコピーするかは、3つの変数で制御されます。デフォルトは、改名
です。変数`backup-by-copying'が`nil'以外ならばコピーします。`nil'のと
きには、変数`backup-by-copying-when-linked'が`nil'以外ならば、複数の名
前を持つファイルではコピーし、編集中のファイルには名前が1つだけなら改
名します。変数`backup-by-copying-when-mismatch'が`nil'以外のときには、
改名するとファイルの所有者やグループが変更されるときにはコピーします。
スーパーユーザーでEmacsを起動すると、`backup-by-copying-when-mismatch'
のデフォルトは`t'です。

ファイルを版管理システム（*Note Version Control::）で管理している場合
には、通常Emacsはそのファイルのバックアップを通常の方法では作りません。
チェックインとチェックアウトは、ある意味でバックアップを作ることに似て
います。残念なことに、これらの操作は典型的にはハードリンクを切るという
類似性があります。つまり、あるファイルの別の名前を使っていたとするとそ
のファイル名がなくなるのです。Emacsにできることはありません。版管理シ
ステムが処理します。



File: emacs-ja.info, Node: Interlocking, Prev: Backup, Up: Saving

同時編集に対する保護
--------------------

2人のユーザーが同じファイルを訪問し、両者がそれを編集し、両者がそれを
保存すると、同時編集が発生します。こういったことが起きていることを誰も
知らせなければ、最初に保存したユーザーは、あとになって自分の変更が失わ
れていることを知るでしょう。

ある種のシステムでは、2人目のユーザーがファイルを変更し始めたことを
Emacsがただちに検知して警告を発します。すべてのシステムでは、ファイル
を保存するときにEmacsが検査して、他人の変更を上書きしようとしているな
らば警告します。ファイルを保存するかわりに適切な修正操作を行えば、他人
の作業結果を失うことを避けられます。

ファイルを訪問しているEmacsバッファで初めて修正を行うと、Emacsはそのユー
ザーがファイルを"ロック"したと記録します。（同じディレクトリ内に異なる
名前のシンボリックリンクを作ることで実現する。）変更を保存するとEmacs
はロックを消します。つまり、ファイルを訪問しているEmacsバッファに未保
存の変更があるときにはファイルをロックしておくのです。

他人がロックしているファイルを訪問先とするバッファを修正し始めると"衝
突"が起こります。Emacsが衝突を検知すると、Lisp関数
`ask-user-about-lock'を呼び出して、どうするかを聞いてきます。この関数
をカスタマイズのために再定義することもできます。この関数の標準の定義で
は、ユーザーに質問をし、3つの返答を受理します。

`s'
     ロックを横取りする。ファイルをすでに変更していた人はロックを失い、
     あなたがロックを得る。
`p'
     続行する。誰かがファイルをロックしたままであるにもかかわらず、ファ
     イルを編集する。
`q'
     放棄する。これはエラー（`file-locked'）を引き起こし、バッファ内で
     修正しようとしたことは、実際には行われない。

ロックはファイル名に基づいて動作することに注意してください。ファイルに
複数の名前があると、Emacsには2つの名前が同じファイルであることはわから
ないので、2人のユーザーが異なる名前で同じファイルを編集することは防げ
ません。しかし、名前に基づいたロックなので、保存しない限り実在しない新
規ファイルの編集をEmacsはインターロック (1) (*Note
Interlocking-Footnotes::) できます。

Emacsがロックを作れる構成になっていないシステムもあります。また、ロッ
クファイルを書けない場合もあります。こういった状況では、Emacsがあらか
じめトラブルを検知することはできませんが、他人の変更を上書きしてファイ
ルを保存しようとしたときには、衝突を検知できます。

Emacsやオペレーティングシステムがクラッシュすると、古いロックファイル
が残っていることあります。そのため、ときどき偽の衝突についての警告を受
けとることがあるかもしれません。偽の衝突であると確信できれば、Emacsに
とにかく続行するように指示する`p'を使います。

Emacsは、バッファを保存するたびに、ディスク上のファイルの最終変更日時
が最後に訪問／保存したときから更新されていないことをまず検査します。変
更日時が不一致ならば、なんらかの方法でそのファイルが変更されたことを示
し、Emacsが本当に保存するとそれらの変更が失われてしまいます。これを避
けるために、Emacsは警告のメッセージを表示し、保存するまえに確認を求め
ます。ファイルが変更された理由を承知していて、それが問題でないことを知っ
ていることもあるでしょう。そうならば、`yes'と答えて続行できます。さも
なければ、`C-g'で保存を中断して、その事態を調査するべきです。

同時編集が発生したことを知らされたときにまず行うべきことは、`C-u C-x
C-d'（*Note Directories::）でディレクトリ一覧を見ることです。このコマ
ンドは、ファイルの現在の所有者を表示します。その人に連絡して、編集を続
けないように警告しましょう。そのつぎの段階は、別の名前でEmacsバッファ
を保存して、`diff'で2つのファイルを比較することでしょう。


File: emacs-ja.info  Node: Interlocking-Footnotes, Up: Interlocking

(1) 【訳注】進行中の動作が完了するまでは、つぎの動作を開始させないよう
にすること。



File: emacs-ja.info, Node: Reverting, Next: Auto Save, Prev: Saving, Up: Files

バッファを復元する
==================

広範囲にファイルを変更したあとで気が変わったときには、そのような変更を
捨てるためにファイルのまえの版を読み込みます。これには、カレントバッファ
に作用する`M-x revert-buffer'を使います。意図せずにバッファを復元する
ことは、たくさんの作業結果を失うことになるので、このコマンドには`yes'
で確認を与える必要があります。

`revert-buffer'は、ファイルの先頭から同じ距離（文字数）にポイントを保
ちます。少し編集しただけなら、復元前後のポイント位置はだいたい同じ部分
にあります。徹底的に変更してしまったときには、古いファイルでのポイント
位置ではまったく異なるテキスト部分に位置付けるでしょう。

復元すると、改めて変更するまでは、そのバッファには『変更なし』の印が付
きます。

diredバッファのように、ファイル以外のデータを反映するバッファでも復元
できる場合があります。その場合、復元とは、適切なデータに基づいて内容を
計算し直すことを意味します。`C-x b'で明示的に作ったバッファを復元する
ことはできません。そういった指示をすると、`revert-buffer'はエラーを報
告します。

自動的にかつ頻繁に変更されるファイル、たとえば、実行中のプロセスから出
力されるログ、を編集するときには、`C-x C-f'でファイルを再訪問すると何
も聞かずにファイルを復元できると便利です。

こういったふるまいを指示するには、変数`revert-without-query'に正規表現
のリストを設定します。これらの正規表現の1つにファイル名が一致すると、
`find-file'と`revert-buffer'は、バッファが変更されていない限り、そのファ
イルが変更されていても復元します。（テキストを編集してしまったときには、
変更を捨てさるのはまちがっている。）



File: emacs-ja.info, Node: Auto Save, Next: File Aliases, Prev: Reverting, Up: Files

自動保存、不慮の事故に対する備え
================================

Emacsは（打鍵数に基づいて）定期的に、訪問しているすべてのファイルを何
も聞かずに保存します。これを"自動保存"（auot-saving）と呼びます。これ
は、システムがクラッシュしたときに失ってしまう作業結果をある程度以下に
制限します。

自動保存を実施する時間になるとEmacsは各バッファを調べて、そのバッファ
に自動保存が指定されていて、かつ、最後に自動保存した以後に変更されてい
る場合は、そのバッファを自動保存します。実際にファイルを自動保存すると、
エコー領域にメッセージ`Auto-saving...'を表示します。自動保存の最中に発
生したエラーは捕獲されるので、打ち込んだコマンドの実行に干渉することは
ありません。

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.



File: emacs-ja.info, Node: Auto Save Files, Next: Auto Save Control, Up: Auto Save

自動保存ファイル
----------------

自動保存は、通常、訪問先のファイルそのものへは保存しません。というのは、
予定の半分を変更しただけでプログラムにまだ一貫性がないのに保存してしま
うのは望ましくないからです。そのかわりに"自動保存ファイル"と呼ばれる別
のファイルに自動保存し、（`C-x C-s'などで）明示的に保存するよう指示さ
れたときだけ、訪問先のファイルに保存します。

通常、自動保存ファイルの名前は、訪問先のファイルの名前の前後に`#'を付
加したものです。したがって、ファイル`foo.c'を訪問したバッファは、ファ
イル`#foo.c#'に自動保存されます。ファイルを訪問していないほとんどのバッ
ファは、明示的に指定したときだけ自動保存されます。それらのバッファの自
動保存ファイルの名前は、バッファ名のまえに`#%'、あとに`#'を付けたもの
になります。たとえば、送信するメッセージを作成するバッファ`*mail*'は、
`#%*mail*#'というファイルに自動保存されます。自動保存ファイルの名前は、
Emacsの一部（関数`make-auto-save-file-name'と`auto-save-file-name-p'）
をプログラムし直さない限り、この方法で作られます。バッファの自動保存に
使うファイル名は、そのバッファで自動保存をオンにしたときに計算されます。

大きなバッファで相当量のテキストを削除したときには、そのバッファの自動
保存を一時的にやめます。意図せずにテキストを削除してしまった場合には、
自動保存ファイルに削除してしまったテキストが残っているほうが、自動保存
ファイルとしてより役に立つからです。こうなったあとで自動保存をふたたび
オンにするには、`C-x C-s'でバッファを保存するか、`C-u 1 M-x auto-save'
を使います。

訪問先のファイルそのものに自動保存を行いたい場合には、変数
`auto-save-visited-file-name'に`nil'以外の値を設定します。こうすると、
自動保存と明示的な保存には、何の違いもありません。

訪問先のファイルにバッファを保存すると、バッファの自動保存ファイルは削
除されます。これを禁止するには、変数`delete-auto-save-files'に`nil'を
設定します。`C-x C-w'や`set-visited-file-name'で訪問先ファイル名を変更
すると、新たな訪問先ファイル名に合わせて自動保存ファイルも改名されます。



File: emacs-ja.info, Node: Auto Save Control, Next: Recover, Prev: Auto Save Files, Up: Auto Save

自動保存の制御
--------------

変数`auto-save-default'が`nil'以外ならば、ファイルを訪問するたびにその
ファイルのバッファの自動保存をオンにします（ただしバッチモードを除く。
*Note Entering Emacs::）。この変数のデフォルトは`t'なので、通常、ファ
イルを訪問したバッファは自動保存されます。コマンド`M-x auto-save-mode'
で、既存バッファの自動保存をオン／オフできます。他のマイナモードのコマ
ンドと同じように、正の引数を指定すると`M-x auto-save-mode'は自動保存を
オンにし、0か負の引数を指定すると自動保存をオフにし、引数を指定しない
と自動保存のオン／オフを切り替えます。

Emacsは、最後に自動保存してから何文字打鍵したかに基づいて定期的に自動
保存します。変数`auto-save-interval'には、自動保存の間隔を表す文字数を
指定します。デフォルトは300です。

しばらく打鍵しないでいるときにも自動保存は行われます。変数
`auto-save-timeout'は、自動保存（およびガベッジコレクション）を行うま
でにEmacsが待つべき秒数を表します。（カレントバッファが大きいと、実際
の時間間隔も長くなる。これは、大きなバッファの自動保存には時間がかかる
ので、その編集中は邪魔にならないようにするため。）アイドルのときには、
自動保存はつぎの2つのことを達成します。1つは、端末からしばらく離れてい
るときに、すべての作業結果が保存されることを保証すること。もう1つは、
実際に打鍵しているときの自動保存をいくぶんでも避けるようにすることです。

重大なエラーを受け取ったときにも、Emacsは自動保存を行います。これには、
`kill %emacs'のようなシェルコマンドでEmacsジョブを強制終了した場合や、
電話回線やネットワーク接続が途切れた場合を含みます。

コマンド`M-x do-auto-save'で、自動保存の実施を明示的に指示できます。



File: emacs-ja.info, Node: Recover, Prev: Auto Save Control, Up: Auto Save

自動保存ファイルからのデータ回復
--------------------------------

コマンド`M-x recover-file RET FILE RET'で、自動保存ファイルの内容から
紛失データを復旧できます。このコマンドは、FILEを訪問してから、（確認し
たあとで）その自動保存ファイル`#FILE#' から内容を回復します。そのあと
に、`C-x C-s'でFILEそのものに復旧したテキストを保存します。たとえば、
`foo.c'の自動保存のファイル`#foo.c#'から`foo.c'を復旧するにはつぎのよ
うにします。

     M-x recover-file RET foo.c RET
     yes RET
     C-x C-s

`M-x recover-file'は確認するまえに、指定したファイルと自動保存ファイル
が置かれたディレクトリの一覧を表示するので、それらのサイズや日付を比較
できます。自動保存ファイルのほうが古いと、`M-x recover-file'はそのファ
イルを読み込むようには聞いてきません。

Emacsやコンピュータがクラッシュしても、コマンド`M-x recover-session'を
使えば、編集中だったすべてのファイルを自動保存ファイルから復旧できます。
このコマンドは、まず、記録されている中断されたセッション一覧を表示しま
す。希望する箇所へポイントを移動し、`C-c C-c'と打ちます。

つぎに、 `recover-session'はそのセッションで編集中だった各ファイルにつ
いてそのファイルを復旧するか聞いてきます。`y'を答えると、
`recover-file'を呼び出し、普通のとおりに動作します。もとのファイルとそ
の自動保存ファイルの日付を表示し、ファイルを復旧するかどうかをもう一度
聞いてきます。

`recover-session'が終了すると、復旧を選んだファイルはEmacsバッファに入っ
ています。これらのバッファを保存してください。こうすることで初めてファ
イルに保存できます。

中断されたセッションは、あとで復旧するために`~/.saves-PID-HOSTNAME'と
いうファイルに記録されています。これらの名前の`~/.saves'の部分は、
`auto-save-list-file-prefix'の値です。この変数を個人の`.emacs'ファイル
で設定すれば、別の場所にセッション記録を置くことができます。しかし、同
様に`recover-session'も再定義して、変更した新しい場所を探すようにする
必要があります。個人の`.emacs'ファイルで`auto-save-list-file-prefix'に
`nil'を設定すると、復旧のためのセッションを記録しません。



File: emacs-ja.info, Node: File Aliases, Next: Version Control, Prev: Auto Save, Up: Files

ファイル名の別名
================

シンボリックリンクやハードリンクを使うことで、同じファイルをいくつかの
異なるファイル名で指すことができます。ハードリンクは、ファイルを直接に
指している別の名前です。すべての名前は等しく有効で、それらに優劣はあり
ません。対照的に、シンボリックリンクは定義された別名の一種です。`foo'
が`bar'へのシンボリックリンクであるとき、どちらの名前でもファイルを指
せますが、`bar'が本当の名前であり、`foo'は別名にすぎません。シンボリッ
クリンクがディレクトリを指しているときには、より複雑な状況になります。

同一のファイルに対して2つの名前で訪問すると、Emacsは通常2つの別々のバッ
ファを作成しますが、その状況を警告します。

同一のファイルを異なる名前で別々のバッファに訪問することを避けたいなら
ば、変数`find-file-existing-other-name'に`nil'以外の値を設定します。そ
うすれば、どのファイル名を指定しようとも、`find-file'はファイルを訪問
している既存のバッファを使います。

変数`find-file-visit-truename'が`nil'以外であれば、バッファに記録する
ファイル名は、ユーザーが指定した名前ではなくて、ファイルの（すべてのシ
ンボリックリンクをその先の名前に置き換えて得られる）"実名"になります。
`find-file-visit-truename'を設定すると、
`find-file-existing-other-name'も暗に設定されます。



File: emacs-ja.info, Node: Version Control, Next: Directories, Prev: File Aliases, Up: Files

VC（版管理、バージョンコントロール）
====================================

"版管理システム"は、ファイルの変更されていない部分を通常は一度だけ格納
して、ソースファイルの複数の版を記録できるパッケージです。版管理システ
ムは、各版の作成時刻、作成者、その版の変更部分に関する記述などの履歴情
報も記録します。

Emacsの版管理パッケージはVCと呼ばれます。このコマンドは、3つの版管理シ
ステム、RCS、CVS、SCCSで動作します。GNUプロジェクトでは、フリーソフト
ウェアでありFree Software Foundationから入手できるRCSとCVSを推奨します。

* Menu:

* Introduction to VC::  How version control works in general.
* VC Mode Line::     How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Old Versions::        Examining and comparing old versions.
* Secondary VC Commands::    The commands used a little less frequently.
* Branches::            Multiple lines of development.
* Snapshots::           Sets of file versions treated as a unit.
* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.



File: emacs-ja.info, Node: Introduction to VC, Next: VC Mode Line, Up: Version Control

VC入門
------

VCはEmacsから版管理システムを使えるようにして、編集作業を版管理操作に
滑らかに統合します。VCは統一された版管理インターフェイスを提供するので、
どの版管理システムを使っているかに関わらず、同じ使い方ができます。

本節では、版管理を概観するとともに、VCが扱う版管理システムの概要を説明
します。使用する版管理システムにすでに慣れているならば、本節は読み飛ば
してください。

* Menu:

* Version Systems::  Supported version control back-end systems.
* VC Concepts::      Words and concepts related to version control.



File: emacs-ja.info, Node: Version Systems, Next: VC Concepts, Up: Introduction to VC

利用可能な版管理システム
........................

VCでは、現在3つの版管理システム、つまり、バックエンドで動作します。RCS、
CVS、SCCSの3つです。

RCSはフリーの版管理システムでFree Software Foundationから入手ができま
す。RCSは、扱えるバックエンドの中では、たぶん、もっとも成熟したもので
す。VCコマンド群は、RCSに概念的にもっとも近いものです。RCSでできるほと
んどのことはVCからもできます。

CVSは、RCSの上に作られてRCSの機能を拡張していて、より洗練されたリリー
ス管理、複数ユーザーの並行開発を許しています。CVSの下では、VCの基本的
な編集操作を使えますが、あまり一般的でない操作に関しては、コマンド行か
らCVSを呼ぶ必要があります。CVSを使うには保管庫（リポジトリ、repository）
を設定しなければなりませんが、ここで扱うには複雑すぎる話題です。

SCCSはフリーではありませんが、版管理システムとしては広く使われています。
能力の観点からすれば、VCが扱える3つのうちでもっとも弱いです。SCCSに欠
けている機能（たとえばスナップショット）はVC自身で実現して補っています
が、複数の枝分かれのようなVCの他のいくつかの機能はSCCSでは利用できませ
ん。RCSを使えない理由があるときに限ってSCCSを使うべきです。



File: emacs-ja.info, Node: VC Concepts, Prev: Version Systems, Up: Introduction to VC

VCの概念
........

ファイルが版管理の管理下にあるとき、そのファイルは版管理システムに"登
録され"ているといいます。各登録されたファイルには、ファイルの現状とそ
の変更履歴を記述した対応する"マスタファイル"が存在します。この情報は、
現在の版や以前の版を再構成するのに十分です。通常、マスタファイルには、
それぞれの版について、その版の変更点を言葉で記述した"記録項目"も記録さ
れています。

版管理の下で管理されているファイルを、そのマスタファイルに対応する"作
業ファイル"と呼ぶこともあります。普通のファイルと同様に、作業ファイル
を編集して変更します。（SCCSやRCSでは、ファイルを編集するまえにファイ
ルを"ロック" (1) (*Note VC Concepts-Footnotes::) する必要がある。）一
連の変更を終えたら、ファイルを"チェックイン"、つまり、記録項目とともに
変更をマスタファイルに記録します。

CVSでは、1つのマスタファイルに対応する作業ファイルを複数個持てます。し
ばしば、各ユーザーが1個ずつ作業ファイルを持てます。RCSでもこのようにで
きますが、RCSの通常の使い方ではありません。

典型的な版管理システムには、複数のユーザーが同じファイルを使う際の調停
を行うためのなんらかの機構が必要です。1つの方法は（Emacsが同時編集の検
出に使うロックに類似だが、それとは別の）"ロック"を使うことです。別の方
法は、ファイルをチェックインする時点で、他人の変更分を併合することです。

ロックを使う版管理の場合、作業ファイルは変更できないように通常は読み出
し専用です。版管理システムに対して、書き込み可能な作業ファイルを作り、
それをロックするように要求します。一度には1人のユーザーだけがこれをで
きます。自分の変更分をチェックインすると、ファイルのロックを外し、作業
ファイルをふたたび読み出し専用にします。これにより、他のユーザーがさら
に変更するためにファイルをロックできるようになります。SCCSはつねにロッ
クを使いますし、RCSも通常はロックを使います。

RCSでは別の方法もあって、各ユーザーがいつでも作業ファイルを変更できま
す。このモードではロックは必要ありませんが、使うこともできます。新版を
記録する方法は、やはりチェックインです。

CVSでは、通常、各ユーザーはいつでも各自の作業ファイルを変更できますが、
チェックイン時に他のユーザーの変更分を併合する必要があります。しかし、
CVSでもロックを使うようにもできます（*Note Backend Options::）。


File: emacs-ja.info  Node: VC Concepts-Footnotes, Up: VC Concepts

(1) 【訳注】Emacsが同時編集を防ぐためのロックとは別のロック。



File: emacs-ja.info, Node: VC Mode Line, Next: Basic VC Editing, Prev: Introduction to VC, Up: Version Control

VCとモード行
------------

版管理の下にあるファイルを訪問すると、Emacsはそのことをモード行に示し
ます。たとえば、`RCS-1.3'は、そのファイルにはRCSが使われていて、現在の
版が1.3であることを表します。

バックエンドの名前と版番号のあいだの文字は、ファイルの版管理状態を示し
ます。`-'は、（ロックを使っているのであれば）作業ファイルがロックされ
ていないこと、あるいは、（ロックを使っていないのであれば）ファイルが変
更されていないことを表します。`:'は他のユーザー（たとえば、`jim'）がロッ
クしていることを表し、`RCS:jim:1.3'のように表示されます。



File: emacs-ja.info, Node: Basic VC Editing, Next: Old Versions, Prev: VC Mode Line, Up: Version Control

VC下の基本的な編集
------------------

主要なVCコマンドは、状況に応じてロックかチェックインを行う汎用コマンド
です。

`C-x C-q'
`C-x v v'
     このファイルに対して論理的なつぎの版管理操作を実施する。

正確にいえば、この操作を行うコマンドは`vc-next-action'であって、`C-x v
v'にバインドしてあります。しかし、`C-x C-q'の通常の意味は、読み出し専
用バッファを書き込み可能にするか、あるいは、その逆を行います。この操作
を、適切な版管理操作を実施することで版管理下で管理されているファイルに
対しても同じことを正しく行うように拡張したのです。登録されたファイルに
対して`C-x C-q'を打つと、`C-x v v'のように動作します。

このコマンドの正確な動作は、ファイルの状態と版管理システム（バックエン
ド）がロックを使うかどうかに依存します。SCCSとRCSは通常はロックを使い
ますが、CVSは通常はロックを使いません。

* Menu:

* VC with Locking::     RCS in its default mode, SCCS, and optionally CVS.
* Without Locking::     Without locking: default mode for CVS.
* Log Buffer::          Features available in log entry buffers.
               


File: emacs-ja.info, Node: VC with Locking, Next: Without Locking, Up: Basic VC Editing

ロック使用時の基本的な編集
..........................

（SCCSの場合とRCSのデフォルトの場合）ファイルに対してロックを使う場合、
`C-x C-q'は、ファイルをロックする、あるいは、ファイルをチェックインす
るのいずれかを行います。

   * ファイルがロックされていなければ、`C-x C-q'はそれをロックし、変更
     できるように書き込み可能にする。

   * 同じユーザーがファイルをロックしていて、かつ、変更されていれば、
     `C-x C-q'はチェックインを行う。このとき、新版に対する記録項目をま
     ず読み取る。*Note Log Buffer::。

   * 同じユーザーがファイルをロックしているが、ロックしてからまったく
     変更していないときには、`C-x C-q'はロックを外してファイルをふたた
     び読み出し専用にする。

   * 他のユーザーがファイルをロックしている場合、`C-x C-q'はそのユーザー
     から『ロックを横取りする』かどうか聞いてくる。横取りするように答
     えると、ファイルをロックし直すが、まえにロックしていたユーザーに
     はロックを横取りされたことを伝える。

以上の規則は、CVSでロックを使用している場合にも適用できますが、『ロッ
クを横取りする』ことはありません。



File: emacs-ja.info, Node: Without Locking, Next: Log Buffer, Prev: VC with Locking, Up: Basic VC Editing

ロック非使用時の基本的な編集
............................

CVSのデフォルトのように、ロックを使わないときには、作業ファイルはいつ
でも書き込み可能です。ファイルを編集するまえにすべきことは何もありませ
ん。モード行の状態表示は、ファイルが変更されていなければ`-'です。作業
ファイルに変更を保存するとただちに`:'に変わります。

以下は、CVSを使っているときの`C-x C-q'の動作です。

   * 他のユーザーが変更分をマスタファイルにチェックインしていると、そ
     れらを自分用の作業ファイルに併合（*Note Merging::）するかどうか聞
     いてくる。自分の変更分をチェックインするまえには、これを行う必要
     がある。

   * マスタファイルに新たな変更がなくても、自分用の作業ファイルを変更
     してある場合には、`C-x C-q'はその変更をチェックインする。これを行
     うために、新版に対する記録項目をまず読み取る。*Note Log Buffer::。

   * ファイルが変更されていなければ、`C-x C-q'は何もしない。

以上の規則は、RCSのロックを使わないモードにも適用できますが、マスタファ
イルから自動的に変更を併合する機能は実装してありません。残念なことに、
あなたが編集を始めたあとに、他のユーザーが同じファイルに変更をチェック
インしても何も警告されないのです。しかも、このような事態が発生すると、
あなたが自分の版をチェックインしたときに、そのユーザーの変更は実質的に
は取り除かれてしまいます（とはいえ、マスタファイルの中には残っているの
で、完全になくなるわけではない）。したがって、自分の変更をチェックイン
するまえには、現在の版が変更されていないことを確認する必要があります。
Emacsの将来の版では、このような危険性を取り除き、RCSでも自動併合を行え
るように考えています。

また、このモードでもRCSのロックを使えますが、必須ではありません。ファ
イルを変更していないときに`C-x C-q'を使うと、RCSの通常の（ロックを使う）
モードのように、ファイルをロックします。



