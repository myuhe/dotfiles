Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Log Buffer, Prev: Without Locking, Up: Basic VC Editing

記録項目用バッファの機能
........................

変更をチェックインすると、`C-x C-q'は記録項目をまず読みます。記録項目
を入力するように、`*VC-Log*'というバッファを立ち上げます。入力し終えた
ら、`*VC-Log*'で`C-c C-c'と打ちます。実際にチェックインを行うと、この
ように行われます。

チェックインをアボートするには、そのバッファでは`C-c C-c'を打た*ない*
でください。別のバッファに切り替えて、別の編集をします。別のファイルを
チェックインしようとしない限り、入力していた記録項目は`*VC-Log*'バッファ
に残っていますから、チェックインを完了するため、いつでもそのバッファに
戻れます。

複数のソースファイルを同じ理由で変更したときには、多くのファイルに同じ
記録項目を指定できると便利です。こうするには、まえの記録項目の履歴を使
います。コマンド、`M-n'、`M-p'、`M-s'、`M-r'は、ミニバッファの履歴コマ
ンドのように働きます（ただし、これらのコマンドはミニバッファの外部で使
う）。

ファイルにチェックインするたびに、記録項目用バッファはVC記録（vc-log）
モードになります。このモードは2つのフック、`text-mode-hook'と
`vc-log-mode-hook'を起動します。*Note Hooks::。



File: emacs-ja.info, Node: Old Versions, Next: Secondary VC Commands, Prev: Basic VC Editing, Up: Version Control

旧版の調査と比較
----------------

版管理の便利な機能の1つは、ファイルの任意の版を調べたり、2つの版を比較
できることです。

`C-x v ~ VERSION RET'
     訪問しているファイルの版VERSIONをそれ専用のバッファで調べる。

`C-x v ='
     カレントバッファの内容とファイルのチェックインした最新版とを比較
     する。

`C-u C-x v = FILE RET OLDVERS RET NEWVERS RET'
     FILEの指定した2つの版を比較する。

`C-x v g'
     表示色を変えてCVSの注記コマンドの結果を表示する。

1つの旧版を調べるには、ファイルを訪問して`C-x v ~ VERSION RET' 
（`vc-version-other-window'）と打ちます。これにより、ファイルの版
VERSIONのテキストを`FILENAME.~VERSION~'という名前のファイルに収め、別
のウィンドウのそれ専用のバッファでそのファイルを訪問します。（RCSでは、
旧版を選択して、それから枝分かれを作成できる。*Note Branches::。）

しかし通常は、コマンド`C-x v ='（`vc-diff'）でファイルの2つの版を比較
したほうが、もっと便利です。引数を指定しない`C-x v ='では、カレントファ
イルの内容（必要があればファイルに保存する）とファイルのチェックインし
てある最新版とを比較します。数引数を指定した`C-u C-x v ='では、ファイ
ル名と2つの版番号を読み取ってから、指定したファイルの2つの版を比較しま
す。

登録したファイルのかわりにディレクトリ名を指定すると、このコマンドは、
そのディレクトリとその下にあるサブディレクトリに置かれているすべての登
録されたファイルの指定した2つの版を比較します。

チェックインしてある版は、その番号で指定します。入力が空だと、（チェッ
クインしてある版とは異なるかもしれない）作業ファイルの現在の内容を指定
します。版番号のかわりに、スナップショット名（*Note Snapshots::）を指
定することもできます。

このコマンドは、変数`diff-switches'で指定されるオプションを用いて、
`diff'プログラムを実行して動作します。その出力は別のウィンドウの特別な
バッファに表示されます。`M-x diff'コマンドと違って、`C-x v ='では新版
と旧版の相違箇所には移動できません。というのは、通常、一方の版、あるい
は、両方の版は、比較するときにはファイルとしては存在していないからです。
それらは、マスタファイルの記録の中に存在するだけです。`M-x diff'につい
てより詳しくは、*Note Comparing Files::。

CVSで管理しているファイルに関しては、一目でわかるように複数の表示色を
使って、CVS注記コマンドの結果を表示できます。これには、`M-x
vc-annotate'を使います。赤は新版、青は旧版、それらの中間色は中間の版を
表します。数引数Nは、時間尺度を伸ばします。つまり、ある表示色で表す期
間をN倍します。



File: emacs-ja.info, Node: Secondary VC Commands, Next: Branches, Prev: Old Versions, Up: Version Control

VCの副次的なコマンド
--------------------

本節では、VCの副次的なコマンドを説明します。1日に一度くらい使うような
コマンドです。

* Menu:

* Registering::         Putting a file under version control.
* VC Status::           Viewing the VC status of files.
* VC Undo::             Cancelling changes before or after check-in.
* VC Dired Mode::       Listing files managed by version control. 
* VC Dired Commands::   Commands to use in a VC Dired buffer.



File: emacs-ja.info, Node: Registering, Next: VC Status, Up: Secondary VC Commands

VCへのファイル登録
..................

ファイルを訪問してから`C-x v i'（`vc-register'）と打つだけで、
ファイルを版管理の管理下に置けます。

`C-x v i'
     訪問したファイルを版管理に登録する。

ファイルを登録するには、Emacsはそのファイルに対してどの版管理システム
を使うか選ぶ必要があります。`vc-default-back-end'に、`RCS'、`CVS'、
`SCCS'のいずれかを設定すれば、明示的に指定できます。あるいは、`RCS'、
`SCCS'、`CVS'という名前のサブディレクトリがあるなら、Emacsは対応する版
管理システムを使います。指定がまったくなければ、デフォルトでは、RCSが
インストールされていればRCS、さもなければSCCSを選びます。

ロックを使用している場合には、`C-x v i'は、ファイルのロックを解除し読
み出し専用にします。ファイルの編集を始めたい場合には、`C-x C-q'と打ち
ます。CVSにファイルを登録したあとでは、`C-x C-q'と打って最初の版を記録
する必要があります。

新しく登録されたファイルの最初の版番号は、デフォルトでは1.1です。異な
るデフォルトを指定するには、変数`vc-default-init-version'に設定します。
あるいは、`C-x v i'に数引数を指定すると、そのファイルだけに使う最初の
版番号をミニバッファで読みます。

`vc-initial-comment'が`nil'以外ならば、`C-x v i'はこのソースファイルの
目的を記した初期コメントを読みます。これは記録項目（*Note Log Buffer::）
を読むのと同じように動作します。



File: emacs-ja.info, Node: VC Status, Next: VC Undo, Prev: Registering, Up: Secondary VC Commands

VC状態表示コマンド
..................

`C-x v l'
     版管理の状態と変更履歴を表示する。

ファイルの詳しい版管理状態や履歴を見るには、`C-x v l'（`vc-print-log'）
と打ちます。記録項目を含めてカレントファイルの変更履歴を表示します。出
力は別のウィンドウに表示されます。



File: emacs-ja.info, Node: VC Undo, Next: VC Dired Mode, Prev: VC Status, Up: Secondary VC Commands

版管理操作のアンドゥ
....................

`C-x v u'
     バッファとファイルを最新のチェックインしてある版に復元する。

`C-x v c'
     訪問先ファイルのマスタファイルに最後に入れた変更を取り除く。つま
     り、最後のチェックインをアンドゥする。

これまでの一連の変更を破棄してチェックインしてある最新版へ復元したいと
きは、`C-x v u'（`vc-revert-buffer'）を使います。ロックを使用している
ときには、ファイルのロックを解除するので、変更を始めるまえにまずファイ
ルをロックし直す必要があります。チェックインした最新版から変更していな
いと判断できない限り、`C-x v u'は確認を求めてきます。

`C-x v u'は、ファイルをロックしたけれどもやはりファイルを変更しないと
決めたときに、ロックを解除するコマンドでもあります。

すでにチェックインしてしまった変更を取り消すには、`C-x v c'
（`vc-cancel-version'）を使います。このコマンドは、チェックインした最
新版のすべての記録を捨てさります。さらに、`C-x v c'は、作業ファイルと
バッファを以前の版（捨てた最新版の1つまえの版）に復元するかどうか聞い
てきます。

`no'と答えると、VCはバッファでの変更を保持してファイルもロックしたまま
にします。チェックインした変更に明らかなまちがいがあるとわかったときに、
この「復元しない」という選択肢は便利です。誤りを含んだチェックインを取
り消し、誤りを訂正してから、改めてファイルをチェックインできます。

`C-x v c'がバッファを復元しないときには、そのかわりに、バッファ内のす
べての版管理ヘッダの展開形をもとの形に戻します（*Note Version
Headers::）。なぜなら、バッファはもはや既存のどの版にも対応しないから
です。ふたたびチェックインすると、チェックインの過程で、新たな版番号と
して正しくヘッダを展開します。

しかしながら、RCSの`$Log$'ヘッダを
自動的にもとの形に戻すことは不可能です。
このヘッダの機能を使うなら、取り消した版に対応する項目を削除することで、
もとの形に手で戻す必要があります。

多くの作業結果を簡単に失ってしまうので、`C-x v c'を起動するときには十
分注意してください。



File: emacs-ja.info, Node: VC Dired Mode, Next: VC Dired Commands, Prev: VC Undo, Up: Secondary VC Commands

VC下のdired
...........

大きなプログラムを扱っているときは、ディレクトリの木構造全体の中でどの
ファイルが変更されたのかを調べたり、版管理の下に置かれているすべてのファ
イルの状態を一度に見られると便利です。コマンド`C-x v d'
（`vc-directory'）を使えば、版管理に関連したファイルだけを含んだディレ
クトリ一覧を作れます。

`C-x v d'は、VC diredモードを使うバッファを作ります。これは、普通の
diredバッファ（*Note Dired::）にそっくりですが、（ロックされていたり、
未更新の）注意を払うべきファイルだけを通常は表示します。これを"簡素な
表示"と呼びます。変数`vc-dired-terse-display'に`nil'を設定すると、VC
diredは、関連するすべてのファイル、つまり、版管理の下に置かれたファイ
ルとすべてのサブディレクトリを表示します（"完全な表示"）。VC diredバッ
ファのコマンド`v t'は、簡素な表示と完全な表示を切り替えます。（*Note
VC Dired Commands::。）

デフォルトでは、VC diredは、指定したディレクトリやそれより下に置かれた
注意を払うべきファイルや関連するファイルの再帰的な一覧を作ります。この
動作を変えるには、変数`vc-dired-recurse'に`nil'を設定します。すると、
VC diredは、指定したディレクトリにあるファイルだけを表示します。

各ファイルを表す行には、ハードリンク数、所有者、グループ、ファイルサイ
ズのかわりに版管理状態があります。ファイルが変更されていなければ、つま
り、マスタファイルの内容に同期しているならば、版管理状態は空です。そう
でなければ、括弧で括ったテキストになります。RCSとSCCSでは、ファイルを
ロックしているユーザーの名前が示されます。CVSでは、cvs状態（`cvs
status'）を簡略化したものが示されます。つぎは、RCSを使っている場合の例
です。

       /home/jim/project:

       -rw-r--r-- (jim)      Apr  2 23:39 file1
       -r--r--r--            Apr  5 20:21 file2

ファイル、`file1'と`file2'が、版管理の下に置かれていて、`file1'はユー
ザーjimがロックしていて、`file2'はロックされていません。

つぎは、CVSを使っている場合の例です。

       /home/joe/develop:

       -rw-r--r-- (modified) Aug  2  1997 file1.c
       -rw-r--r--            Apr  4 20:09 file2.c
       -rw-r--r-- (merge)    Sep 13  1996 file3.c

保管庫のものに比べて、`file1.c'は変更されていますが、`file2.c'は変更さ
れていません。`file3.c'も変更されていますが、保管庫には他の変更がチェッ
クインされています。`file3.c'をチェックインするまえに、それらの変更を
併合する必要があります。

VC diredで（『完全な表示』のときに）サブディレクトリを表示するときには、
版管理の下には絶対に置かれないものは省略します。デフォルトでは、`RCS'
や`CVS'などのVCのサブディレクトリが含まれます。これは、変数
`vc-directory-exclusion-list'を設定してカスタマイズできます。

普通のdiredのように、`C-u C-x v d'と打てば、`ls'プログラムに渡す追加オ
プションを指定して、VC diredの出力書式を微調整できます。



File: emacs-ja.info, Node: VC Dired Commands, Prev: VC Dired Mode, Up: Secondary VC Commands

VC diredコマンド
................

VC diredモードでも、通常のdiredコマンドはすべて普通に動作しますが、`v'
は例外で、版管理プレフィックスとして再定義してあります。`vc-diff'や
`vc-print-log'のようなVCコマンドは、`v ='や`v l'いうように打てば起動で
きます。これらのコマンドの多くは、現在行のファイルに作用します。

コマンド`v v'（`vc-next-action'）は、印を付けたすべてのファイルに作用
するので、複数のファイルを一度にロックしたりチェックインしたりできます。
複数のファイルに作用する場合、各ファイルの現状に応じて個別に扱います。
つまり、あるファイルはロックしたり、別のファイルはチェックインしたりし
ます。これは混乱の原因かもしれません。同じ状態の一連のファイルに印を付
けて、混乱を防止するのはユーザーの責任です。

ファイルをチェックインするときには、`v v'は1つの記録項目を読んで、それ
をチェックインするすべてのファイルに使います。これは、同じ変更に属する
一連のファイルを一度にチェックインする場合に便利です。

`v t'（`vc-dired-toggle-terse-mode'）と打てばいつでも、（ロックされて
いたり、内容が未更新のものだけを表示する）簡素な表示と完全な表示とを切
り替えられます。特別なコマンド`* l'（`vc-dired-mark-locked'）もありま
す。これは現在ロックされている（CVSの場合には、内容が未更新である）す
べてのファイルに印を付けます。つまり、現在ロックされいるもの以外のすべ
てのファイルをバッファから削除する別の方法は、`* l t k'と打つことです。



File: emacs-ja.info, Node: Branches, Next: Snapshots, Prev: Secondary VC Commands, Up: Version Control

ファイルの複数の枝分かれ
------------------------

版管理の用途の1つは、ファイルの複数の『現在』版を維持することです。た
とえば、さまざまな完了していない新しい機能を徐々に付け加えているプログ
ラムの異なる版を持つかもしれません。そういった開発の独立した流れを"枝"
（branch）と呼びます。VCでは、枝を作ったり、別の枝へ切り替えたり、2つ
の枝を併合したりできます。しかし、今のところ、RCSだけで枝を使えること
に注意してください。

ファイルの開発の主要な流れを"幹"（trunk）と呼びます。幹にある版は、普
通、1.1、1.2、1.3、…と番号が付けられます。そのような版のどれからでも、
独立した枝を始めることができます。版1.2から始まる枝の版番号は1.2.1.1と
なり、同じ枝の後続の版番号は1.2.1.2、1.2.1.3、1.2.1.4、…となります。
版1.2から始まる別の枝があれば、それらの版番号は、1.2.2.1、1.2.2.2、
1.2.2.3、…となります。

版番号の最後の要素を省略したものを"枝番号"と呼びます。これは、その枝に
ある版の中でもっとも大きい番号の版、"先頭版"を指します。まえの例の枝は、
枝番号1.2.1と1.2.2です。

* Menu:

* Switching Branches::    How to get to another existing branch.
* Creating Branches::     How to start a new branch.
* Merging::               Transferring changes between branches.
* Multi-User Branching::  Multiple users working at multiple branches 
                            in parallel.



File: emacs-ja.info, Node: Switching Branches, Next: Creating Branches, Up: Branches

枝の切り替え
............

枝を切り替えるには、`C-u C-x C-q'と打ってから、選択したい版番号を指定
します。その版を*ロックしない*（書き込み不可）で訪問するので、ロックす
るまえに調べることができます。このような枝の切り替えが可能なのは、ファ
イルがロックされていない場合に限ります。

枝の中での版番号を省略して枝番号だけを指定できます。すると、その枝の先
頭版を選ぶことになります。RETだけを打つと、Emacsは幹の上のもっとも大き
い版を選びます。

（幹を含む）どれかの枝へ切り替えたあとでは、明示的に他の枝を選択するま
で、それ以降のVCコマンドはその枝を使います。



File: emacs-ja.info, Node: Creating Branches, Next: Merging, Prev: Switching Branches, Up: Branches

新しい枝の作成
..............

先頭版（枝の中にある最新版）から新たな枝を作るには、必要ならまずその版
を選択してから、`C-x C-q'でそれをロックし、必要な変更を施します。そし
て、変更をチェックインするときに、`C-u C-x C-q'を使います。このコマン
ドでは、新版に対する版番号を指定できます。現在の版から始まる枝として適
切な番号を指定する必要があります。たとえば、現在の版が2.5ならば、その
時点で存在する枝の数に依存しますが、枝番号は、2.5.1、2.5.2、…です。

旧版（先頭版ではないもの）から新しい枝を作るには、その版をまず選択して
から（*Note Switching Branches::）、それを`C-x C-q'でロックします。旧
版をロックすると、本当に新しい枝を作るのかどうか確認してきます。noで答
えると、かわりに、最新版をロックするかどうか聞いてきます。

変更してから、ふたたび`C-x C-q'と打って新版にチェックインします。こう
すると選択した版から始まる新しい枝を自動的に作ります。新しい枝を特に指
定する必要はありません。なぜなら、枝の先頭版でないところに新版を付け加
える唯一の方法だからです。

枝を作ったあとでは、その枝に『留まり』ます。つまり、それ以降にチェック
インすると、その枝に新版が作られます。枝を去るには、`C-u C-x C-q'で明
示的に別の版を選ぶ必要があります。ある枝から別の枝へ変更を移すには、次
節で説明する併合コマンドを使ってください。



File: emacs-ja.info, Node: Merging, Next: Multi-User Branching, Prev: Creating Branches, Up: Branches

枝の併合
........

ある枝で変更を完了したときには、それらの変更をファイルの開発の主流（幹）
に取り込みたいことがしばしばあるでしょう。これは簡単な操作ではありませ
ん。というのは、幹でも開発は進行しているので、別の向きに変更されている
ファイルに変更を"併合"する必要があるからです。VCでは、`vc-merge'コマン
ドで併合（とそれ以外のことも）できます。

`C-x v m (vc-merge)'
     作業ファイルに変更を併合する。

`C-x v m'（`vc-merge'）は、一連の変更を作業ファイルの現在の版に併合し
ます。このコマンドはまず、ミニバッファで枝番号か2つの版番号を読み取り
ます。そして、その枝での変更、あるいは、指定した2つの版のあいだの変更
を調べ、それらをファイルの現在の版に併合します。

例として、枝1.3.1である機能を実装し終えたとしましょう。この間、幹でも
開発が進んでいて版1.5になっています。枝での変更を幹に併合するには、ま
ず、`C-u C-x C-q RET'と打って、幹の先頭版へ行きます。版1.5が現在の版に
なります。ファイルのロックを使っている場合には、`C-x C-q'と打って、版
1.5をロックして変更できるようにします。続いて`C-x v m 1.3.1 RET'と打ち
ます。すると、枝1.3.1での（枝の開始点である版1.3から枝の中にある最新版
までの）一連の変更を取り出して、それらを作業ファイルの現在の版に併合し
ます。ここで、変更された作業ファイルをチェックインできます。つまり、枝
での変更を取り込んだ版1.6を作れるのです。

チェックインするまえに、枝から併合したあとにさらに編集することも可能で
す。しかし、併合した版をチェックインしたあとで、ロックしてさらに編集す
るのが、普通は賢いやり方です。こうすれば、変更履歴をよりよく記録に残せ
ます。

すでに修正されているファイルに変更を併合するときには、変更が重複する場
合があります。この状況を"矛盾"と呼びます。矛盾した変更の辻褄を合わせる
ことを"矛盾の解消"と呼びます。

併合中に矛盾が起こると、VCはこれらを検出し、それらをエコー領域に表示し
てユーザーに伝え、併合を補佐してほしいかどうか聞いてきます。yesで答え
ると、ediffセッションを開始します（*Note Ediff: (ediff)Top.）。

noで答えると、矛盾する変更はどちらも"矛盾印"で囲ってファイルに挿入しま
す。矛盾する部分は、下の例のようになります。作業ファイルの名前は`name'
であり、ユーザーBの変更を収めたマスタファイルの版は1.11です。

     <<<<<<< name
       USER A'S VERSION
     =======
       USER B'S VERSION
     >>>>>>> 1.11

この矛盾を解消するようにファイルを手で編集できます。あるいは、ファイル
を訪問してから`M-x vc-resolve-conflicts'と打ちます。すると上に述べた
ediffセッションを開始します。



File: emacs-ja.info, Node: Multi-User Branching, Prev: Merging, Up: Branches

複数ユーザーの枝
................

ファイルの異なる枝上で同時に複数の開発者が作業すると有益なことがしばし
ばあります。CVSでは、デフォルトで、これができます。RCSでは、複数のソー
スディレクトリを作れば可能です。RCSのマスタファイルを置いた共通のディ
レクトリを指す`RCS'という名前のリンクを各ソースディレクトリに置きます。
こうすれば、各ソースディレクトリでは、それぞれ独自に版を選択できます。
しかし、同じ共通のRCSレコードをすべてで共有します。

ソースファイルにRCSの版管理ヘッダ（*Note Version Headers::）が入ってい
れば、この技法は信頼性があり自動的に動作します。ヘッダにより、Emacsは
いつでも作業ファイルに入っている版番号がわかります。

ファイルに版管理ヘッダが入っていないときには、各セッションごとにどの枝
で作業しているかをEmacsに明示する必要があります。こうするには、ファイ
ルを訪問してから、`C-u C-x C-q'と打ち、正しい枝番号を指定します。これ
により、編集セッションではどの枝を操作しているかをEmacsが知っているこ
とを保証します。



File: emacs-ja.info, Node: Snapshots, Next: Miscellaneous VC, Prev: Branches, Up: Version Control

スナップショット
----------------

"スナップショット"とは、ファイルの版（登録されたファイルそれぞれに1つ
ずつ）の集合に名前を付けたもので、一塊として扱うことができます。スナッ
プショットの重要な種類の1つは、"リリース"です。これは、ユーザーへ配布
する準備が整ったシステムの（理論的には）安定した版のことです。

* Menu:

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.



File: emacs-ja.info, Node: Making Snapshots, Next: Snapshot Caveats, Up: Snapshots

スナップショットの作成と使用
............................

スナップショットに対しては、基本的なコマンドが2つあります。1つは名前を
指定してスナップショットを作り、もう1つは指名したスナップショットを取
り出すことです。

`C-x v s NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルのそれ
     ぞれの保存された最新版をNAMEという名前のスナップショットとして定
     義する（`vc-create-snapshot'）。

`C-x v r NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルすべて
     について、スナップショットNAMEに対応する版を選択する。

     カレントディレクトリやその下に置いてある登録されたファイルのいず
     れかがロックされていると、このコマンドは何も変更せずにエラーを報
     告する。これは、進行中の作業結果を上書きしてしまうことを避けるた
     め。

スナップショットはとても少量の資源しか使いません。ファイル名一覧とスナッ
プショットに属する版番号を記録するに十分な量だけでいいのです。したがっ
て、使いものになるものをスナップショットにすることを躇うことはありませ
ん。

`C-x v ='や`C-x v ~'（*Note Old Versions::）の引数として、スナップショッ
トの名前を指定できます。したがって、スナップショットと現在のファイル、
あるいは、2つのスナップショット同士、あるいは、指定した名前の版とスナッ
プショット同士を比較できます。



File: emacs-ja.info, Node: Snapshot Caveats, Prev: Making Snapshots, Up: Snapshots

スナップショットの弱点
......................

VCのスナップショット機能は、RCSの名前付きコンフィギュレーションサポー
ト（named-configuration support）をモデルにしています。RCS固有の機能を
使っているため、RCSを使って作ったVCのスナップショットは、VCを使わなく
ても見えます。

SCCSでは、VC自身でスナップショット機能を実装しています。VCが使うファイ
ルには、名前／ファイル／版番号の3つ組みが含まれます。これらのスナップ
ショットは、VCを使ったときだけ見えます。

スナップショットはチェックインした版の集合です。ですから、スナップショッ
トを作るときには、すべてのファイルをチェックインしてあり、しかもロック
していないことを確認してください。

ファイルを改名したり削除すると、スナップショットに問題を生じます。これ
はVCに固有の問題ではなく、版管理システムに一般的な設計上の問題で、まだ
誰も満足ゆく解決をできていません。

登録されたファイルを改名するなら、そのマスタファイルも一緒に改名する必
要があります（コマンド`vc-rename-file'は自動的にこれを行う）。SCCSを使っ
ているならば、ファイル名を新しい名前にしてスナップショットの記録も更新
する必要があります（`vc-rename-file'はこれも行う）。記録された名前では
もはや存在しないマスタファイルを参照する古いスナップショットは無効です。
VCは（古い名前では）取り出せません。スナップショットを手で更新する方法
を説明するためにRCSやSCCSを詳しく説明することは、本書の範囲を越えてい
ます。

`vc-rename-file'を使えば、取り出し操作に使える程度にはスナップショット
を保てますが、すべての問題を解決できるわけではありません。たとえば、プ
ログラムのいくつかのファイルでは、名前で他のファイルを参照しているでしょ
う。少なくとも、makefileでは、改名したファイルを指しているでしょう。古
いスナップショットを取り出すと、改名したファイルは新しい名前で取り出し
ますが、makefileで使っている名前ではありません。ですから、取り出しただ
けではプログラムは動かないでしょう。



File: emacs-ja.info, Node: Miscellaneous VC, Next: Customizing VC, Prev: Snapshots, Up: Version Control

VCのその他のコマンドと機能
--------------------------

本節では、使用頻度の少ないVCの機能を説明します。

* Menu:

* Change Logs and VC::  Generating a change log file from log entries.
* Renaming and VC::     A command to rename both the source and master 
                          file correctly.
* Version Headers::     Inserting version control headers into working files.



File: emacs-ja.info, Node: Change Logs and VC, Next: Renaming and VC, Up: Miscellaneous VC

変更記録とVC
............

プログラムに対してRCSやCVSを使い、しかも、それらに変更記録ファイル
（*Note Change Log::）を保持しているならば、版管理の記録項目から変更記
録項目を自動的に生成できます。

`C-x v a'
     カレントディレクトリにある変更記録ファイルを訪れる。そして、その
     ディレクトリに置いてある登録された各ファイルについて、変更記録ファ
     イルにある最新の項目以降にチェックインされた版に関する新たな項目
     を作成する。（`vc-update-change-log'）。

     このコマンドはRCSやCVSだけで動作し、SCCSでは動作しない。

`C-u C-x v a'
     上と同様であるが、カレントバッファのファイルに関する項目だけを探
     す。

`M-1 C-x v a'
     上と同様だが、現在訪問しているファイルのうち版管理の下に置かれて
     いるファイルすべてに関する項目を探す。このコマンドはRCSでのみ動作
     する。しかも、デフォルトディレクトリに関するすべての項目を変更記
     録に追加するが、これは適切でないこともある。

たとえば、`ChangeLog'の最初の行の日付が1999年4月10日であり、それ以降の
チェックインはNathaniel Bowditchが1999年5月22日に`Ignore log messages
that start with `#'.'という記録で`rcs2log'にチェックインしたものだけだ
としましょう。そうすると、`C-x v a'は`ChangeLog'を訪問して、つぎのよう
なテキストを挿入します。

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with `#'.

このあと、変更記録の新しい項目を好きなように編集できます。

残念ながら、ChangeLogファイルには日付しか記録していないので、新たな変
更記録項目がChangeLogファイルの既存の項目と重複することがあります。そ
のような日付の重複は、手作業で削除する必要があります。

通常、ファイル`foo'に関する記録項目は、
`* foo: TEXT OF LOG ENTRY'のように表示されます。
記録項目のテキストが`(FUNCTIONNAME):'で始まると、
`foo'のうしろの`:'は省かれます。
たとえば、`vc.el'に関する記録項目が
`(vc-do-command): Check call-process status.'であれば、
`ChangeLog'の中のテキストはつぎのようになります。

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

`C-x v a'が複数の変更記録項目を一度に追加するときには、同じ作者がほぼ
同じ日時にチェックインしたものならば、関連する記録項目をまとめます。そ
のようないくつかのファイルに対する記録項目がすべて同じテキストならば、
1つの項目にまとめます。たとえば、最後にチェックインしたものに、以下の
記録があったとします。

* `vc.texinfo'の記録項目: `Fix expansion typos.'
* `vc.el'の記録項目: `Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `Don't call expand-file-name.'

これらは`ChangeLog'の中ではつぎのようになります。

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.

             * vc.el, vc-hooks.el: Don't call expand-file-name.

通常、`C-x v a'は記録項目を空行で区切りますが、
関連する記録項目のテキストを`{CLUMPNAME} 'のような
ラベルで始めれば、関連する複数の記録項目を1つの塊にする
（区切りの空行を入れない）ように印を付けられます。
ラベル自体は`ChangeLog'にはコピーされません。
たとえば、記録項目がつぎのようであるとします。

* `vc.texinfo'の記録項目: `{expand} Fix expansion typos.'
* `vc.el'の記録項目: `{expand} Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `{expand} Don't call expand-file-name.'

すると、`ChangeLog'のテキストはつぎのようになります。

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.
             * vc.el, vc-hooks.el: Don't call expand-file-name.

記録項目のテキストが`#'で始まると、その記録項目は`ChangeLog'にはコピー
されません。たとえば、コメントの綴りまちがいだけを変更したときには、記
録項目を`#'で始めれば、このような自明なものを`ChangeLog'に入れないです
みます。



File: emacs-ja.info, Node: Renaming and VC, Next: Version Headers, Prev: Change Logs and VC, Up: Miscellaneous VC

VC作業ファイルとマスタファイルの改名
....................................

登録したファイルを改名するときには、そのマスタファイルも同様に改名して
正しい結果を得られるようにする必要があります。指定どおりにソースファイ
ルを改名し、それに従ってマスタファイルも改名するには、`vc-rename-file'
を使います。このコマンドは、当該ファイルを指名しているどんなスナップ
ショット（*Note Snapshots::）も更新するので、スナップショットでも新し
い名前を使うようになります。それにも関わらず、修正したスナップショット
は動作しないかもしれません（*Note Snapshot Caveats::）。

誰かがロックしているファイルに対しては、`vc-rename-file'を使えません。



File: emacs-ja.info, Node: Version Headers, Prev: Renaming and VC, Up: Miscellaneous VC

版管理ヘッダの挿入
..................

版を識別する文字列を作業ファイルへ直接入れておくと便利なこともあります。
"版管理ヘッダ"と呼ばれる特別な文字列は、各版ごとにその版番号で置き換え
られます。

RCSを使っていて、かつ、作業ファイルに版管理ヘッダが入っていれば、Emacs
は、版管理ヘッダを使って現在の版とファイルのロック状態を決定できます。
これは、版管理ヘッダがないときにマスタファイルを参照するより、信頼でき
ます。複数の枝を使う環境では、VCが正しくふるまうためには版管理ヘッダが
必要です（*Note Multi-User Branching::）。

版管理ヘッダの探索は、変数`vc-consult-headers'で制御されます。`nil'以
外ならば、編集中の版番号を決定するためにEmacsはヘッダを探します。`nil'
を設定すると、この機能はオフになります。

適切なヘッダ文字列を入れるには、コマンド`C-x v h' 
（`vc-insert-headers'）を使います。

`C-x v h'
     版管理システムで使うヘッダをファイルに挿入する。

デフォルトのヘッダ文字列は、
RCSでは`$Id$'、SCCSでは`%W%'です。
変数`vc-header-alist'に設定すれば、他のヘッダを指定できます。
この値は、`(PROGRAM . STRING)'の形式の
要素から成るリストです。
ここで、PROGRAMは`RCS'または`SCCS'であり、
STRINGは使用する文字列です。

1つの文字列のかわりに、文字列のリストを指定することもできます。そうす
ると、リストの各文字列は、別々の行に別のヘッダとして挿入されます。

この変数に入れる文字列を書くときには、『余分な』バックスラッシュを使う
必要がよくあります。この文字列を含むEmacs Lispファイルが版管理の下に置
かれているときに、定数中の文字列がヘッダと解釈されることを防ぐためです。

各ヘッダは、ポイント位置の新しい行に、コメント区切りの内側にタブで囲ん
で挿入されます。通常、現在のモードのコメント開始文字列とコメント終了文
字列を使いますが、特定のモードでは、この目的のための特別なコメント区切
りがあります。変数`vc-comment-alist'がそれらを指定します。このリストの
各要素は`(MODE STARTER ENDER)'という形式です。

変数`vc-static-header-alist'は、バッファ名に基づいた追加の文字列を指定
します。この値は、`(REGEXP . FORMAT)'の形式の要素から成るリストでなく
てはいけません。REGEXPがバッファ名に一致するたびに、FORMATをヘッダの一
部として挿入します。バッファ名に一致する各要素と`vc-header-alist'に指
定された各文字列ごとにヘッダ行を挿入します。`vc-header-alist'の文字列
を要素の書式FORMATで処理してヘッダ行を作ります。
`vc-static-header-alist'のデフォルト値はつぎのとおりです。

     (("\\.c$" .
       "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
     #endif /* lint */\n"))

これは、つぎのようなテキストを挿入します。


     #ifndef lint
     static char vcid[] = "STRING";
     #endif /* lint */

上のテキストは空行で始まっていることに注意してください。

複数の版管理ヘッダをファイルに入れる場合には、ファイル内ではそれらを一
緒にまとめて入れておきます。`revert-buffer'のマーカを保存する機構は、2
つの版管理ヘッダのあいだに置かれたマーカを扱えないこともあります。



File: emacs-ja.info, Node: Customizing VC, Prev: Miscellaneous VC, Up: Version Control

VCのカスタマイズ
----------------

VCをカスタマイズする方法はたくさんあります。設定可能なオプションは、次
節に述べる4つに分類できます。

* Menu:

* Backend Options::       Customizing the back-end to your needs.
* VC Workfile Handling::  Various options concerning working files.
* VC Status Retrieval::   How VC finds the version control status of a file,
                            and how to customize this.
* VC Command Execution::  Which commands VC should run, and how.



File: emacs-ja.info, Node: Backend Options, Next: VC Workfile Handling, Up: Customizing VC

VCのバックエンドに対するオプション
..................................

RCSとCVSには、ファイルのロックを使うかどうかを指定できます（ロックに関
しては*Note VC Concepts::）。VCはどちらを選んだかを識別し、そのように
ふるまいます。

RCSでは、デフォルトはロックを使います。しかし、ファイルをロックしてい
なくても変更をチェックインできる、"弱いロック"と呼ばれるモードがありま
す。特定のファイルに対して弱いロックを使うように切り替えるには、`rcs
-U'を使います。詳しくは、`rcs'のマニュアルページを参照してください。

CVSでは、デフォルトはロックを使いません。いつでも誰もが作業ファイルを
変更できます。しかし、これを制限する方法があり、ロックに似たふるまいを
します。

1つの方法は、環境変数`CVSREAD'に何か値を設定することです。この変数が定
義されていると、CVSはデフォルトでは作業ファイルを読み出し専用にします。
Emacs内では、`C-x C-q'と打ってファイルを書き込み可能にする必要がありま
す。そうすると、事実上ロックを使っているかのように編集できます。しかし
ながら、実際にロックされているわけではないので、複数のユーザーが各自の
ファイルを同時に書き込み可能にできてしまいます。`CVSREAD'を初めて設定
するときには、ファイルの保護が正しく設定されるように、あなたのモジュー
ルすべてを新たにチェックアウトしたことを確認してください。

ロックに似たふるまいを達成する別の方法は、CVSの"監視"機能を使うことで
す。ファイルを監視するようにしておくと、CVSはデフォルトでそのファイル
を読み出し専用にします。そのため、Emacs内では`C-x C-q'を使って書き込み
可能にする必要があります。VCは、`cvs edit'を実行してファイルを書き込み
可能にします。すると、CVSは、あなたがファイルを変更しようとしているこ
とを他の開発者に通知します。監視機能の詳しい使い方については、CVSの解
説を参照してください。

変数`vc-handle-cvs'に`nil'を設定すれば、CVSの管理下に置いたファイルに
対してVCを使わないようにできます。こうすると、Emacsは、これらのファイ
ルをあたかも登録されていないかのように扱い、それらに対してVCコマンドは
使えません。すべてのCVS操作を手動で行う必要があります。



File: emacs-ja.info, Node: VC Workfile Handling, Next: VC Status Retrieval, Prev: Backend Options, Up: Customizing VC

VC作業ファイルの扱い方
......................

Emacsは、版管理の下に置かれたソースファイルに対しては、通常バックアッ
プファイルを作りません。版管理を使っているファイルに対してもバックアッ
プファイルを作りたいなら、変数`vc-make-backup-files'に`nil'以外の値を
設定します。

ロックの状態に関わらず、普通、作業ファイルはつねに存在します。
`vc-keep-workfiles'に`nil'を設定すると、`C-x C-q'で新版をチェックイン
すると、作業ファイルを削除します。しかし、Emacsでファイルを訪問しよう
とすると、作業ファイルをふたたび作ります。（CVSでは、作業ファイルはつ
ねに存在する。）

版管理されているファイルをシンボリックリンクを介して編集することは、危
険なことになりえます。版管理システムを迂回してしまいます。つまり、ロッ
クせずにファイルを編集できてしまい、変更のチェックインには失敗します。
また、他のユーザーがあなたの変更を上書きしてしまうかもしれません。こう
いったことを防ぐために、VCは、訪問する各シンボリックリンクを検査して、
それが版管理の下に置かれたファイルを指しているかどうか調べます。

変数`vc-follow-symlinks'は、シンボリックリンクが版管理されているファイ
ルを指しているときにどうするかを制御します。その値が`nil'ならば、VCは
警告メッセージを表示するだけです。`t'ならば、VCは自動的にリンクを辿っ
て、かわりに本当のファイルを訪問し、エコー領域にこのことを表示します。
値が`ask'（デフォルト）ならば、VCはリンクを辿るかどうかを毎回聞いてき
ます。



File: emacs-ja.info, Node: VC Status Retrieval, Next: VC Command Execution, Prev: VC Workfile Handling, Up: Customizing VC

VC状態検索
..........

ファイルのロック状態を推測するとき、VCはまずファイルのRCSの版管理ヘッ
ダ文字列を探します（*Note Version Headers::）。ヘッダ文字列がなかった
り、SCCSを使っているときは、VCは通常、作業ファイルのパーミッションを調
べます。ここまでは、すぐにできます。しかし、ファイルのパーミッションを
信頼できない場合もあります。この場合、やや手間がかかりますが、マスタファ
イルを調べる必要があります。さらに、マスタファイルは、ファイルがロック
されているかどうかは教えてくれますが、作業ファイルがロックされた版を本
当に含んでいるかどうかは教えてくれません。

ロック状態を調べるために版管理ヘッダを使わないようにVCに指示するには、
変数`vc-consult-headers'に`nil'を設定します。すると、VCは（信頼できる
なら）ファイルパーミッションを使うか、マスタファイルを調べます。

変数`vc-mistrust-permissions'を設定することで、ファイルパーミッション
を信頼するかどうかの基準を指定できます。その値は、`t'（つねにファイル
パーミッションを疑い、マスタファイルを調べる）、`nil'（つねにファイル
パーミッションを信頼する）、あるいは、可否を決定する1引数の関数です。
その引数は、サブディレクトリ、`RCS'、`CVS'、`SCCS'のいずれかの名前です。
関数の戻り値が`nil'以外ならば、ファイルパーミッションを疑います。作業
ファイルのパーミッションがまちがって変更されていると思うなら、 
`vc-mistrust-permissions'に`t'を設定します。すると、VCはつねにファイル
の状態を決定するためにマスタファイルを調べます。



File: emacs-ja.info, Node: VC Command Execution, Prev: VC Status Retrieval, Up: Customizing VC

VCコマンドの実行
................

`vc-suppress-confirm'が`nil'以外ならば、`C-x C-q'と`C-x v i'は確認せず
にカレントバッファを保存し、`C-x v u'も確認せずに作用します。（この変
数は`C-x v c'には影響しない。その操作は思い切ったものなので、つねに確
認するべき。）

VCモードは、RCS、CVS、SCCSのシェルコマンドを実行することで、その作業の
多くを行います。`vc-command-messages'が`nil'以外ならば、VCはどのシェル
コマンドを実行しているか表示し、コマンドが終了したときに追加メッセージ
を表示します。

変数`vc-path'を設定すれば、版管理プログラムを探すための追加のディレク
トリを指定できます。これらのディレクトリは、通常の探索パスを探すまえに
探されます。しかし、通常は適切なファイルを自動的にみつけられます。



File: emacs-ja.info, Node: Directories, Next: Comparing Files, Prev: Version Control, Up: Files

ファイルディレクトリ
====================

ファイルシステムは、ファイル群を"ディレクトリ"にまとめます。"ディレク
トリ一覧"は、ディレクトリの中にある、すべてのファイルの一覧表です。
Emacsには、ディレクトリを作成したり削除したりするコマンド、短形式（ファ
イル名のみ）や長形式（サイズ、日付、作者を含む）のディレクトリ一覧を作
成するコマンドがあります。diredと呼ばれるディレクトリブラウザもありま
す。*Note Dired::。

`C-x C-d DIR-OR-PATTERN RET'
     短形式でディレクトリ一覧を表示する（`list-directory'）。
`C-u C-x C-d DIR-OR-PATTERN RET'
     長形式でディレクトリ一覧を表示する。
`M-x make-directory RET DIRNAME RET'
     DIRNAMEという名前の新しいディレクトリを作る。
`M-x delete-directory RET DIRNAME RET'
     DIRNAMEという名前のディレクトリを削除する。ディレクトリは空である
     必要があり、さもないとエラー。

ディレクトリ一覧を表示するコマンドは`C-x C-d'（`list-directory'）です。
表示するディレクトリや一覧に含めるファイルを指定するワイルドカードを含
むパターンをミニバッファから読み取ります。たとえば、

     C-x C-d /u2/emacs/etc RET

とすると、ディレクトリ`/u2/emacs/etc'の中のすべてのファイルを表示しま
す。ファイル名のパターンを指定した例はつぎのとおりです。

     C-x C-d /u2/emacs/src/*.c RET

通常、`C-x C-d'はファイル名だけを含んだ短形式のディレクトリ一覧を表示
します。（値は無関係な）数引数を指定すると、（`ls -l'のように）サイズ、
日付、作者を含む長形式の一覧を作ります。

ディレクトリ一覧のテキストは、下位プロセスで`ls'を実行して取得します。
Emacsの2つの変数で、`ls'へ渡すオプションを制御します。
`list-directory-brief-switches'は、短形式一覧のときに使うオプションを
与える文字列です（デフォルトは`"-CF"'）。
`list-directory-verbose-switches'は、長形式一覧のときに使うオプション
を与える文字列です（デフォルトは`"-l"'）。



File: emacs-ja.info, Node: Comparing Files, Next: Misc File Ops, Prev: Directories, Up: Files

ファイルの比較
==============

コマンド`M-x diff'は、2つのファイルを比較し、`*Diff*'という名前のEmacs
バッファにその違いを表示します。このコマンドは、値が文字列である変数
`diff-switches'で指定されたオプションを使って`diff'プログラムを実行し
ます。

バッファ`*Diff*'のメジャーモードはコンパイル（compilation）モードです。
ですから、`C-x `'を使って、2つのソースファイルで変更されている箇所を次々
に訪れることができます。特定の変更箇所にポイントを移動してから、RETや
`C-c C-c'を打つか、そこで`Mouse-2'をクリックすると、そこに対応するソー
スの場所へ移動できます。コンパイル（compilation）モードの他の特別なコ
マンドを使うこともできます。SPCとDELでスクロール、`M-p'と`M-n'でカーソ
ル移動できます。*Note Compilation::。

コマンド`M-x diff-backup'は、指定されたファイルとその最新のバックアッ
プとを比較します。バックアップファイルの名前を指定すると、
`diff-backup'はそのもとのファイルとバックアップファイルとを比較します。

コマンド`M-x compare-windows'は、カレントウィンドウの中のテキストと、
つぎのウィンドウの中のテキストを比較します。それぞれのウィンドウのポイ
ント位置から比較を始めます。それぞれの開始位置は、各バッファのマークリ
ングに積まれます。そして、各ウィンドウでそれぞれのポイントを1文字ずつ
進めることを、両者のウィンドウで一致しないものに出会うまで行います。そ
して、コマンドは終了します。Emacsのウィンドウについてより詳しくは、
*Note Windows::。

数引数を指定すると、`compare-windows'は白文字の違いを無視します。変数
`compare-ignore-case'が`nil'以外ならば、大文字小文字の違いも同様に無視
します。

2つの似たファイルの併合に便利な機能に関しては、*Note Emerge::。



File: emacs-ja.info, Node: Misc File Ops, Next: Compressed Files, Prev: Comparing Files, Up: Files

その他のファイル操作
====================

Emacsには、ファイルをさまざまに操作するコマンドがあります。それらすべ
ては1つのファイルを操作します。これらのコマンドは、ワイルドカードを含
むファイル名を受け付けません。

`M-x view-file'では、ファイルを1画面分ずつ順番に眺めることができます。
このコマンドは、ミニバッファでファイル名を読み取ります。Emacsバッファ
にファイルを読み込んだあと、`view-file'は先頭を表示します。そうしたら、
1ウィンドウ分先へスクロールするにはSPC、逆向きにスクロールするにはDEL
を打ちます。ファイル内を動き廻るための他のいろいろなコマンドもあります
が、変更するためのコマンドはありません。コマンド一覧を見るには、このモー
ドで`?'と打ちます。コマンド群は、Emacsの普通のカーソル移動コマンドとほ
とんど同じです。ファイル閲覧を終了するには、`q'を打ちます。閲覧用のコ
マンドは、閲覧（view）モードと呼ばれる特別なメジャーモードで定義されて
います。

関連したコマンド、`M-x view-buffer'は、Emacsの既存のバッファを閲覧しま
す。*Note Misc Buffer::。

`M-x insert-file'は、指定したファイルの内容をカレントバッファのポイン
ト位置に挿入します。ポイントの位置はそのままですが、挿入された部分の直
後にマークを設定します。

`M-x write-region'は、`M-x insert-file'の逆です。指定したファイルにリー
ジョンの内容をコピーします。`M-x append-to-file'は、指定したファイルの
末尾にリージョンのテキストを付け加えます。*Note Accumulating Text::。

`M-x delete-file'は、シェルの`rm'コマンドのように、指定したファイルを
削除します。1つのディレクトリ内のたくさんのファイルを削除するのなら、
diredを使うほうが便利です（*Note Dired::）。

`M-x rename-file'は、ミニバッファで2つのファイル名、OLDとNEWを読み取り、
ファイルOLDをNEWに改名します。NEWという名前のファイルが既存のときには、
確認に`yes'で応答する必要があります。そうしないと、改名しません。これ
は、改名により名前NEWの古い意味が失われるからです。OLDとNEWが異なるファ
イルシステムの上にあるときには、ファイルOLDを（NEWに）コピーしてから削
除します。

似たコマンド`M-x add-name-to-file'は、既存ファイルの名前を消さずに別の
名前を追加するために使います。新しい名前は、既存ファイルが置かれている
同じファイルシステムに属している必要があります。

`M-x copy-file'は、ファイルOLDを読んで、新しいファイルNEWに同じ内容を
書き出します。NEWという名前のファイルが既存なら、確認を求めてきます。
というのは、コピーするとファイルNEWの古い内容を上書きしてしまうからで
す。

`M-x make-symbolic-link'は、2つのファイル名、TARGETとLINKNAMEを読み取っ
て、TARGETを指すLINKNAMEという名前のシンボリックリンクを作ります。この
結果、将来LINKNAMEをオープンしようとすると、その時点でTARGETという名前
のファイルを参照します。その時点で名前TARGETが使われていなければ、エラー
になります。このコマンドは引数TARGETを展開しないので、リンク先に相対名
を書くことができます。

LINKNAMEが使われていると、リンクを作るときに確認を求めます。すべてのシ
ステムでシンボリックリンクを使えるわけではないことに注意してください。



File: emacs-ja.info, Node: Compressed Files, Next: Remote Files, Prev: Misc File Ops, Up: Files

圧縮されたファイルの参照
========================

Emacsには、圧縮されたファイルを訪問すると自動的に展開し、それを変更し
て保存すると自動的に再度圧縮するライブラリがあります。この機能を利用す
るには、コマンド`M-x auto-compression-mode'を打ちます。

（自動展開を含む）自動圧縮がオンのときには、Emacsはファイル名で圧縮さ
れたファイルを認識します。ファイル名の語尾が`.gz'のものは、`gzip'で圧
縮されたファイルであることを表します。他の語尾の場合には、他の圧縮プロ
グラムであることを表します。

自動展開と自動圧縮は、Emacsがファイルの内容を使うすべての操作に適用さ
れます。ファイルを訪問する、ファイルに保存する、ファイルの内容をバッファ
に挿入する、ファイルをロードする、ファイルをバイトコンパイルすることを
含みます。



File: emacs-ja.info, Node: Remote Files, Next: Quoted File Names, Prev: Compressed Files, Up: Files

リモートファイル
================

特別なファイル名の構文を使って、他のマシン上のファイルを参照できます。

     /HOST:FILENAME
     /USER@HOST:FILENAME

このようにすると、Emacsは、指定したホスト上のファイルを読み書きするた
めにFTPプログラムを使います。あなたのユーザー名かUSERを使ってFTPでログ
インします。毎回パスワードを聞かれることもありますが、これはHOSTへのロ
グインに使われます。

普通、リモートファイル名にユーザー名を指定しないと、あなたのユーザー名
を使うことを意味します。しかし、変数`ange-ftp-default-user'に文字列を
設定しておけば、その文字列をかわりに使います。（FTPによるファイル参照
を実装するEmacsのパッケージは、`ange-ftp'と呼ばれる。）

変数`file-name-handler-alist'に`nil'を設定すると、FTPファイル名機能を
完全にオフにできます (1) (*Note Remote Files-Footnotes::)。


File: emacs-ja.info  Node: Remote Files-Footnotes, Up: Remote Files

(1) ファイル名をクォートする`/:'の機能もオフになる。



File: emacs-ja.info, Node: Quoted File Names, Prev: Remote Files, Up: Files

クォートしたファイル名
======================

特殊文字や特別な構文の特別な効果を抑えるために、絶対ファイル名を"クォー
ト"できます。そうするには、先頭に`/:'を加えます。

たとえば、リモートにあるように見えるローカルなファイル名をクォートして、
リモートファイル名として扱われるのを防ぎます。したがって、ディレクトリ
が`/foo:'という名前であり、その中に`bar'という名前のファイルがあるとき、
Emacsでは、そのファイルを`/:/foo:/bar'で参照できます。

`/:'は、`~'をユーザーのホームディレクトリを表す特殊文字として扱わない
ようにもします。たとえば、`/:/tmp/~hack'は、ディレクトリ`/tmp'の中にあ
る`~hack'というファイル名を指します。

同様に、`/:'は`$'を含むファイル名をミニバッファで入力する方法の1つです。
しかし、`$'をクォートするには、`/:'は（ミニ）バッファの先頭に置く必要
があります。

ワイルドカード文字を`/:'でクォートすることもできます。たとえば、
`/:/tmp/foo*bar'でファイル`/tmp/foo*bar'を訪問します。しかしながら、多
くの場合、単にワイルドカード文字そのものを入力できます。たとえば、
`/tmp'にある`foo'で始まり`bar'で終る名前のファイルが`foo*bar'であると
きには、`/tmp/foo*bar'と指定すると、単に`/tmp/foo*bar'を訪問します。



File: emacs-ja.info, Node: Buffers, Next: Windows, Prev: Files, Up: Top

複数のバッファの使い方
**********************

Emacs内で編集しているテキストは"バッファ"（buffer）と呼ばれるオブジェ
クトの中に存在します。ファイルを訪問するたびに、ファイルのテキストを保
持するバッファを作ります。diredを起動するたびに、ディレクトリ一覧を保
持するバッファを作ります。`C-x m'でメッセージを送信するときには、メッ
セージのテキストを保持するためにバッファ`*mail*'が使われます。コマンド
の説明文を求めると、`*Help*'と呼ばれるバッファに説明文が現れます。

どんなときでも、1つのバッファだけが"選択"されています。このバッファを"
カレントバッファ"とも呼びます。バッファが1つしかないかのように、コマン
ドが『バッファ』に作用するといういい方をよくします。しかし、実際には、
コマンドが選択されたバッファに作用するということです（多くのコマンドは
そうする）。

複数のウィンドウがあるとき、各ウィンドウはそこに表示しているバッファを
選んでいますが、いつでもそれらのウィンドウのうち1つだけが選択されてい
て、そのウィンドウに表示されているバッファが選択されているバッファです。
各ウィンドウのモード行は、そのウィンドウに表示しているバッファの名前を
表示します（*Note Windows::）。

各バッファにはどんな長さでもよい名前があり、バッファ名を指定してバッファ
を選択できます。多くのバッファはファイルを訪問することで作成され、それ
らの名前はファイル名から導き出します。好きな名前で空のバッファを作るこ
ともできます。Emacsを新たに始めると、Emacs内でLisp式の評価に使える
`*scratch*'という名前のバッファができます。バッファ名では大文字小文字
を区別します。

各バッファは独立に、どのファイルを訪問しているか、変更されているか、ど
のメジャーモードとマイナモードを使っているかを記録しています。（*Note
Major Modes::）。どのEmacs変数も各バッファに"ローカルに"することができ
ます。つまり、あるバッファでの変数の値を他のバッファでのその変数の値と
は違う値にできます。*Note Locals::。

* Menu:

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::	        Renaming; changing read-onlyness; copying text.
* Kill Buffer::	        Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
			  and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer. 



File: emacs-ja.info, Node: Select Buffer, Next: List Buffers, Up: Buffers

バッファの作成と選択
====================

`C-x b BUFFER RET'
     BUFFERという名前のバッファを選択または作成する
     （`switch-to-buffer'）。
`C-x 4 b BUFFER RET'
     同様だが、別のウィンドウでBUFFERを選択する
     （`switch-to-buffer-other-window'）。
`C-x 5 b BUFFER RET'
     同様だが、別のフレームでBUFFERバッファを選択する
     （`switch-to-buffer-other-frame'）。

BUFNAMEという名前のバッファを選択するには、`C-x b BUFNAME RET'と打ちま
す。これは、引数BUFNAMEでコマンド`switch-to-buffer'を実行します。バッ
ファ名の略称形を補完することができます（*Note Completion::）。`C-x b'
に空の引数を指定すると、どのウィンドウにも表示されていない最近選択した
バッファを意味します。

ほとんどのバッファは、ファイルを訪問することで作られるか、テキストを表
示するようなEmacsコマンドによって作られますが、`C-x b BUFNAME RET'と打っ
て、明示的にバッファを作ることもできます。こうすると、ファイルを訪問し
ていない新しい空のバッファを作り、編集できるようにそのバッファを選択し
ます。このようなバッファは、自分用のメモを作るのに使います。これらのバッ
ファを保存しようとすると、使用するファイル名を聞かれます。新しいバッファ
のメジャーモードは、`default-major-mode'の値で決まります（*Note Major
Modes::）。

`C-x C-f'やファイルを訪問する他のコマンドは、ファイルを訪問している既
存のバッファへの切り替えにも使えることに注意してください。*Note
Visiting::。

Emacsは、内部目的用のバッファには、空白で始まるバッファ名を使います。
Emacsは、これらのバッファを少々特別に扱います。たとえば、デフォルトで
は、アンドゥ情報を記録しません。このようなバッファ名は避けるのが最良で
す。



File: emacs-ja.info, Node: List Buffers, Next: Misc Buffer, Prev: Select Buffer, Up: Buffers

既存バッファの一覧
==================

`C-x C-b'
     既存バッファを一覧表示する（`list-buffers'）。

既存のすべてのバッファを一覧表示するには、`C-x C-b'と打ちます。各行は、
バッファ名、メジャーモード、訪問しているファイルを示します。バッファは
選択された順に表示されます。もっとも最近に選択されたバッファが始めにき
ます。

行頭の`*'は、バッファが『修正され』ていることを示します。いくつかのバッ
ファが修正されているなら、`C-x s'でいくつかのバッファを保存する時期か
もしれません（*Note Saving::）。`%'は、読み出し専用バッファを示します。
`.'は選択されているバッファに付けられます。つぎは、バッファ一覧の例で
す。

      MR Buffer         Size  Mode           File
      -- ------         ----  ----           ----
     .*  emacs.tex      383402 Texinfo       /u2/emacs/man/emacs.tex
         *Help*         1287  Fundamental	
         files.el       23076 Emacs-Lisp     /u2/emacs/lisp/files.el
       % RMAIL          64042 RMAIL          /u/rms/RMAIL
      *% man            747   Dired          /u2/emacs/man/		
         net.emacs      343885 Fundamental   /u/rms/net.emacs
         fileio.c       27691 C              /u2/emacs/src/fileio.c
         NEWS           67340 Text           /u2/emacs/etc/NEWS
         *scratch*	   0	 Lisp Interaction

バッファ`*Help*'は、ヘルプ要求で作られたものです。このバッファはファイ
ルを訪問していません。バッファ`man'は、ディレクトリ`/u2/emacs/man/'に
対してdiredが作ったものです。



File: emacs-ja.info, Node: Misc Buffer, Next: Kill Buffer, Prev: List Buffers, Up: Buffers

その他のバッファ操作
====================

`C-x C-q'
     バッファの読み出し専用状態を切り替える（`vc-toggle-read-only'）。
`M-x rename-buffer RET NAME RET'
     カレントバッファの名前を変更する。
`M-x rename-uniquely'
     名前の最後に`<NUMBER>'を付加してカレントバッファ名を変更する。
`M-x view-buffer RET BUFFER RET'
     バッファBUFFERをスクロールする。

バッファは、"読み出し専用"にもなります。そうすると、その内容を変更する
コマンドは許されません。モード行では、左端付近に`%%'や`%*'を表示して、
読み出し専用バッファであることを示します。通常、読み出し専用バッファは、
テキストを操作する特別なコマンドを持つdiredやrmailなどのサブシステムが
作ります。書き込みを禁止されたファイルを訪問しても読み出し専用バッファ
が作られます。

読み出し専用バッファで変更したいときには、コマンド`C-x C-q'を使います
（`vc-toggle-read-only'）。これは、読み出し専用バッファは書き込み可能
にし、書き込み可能バッファは読み出し専用にします。多くの場合、これは変
数`buffer-read-only'を設定することで動作します。この変数は各バッファで
ローカルな値を持ち、値が`nil'以外だとバッファは読み出し専用になります。
ファイルが版管理の下に置かれている場合には、`C-x C-q'は版管理システム
を介してバッファだけでなくファイルの読み出し専用の状態も変更します。
*Note Version Control::。

`M-x rename-buffer'は、カレントバッファの名前を変更します。ミニバッファ
引数として新しい名前を指定します。デフォルトはありません。すでに他のバッ
ファに使っている名前を指定すると、エラーになり、名前は変更されません。

`M-x rename-uniquely'は、他のどれとも違う唯一の名前にするために、カレ
ントバッファ名に数字の接尾辞を付け加えて似た名前に変更します。このコマ
ンドは引数を必要としません。このコマンドは複数のシェルバッファを作るの
に便利です。バッファ`*Shell*'を改名すれば、`M-x shell'をふたたび実行し
てバッファ名`*Shell*'の新しいシェルバッファを作れます。一方、古いシェ
ルバッファは、新しい名前で存在し続けます。この方法は、メイルバッファ、
コンパイルバッファ、特定の名前のバッファを作るEmacsの多くの機能にも有
効です。

`M-x view-buffer'は、既存のEmacsバッファを調べることを除けば、`M-x
view-file'（*Note Misc File Ops::）によく似ています。閲覧（view）モー
ドには、バッファを簡単にスクロールするためのコマンドがありますが、変更
するコマンドはありません。`q'で閲覧（view）モードから抜けると、ウィン
ドウにまえに表示していたバッファ（とその中での箇所）に切り替わります。
あるいは、`e'で閲覧（view）モードから抜けると、閲覧していたバッファと
そのポイント位置はそのまま残ります。

コマンド、`M-x append-to-buffer'と`M-x insert-buffer'は、1つのバッファ
から別のバッファへテキストをコピーするのに使います。*Note Accumulating
Text::。



File: emacs-ja.info, Node: Kill Buffer, Next: Several Buffers, Prev: Misc Buffer, Up: Buffers

バッファの消去
==============

Emacsのセッションをしばらく続けると、たくさんの数のバッファが溜ってい
るでしょう。もう必要としないバッファを"消去"したほうがよいと思うかもし
れません。多くのオペレーティングシステムでは、バッファを消去するとその
メモリ領域を解放してオペレーティングシステムに返すので、他のプログラム
が使えるようになります。バッファを消去するコマンドをいくつかあげます。

`C-x k BUFNAME RET'
     バッファBUFNAMEを消去する（`kill-buffer'）。
`M-x kill-some-buffers'
     1つ1つ各バッファを消去するかどうか聞いてくる。


`C-x k'（`kill-buffer'）は、ミニバッファで指定した名前のバッファを消去
します。ミニバッファでRETだけ打ったときに使われるデフォルトは、カレン
トバッファを消去することです。カレントバッファを消去すると、別のバッファ
が選択されます。どのウィンドウにも表示されていない、もっとも最近に選択
されたバッファです。ファイルを訪問して修正してある（編集後に保存してい
ない）バッファを消去しようとすると、バッファを消去するまえに`yes'での
確認を求めます。

コマンド`M-x kill-some-buffers'は、1つ1つ各バッファについて消去するか
聞いてきます。`y'と答えると、そのバッファを消去します。カレントバッファ
や未保存の変更を含むバッファを消去しようとすると、新しいバッファを選択
するか`kill-buffer'のように確認を求めてきます。

バッファメニュー機能（*Note Several Buffers::）も、さまざまなバッファ
を削除するのに便利です。

バッファを削除するときに、毎回何か特別なことをしたいならば、フック
`kill-buffer-hook'にフック関数を追加します（*Note Hooks::）。

多くの人々がやるように、何日にもわたってたった1つのEmacsセッションを実
行する場合、数日前に使ったバッファで一杯になることがあります。コマンド
`M-x clean-buffer-list'は、それらのバッファを消去する便利な方法です。
長い期間にわたって使っていない未修正のバッファすべてを消去します。3日
間表示していない普通のバッファは消去されます。しかし、特定のバッファを
自動的には消去しないようにしたり、ほんの数時間使用しないだけで消去する
ようにも指定できます。

真夜中（midnight）モードをオンにすれば、このようなバッファの消去を毎日
真夜中に行わせることもできます。真夜中（midnight）モードは、毎日真夜中
に動作します。真夜中に、`clean-buffer-list'、あるいは、ノーマルフック
`midnight-hook'に指定した関数を実行します。

真夜中（midnight）モードをオンにするには、カスタマイズ（customization）
バッファを使って、変数`midnight-mode'に`t'を設定します。*Note Easy
Customization::。



File: emacs-ja.info, Node: Several Buffers, Next: Indirect Buffers, Prev: Kill Buffer, Up: Buffers

複数バッファの操作
==================

"バッファメニュー"（buffer-menu）機能は『バッファに対するdired』に似て
います。このコマンドは、バッファ一覧を収めたEmacsバッファを編集するこ
とで、さまざまなEmacsバッファを操作できます。バッファの保存、消去（こ
こではdiredとの一貫性のために"削除"と呼ぶ）、表示を行うことができます。

`M-x buffer-menu'
     すべてのEmacsバッファの一覧を収めたバッファを編集し始める。

コマンド`buffer-menu'は、すべてのEmacsバッファの一覧をバッファ`*Buffer
List*'に書き、そのバッファをバッファメニュー（buffer-menu）モードにし
て選択します。そのバッファは読み出し専用で、本節で述べる特別なコマンド
でのみ変更できます。普通のEmacsカーソル移動コマンドは、`*Buffer List*'
バッファでも使えます。つぎにあげるコマンドは、現在行に書かれているバッ
ファに作用します。

`d'
     バッファを削除（消去）するように指示し、1行下へ移動する。この指示
     は、その行のバッファ名のまえに`D'を表示する。指示した削除は、`x'
     コマンドを打ったときに実行される。
`C-d'
     `d'に似ているが、1行下へ移動するかわりに上へ移動する。
`s'
     バッファを保存するように指示する。この指示により、行には`S'が表示
     される。指示した保存は、`x'コマンドを打ったときに実行される。同じ
     バッファに対して、保存と削除の両方を指示できる。
`x'
     まえに指示した削除と保存を実行する。
`u'
     現在行に対する指示を消し、1行下へ移動する。
`DEL'
     1つまえの行に移動し、その行に対するどんな指示も消す。

`d'、`C-d'、`s'、`u'コマンドは、フラグを追加または削除して、1行下へ
（あるいは上へ）移動します。これらのコマンドは、反復回数として数引数を
取ります。

つぎにあげるコマンドは、現在行に書かれているバッファにただちに作用しま
す。

`~'
     バッファに『変更なし』と印を付ける。コマンド`~'を打つと、ただちに
     実行する。
`%'
     バッファの読み出し専用フラグをトグルする。コマンド`%'を打つと、た
     だちに実行する。
`t'
     タグテーブルとしてバッファを訪問する。*Note Select Tags Table::。

他のバッファや複数のバッファを選択するコマンドもあります。

`q'
     バッファメニューをやめる。このウィンドウには、ここに表示していた
     もっとも最近のバッファを表示する。
`RET'
`f'
     `*Buffer List*'のかわりに、この行のバッファをただちに選択する。
`o'
     `C-x 4 b'のように、別のウィンドウでこの行のバッファをただちに選択
     する。`*Buffer List*'はそのまま。
`C-o'
     別のウィンドウにこの行のバッファをただちに表示するが、そのウィン
     ドウを選択しない。
`1'
     この行のバッファを画面一杯のウィンドウにただちに選択する。
`2'
     ただちに2つのウィンドウにして、この行のバッファをその1つに、
     （`*Buffer List*'バッファを除いて）まえに選択していたバッファをも
     う1つに表示する。
`b'
     この行のバッファを一覧の最後に移す。
`m'
     `v'コマンドでバッファメニューをやめたときに、この行のバッファを別
     のウィンドウに表示するように印を付ける。この指示は、行頭に`>' を
     表示する。（1つのバッファに、削除指示と表示指示の両方を付けること
     はできない。）
`v'
     ただちにこの行のバッファを選択し、別のウィンドウ群には`m'コマンド
     で印を付けたバッファ群を表示する。印を付けたバッファがなければ、
     このコマンドは`1'コマンドと同じ。

`buffer-menu'が直接行うことは、適切なバッファを作成してそれに切り替え
てから、バッファメニュー（buffer-menu）モードにすることです。それ以外
の上に述べたことはすべて、バッファメニュー（buffer-menu）モードが用意
した特別なコマンドで実装されています。その結果、`*Buffer List*'バッファ
から別のEmacsバッファへ切り替えて、そこで編集できます。あとで`*Buffer
List*'バッファをふたたび選択してすでに指示した操作を実行したり、このバッ
ファを削除したり、無視したりもできます。

`buffer-menu'と`list-buffers'の唯一の違いは、`buffer-menu'は選択された
ウィンドウで`*Buffer List*'バッファに切り替えることです。
`list-buffers'は別のウィンドウにこのバッファを表示するだけです。
`list-buffers'を実行し（つまり、`C-x C-b'と打つ）、`*Buffer List*'バッ
ファを手動で選択すると、ここに述べたすべてのコマンドを使えます。

バッファを作成したり削除したりしても、バッファ`*Buffer List*'は自動的
に更新されません。その内容はただのテキストにすぎません。バッファを作成／
削除／改名したら、現在のバッファの状態を見るために`*Buffer List*'を更
新する方法は、`g'（`revert-buffer'）を打つか、`buffer-menu'コマンドを
再度実行することです。



File: emacs-ja.info, Node: Indirect Buffers, Prev: Several Buffers, Up: Buffers

間接バッファ
============

"間接バッファ"は、他のバッファとテキストを共有します。そのような他のバッ
ファを間接バッファの"基底バッファ"と呼びます。ある意味で、ファイルのあ
いだのシンボリックリンクに似ています。

`M-x make-indirect-buffer BASE-BUFFER RET INDIRECT-NAME RET'
     BASE-BUFFERを基底バッファとする間接バッファINDIRECT-NAMEを作る。

間接バッファのテキストはつねに基底バッファのテキストと同じです。どちら
か片方を編集して変更すると、他方のバッファでもすぐにそれが見えます。し
かし、それ以外のすべての点では、間接バッファとその基底バッファは完全に
別のものです。これらは、異なる名前、異なるポイントの値、異なるナロイン
グ、異なるマーカ、異なるメジャーモード、異なるローカル変数を持ちます。

間接バッファではファイルを訪問できませんが、基底バッファではできます。
間接バッファを保存しようとすると、実際には基底バッファを保存します。基
底バッファを消去すると間接バッファも消去されますが、間接バッファを消去
しても基底バッファには影響しません。

間接バッファの使い方の1つは、アウトラインを複数の視点で表示することで
す。*Note Outline Views::。


File: emacs-ja.info, Node: Windows, Next: Frames, Prev: Buffers, Up: Top

複数のウィンドウ
****************

Emacsは、フレームを2つ以上のウィンドウに分割できます。複数のウィンドウ
は、異なるバッファの一部分、あるいは、1つのバッファの異なる部分を表示
することができます。複数フレームはつねに複数ウィンドウを意味します。と
いうのは、各フレームはそれ独自のウィンドウの集合を持つからです。各ウィ
ンドウはたった1つのフレームだけに属します。

* Menu:

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Force Same Window::   Forcing certain buffers to appear in the selected
                          window rather than in another window.
* Change Window::       Deleting windows and changing their sizes.



File: emacs-ja.info, Node: Basic Window, Next: Split Window, Up: Windows

Emacsウィンドウの概念
=====================

各Emacsウィンドウは、いつでも1つのEmacsバッファを表示します。1つのバッ
ファは複数のウィンドウに表示できます。その場合、そのテキストの変更は、
そのバッファを表示しているすべてのウィンドウで表示されます。しかし、同
じバッファを表示している各ウィンドウではバッファの異なる部分を表示する
ことができます。なぜなら、各ウィンドウはそれ自身のポイント値を持つから
です。

どんなときでも、1つのウィンドウだけが"選択されたウィンドウ"です。その
ウィンドウに表示されているバッファがカレントバッファです。端末のカーソ
ルは、そのウィンドウのポイント位置を示します。別の各ウィンドウにもそれ
ぞれ同じようにポイント位置がありますが、端末にはカーソルは1つしかない
ので、それらの位置を示す方法がありません。Xウィンドウシステムで複数フ
レームを表示しているときには、各フレームには、そのフレームで選択された
ウィンドウにカーソルがあります。選択されているフレームのカーソルは塗り
潰されている矩形で、それ以外のフレームのカーソルは中空の矩形です。

ポイントを移動するコマンドは、選択されているEmacsウィンドウのポイント
値に対してだけ影響します。たとえ同じバッファを表示しているとしても、他
のEmacsウィンドウのポイント値は変更しません。選択しているウィンドウで
選択しているバッファを変更する`C-x b'といったコマンドでも同様です。他
のウィンドウには少しも影響しません。しかし、別のウィンドウを選択してそ
のバッファを切り替える`C-x 4 b'のようなコマンドもあります。さらに、
（たとえば）`C-h f'（`describe-function'）や`C-x C-b'（`list-buffers'）
などを含むウィンドウに情報を表示するコマンドは、選択されているウィンド
ウに影響することなく、選択されていないウィンドウのバッファを切り替えま
す。

複数のウィンドウが同じバッファを表示するとき、異なるリージョンを持つこ
とができます。というのは、各ウィンドウは、それぞれ異なるポイント値を持
てるからです。しかしながら、各バッファにはたった1つのマーク位置しかな
いため、マークの値はすべて同じになります。

各ウィンドウにはそれ専用のモード行があり、そこにはウィンドウに表示して
いるバッファの名前、修正状態、バッファのメジャーモード、バッファのマイ
ナモードを表示します。モード行に関して詳しくは、*Note Mode Line::。




File: emacs-ja.info, Node: Split Window, Next: Other Window, Prev: Basic Window, Up: Windows

ウィンドウの分割
================

`C-x 2'
     選択されているウィンドウを上下2つに分割する。
     （`split-window-vertically'）。
`C-x 3'
     選択されているウィンドウを左右2つに分割する
     （`split-window-horizontally'）。
`C-Mouse-2'
     ウィンドウのモード行やスクロールバー上の位置で、そのウィンドウを
     分割する。

コマンド`C-x 2'（`split-window-vertically'）は、選択されているウィンド
ウを上下2つのウィンドウに分割します。どちらのウィンドウも同じポイント
値、同じバッファを表示するところから始まります。デフォルトでは2つのウィ
ンドウは、それぞれ、分割されるウィンドウの半分の高さになります。数引数
は上のウィンドウの行数を指定します。

`C-x 3'（`split-window-horizontally'）は、選択されているウィンドウを左
右2つのウィンドウに分割します。数引数は左側のウィンドウの桁数を指定し
ます。2つのウィンドウはスクロールバーで分けられます。画面幅に満たない
ウィンドウのモード行は、切り詰められます。Emacsが強調表示を扱えない端
末では、切り詰めたモード行が反転表示されない場合があります。

モード行やスクロールバーで`C-Mouse-2'をクリックすることで、ウィンドウ
を左右や上下に分割できます。 分割する線はクリックした位置を通ります。
モード行でクリックすると、新しいスクロールバーはクリックした点上を通り
ます。スクロールバーでクリックすると、分割したウィンドウのモード行はク
リックした位置に並びます。

ウィンドウの幅が十分でないと、長すぎて行に入りきらないテキスト行が多く
なります。これらの行すべてを継続すると混乱してしまうかもしれません。変
数`truncate-partial-width-windows'に`nil'以外を設定すると、画面幅に満
たないすべてのウィンドウで切り詰めを強制できます。これは、表示されてい
るバッファや`truncate-lines'の値とは独立しています。*Note Continuation
Lines::。

水平スクロールは左右に並べたウィンドウでよく使われます。*Note
Display::。

`split-window-keep-point'の値が`nil'以外（デフォルト）ならば、`C-x 2'
で分割した2つのウィンドウは、分割前のウィンドウのポイント値を継承しま
す。つまり、スクロールを避けられません。この変数が`nil'ならば、`C-x 2'
は、画面上のテキストが移動しないように、各ウィンドウで見えている部分に
ポイントを移動しようと試みます。また、分割前にカーソルがあった行を表示
しているウィンドウを選択します。遅い端末では後者の動作を好むユーザーも
います。



File: emacs-ja.info, Node: Other Window, Next: Pop Up Window, Prev: Split Window, Up: Windows

別のウィンドウの使い方
======================

`C-x o'
     別のウィンドウを選択する（`other-window'）。（小文字の）`o'であっ
     てゼロではない。
`C-M-v'
     つぎのウィンドウをスクロールする（`scroll-other-window'）。
`M-x compare-windows'
     選択されているウィンドウのテキストとつぎのウィンドウのテキストで
     一致していないつぎの箇所を探す。
`Mouse-1'
     ウィンドウのモード行で`Mouse-1'をクリックすると、そのウィンドウを
     選択するがポイントは移動しない（`mouse-select-window'）。

別のウィンドウを選択するには、そのモード行で`Mouse-1'をクリックします。
キーボードからは、`C-x o'（`other-window'）でウィンドウを切り替えられ
ます。これは「other」の`o'であってゼロではありません。2つ以上のウィン
ドウがあるときは、このコマンドはすべてのウィンドウを、一般的には、上か
ら下へ、左から右へ巡回します。もっとも右下のウィンドウのつぎは、左上隅
にあるウィンドウに戻ります。数引数は、ウィンドウを巡回する回数を意味し
ます。負の引数では逆順に巡回します。ミニバッファを使っているときには、
ミニバッファが巡回の最後のウィンドウになります。ミニバッファウィンドウ
から別のウィンドウに切り替えて、あとで戻ってきて、ミニバッファ引数が要
求しているものを与えてから終了できます。*Note Minibuffer Edit::。

通常のスクロールコマンド（*Note Display::）は、選択されているウィンド
ウのみに作用しますが、つぎのウィンドウをスクロールするコマンドが1つあ
ります。`C-M-v'（`scroll-other-window'）は、`C-x o'が選択するウィンド
ウをスクロールします。`C-v'のように正負の引数を取ります。（ミニバッファ
では、ミニバッファヘルプがあると、標準の巡回順でつぎのウィンドウではな
くて、ミニバッファヘルプを表示しているウィンドウをスクロールする。）

コマンド`M-x compare-windows'は、2つのウィンドウで見えている2つのファ
イル、つまり、バッファを比較して、一致しないつぎの箇所へ移動します。詳
細は、*Note Comparing Files::。



File: emacs-ja.info, Node: Pop Up Window, Next: Force Same Window, Prev: Other Window, Up: Windows

別のウィンドウに表示する
========================

`C-x 4'は、（ウィンドウが1つだけならば分割して）別のウィンドウを選択し
て、そのウィンドウでバッファを選択するコマンドのプレフィックスキーです。
異なる`C-x 4'コマンドは、異なる方法で選択するバッファを探します。

`C-x 4 b BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを選択する。このコマンドは、
     `switch-to-buffer-other-window'を実行する。
`C-x 4 C-o BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを表示するが、そのウィンドウもその
     バッファも選択しない。このコマンドは、`display-buffer'を実行する。
`C-x 4 f FILENAME RET'
     ファイルFILENAMEを訪問して、別のウィンドウでそのバッファを選択す
     る。このコマンドは、`find-file-other-window'を実行する。*Note
     Visiting::。
`C-x 4 d DIRECTORY RET'
     別のウィンドウでディレクトリDIRECTORYに対するdiredバッファを選択
     する。このコマンドは、`dired-other-window'を実行する。*Note
     Dired::。
`C-x 4 m'
     別のウィンドウでメイルメッセージを作成し始める。このコマンドは、
     `mail-other-window'を実行する。これは、同じウィンドウを使う`C-x
     m'に類似したもの。（*Note Sending Mail::）。
`C-x 4 .'
     別のウィンドウで現在のタグテーブルのタグを探す。このコマンドは、
     `find-tag-other-window'を実行するが、`M-.'の複数ウィンドウ向けの
     変種（*Note Tags::）。
`C-x 4 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し、別のウィンドウでそのバッ
     ファを選択する。このコマンドは `find-file-read-only-other-window'
     を実行する。*Note Visiting::。



File: emacs-ja.info, Node: Force Same Window, Next: Change Window, Prev: Pop Up Window, Up: Windows

同じウィンドウへの強制表示
==========================

ある種のEmacsコマンドは、特別な内容を持つ特有のバッファに切り替えます。
たとえば、 `M-x shell'は、`*Shell*'という名前のバッファに切り替えます。
慣習では、これらのすべてのコマンドは、別のウィンドウにバッファを立ち上
げるようにプログラムされています。しかし、これらのバッファのいくつかを
選択されているウィンドウに表示するように指定できます。

バッファ名をリスト`same-window-buffer-names'に追加すると、そういったコ
マンドは、選択されているウィンドウで特定のバッファに切り替えます。たと
えば、そのリストに要素`"*grep*"'を追加すれば、`grep'コマンドは、選択さ
れているウィンドウにその出力バッファを表示します。

`same-window-buffer-names'のデフォルト値は`nil'ではありません。（古い
Emacsパッケージが使うものも含めて）バッファ名、`*info*'、`*mail*'、
`*shell*'を指定してあります。このため、`M-x shell'が通常は選択されてい
るウィンドウで`*shell*'バッファに切り替えるのです。もしこの要素を
`same-window-buffer-names'から削除すると、`M-x shell'のふるまいは変わ
ります。かわりに別のウィンドウでバッファを立ち上げます。

これらのバッファを、より一般的に変数`same-window-regexps'で指定できま
す。この変数には、正規表現のリストを設定します。そうすると、正規表現の
1つに一致するバッファはどれも、選択されているウィンドウでバッファを切
り替えて表示します。（繰り返すが、これは、普通は別のウィンドウに表示さ
れるバッファのみにあてはまる。）この変数のデフォルト値には、telnetバッ
ファとrloginバッファが指定されています。

類似の機能で、独立したフレームに表示させるバッファを指定することができ
ます。*Note Special Buffer Frames::。



File: emacs-ja.info, Node: Change Window, Prev: Force Same Window, Up: Windows

ウィンドウの削除と再配置
========================

`C-x 0'
     選択されているウィンドウを削除する（`delete-window'）。このキー列
     の最後の文字はゼロ。
`C-x 1'
     選択されているウィンドウを除いて、選択されているフレームのウィン
     ドウすべてを削除する（`delete-other-windows'）。
`C-x 4 0'
     選択されているウィンドウを削除し、その中に表示されているバッファ
     を削除する（`kill-buffer-and-window'）。このキー列の最後の文字は
     ゼロ。
`C-x ^'
     選択されているウィンドウの高さを大きくする（`enlarge-window'）。
`C-x }'
     選択されているウィンドウの幅を広くする
     （`enlarge-window-horizontally'）。
`C-x {'
     選択されているウィンドウの幅を狭くする
     （`shrink-window-horizontally'）。
`C-x -'
     バッファがそんなに多くの行を必要としないならウィンドウを縮める
     （`shrink-window-if-larger-than-buffer'）。
`C-x +'
     すべてのウィンドウを同じ高さにする（`balance-windows'）。
`Drag-Mouse-1'
     ウィンドウのモード行を`Mouse-1'で上下にドラッグして、ウィンドウの
     高さを変更する。
`Mouse-2'
     ウィンドウのモード行で`Mouse-2'をクリックすると、フレーム内のその
     ウィンドウ以外のすべてのウィンドウを削除する
     （`mouse-delete-other-windows'）。
`Mouse-3'
     ウィンドウのモード行で`Mouse-3'をクリックすると、そのウィンドウを
     削除する（`mouse-delete-window'）。

ウィンドウを削除するには、`C-x 0'（`delete-window'）と打ちます（これは
ゼロ）。削除されたウィンドウが占めていた場所は、隣接のウィンドウに与え
られます。（ただし、ミニバッファのウィンドウを使っている場合でも、ミニ
バッファのウィンドウには与えない。）ウィンドウを一度削除すると、その属
性は失われます。ウィンドウの構成情報を回復する以外にウィンドウをもとに
戻す方法はありません。ウィンドウを削除しても、そこに表示していたバッファ
には何の影響もありません。バッファは存在し続け、どのウィンドウへでも
`C-x b'で選択できます。

`C-x 4 0'（`kill-buffer-and-window'）は、`C-x 0'よりも強いコマンドです。
これは、カレントバッファを削除し、そこで選択されていたウィンドウを削除
します。

`C-x 1'（`delete-other-windows'）は、別の意味でさらに強力です。選択さ
れているウィンドウ（とミニバッファ）を除いて、すべてのウィンドウを削除
します。選択されているウィンドウは、エコー領域を除いたフレーム全体を使
うように広がります。

モード行で`Mouse-2'をクリックしても、そのウィンドウを削除できます。モー
ド行で`Mouse-3'をクリックすると、そのウィンドウを除いて、フレーム内の
すべてのウィンドウを削除します。

ウィンドウの高さを調節するもっとも簡単な方法は、マウスを使うことです。
モード行で`Mouse-1'を押し下げてモード行を上下にドラッグすると、ウィン
ドウの高さを変更できます。

上下に接しているウィンドウの分割を再調整するには、`C-x ^'
（`enlarge-window'）を使います。このコマンドは、現在選択されているウィ
ンドウを1行だけ、あるいは、数引数分の行数だけ大きくします。負の引数を
指定すると、選択されているウィンドウは小さくなります。`C-x }'
（`enlarge-window-horizontally'）は、選択されているウィンドウを指定さ
れた桁数分だけ広くします。`C-x {'（`shrink-window-horizontally'）は、
選択されているウィンドウを指定された桁数分だけ狭くします。

ウィンドウを大きくするとき、その場所は隣のウィンドウから取ります。その
結果、ウィンドウが小さくなりすぎるとそのウィンドウは削除され、その場所
を隣接するウィンドウに与えます。最小の大きさは変数`window-min-height'
と`window-min-width'で指定します。

コマンド`C-x -'（`shrink-window-if-larger-than-buffer'）は、選択されて
いるウィンドウの高さが、表示しているバッファのテキスト全体を表示するた
めに必要な高さよりも大きい場合には、その高さを縮めます。余った行はフレー
ム内の他のウィンドウに与えられます。

選択されているフレーム内のすべてのウィンドウの高さをすべて同じにするに
は、`C-x +'（`balance-windows'）を使えます。

ミニバッファのテキストにちょうど合うようにミニバッファウィンドウの大き
さを自動的に変更するミニバッファリサイズ（resize-minibuffer）モードに
ついては、*Note Minibuffer Edit::。


File: emacs-ja.info, Node: Frames, Next: International, Prev: Windows, Up: Top

フレームとXウィンドウシステム
*****************************

Xウィンドウシステムで使っているときには、1つのEmacsセッションでXのレベ
ルで複数のウィンドウを作ることができます。Emacsに属するXの各ウィンドウ
は、Emacsのウィンドウを1つ以上含めことができる"フレーム"（frame）を表
示します。フレームは、最初は汎用のEmacsのウィンドウを1つ含みますが、上
下左右に小さなウィンドウに分割できます。フレームは通常、専用のエコー領
域とミニバッファを含みますが、それらを含まないものを作ることもできます。
その場合は、別のフレームのエコー領域やミニバッファを使います。

あるフレームでの編集は、別のフレームにも影響します。たとえば、あるフレー
ムでキルリングにテキストを入れると、別のフレームでヤンクできます。ある
フレームで`C-x C-c'でEmacsを終ると、すべてのフレームを終了します。1つ
のフレームだけを削除するなら、`C-x 5 0'を使います。

混乱を避けるために、Emacsが実装している細分化できるものを『ウィンドウ』
と呼び、フレームを意味するときにはこの単語を使いません。

MS-DOS用にコンパイルしたEmacsは、ウィンドウシステムのある種の特徴をエ
ミュレートするので、本章で説明する機能の多くを使うことができます。詳し
くは、*Note MS-DOS Input::。

* Menu:

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Secondary Selection:: Cutting without altering point and mark.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Speedbar::            How to make and use a speedbar frame.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Multiple Displays::   How one Emacs job can talk to several displays.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::	        How to enable and disable scroll bars; how to use them.
* Menu Bars::	        Enabling and disabling the menu bar.
* Faces::	        How to change the display style using faces.
* Font Lock::           Minor mode for syntactic highlighting using faces.
* Support Modes::       Font Lock support modes make Font Lock faster.
* Highlight Changes::   Using colors to show where you changed the buffer.
* Misc X::	        Iconifying and deleting frames. Region highlighting.
* Non-Window Terminals::  Multiple frames on terminals that show only one.



