Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Mouse Commands, Next: Secondary Selection, Up: Frames

編集用マウスコマンド
====================

リージョンを選択したりコピーしたりするマウスコマンドは、`xterm'プログ
ラムとほぼ互換です。Emacsと他のXクライアントプログラムとのあいだでコピー
するには、Xのマウスコマンドと同じものを使えます。

これらのマウスコマンドでリージョンを選択して、そのあとすぐにファンクショ
ンキーDELETEを打つと、選択したリージョンを削除します。ファンクションキー
BACKSPACEやASCII文字DELは、これを行いません。マウスコマンドとDELETEの
あいだに別のキーを打ったときも、これを行いません。

`Mouse-1'
     クリックした位置にポイントを移動する（`mouse-set-point'）。通常、
     左ボタン。

`Drag-Mouse-1'
     ドラッグにより選択したテキストにリージョンを設定し、キルリングに
     それをコピーする（`mouse-set-region'）。リージョンの始めと終りの
     両方をこのコマンド1つで指定できる。

     ドラッグ中に、ウィンドウの上下からマウスが出ると、マウスがウィン
     ドウ内に戻ってくるまで、ウィンドウを一定の割合でスクロールする。
     こうして、画面全体に入りきらないリージョンでも選択できる。一度に
     スクロールする行数は、マウスがウィンドウの縁からどの程度離れてい
     るかに依存する。変数`mouse-scroll-min-lines'には最小の行数を指定
     する。

`Mouse-2'
     クリックした場所に、もっとも最近にキルしたテキストをヤンクする
     （`mouse-yank-at-click'）。通常、中ボタン。

`Mouse-3'
     このコマンド`mouse-save-then-kill'は、クリックした場所とリージョ
     ンの状態に依存して、いくつかの機能がある。

     もっとも基本的な場合は、ある場所で`Mouse-1'をクリックしてから、別
     の場所で`Mouse-3'をクリックしたとき。こうすると、これらの2点のあ
     いだにあるテキストをリージョンとして選択する。さらに、新しいリー
     ジョンをキルリングへもコピーするので、別の場所へそれをコピーでき
     る。

     テキスト上で`Mouse-1'をクリックしてから、スクロールバーでスクロー
     ルしたあとで`Mouse-3'をクリックすると、スクロールする以前の
     （`Mouse-1'でクリックした）場所を覚えていて、そこをリージョンの片
     方の端点として使う。こうすると、画面に入りきらないリージョンでも
     選択できる。

     より一般的には、強調表示されたリージョンがないならば、`Mouse-3'は、
     ポイントとクリックした位置のあいだのテキストをリージョンとして選
     択する。これは、ポイントがあった位置にマークを設定し、クリックし
     た位置にポイントを移動することで行う。

     強調表示されたリージョンがある場合、あるいは、ボタン1をドラッグし
     てリージョンを設定してある場合、`Mouse-3'はクリックした場所に近い
     側のリージョンの端をクリック位置に移動して調整する。また、調整し
     たリージョンのテキストは、キルリング内の古いリージョンのテキスト
     を置き換える。

     もともと`Mouse-1'をダブルクリックあるいはトリプルクリックして、リー
     ジョンを単語や行単位で設定した場合には、`Mouse-3'によるリージョン
     の調整も単語や行単位で行われる。

     連続して2度同じ場所で`Mouse-3'を使うと、すでに選択してあるリージョ
     ンをキルする。

`Double-Mouse-1'
     このキーは、クリックした単語全体にリージョンを設定する。『シンボ
     ル』の構文（Cの下線のような）の文字をクリックすると、その文字を囲
     むシンボル全体にリージョンを設定する。

     開き括弧や閉じ括弧の構文の文字をクリックすると、その文字で始まり／
     終る括弧で囲まれた塊（sexp）にリージョンを設定する。文字列区切り
     の構文（Cのシングルクォートやダブルクォート）の文字をクリックする
     と、（その文字が文字列の始まりか終りかを発見的方法を使って決めて）
     文字列定数を囲むリージョンを設定する。

`Double-Drag-Mouse-1'
     このキーは、ドラッグした範囲内にある単語を囲むリージョンを設定す
     る。

`Triple-Mouse-1'
     このキーは、クリックした行全体を囲むリージョンを設定する。

`Triple-Drag-Mouse-1'
     このキーは、ドラッグした範囲内にある行すべてを囲むリージョンを設
     定する。

マウスを使ったもっとも単純なテキストのキル方法は、片方の端で`Mouse-1'
を押し、もう一方の端で`Mouse-3'を2回押すことです。*Note Killing::。バッ
ファから削除しないでキルリングにテキストをコピーするには、`Mouse-3'を
一度だけ押します。あるいは、`Mouse-1'でテキストを横断してドラッグする
だけです。そうすると、どこででも、それをヤンクすることでコピーできます。

キルしたりコピーしたりしたテキストをどこか別の場所にヤンクするには、マ
ウスをその場所に移動して`Mouse-2'を押します。*Note Yanking::。しかし、
`mouse-yank-at-point'が`nil'以外ならば、`Mouse-2'はポイント位置にヤン
クします。つまり、ウィンドウのどこをクリックしたのか、あるいは、フレー
ムのどのウィンドウをクリックしたのかは問題ではありません。デフォルトの
値は`nil'です。この変数は二次セレクションのヤンクにも影響します。

別のXのウィンドウへテキストをコピーするには、その部分をキルするかキル
リングに保存します。Xの管理下では、"一次セレクション"も設定します。そ
のあとで、別のXのウィンドウで動いているプログラムの『ペースト』や『ヤ
ンク』コマンドを使って、セレクションからテキストを挿入します。

別のXのウィンドウからテキストをコピーするには、そのウィンドウで動いて
いるプログラムの『カット』や『コピー』コマンドを使って目的のテキストを
セレクションにします。そのあとで、`C-y'や`Mouse-2'を使ってEmacsにヤン
クします。

これらのカット／ペーストコマンドはMS-Windows上でも動作します。

Emacsがテキストをキルリングに入れたり、キルリングのテキストを先頭へ巡
回するとき、EmacsはXサーバーの一次セレクションに設定します。このために、
別のXクライアントがテキストを参照できるのです。テキストが十分に短い場
合にのみ（`x-cut-buffer-max'は最大文字数を指定する）、Emacsはカットバッ
ファにもテキストを収めます。長い文字列をカットバッファへ置くには時間が
かかります。

キルリングの始めのテキストをヤンクするコマンドは、実際には、別のプログ
ラムの一次セレクションをまず調べ、そのあとで、カットバッファのテキスト
を調べます。どちらにもヤンクするテキストがなれば、キルリングの内容を使
います。



File: emacs-ja.info, Node: Secondary Selection, Next: Mouse References, Prev: Mouse Commands, Up: Frames

二次セレクション
================

"二次セレクション"は、Xにおいてテキストを選択する別の方法です。これは、
ポイントやマークを使わないので、ポイントやマークを設定せずにテキストを
削除するのに使えます。

`M-Drag-Mouse-1'
     ボタンを押した場所を片方の端、ボタンを離した場所をもう一方の端と
     して、二次セレクションを設定する（`mouse-set-secondary'）。強調表
     示されドラッグするにつれて変化する。

     ドラッグ中にウィンドウの上下からマウスが出ると、ウィンドウへマウ
     スが戻ってくるまで、ウィンドウを一定の割合でスクロールする。こう
     して、画面全体に入りきらないリージョンも選択できる。

`M-Mouse-1'
     "二次セレクション"の一方の端を設定する（`mouse-start-secondary'）。

`M-Mouse-3'
     `M-Mouse-1'で指定した場所を一方の端として使い、二次セレクションを
     設定する。（`mouse-secondary-save-then-kill'）。同じ位置での2回目
     のクリックは、ちょうど作成した二次セレクションをキルする。

`M-Mouse-2'
     クリックした位置に二次セレクションを挿入する
     （`mouse-yank-secondary'）。ヤンクしたテキストの最後にポイントを
     置く。

`M-Mouse-1'のダブルクリックやトリプルクリックは、`Mouse-1'のように単語
や行単位に作用します。

`mouse-yank-at-point'が`nil'以外ならば、`M-Mouse-2'はポイント位置にヤ
ンクします。そのときには、どこをクリックしたかは関係なく、どのウィンド
ウをクリックしたかだけが関係します。*Note Mouse Commands::。



File: emacs-ja.info, Node: Mouse References, Next: Menu Mouse Clicks, Prev: Secondary Selection, Up: Frames

マウスで参照を辿る
==================

いくつかのEmacsバッファでは、いろいろなものの一覧を表示します。ファイ
ル一覧、バッファ一覧、補完候補一覧、パターンに一致したものの一覧などで
す。

これらのバッファにテキストをヤンクできても便利ということはないので、こ
れらの多くは`Mouse-2'を特別に定義して、クリックした項目を使ったり眺め
たりするコマンドとしています。

たとえば、diredバッファのファイル名を`Mouse-2'でクリックすると、そのファ
イルを訪問します。`*Compilation*'バッファのエラーメッセージを`Mouse-2'
でクリックすると、そのエラーメッセージに対応するソースコードへ行きます。
`*Completions*'バッファの補完候補を`Mouse-2'でクリックすると、その補完
候補を選択します。

反応するテキストの上にマウスが移動するとテキストが強調表示されるので、
`Mouse-2'がいつ特別な意味を持つか普通はわかります。



File: emacs-ja.info, Node: Menu Mouse Clicks, Next: Mode Line Mouse, Prev: Mouse References, Up: Frames

メニューを出すマウスクリック
============================

CTRLやSHIFTキーで修飾されたマウスクリックは、メニューを立ち上げます。

`C-Mouse-1'
     バッファを選択するためのメニュー。

`C-Mouse-2'
     整形済みのテキストに使うフェイスやテキスト属性を指定するためのメ
     ニュー。*Note Formatted Text::。

`C-Mouse-3'
     モードに特有のメニュー。ほとんどのモードでは、このメニューは、す
     べてのモード特有のメニューバーメニューを一緒にしたのと同じ項目を
     持つ。いくつかのモードでは、このボタン (1) (*Note Menu Mouse
     Clicks-Footnotes::) に異なるメニューを指定しているかもしれない。


`S-mouse-1'
     フレームの主要フォントの指定に関するメニュー。


File: emacs-ja.info  Node: Menu Mouse Clicks-Footnotes, Up: Menu Mouse Clicks

(1) いくつかのシステムでは、`Mouse-3'をモード特有のメニューに
使う。ユーザーを調査した結果、`Mouse-3'をリージョンの選択とキ
ルに使い続けることが好まれていることが判明した。ゆえに、このメニュー
に対して`C-Mouse-3'を使うことにした。



File: emacs-ja.info, Node: Mode Line Mouse, Next: Speedbar, Prev: Menu Mouse Clicks, Up: Frames

モード行のマウスコマンド
========================

ウィンドウを選択したり操作するために、ウィンドウのモード行でマウスクリッ
クを使えます。

`Mouse-1'
     モード行で`Mouse-1'をクリックするとその上のウィンドウを選択する。
     モード行を`Mouse-1'でドラッグするとモード行を移動することができ、
     そのウィンドウの高さを変更できる。

`Mouse-2'
     モード行で`Mouse-2'をクリックすると、そのフレーム一杯にウィンドウ
     を広げる。

`Mouse-3'
     モード行で`Mouse-3'をクリックすると、その上のウィンドウを削除する。

`C-Mouse-2'
     モード行で`C-Mouse-2'をクリックすると、モード行をクリックした場所
     でその上のウィンドウを左右に分割する。

スクロールバーで`C-Mouse-2'をクリックすると、対応するウィンドウを上下
に分割します。*Note Split Window::。



File: emacs-ja.info, Node: Creating Frames, Next: Multiple Displays, Prev: Speedbar, Up: Frames

フレームの作成
==============

プレフィックスキー`C-x 5'は、`C-x 4'と同じようなサブコマンドがあるとい
う点で似ています。違いは、`C-x 5'コマンドは、選択されているフレームで
新たにウィンドウを作るのではなく、新しいフレームを作ることです（*Note
Pop Up Window::）。既存の見えているフレームやアイコン化されたフレーム
が、要求された内容を表示しているなら、これらのコマンドは、必要ならフレー
ムをいちばん手前にもってきたりアイコンを開いてから、既存のフレームを使
います。

さまざまな`C-x 5'コマンドは、選択するバッファの探し方や作成方法が異な
ります。

`C-x 5 2'
     新しいフレームを作る（`make-frame-command'）。
`C-x 5 b BUFNAME RET'
     別のフレームでバッファBUFNAMEを選択する。これは、
     `switch-to-buffer-other-frame'を実行する。
`C-x 5 f FILENAME RET'
     ファイルFILENAMEを訪問して、別のフレームでそのバッファを選択する。
     これは、`find-file-other-frame'を実行する。*Note Visiting::。
`C-x 5 d DIRECTORY RET'
     別のフレームでディレクトリDIRECTORYに対するdiredバッファを選択す
     る。これは、`dired-other-frame'を実行する。*Note Dired::。
`C-x 5 m'
     別のフレームでメイルメッセージの作成を始める。これは、
     `mail-other-frame'を実行する。これは、`C-x m'の他のフレームを使う
     変形版。*Note Sending Mail::。
`C-x 5 .'
     別のフレームで現在のタグテーブルからタグを探す。これは、
     `find-tag-other-frame'を実行し、`M-.'の複数フレーム向けの変形版。
     *Note Tags::。
`C-x 5 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し、別のフレームでそのバッファ
     を選択する。これは、`find-file-read-only-other-frame'を実行する。
     *Note Visiting::。

`default-frame-alist'にフレームパラメータを設定することで、新たに作成
するフレームの見た目を制御できます。初期フレームだけに影響するパラメー
タを指定するには、変数`initial-frame-alist'を使います。詳しくは、*Note 
初期フレームのパラメータ: (elisp)Initial Parameters。

すべてのEmacsフレームに主要フォントを指定するもっとも簡単な方法は、Xの
リソース（*Note Font X::）を使うことですが、つぎに示すように、`font'パ
ラメータを指定するように`default-frame-alist'を変更してもできます。

     (add-to-list 'default-frame-alist '(font . "10x20"))



File: emacs-ja.info, Node: Speedbar, Next: Creating Frames, Prev: Mode Line Mouse, Up: Frames

スピードバーフレームの作成と使い方
==================================

Emacsのフレームは、"スピードバー"を持つことができます。スピードバーは、
縦長のウィンドウで、訪問したりタグを探したりするためのスクロール可能な
ファイルメニューとして働きます。スピードバーを作るには、`M-x speedbar'
と打ちます。これは、選択されたフレームに対するスピードバーウィンドウを
作ります。そうすると、スピードバーのファイル名をクリックすると、対応す
るEmacsフレームでそのファイルを訪問できます。あるいは、タグの名前をク
リックすると、Emacsフレームでそのタグの箇所へ飛んで行きます。

最初、スピードバーには、カレントディレクトリの直下の内容を1行につき1つ
のファイルで表示します。各行には、`[+]'か`<+>'の箱があって、それを
`Mouse-2'でクリックするとその項目の内容を『開け』ます。その行の名前が
ディレクトリならば、それを開くと、そのディレクトリの内容をその行の下に
追加してスピードバーに表示します。その行が普通のファイルならば、それを
開くと、そのファイル内のタグ一覧をスピードバーに追加して表示します。ファ
イルが開かれていると、`[+]'は`[-]'に変わります。ファイルを『閉じる』
（内容を隠す）ためにその箱をクリックできます。

rmailモード、infoモード、GUDモードを含むいくつかのメジャーモードには、
選択可能な有用な項目をスピードバーに追加する特別な方法があります。たと
えば、rmailモードでは、スピードバーにはrmailファイル一覧を表示します。
カレントメッセージを別のrmailファイルに移すには、目的のrmailファイルの
`<M>'の箱をクリックするだけです。

スピードバーは1つのEmacsフレームに属し、つねにそのフレームに作用します。
複数のフレームを使うときには、一部のフレームやすべてのフレームにスピー
ドバーを作れます。フレームのスピードバーを作るには、そのフレームで`M-x
speedbar'と打ちます。



File: emacs-ja.info, Node: Multiple Displays, Next: Special Buffer Frames, Prev: Creating Frames, Up: Frames

複数ディスプレイ
================

1つのEmacsは、複数のXディスプレイと通信できます。最初は、Emacsは1つの
ディスプレイだけを使います。環境変数`DISPLAY'や`--display'オプションに
指定されたものです（*Note Initial Options::）。他のディスプレイに接続
するには、コマンド`make-frame-on-display'を使います。

`M-x make-frame-on-display RET DISPLAY RET'
     ディスプレイDISPLAY上に新しいフレームを作成する。

1つのXサーバーは複数のスクリーンを扱えます。1つのサーバーに属する2つの
スクリーンにフレームを開くとき、Emacsは1つのキーボードを共有しているこ
とを知っていて、これらのスクリーンから到着するすべてのコマンドを1つの
入力ストリームとして扱います。

異なるXサーバー上にフレームを開くとき、Emacsはそれぞれのサーバーに対し
て別々の入力ストリームを作ります。こうすることで、2つのディスプレイ上
で2人のユーザーが同時に打鍵でき、Emacsはそれらの入力をごっちゃにするこ
とはありません。各サーバーにはそれ自身が選択しているフレームがあります。
特定のXサーバーで入力したコマンドは、そのサーバーが選択しているフレー
ムに適用されます。

これらの機能にも関わらず、異なるディスプレイで同じEmacsジョブを使って
いる人達は、注意を怠ると、互いに干渉し合ってしまいます。たとえば、誰か
が`C-x C-c'と打つと、その人達が共有している（1つの）Emacsジョブは終了
してしまいます！



File: emacs-ja.info, Node: Special Buffer Frames, Next: Frame Parameters, Prev: Multiple Displays, Up: Frames

特別なバッファフレーム
======================

ウィンドウが1つのときにはEmacsが普通2つめのウィンドウを作るような特定
のバッファでは、それ専用の特別なフレームに表示することができます。こう
するには、変数`special-display-buffer-names'にバッファ名のリストを設定
します。そのリストに名前があるどのバッファも、Emacsコマンドが『別のウィ
ンドウに』表示したいときには、特別なフレームを自動的に取得します。

たとえば、つぎのように変数を設定したとすると、補完一覧、`grep'の出力、
TeXモードのシェルバッファは、それぞれ個別のフレームを取得します。

     (setq special-display-buffer-names
           '("*Completions*" "*grep*" "*tex-shell*"))

これらのフレームとその中のウィンドウは、別のバッファのために自動的に分
割されたり再利用されることはありません。手動で変更するまで、そのために
作成されたバッファを表示し続けます。特別なバッファを消去すると、そのフ
レームも自動的に削除されます。

より一般的には、正規表現のリストを`special-display-regexps'に設定でき
ます。すると、バッファの名前がそれらの正規表現に一致すると、バッファは
専用のフレームを取得します。（繰り返すが、これは通常、別のウィンドウに
表示するバッファにのみ適用する。）

変数`special-display-frame-alist'は、このようなフレームに対するフレー
ムパラメータを指定します。これにはデフォルト値があるので、特に設定する
必要はありません。

Lispがわかる人のためにですが、`special-display-buffer-names'や
`special-display-regexps'の要素は、リストでもかまいません。その場合、
最初の要素はバッファ名か正規表現です。リストの残りは、フレームの作成方
法を指定します。これは、フレームパラメータの値を指定する連想リストにす
ることもできます。これらの値は、`special-display-frame-alist'に指定さ
れたパラメータの値より優先されます。あるいは、リストはつぎのような形式
にすることもできます。

     (FUNCTION ARGS...)

ここで、FUNCTIONはシンボルです。こうすると、FUNCTIONを呼んでフレームを
作ります。関数呼び出しの最初の引数はバッファで、残りの引数はARGSです。

似たような機能で、バッファをどの選択されているウィンドウに表示するか指
定できます。*Note Force Same Window::。同じウィンドウに表示する機能は、
特別なフレームに表示する機能に優ります。したがって、バッファ名を
`special-display-buffer-names'に追加しても何の効果もなかったら、その機
能が同じバッファ名に対しても使われていないか調べてください。



File: emacs-ja.info, Node: Frame Parameters, Next: Scroll Bars, Prev: Special Buffer Frames, Up: Frames

フレームパラメータの設定
========================

本節では、選択しているフレームの表示スタイルやウィンドウ管理のふるまい
を変更するコマンドを説明します。

`M-x set-foreground-color RET COLOR RET'
     選択しているフレームの前景色をCOLORと指定する。

`M-x set-background-color RET COLOR RET'
     選択しているフレームの背景色をCOLORと指定する。これは`modeline'フェ
     イスの前景色も変更するので、デフォルトと比較しても反転表示のまま
     になる。

`M-x set-cursor-color RET COLOR RET'
     選択しているフレームのカーソルの表示色をCOLORと指定する。

`M-x set-mouse-color RET COLOR RET'
     マウスカーソルが選択しているフレーム内にあるときのマウスカーソル
     の表示色をCOLORと指定する。

`M-x set-border-color RET COLOR RET'
     選択しているフレームの境界色をCOLORと指定する。

`M-x list-colors-display'
     定義されている表示色の名称とそれがどう見えるか表示する。このコマ
     ンドは少し遅い。

`M-x auto-raise-mode'
     選択されているフレームをオートレイズするべきかどうか切り替える。
     オートレイズとは、マウスカーソルがフレームに入るたびに、そのフレー
     ムを手前にもってくること。

     このオートレイズ機能はEmacs自身が実装していることに注意。ウィンド
     ウマネージャの中にも、オートレイズを実装しているものがある。Xのウィ
     ンドウマネージャでEmacsフレームのオートレイズを指定しているときに
     は、それが動作するはず。しかし、それはEmacsの制御を超えているので、
     それに関しては`auto-raise-mode'は何の影響もない。

`M-x auto-lower-mode'
     選択されているフレームをオートローワするべきかどうか切り替える。
     オートローワとは、マウスカーソルがフレームから出るたびに、そのフ
     レームをXのウィンドウスタックの底に移すこと。

     コマンド`auto-lower-mode'は、Xのウィンドウマネージャが実装するオー
     トローワには何の影響もない。それを制御するには、適切なウィンドウ
     マネージャの機能を使う必要がある。

`M-x set-frame-font RET FONT RET'
     選択されたフレームに対する主要フォントとしてFONTを指定する。フェ
     イス（*Note Faces::）が別のフォントを使うことを指定しているときを
     除いて、主要フォントは、フレームに表示するすべてのテキストに対し
     て使われる。あなたのシステムで使えるフォント一覧を表示する方法に
     ついては、*Note Font X::。

     ポップアップメニューから、フレームの主要フォントを設定することも
     できる。このメニューを立ち上げるには`S-Mouse-1'を押す。

Xツールキットを使うEmacsの版では、表示色とフォントを設定する関数はメ
ニューやメニューバーには影響しません。というのは、メニューやメニューバー
は、それら自身のウィジェットクラスを使って表示されているからです。メ
ニューとメニューバーの見た目を変更するには、Xのリソースを使う必要があ
ります（*Note Resources X::）。表示色に関しては、*Note Colors X::。フォ
ントの選択については、*Note Font X::。

フレームパラメータとそのカスタマイズについては、*Note フレームパラメー
タ: (elisp)Frame Parameters。



File: emacs-ja.info, Node: Scroll Bars, Next: Menu Bars, Prev: Frame Parameters, Up: Frames

スクロールバー
==============

Xを使っているときには、Emacsは通常、各Emacsウィンドウの左側に"スクロー
ルバー"（scroll bar）を作ります。スクロールバーは、ウィンドウの高さに
延びていて、内側に動く矩形の箱を表示します。この箱は、現在表示されてい
るバッファ内の部分を表しています。スクロールバーの全体の高さは、バッファ
の全体の長さを表します。

`Mouse-2'（通常、中ボタン）を使って、スクロールバーの内側の箱を上下に
移動したりドラッグできます。内側の箱をスクロールバーのいちばん上へ移動
すると、バッファの先頭を見ることができます。スクロールバーのいちばん下
に内側の箱を移動すると、バッファの末尾が見えます。

スクロールバーで左や右ボタンを使うと、制御された増分でスクロールできま
す。`Mouse-1'（通常、左ボタン）は、クリックした場所の高さの行をウィン
ドウの最上端の行へ移動します。`Mouse-3'（通常、右ボタン）は、ウィンド
ウの最上端の行をクリックした場所の高さの行へ移動します。同じ位置で繰り
返しクリックすると、同じ分量のスクロールを繰り返します。

スクロール以外では、スクロールバーで`C-Mouse-2'をクリックすると、ウィ
ンドウを上下に分割できます。クリックした場所の行で分割されます。

コマンド`M-x scroll-bar-mode'で、スクロールバー（scroll-bar）モードを
オン／オフできます。引数を指定しなければ、スクロールバーの使用をトグル
します。引数を指定した場合、引数が正のときだけスクロールバーを使うよう
にします。このコマンドは、これから作成されるフレームを含めてすべてのフ
レームに作用します。Xのリソース`verticalScrollBars'を使って、スクロー
ルバー（scroll-bar）モードの初期設定を制御できます。*Note Resources
X::。

選択されているフレームに対してのみスクロールバーをオン／オフするには、
`M-x toggle-scroll-bar'コマンドを使います。



File: emacs-ja.info, Node: Menu Bars, Next: Faces, Prev: Scroll Bars, Up: Frames

メニューバー
============

`M-x menu-bar-mode'でメニューバーの表示をオン／オフできます。引数を指
定しないと、このコマンドはマイナモードであるメニューバー（menu-bar）モー
ドをトグルします。引数を指定した場合、引数が正ならメニューバー
（menu-bar）モードをオンにし、引数が正でないならオフにします。Xのリソー
ス`menuBarLines'を使って、メニューバー（menu-bar）モードの初期設定を制
御できます。*Note Resources X::。熟練したユーザーは、メニューバーをし
ばしばオフにし、特に文字端末上ではそうします。というのは、テキスト表示
に1行余分に使えるからです。

メニューバーでコマンドを起動する方法については、*Note Menu Bar::。



File: emacs-ja.info, Node: Faces, Next: Font Lock, Prev: Menu Bars, Up: Frames

複数タイプフェイスの利用
========================

XでEmacsを使っているとき、文字表示に複数のスタイルを設定できます。制御
できるスタイルは、フォントの種類、前景色、背景色、下線を引くかどうかで
す。MS-DOS用Emacsは、各フェイスの前景色と背景色を制御して、フェイスの
一部だけを扱えます（*Note MS-DOS::）。

表示スタイルを制御する方法は、名前付き"フェイス"を定義することです。各
フェイスでは、フォントの種類、前景色、背景色、下線フラグを指定できます。
しかし、これらすべてを指定する必要はありません。バッファ内のテキストの
一部分に対して使用するフェイスを指定することで、そのテキストの見た目を
制御できます。

テキスト中のある文字に対して使う表示スタイルは、いくつかのフェイスを組
み合わせて決定されます。重ね合わせやテキスト属性で指定されていない表示
スタイルは、フレームそのものから得ます。

整形済みテキストを編集するモードであるエンリッチ（enriched）モードには、
フェイスを指定するためのコマンドやメニューがあります。バッファ内のテキ
ストに対するフォントの指定方法については、*Note Format Faces::。前景色
と背景色の指定方法については、*Note Format Colors::。

フェイスの見た目を変更するには、カスタマイズバッファを使います*Note
Face Customization::。Xのリソースを使って、特定のフェイスの属性を指定
できます（*Note Resources X::）。

現在定義されているフェイスとその見た目を調べるには、`M-x
list-faces-display'と打ちます。あるフェイスを違うフレームでは違って見
えるようにできます。このコマンドは、コマンドを打ったフレーム上での見た
目を表示します。つぎは、標準的に定義されているフェイス一覧です。

`default'
     このフェイスは、他のフェイスを指定していない普通のテキストに使わ
     れる。
`modeline'
     このフェイスはモード行に対して使われる。デフォルトでは、`default'
     フェイスの反転表示を設定。*Note Display Vars::。
`highlight'
     このフェイスは、さまざまモードでのテキストの強調表示部分に対して
     使われる。
`region'
     このフェイスは、選択されているリージョン（暫定マーク
     （transient-mark）モードがオンのとき。下記参照）の表示に使われる。
`secondary-selection'
     このフェイスは、二次セレクションの表示に使われる（*Note Secondary
     Selection::）。
`bold'
     このフェイスは、ボールド体（太字体）があるならば、ボールド体を用
     いたデフォルトフォントの変種。
`italic'
     このフェイスは、イタリック体（斜体）があるならば、イタリック体を
     用いたデフォルトフォントの変種。
`bold-italic'
     このフェイスは、ボールドイタリック体（太字斜体）があるならば、ボー
     ルドイタリック体を用いたデフォルトフォントの変種。
`underline'
     このフェイスは、テキストに下線を引く。

暫定マーク（transient-mark）モードがオンのときは、マークが活性ならば、
リージョンのテキストは強調表示されます。これには`region'という名前のフェ
イスを使います。このフェイスのスタイルを変更することで、強調表示のスタ
イルを制御できます（*Note Face Customization::）。暫定マーク
（transient-mark）とマークの活性／不活性について詳しくは、*Note
Transient Mark::。

フェイスを使う簡単な方法の1つは、フォントロック（font-lock）モードを使
うことです。特定のバッファにつねにローカルであるこのマイナモードは、編
集するテキストの構文に従ってフェイスを選択します。このモードは、ほとん
どの言語のコメントと文字列を認識できます。いくつかの言語では、それ以外
のさまざまな重要な構造も認識して、適切に強調表示します。フォントロック
（font-lock）モードと構文の強調表示について詳しくは、*Note Font Lock::。

画面上で強調表示されたバッファは、コマンド`ps-print-buffer-with-faces'
を使って印刷できます。*Note Postscript::。



File: emacs-ja.info, Node: Font Lock, Next: Support Modes, Prev: Faces, Up: Frames

フォントロックモード
====================

フォントロック（font-lock）モードはマイナモードです。特定のバッファに
つねにローカルであり、編集しているテキストの構文に従ってさまざまなフェ
イスを使って強調表示（または『フォント表示化』）します。このモードは、
ほとんどの言語のコメントや文字列を認識できます。いくつかの言語では、他
のさまざまな重要な構成要素も認識し、正しく強調表示します。 たとえば、
定義されている関数名や予約語です。

コマンド`M-x font-lock-mode'は、引数に従ってフォントロック（font-lock）
モードをオン／オフし、引数がなければモードをトグルします。関数
`turn-on-font-lock'は、フォントロック（font-lock）モードを無条件でオン
にします。このコマンドは、モードフック関数で使うと便利です。たとえば、
Cのファイルを編集しているときにはいつでもフォントロック（font-lock）モー
ドをオンにするには、つぎのようにします。

     (add-hook 'c-mode-hook 'turn-on-font-lock)

フォントロック（font-lock）モードを扱えるすべての（メジャー）モードで
自動的にフォントロック（font-lock）モードをオンにするには、関数
`global-font-lock-mode'をつぎのように使います。

     (global-font-lock-mode 1)

フォントロック（font-lock）モードでは、テキストを編集していると、自動
的に変更した行の強調表示を更新します。ほとんどの変更は、後続行の強調表
示には影響しませんが、時折、影響することもあります。ある範囲の行を強調
表示し直すには、コマンド`M-g M-g'を使います（`font-lock-fontify-bloc
k'）。

ある種のメジャーモードでは、`M-g M-g'は、現在の関数定義全体をフォント
表示化し直します。（変数`font-lock-mark-block-function'は、現在の関数
定義の探し方を制御する。）別のメジャーモードでは、 `M-g M-g'は、ポイン
トのまえとあとの16行をフォント表示化し直します。

数引数Nを指定すると、`M-g M-g'は、モードに関係なく、 ポイントのまえと
あとのN行をフォント表示化し直します。

フォントロック（font-lock）モードの利点を十分に活用するには、ボールド
体、イタリック体、ボールドイタリック体のデフォルトフォントを選ぶ必要が
あります。あるいは、カラーやグレースケールの画面が必要です。

変数`font-lock-maximum-decoration'は、複数のレベルを提供するモードでの
フォント表示化の好ましいレベルを指定します。レベル1は最低限のフォント
表示化です。いくつかのモードでは、もっとも高い3のレベルまであります。
通常デフォルトは『可能な限り大きい数』です。すべてのモードに適用する整
数を指定できます。あるいは、特定のメジャーモードに対して異なる数を指定
できます。たとえば、C/C++モードではレベル1を、それ以外ではデフォルトの
レベルを指定するには、つぎのようにします。

     (setq font-lock-maximum-decoration
           '((c-mode . 1) (c++-mode . 1)))

フォント表示化は、大きなバッファに対してはとても遅くなりえますから、抑
制することもできます。変数`font-lock-maximum-size'にバッファサイズを指
定すると、その値を越えるバッファについてはフォント表示化を抑制します。

コメントと文字列のフォント表示化（あるいは、『構文の』フォント表示化）は、
バッファのテキストの構文解析に頼っています。
速度向上のために、CモードやLispモードを含むいくつかのモードでは、
特別な習慣に頼っています。
最左桁にある開き括弧は、つねに関数定義の開始を表し、
そのため、つねに文字列やコメントの外側だということです。
（*Note Defuns::。）
この習慣に従わないと、フォントロック（font-lock）モードは、
文字列やコメントの内側にある最左桁の開き括弧のうしろでは、
違ったフォント表示化をすることもありえます。

変数`font-lock-beginning-of-syntax-function' （つねにバッファにローカ
ル）は、フォントロック（font-lock）モードが、コメントや文字列の外側で
あることが保証される位置をどのように探すかを指定します。最左桁の括弧の
習慣を使うモードでは、変数のデフォルト値は、`beginning-of-defun'です。 
つまり、フォントロック（font-lock）モードは習慣を使うようにということ
です。この変数に`nil'を設定すると、フォントロック（font-lock）モードは、
もはや習慣に頼りません。これでまちがった結果を避けられますが、その代償
は、変更したテキストをフォント表示化するには、バッファのテキストをバッ
ファの先頭から再走査する必要がある場合もあります。

多くのモードに対するフォントロックの強調表示パターンはすでにありますが、
フォント表示化するパターンを追加したいこともあるでしょう。関数
`font-lock-add-keywords'を使って、特定のモードに対する個人用の強調表示
パターンを追加できます。たとえば、Cのコメントで単語`FIXME:'を強調表示
するには、つぎのように使います。

     (font-lock-add-keywords
      'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face t)))



File: emacs-ja.info, Node: Support Modes, Next: Highlight Changes, Prev: Font Lock, Up: Frames

フォントロックのモード
======================

フォントロックには、大きなバッファに対してフォントロック（font-lock）
モードを高速に動作させるモードがあります。高速ロック（fast-lock）モー
ドと遅延ロック（lazy-lock）モードです。これらは、フォントロック
（font-lock）モードの速度を向上するために2つの異なる方法を使います。

* Menu:

* Fast Lock Mode::      Saving font information in files.
* Lazy Lock Mode::      Fontifying only text that is actually displayed.
* Fast or Lazy::        Which support mode is best for you?



File: emacs-ja.info, Node: Fast Lock Mode, Next: Lazy Lock Mode, Up: Support Modes

高速ロックモード
----------------

大きなファイルを訪問したバッファに対してフォントロック（font-lock）モー
ドを速くするには、高速ロック（fast-lock）モードを使えます。高速ロック
（fast-lock）モードは、各ファイルに対するフォント情報を別のキャッシュ
ファイル（cache file）に保存します。ファイルを訪問するたびに、最初から
テキストをフォント表示化し直すかわりに、キャッシュファイルからフォント
情報を読み直します。

コマンド`M-x fast-lock-mode'は、引数に従って高速ロック（fast-lock）モー
ドをオン／オフします（引数がないければトグル）。フォントロック
（font-lock）モードを使うときに、いつでも高速ロック（fast-lock）モード
をオンにするには、つぎのようにします。

     (setq font-lock-support-mode 'fast-lock-mode)

小さなバッファに対しては、キャッシュファイルを書く価値がありません。そ
れゆえ、変数`fast-lock-minimum-size'は、フォント情報をキャッシュする最
小のファイルサイズを指定します。

変数`fast-lock-cache-directories'は、
キャッシュファイルをどこに置くかを指定します。
その値は、ディレクトリ群のリストです。
`"."'は、編集しているファイルと同じディレクトリを表します。
デフォルト値は、`("." "~/.emacs-flc")'で、
可能ならば同じディレクトリを使い、
さもなければディレクトリ`~/.emacs-flc'を使うという意味です。 

変数`fast-lock-save-others'は、あなたが所持していないファイルに対する
キャッシュファイルを高速ロック（fast-lock）モードが保存すべきかどうか
を指定します。値が`nil'以外ならば保存します（これがデフォルト）。



File: emacs-ja.info, Node: Lazy Lock Mode, Next: Fast or Lazy, Prev: Fast Lock Mode, Up: Support Modes

遅延ロックモード
----------------

大きなバッファに対してフォントロック（font-lock）モードを速くするには、
フォント表示化するテキストの量を減らす遅延ロック（lazy-lock）モードを
使えます。遅延ロック（lazy-lock）モードでは、バッファのフォント表示化
は要求駆動型です。表示されようとしているバッファの部分だけをフォント表
示化します。また、変更部分のフォント表示化は延期され、Emacsがある短い
時間アイドルであったときにのみフォント表示化します。

コマンド`M-x lazy-lock-mode'は、遅延ロック（lazy-lock）モードを引数に
従ってオン／オフします（引数がなければトグル）。フォントロック
（font-lock）モードを使うときに、いつでも遅延ロック（lazy-lock）モード
をオンにするには、つぎのようにします。

     (setq font-lock-support-mode 'lazy-lock-mode)

小さなバッファに対してバッファのフォント表示化を避ける価値はありません。
ですから、変数`lazy-lock-minimum-size'は、要求駆動型でバッファのフォン
ト表示化を行う最小のバッファサイズを指定します。これより小さなバッファ
は、普通のフォントロック（font-lock）モードのように一度にフォント表示
化します。

バッファを変更したとき、遅延ロック（lazy-lock）モードは変更したテキス
トのフォント表示化を延期します。変数`lazy-lock-defer-time'は、変更部分
のフォント表示化を始めるまでにEmacsがアイドルであるべき秒数です。この
値が0ならは、普通のフォントロック（font-lock）モードと同じように、変更
はすぐにフォント表示化されます。

遅延ロック（lazy-lock）モードは、通常、新たに見えてくるバッファ部分が
初めて表示されるまえにその部分をフォント表示化します。しかし、
`lazy-lock-defer-on-scrolling'の値が`nil'以外ならば、新たに見えてくる
テキストは、Emacsが`lazy-lock-defer-time'秒だけアイドルしたときにのみ
フォント表示化されます。

CやEmacs Lispモードを含むいくつかのモードでは、ある1行の内容を変更する
と後続行の文脈が変わり、そのため、後続行をどうフォント表示化するかも変
わります。通常は、後続行を再フォント表示化するために`M-g M-g'を打つ必
要があります。しかし、変数`lazy-lock-defer-contextually'に`nil'以外を
設定していると、遅延ロック（lazy-lock）モードでは、
`lazy-lock-defer-time'秒後にこれを自動的に行います。

Emacsが長時間アイドルだと、遅延ロックは、バッファのまだ表示されていな
い部分を、のちの表示に備えてフォント表示化します。これを"内密のフォン
ト表示化"（stealth fontification）と呼びます。

変数`lazy-lock-stealth-time'は、内密のフォント表示化を開始するまでに、
Emacsが何秒間アイドルであるべきかを指定します。値が`nil'だと、内密のフォ
ント表示化をしません。変数`lazy-lock-stealth-lines'と
`lazy-lock-stealth-verbose'は、内密のフォント表示化の粒度と冗長性を指
定します。



File: emacs-ja.info, Node: Fast or Lazy, Prev: Lazy Lock Mode, Up: Support Modes

高速ロックか遅延ロックか？
--------------------------

フォントロックで使えるモードの1つを選択する目安となる簡単な指針をあげ
ます。

   * 高速ロック（fast-lock）モードは、ファイルの訪問とバッファの削除
     （と関連する事象）の最中に作業する。それゆえ、バッファの編集やウィ
     ンドウのスクロールは、普通のフォントロック（font-lock）モードより
     速くも遅くもない。

   * 高速ロック（fast-lock）モードのキャッシュファイルの読み込みは、遅
     延ロック（lazy-lock）モードがウィンドウをフォント表示化するより遅
     い。よって、高速ロック（fast-lock）モードは、遅延ロック
     （lazy-lock）モードよりファイルの訪問が遅い。

   * 遅延ロック（lazy-lock）モードは、ウィンドウをスクロールする最中に、
     画面上に現れるテキストをフォント表示化する。よって、スクロールは、
     通常のフォントロック（font-lock）モードより遅い。

   * 遅延ロック（lazy-lock）モードは、バッファを編集中はフォント表示化
     しない（変更部分のフォント表示化を延期する）。よって、編集は、通
     常のフォントロック（font-lock）モードより速い。

   * 高速ロック（fast-lock）モードは、版管理の下に置かれたファイルでは
     だまされることがある。よって、そのファイルに対するキャッシュファ
     イルが存在していても、バッファのフォント表示化が起こりえる。

   * 高速ロック（fast-lock）モードは、ファイルを訪問しているバッファで
     のみ動作する。遅延ロック（lazy-lock）モードは、どのバッファでも動
     作する。

   * 高速ロック（fast-lock）モードは、キャッシュファイルを生成する。遅
     延ロック（lazy-lock）モードは、生成しない。

変数`font-lock-support-mode'は、これらのどちらのモードを使うかを指定し
ます。たとえば、C/C++モードでは高速ロック（fast-lock）モードを使い、そ
れ以外のモードでは遅延ロック（lazy-lock）モードを使うように指定するに
は、変数をつぎのように設定します。

     (setq font-lock-support-mode
           '((c-mode . fast-lock-mode) (c++-mode . fast-lock-mode)
             (t . lazy-lock-mode)))



File: emacs-ja.info, Node: Highlight Changes, Next: Misc X, Prev: Support Modes, Up: Frames

変更部分強調表示モード
======================

バッファ内の最近に変更された部分を示すためにフェイス（典型的には表示色）
を用いるマイナモードをオンにするには、`M-x highlight-changes-mode'を使
います。



File: emacs-ja.info, Node: Misc X, Next: Non-Window Terminals, Prev: Highlight Changes, Up: Frames

その他のXウィンドウシステムでの機能
===================================

つぎのコマンドは、フレームを作成したり削除したり操作したりします。

`C-z'
     選択されているEmacsフレームをアイコン化する
     （`iconify-or-deiconify-frame'）。Emacsを休止するという`C-z'の通
     常の意味は、ウィンドウシステムでは有用ではない。そのため、別のバ
     インドになっている。

     Emacsフレームのアイコンでこのコマンドを打つと、アイコンをフレーム
     に開く。

`C-x 5 0'
     選択されているフレームを削除する（`delete-frame'）。フレームがたっ
     た1つの場合には、このコマンドは許されない。

`C-x 5 o'
     別のフレームを選択し、それをいちばん手前にもってきて、そのフレー
     ムが選択されるようにマウスを飛び込ませる。このコマンドを繰り返す
     と、端末上のすべてのフレームを巡回する。



File: emacs-ja.info, Node: Non-Window Terminals, Prev: Misc X, Up: Frames

非ウィンドウ端末
================

Emacsが扱えるウィンドウシステムを使えない端末では、一度に1つのフレーム
しか表示できません。しかし、複数のEmacsフレームを作って、それらのフレー
ム間を切り替えられます。このような端末でのフレームの切り替えは、異なる
ウィンドウ構成の端末での切り替えとたいへんよく似ています。

新しいフレームを作りそれに切り替えるには、`C-x 5 2'を使います。既存の
フレーム間を巡回するには、`C-x 5 o'を使います。カレントフレームを削除
するには、`C-x 5 0'を使います。

各フレームにはそれを区別する番号があります。一度には1つのフレームだけ
しか表示できない端末では、選択されているフレームの番号Nが、モード行の
先頭近くに`FN'という形式で現れます。

`FN'は、実際にはフレームの名前です。望むなら別の名前を指定でき、その名
前でフレームを選択できます。選択されたフレームに新しい名前を指定するに
は、コマンド`M-x set-frame-name RET NAME RET'を使います。その名前でフ
レームを選択するには、`M-x select-frame-by-name RET NAME RET'を使いま
す。指定した名前は、フレームを選択するとモード行に表示されます。



File: emacs-ja.info, Node: International, Next: Major Modes, Prev: Frames, Up: Top

国際化文字集合の使い方
**********************

Emacsでは広範囲の国際化文字集合を使えます。ラテンアルファベットの変種
であるヨーロッパの言語はもちろん、中国語、デバナーガリー（ヒンディー語
とマラッタ語）、エチオピア語、ギリシア語、IPA（International Phonetic
Alphabet、万国表音文字）、日本語、韓国語、ラオ語、ロシア語、タイ語、チ
ベット語、ベトナム語の文字を含んでいます。これらの機能は、MULE
（『MULti-lingual Enhancement to GNU Emacs』）として知られるEmacsの修
正版から併合しました。

* Menu:

* International Intro::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Multibyte Conversion::    How single-byte characters convert to multibyte.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Various ways to choose which conversion to use.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Single-Byte European Support::
                            You can pick one European character set
                            to use without multibyte characters.



File: emacs-ja.info, Node: International Intro, Next: Enabling Multibyte, Up: International

国際化文字集合の紹介
====================

これらの文字のユーザーは、ファイルに格納するために、たくさんの標準的な
コーディングシステムを確立してきました。Emacsは内部的には単一のマルチ
バイト文字符号化を使用しているので、1つのバッファや1つの文字列の中に、
これらのすべての文字を混ぜ合わせることができます。この符号化では、非
ASCII文字を0200から0377の範囲のバイトの並びとして表現します。Emacsは、
ファイルを読み書きするとき、サブプロセスとデータを交換するとき、（場合
によっては）`C-q'コマンドを使うときに、マルチバイト文字符号化と他のさ
まざまなコーディングシステムのあいだで変換します（*Note Multibyte
Conversion::）。

コマンド`C-h h'（`view-hello-file'）は、多くの言語で『hello』と書いた
ファイル`etc/HELLO'を表示します。これは、さまざまな字体を例示します。

これらの文字集合を使っている国々であっても、一般にキーボードには、それ
らすべての文字に対するキーはありません。ですから、Emacsではさまざまな" 
入力方式"（input methods） (1) (*Note International Intro-Footnotes::) 
を使って、便利に文字を打ち込めるようにします。典型的には、1つの字体や1 
つの言語について1つの入力方式があります。

プレフィックスキー`C-x RET'は、マルチバイト文字、コーディングシステム、
入力方式に関係するコマンドに使います。


File: emacs-ja.info  Node: International Intro-Footnotes, Up: International Intro

(1) 【訳注】GNU Emacsをインストールする時点で、対応する版のLEIM
（Library of Emacs Input Method）のソースをGNU Emacsのソースディレクト
リに展開しておくと、自動的にインストールされる。



File: emacs-ja.info, Node: Enabling Multibyte, Next: Language Environments, Prev: International Intro, Up: International

マルチバイト文字を使用可能にする
================================

Emacs全体やバッファごとにマルチバイト文字の使用可／使用不可を設定でき
ます。バッファでマルチバイト文字を使用不可にすると、そのバッファ内の各
バイトは1つの文字を表します。たとえコードが0200から0377のあいだであっ
てもそうです。ヨーロッパの文字集合であるISO Latin-1とISO Latin-2を扱う
古い機能は、Emacs 19で動作していたように動き、他のISO 8859文字集合に対
しても動作します。

しかし、ISO Latinを使うために、マルチバイト文字を使用不可にする必要は
ありません。Emacsのマルチバイト文字集合にはこれらの文字集合のすべての
文字が含まれ、EmacsはこれらのISOコードと相互に自動的に変換できます。

特定のファイルをユニバイト表現で編集するには、`find-file-literally'を
使ってファイルを訪問します。*Note Visiting::。マルチバイト表現のバッファ
を同じ文字の1バイト表現に変換するには、もっとも簡単な方法は、内容をファ
イルに保存してから、バッファを削除し、`find-file-literally'でそのファ
イルを訪問し直します。`C-x RET c'（`universal-coding-system-argument'）
を使って、ファイルを探したり保存するときのコーディングシステムとして
`raw-text'を指定することもできます。*Note Specify Coding::。`raw-text'
としてファイルを探しても、`find-file-literally'のようには、書式変換、
圧縮の展開、モードの自動選択を禁止しません。

デフォルトでマルチバイト文字を使用不可にするには、`--unibyte'オプショ
ン（*Note Initial Options::）を指定してEmacsを始めるか、あるいは、環境
変数`EMACS_UNIBYTE'を設定します。`--unibyte'と同等な効果を得るには、
`enable-multibyte-characters'をカスタマイズするか、これと等価に、初期
化ファイル内で、変数`default-enable-multibyte-characters'を直接設定し
ます。

環境変数の値、`/etc/passwd'の内容などの非ASCII 8ビット文字からの初期化
中にはマルチバイト文字列は作られません。しかし、`--unibyte'を指定した
としても、一般のLispファイルのように、初期化ファイルは、通常、マルチバ
イトとして読み込みます。それらに含まれる非ASCII文字からマルチバイト文
字列が生成されるのを防ぐには、1行目の注釈に`-*-unibyte: t;-*-'を入れて
おきます。gnusなどのパッケージの初期化ファイルでも同じことをします。

モード行には、カレントバッファでマルチバイト文字が使用可かどうか表示さ
れます。使用可ならば、モード行の先頭付近のコロンのまえに2文字か数文字
（ほとんどの場合ダッシュ2個）があります。マルチバイト文字が使用不可な
らば、コロンのまえにはダッシュが1個だけです。



File: emacs-ja.info, Node: Language Environments, Next: Input Methods, Prev: Enabling Multibyte, Up: International

言語環境
========

マルチバイト文字が使用可のときはいつでも、すべての扱える文字集合を
Emacsバッファの中で使えます。ある言語の文字を表示するために、Emacsバッ
ファでその言語を選択する必要はありません。しかし、さまざまなデフォルト
を設定するために"言語環境"を選択しておくことは重要です。言語環境は、言
語の選択というより、（多かれ少なかれ）実際には好みの文字を表します。

言語環境は、テキストを読み込むときにどのコーディングシステムを認識する
かを制御します（*Note Recognize Coding::）。言語環境は、ファイル、到着
メイル、ニュース、Emacsへ読み込むその他のテキストに適用されます。言語
環境は、ファイルを作成したときに使うデフォルトのコーディングシステムを
指定することもあります。各言語環境は、デフォルトの入力方式も指定します。

言語環境を選択するには、コマンド`M-x set-language-environment'を使いま
す。このコマンドを使ったときにどのバッファがカレントバッファであるかは
関係ありません。というのは、その効力は、そのEmacsセッションに全体に適
用されるからです。以下の言語環境を使えます。

     Chinese-BIG5、Chinese-CNS、Chinese-GB、Cyrillic-Alternativnyj、
     Cyrillic-ISO、Cyrillic-KOI8、Devanagari、English、Ethiopic、Greek、
     Hebrew、Japanese、Korean、Lao、Latin-1、Latin-2、Latin-3、Latin-4、
     Latin-5、Thai、Tibetan、Vietnamese。

いくつかのオペレーティングシステムでは、ローケル（locale）環境変数を設
定することで言語を指定できます。Emacsは、このよくある特別な場面を扱い
ます。文字種を表すローケル名が文字列`8859-N'を含むなら、Emacsは自動的
に対応する言語環境を選択します。

ある言語環境LANG-ENVの効果についての情報を表示するには、コマンド`C-h L
LANG-ENV RET' （`describe-language-environment'）を使います。このコマ
ンドは、その言語環境がどの言語に役立つのか、その言語で使われる文字集合、
コーディングシステム、入力方式の一覧を表示します。また、その言語環境で
使われる文字を例示する例文も表示します。デフォルトでは、このコマンドは
選択されている言語環境を記述します。

どの言語環境もノーマルフック`set-language-environment-hook'でカスタマ
イズできます。コマンド`set-language-environment'は、新しい言語環境を設
定したあとでこのフックを実行します。フック関数では、変数
`current-language-environment'を検査すれば、言語環境を知ることができま
す。

`set-language-environment'は、新しい言語環境を設定し始めるまえに、まず
フック`exit-language-environment-hook'を実行します。このフックは、（直
前の言語環境を設定した）`set-language-environment'で施したカスタマイズ
をもとに戻すのに便利です。たとえば、`set-language-environment-hook'を
使って設定した特定の言語環境で特別なキーバインディングを定義したときに
は、それをそのキーのもとのバインディングに戻すために
`exit-language-environment-hook'を設定するべきです。



File: emacs-ja.info, Node: Input Methods, Next: Select Input Method, Prev: Language Environments, Up: International

入力方式
========

"入力方式"（input method）は、対話的に入力するために特別に設計された文
字変換の一種です。Emacsでは、典型的には、各言語向けに専用の入力方式が
あります。ときには、同じ文字を使ういくつかの言語で入力方式を共有します。
複数の入力方式を使う言語も少しはあります。

入力方式のもっとも単純なものは、ASCII文字を別のアルファベットに対応さ
せることで動作します。ギリシア語とロシア語の入力方式はこのように動作し
ます。

より強力な方法は合成で、文字の列を1つの文字に変換します。多くのヨーロッ
パの入力方式は、文字のうしろにアクセント文字が続く列（あるいはその逆順）
から、1つの非ASCII文字を生成する合成を使います。たとえば、いくつかの入
力方式では、文字の列`a''を1つのアクセント付き文字に変換します。これら
の入力方式には、その方式に固有の特別なコマンドはありません。印字文字の
列を合成するだけです。

音節文字用の入力方式では、典型的には、対応付けたあとで合成します。タイ
語と韓国語の入力方式は、この方法で動作します。まず、文字を音声記号に対
応付けます。そして、1つの音節全体を構成するそれらの列を1つの音節記号に
対応付けます。

中国語や日本語では、より複雑な方法が必要です。中国語の入力方式では、ま
ず、中国語の単語の発音表記を入力する（とりわけ入力方式`chinese-py'）か、
1文字の各部分部分の列（とりわけ入力方式`chinese-4corner'や`chinese-sw'）
を入力します。1つの発音表記は、普通、多くの異なる中国語の文字に対応し
ているので、特別なEmacsコマンドを使って候補群から1つを選ぶ必要がありま
す。`C-f'、`C-b'、`C-n'、`C-p'と数字キーは、この状況で候補を選ぶために
使われる特別な定義になっています。TABは、すべての候補をバッファに表示
します。

日本語の入力方式 (1) (*Note Input Methods-Footnotes::) では、まず、発
音表記を使って1つの単語全体を入力します。そして、単語がバッファに入っ
たあとで、Emacsは大きな辞書を使って1つ以上の文字へ変換します。1つの発
音表記は、たくさんの異なる日本語の単語に対応しているので、その中から選
ぶ必要があります。候補を巡回するには、`C-n'や`C-p'を使います。


ときには、入力方式での処理を切り離したほうが便利なことがあります。そう
すれば、入力した文字は後続の入力文字と結合されません。たとえば、入力方
式`latin-1-postfix'では、キー列`e ''は結合されてアクセント付き`e'にな
ります。これらを別々の文字として入力したいときはどうするのでしょう？

1つの方法は、アクセントを2回打つことです。これは、アルファベットとアク
セントを別々に入力する特別な機能です。たとえば、`e ' ''は、2つの文字
`e''になります。別の方法は、`e'のあとに結合されない別の文字を打ってか
ら、すぐにそれを消すことです。たとえば、 `e'と`''を入力するには、`e e
DEL''と打ちます。

別の方法はより一般的ですが、打つのは簡単ではありません。2つの文字のあ
いだで`C-\ C-\'を打って、結合を止めます。これは、コマンド`C-\' 
（`toggle-input-method'）を2回使っています。*Note Select Input
Method::。

`C-\ C-\'は、インクリメンタルサーチの中では特に便利です。というのは、
結合する文字を待つことを止めて、すでに入力したものを探索し始めるからで
す。

 変数`input-method-highlight-flag'と`input-method-verbose-flag'は、入
力方式に何が進行中かをどのように表示させるかを制御します。
`input-method-highlight-flag'が`nil'以外ならば、バッファでは（入力途中
の）部分列を強調表示します。`input-method-verbose-flag'が`nil'以外なら
ば、（ミニバッファの中でなければ）つぎに打鍵できる文字の一覧をエコー領
域に表示します。


File: emacs-ja.info  Node: Input Methods-Footnotes, Up: Input Methods

(1) 【訳注】言語環境が`Japanese'のときにデフォルトで使用される
LEIMに含まれているもの。「ローマ字→ひらがな→漢字」と変換するが、あま
い使いやすくはない。WNN、かんな、SKKなどを使うには、Emacsの配布とは別
の非公式パッチを自前で当てる必要がある。ただし、これらを用いた場合、日
本語を入力できない場面もあることを承知しておく必要がある。



File: emacs-ja.info, Node: Select Input Method, Next: Multibyte Conversion, Prev: Input Methods, Up: International

入力方式の選択
==============

`C-\'
     選択されている入力方式をオン／オフする。

`C-x RET C-\ METHOD RET'
     カレントバッファに対して新しい入力方式を選択する。

`C-h I METHOD RET'
`C-h C-\ METHOD RET'
     入力方式METHODについて説明する（`describe-input-method'）。デフォ
     ルトでは、（あれば）現在の入力方式を説明する。この説明で、ある入
     力方式の使い方の詳細がわかるはず。

`M-x list-input-methods'
     使用可能なすべての入力方式の一覧を表示する。

カレントバッファに対する入力方式を選ぶには、`C-x RET C-\'
（`set-input-method'）を使います。このコマンドは、ミニバッファで入力方
式名を読みます。その名前は、通常、一緒に使うことを意図された言語環境で
始まります。変数`current-input-method'は、どの入力方式を選択したかを記
録します。
  
入力方式は、非ASCII文字を入力するために、さまざまなASCII文字の列を使い
ます。ときには、一時的に入力方式をオフにできると便利なこともあります。
そうするには、`C-\'（`toggle-input-method'）と打ちます。入力方式をふた
たびオンにするには、`C-\'をもう一度打ちます。

`C-\'を打ったときに、入力方式をまだ選択していないと、入力方式を指定す
るように聞いてきます。これは、入力方式を指定するために`C-x RET C-\'を
使うのと同じ効果があります。

言語環境を選択すると、さまざまなバッファで使うデフォルトの入力方式を指
定します。デフォルトの入力方式を指定してあれば、`C-\'と打てばカレント
バッファでそれを選択できます。変数`default-input-method'は、デフォルト
の入力方式を指定します（`nil'は入力方式なしの意味）。

アルファベット文字に対するいくつかの入力方式は、その文字向けに一般的に
使用されるさまざまなキーボード配列をエミュレートするようにキーボードを
（実質的に）マッピングし直すことで動作します。マッピングし直す方法は、
あなたの実際のキーボード配列に依存します。使っているキーボード配列を指
定するには、コマンド`M-x quail-set-keyboard-layout'を使います。

使用可能なすべての入力方式の一覧を表示するには、`M-x
list-input-methods'と打ちます。この一覧には、モード行に表示される入力
方式を表す文字列を含めて、各入力方式についての情報が示されます。



File: emacs-ja.info, Node: Multibyte Conversion, Next: Coding Systems, Prev: Select Input Method, Up: International

ユニバイトとマルチバイトの非ASCII文字
=====================================

マルチバイト文字が使用可のときには、文字コード0240（8進数）から0377（8
進数）の文字は、実際にそのままではバッファ内に存在しません。正しい非
ASCII印字文字は、0400から始まるコードになります。

0240から0377の不正な範囲の自己挿入文字を打った場合、Emacsは、ISO
Latin-N文字集合の1つを使おうとしていると仮定して、Latin-Nの文字を表す
Emacsのコードに変換します。言語環境の選択を介して、*どの*ISO Latin文字
集合を使うのか指定できます（*Note Language Environments::）。何も選ん
でないと、デフォルトはLatin-1です。

`C-q'でこの範囲の8進コードを入力すると、同じことが起こります。



File: emacs-ja.info, Node: Coding Systems, Next: Recognize Coding, Prev: Multibyte Conversion, Up: International

コーディングシステム
====================

さまざまな言語を使うユーザーは、それらを表現するための標準的なコーディ
ングシステムを数多く確立してきました。Emacsはこれらのコーディングシス
テムを内部的には使用しません。そのかわり、データを読むときには、さまざ
まなコーディングシステムからEmacs独自のコーディングシステムに変換し、
データを書くときには、内部コーディングシステムから他のコーディングシス
テムに変換します。ファイルの読み書き、端末とのやりとり、サブプロセスと
のデータ交換において、変換できます。

Emacsは各コーディングシステムに名前を付けています。多くのコーディング
システムは、1つの言語で使用されるので、コーディングシステムの名前は、
言語の名前で始まります。いくつかのコーディングシステムは、いくつもの言
語で使用されます。その場合、コーディングシステムの名前は、通常、`iso'
で始まります。印字文字をまったく変換しない特別なコーディングシステム、
`no-conversion'、`raw-text'、`emacs-mule'もあります。

非ASCII文字のさまざまな表現形の変換に加えて、コーディングシステムは行
末変換も行います。Emacsは、ファイル内の行の区切り方として、3つの異なる
変換を扱えます。つまり、改行、復帰改行、復帰です。

`C-h C CODING RET'
     コーディングシステムCODINGを説明する。

`C-h C RET'
     現在使用しているコーディングシステムを説明する。

`M-x list-coding-systems'
     使用可能なすべてのコーディングシステムの一覧を表示する。

コマンド`C-h C'（`describe-coding-system'）は、特定のコーディングシス
テムについての情報を表示します。引数にコーディングシステム名を指定でき
ます。あるいは、引数が空のときには、カレントバッファに対するものとデフォ
ルトの両方について、さまざまな目的のために選択されている現在のコーディ
ングシステムと、コーディングシステムを認識するための優先順位表を説明し
ます。（*Note Recognize Coding::）。

利用可能なすべてのコーディングシステムの一覧を表示するには、`M-x
list-coding-systems'と打ちます。モード行に表示される文字を含めて、各コー
ディングシステムについての情報の一覧を表示します（*Note Mode Line::）。

いかなる種類の変換も行わない`no-conversion'を除いて、この一覧に現れる
各コーディングシステムは印字文字をどのように変換する／しないを指定しま
す。しかし、行末変換は、各ファイルの内容に基づいて決定されます。たとえ
ば、ファイルが行区切りに復帰改行を使用しているように思われるときには、
その行末変換を使います。

一覧の各コーディングシステムには、どのように行末変換するかを正確に指定
する3つの変種があります。

`...-unix'
     行末変換を行わない。ファイルでは、行区切りに改行を使用していると
     仮定する。（これは、UNIXとGNUシステムで普通に使用される変換。）

`...-dos'
     ファイルでは、行区切りに復帰改行を使用していると仮定し、適当な変
     換を行う。（これは、Microsoftシステムで普通に使用される変換。 (1)
     (*Note Coding Systems-Footnotes::)）

`...-mac'
     ファイルでは、行区切りに復帰を使用していると仮定し、適当な変換を
     行う。（これは、Machintoshシステムで普通に使用される変換。）

これらのコーディングシステムの変種は、完全に予想できるので
`list-coding-systems'の表示からは簡潔にするために除かれています。たと
えば、コーディングシステム`iso-latin-1'には、`iso-latin-1-unix'、
`iso-latin-1-dos'、`iso-latin-1-mac' の変種があります。

コーディングシステム`raw-text'は、主にASCIIテキストのファイルに適して
いますが、ファイルには、非ASCII文字の符号を意味しない127を越えるバイト
値が含まれるかもしれません。`raw-text'では、Emacsは、それらのバイトが
適切に解釈されるように値を変更しないでコピーし、カレントバッファの
`enable-multibyte-characters'に`nil'を設定します。`raw-text'は、出会っ
たデータに基づく普通の方法で行末変換を処理し、使用する行末変換を指定す
る3つの変種を持ちます。

対照的に、コーディングシステム`no-conversion'は、非ASCIIバイト値と行末
に対して、いかなる文字コード変換も指定しません。これは、バイナリファイ
ル、tarファイル、そのまま処理する必要があるその他のファイルを読み書き
するのに便利です。これも、`enable-multibyte-characters'に`nil'を設定し
ます。

いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は、
`M-x find-file-literally'コマンドを使うことです。このコマンドは、
`no-conversion'を使い、あなたがファイルを見るまえにファイルの内容を変
換するかもしれないEmacsのその他の機能を抑制します。*Note Visiting::。

コーディングシステム`emacs-mule'は、Emacs内部の符号化のままで格納され
た非ASCII文字を含むファイルであることを意味します。これは、出会ったデー
タに基づいて行末変換を扱い、行末変換の種類を指定する通常の3つの変種を
持ちます。


File: emacs-ja.info  Node: Coding Systems-Footnotes, Up: Coding Systems

(1) MIMEの「text/*」の本体や、他のネットワーク転送の場面でも指定
される。Emacsが直接には扱えないSGMLの参照構文である
record-start/record-end書式とは異なる。



File: emacs-ja.info, Node: Recognize Coding, Next: Specify Coding, Prev: Coding Systems, Up: International

コーディングシステムの認識
==========================

一度自分の好みを指定しておけば、ほとんどの場合、Emacsは、与えられたファ
イルに対してどのコーディングシステムを使うか認識できます。

いくつかのコーディングシステムは、データ内にどのようなバイト列が現れた
かで、認識したり区別できます。しかし、区別できないコーディングシステム
やその可能性もないコーディングシステムもあります。たとえば、Latin-1と
Latin-2を区別する方法はありません。これらは同じバイト値を異なる意味で
使用しています。

Emacsは、コーディングシステムの優先順位表を用いてこの事態を処理します。
使用するコーディングシステムを指定しなければ、Emacsはファイルを読むと
きはいつでも、優先順位のもっとも高いものから始めて順に下りながら、デー
タに合うコーディングシステムをみつけるまで各コーディングシステムに対し
てデータを検査します。そして、ファイルはそのコーディングシステムで表現
されていると仮定して、ファイルの内容を変換します。

コーディングシステムの優先順位表は、選択されている言語環境に依存します
（*Note Language Environments::）。たとえば、フランス語を使うのなら、
たぶん、EmacsにはLatin-2よりLatin-1を選んでほしいでしょう。チェコ語を
使うなら、たぶん、Latin-2のほうがよいでしょう。これが、言語環境を指定
する理由の1つです。

しかし、コマンド`M-x prefer-coding-system'を使って、優先順位表の詳細を
変更できます。このコマンドはミニバッファからコーディングシステムの名前
を読み、それを優先順位表の先頭に追加して、他のすべてのものより優先する
ようにします。このコマンドを数回使うと、使用するごとに優先順位表の先頭
に1つの要素が追加されます。

`iso-8859-1-dos'のような行末変換を指定したコーディングシステムを使うと、
`iso-8859-1'を優先して認識し、その場合にはDOSの行末変換を使うことを
Emacsに指示することになります。

ときには、ファイルに対して使用するコーディングシステムをファイル名が示
していることがあります。変数`file-coding-system-alist'は、この対応関係
を指定します。このリストに要素を追加する特別な関数
`modify-coding-system-alist'があります。たとえば、すべての`.txt'の読み
書きに、コーディングシステム`china-iso-8bit'を使用したいなら、つぎの
Lisp式を実行します。

     (modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)

始めの引数は`file'、第2引数はこれを適用するファイルを決定する正規表現、
第3引数はこれらのファイルに対して使用するコーディングシステムです。

Emacsは、ファイルの内容に基づいて、使用する行末変換の種類を認識します。
復帰のみ、あるいは、復帰改行の列のみであれば、対応する行末変換を選択し
ます。変数`inhibit-eol-conversion'に`nil'以外を設定すると、行末変換の
自動的な使用を禁止できます。

ファイルの先頭の`-*-...-*-'や、ファイルの最後のローカル変数リストを使っ
て、個々のファイルに対してコーディングシステムを指定できます（*Note
File Variables::）。これを行うには、`coding'という名前の『変数』に値を
定義します。Emacsには、変数`coding'は実際にはありません。変数を設定す
るかわりに、ファイルに対して指定されたコーディングシステムを使います。
たとえば、`-*-mode: C; coding: latin-1;-*-'は、Cモードを指定するととも
に、Latin-1のコーディングシステムの使用を指定します。ファイルでコーディ
ングシステムを明示的に指定した場合、それは`file-coding-system-alist'に
優先します。

変数`auto-coding-alist'は、特定のパターンのファイル名に対してコーディ
ングシステムを指定するもっとも強い方法です。この変数は、ファイル自身の
`-*-coding:-*-'にさえも優先します。Emacsはtarファイルやアーカイブファ
イルに対してこの機能を使います。アーカイブ内のファイルの中にある
`-*-coding:-*-'で混乱して、ファイル全体にコーディングシステムを適用し
てしまうことを防ぐのです。

Emacsがバッファに対するコーディングシステムを一度選択すると、そのコー
ディングシステムを`buffer-file-coding-system'に入れておき、このバッファ
からファイルに書く操作では、デフォルトでこのコーディングシステムを使い
ます。これには、コマンド`save-buffer'や`write-region'も含まれます。異
なるコーディングシステムを用いてこのバッファからファイルに書きたいとき
には、`set-buffer-file-coding-system'を使って、そのバッファに対して異
なるコーディングシステムを指定します（*Note Specify Coding::）。

メイル（mail）モード（*Note Sending Mail::）でメッセージを送るとき、
Emacsには、メッセージテキストの符号化に使うコーディングシステムを決定
する異なる方法が4つあります。バッファの`buffer-file-coding-system'が
`nil'以外ならば、その値を試します。さもなければ、
`sendmail-coding-system'の値が`nil'以外ならば、その値を使います。3つめ
の方法は、新しいファイルに対するデフォルトのコーディングシステムが
`nil'以外ならば、それを使います。この値は、言語環境の選択で制御されま
す。これらの3つの値がすべて`nil'ならば、Emacsは、Latin-1のコーディング
システムを使用して送出メイルを符号化します。

rmailで新しいメイルを受けとったとき、各メッセージが別々のファイルであ
るかのように、各メッセージは自動的にそのメイルが書かれたコーディングシ
ステムで変換されます。これには、指定したコーディングシステムの優先順位
表を使います。MIMEメッセージが文字集合を指定するときには、
`rmail-decode-mime-charset'が`nil'でない限り、rmailはその指定に従いま
す。

rmailファイル自身を読んだり保存したりするときには、Emacsは、変数
`rmail-file-coding-system'で指定されたコーディングシステムを使います。
そのデフォルト値は、`nil'です。rmailファイルは変換しないという意味です
（rmailファイルは、Emacsの内部文字コードで読み書きされる。）



File: emacs-ja.info, Node: Specify Coding, Next: Fontsets, Prev: Recognize Coding, Up: International

コーディングシステムの指定
==========================

Emacsが自動的に正しいコーディングシステムを選択しない場合には、コーディ
ングシステムを指定するつぎのコマンドを使用できます。

`C-x RET f CODING RET'
     カレントバッファに訪問したファイルにコーディングシステムCODINGを
     使う。

`C-x RET c CODING RET'
     このコマンドの直後に続くコマンドに対してコーディングシステム
     CODINGを指定する。

`C-x RET k CODING RET'
     キーボード入力に対してコーディングシステムCODINGを使用する。

`C-x RET t CODING RET'
     端末出力に対してコーディングシステムCODINGを使用する。

`C-x RET p INPUT-CODING RET OUTPUT-CODING RET'
     カレントバッファでのサブプロセスの入力と出力にコーディングシステ
     ムINPUT-CODINGとOUTPUT-CODINGを使用する。

`C-x RET x CODING RET'
     ウィンドウシステムを介した他のプログラムとのセレクションの交換に
     は、コーディングシステムCODINGを使用する。

`C-x RET X CODING RET'
     ウィンドウシステムで*1つ*のセレクションの交換には、コーディングシ
     ステムCODINGを使用する。

コマンド`C-x RET f'（`set-buffer-file-coding-system'）はカレントバッファ
に対してファイルコーディングシステムを指定します。いいかえれば、訪問し
たファイルを保存したりふたたび読む込むときに使うコーディングシステムで
す。コーディングシステムはミニバッファを使って指定します。このコマンド
は、すでに訪問したファイルに作用するので、ファイルを保存するときにしか
影響しません。

ファイルに対するコーディングシステムを指定する別の方法は、ファイルを訪
問するときです。まずコマンド`C-x RET c' 
（`universal-coding-system-argument'）を使います。このコマンドは、ミニ
バッファを使ってコーディングシステム名を読みます。ミニバッファを出たあ
と、*直後のコマンド*に対して指定したコーディングシステムが使用されます。

ですから、たとえば、その直後のコマンドが`C-x C-f'ならば、そのコーディ
ングシステムを使ってファイルを読みます（そして、ファイルを保存するとき
のためにそのコーディングシステムを記録します）。 あるいは、その直後の
コマンドが`C-x C-w'ならば、そのコーディングシステムを使ってファイルに
書きます。コーディングシステムを指定することで、影響される他のファイル
コマンドは、`C-x C-i'と`C-x C-v'、および、別のウィンドウを使う`C-x
C-f'の変形です。

`C-x RET c'は、`M-x shell'（*Note Shell::）を含むサブプロセスを開始す
るコマンドにも影響します。

しかしながら、その直後のコマンドがコーディングシステムを使用しないなら、
`C-x RET c'は最終的には何の効果もありません。

ファイルを変換しないで訪問するもっとも簡単な方法は、`M-x
find-file-literally'コマンドです。*Note Visiting::。

 変数`default-buffer-file-coding-system'は、新しいファイルを作成すると
きのコーディングシステムの選択を指定します。この変数は、新規作成のファ
イルを訪問するとき、あるいは、バッファを作成してそれをファイルに保存す
るときに適用されます。言語環境を選択すると、典型的には、言語環境に対し
て最適のデフォルトのコーディングシステムをこの変数に設定します。

コマンド`C-x RET t'（`set-terminal-coding-system'）は端末出力に対する
コーディングシステムを指定します。端末出力のコーディングシステムを指定
すると、端末へのすべての文字出力はそのコーディングシステムに翻訳されま
す。

この機能は、特定の言語や文字集合向けに作られたある種の文字端末には便利
です。たとえば、ISO Latin 文字集合の1つを扱えるヨーロッパの端末です。 
マルチバイトテキストを使っているときには、Emacsが端末で実際に扱える文
字を知るために、端末コーディングシステムを指定する必要があります。

Emacsがあなたの端末の正しいコーディングシステムを推測できない限り、デ
フォルトでは、端末出力はまったく変換しません。

コマンド`C-x RET k'（`set-keyboard-coding-system'）はキーボード入力に
対するコーディングシステムを指定します。キーボードから入力した文字コー
ドの変換は、非ASCII図形文字を送出するキーを有する端末には便利です。た
とえば、いくつかの端末は、ISO Latin-1やその部分集合向けに設計されてい
ます。

デフォルトでは、キーボード入力はまったく変換しません。

コーディングシステムを使用してキーボード入力を変換することと、入力方式
の使用には似たところがあります。どちらも、1つの文字に変換するキーボー
ド入力列を定義しています。しかしながら、入力方式は人が対話的に使用する
のに便利なように設計されていて、変換される列は典型的にはASCII印字文字
の列です。コーディングシステムは、典型的には非図形文字の列を変換します。

コマンド`C-x RET x'（`set-selection-coding-system'）は、選択されたテキ
ストをウィンドウシステムへ送るとき、および、他のアプリケーションで作ら
れたセレクションのテキストを受け取るときのコーディングシステムを指定し
ます。このコマンドは、再設定しない限り、以降のすべてのセレクションに作
用します。コマンド`C-x RET X'（`set-next-selection-coding-system'）は、
Emacsが作る／読むつぎのセレクションのコーディングシステムを指定します。

コマンド`C-x RET p'（`set-buffer-process-coding-system'）は、サブプロ
セスの入出力に対するコーディングシステムを指定します。このコマンドはカ
レントバッファに作用します。通常、各サブプロセスはそれ自身のバッファを
持ちます。ですから、各サブプロセスの入出力の変換を指定するには、対応す
るバッファでこのコマンドを使用します。

デフォルトでは、プロセスの入出力はまったく変換しません。

変数`file-name-coding-system'は、ファイル名を符号化するためのコーディ
ングシステムを指定します。この変数に（Lispシンボルや文字列で）コーディ
ングシステム名を設定すると、Emacsは、すべてのファイル操作に対してその
コーディングシステムを使ってファイル名を符号化します。これは、ファイル
名に非ASCII文字を使うことを可能にしています。あるいは、少なくとも、指
定したコーディングシステムで符号化できる非ASCII文字を使えるはずです。

`file-name-coding-system'が`nil'ならば、Emacsは、選択されている言語環
境で決まるデフォルトのコーディングシステムを使います。デフォルトの言語
環境では、ファイル名の中の非ASCII文字は特別に符号化しません。Emacsの内
部表現でファイルシステム上に現れます。

*警告：*` 'Emacsセッションの途中で`file-name-coding-system' （や言語環
境）を変更すると、問題となる場合があります。つまり、それまでのコーディ
ングシステムで符号化された名前のファイルをすでに訪問していて、新しいコー
ディングシステムではその名前を符号化できない（あるいは異なって符号化さ
れる）ときです。そのようなバッファを訪問先ファイル名で保存しようとする
と、まちがった名前のファイルに保存されるか、エラーになります。そのよう
な問題が発生した場合には、 `C-x C-w'を使って、そのバッファに新しいファ
イル名を指定します。



File: emacs-ja.info, Node: Fontsets, Next: Defining Fontsets, Prev: Specify Coding, Up: International

フォントセット
==============

Xウィンドウシステムのフォントは、典型的には、1つのアルファベットや文字
集合の形を定義しています。したがって、Emacsが扱える文字の範囲全体を表
示するには、たくさんのフォントを集めたものが必要です。Emacsでは、そう
いったフォントを集めたものを"フォントセット"（fontset）と呼びます。フォ
ントセットは、ある文字コード範囲を扱うフォントのリストで定義されます。

各フォントセットには、フォントと同様に名前があります。使用可能なXのフォ
ントは、Xサーバーが定義します。しかし、フォントセットはEmacsの中で定義
されます。いったんフォントセットを定義すれば、フォントを使える場面では
どこでも、その名前を指定してEmacs内のフォントセットを使用できます。も
ちろん、Emacsのフォントセットでは、Xサーバーで使えるフォントだけを使え
ます。ある文字が画面で中抜きの箱で表示されたなら、その文字に使用したフォ
ントセットには、その文字に対するフォントがないことを意味します。

Emacsは、"標準フォントセット"と"スタートアップフォントセット"の2つのフォ
ントセットを自動的に作ります。標準フォントセットは、非ASCII文字向けの
広い範囲のフォントをもっとも持ちそうなものです。しかし、これは、Emacs
が使うデフォルトではありません。（デフォルトでは、Emacsはボールドとイ
タリックの変種のフォントをみつけようとする。）オプション`-fn'やXのリソー
ス`Font'（*Note Font X::）で使用する標準フォントセットを指定できます。
たとえば、つぎのようにします。

     emacs -fn fontset-standard

フォントセットが、すべての文字コードに対するフォントを指定する必要はあ
りません。フォントセットが、ある文字に対してフォントを指定していない、
あるいは、システムに存在しないフォントを指定している場合には、その文字
を正しく表示できません。そのかわりに、中抜きの箱を表示します。

フォントセットの高さと幅は、ASCII文字で決定されます（つまり、そのフォ
ントセット内でASCII文字用に使われるフォント）。フォントセットのあるフォ
ントが異なる高さや幅を持つ場合には、そのフォントを割り当てられた文字は、
フォントセットの大きさに切り詰められます。`highlight-wrong-size-font'
が`nil'以外ならば、これらのまちがった大きさの文字は箱で囲まれて表示さ
れます。



File: emacs-ja.info, Node: Defining Fontsets, Next: Single-Byte European Support, Prev: Fontsets, Up: International

フォントセットの定義方法
========================

Emacsは`standard-fontset-spec'の値に従って、自動的に標準フォントセット
を作ります。フォントセットの名前はつぎのとおりです。

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または、省略して`fontset-standard'です。

標準フォントセットのボールド、イタリック、ボールドイタリックの変種も自
動的に作られます。それらの名前は、`medium'のかわりに`bold'、`r'のかわ
りに`i'、あるいは、両方ともそのようになります。

リソース`Font'やオプション`-fn'で、デフォルトのASCIIフォントを指定する
と、Emacsはそれから自動的にフォントセットを生成します。これが、"スター
トアップフォントセット"で、その名前は`fontset-startup'です。これは、フォ
ント名のフィールド、FOUNDRY、FAMILY、ADD_STYLE、AVERAGE_WIDTHを`*'で、
CHARSET_REGISTRYを`fontset'で、CHARSET_ENCODINGを`startup'で置き換えて
得られた文字列をフォントセットの指定に使用します。

たとえば、Emacsをつぎのように起動します。

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsがつぎのフォントセットを生成して、Xウィンドウの初期フレームに使い
ます。

     -*-*-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

Xのリソース`Emacs.Font'で、フォントセット名を実際のフォント名のように
指定できます。しかし、`Emacs*Font'のようなワイルドカードを使ったリソー
スにフォントセット名を指定しないように注意してください。ワイルドカード
を使った指定は、フォントセットを扱えないメニューのような、他のさまざま
な目的にも適用されます。

`Fontset-N'という名前のXのリソースを使って追加フォントセットを指定でき
ます。ただし、Nは0から始まる整数です。リソースの値はつぎのような形式で
なければなりません。

     FONTPATTERN, [CHARSETNAME:FONTNAME]...

FONTPATTERNは、最後の2つのフィールドを除いて、標準のXフォント名の形式
でなければなりません。最後の2つのフィールドは、`fontset-ALIAS'の形式を
持つべきです。

フォントセットには2つの名前、長い名前と短い名前があります。長い名前は
FONTPATTERNです。短い名前は`fontset-ALIAS'です。どちらの名前でもフォン
トセットを参照できます。

`CHARSET:FONT'という構成は、ある文字集合に対して（このフォントセットで
は）どのフォントを使用するかを指定します。ここでCHARSETは、文字集合の
名前で、FONTはその文字集合に使用するフォントです。1つのフォントセット
の定義の中では、この構成を何度でも使用できます。

他の文字集合に対しては、EmacsはFONTPATTERNに基づいて選択します。これに
は、文字集合を記述する値で`fontset-ALIAS'を置き換えます。ASCII文字フォ
ントに対しては、`fontset-ALIAS'を`ISO8859-1'で置き換えます

これに加えて、いくつか連続したフィールドがワイルドカードであるなら、
Emacsはそれらを1つのワイルドカードにまとめます。これは、自動的に拡大縮
小したフォントの使用を避けるためです。大きめのフォントを縮小したフォン
トは編集には使えません。また、小さめのフォントを拡大したフォントも便利
ではありません。というのは、Emacsがそうするように、もともと小さなフォ
ントを使うほうがよいからです。

したがって、FONTPATTERNがつぎのようであると、

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

また、Chinese GB2312文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

上のフォント指定に一致する中国語フォントがないかもしれません。多くのX
の配布には、FAMILYフィールドが`song ti'か`fangsong ti'の中国語フォント
だけが含まれています。そういった場合、`Fontset-N'をつぎのように指定し
ます。

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうすると、Chinese GB2312の文字を除くフォント指定ではFAMILYフィールド
が`fixed'となり、Chinese GB2312の文字に対するフォント指定ではFAMILYフィー
ルドが`*'となります。

フォントセットのリソース値を処理してフォントセットを作る関数は、
`create-fontset-from-fontset-spec'です。フォントセットを作るために、こ
の関数を明示的に呼ぶこともできます。

Xにおけるフォントの命名法について詳しくは、*Note Font X::。



File: emacs-ja.info, Node: Single-Byte European Support, Prev: Defining Fontsets, Up: International

1バイトヨーロッパ文字の使い方
=============================

ISO 8859 Latin-N文字集合は、さまざまなヨーロッパの言語で必要とされるア
クセント文字と句読点記号を扱うために、160から250の範囲の文字コードを定
義しています。マルチバイト文字を使用不可にしても、Emacsは、一度にはこ
れらの文字コードの*1つ*を扱えます。これらのコードの*どれ*を使うかを指
定するには、`M-x set-language-environment'を起動して、`Latin-N'のよう
な適切な言語環境を指定します。

ユニバイト操作についてより詳しくは、*Note Enabling Multibyte::を参照し
てください。非ASCII文字を含んだ初期化ファイルをユニバイトで読むことを
保証したいときには特に注意してください。

端末や使っているフォントでこれらの文字を扱えるならば、Emacsはこれらの
文字を表示できます。これは自動的に行われます。あるいは、ウィンドウシス
テムを使っている場合には、現在の言語環境に従ってそれらに対応するマルチ
バイト文字を表示することで、Emacsはフォントセットを介して1バイト文字を
表示できます。これを行うには、変数
`unibyte-display-via-language-environment'に`nil'以外の値を設定します。

もし、端末でLatin-1文字集合を表示できなければ、Emacsは、これらの文字を
その文字が少なくとも何であるかを明確に理解できるようなASCII列として表
示できます。これを行うには、ライブラリ`iso-ascii'をロードします。他の
Latin-N文字集合に対しても似たようなライブラリを実装できますが、まだ行っ
ていません。

（文字128から159の）非ISO 8859文字は、通常、8進表示されます。ライブラ
リ`disp-table'の関数`standard-display-8bit'を使えば、この表示を非標準
の「拡張」版のISO 8859文字集合に変更できます。

1バイト非ASCII文字を入力する異なる方法が3つあります。

   * キーボードが、非ASCII文字を表現する128以上の文字コードを生成でき
     るならば、Emacsがそれらを理解できるようにつぎの式を実行する。

          (set-input-mode (car (current-input-mode))
                          (nth 1 (current-input-mode))
                          0)

   * 選択した言語環境の入力方式を使う。*Note Input Methods::。ユニバイ
     トのバッファで入力方式を使うと、入力した非ASCII文字は、ユニバイト
     に変換される。

   * Latin-1に対してだけだが、非ASCIIのLatin-1の印字文字の入力の『合成
     文字』プレフィックスとして`C-x 8'を使える。`C-x 8'は、（ミニバッ
     ファや他のバッファでの）挿入、探索、キー列が許される他の文脈など
     で使える。

     ライブラリ`iso-transl'をロードすることで`C-x 8'は動作する。ライブ
     ラリをロードしておくと、ALT修飾キーがあるならば、`C-x 8'と同じ目
     的で使用できる。後続の文字を修飾するには、アクセント文字と一緒に
     ALTを使う。さらに、Latin-1の『専用アクセント文字』キーがあると、
     `iso-transl'をロード後は、それらのキーも後続の文字を合成するよう
     に定義される。


