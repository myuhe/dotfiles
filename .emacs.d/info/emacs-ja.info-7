Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Major Modes, Next: Indentation, Prev: International, Up: Top

メジャーモード
**************

Emacsには、多数の選択できる"メジャーモード"（major mode）があり、各モー
ドは特定の種類のテキストを編集するためにEmacsをカスタマイズします。メ
ジャーモードは相互に排他的で、各バッファはいつでも1つのメジャーモード
だけを持ちます。モード行は、通常、現行のメジャーモードの名前を括弧の中
に表示します（*Note Mode Line::）。

もっとも特殊化されていないメジャーモードは、"基本（fundamental）モード
"と呼ばれます。このモードには、モード独自の再定義や変数設定がなく、各
Emacsコマンドはもっとも一般的なふるまいをして、各オプションはデフォル
トの状態になっています。Lispや英文のように、Emacsが知っている特定の種
類のテキストを編集するには、Lispモードや、テキスト（text）モードのよう
な適切なメジャーモードに切り替えるべきです。

メジャーモードを選択することは、編集対象の言語により明確に適応するよう
にキーの意味を多少変更することです。よく変更されるキーはTAB、DEL、
`C-j'です。プレフィックスキー`C-c'は、モード特有のコマンドを含みます。
さらに、コメントを扱うコマンドは、モードを使ってコメントの区切り方を決
定します。多くのメジャーモードでは、バッファ内に現れる文字の構文上の属
性を再定義しています。*Note Syntax::。

メジャーモードは3つのグループに分けられます。（いくつかの変種を有する）
Lispモード、Cモード、Fortranモード、その他のプログラム言語特有のモード
のグループがあります。テキスト（text）モード、nroffモード、TeXとアウト
ライン（outline）モードなど英文を編集するためのものがあります。残りの
メジャーモードは、ユーザーのファイルに使うためのものではありません。
Emacsが特別の目的のために作るバッファで使われます。dired（*Note
Dired::）が作るバッファ向けのdiredモード（*Note Dired::）、`C-x m'で作
られるバッファ向けのメイル（mail）モード（*Note Sending Mail::）、下位
のシェルプロセスとの通信用のバッファ向けのシェル（shell）モード（*Note
Interactive Shell::）などです。

ほとんどのプログラム言語用のメジャーモードでは、段落の区切りは空行だけ
です。これは、段落コマンドを役立つようにするためです。（*Note
Paragraphs::。）また、これらのモードでは、自動詰め込み（auto-fill）モー
ドにおいて、新たに作った行を字下げするようにTABを定義します。というの
は、プログラム中のほとんどの行は通常字下げされるからです。（*Note
Indentation::。）

* Menu:

* Choosing Modes::     How major modes are specified or chosen.



File: emacs-ja.info, Node: Choosing Modes, Prev: Major Modes, Up: Major Modes

メジャーモードの選択方式
========================

カレントバッファに対して明示的にメジャーモードを選択することもできます。
しかし、たいていは、ファイル名やファイル内の特別のテキストに基づいて
Emacsはどのモードを使うかを決定します。

明示的に新しいメジャーモードを選択するには、`M-x'コマンドで行います。
メジャーモードの名前に`-mode'を付け加えると、そのモードを選ぶコマンド
名になります。したがって、Lispモードに入るには`M-x lisp-mode'を実行し
ます。

ファイルを訪問すると、Emacsは通常ファイル名に基づいて正しいメジャーモー
ドを選択します。たとえば、`.c'で終る名前のファイルは、Cモードで編集さ
れます。ファイル名とメジャーモードとの対応は、変数`auto-mode-alist'で
制御します。その値は、要素がつぎのような形式のリストです。

     (REGEXP . MODE-FUNCTION)

または、つぎの形式です。

     (REGEXP MODE-FUNCTION FLAG)

たとえば、このリストに通常ある要素は、`("\\.c\\'". c-mode)'です。これ
は、`.c'で終る名前のファイルにはCモードを選びます。（Lispの構文では、
`\'を含めるには`\\'が必要。また、`\'は、正規表現の`.'の特別な意味を抑
制するために必要。）リストの要素が`(REGEXP MODE-FUNCTION FLAG)'の形式
でFLAGが`nil'以外ならば、FUNCTIONを呼んだあとにREGEXPに一致する接尾辞
を捨てて、リストで他に一致するものをふたたび探します。

ファイルの空行でない最初の行の特別な種類のテキストによって、そのファイ
ルを編集するためにどのメジャーモードを使うかを指定できます。モード名は、
その行に`-*-'で囲まれて現れます。他のテキストがその行にあってもかまい
ません。たとえば、

     ;-*-Lisp-*-

は、EmacsにLispモードを使うように指示します。このような明示的な指定は、
ファイル名に基づいたメジャーモードに優先します。この行がLispのコメント
になるようにセミコロンを使っていることに注意してください。

モードを指定する別の書式は、つぎのとおりです。

     -*- mode: MODENAME;-*-

これは、同様にローカル変数も指定できて、つぎのように書きます。

     -*- mode: MODENAME; VAR: VALUE; ... -*-

より詳しくは、*Note File Variables::。

ファイルの内容が`#!'で始まるときは、ファイルの1行目で指定したコマンド
インタープリタを実行することで、実行可能なシェルコマンドとして働きます。
ファイルの残りの部分は、インタープリタへの入力として使われます。

Emacsでそのようなファイルを訪問したとき、ファイルの名前がメジャーモー
ドを指定しないときには、Emacsはモードを選択するために1行目のインタープ
リタの名前を使います。1行目が、`perl'や`tcl'のような認識されるインター
プリタプログラムの名前ならば、Emacsはインタープリタのプログラムにとっ
て適切なモードを使用します。変数`interpreter-mode-alist'は、インタープ
リタプログラム名とメジャーモードとの対応を指定します。

1行目が`#!'で始まるときには、インタープリタを実行するときにシステムが
混乱するため、1行目では`-*-'の機能を使えません。そのため、そのようなファ
イルでは、Emacsは1行目に加えて2行目でも`-*-'を探します。

使用するメジャーモードを指定しないファイルを訪問したとき、あるいは、
`C-x b'で新たにバッファを作るときには、変数`default-major-mode'が、使
用するモードを指定します。通常、その値は、基本（fundamental）モードを
指定するシンボル`fundamental-mode'です。`default-major-mode'が`nil'な
ら、メジャーモードはまえに選択していたバッファのモードと同じものとなり
ます。

バッファのメジャーモードを変更しても、Emacsが自動的に選択するメジャー
モードに戻れます。それには、コマンド`M-x normal-mode'を使います。この
コマンドは、メジャーモードを選択するために`find-file'が呼び出す関数と
同じ関数です。この関数は、ファイル中にローカル変数リストがあればそれも
処理します。

コマンド`C-x C-w'と`set-visited-file-name'は、新しいファイル名がモード
を示すものであるなら、新しいメジャーモードに変更します（*Note Savin
g::）。しかし、バッファの内容がメジャーモードを指定していて、かつ、あ
る『特別な』メジャーモードがそのモードの変更を許さないなら、メジャーモー
ドは変更されません。`change-major-mode-with-file-name'を`nil'に設定す
ると、このモード変更機能をオフにできます。


File: emacs-ja.info, Node: Indentation, Next: Text, Prev: Major Modes, Up: Top

字下げ
******

本章では、字下げ（indentation）を付加／削除／調整するEmacsコマンドにつ
いて説明します。

`TAB'
     モードに固有の方法で、現在行を『適切に』字下げする。
``C-j''
     RETに続けてTABを実行する（`newline-and-indent'）。
`M-^'
     2つの行を連結して1つにする（`delete-indentation'）。`C-j'の効果を
     取り消す。
`C-M-o'
     ポイント位置で行を分割する。つまり、行内のポイント以降のテキスト
     は新たな行になり、かつ、ポイント位置まで字下げする（`split-line'）。
`M-m'
     現在行の空白でない最初の文字までポイントを（行末か行頭へ向かって）
     移動する（`back-to-indentation'）。
`C-M-\'
     複数の行を同じ桁に字下げする（`indent-region'）。
`C-x TAB'
     複数の行の塊を（右か左に）同じ量だけきっちり移動する
     （`indent-rigidly'）。
`M-i'
     ポイント位置からあらかじめ設定したつぎのタブストップ位置まで字下
     げする（`tab-to-tab-stop'）。
`M-x indent-relative'
     ポイント位置からまえの行の字下げ位置まで字下げする。

ほとんどのプログラム言語には、字下げの慣習があります。Lispコードでは、
括弧の入れ子の深さに従って行を字下げします。細部はかなり異なりますが、
概念的にはCコードでも同様の考え方で字下げします。

どんな言語であっても、行を字下げするにはTABコマンドを使います。各メジャー
モードでは、特定の言語に適した字下げを行うように、このコマンドを定義し
ます。Lispモードでは、TABは括弧の深さに応じて行を整列します。行のどこ
でTABを打鍵しても、その行全体を整列します。Cモードでは、TABは、Cの構文
上のさまざまな側面を考慮した巧みで洗練された字下げスタイルを実現してい
ます。

テキスト（text）モードでは、TABは`tab-to-tab-stop'コマンドを実行します。
これは、つぎのタブストップ位置まで字下げを行います。タブストップ位置は
`M-x edit-tab-stops'で設定できます。

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.



File: emacs-ja.info, Node: Indentation Commands, Next: Tab Stops, Prev: Indentation, Up: Indentation

字下げコマンドとその技巧
========================

行の字下げを飛び越えるには、`M-m'（`back-to-indentation'）を使います。
行のどこで実行しても、その行の空白でない最初の文字位置にポイントを移動
します。

現在行のまえに字下げした行を挿入するには、`C-a C-o TAB'を使います。現
在行のあとに字下げした行を挿入するには、`C-e C-j'を使います。

単にタブ文字を挿入するには、`C-q TAB'と打ちます。

`C-M-o'（`split-line'）は、ポイントから行末までのテキストを垂直に下ろ
します。その結果、現在行は2つの行に分割されます。`C-M-o'は、まず、ポイ
ントの直後に空白やタブがある限りポイントを進めます。そして、ポイントの
直後に、改行とポイント位置の桁までに必要な字下げを挿入します。ポイント
自身は挿入した改行の直前に留まります。この点では、`C-M-o'は`C-o'に似て
います。

2つの行を連結するには、コマンド`M-^'（`delete-indentation'）を使います。
このコマンドは、現在行の行頭の字下げと行区切り（改行文字）を削除して空
白1個に置き換えます。ただし、この空白1個を省いてしまう（Lispコードには
便利な）特別な場合があります。2つの行を繋げた結果、開き括弧や閉じ括弧
が連続する場合、あるいは、さらに改行が続く場合です。現在行の字下げだけ
を削除するには、行頭に移動してから`M-\'（`delete-horizontal-space'）を
使います。このコマンドは、カーソル（ポイント）の周りの空白とタブをすべ
て削除します。

詰め込み接頭辞がある場合、`M-^'は、削除される改行の直後に現れる詰め込
み接頭辞を削除します。*Note Fill Prefix::。

一度に複数の行の字下げを変更するコマンドもあります。`C-M-\'
（`indent-region'）は、リージョン内で始まるすべての行に作用します。こ
のコマンドは、行頭でTABを打鍵したかのように『普通の』方法で各行を字下
げします。数引数は字下げする桁位置を指定します。つまり、最初の空白でな
い文字がその桁位置にくるように行全体を右か左に水平移動します。`C-x
TAB'（`indent-rigidly'）は、リージョン内のすべての行を、引数で指定した
分だけ右に移動します（引数が負であれば左に移動）。複数の行全部をきちっ
と揃えて（rigidly）横に移動することから、コマンドにはこのような名前が
付いています。

`M-x indent-relative'は、先行する行（実際には空行でないいちばん近くの
行）に基づいてポイント位置を字下げします。ポイント位置に空白を挿入して
ポイントを進めて、ポイントが先行する行の字下げ位置の真下にくるようにし
ます。字下げ位置とは連続した白文字の末尾か行末のことです。ポイントが先
行する行のどの字下げ位置よりも右にある場合には、ポイントのまえの白文字
を削除してから、先行する行の適用可能な最初の字下げ位置まで字下げします。
適用可能な字下げ位置がない場合には、`indent-relative'は
`tab-to-tab-stop'を実行します（*Note Tab Stops::）。

字下げテキスト（indented text）モードでは、TABは`indent-relative'と定
義されます。*Note Text::。

テキストの一部を字下げする別の方法については*Note Format Indentation::。



File: emacs-ja.info, Node: Tab Stops, Next: Just Spaces, Prev: Indentation Commands, Up: Indentation

タブストップ
============

表を入力するには、テキスト（textモード）におけるTABの定義、
`tab-to-tab-stop'を利用できます。このコマンドは、ポイントがつぎのタブ
ストップ位置に達するまでポイントのまえに字下げを挿入します。テキスト
（text）モードでなくても、`M-i'でこのコマンドを実行できます。

`M-i'が使用するタブストップは任意に設定できます。この設定は、昇順に並
べた桁番号のリストとして`tab-stop-list'と呼ばれる変数に格納されます。

タブストップを設定する便利な方法は、`M-x edit-tab-stops'を使うことです。
このコマンドは、タブストップの設定を記述したバッファを作成して選択しま
す。このバッファを編集して今までとは異なるタブストップを指定し、`C-c
C-c'と打ってその新たな設定を有効にします。`edit-tab-stops'は、呼ばれた
ときのカレントバッファをあらかじめ記録しておくので、そのバッファに新た
なタブストップを設定します。通常、全バッファで同じタブストップを共有し
ているので、1つのバッファでタブストップを変更すると、すべてのバッファ
に影響をします。しかし、あるバッファで`tab-stop-list'をローカルにして
おくと、そのバッファで`edit-tab-stops'を実行するとローカルな設定を編集
します。

一般的に使われる8桁ごとに設定されたタブストップの場合、設定用バッファ
の内容はつぎのようになります。

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

1行目は、各タブストップ位置をコロンで表します。残りの行は、タブストッ
プ位置を読み取りやすくためや使い方です。

`tab-to-tab-stop'を制御するタブストップと、バッファ内でのタブ文字の表
示とは、関係がないことに注意してください。詳細については*Note Display
Vars::。



File: emacs-ja.info, Node: Just Spaces, Prev: Tab Stops, Up: Indentation

タブと空白
==========

Emacsでは、通常、行の字下げにはタブと空白の両方を使用します。しかし、
空白だけを用いて字下げを行うことも可能です。そうするには、変数
`indent-tabs-mode'に`nil'を設定します。この変数はバッファごとの変数で
す。変数を変更してもカレントバッファだけに影響しますが、デフォルト値を
変更することもできます。*Note Locals::。

空白以外のテキストの桁を保存したまま、タブを空白（あるいはその逆）に変
換するコマンドもあります。`M-x tabify'は、リージョン内の連続する空白を
探して、字下げを変えることがなければ少なくとも連続する3個の空白をタブ
に変換します。`M-x untabify'は、リージョン内のすべてのタブを適切な個数
の空白に変換します。


File: emacs-ja.info, Node: Text, Next: Programs, Prev: Indentation, Up: Top

自然言語用のコマンド
********************

コンピュータの分野では、"テキスト"（text）という用語には2つの大きな意
味があります。1つは、文字の列から成るデータのことです。この意味からす
れば、Emacsで編集するどんなファイルもテキストです。もう1つの意味はより
限定されていて、人間が読む自然言語の（テキスト整形処理後の場合もあるが）
文字の列のことで、プログラムやプログラムに与えるコマンドと対比されます。

自然言語には、エディタコマンドで支援したり利用したりできる構文的／様式
的な約束事があります。たとえば、単語、文、段落、大文字といったものです。
本章では、これらを扱うEmacsコマンドについて述べます。また、"詰め込み"
（filling）、つまり、段落の各行がほぼ同じ長さになるように再配置し直す
コマンドについてもふれます。単語、文、段落を横断してポイントを移動した
り、それらをキルするコマンドは、自然言語テキストの編集を意図したもので
すが、プログラムの編集にも役立ちます。

Emacsには、自然言語テキストの編集用のメジャーモードがいくつかあります。
扱うテキストが純粋にテキストだけで単純なものであれば、テキスト（text）
モードを使いましょう。これは、自然言語テキストの構文上の約束事を扱える
ように、Emacsを少しだけカスタマイズしてあります。アウトライン（outline）
モードには、アウトライン構造を持つテキストを操作する特別なコマンドがあ
ります。

テキスト整形コマンドを埋め込んだテキストに対しては、特定のテキスト清書
系ごとに別のメジャーモードが用意してあります。たとえば、TeX用にはTeX 
モードがあります。nroff用にはnroffモードがあります。

テキスト清書系を使うかわりにエンリッチ（enriched）モードを使用すれば、
WYSIWYG（what you see is what you get、『見たとおりを得る』）スタイル
で整形済みテキストを編集することもできます。つまり、Emacsの画面上で整
形結果を見ながら編集できるわけです。

* Menu:

* Words::	        Moving over and killing words.
* Sentences::	        Moving over and killing sentences.
* Paragraphs::	        Moving over paragraphs.
* Pages::	        Moving over pages.
* Filling::	        Filling or justifying text.
* Case::	        Changing the case of text.
* Text Mode::	        The major modes for editing text files.
* Outline Mode::        Editing outlines.
* TeX Mode::	        Editing input to the formatter TeX.
* Nroff Mode::	        Editing input to the formatter nroff.
* Formatted Text::      Editing formatted text directly in WYSIWYG fashion.



File: emacs-ja.info, Node: Words, Next: Sentences, Up: Text

単語
====

Emacsには、単語を横断してポイントを移動したり、単語を操作対象とするコ
マンドがあります。慣例として、これらのコマンドのキーはメタ文字です。

`M-f'
     単語を横断してポイントを前向きに移動する（`forward-word'）。
`M-b'
     単語を横断してポイントを後向きに移動する（`backward-word'）。
`M-d'
     ポイント位置から単語の末尾までをキルする（`kill-word'）。
`M-DEL'
     ポイント位置から単語の先頭までを後向きにキルする
     （`backward-kill-word'）。
`M-@'
     つぎの単語の末尾にマークを設定する（`mark-word'）。
`M-t'
     隣接した2つの単語を入れ替える。あるいは、単語を複数の単語を飛び越
     して移す。（`transpose-words'）。

これらのキーは、文字単位の操作コマンド、`C-f'、`C-b'、`C-d'、DEL、
`C-t'に対応していることに注目してください。`M-@'も、`C-SPC'の別名であ
る`C-@'に対応しています。

コマンド`M-f'（`forward-word'）と`M-b'（`backward-word'）は、単語を横
断してポイントを前向きに（末尾に向かって）あるいは後向きに（先頭に向かっ
て）移動します。これらのメタ文字は、文字単位でポイントを前後に移動する
コントロール文字`C-f'や`C-b'に類似しています。この類似性は、数引数を反
復回数として扱うことにもおよびます。負の引数を指定すると、`M-f'は後向
きに移動し、`M-b'は前向きに移動します。前向き移動では単語の最後の文字
の直後に、後向き移動では最初の文字の直前に、ポイントを移動します。 (1)
(*Note Words-Footnotes::)

`M-d'（`kill-word'）はポイントの直後の単語をキルします。正確にいえば、
ポイント位置から`M-f'による移動位置までの全文字をキルします。ポイント
が単語の途中にあれば、ポイントよりあとの部分だけをキルします。また、ポ
イントとつぎの単語のあいだに句読点があれば、単語と一緒にそれらもキルし
ます。（つぎの単語だけをキルしてそのまえにある句読点を残したければ、
`M-f'でつぎの単語の末尾に移動してから、`M-DEL'でその単語を後向きにキル
する。）`M-d'は、引数を`M-f'と同様に解釈します。

`M-DEL'（`backward-kill-word'）は、
ポイントの直前の単語をキルします。
ポイント位置から`M-b'による移動位置までの全文字をキルします。
ポイントが`FOO, BAR'の空白の直後にあるとすれば、
`FOO, 'をキルします。
（`FOO'だけをキルしてコンマと空白を残したければ、
`M-DEL'のかわりに`M-b M-d'を使う。）

`M-t'（`transpose-words'）は、
ポイントの直前にある単語あるいはポイントを含む単語と、
後続の単語とを入れ替えます。
単語のあいだにある区切り文字は動きせん。
たとえば、`FOO, BAR'を入れ替えると、
`BAR FOO,'ではなく`BAR, FOO'となります。
入れ替えや入れ替えコマンドの引数については、
*Note Transpose::。

ポイントとマークのあいだに適用される操作を後続のN個の単語に適用する方
法は、2つあります。ポイント位置にマークを設定してから、単語を横断して
ポイントを移動します。あるいは、コマンド`M-@'（`mark-word'）を使います。
このコマンドは、ポイントを移動せずに、`M-f'による移動位置にマークを設
定します。`M-@'には、何単語先にマークを設定するかを数引数で指定できま
す。暫定マーク（transient-mark）モードでは、このコマンドはマークを活性
にします。

単語操作コマンドが理解する構文は、すべて構文テーブルで制御されます。た
とえば、任意の文字を単語の区切り文字として宣言できます。*Note Syntax::。


File: emacs-ja.info  Node: Words-Footnotes, Up: Words

(1) 【訳注】なお、移動方向に単語構成文字がない場合には、それらを飛び越
えてポイントを移動します。



File: emacs-ja.info, Node: Sentences, Next: Paragraphs, Prev: Words, Up: Text

文
==

Emacsの文／段落操作コマンドは、単語操作コマンドと同じく、ほとんどメタ
キーです。

`M-a'
     文の先頭にポイントを後向きに移動する（`backward-sentence'）。
`M-e'
     文の末尾にポイントを前向きに移動する（`forward-sentence'）。
`M-k'
     ポイント位置から文末までを前向きにキルする（`kill-sentence'）。
`C-x DEL'
     ポイント位置から文頭までを後向きにキルする
     （`backward-kill-sentence'）。

コマンド`M-a'と`M-e' （`backward-sentence'と`forward-sentence'）は、そ
れぞれ、ポイントを含む文の先頭あるいは末尾にポイントを移動します。これ
らは、行頭や行末にポイントを移動するコマンド`C-a'と`C-e'に類似するよう
に選ばれました。ただし、`M-a'や`M-e'を反復して使ったり数引数を指定する
と、ポイントは連続した文を横断して移動する点が違います。

（文頭に向かって）後向きに移動するときは、文の先頭の文字の直前にポイン
トを置きます。（文末に向かって）前向きに移動するときは、文を終える句読
点の直後に置きます。どちらのコマンドも、文と文の境界にある白文字にポイ
ントを移動することはありません。

`C-a'と`C-e'には調和したキルコマンド`C-k'があるように、`M-a'と`M-e'に
もコマンド`M-k'（`kill-sentence'）があります。これはポイントから文末ま
でをキルします。引数に-1を指定すると、文頭までを後向きにキルします。こ
れより大きな引数は反復回数になります。また、ポイント位置から文頭までを
後向きにキルするコマンドとして`C-x DEL'（`backward-kill-sentence'）も
あります。このコマンドは、文の作成途中で考えが変わったときに便利です。

文操作コマンドでは、文末に空白を2個打つという米国のタイピストの習慣を
踏襲しているものと仮定します。つまり、`.'、`?'、`!'の直後が行末である
か空白が2個続けば、その箇所を文末とみなします。ただし、`.'、`?'、`!'の
直後には、`)'、`]'、`''、`"'がいくつあってもかまいません。また、段落の
先頭と末尾も、それぞれ、文の先頭と末尾になります。

変数`sentence-end'で、文末の識別方法を制御します。この値は、文末の数個
の文字とそれらに続く白文字に一致する正規表現です。通常の値はつぎのとお
りです。 (1) (*Note Sentences-Footnotes::)

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この例は、正規表現の節で説明しました。*Note Regexps::。

文のあいだには空白を1個だけとしたければ、`sentence-end'にはつぎの値を
設定します。

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"

同時に、変数`sentence-end-double-space'には`nil'を設定して、詰め込みコ
マンドにも、文末には空白が1個だけあり、また、文末には空白を1個だけ追加
することを指示します。ただし、このように設定すると、文末のピリオドと省
略のピリオドとを区別できなくなることに注意してください。


File: emacs-ja.info  Node: Sentences-Footnotes, Up: Sentences

(1) 【訳注】言語環境を`Japanese'にすると、変数`sentence-end' は
     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*\\|[。？！]"
となっている。追加部分は、日本語の文末に対応する文字集合。



File: emacs-ja.info, Node: Paragraphs, Next: Pages, Prev: Sentences, Up: Text

段落
====

段落を操作するEmacsコマンドもメタキーです。

`M-{'
     まえの段落の先頭にポイントを後向きに移動する
     （`backward-paragraph'）。
`M-}'
     つぎの段落の末尾にポイントを前向きに移動する（`forward-paragrap
     h'）。
`M-h'
     ポイントを含む段落かつぎの段落の周りにポイントとマークを置く
     （`mark-paragraph'）。

`M-{'は、ポイントを含む段落の先頭か、まえの段落の先頭にポイントを移動
します。一方、`M-}'は、ポイントを含む段落の末尾か、つぎの段落の末尾に
ポイントを移動します。段落は、空行やテキスト整形コマンドの行で区切られ
ますが、それらの行自体は段落には属しません。基本（fundamental）モード
では、字下げした行も新たな段落の始まりとみなしますが、テキスト（text）
モードではそうしません。（段落の直前に空行があれば、これらのコマンドは
それらを段落の先頭として扱う。）

プログラム用のメジャーモードでは、段落は空行で始まり空行で終ります。こ
うしておけば、本来段落を持たないプログラムでも段落操作コマンドが役立ち
ます。

詰め込み接頭辞がある場合には、接頭辞で始まらない行が段落の区切りとなり
ます。*Note Filling::。

段落を対象に操作したいときには、コマンド`M-h'（`mark-paragraph'）を使っ
て段落を囲むようなリージョンを設定します。したがって、たとえば、`M-h
C-w'とすると、ポイントを含むか直後の段落を削除します。`M-h'コマンドは、
ポイントを含む段落の先頭にポイントを置き、末尾にマークを設定します。暫
定マーク（transient-mark）モードでは、このマークを活性にします。ポイン
トが段落のあいだ（空行や境界）にある場合は、ポイントの直後にある段落の
周りにポイントとマークを設定します。段落の1行目のまえに空行があれば、
直前の空行1行も`M-h'が設定するリージョンに含まれます。

正確な段落の境界は、変数`paragraph-separate'と`paragraph-start'で定義
されます。`paragraph-start'の値は、段落を始めたり区切ったりする行に一
致する正規表現です。`paragraph-separate'の値も別の正規表現ですが、どの
段落にも属さない段落を分割する行（たとえば空行）だけに一致するものです。
新たな段落を始めてその段落に属す行は、`paragraph-start'だけに一致して、
`paragraph-separate'に一致してはいけません。たとえば、基本
（fundamental）モードでは、`paragraph-start'は`"[ \t\n\f]"'であり、
`paragraph-separate'は`"[ \t\f]*$"'です。

通常、ページ境界でも段落が区切られるのが望ましいです。これらの変数のデ
フォルト値は、ページの一般的な区切り文字も認識します。



File: emacs-ja.info, Node: Pages, Next: Filling, Prev: Paragraphs, Up: Text

ページ
======

ファイルを"ページ送り"文字（ASCIIコードのコントロールL、8進コードの014）
で区切った"ページ"の集まりとして捉えることがよくあります。ファイルを印
刷すると、この文字は改ページを行います。そのため、ファイル内の各ページ
は別々の用紙に印刷されます。ほとんどのEmacsコマンドは、ページを区切る
文字を他の文字と同様に扱いますから、`C-q C-l'でページ送り文字を挿入し
たり、DELで削除できます。つまり、ファイルをページに区切るのも区切らな
いのも自由です。しかし、ページはファイルを分割する意味ある単位なので、
Emacsには、ページ間の移動やページを対象とするコマンドがあります。

`C-x ['
     まえのページ境界にポイントを移動する（`backward-page'）。
`C-x ]'
     つぎのページ境界にポイントを移動する（`forward-page'）。
`C-x C-p'
     このページ（か別のページ）の周りに、ポイントとマークを置く
     （`mark-page'）。
`C-x l'
     このページの行数を数える（`count-lines-page'）。

`C-x ['（`backward-page'）コマンドは、まえのページ区切り文字の直後にポ
イントを移動します。ポイントがすでにページ区切りの直後にあれば、さらに
まえのページ区切り文字の直後に移動します。数引数は反復回数として扱われ
ます。`C-x ]'（`forward-page'）コマンドは、つぎのページ区切り文字の直
後にポイントを移動します。

`C-x C-p'コマンド（`mark-page'）は、ページの先頭にポイントを置き、末尾
にマークを設定します。末尾にあるページ区切り文字は含まれます（マークは
ページ区切り文字の直後にある）。先頭にあるページ区切り文字は除外されま
す（ポイントはページ区切り文字の直後にある）。`C-x C-p C-w'は、ページ
全体をキルして別の場所に移動するのに便利な方法です。`C-x ['や`C-x ]'で
別のページ区切り位置に移動してからキルしたページをヤンクすれば、すべて
のページが適切に区切られた状態が維持されます。`C-x C-p'が末尾のページ
区切り文字だけを含める理由は、これを保証するためです。

`C-x C-p'への数引数は、現在のページを基準にしてポイントの移動先のペー
ジを指定します。0は現在のページを意味します。1はつぎのページ、-1はまえ
のページを意味します。

`C-x l'コマンド（`count-lines-page'）は、ページをどこで2つに分割するか
を決めるのに便利です。現在のページについて、総行数、現在行のまえにある
行数とうしろにある行数をつぎのようにエコー領域に表示します。

     Page has 96 lines (72+25)

この例で、総行数が1だけ少ないことに注意してください。ポイントが行頭に
ないとつねにこうなります。

変数`page-delimiter'はページの始まりを制御します。この変数の値は、ペー
ジを区切る行の先頭に一致する正規表現です。この変数の通常の値は`"^\f"'
で、行頭のページ送り文字に一致します。



File: emacs-ja.info, Node: Filling, Next: Case, Prev: Pages, Up: Text

テキストの詰め込み
==================

テキストの"詰め込み"（filling）とは、指定した幅に納まるようにテキスト
を行に分割することです。Emacsには、詰め込む方法が2つあります。自動詰め
込み（auto-fill）モードでは、自己挿入文字でテキストを挿入すると同時に
詰め込みを行います。あるいは、詰め込まずにテキストを編集しているときに
は、陽に詰め込みコマンドを使います。整形済みテキストを編集しているとき
は、テキストの各部分ごとに詰め込みのスタイルを指定できます（*Note
Formatted Text::）。

* Menu:

* Auto Fill::	        Auto Fill mode breaks long lines automatically.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::	        Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.



File: emacs-ja.info, Node: Auto Fill, Next: Fill Commands, Up: Filling

自動詰め込みモード（auto-fillモード）
-------------------------------------

"自動詰め込み"（auto-fill）モードはマイナモードで、行が長くなりすぎる
と自動的に分割します。SPCやRETを打鍵したときだけ、行を分割します。

`M-x auto-fill-mode'
     自動詰め込み（auto-fill）モードをオンにしたりオフにする。
`SPC'
`RET'
     自動詰め込み（auto-fill）モードでは、適切な場合には行を分割する。

`M-x auto-fill-mode'は、自動詰め込み（auto-fill）モードがオフならばオ
ンにし、オンならばオフにします。正の数引数を指定すると自動詰め込み
（auto-fill）モードをつねにオンにしますが、負の引数を指定するとつねに
オフにします。モード行の括弧の中に`Fill'と表示されていれば、このモード
はオンになっています。自動詰め込み（auto-fill）モードは、各バッファご
とにオン／オフできるマイナモードです。*Note Minor Modes::。

自動詰め込み（auto-fill）モードでは、行が決められた幅より長くなると、
自動的に空白の位置で行を分割します。行の分割と再配置は、SPCかRETを打鍵
したときだけ行われます。行を分割せずに空白や改行を挿入するには、`C-q
SPC'や`C-q C-j'と打鍵します（改行はまさにコントロールJであることを思い
出してほしい）。`C-o'も行を分割せずに改行を挿入します。

自動詰め込み（auto-fill）モードは、TABで新たな行を字下げするので、プロ
グラム言語用のモードと組み合わせてもうまく動作します。コメントで終わる
行が長くなりすぎた場合には、コメント内のテキストを2つのコメント行に分
割します。始めの行の末尾とつぎの行の行頭に新たにコメントの区切り文字列
を挿入して、2つの独立したコメント行にすることもできます。この付加機能
は、変数`comment-multi-line'で制御します（*Note Comments::）。

適応型詰め込み（後述）は、明示した詰め込みコマンドのみならず、自動詰め
込みに対しても有効に働きます。これは、段落の先頭行あるいは第2行目から、
自動的に詰め込み接頭辞を切り出します。

自動詰め込み（auto-fill）モードは、段落全体を詰め直すことはしません。
行を分割できても、併合はできません。そのため、段落の途中を編集すると、
必ずしも段落を正しく詰め込めません。段落をふたたび適切に詰め込まれた状
態にするもっとも簡単な方法は、明示的に詰め込みコマンドを使用することで
す。*Note Fill Commands::。

多くのユーザーは自動詰め込み（auto-fill）モードを好み、あらゆるテキス
トファイルの編集に使用しようとします。初期化ファイルの節では、こうする
方法を説明します。*Note Init File::。



File: emacs-ja.info, Node: Fill Commands, Next: Fill Prefix, Prev: Auto Fill, Up: Filling

明示的な詰め込みコマンド
------------------------

`M-q'
     現在の段落を詰め込む（`fill-paragraph'）。
`C-x f'
     詰め込み桁を設定する（`set-fill-column'）。
`M-x fill-region'
     リージョン内の各段落を詰め込む（`fill-region'）。
`M-x fill-region-as-paragraph'
     リージョン全体を1つの段落とみなして詰め込む。
`M-s'
     行を中央に揃える。

段落を詰め直すには、コマンド`M-q'（`fill-paragraph'）を使います。ポイ
ントを含む段落、あるいは、ポイントが段落のあいだにある場合には直後の段
落を操作します。改行をすべて取り除いてから、必要な箇所に新たに改行を挿
入することで段落を詰め直します。

いくつもの段落を詰め直すには、`M-x fill-region'を使います。これは、リー
ジョンを段落に分けてから、各段落を詰め込みます。

`M-q'と`fill-region'は、`M-h'と同じ基準で段落の境界を探します（*Note
Paragraphs::）。段落の大きさを制御するには、`M-x
fill-region-as-paragraph'を使います。これは、ポイントとマークのあいだ
にあるものすべてを詰め直します。このコマンドはリージョン内の空行をすべ
て削除して、分かれていたテキストの塊を1つの塊にまとめ上げます。

`M-q'に数引数を指定すると、テキストの詰め込みだけでなく、テキストの"幅
揃え"（justify）も行います。つまり、余分に空白を挿入して、行の右端が詰
め込み桁に一致するようにします。余分な空白を取り除くには、引数を指定し
ないで`M-q'を使います。（`fill-region'も同様。）幅揃えを制御して別の詰
め込みスタイルを選択する別の方法は、テキスト属性`justification'を使う
ことです。これに関しては、*Note Format Justification::を参照してくださ
い。

コマンド`M-s'（`center-line'）は、詰め込み桁までの範囲内で現在行を中央
に揃えます。引数Nを指定すると、現在行を含めN行をそれぞれ独立に中央に揃
えてから、揃えた行のつぎにポイントを移動します。

詰め込むときの行の最大幅は、変数`fill-column'に入っています。
`fill-column'の値を変更すると、カレントバッファにローカルな変数になり
ます。それまではデフォルト値が有効です。デフォルト値は始めは70です。
*Note Locals::。`fill-column'を設定するもっとも簡単な方法は、コマンド
`C-x f'（`set-fill-column'）を使うことです。このコマンドに数引数を指定
すると、その値を新たな詰め込み桁として使います。`C-u'だけを引数に指定
すると、ポイントの現在の水平位置を`fill-column'に設定します。

Emacsコマンドは通常、ピリオドの直後に空白が2個あるか改行があれば文末と
して扱います。ピリオドの直後に空白が1個だけでは、文末ではなく省略とみ
なします。ピリオドのこれら2つの用法の違いを保存するために、ピリオドの
直後に空白が1個だけの箇所では詰め込みコマンドは行を分割しません。

変数`sentence-end-double-space'が`nil'ならば、詰め込みコマンドは、文末
には空白が1個だけあると仮定し、かつ、文末には空白を1個だけ残します。普
通、この変数の値は`t'なので、上述のように空白が2個ある場合だけを文末と
して扱います。*Note Sentences::。

`colon-double-space'が`nil'以外ならば、詰め込みコマンドはコロンのうし
ろに空白を2個置きます。



File: emacs-ja.info, Node: Fill Prefix, Next: Adaptive Fill, Prev: Fill Commands, Up: Filling

詰め込み接頭辞
--------------

各行が（段落を字下げする数個の空白などの）特別の印で始まっている段落を
詰め込むには、"詰め込み接頭辞"（fill prefix）の機能を使えます。詰め込
み接頭辞は文字列であり、Emacsはすべての行がその文字列で始まると仮定し
ますが、詰め込み接頭辞自体は詰め込みの対象ではありません。明示的に詰め
込み接頭辞を指定できますが、Emacsが詰め込み接頭辞を自動的に推測するこ
ともできます（*Note Adaptive Fill::）。

`C-x .'
     詰め込み接頭辞を設定する（`set-fill-prefix'）。
`M-q'
     現在の詰め込み接頭辞を使って、段落を詰め込む（`fill-paragraph'）。
`M-x fill-individual-paragraphs'
     字下げ幅の変化を新たな段落の始まりとみなして、リージョン内を詰め
     込む。
`M-x fill-nonuniform-paragraphs'
     段落を分割する行だけを新たな段落の始まりとみなして、リージョン内
     を詰め込む。

詰め込み接頭辞を指定するには、
目的の接頭辞で始まっている行に移動して接頭辞の直後にポイントを置いてから、
コマンド`C-x .'（`set-fill-prefix'）を実行します。
`C-x'のあとはピリオドです。
詰め込み接頭辞の使用をやめるには、空の接頭辞を設定します。
つまり、行頭にポイントを置いてから`C-x .'と打ちます。

詰め込み接頭辞が設定されている場合、詰め込みコマンドは処理に先だって各
行から詰め込み接頭辞を取り除き、詰め込みを行ったあとに各行に挿入します。
自動詰め込み（auto-fill）モードでも、新たに行を作成するときに自動的に
詰め込み接頭辞を挿入します。行頭で`C-o'コマンド（*Note Blank Lines::）
を使用すると、新たに作成する行にも詰め込み接頭辞を挿入します。逆に、コ
マンド`M-^'は、削除する改行の直後に詰め込み接頭辞があると接頭辞も削除
します（*Note Indentation::）。

たとえば、`fill-column'が40で詰め込み接頭辞が`;; 'のときに、つぎのテキ
ストで`M-q'を実行します。

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

結果はつぎのようになります。

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

`M-q'および段落コマンドは、詰め込み接頭辞で始まらない行を段落の始まり
とみなします。これにより、ぶら下がり字下げ（先頭行を除いてすべての行が
字下げ）された段落も正しく詰め込みます。空行や接頭辞を取りさると字下げ
した行になる行も、段落の区切りや始まりとみなします。これによって、各行
にコメント区切りがある複数段落のコメントを書いているときにも、望みどお
りの結果を得られます。

各段落に対して自動的に詰め込み接頭辞を設定するには、`M-x
fill-individual-paragraphs'を使います。このコマンドは、字下げ幅の変化
を新たな段落の始まりとみなして、リージョンを段落に分割したあと、各段落
を詰め込みます。つまり、1つの『段落』内の行はどれも同じ字下げ幅です。
字下げ幅が、段落に対する詰め込み接頭辞として働きます。

`M-x fill-nonuniform-paragraphs'も同様なコマンドですが、リージョンを段
落に分割する方法が異なります。このコマンドは、（変数
`paragraph-separate'で定義される）段落区切り行だけを新たな段落の始まり
とみなします。つまり、各段落の行はさまざまに字下げされているかもしれな
いので、その中の最少の字下げを詰め込み接頭辞として使用するわけです。段
落の最初の行の字下げが残りの行に比べて多くても少なくても、正しい詰め込
み結果を得られます。

詰め込み接頭辞は変数`fill-prefix'に格納されます。この値は文字列である
か、詰め込み接頭辞が設定されていなければ`nil'です。この変数を変更して
もカレントバッファだけに影響しますが、デフォルト値を変更することもでき
ます。*Note Locals::。

テキスト属性`indentation'は、段落に与える字下げ幅を調整する別の方法で
す。*Note Format Indentation::。



File: emacs-ja.info, Node: Adaptive Fill, Prev: Fill Prefix, Up: Filling

適応型詰め込み
--------------

詰め込みコマンド自身が、段落に対する適切な詰め込み接頭辞を推測できる状
況もあります。段落のすべての行の先頭に白文字やある種の句読点文字が使わ
れている場合です。

段落が2行以上から成る場合、段落の2行目から詰め込み接頭辞を切り出します
が、1行目にもそれが現れるときに限ります。

段落が1行だけの場合には、その行から詰め込み接頭辞を切り出す*かもしれま
せん* (1) (*Note Adaptive Fill-Footnotes::)。こういった状況では、つぎ
のような3つの合理的な挙動が考えられるので、接頭辞の決定は複雑です。


   * 最初の行の接頭辞を段落のすべての行に用いる。

   * 1行目の接頭辞に続くテキストの直下に並ぶように後続の行を白文字で字
     下げするが、1行目から接頭辞をコピーしない。

   * 2行目以降には何も特別なことは行わない。

これら3つの整形スタイルは、いずれも一般的に使用されます。そこで、詰め
込みコマンドは、現れた接頭辞とそのときのメジャーモードに基づいて、ユー
ザーが望むスタイルを決定しようとします。判断基準はつぎのとおりです。

1行目でみつけた接頭辞が`adaptive-fill-first-line-regexp'に一致するか、
（メジャーモードに依存する）コメント開始文字列のようであれば、みつけた
接頭辞を段落の詰め込みに用います。ただし、その接頭辞が後続の行に対して
段落の始まりにならない場合に限ります。

さもなければ、みつけた接頭辞を相当分の空白に変換して、それらの空白を段
落の2行目以降の詰め込み接頭辞として使います。ただし、それらの空白が後
続の行に対して段落の始まりにならない場合に限ります。

テキスト（text）モード、および、空行やページ区切りだけが段落を区切るモー
ドでは、適応型詰め込みによって選ばれた接頭辞が段落の始まりになることは
けっしてありませんから、その接頭辞を段落の詰め込みに使用することができ
ます。

変数`adaptive-fill-regexp'で、行頭のどんな文字列を詰め込み接頭辞として
使えるかを決定します。この変数の正規表現に一致する行頭の文字列を接頭辞
とします。変数`adaptive-fill-mode'に`nil'を設定すると、詰め込み接頭辞
を自動的には切り出しません。

変数`adaptive-fill-function'に関数を設定すると、詰め込み接頭辞を自動的
に切り出すためのより複雑な方法を指定できます。この関数は行の左端の直後
にポイントを置いて呼び出されます。その行から類推される適切な詰め込み接
頭辞を返さなくてはいけません。その行に詰め込み接頭辞がなさそうであれば
`nil'を返します。


File: emacs-ja.info  Node: Adaptive Fill-Footnotes, Up: Adaptive Fill

(1) 【訳注】段落に1行しかなければ、詰め込み接頭辞を切り出す必要はない
と思うかもしれないが、たとえば、その行が詰め込み桁より長かったり、新た
な入力によって複数行の段落になったときのことを考えてみてほしい。



File: emacs-ja.info, Node: Case, Next: Text Mode, Prev: Filling, Up: Text

大文字小文字変換コマンド
========================

Emacsには、単語や任意の長さのテキストを大文字あるいは小文字に変換する
コマンドがあります。

`M-l'
     後続の単語を小文字に変換する（`downcase-word'）。
`M-u'
     後続の単語を大文字に変換する（`upcase-word'）。
`M-c'
     後続の単語の1文字目だけを大文字にする（`capitalize-word'）。
`C-x C-l'
     リージョン内のテキストを小文字に変換する（`downcase-region'）。
`C-x C-u'
     リージョン内のテキストを大文字に変換する（`upcase-region'）。

単語変換コマンドはたいへん便利です。`M-l'（`downcase-word'）はポイント
の直後の単語を小文字に変換し、単語の末尾にポイントを移動します。したがっ
て、`M-l'を繰り返すと、連続した単語を変換できます。`M-u'
（`upcase-word'）は単語を大文字に変換し、`M-c'（`capitalize-word'）は
単語の1文字目を大文字して残りを小文字に変換します。これらのコマンドに
引数を指定すると、一度に数単語を変換できます。これらのコマンドは、大文
字だけの大量のテキストを大文字小文字が混在するように変換するときに、特
に威力を発揮します。というのは、必要に応じて`M-l'、`M-u'、`M-c'を使い
分けて移動したり、`M-f'で変換せずに単語を飛び越えられるからです。

負の引数を指定すると、ポイントの直前にある数個の単語を変換しますが、ポ
イントは移動しません。これは、大文字小文字をまちがえて単語を入力した直
後には便利です。大文字小文字変換コマンドを打ってからすぐに入力を再開で
きます。

単語の途中で大文字小文字変換コマンドを実行すると、ポイントのうしろにあ
る部分だけを変換します。これは`M-d'（`kill-word'）のふるまいと同じです。
また、負の引数を指定すると、ポイントよりまえの部分を変換します。

他の大文字小文字変換コマンドは、`C-x C-u'（`upcase-region'）と`C-x
C-l'（`downcase-region'）です。これらは、リージョン内のテキストを指定
どおりに変換します。ポイントもマークも移動しません。

リージョンに対する大文字小文字変換コマンドである`upcase-region'と
`downcase-region'は、通常、使用禁止になっています。つまり、これらのコ
マンドを使おうとすると、最初に確認を求めてきます。確認するときにコマン
ドを使用可にしておけば、つぎからは確認を求めてきません。*Note
Disabling::。



File: emacs-ja.info, Node: Text Mode, Next: Outline Mode, Prev: Case, Up: Text

テキストモード（textモード）
============================

自然言語テキストのファイルを編集するときには、基本（fundamental）モー
ドではなくテキスト（text）モードを使ったほうが便利です。テキスト（text）
モードに入るには`M-x text-mode'と打ちます。

テキスト（text）モードでは、空行とページ区切りだけが段落の区切りです。
その結果、段落を字下げできて、適応型詰め込みでは段落の詰め込みに使用す
る字下げを決定できます。*Note Adaptive Fill::。

テキスト（text）モードでは、TABは`indent-relative'（*Note
Indentation::）を実行するように定義してあるので、先行する行と同じよう
に字下げするのに便利です。先行する行が字下げされてなければ、
`indent-relative'は`tab-to-tab-stop'を実行します。これは、ユーザーが設
定したEmacsのタブストップを使います（*Note Tab Stops::）。

テキスト（text）モードでは、コメントに関する機能は、陽に起動した場合を
除いてオフです。ピリオドは単語の一部ではなく、一方、アポストロフ、バッ
クスペース、下線は単語の一部である、となるように構文テーブルを変更しま
す。

段落の最初の行を字下げするのであれば、テキスト（text）モードではなく段
落字下げ型テキスト（paragraph-indent-text）モードを使うべきです。この
モードでは、段落のあいだに空行を設ける必要はありません。というのは、最
初の行の字下げで、段落の始まりがわかるからです。ただし、すべての行が字
下げされている段落は扱えません。このモードに入るには、`M-x
paragraph-indent-text-mode'を使います。

テキスト（text）モード、および、テキスト（text）モードに基づくすべての
モードでは、`M-TAB'をコマンド`ispell-complete-word'として定義します。
このコマンドは、ポイントの直前の部分的な単語を綴り辞書を用いて補完しま
す。*Note Spelling::。

テキスト（text）モードに入ると、フック`text-mode-hook'を実行します。テ
キスト（text）モードに関連する他のモードも、このフックに続けて各モード
専用のフックを実行します。つまり、段落字下げ型テキスト
（paragraph-indent-text）モード、nroffモード、TeXモード、アウトライン
（outline）モード、メイル（mail）モードがそうです。`text-mode-hook'に
登録されたフック関数では、`major-mode'の値を調べれば実際にどのモードに
入ったかわかります。*Note Hooks::。

Emacsには、綺麗な印刷出力を得るためにテキスト清書系に渡すテキストを編
集するためのモードが他に2つあります。nroff入力の編集については、*Note
Nroff Mode::。TeX入力の変数については、*Note TeX Mode::。

別のモードは、アウトラインの編集に使います。このモードは、さまざまなレ
ベルの詳しさでテキストを眺めることができます。アウトラインの見出しだけ
を見たり、見出しとテキストを同時に見たりできます。低いレベルの見出しの
一部を隠して、より高いレベルの構造を際だたせることもできます。*Note
Outline Mode::。



File: emacs-ja.info, Node: Outline Mode, Next: TeX Mode, Prev: Text Mode, Up: Text

アウトラインモード（outlineモード）
===================================

アウトライン（outline）モードはテキスト（text）モードにたいへんよく似
たメジャーモードですが、アウトライン構造を持つテキストの編集用です。ア
ウトライン構造を把握できるようにテキストの一部を一時的に不可視にできま
す。カレントバッファのメジャーモードをアウトライン（outline）モードに
切り替えるには、`M-x outline-mode'と打ちます。

アウトライン（outline）モードで行を不可視にすると、その行は画面上に表
示されません。画面上では、不可視にした行が削除されたかのように見えます
が、それに先行する可視な行の末尾に省略記号（ピリオドが3つ...）が表示さ
れます（何行不可視にしていても、省略記号は1つだけ）。

`C-n'や`C-p'のような行を対象とした編集コマンドは、不可視にした行のテキ
ストを、先行する可視な行の一部であるかのように扱います。改行も含めて可
視な行全体をキルすると、後続の不可視な行も一緒にキルします。

アウトラインマイナ（outline-minor）モードは、メジャーモードであるアウ
トライン（outline）モードと同じコマンドを提供しますが、他のメジャーモー
ドと一緒に使用できます。カレントバッファでアウトラインマイナ
（outline-minor）モードをオンにするには、`M-x outline-minor-mode'と打
ちます。`mode: outline-minor'といった形のファイルにローカルな変数で、
テキストファイルにアウトラインマイナ（outline-minor）モードを指定する
こともできます（*Note File Variables::）。

メジャーモードであるアウトライン（outline）モードでは、プレフィックス
`C-c'に特別なキーバインディングを設定しています。アウトラインマイナ
（outline-minor）モードでは、`C-c @'をプレフィックスとして同様のバイン
ディングがあります。これは、一緒に用いるメジャーモードの特別なコマンド
との衝突を減らすための措置です。（変数`outline-minor-mode-prefix'で、
実際に使用するプレフィックスを制御する。）

アウトライン（outline）モードに入ると、フック`text-mode-hook'に続けて
フック`outline-mode-hook'を実行します（*Note Hooks::）。

* Menu:

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines. 
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.



File: emacs-ja.info, Node: Outline Format, Next: Outline Motion, Up: Outline Mode

アウトラインの形式
------------------

アウトライン（outline）モードは、バッファの中には2種類の行、つまり、"
見出し行"（heading lines）、"本体行"（body lines）があると仮定します。
見出し行は、アウトラインのトピックを表していて、1つ以上の星印で始まり
ます。星印の個数は、アウトライン構造における見出しの深さを表します。つ
まり、星印1つの見出し行は主要なトピックを表します。この行とつぎの星印1
個の行のあいだにある星印2個の見出し行は、この行の下位トピックです。星
印がいくつであってもこのような関係が成り立ちます。見出し行以外は本体行
です。これらは直前の見出し行に属します。以下に例を示します。

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

見出し行とそれに続く本体行をまとめて"項目"（entry）と呼びます。また、
見出し行と、それに続くさらに深いレベルの見出し行とそれらの本体行をまと
めて"部分木"（subtree）と呼びます。

変数`outline-regexp'に値を設定して、見出し行を判定する基準をカスタマイ
ズできます。この正規表現に行頭が一致する行を見出し行とみなします。（左
端からではなく）行の途中で一致するものは、無視します。一致したテキスト
の長さによって、見出しのレベルを決定します。一致したテキストが長いほど
レベルが深くなります。したがって、たとえば、清書系に章や節を分ける
`@chapter'、`@section'、`@subsection'といったコマンドがある場合、これ
らの行を見出しとして扱えばよいのですが、それには`outline-regexp'に
`"@chap\\|@\\(sub\\)*section"'と設定します。これには、ちょっとしたトリッ
クがあります。2つの単語、`chapter'と`section'は同じ長さですが、正規表
現では、`chap'だけに一致するように定義することで、章見出しに一致するテ
キストの長さのほうを短くできます。これによって、アウトライン（outline）
モードは、章（chapter）の中に節（section）が含まれるとわかるのです。他
のコマンドが`@chap'で始まらない限り、この設定は有効です。

変数`outline-level'を設定すると、見出し行のレベル計算方法を変更できま
す。`outline-level'の値は、引数を取らない、現在の見出しのレベルを返す
関数である必要があります。Cモード、nroffモード、Emacs Lispモードといっ
たメジャーモードのいくつかでは、アウトラインマイナ（outline-minor）モー
ドが有効に働くように、この変数を設定します。



File: emacs-ja.info, Node: Outline Motion, Next: Outline Visibility, Prev: Outline Format, Up: Outline Mode

アウトライン上での移動コマンド
------------------------------

アウトライン（outline）モードには、前後の見出し行に移動する特別なコマ
ンドがあります。

`C-c C-n'
     つぎの可視な見出し行にポイントを移動する
     （`outline-next-visible-heading'）。
`C-c C-p'
     まえの可視な見出し行にポイントを移動する
     （`outline-previous-visible-heading'）。
`C-c C-f'
     ポイント位置と同じレベルのつぎの可視な見出し行にポイントを移動す
     る（`outline-forward-same-level'）。
`C-c C-b'
     ポイント位置と同じレベルのまえの可視な見出し行にポイントを移動す
     る（`outline-backward-same-level'）。
`C-c C-u'
     より浅い（より多くの項目を含む）レベルで、可視な見出し行にポイン
     トを移動する（`outline-up-heading'）。

`C-c C-n'（`outline-next-visible-heading'）は、つぎの見出し行にポイン
トを移動します。`C-c C-p'（`outline-previous-visible-heading'）も同様
ですが、逆向きにポイントを移動します。どちらのコマンドも、数引数を反復
回数として受け取ります。コマンドの名前は、不可視な見出し行を飛び越える
ことを強調していますが、これは何も特別な機能ではありません。行を探すよ
うなすべての編集コマンドは、不可視な行を自動的に無視します。

もっと強力な移動コマンドは、見出しのレベル構造を把握して移動を行うもの
です。`C-c C-f'（`outline-forward-same-level'）と`C-c C-b'
（`outline-backward-same-level'）は、アウトライン構造中で同じレベルに
ある別の見出し行にポイントを移動します。`C-c C-u'
（`outline-up-heading'）は、より浅いレベルの見出し行へ戻るようにポイン
トを移動します。



File: emacs-ja.info, Node: Outline Visibility, Next: Outline Views, Prev: Outline Motion, Up: Outline Mode

アウトラインの可視／不可視制御コマンド
--------------------------------------

アウトライン（outline）モードの特別なコマンドとして、行を可視／不可視
にするものもあります。これらのコマンドの名前は、すべて`hide'あるいは
`show'で始まります。これらのほとんどは、逆の機能のコマンドと対になって
います。これらのコマンドはアンドゥ可能ではありませんが、実行直後ならば
戻すことはできます。行を可視／不可視にするのは、アンドゥ機構に単純に記
録するのではありません。

`C-c C-t'
     バッファ中の本体行をすべて不可視にする（`hide-body'）。
`C-c C-a'
     バッファ中のすべての行を可視にする（`show-all'）。
`C-c C-d'
     ポイント位置の見出し行を除いて、その下位レベルのすべてを不可視に
     する（`hide-subtree'）。
`C-c C-s'
     ポイント位置の見出し行、本体、下位の見出し／本体、すべてを可視に
     する（`show-subtree'）。
`C-c C-l'
     ポイント位置の見出し行の本体と下位の見出し行のすべての本体を不可
     視にする（`hide-leaves'）。
`C-c C-k'
     ポイント位置の見出し行の下位の見出し行をすべて可視にする
     （`show-branches'）。
`C-c C-i'
     ポイント位置の見出し行の直下（1レベル深い）の下位見出しを可視にす
     る（`show-children'）。
`C-c C-c'
     ポイント位置の見出し行の本体を不可視にする（`hide-entry'）。
`C-c C-e'
     ポイント位置の見出し行の本体を可視にする（`show-entry'）。
`C-c C-q'
     最上位のNレベルまでを除き、すべてを不可視にする（`hide-sublevel
     s'）。
`C-c C-o'
     ポイント位置の見出し行や本体、および、そこから最上位レベルに至る
     までに通過する見出し行を除き、すべて不可視にする（`hide-other'）。

`C-c C-c'（`hide-entry'）と`C-c C-e'（`show-entry'）の2つのコマンドは、
正反対の機能を持っています。これらは、見出し行にポイントがある場合 (1)
(*Note Outline Visibility-Footnotes::) に、その本体のみに作用します。
下位見出しとその本体は影響を受けません。

もっと強力で機能が正反対のコマンドは、`C-c C-d'（`hide-subtree'）と
`C-c C-s'（`show-subtree'）です。どちらも見出し行にポイントがあるとき 
(2) (*Note Outline Visibility-Footnotes::) に使い、見出しの"部分木" 内
のすべての行つまり、本体、直接／間接に関わらずあらゆる下位の見出しとそ
の本体、に作用します。つまり、部分木には、その見出し行に続くつぎの同レ
ベルか上位レベルの見出し行の直前までが含まれます。

可視な部分木と、すべて不可視な部分木の中間的な状態には、本体は不可視で
下位の見出し行はすべて可視といったものも存在します。この状態を作り出す
コマンドは2つあり、本体を不可視にするか、下位見出しを可視にするかです。
これらは、`C-c C-l'（`hide-leaves'）と`C-c C-k'（`show-branches'）です。

`C-c C-i'（`show-children'）は、`show-branches'より少し弱いコマンドで
す。これは、直下の、つまり1レベル深い見出し行だけを可視にします。より
深いレベルの見出しは不可視ならば不可視のままです。

ファイル全体に効果がおよぶ2つのコマンドがあります。`C-c C-t'
（`hide-entry'）は本体行をすべて不可視にするので、アウトライン構造だけ
を眺めることができます。`C-c C-a'（`show-all'）は、すべての行を可視に
します。`C-c C-a'は本体行以外にも作用しますが、これらのコマンドは正反
対の機能の対と考えることができます。

コマンド`C-c C-q'（`hide-sublevels'）は、最上位レベルの見出し以外をす
べて不可視にします。数引数Nを指定すると、最上位からNレベルまでの見出し
行を除いたすべてを不可視にします。

コマンド`C-c C-o'（`hide-other'）は、ポイント位置の見出しあるいは本体、
その親（アウトライン構造においてポイント位置から最上位レベルまで至る見
出し）を除いたすべてを不可視にします。

変数`selective-display-ellipses'に`nil'を設定すると、可視な行の末尾に
現れる省略記号を消せます。そうすると、不可視な行の存在を示すものは何も
なくなります。

インクリメンタルサーチでアウトライン（outline）モードが不可視にしてい
るテキストを探しだすと、バッファのその部分は可視になります。その箇所で
探索から抜けると、テキストは可視のまま (3) (*Note Outline
Visibility-Footnotes::)になります。


File: emacs-ja.info  Node: Outline Visibility-Footnotes, Up: Outline Visibility

(1) 【訳注】ポイントが本体行にあっても動作する。

(2) 【訳注】ポイントが本体行にあっても動作し、結果も同じ。

(3) 【訳注】抜けると、また不可視にもどってしまう。




File: emacs-ja.info, Node: Outline Views, Prev: Outline Visibility, Up: Outline Mode

複数の視点からアウトラインを眺める
----------------------------------

1つのアウトライン構造を同時に2つの視点から別々のウィンドウに表示して眺
めることができます。それには、`M-x make-indirect-buffer'を使って間接バッ
ファを作成する必要があります。このコマンドの最初の引数は、既存のアウト
ライン用バッファの名前で、2番目の引数は新たに作成する間接バッファの名
前です。*Note Indirect Buffers::。

間接バッファがあるならば、`C-x 4 b'や他のEmacsコマンドで普通にそのバッ
ファをウィンドウに表示できます。テキストの一部を可視／不可視にするアウ
トライン（outline）モードのコマンドは、各バッファで独立に働きます。そ
の結果、各バッファごとに独自の視点を持たせることが可能です。同じアウト
ラインに対して3つ以上の視点が必要ならば、間接バッファをさらに作成して
ください。



File: emacs-ja.info, Node: TeX Mode, Next: Nroff Mode, Prev: Outline Mode, Up: Text

TeXモード
=========

TeXは、Donald Knuthが作成した強力な清書系です。しかも、GNU Emacsと同じ
くフリーです。LaTeXは、TeXの入力形式を単純化したもので、TeXのマクロで
実現されています。これもTeXに付属しています。SliTeXはスライドを作成す
るためにLaTeXを特殊化したものです。

Emacsには、TeXの入力ファイルを編集するための特別なTeXモードがあります。
このモードには、区切りの対応を検査したり、ファイル全体やその一部に対し
てTeXを起動したりする機能があります。

TeXモードには3つの変種があります。それぞれ、プレインTeX（plain-tex）モー
ド、LaTeX（latex）モード、SliTeX（slitex）モードです（これら3つはメジャー
モードですが、差異はわずか）。これらのモードは、異なる3つの入力形式を
編集するように設計されています。コマンド`M-x tex-mode'は、バッファ内の
内容を調べて、LaTeXの入力なのかSliTeXの入力なのか判断します。そのいず
れかであれば、それに適したモードを選択します。ファイルの中身がLaTeXで
もSliTeXでもなさそうであれば、プレインTeX（plain-tex）モードを選択しま
す。ファイルの内容が判断するに十分でなければ、変数`tex-default-mode'で
使用するモードを制御します。

`M-x tex-mode'が適切なモードを推測できなかった場合には、コマンド`M-x
plain-tex-mode'、`M-x latex-mode'、`M-x slitex-mode'で明示的にTeXの変
種を選択できます。

* Menu:

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.



File: emacs-ja.info, Node: TeX Editing, Next: LaTeX Editing, Up: TeX Mode

TeX編集コマンド
---------------

ここでは、TeXの入力ファイルのテキストを編集するためにTeXモードに用意し
てある特別なコマンドについて述べます。

`"'
     文脈に応じて`"'、`"'、`"'を挿入する（`tex-insert-quote'）。
`C-j'
     段落区切り（空行を2つ）を挿入し、まえの段落の中括弧やドル記号の対
     応を検査する（`tex-terminate-paragraph'）。
`M-x tex-validate-region'
     リージョン内の各段落に対して、中括弧やドル記号の対応を検査する。
`C-c {'
     `{}'を挿入して、そのあいだにポイントを移動する
     （`tex-insert-braces'）。
`C-c }'
     対応が取れていないつぎの閉じ中括弧のあとに前向きにポイントを移動
     する（`up-list'）。

TeXでは、文字`"'はまず使いません。引用を始めるには`"'を、終るには`"'を
使います。こういったテキスト整形上の規則の下で編集作業を楽にするために、
TeXモードでは``'と`''を対で挿入する（`tex-insert-quote'）ようにキー`"'
の意味を変えています。より正確にいえば、このコマンドは白文字や開き中括
弧のあとでは`"'を、バックスラッシュのあとでは`"'を、これ以外の文字のあ
とでは`"'を挿入します。

特別な文脈で`"'文字が必要であれば、`C-q'を使って挿入します。また、`"'
に数引数を指定すると、その個数分の`"'を入力します。ローカルマップから
バインディング（*Note Key Bindings::）を取り除けば、`"'を展開する機能
をオフにできます。

TeXモードでは、`$'にはTeXの数式モードの区切りの対応を確認するための特
別な構文コードが設定されています。数式モード終了を意味する`$'を挿入す
ると、それに対応した数式モード開始の`$'を1秒間ほど表示します。これは、
閉じ中括弧を挿入すると、それに対応する開き中括弧を表示する機能と同じで
す。しかし、`$'が数式モードを開始するものか終了するものかを知る方法が
ありません。したがって、数式モード開始の`$'を挿入しても、たとえ実際に
は無関係であっても、まえにある`$'が対応しているかのように表示されてし
まいます。

TeXは、中括弧を必ず対応が取れている区切りとして使います。ユーザーの中
には、中括弧を別々に入力するよりも、つねに対応が取れている中括弧の入力
を好む人もいます。`C-c {'（`tex-insert-braces'）と打てば中括弧の対を挿
入できます。さらに、ポイントがそれらのあいだに置かれるので、中括弧の内
側にテキストを挿入できます。そのあとに、コマンド`C-c }'（`up-list'）を
使って、閉じ中括弧のうしろに移動します。

中括弧の対応を調べるコマンドは2つあります。`C-j'
（`tex-terminate-paragraph'）は、ポイントの直前の段落を検査してから、
新たな段落を始める空行を2つ挿入します。対応していない中括弧があれば、
エコー領域にメッセージを表示します。`M-x tex-validate-region'は、リー
ジョンの段落を1つ1つ検査します。エラーはバッファ`*Occur*'に表示されま
す。このバッファで`C-c C-c'や`Mouse-2'を使えば、特定の非対応箇所へ移動
できます。

TeXモードでは、Emacsコマンドは中括弧だけでなく、括弧（`()'）や角括弧
（`[]'）も数えています。これは、TeXの構文を検査する目的からいえば、厳
密には正しくありません。しかし、括弧や角括弧はテキスト内で対応する区切
りとしてよく使われますし、各種の移動コマンドや対応関係を自動表示するコ
マンドがそれらを扱えると便利です。



File: emacs-ja.info, Node: LaTeX Editing, Next: TeX Print, Prev: TeX Editing, Up: TeX Mode

LaTeX編集コマンド
-----------------

LaTeXモードと、その変種のSliTeX モードには、プレインTeX（plain-tex）で
は利用できない特別な機能がいくつかあります。

`C-c C-o'
     LaTeXのブロックを表す`\begin'と`\end'を挿入し、それらのあいだにポ
     イントを置く（`tex-latex-block'）。
`C-c C-e'
     まだ閉じていないもっとも内側のLaTeXのブロックを閉じる
     （`tex-close-latex-block'）。

LaTeXの入力では、`\begin'と`\end'がテキストのブロックをグループ化する
ために使われます。`\begin'と対応する`\end'を（`\begin'のつぎの新しい行
に）挿入するには、`C-c C-o'（`tex-latex-block'）を使います。それらのあ
いだには空行が挿入されてポイントもそこに置かれます。ブロックの種類を入
力するときには、補完を使えます。標準のリストに含まれないブロック名を使
う場合には、変数`latex-block-names'に設定します。つぎの例は、`theorem'、
`corollary'、`proof'を追加するものです。

     (setq latex-block-names '("theorem" "corollary" "proof"))

LaTeXの入力では、`\begin'と`\end'は対応が取れている必要があります。
`C-c C-e'（`tex-close-latex-block'）を使うと、対応が取れていない最後の
`\begin'に対応する`\end'を自動的に挿入できます。また、対応する`\begin'
と同じ字下げを`\end'にも施します。ポイントが行頭にあったときには、
`\end'のうしろで改行します。



File: emacs-ja.info, Node: TeX Print, Prev: LaTeX Editing, Up: TeX Mode

TeX印刷コマンド
---------------

バッファ全体あるいは一部のテキストに対して、Emacsの下位プロセスとして
TeXを起動できます。特定の章だけに対してこのようにTeXを実行するのは、ファ
イル全体の清書に時間を費すことなく、変更部分の見え方を確認するよい方法
です。

`C-c C-r'
     バッファのヘッダとともに、カレントリージョンに対してTeXを起動する
     （`tex-region'）。
`C-c C-b'
     カレントバッファ全体に対してTeXを起動する（`tex-buffer'）。
`C-c TAB'
     現在のファイルに対してBibTeXを起動する（`tex-bibtex-file'）。
`C-c C-f'
     現在のファイルに対してTeXを起動する（`tex-file'）。
`C-c C-l'
     下位プロセスであるTeXの出力を表示したウィンドウをスクロールして、
     出力行の最後が見えるようにする（`tex-recenter-output-buffer'）。
`C-c C-k'
     TeXのサブプロセスを終了させる（`tex-kill-job'）。
`C-c C-p'
     最後に実行した`C-c C-r'、`C-c C-b'、`C-c C-f'の出力を印刷する。
     （`tex-print'）。
`C-c C-v'
     最後に実行した`C-c C-r'、`C-c C-b'、`C-c C-f'の出力をプレビューす
     る（`tex-view'）。
`C-c C-q'
     プリンタキューを表示する（`tex-show-print-queue'）。

`C-c C-b'（`tex-buffer'）を使えば、カレントバッファの内容を下位のTeXに
渡すことができます。清書結果は一時ファイルに出力されます。それを印刷す
るには、`C-c C-p'（`tex-print'）と打ちます。そのあとで、印刷の進捗状況
を確認するには`C-c C-q'（`tex-show-print-queue'）を利用できます。TeXの
出力ファイルを表示する機能を持った端末があれば、`C-c C-v'（`tex-view'）
でプレビューできます。

TeXが実行時に使うディレクトリを指定するには、変数`tex-directory'に設定
します。デフォルトの値は`"."'です。環境変数`TEXINPUTS'に相対的なディレ
クトリ名が入っていたり、TeXの`\input'コマンドに相対的なファイル名を指
定してある場合には、`tex-directory'は`"."'である*必要*があります。さも
ないと、誤った結果になるでしょう。そういった状況でなければ、`"/tmp"'の
ような、他のディレクトリを設定しても安全です。

下位のTeXを起動するために使うコマンドを指定したければ、変数
`tex-run-command'、`latex-run-command'、`slitex-run-command'、
`tex-dvi-print-command'、`tex-dvi-view-command'、
`tex-show-queue-command'にそれぞれ値を設定します。
`tex-dvi-view-command'にはデフォルト値がないので、使用する端末にあわせ
た値を設定する*必要*があります。これ以外の変数には、使用するシステムに
適切と思われる（そうでないかもしれないが）デフォルト値が設定されていま
す。

通常は、これらのコマンドに与えるファイル名はコマンド文字列の最後にきま
す。たとえば、`latex FILENAME'です。しかし、ときにはコマンドの途中にファ
イル名を埋め込む必要があります。たとえば、パイプを介して出力を他のコマ
ンドに渡すようなコマンドの引数にファイル名を指定する場合です。ファイル
名を置く箇所は、コマンド文字列中の`*'で指定できます。たとえば、以下の
ように設定します。

     (setq tex-dvi-print-command "dvips -f * | lpr")

エラーメッセージを含めたTeXからの端末出力は、`*tex-shell*'と呼ばれるバッ
ファにすべて現れます。TeXがエラーを報告した場合には、このバッファに切
り替えれば適切な入力を与えることができます（これはシェル（shell）モー
ドと同様に動作する。*Note Interactive Shell::）。このバッファに切り替
えなくても`C-c C-l'と打てば、バッファの最後の行が表示されるようにスク
ロールできます。

TeXの出力が不要となったら、TeXプロセスを終了させるために`C-c C-k'
（`tex-kill-job'）と打ちます。`C-c C-b'や`C-c C-r'を使っても、動作中の
TeXプロセスを終了できます。

`C-c C-r'（`tex-region'）と打てば、任意のリージョンを下位のTeXに渡せま
す。しかし、これには少々巧妙な手口を必要とします。というのは、たいてい
の場合、TeXの入力ファイルの先頭部分にはパラメータの設定やマクロ定義が
あり、それらがないと残りの部分を正しく清書できないからです。この問題を
解決するために、`C-c C-r'ではファイルの中で必須の整形コマンドを含んで
いる部分を指定できます。リージョンのまえにその部分を加えてTeXへの入力
とします。ファイル中の必須であると指定された部分を"ヘッダ"と呼びます。

プレインTeX（plain-tex）モードでヘッダの境界を示すには、ファイルに2つ
の特別な文字列を挿入します。ヘッダの直前に`%**start of header'を、ヘッ
ダの直後に`%**end of header'を挿入します。どちらの文字列も2行にまたがっ
てはいけませんが、前後に別のテキストがあってもかまいません。これらの文
字列を持つ行もヘッダに含まれます。バッファの先頭から100行以内に
`%**start of header'が現れなければ、`C-c C-r'はヘッダがないと仮定しま
す。

LaTeXモードでは、`\documentstyle'で始まり`\begin{document}'で終わる部
分がヘッダです。これらは、いかなる場合でもLaTeXが要求するコマンドなの
で、ヘッダを認識するために特別なことをする必要はありません。

コマンド`tex-buffer'と`tex-region'は、一時的なディレクトリ上ですべての
作業を行うので、相互参照のためにTeXが必要とする補助ファイルを使用でき
ません。一般に、これらのコマンドは、相互参照がすべて正しい必要がある最
終的な原稿の作成には適していません。

相互参照のための補助ファイルを必要とする場合には、カレントバッファのファ
イルを入力として、そのファイルを置いたディレクトリでTeXを実行する`C-c
C-f'（`tex-file'）を使います。TeXを実行するまえに、変更したすべてのバッ
ファを保存するか尋ねてきます。一般には、正しい相互参照を得るためには、
`tex-file'を2度実行する必要があります。

変数`tex-start-options-string'の値は、TeXの実行のオプションを指定しま
す。デフォルト値は、TeXをバッチモードで実行します。TeXを対話的に実行す
るには、変数に`""'を設定します。

巨大なTeX文書は、複数のファイル、つまり、1つのメインファイルとサブファ
イルとに分割されることがよくあります。サブファイルに対してTeXを実行し
ても、うまくいくことはまずありません。メインファイルに対してTeXを実行
する必要があります。サブファイルを編集する場合でも`tex-file'を使えるよ
うに、メインファイルの名前を変数`tex-main-file'に設定できます。そうす
ると`tex-file'はそのファイルに対してTeXを実行します。

`tex-main-file'のもっとも便利な使い方は、各サブファイルのローカル変数
リストで指定することです。*Note File Variables::。

LaTeX用ファイルであれば、カレントバッファのファイルに対する補助ファイ
ルを処理するためにBibTeXを使えます。BibTeXは、参考文献をデータベースで
調べて、参考文献の節のための文献リストを準備します。コマンド`C-c TAB'
（`tex-bibtex-file'）は、カレントバッファのファイルに対する`.bbl'ファ
イルを生成するためのシェルコマンド（`tex-bibtex-command'）を実行します。
通常は、まず`.aux'ファイルを作るために`C-c C-f'（`tex-file'）を一度実
行してから、つぎに`C-c TAB'（`tex-bibtex-file'）を実行し、正しい相互参
照を得るために`C-c C-f'（`tex-file'）をさらに2回実行します。

どのTeXモードに入っても、フック`text-mode-hook'と`tex-mode-hook'を実行
します。そのあとで、`plain-tex-mode-hook'か`latex-mode-hook'の適切なフッ
クを実行します。SliTeXファイルに対しては、`slitex-mode-hook'を呼びます。
TeX用のシェルの開始時には、フック`tex-shell-hook'を実行します。*Note
Hooks::。



File: emacs-ja.info, Node: Nroff Mode, Next: Formatted Text, Prev: TeX Mode, Up: Text

nroffモード
===========

nroffモードはテキスト（text）モードに似ていますが、テキスト中のnroffコ
マンドを扱えるように変更してあります。このモードに入るには、`M-x
nroff-mode'を実行します。テキスト（text）モードとは、2、3の点で異なる
だけです。nroffコマンドを含んだ行は、すべて段落区切りとみなすので、詰
め込みによってnroffコマンドが本文に混ざってしまうことはありません。ペー
ジは`.bp'コマンドで分割されます。コメントは`.\"'で始まります。また、テ
キスト（text）モードにはない、つぎの3つの特別なコマンドがあります。

`M-n'
     nroffコマンドではないつぎの行の先頭にポイントを移動する
     （`forward-text-line'）。引数は反復回数。
`M-p'
     `M-n'と同様だが、まえの行に移動する（`backward-text-line'）。
`M-?'
     リージョン中のテキスト（nroffコマンド以外）の行数をエコー領域に表
     示する（`count-text-lines'）。

nroffモードの他の機能としては、エレクトリックnroff（electric-nroff）モー
ドがあります。これは`M-x electric-nroff-mode'でオン／オフできるマイナ
モードです（*Note Minor Modes::）。このモードがオンのとき、グループを
始めるnroffコマンドを含む行を終えるためにRET (1) (*Note Nroff
Mode-Footnotes::)を打つたびに、そのグループを終える対応したnroffコマン
ドを自動的につぎの行に挿入します。たとえば、行頭で`. ( b RET'と打つと、
ポイントのうしろに新たな行として対応するnroffコマンド`.)b'を挿入します。

nroffモードと一緒にアウトラインマイナ（outline-minor）モード（*Note
Outline Mode::）を使用すると、見出し行は`.H'のあとに（見出しのレベルに
あたる）数字が続く形になります。

nroffモードに入ると、フック`text-mode-hook'に続いてフック
`nroff-mode-hook'が実行されます（*Note Hooks::）。


File: emacs-ja.info  Node: Nroff Mode-Footnotes, Up: Nroff Mode

(1) 【訳注】実際には`C-j'。



File: emacs-ja.info, Node: Formatted Text, Prev: Nroff Mode, Up: Text

整形済みテキストの編集
======================

"エンリッチ（enriched）モード"は、ワープロのようにWYSIWYG方式で、整形
済みテキストを含むファイルの編集を行うためのマイナモードです。現在のと
ころ、エンリッチ（enriched）モードの整形済みテキストには、フォント、表
示色、下線、左右端、詰め込みと幅揃えの種類を指定できます。将来的には、
その他の整形機能も実装しようと計画しています。

エンリッチ（enriched）モードはマイナモードです（*Note Minor Modes::）。
通常は、テキスト（text）モードと一緒に使います（*Note Text Mode::）。
しかしながら、アウトライン（outline）モードや段落字下げ型テキスト
（paragraph-indent-text）モードのような他のメジャーモードと一緒に使う
ことも可能です。

Emacsは能力的には整形済みテキストのファイルをさまざまなファイル形式で
格納することができす。現在のところは、1種類の形式のみ、つまり、MIMEプ
ロトコルで定義された"text/enriched"形式のみを実装してあります。Emacsが
どのようにファイルの形式を識別し変換するかの詳細に関しては*Note ファイ
ル書式変換: (elisp)Format Conversion。

Emacsの配布の中には、実例として整形済みテキストファイル
`etc/enriched.doc'があります。このファイルには、本節で説明するすべての
機能の実例が盛り込まれています。また、将来の拡張に関するアイデアも述べ
てあります。

* Menu:

* Requesting Formatted Text::   Entering and exiting Enriched mode.
* Hard and Soft Newlines::      There are two different kinds of newlines.
* Editing Format Info::         How to edit text properties.
* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the 
                                  left or right margin, etc.
* Other: Format Properties.     The "special" text properties submenu.
* Forcing Enriched Mode::       How to force use of Enriched mode.



File: emacs-ja.info, Node: Requesting Formatted Text, Next: Hard and Soft Newlines, Up: Formatted Text

整形済みテキストの編集
----------------------

text/enriched形式でEmacsが保存したファイルを訪れると、Emacsは自動的に
ファイル中の整形情報をEmacs自身の内部形式（テキスト属性）に変換し、エ
ンリッチ（enriched）モードをオンにします。

新たに整形済みテキストファイルを作成するには、まず、存在しないファイル
を訪れてから、テキストを入力するまえに`M-x enriched-mode'と打ちます。
このコマンドはエンリッチ（enriched）モードをオンにします。入力されるテ
キストが正しく扱われることを保証するために、テキストを挿入するまえにエ
ンリッチ（enriched）モードをオンにしてください。

より一般的にいえば、コマンド`enriched-mode'は、エンリッチ（enriched）
モードがオフならオン、オンならオフにします。数引数を指定すると、それが
正であればエンリッチ（enriched）モードをオンにし、それ以外ではオフにし
ます。

エンリッチ（enriched）モードがオンのときにバッファを保存すると、Emacs
はテキストをファイルに書き出すときに自動的にtext/enriched形式へ変換し
ます。ふたたびそのファイルを訪問すると、Emacsは自動的にその形式を認識
してテキストを変換し、エンリッチ（enriched）モードをオンにします。

通常、text/enriched形式のファイルを訪問すると、Emacsは各段落を指定され
た右端に納まるように詰め込みます。この詰め込みをやめて時間を短縮するた
めに、変数`enriched-fill-after-visiting'に`nil'か`ask'を設定します。

しかし、エンリッチ（enriched）モードで保存したファイルを訪問するときに
は、Emacsは右端の設定をテキストと一緒に保存しているので、テキストを再
度詰め込む必要はありません。

通常はEmacsが保存しないテキスト属性に対する注記（annotation）も保存す
るようにするには、変数`enriched-translations'に追加しておきます。
text/enriched規格では、非標準の注記には、`x-read-only'のように`x-'で始
まる名前が必要なことに注目してください。これによって、あとから追加され
る標準的な注記と名前が衝突しないことが保証されます。



File: emacs-ja.info, Node: Hard and Soft Newlines, Next: Editing Format Info, Prev: Requesting Formatted Text, Up: Formatted Text

ハード改行とソフト改行
----------------------

Emacsは整形済みテキスト中の改行を、"ハード"改行と"ソフト"改行の2種類に
区別します。

ハード改行は、段落の区切り、リスト内の項目、左右端に関係なく行分割がつ
ねに必要な箇所に用いられます。RETコマンド（`newline'）と`C-o'
（`open-line'）はハード改行を挿入します。

ソフト改行は、テキストを左右端のあいだに納めるために使用されます。自動
詰め込み（auto-fill）モードを含めたすべての詰め込みコマンドはソフト改
行を挿入し、ソフト改行だけを削除します。

ハード改行とソフト改行は見た目は同じですが、違いを理解することは重要で
す。詰め込んだ段落の途中で行に分割するときにRETを使ってはいけません。
あとの詰め込みの妨げとなるハード改行を挿入してしまいます。かわりに、自
動詰め込み（auto-fill）モードに行分割を行わせて、テキストや左右端が変
化してもEmacsが適切に再度詰め込めるようにします。*Note Auto Fill::。

一方、表やリストのように、入力したとおりの行にしておく必要がある場合に
は、RETで行を終えます。これらの行では、幅揃えのスタイルとして
`unfilled'を指定するのもよいかもしれません。*Note Format
Justification::。



File: emacs-ja.info, Node: Editing Format Info, Next: Format Faces, Prev: Hard and Soft Newlines, Up: Formatted Text

整形情報の編集
--------------

整形済みテキストファイルの整形情報を変更するには、2つの方法があります。
キーボードコマンドを使うか、マウスを使います。

文書に属性を追加するもっとも簡単な方法は、Text Propertiesメニューを使
用することです。このメニューを出すには2つの方法があります。メニューバー
のEditメニューから選択するか、`C-mouse-2'（CTRLキーを押し下げたままマ
ウスの真中のボタンを押す）です。

Text Propertiesメニューのほとんどの項目には、別のサブメニューがついて
います。これらについては後述します。コマンドを直接実行する項目もありま
す。

`Remove Properties'
     Text Propertiesメニューで扱えるすべてのテキスト属性をリージョンか
     ら取り除く（`facemenu-remove-props'）。

`Remove All'
     *すべて*のテキスト属性をリージョンから取り除く
     （`facemenu-remove-all'）。

`List Properties'
     ポイント直後の文字のすべてのテキスト属性を表示する
     （`list-text-properties-at'）。

`Display Faces'
     定義済みフェイス一覧を表示する。

`Display Colors'
     定義済み表示色一覧を表示する。
            


File: emacs-ja.info, Node: Format Faces, Next: Format Colors, Prev: Editing Format Info, Up: Formatted Text

整形済みテキストのフェイス
--------------------------

Facesサブメニューには、`bold'、`italic'、`underline'といったEmacsで使
用できる各種フェイスが並んでいます。その中から1つを選ぶと、リージョン
にフェイスを追加します。*Note Faces::。以下のキーボードコマンドでフェ
イスを指定することもできます。

`M-g d'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`default'にす
     る（`facemenu-set-default'）。
`M-g b'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`bold'にする
     （`facemenu-set-bold'）。
`M-g i'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`italic'にす
     る（`facemenu-set-italic'）。
`M-g l'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`bold-italic'
     にする（`facemenu-set-bold-italic'）。
`M-g u'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`underline'に
     する（`facemenu-set-underline'）。
`M-g o FACE RET'
     リージョン、あるいは、つぎに挿入する文字のフェイスをFACEにする
     （`facemenu-set-face'）。

前置引数を指定してこれらのコマンドを使ったり、暫定マーク
（transient-mark）モードでリージョンが選択されていなければ、これらのコ
マンドはつぎに入力する自己挿入文字だけに使うフェイスを指定します。
*Note Transient Mark::。これはキーボードコマンドとメニューコマンドの両
方に通用します。

エンリッチ（enriched）モードには、`excerpt'と`fixed'の2つの追加フェイ
スが定義されています。これらのフェイスは、text/enrichedファイル形式で
使用されるコードに対応しています。

`excerpt'フェイスは引用を表すためのものです。カスタマイズしてなければ
`italic'と同じです（*Note Face Customization::）。

`fixed'フェイスは、『この部分のテキストには固定幅フォントを使用する』
という意味です。現在、Emacsは固定幅フォントにだけ対応しています。した
がって、`fixed'の注記は今のところ必要ありません。しかしながら、将来の
Emacsでは可変幅フォントに対応したり、固定幅フォントをデフォルトとしな
いtext/enriched形式を表示可能な他のシステムを計画しています。ですから、
固定幅フォントをどうしても使いたい箇所には、その部分のテキストに
`fixed'を指定するべきです。

通常、`fixed'フェイスには、デフォルトと異なるフォントを使うように定義
されています。ところが、システムごとにさまざまなフォントがありますから、
この定義をカスタマイズする必要があるかもしれません。

異なるフェイスを表示できない端末ではそれらの違いを目にすることはできま
せんが、それでも、さまざまなフェイスを含む文書の編集は行えます。文書に
フェイスや表示色を追加することもできます。それらを表示可能な端末で見た
ときにフェイスや色を目にすることができます。



File: emacs-ja.info, Node: Format Colors, Next: Format Indentation, Prev: Format Faces, Up: Formatted Text

整形済みテキストの表示色
------------------------

テキストの部分ごとに前景色と背景色を指定できます。前景色を指定するメ
ニューと背景色を指定するメニューがあります。これらのメニューには、その
Emacsセッションのエンリッチ（enriched）モードで使っている表示色一覧が
表示されます。

前置引数とともに表示色を指定したり、暫定マーク（transient-mark）モード
でリージョンが選択されていなければ、つぎに入力する自己挿入文字だけに作
用します。*Note Transient Mark::。そうでなければ、コマンドはリージョン
に作用します。

それぞれの表示色メニューにはもう1つ`Other'という項目があります。この項
目は、メニューに表示されていない表示色を指定するために使います。これは、
ミニバッファで表示色名称を読み取ります。利用可能な表示色と名前の一覧を
表示するには、Text Propertiesメニューの`Display Colors'項目を使います
（*Note Editing Format Info::）。

このようにして指定した表示色や、読み込んだ整形済みテキスト内で使われて
いる表示色は、そのEmacsセッション中は、両方の表示色メニューに追加され
ます。

表示色を指定するためのキーバインディングはありませんが、拡張コマンド
`M-x facemenu-set-foreground'や`M-x facemenu-set-background'を使えばで
きます。どちらのコマンドもミニバッファで表示色名称を読み取ります。



