Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja.info, Node: Format Indentation, Next: Format Justification, Prev: Format Colors, Up: Formatted Text

整形済みテキストの字下げ
------------------------

整形済みテキストの編集では、段落全体あるいは段落の一部に異なる左端と右
端の字下げを指定できます。指定した左右端は、自動的に詰め込みコマンド
（*Note Filling::）と行分割コマンドに反映されます

Indentationサブメニューは、これらの属性を指定するための便利なインター
フェイスです。このサブメニューにはつぎの4つの項目があります。

`Indent More'
     リージョンを4桁分字下げする（`increase-left-margin'）。エンリッチ
     （enriched）モードでは、このコマンドは`C-x TAB'でも実行できる。数
     引数を指定すると、左端に加える桁数として扱う（負の値であれば桁を
     減らす）。

`Indent Less'
     リージョンから4桁分字下げを取り除く。

`Indent Right More'
     右端を4桁分字下げしてテキストの幅を狭める。

`Indent Right Less'
     右端から4桁分字下げを取り除く。

なお、これらのコマンドを繰り返せば、字下げを増やしたり減らしたりできま
す。

これらのコマンドの一般的な使い方は、段落全体の字下げを変更することです。
しかし、それだけではありません。任意の箇所で左右端を変更できます。新た
に設定された値は、行末（右端）やつぎの行の先頭（左端）に影響します。

それにより、"ぶら下がり字下げ"で段落を整形することができます。ぶら下が
り字下げとは、1行目の字下げ幅が2行目以降の字下げ幅より少ないものです。
ぶら下がり字下げするには、段落の最初の単語の直後から始まり段落の末尾ま
で続くリージョンの字下げ幅を増やします。

段落の1行目の字下げはもっと簡単です。段落の本体があるべき位置に段落全
体に対する左右端を設定してから、最初の行に追加の空白やタブを挿入すれば
よいのです。

編集の結果、段落の詰め込みが汚くなってしまうことがあります。たとえば、
段落の一部が左端や右端からはみ出してしまうことです。そうなったときには、
`M-q'（`fill-paragraph'）を使って、段落を詰め込み直します。

変数`standard-indent'は、これらのコマンドで増減する字下げ幅を指定しま
す。デフォルト値は4です。エンリッチ（Enriched）モード全体に対する右端
のデフォルトは、通常どおり変数`fill-column'で制御します。

詰め込み接頭辞があれば、指定した段落の字下げに追加されます。`C-x .'は、
詰め込み接頭辞として新たに指定された値には、字下げの白文字を含めません。
しかも、詰め込みコマンドは各行の字下げのうしろにある詰め込み接頭辞を探
します。*Note Fill Prefix::。



File: emacs-ja.info, Node: Format Justification, Next: Format Properties, Prev: Format Indentation, Up: Formatted Text

整形済みテキストの幅揃え
------------------------
            
整形済みテキストの編集では、段落に対してさまざまなスタイルの揃え方を指
定できます。指定したスタイルは自動的にEmacsの詰め込みコマンドに影響し
ます。

Justificationサブメニューは、スタイルを指定するための便利なインターフェ
イスです。このサブメニューにはつぎの5項目があります。

`Flush Left'
     これは（少なくとも英語では）もっとも一般的な幅揃えスタイル。行は
     左端に揃えられるが、右側は不揃いのまま。

`Flush Right'
     右端に行を揃える。必要に応じて左側に空白やタブを挿入して右側で行
     を揃える。

`Full'
     行ごとに左右両端を揃える。このスタイルで揃えると空白を均等に挿入
     する。印刷物では見栄えがたいへんよいが、画面上の固定幅フォントで
     はそれほど美しくない。たぶん、将来のEmacsでは行内の空白量を調節で
     きるようになり、エレガントな幅揃えが達成できるであろう。

`Center'
     各行を現在の左右端の中央に揃える。

`None' (1) (*Note Format Justification-Footnotes::)詰め込みをいっさい止める。各行は入力したままになる。つまり、この
     設定をしたテキストでは、詰め込みコマンドも自動詰め込み機能も何の
     効果もない。それでも、左端を字下げすることは可能。詰め込まないリー
     ジョンでは、改行はすべてハード改行として扱う（*Note Hard and Soft
     Newlines::）。

エンリッチ（enriched）モードでは、`M-j'プレフィックス文字を使ってキー
ボードで幅揃えを指定することもできます。

`M-j l'
     リージョンを左端揃えにする（`set-justification-left'）。
`M-j r'
     リージョンを右端揃えにする（`set-justification-right'）。
`M-j f'
     リージョンを左右端揃えにする（`set-justification-full'）。
`M-j c'
`M-S'
     リージョンを中央揃えにする（`set-justification-center'）。
`M-j u'
     リージョンでは詰め込まない（`set-justification-none'）。

揃え方のスタイルは段落全体に適用されます。揃え方を変更するコマンドは、
ポイントを含む段落に作用しますが、リージョンが設定されているときにはリー
ジョンと重なる段落すべてが対象になります。

揃え方のスタイルのデフォルトは、変数`default-justification'で指定され
ます。この値は、`left'、`right'、`full'、`center'、`none' (2) (*Note
Format Justification-Footnotes::) のいずれかのシンボルでなくてはいけま
せん。


File: emacs-ja.info  Node: Format Justification-Footnotes, Up: Format Justification

(1) 【訳注】メニューには`None'ではなく`Unfilled'が表示
される。

(2) 【訳注】詰め込まないことを指定するシンボルは`none'。
`Unfilled'ではない。
         


File: emacs-ja.info, Node: Format Properties, Next: Forcing Enriched Mode, Prev: Format Justification, Up: Formatted Text

他のテキスト属性の設定
----------------------

Other Propertiesメニュー (1) (*Note Format Properties-Footnotes::)には、
`read-only'、`invisible'、`intangible'といった有用なテキスト属性を追加／
削除する項目があります。`intangible'属性はテキスト内にポイントを移動で
きなくし、`invisible'属性はテキストを表示しないようにし、`read-only'属
性はテキストを変更できなくします。


これらの特別な属性には、リージョンに属性を付加するためのメニュー項目が
あります。最後のメニュー項目`Remove Special'は、これらの特別な属性すべ
てをリージョンから取り除きます。

現在のところ、`invisible'属性と`intangible'属性は、text/enriched形式に
保存され*ません*。`read-only'属性は保存されますが、これはtext/enriched
形式の標準的なものではないので、Emacs以外の他のエディタでは使用されな
いかもしれません。


File: emacs-ja.info  Node: Format Properties-Footnotes, Up: Format Properties

(1) 【訳注】`Other Properties'ではなく、`Special Properties'
と表示される。



File: emacs-ja.info, Node: Forcing Enriched Mode, Prev: Format Properties, Up: Formatted Text

エンリッチ（enriched）モードの強制
----------------------------------

普通は、Emacsは訪問したファイル内にある特別な注記を認識するので、整形
済みテキストを編集中であることがわかります。ところが、ファイルの内容を
変換するために特別な操作をしたり、手動でエンリッチ（enriched）モードを
オンにする必要がある状況もあります。

   * 他のエディタで作成したtext/enriched形式のファイルを訪問すると、
     Emacsがそのファイルをtext/enriched形式であると認識しないかもしれ
     ない。こういった場合、ファイルを訪れると、整形済みテキストではな
     く整形コマンドを目にする。`M-x format-decode-buffer'と打って形式
     を変換する。

   * ファイルを訪問したのではなく、バッファにファイルを*挿入*したとき。
     Emacsは挿入されたテキストに対しては必要な変換を行うが、エンリッチ
     （enriched）モードをオンにしない。オンにしたければ、`M-x
     enriched-mode'と打つ。

コマンド`format-decode-buffer'は、さまざまな形式のテキストをEmacsの内
部形式に変換します。このコマンドは、どの形式からの変換であるのかを尋ね
てきますが、通常は単にRETを打てばEmacsが形式を推測します。

text/enriched形式のファイルをそのままの形、つまり、整形済みテキストで
はなく文字列として見たいのであれば、`M-x find-file-literally'コマンド
を使います。このコマンドは`find-file'のようにファイルを訪問しますが、
形式変換を行いません。文字コード変換（*Note Coding Systems::）と自動展
開（*Note Compressed Files::）も禁止します。形式変換を禁止しても、適宜、
文字コード変換や自動展開を行わせたいのであれば、適当な引数を指定して
`format-find-file'を使います。



File: emacs-ja.info, Node: Programs, Next: Building, Prev: Text, Up: Top

プログラムの編集
****************

Emacsには、LispやCといったプログラム言語の構文を理解するように設計され
たコマンドが数多くあります。以下のことを行えます。

   * 釣り合った式や"S式"（*Note Lists::）を横断したりそれらをキルする。
   * トップレベルの式、つまり、Lispの"defun"やCの関数（*Note Defuns::）
     を横断したりそれらにマークを設定する。
   * 括弧の対応具合を表示する（*Note Matching::）。
   * コメントの挿入／キル／整列（*Note Comments::）。
   * 使用言語の慣用的な字下げを踏襲する（*Note Program Indent::）。

単語／文／段落を扱うコマンドは、自然言語のテキストを編集するのが本来の
目的ですが、コードを編集する場合にもおおいに役立ちます。なぜなら、たい
ていのシンボルは単語ですし（*Note Words::）、文は文字列やコメントの中
にも含まれるからです（*Note Sentences::）。段落は本質的にはコードの中
には存在しませんが、プログラム言語向けのメジャーモードでは、段落は空行
で始まり空行で終わると定義するので、段落コマンドも役立ちます（*Note
Paragraphs::）。空行をうまく使ってプログラムが整然と見えるようにすると、
段落コマンドもうまく働きます。

選択的表示機能は、関数の全体構成を眺めるのに便利です（*Note Selective
Display::）。この機能は、指定幅以内の字下げ幅の行だけを表示します。

* Menu:

* Program Modes::       Major modes for editing programs.
* Lists::	        Expressions with balanced parentheses.
* List Commands::       The commands for working with list and sexps.
* Defuns::	        Each program is made up of separate functions.
			  There are editing commands to operate on them.
* Program Indent::      Adjusting indentation to show the nesting.
* Matching::	        Insertion of a close-delimiter flashes matching open.
* Comments::	        Inserting, killing, and aligning comments.
* Balanced Editing::    Inserting two matching parentheses at once, etc.
* Symbol Completion::   Completion on symbol names of your program or language.
* Which Function::      Which Function mode shows which function you are in.
* Documentation::       Getting documentation of functions you plan to call.
* Change Log::	        Maintaining a change history for your program.
* Tags::	        Go direct to any function in your program in one
			  command.  Tags remembers which file it is in.
* Emerge::	        A convenient way of merging two versions of a program.
* C Modes::             Special commands of C, C++, Objective-C, 
                          Java, and Pike modes.
* Fortran::	        Fortran mode and its special features.
* Asm Mode::	        Asm mode and its special features.



File: emacs-ja.info, Node: Program Modes, Next: Lists, Up: Programs

プログラム言語向けメジャーモード
================================

Emacsには、Lisp、Scheme（Lispの方言の1つ）、Awk、C、C++、Fortran、Icon、
Java、Objective-C、Pascal、Perl、Pike、CORBA IDL、Tclといった各種プロ
グラム言語向けのメジャーモードがあります。makefile用のメジャーモード、
makefileモードもあります。Perl向けの別のモードとして、cperlモードもあ
ります。

理想的には、Emacsで編集する可能性のあるすべてのプログラム言語に対して、
それぞれのメジャーモードを実装すべきです。しかし、ある言語向けのモード
が、構文的に類似した他の言語にも使えることがよくあります。既存の言語モー
ド群は、誰かがわざわざ書こうと決心したものです。

Lispモードにはいくつか変種がありますが、Lispを実行する際のインターフェ
イス方法が異なります。*Note Executing Lisp::。

各プログラム言語向けメジャーモードでは、その言語の慣用的な字下げ方法を
理解し現在行をそのように字下げする関数を実行するようにTABキーを定義し
ます。たとえば、Cモードでは、TABは`c-indent-line'にバインドされていま
す。また、`C-j'は、RETに続けてTABを実行するように定義されています。つ
まり、モードに固有の字下げも行います。

多くのプログラム言語では、行ごとに字下げ量が異なります。そのため、その
ような言語向けのメジャーモードでは、（コマンド
`backward-delete-char-untabify'を使って）タブ文字を等価な個数の空白と
同じに扱うようにDELを再定義しています。その結果、字下げが空白かタブの
どちらで構成されているのか気にせずに、1度に1桁ずつ消去することが可能と
なります。そのようなモードでは、ポイントの直前にあるタブ文字を削除する
には`C-b C-d'を使います。

プログラム言語向けモードでは、段落は空行で分割されると定義するので、段
落コマンドも便利に使えます。プログラム言語向けメジャーモードで自動詰め
込み（auto-fill）モードがオンのときには、新たに行を作ると自動的に字下
げも行われます。

メジャーモードに入ると、"モードフック"（mode hook）と呼ばれるノーマル
フックが実行されます。モードフックは、Lisp変数の値です。各メジャーモー
ドにはモードフックがあり、フック名はつねにモードに入るためのコマンド名
に`-hook'を付加したものです。たとえば、Cモードに入るとフック
`c-mode-hook'が実行され、Lispモードではフック`lisp-mode-hook'が実行さ
れます。*Note Hooks::。



File: emacs-ja.info, Node: Lists, Next: List Commands, Prev: Program Modes, Up: Programs

リストとS式
===========

慣習として、釣り合った式を扱うEmacsのキーは、普通、コントロール・メタ
文字です。これらは、コントロールやメタだけの対応したキーの機能に似せて
あります。これらは、プログラム言語の式だけに関係したコマンドだと考えら
れがちですが、ある種の括弧が存在する（自然言語も含めた）任意の言語に対
しても有益なものです。

これらのコマンドは、2つのグループに分けられます。一方は（括弧でまとめ
た）"リスト"（list） (1) (*Note Lists-Footnotes::)だけを扱うもので、丸
括弧、角括弧、中括弧（使用言語において対応が取れている必要がある括弧）
と、それらをクォートするエスケープ文字だけに注目するコマンド群です。


もう一方は、式あるいは"S式"（sexp）を扱うコマンド群です。「sexp」とい
う用語は、Lispの式を意味する古くからの用語"s-expression"に由来します。
Emacsでは「S式」の概念をLispに限定しません。プログラムを記述した言語が
何であっても、その式をS式と呼びます。各プログラム言語には独自のメジャー
モードがあり、そこでは、その言語の式をS式とみなすように構文テーブルを
調整してあります。

一般にS式には、丸括弧、角括弧、中括弧に囲まれた部分だけでなく、シンボ
ル、数値、文字列定数も含まれます。

Cのように前置演算子と中置演算子を使う言語では、すべての式をS式として扱
うことは不可能です。たとえば、Cモードでは、`foo + bar'はCの式*です*が、
S式としては認識しません。かわりに、`foo'と`bar'をそれぞれ1つのS式とし
て認識し、`+'はあいだにある句読点として認識します。これは根本的に曖昧
なのです。たとえば、ポイントが`f'にあるとき、横断すべきS式としては、
`foo + bar'でも`foo'でも正当な選択肢です。`(foo + bar)'は、Cモードにお
いて単一のS式であることに注意してください。

式の構文が曖昧なために、Emacsが正しく解釈できるようにしようなどとは誰
も思わない言語もあります。


File: emacs-ja.info  Node: Lists-Footnotes, Up: Lists

(1) 【訳注】ここでは、Lispの「リスト」ではなく、単に括弧で括った一塊の
こと。



File: emacs-ja.info, Node: List Commands, Next: Defuns, Prev: Lists, Up: Programs

リストとS式に対するコマンド
===========================

`C-M-f'
     S式を横断して前向きに移動する（`forward-sexp'）。
`C-M-b'
     S式を横断して後向きに移動する（`backward-sexp'）。
`C-M-k'
     前向きにS式をキルする（`kill-sexp'）。
`C-M-DEL'
     後向きにS式をキルする（`backward-kill-sexp'）。
`C-M-u'
     リスト構造を1レベル上がって後向きに移動する（`backward-up-list'）。
`C-M-d'
     リスト構造を1レベル下がって前向きに移動する（`down-list'）。
`C-M-n'
     リストを横断して前向きに移動する（`forward-list'）。
`C-M-p'
     リストを横断して後向きに移動する（`backward-list'）。
`C-M-t'
     式を入れ替える（`transpose-sexps'）。
`C-M-@'
     つぎの式の直後にマークを設定する（`mark-sexp'）。

S式を横断して前向きに移動するには、`C-M-f'（`forward-sexp'）を使います。
ポイントに続く最初の意味ある文字が開き区切り（Lisp では`('、Cでは`('や
`['や`{'）であれば、対応する閉じ区切りのうしろに移動します。シンボル、
文字列、数値を始める文字の場合には、それらを横断してその末尾に移動しま
す。

コマンド`C-M-b'（`backward-sexp'）は、S式を横断して後向きに移動します。
移動の詳しい規則は上記の`C-M-f'と同様ですが、方向は逆です。S式のまえに
接頭辞文字（Lispではシングルクォート、バッククォート、コンマ）がある場
合には、それらも横断します。ほとんどのモードでは、S式コマンドはコメン
トを空白であるかのように飛び越えます。

`C-M-f'や`C-M-b'に引数を指定すると、指定された回数だけ動作を繰り返しま
す。負の引数では、逆向きに移動します。

1つのS式全体をキルするには、`C-M-k'（`kill-sexp'）や`C-M-DEL'
（`backward-kill-sexp'）で行います。`C-M-k'は`C-M-f'で横断するだけの文
字をキルし、`C-M-DEL'は`C-M-b'で横断するだけの文字をキルします。

S式コマンドと同様に、"リストコマンド"はリストを横断しますが、リスト以
外のS式（シンボルや文字列など）は飛び越します。これらのコマンドは、
`C-M-n'（`forward-list'）と`C-M-p'（`backward-list'）です。これらのコ
マンドが便利である主な理由は、（コメントにはリストが何も含まれないのが
普通なので）コメントを無視するからです。

`C-M-n'と`C-M-p'は、可能な限り同じレベルの括弧にとどまります。1つ（あ
るいはNだけ）*上の*レベルに移動するには、`C-M-u'（`backward-up-list'）
を使います。`C-M-u'は、対応の取れていない開き区切りのまえへ後向きに移
動して、1つレベルを上げます。正の引数は反復回数になります。負の引数は、
移動を逆向きにしますが、やはり反復回数です。つまり、前向きに移動して、
1つ以上レベルを上げます。

リスト構造中で*下*のレベルに移動するには、`C-M-d'（`down-list'）を使い
ます。Lispモードでは、`('が唯一の開き区切りなので、このコマンドは`('を
探索するのとほとんど同じです。引数は下がるべき括弧のレベルを指定します。

本当は役に立つのに、何の役に立つのだろうと思われるコマンドが`C-M-t'
（`transpose-sexps'）です。これはポイントのまえにあるS式を、つぎにある
S式を越えて移動するコマンドです。引数は反復回数となり、負の引数では後
向きにS式を移動します（つまり正の引数を指定した`C-M-t'の効果を打ち消せ
る）。引数が0の場合は、何もしないのではなくて、ポイントのあとにあるS式
とマークのあとにあるS式を入れ替えます。

バッファ内でつぎにあるS式の周りにリージョンを設定するには、`C-M-@'
（`mark-sexp'）を使います。このコマンドは、`C-M-f'による移動先にマーク
を設定します。`C-M-@'は、`C-M-f'と同様に引数を取ります。とりわけ、負の
引数は、直前のS式の先頭にマークを設定するのに便利です。

リストおよびS式コマンドが行う構文の解釈は、構文テーブルに完全に支配さ
れます。たとえば、任意の文字を開き区切りとして宣言できて、そうすると開
き括弧のようにふるまうようになります。*Note Syntax::。



File: emacs-ja.info, Node: Defuns, Next: Program Indent, Prev: List Commands, Up: Programs

関数定義（defun）
=================

Emacsでは、トップレベルの括弧でグループ化したものは"関数定義"（defun）
と呼ばれます。この名前は、Lispファイルではトップレベルにあるリストの大
半がスペシャルフォーム`defun'であるという事実に由来します。しかし、そ
の中身が何であろうとも、また、使用プログラム言語が何であろうとも、
Emacs流には、トップレベルの括弧でグループ化されたものはすべて関数定義
（defun）です。たとえば、Cの関数定義の本体は関数定義（defun）です。

`C-M-a'
     現在の関数定義、あるいは、直前の関数定義の先頭に移動する
     （`beginning-of-defun'）。
`C-M-e'
     現在の関数定義、あるいは、つぎの関数定義の末尾に移動する
     （`end-of-defun'）。
`C-M-h'
     現在の関数定義、あるいは、つぎの関数定義を囲むリージョンを設定す
     る（`mark-defun'）。

現在の関数定義の先頭や末尾に移動するコマンドは、`C-M-a'
（`beginning-of-defun'）と`C-M-e'（`end-of-defun'）です。

現在の関数定義を操作したいのであれば、`C-M-h'（`mark-defun'）を使って、
現在の関数定義かつぎの関数定義の先頭にポイントを置き、その末尾にマーク
を設定します。たとえば、関数定義をテキストの別の位置に移動する準備をす
るには、このコマンドを使うのがもっとも簡単な方法です。Cモードでは、
`C-M-h'は`c-mark-function'を実行しますが、`mark-defun'とほとんど同じで
す。違いは、引数宣言、関数名、戻り値の型名と遡って、Cの関数全体をリー
ジョンに含めることです。*Note Marking Objects::。

Emacsは、もっとも左の桁でみつけた任意の開き括弧を関数定義の始まりであ
ると仮定します。したがって、*トップレベルのリストの始まりでない限り、
Lispファイルの中では左端に開き括弧を置いてはいけません。また、関数本体
の始まりを表すのでない限り、Cのコードの行頭に開き中括弧や開き区切りを
置いてはいけません。* もっとも起こりやすい場面は、文字列の途中で、行頭
に開き区切りを入れたい場合です。トラブルを避けるために、開き区切りのま
えにエスケープ文字（CやEmacs Lispでは `\'、その他のLisp方言のいくつか
では`/'）を入れてください。これで文字列の内容が影響を受けることはあり
ません。

大昔のもともとのEmacsでは、関数定義を探すために、より上位レベルの括弧
がなくなるまで遡っていました。この方法では、たとえ小さな関数であっても、
バッファの先頭まで遡って走査することがつねに必要でした。これを高速化す
るために、左端内の任意の`(' （あるいは、開き区切りと宣言された任意の文
字）が関数定義の始まりであると仮定するように、Emacsを変更しました。こ
の発見的手法で、ほとんど正しく処理できて、時間のかかる走査を回避できま
す。しかし、上述の約束事は必要です。



File: emacs-ja.info, Node: Program Indent, Next: Matching, Prev: Defuns, Up: Programs

プログラムの字下げ
==================

正しく字下げされた状態にプログラムを保つ最良の方法は、変更したらEmacs
に字下げをやり直させることです。Emacsには、1行の字下げ、指定された行数
の字下げ、あるいは、括弧でグループ化した内部のすべての行の字下げを行う
コマンドがあります。

* Menu:

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Extra features for indenting C and related modes.
* Custom C Indent::	Controlling indentation style for C and related modes.

Emacsでは、ライブラリ`pp'にLispのプリティプリンタ (1) (*Note Program
Indent-Footnotes::) もあります。このプログラムは、美しく見えるように字
下げを施してLispオブジェクトを清書するプログラムです。


File: emacs-ja.info  Node: Program Indent-Footnotes, Up: Program Indent

(1) 【訳注】プログラムのソースコードを美しく清書するプログラムを一般に
プリティプリンタ（pretty-printer）と呼ぶ。



File: emacs-ja.info, Node: Basic Indent, Next: Multi-line Indent, Up: Program Indent

プログラムの字下げ基本コマンド
------------------------------

`TAB'
     現在行の字下げを調整する。
`C-j'
     RETに続けてTABと打鍵するのと同じ（`newline-and-indent'）。

基本的な字下げコマンドはTABです。直前の数行から判断した正しい字下げを
現在行に施します。TABが実行する関数は、メジャーモードに依存します。た
とえば、Lispモードでは`lisp-indent-line'、Cモードでは`c-indent-line'が
実行されます。これらの関数はそれぞれの言語の構文を解釈しますが、どれも
同じことを行うためのものです。プログラム言語向けメジャーモードにおいて
は、TABは、現在行のどこにポイントがあっても、現在行の先頭に白文字を挿
入したり削除したりします。ポイントが行頭の白文字の中にあったときは、
TABは最後の白文字のうしろにポイントを置きます。そうでなければ、TABを打っ
たときの文字のところに留まります。

ポイント位置にタブを挿入するには、`C-q TAB'を使います。

新たにソースコード行を入力するときには、`C-j'（`newline-and-indent'）
を使ってください。これは、RETに続けてTABを打鍵することと等価です。
`C-j'は、空行を作ってから、その行で適切な字下げを行います。

括弧でグループにまとめたところでは、TABは、2行目以降の行をそれぞれ直前
の行の真下にくるように字下げします。したがって、ある行を非標準的な字下
げにすると、以降の行もその字下げに従うことになります。TABによる標準的
な字下げが、特定の行では美しくないので無視したい場合には、字下げのこの
ようなふるまいが便利です。

（字下げ処理を含めて）Emacsは、左端にある、開き丸括弧、開き中括弧、お
よび、その他の開き区切りを関数の始まりと仮定することを覚えておきましょ
う。たとえ文字列の中であっても、関数の始まりでない開き区切りをけっして
0桁目に置いてはいけません。この制約は字下げコマンドを高速にするために
きわめて重要です。無条件で受け入れてください。これに関してより詳しくは、
*Note Defuns::。



File: emacs-ja.info, Node: Multi-line Indent, Next: Lisp Indent, Prev: Basic Indent, Up: Program Indent

複数行の字下げ
--------------

変更した複数行や、リスト構造中の異なるレベル箇所へ移した複数の行を字下
げし直すには、いくつかのコマンドを利用できます。

`C-M-q'
     リスト内のすべての行を字下げし直す（`indent-sexp'）。
`C-u TAB'
     リストの最初の行が正しい字下げ位置にくるように、リストのすべての
     行を横にそのまま動かす。
`C-M-\'
     リージョン内のすべての行を字下げし直す（`indent-region'）。

1つのリストの中身を字下げし直すには、リストの始まり位置にポイントを置
いて`C-M-q'（Lispモードでは`indent-sexp'、Cモードでは`c-indent-exp'、
他のモードでは適切なコマンドにバインドされている）と打ちます。S式が始
まる行の字下げは変化しません。つまり、リスト内の相対的な字下げが変化す
るだけで、リストの位置は変わりません。リストの開始位置も直すには、
`C-M-q'のまえにTABを打ってください。

リスト内の相対的な字下げは正しいけれども、リストの開始行の字下げが正し
くない場合には、その行に移動して`C-u TAB'と打ちます。TABに数引数を指定
すると、通常どおり現在行を字下げしてから、その行から始まるリスト内のす
べての行にも同じ量の字下げを加えます。いいかえれば、グループ全体をひと
まとめに字下げし直します。ただし、このコマンドは賢くて、文字列の中の行
は移動しませんし、Cモードではプリプロセッサ行を移動しません。

字下げし直す範囲を指定するには、リージョンを使うこともできます。コマン
ド`C-M-\'（`indent-region'）は、ポイントとマークのあいだに行の先頭文字
が含まれるすべての行についてTABを実行します。



File: emacs-ja.info, Node: Lisp Indent, Next: C Indent, Prev: Multi-line Indent, Up: Program Indent

Lispの字下げのカスタマイズ
--------------------------

Lisp式に対する字下げの仕方を、その式から呼ばれる関数と関係付けることが
できます。各Lisp関数に対して、あらかじめ定義された字下げパターンの中か
ら選んだり、Lispプログラムで任意のものを定義したりできます。

字下げの標準パターンは、つぎのとおりです。式の開始行に関数呼び出しの引
数がある場合は、最初の引数の直下に2行目がくるように字下げします。それ
以外の場合は、関数名の直下に2行目がくるように字下げします。続く各行は、
入れ子の深さが同じである行の字下げと同じになります。

変数`lisp-indent-offset'が`nil'以外ならば、式の2行目に対する通常の字下
げパターンを無効にして、式の開始桁からつねに`lisp-indent-offset'だけ字
下げします。

標準パターンが使用されない関数もいくつかあります。名前が`def'で始まる
関数に対しては、式を開始する開き括弧の桁位置に`lisp-body-indent'を加え
た桁位置へ2行目がくるように字下げします。

関数名の属性`lisp-indent-function'を変更すれば、各関数ごとに標準パター
ン以外の字下げを施せます。この属性が取りえる値にはつぎの4つがあります。

`nil'
     属性がないのと同じ。標準の字下げパターンを使用する。
`defun'
     名前が`def'で始まる関数に用いる字下げパターンを使用する。
数値 NUMBER
     関数の最初のNUMBER個の引数を"区別された"引数と呼び、残りを式の"本
     体"と呼ぶ。行の最初の引数が区別された引数かどうかによって、各行の
     字下げが異なる。引数が本体の一部ならば、それを含んだ式を開始する
     開き括弧の桁位置に`lisp-body-indent'を加えた桁位置へ字下げする。
     引数が区別された引数で最初か2番目ならば、`lisp-body-indent'の*2倍
     *を加えた桁位置へ字下げする。引数が区別された引数であっても3番目
     以降ならば、標準パターンを適用する。
シンボルSYMBOL
     SYMBOLは関数名であること。この関数は、当該式の字下げ幅を計算する。
     この関数はつぎの2つの引数を受け取る。STATE 当該行の先頭までを解析
     したときの`parse-partial-sexp' （字下げと入れ子の計算を行うLispの
     基本的な関数）の戻り値。POS 字下げ対象の行の開始位置。この関数は、
     当該行に対する字下げ幅の桁数、あるいは、リストのcarがそのような数
     値であるリストを返す必要がある。数値を返した場合は、括弧の入れ子
     レベルが同じ行に対しては同じ字下げ幅を意味する。リストを返した場
     合は、後続の行に対しては字下げ幅が異なる可能性を意味する。このよ
     うな差異は、`C-M-q'で字下げを計算するときに現れる。数値が返された
     場合、`C-M-q'は、リストの末尾に達するまでは、字下げの再計算を行う
     必要がない。



File: emacs-ja.info, Node: C Indent, Next: Custom C Indent, Prev: Lisp Indent, Up: Program Indent

Cの字下げコマンド
-----------------

ここでは、Cモードとその関連モードにおける字下げコマンドを紹介します。

`C-c C-q'
     現在のトップレベルの関数定義、あるいは、型宣言の集まりを字下げし
     直す（`c-indent-defun'）。

`C-M-q'
     ポイントのうしろにある釣り合った式の中の各行を字下げし直す
     （`c-indent-exp'）。前置引数を指定すると、不正な構文に対する検査
     をせずに、警告メッセージも発しない。

`TAB'
     現在行を字下げし直すか、タブ文字を挿入する（`c-indent-command'）。

     `c-tab-always-indent'が`t'ならば、現在行を字下げし直すだけで、他
     には何もしない。これがデフォルト。

     この変数が`nil'ならば、ポイントが左端か字下げの余白部分にある場合
     に限り、字下げし直す。さもなければ、タブ（あるいは、
     `indent-tabs-mode'が`nil'ならば、等価な個数の空白）を挿入する。

     上記の（`nil'や`t'）以外の値であれば、通常どおり字下げし直す。た
     だし、コメント、文字列、プリプロセッサ指令の内側では、タブを挿入
     する。

`C-u TAB'
     現在行の構文に従って現在行を字下げし直す。なお、現在行から始まる
     式を構成する行も同じ幅だけ字下げし直す。*Note Multi-line Indent::。

カレントバッファ全体を字下げし直すには、`C-x h C-M-\'と打ちます。これ
は、まず、バッファ全体をリージョンとしてから、そのリージョンを字下げし
直します。

カレントブロックを字下げし直すには、`C-M-u C-M-q'と打ちます。これは、
まず、ブロックの先頭に移動してから、ブロック全体を字下げし直します。



File: emacs-ja.info, Node: Custom C Indent, Prev: C Indent, Up: Program Indent

Cの字下げのカスタマイズ
-----------------------

Cモードとその関連モードでは、字下げのカスタマイズには、単純ですが柔軟
性のある機構を用いています。この機構は2段階で動作します。まず、行をそ
の内容と文脈から構文的に分類します。つぎに、構文構成要素の各種類に、カ
スタマイズ可能な字下げのオフセットを対応させます。

* Menu:

* Syntactic Analysis::
* Indentation Calculation::
* Changing Indent Style::
* Syntactic Symbols::
* Variables for C Indent::
* C Indent Styles::



File: emacs-ja.info, Node: Syntactic Analysis, Next: Indentation Calculation, Up: Custom C Indent

第1段階−−構文解析
...................

第1段階では、Cの字下げ機構は、字下げしようとしているまえの行を調べて、
その行を構成する構文上の構成要素を決定します。つまり、"構文シンボル"と
バッファ内の相対位置を要素とする構文構成要素のリストを組み立てます。構
文シンボルには、`statement'（文）や`substatement'（部分文）のように文
法要素を記述するものと、`class-open'（クラス開始）や`knr-argdecl'（K&R
版引数宣言）のように文法要素のあいだの位置を記述するものがあります。

概念的には、Cのコード行は、バッファ中でそれよりまえにあるいずれかの行
に対して必ず相対的に字下げされます。これは構文構成要素リストの中にある
バッファ内位置として表現されます。

以下に例を示します。つぎのコードが、C++モードのバッファに入っていると
しましょう（実際にバッファに行番号が表示されるわけではない）。

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

4行目で（`c-show-syntactic-information'を実行する）`C-c C-s'を打つと、
その行に対する字下げ機構の結果が表示されます。

     ((statement . 32))

これは、その行が文であり、バッファ内位置32に対して相対的に字下げされて
いることを示します。バッファ内位置32は、3行目の`int'の`i'にあたります。
カーソルを3行目に動かして`C-c C-s'と打つと、今度はつぎのように表示され
ます。

     ((defun-block-intro . 28))

この結果は、`int'行がブロックの最初の文であり、バッファ内位置28に対し
て相対的に字下げされていることを示しています。バッファ内位置28は、関数
ヘッダの直後の中括弧にあたります。

別の例を見てみましょう。

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return (val + incr);
     6:     }
     7:   return (val);
     8: }

4行目で`C-c C-s'と打つと、つぎのように表示されます。

     ((substatement-open . 43))

これは、中括弧が部分文のブロックを*始めて*いることを示しています。とこ
ろで、"部分文"とは、`if'、`else'、`while'、`do'、`switch'、`for'、
`try'、`catch'、`finally'、`synchronized'のあとの行を表します。

Cの字下げコマンドにおいては、字下げのために行を構文解析し終えると、変
数`c-syntactic-context'には解析結果を表すリストが入ります。このリスト
の各要素は"構文構成要素"であり、構文シンボルと（省かれるかもしれない）
対応するバッファ内位置のコンスセルです。構文構成要素リストには、複数の
要素が含まれることもあります。また、典型的には、バッファ内位置を持つ要
素は1つだけです。



File: emacs-ja.info, Node: Indentation Calculation, Next: Changing Indent Style, Prev: Syntactic Analysis, Up: Custom C Indent

第2段階−−字下げ計算
.....................

Cの字下げ機構は、構文解析で得られた構文構成要素リスト
`c-syntactic-context'を使って、現在行の字下げ幅を計算します。このリス
トの各要素は、構文シンボルを含むコンスセルですが、バッファ内位置を含ん
でいる場合もあります。

リストの各要素は、最終的な総字下げ量に2つの方法で寄与します。まず、各
構文シンボルに字下げオフセットを対応付ける連想リスト`c-offsets-alist'
から要素を探すために構文シンボルが使われます。各構文構成シンボルのオフ
セットを総字下げ量に加えます。つぎに、リストの要素にバッファ内位置が含
まれていれば、その箇所の桁位置を字下げ量に加えます。これらのオフセット
と桁数をすべて加えることで、総字下げ量が求まります。

以下の例でCの字下げ機構の動作を説明しましょう。

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

3行目にポイントがあって、そこでTABと打って字下げし直すとしましょう。上
（*Note Syntactic Analysis::）でも説明しましたが、その行に対する構文構
成要素リストはつぎのようになります。

     ((defun-block-intro . 28))

ここでは、まず、連想リスト`c-offsets-alist'から`defun-block-intro'を探
すことから始めます。その結果が整数値2であったとしましょう。この値を計
算中の合計（0で初期化されている）に加えて、総字下げ量は空白2文字と更新
されます。

つぎの段階は、バッファ内位置28の桁位置を求めることです。バッファ内位置
28の中括弧は0桁目にあるので、0を計算中の合計に加えます。3行目には構文
要素が1つしかないので、総字下げ量は空白2文字となります。

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return(val + incr);
     6:     }
     7:   return(val);
     8: }

4行目でTABと打つと、同じ過程を繰り返しますが、異なる値を使って計算され
ます。この行に対する構文構成要素リストはつぎのとおりです。

     ((substatement-open . 43))

まずは、シンボル`substatement-open'を連想リスト`c-offsets-alist'から探
します。このシンボルに対するオフセットが2であったとしましょう。この時
点で計算中の合計は2（0 + 2 = 2）です。つぎに、バッファ内位置43（3行目
の`if'の`i'の位置）の桁位置2を加えます。結果として、空白4文字という総
字下げ量が求まります。

行を解析した結果、`c-offsets-alist'に現れない構文シンボルがみつかった
場合、そのシンボルは無視します。しかし、変数`c-strict-syntax-p'が`nil'
以外の値であれば、エラーを報告します。



File: emacs-ja.info, Node: Changing Indent Style, Next: Syntactic Symbols, Prev: Indentation Calculation, Up: Custom C Indent

字下げスタイルの変更
....................

C流のモードの字下げをカスタマイズする方法は2つあります。1つは、あらか
じめ定義されているスタイルから選択する方法です。それぞれのスタイルでは、
各構文シンボルに対するオフセットが定められています。もう1つはより柔軟
な方法で、各構文シンボルの扱い方をカスタマイズできます。定義されている
構文シンボルの一覧については、*Note Syntactic Symbols::。

`M-x c-set-style RET STYLE RET'
     あらかじめ定義されている字下げスタイルSTYLEを選択する。STYLEを入
     力する際に`?'と打てば、定義済みのスタイル一覧を見ることができる。
     スタイルの見栄えを調べるには、そのスタイルを選択して、適当なCのコー
     ドを字下げし直してみる。

`C-c C-o SYMBOL RET OFFSET RET'
     構文シンボルSYMBOLに対する字下げのオフセットを設定する
     （`c-set-offset'）。2番目の引数OFFSETで、字下げのオフセットを指定
     する。

変数`c-offsets-alist'は、各構文シンボルに与える字下げ量を制御します。
この変数の値は連想リストであり、各要素は`(SYNTACTIC-SYMBOL . OFFSET)'
の形をしています。さまざまな構文シンボルに対するオフセットを変えること
で、字下げを細かくカスタマイズできます。連想リストを変更するには、
`c-set-offset'を使います（下記参照）。

`c-offsets-alist'内の各オフセットには、整数、関数名や変数名、あるいは、
変数`c-basic-offset'の値の正負の倍数を表すシンボルである`+'、`-'、`++'、
`--'、`*'、`/'のいずれかを設定できます。したがって、基本の字下げ幅を空
白2文字から3文字に変更したければ、`c-basic-offset'に3を設定します。

オフセットに関数を用いると、字下げのカスタマイズに究極の柔軟性を持たせ
られます。この関数は、構文シンボルとバッファ内位置があればそれを`cons'
したものを引数として呼ばれます。戻り値としては、整数値のオフセットを返
す必要があります。
  
オフセットの値がリストの場合、各要素は、`nil'以外の値がみつかるまで上
の規則にしたがって処理されます。その後、その値は、通常のように、字下げ
の総量に加えられます。これは、主に、複数の関数の結果を組み合わせるため
に使われます。

対話的に設定するにしてもファイル`~/.emacs'で設定するにしても、オフセッ
トを設定するもっとも簡単な方法は、コマンド`C-c C-o'（`c-set-offset'）
を使うことです。最初の引数は構文シンボル、2番目の引数は希望のオフセッ
トです。有効な構文シンボル名とその意味の一覧は、*Note Syntactic
Symbols::。



File: emacs-ja.info, Node: Syntactic Symbols, Next: Variables for C Indent, Prev: Changing Indent Style, Up: Custom C Indent

構文シンボル
............

Cモードや関連するモードの字下げに対して有効な構文シンボルを、構文上の
意味とともに、以下に示します。これらのほとんどのシンボルには、
`c-offsets-alist'でオフセットが与えられています。

`string'
     複数行におよぶ文字列の内側。

`c'
     複数行におよぶCスタイルのブロックコメントの内側。

`defun-open'
     関数定義を開始する中括弧。

`defun-close'
     関数定義を終了する中括弧。

`defun-block-intro'
     トップレベルの関数定義の最初の行。

`class-open'
     クラス定義を開始する中括弧。

`class-close'
     クラス定義を終了する中括弧。

`inline-open'
     クラス内のインラインメソッドを開始する中括弧。

`inline-close'
     クラス内のインラインメソッドを終了する中括弧。

`extern-lang-open'
     外部言語ブロックを開始する中括弧。

`extern-lang-close'
     外部言語ブロックを終了する中括弧。

`func-decl-cont'
     関数定義の引数リストと関数定義の本体を開始する中括弧のあいだの領
     域。ただし、K&R版の関数定義を除く。Cでは、この部分に空文字やコメ
     ント以外は置けない。C++やJavaでは、`throws'宣言などを置ける。

`knr-argdecl-intro'
     K&R版Cの引数宣言の最初の行。

`knr-argdecl'
     K&R版Cの引数宣言の2行目以降。

`topmost-intro'
     最上位の言語構成要素の最初の行。

`topmost-intro-cont'
     最上位の言語構成要素の2行目以降。

`member-init-intro'
     （構造体の）メンバ初期化リストの最初の行。

`member-init-cont'
     （構造体の）メンバ初期化リストの2行目以降。

`inher-intro'
     多重継承リストの最初。

`inher-cont'
     多重継承リストの2行目以降。

`block-open'
     文ブロックを開始する中括弧。

`block-close'
     文ブロックを終了する中括弧。

`brace-list-open'
     `enum'のリストや静的配列の初期化リストを開始する中括弧。

`brace-list-close'
     `enum'のリストや静的配列の初期化リストを終了する中括弧。

`brace-list-intro'
     `enum'のリストや静的配列の初期化リストの最初の行。

`brace-list-entry'
     `enum'のリストや静的配列の初期化リストの2行目以降。

`brace-entry-open'
     行が開き中括弧で始まるときの、`enum'のリストや静的配列の初期化リ
     ストの2行目以降。

`statement'
     通常の文。

`statement-cont'
     文の継続行。

`statement-block-intro'
     新規文ブロックの最初の行。

`statement-case-intro'
     `case'ブロックの最初の行。

`statement-case-open'
     中括弧で始まる`case'ブロックの最初の行。

`inexpr-statement'
     式の内側にある文ブロック。これは、C言語のGNU拡張や、文ブロックを
     引数としてとるPikeの特殊関数に用いる。

`inexpr-class'
     式の内側にあるクラス定義。これは、Javaの無名クラスや無名配列の初
     期化式に用いる。

`substatement'
     `if'、`while'、`for'、`do'、`else'の直後の最初の行

`substatement-open'
     substatementのブロックを開始する中括弧。

`case-label'
     `case'または`default'ラベルを表す。

`access-label'
     C++のアクセス指定子`private'、`protected'、`public'を表す。

`label'
     通常のラベル。

`do-while-closure'
     `do'-`while'文の`while'。

`else-clause'
     `if'-`else'文の`else'。

`catch-clause'
     C++やJavaの`try'...`catch'構成の`catch'行や`finally'行。

`comment-intro'
     コメントの導入部分だけを含んだ行。

`arglist-intro'
     引数リストの最初の行。

`arglist-cont'
     引数リストを開始する括弧の行に引数がない場合、引数リストの2行目以
     降。

`arglist-cont-nonempty'
     引数リストを開始する括弧の行に少なくとも1つの引数がある場合、引数
     リストの2行目以降。

`arglist-close'
     引数リストを終了する括弧。

`stream-op'
     ストリーム演算子を用いた式が継続する行。

`inclass'
     クラス定義の内側に入れ子になった言語構成要素。字下げは、クラス定
     義の開き中括弧に相対である。

`inextern-lang'
     外部言語ブロックの内側に入れ子になった言語構成要素。

`inexpr-statement'
     式の内側の文ブロックの最初の行。これは、構文`({ ... })'を使うCに
     対するGCC拡張に用いる。文ブロックを引数としてとるPikeの特殊関数に
     も用いる。

`inexpr-class'
     式の内側のクラス定義の最初の行。これは、Javaの無名クラスや無名配
     列の初期化式に用いる。

`cpp-macro'
     cppマクロの開始。

`friend'
     C++の`friend'宣言。

`objc-method-intro'
     Objective-Cのメソッド定義の最初の行。

`objc-method-args-cont'
     Objective-Cのメソッド定義を継続する行。

`objc-method-call-cont'
     Objective-Cのメソッド呼び出しを継続する行。

`inlambda'
     `inclass'と同様だが、ラムダ（つまり、無名）関数の内側に用いる。
     Pikeのみで用いる。

`lambda-intro-cont'
     キーワード`lambda'と関数本体のあいだの、ラムダ関数のヘッダーの継
     続行。Pikeのみで用いる。



File: emacs-ja.info, Node: Variables for C Indent, Next: C Indent Styles, Prev: Syntactic Symbols, Up: Custom C Indent

Cの字下げのための変数
.....................

本節では、Cモードとその関連モードの字下げ動作を制御する、モードに固有
な変数について説明します。

`c-offsets-alist'
     構文シンボルとその字下げオフセットの連想リスト。このリストに直接
     に値を設定するのではなく、`c-set-offset'を使うこと。詳細について
     は、*Note Changing Indent Style::。

`c-style-alist'
     字下げスタイルを定義している変数。下記参照。

`c-basic-offset'
     `c-offsets-alist'の中で、シンボル`+'や`-'が用いるオフセットの基本
     量。

`c-special-indent-hook'
     ユーザー定義の特別な字下げ調整用のフック。このフックは、Cモードや
     その関連モードが行の字下げを終えたあとに呼ばれる。

変数`c-style-alist'は、あらかじめ定義された字下げスタイルを保持します。
各要素は`(NAME VARIABLE-SETTING...)'の形をしていて、NAMEはスタイル名で
す。また、各VARIABLE-SETTINGは、`(VARIABLE . VALUE)'の形をしています。
VARIABLEには、Cモードが使用するカスタマイズ用変数の1つを指定します。
VALUEは、選択されたスタイルが使われるときのVARIABLEの値です。

VARIABLEが`c-offsets-alist'である場合は、特殊なケースです。
`c-offsets-alist'の値をVALUEの値で置き換えるのではなく、
`c-offsets-alist'の値の先頭にVALUEを追加します。したがって、VALUEにす
べての構文シンボルを設定する必要はありません。デフォルトと異なる構文シ
ンボルだけを単に設定すればよいのです。

コメントだけを含んだ行の字下げも、変数`c-comment-only-line-offset' 
（*Note Comments in C::）に影響されます。



File: emacs-ja.info, Node: C Indent Styles, Prev: Variables for C Indent, Up: Custom C Indent

Cの字下げスタイル
.................

"Cスタイル"とは、カスタマイズされた字下げスタイルの集合です。Emacsには、
Cモードや関連するモードのためにあらかじめ定義された、`gnu'、`k&r'、
`bsd'、`stroustrup'、`linux'、`python'、`java'、`whitesmith'、
`ellemtel'、`cc-mode'といった字下げスタイルがあります。デフォルトのス
タイルは`gnu'です。

望みのスタイルを選択するには、コマンド`M-x c-set-style'を使います。引
数としてスタイル名を指定します（Cスタイル名では大文字小文字は区別しな
い）。選択したスタイルは新たに訪問したバッファにだけ影響し、すでに編集
中のバッファには影響しません。さまざまなメジャーモードのスタイルを指定
するために変数`c-default-style'を設定することもできます。その値は連想
リストである必要があり、その各要素は、1つのメジャーモードとそのモード
で使う字下げスタイルを指定します。たとえば、

     (setq c-default-style
           '((java-mode . "java") (other . "gnu")))

は、Javaモードには対しては選択を明示し、他のC流モードには`gnu'をデフォ
ルトとします。

Cの字下げスタイルを新たに定義するには、関数`c-add-style'を呼びます。

     (c-add-style NAME VALUES USE-NOW)

ここで、NAMEは新しいスタイルの名前（文字列）、VALUESは要素が`(VARIABLE
. VALUE)'の形をした連想リストです。VARIABLEには、*Note Variables for C
Indent::に書かれているものを指定してください。

USE-NOWが`nil'以外ならば、新しいスタイルの定義後すぐにそれに切り替えま
す。



File: emacs-ja.info, Node: Matching, Next: Comments, Prev: Program Indent, Up: Programs

対応している括弧の自動表示
==========================

Emacsの括弧の対応付け機能は、テキスト中でどのように括弧が対応している
か自動的に表示するよう設計されています。閉じ区切りである自己挿入文字を
打つと、それに対応する開き区切りが画面上にあれば、その箇所にほんのしば
らくカーソルが移動します。画面上になければ、エコー領域にその箇所の近く
にある文字列を表示します。いずれにしても、1つのまとまりが閉じたことが
判ります。

Lispでは、括弧だけに対して自動的な対応付けを行います。Cでは、中括弧や
角括弧も対象となります。Emacsは、メジャーモードが設定する構文テーブル
に基づいて、どの文字が対応関係にある区切りであるか判定します。*Note
Syntax::。

`[x)'のように、開き区切りと閉じ区切りが対応しない場合、エコー領域に警
告メッセージを表示します。正しい対応関係は構文テーブルで指定します。

括弧の対応表示を制御する変数は3つあります。`blink-maching-paren'は、対
応表示機能をオンまたはオフにします。`nil'を設定すると対応表示機能はオ
フになりますが、デフォルトは`t'であり、対応表示を行います。
`blink-matching-delay'は、対応表示のために待つ秒数を指定します。デフォ
ルトは1秒ですが、システムによっては何分の1秒のほうが便利かもしれません。
`blink-matching-paren-distance'は、対応している開き区切りをみつけるた
めに、何文字分まで戻って探索するか指定します。その範囲内で対応するもの
がみつからなければ、走査をやめて何も表示しません。これは、存在しもしな
い対応する区切りを探すことに時間を浪費するのを防ぐためです。デフォルト
は12,000です。

Xウィンドウシステムを使用している場合、対応括弧表示（show-paren）モー
ドにすれば、より強力な括弧の対応表示を利用できます。このモードは、通常
の対応表示をオフにするかわりに、対応する括弧同士を示すために強調表示を
行います。ポイントが閉じ括弧の直後にあるときには、閉じ括弧とそれに対応
する開き括弧の両方を強調表示します。ポイントが開き括弧の直前にあるとき
には、対応する閉じ括弧を強調表示します。（ポイントの直後に開き括弧があ
るときには、カーソルが開き括弧に重ねて表示されるので、開き括弧を強調表
示する必要はない。）このモードをオン／オフするには、コマンド`M-x
show-paren-mode'を使います。



File: emacs-ja.info, Node: Comments, Next: Balanced Editing, Prev: Matching, Up: Programs

コメントの操作
==============

コメントはプログラミングの重要な部分なので、Emacsにはコメントの編集や
挿入を行うための特別なコマンドがあります。

* Menu:

* Comment Commands::
* Multi-Line Comments::
* Options for Comments::



File: emacs-ja.info, Node: Comment Commands, Next: Multi-Line Comments, Up: Comments

コメント用コマンド
------------------


コメント用コマンドはコメントの挿入、削除、および位置揃えを行います。

`M-;'
     コメントの挿入／位置揃えを行う（`indent-for-comment'）。
`C-x ;'
     コメントの桁位置を設定する（`set-comment-column'）。
`C-u - C-x ;'
     現在行のコメントをキルする（`kill-comment'）。
`C-M-j'
     RETに続けて、コメントの挿入／位置揃えを行う
     （`indent-new-comment-line'）。
`M-x comment-region'
     リージョン内の各行に対して、コメント区切りを追加／削除する。

コメントを挿入するコマンドは`M-;'（`indent-for-comment'）です。行にコ
メントがなければ、新規にコメントを作成して、"コメント桁位置"と呼ばれる
特定の桁に置きます。コメントを作成する際には、Emacsが正しいと信じるコ
メント開始文字列（`comment-start'の値。下記参照）を挿入します。ポイン
トはその文字列の直後に置かれます。コードのテキストがコメント桁位置を越
えているときには、適当な境界に字下げします（通常は少なくとも空白1文字）。
メジャーモードでコメント終了文字列が指定されていれば、構文を正しく保つ
ために、ポイントの直後にその文字列を挿入します。

`M-;'は、既存のコメントを位置揃えするためにも使えます。行にコメント開
始文字列がすでに含まれていれば、その文字列の直後にポイントを移動してか
ら、適切な位置に字下げします。例外として、0桁目から始まるコメントは動
かしません。

特定の文脈における、ある種のコメントの字下げには特殊な規則を持つメジャー
モードもあります。たとえば、Lispのコードでは、セミコロン2つで始まるコ
メントは、コメント桁位置に揃えるのでなく、コードであるかのように字下げ
されます。また、セミコロン3つで始まるコメントは左端に置くと仮定されま
す。Emacsはこれらの慣習を理解していて、セミコロン2つのコメントはTABで
字下げし、セミコロン3つのコメントは字下げをまったく変更しません。

     ;; This function is just an example
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;; And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

Cのコードでは、コメントのまえに白文字しかない場合には、そのコメントを
コードのように字下げします。

既存のコメントの位置が適切に揃えられている場合でも、コメント開始直後の
位置にすぐに移動するには`M-;'が便利です。

`C-u - C-x ;'（`kill-comment'）は、現在行にコメントがあれば、それをキ
ルします。コメント開始文字列のまえにある字下げもキルします。コメントと
思われるものが何もなければ、何もしません。他の行にコメントを再挿入する
には、その行の末尾に移動してから`C-y'と打って、さらに、位置を再調整す
るために`M-;'と打ちます。`C-u - C-x ;'はひとまとまりのキーではなく、負
の引数を指定した`C-x ;'（`set-comment-column'）であることに注意しましょ
う。このコマンドは、負の引数を受け取ると、`kill-comment'を呼ぶようにプ
ログラムされています。`kill-comment'は、望むならばキーに直接バインドで
きる通常のコマンドです。



File: emacs-ja.info, Node: Multi-Line Comments, Next: Options for Comments, Prev: Comment Commands, Up: Comments

複数行にわたるコメント
----------------------

コメントを入力していて別の行に継続したければ、コマンド `C-M-j'
（`indent-new-comment-line'）を利用できます。このコマンドは、入力中の
コメントを終了して、そのつぎに空行を作り、直前のコメントの直下にくるよ
うに字下げして新たなコメントを始めます。自動詰め込み（auto-fill）モー
ドがオンならば、コメントを入力中に詰め込み桁を越えると、同様にコメント
はつぎの行に継続されます。`C-M-j'を打ったときにポイントが行末になけれ
ば、ポイント位置から行末までのテキストは新たなコメントの一部になります。

既存の行をコメントにするには、コマンド`M-x comment-region'を使います。
このコマンドは、リージョン内で始まる各行にコメント区切り文字列を加えて
コメントにします。負の引数を指定すると逆の操作、つまり、コメント区切り
文字列を削除します。

正の引数を指定すると、`comment-region'は、追加するコメント開始文字列の
最後の文字を重複させます。つまり、引数は、その文字を何回重複させるかを
示します。たとえば、Lispモードで`C-u 2 M-x commment-region'とすると、
各行に`;;'を付加します。コメント区切り文字を重複させるのは、コメントに
注意を引き付けるためです。また、コメントの字下げにも影響します。Lispで
は、適切な字下げになるように、関数定義（defun）のあいだでは引数として3
を、関数定義の内側では引数として2を指定すべきです。

変数`comment-padding'は、`comment-region'がコメント区切りと各行のもと
のテキストとのあいだに挿入する空白の個数を指定します。デフォルトは1で
す。



File: emacs-ja.info, Node: Options for Comments, Prev: Multi-Line Comments, Up: Comments

コメントを制御するオプション
----------------------------

コメント桁位置は、変数`comment-column'に入っています。この変数には明示
的に値を設定できます。あるいは、コマンド `C-x ;'（`set-comment-column'）
を使って、ポイント位置の桁をコメント桁位置として設定できます。`C-u C-x
;'は、バッファ内で現在行よりまえにある最後のコメントの桁位置をコメント
桁位置としてから、`M-;'を行って現在行のコメントをまえのコメントの直下
にくるように位置を揃えます。`C-u - C-x ;'は、前述のように関数
`kill-comment'を実行することに注意してください。

変数`comment-column'は、バッファごとの変数です。つまり、通常の方法で設
定すると、カレントバッファだけに影響しますが、`setq-default'でデフォル
ト値を変更できます。*Note Locals::。多くのメジャーモードでは、この変数
をカレントバッファ用に初期化します。

コメント用コマンドは、変数`comment-start-skip'の正規表現に基づいてコメ
ントを認識します。この正規表現が空文字列には一致しないようにしてくださ
い。厳密にはコメント開始文字列よりも長く一致するかもしれません。たとえ
ば、Cモードではこの変数の値は`"/\\*+ *"'ですが、これは `/*'のうしろの
余分なアスタリスクと空白に一致します。（Lispの構文では、文字列中に`\'
を含めるために`\\'とする必要がある。この`\'は、最初のアスタリスクの正
規表現における特別な意味を抑制するために必要。*Note Regexps::。）

コメント用コマンドで新たなコメントを作ると、
コメントを始めるために`comment-start'の値を挿入します。
また、ポイントの直後には`comment-end'の値が挿入されて、
これから入力するテキストのあとに続くことになります。
Cモードでは、`comment-start'の値は`"/* "'、
`comment-end'の値は`" */"'です。

変数`comment-multi-line'は、`C-M-j'（`indent-new-comment-line'）がコメ
ントの内側で使われたときの動作を制御します。`comment-multi-line'が
`nil'（通常の設定）ならば、現在行のコメントを終了し、新たなコメントを
つぎの行から始めます。`comment-multi-line'が`nil'以外ならば、現在行と
同じコメントが継続されます。つまり、現在行のコメントを終えず、新たな行
にも開始文字列を挿入しません。複数行にわたるコメントを許す言語では、こ
の変数に設定する値は好みの問題です。

変数`comment-indent-function'には、新たに挿入したコメントの字下げや既
存のコメントに桁を揃えるための字下げを計算する関数を設定する必要があり
ます。この変数には、メジャーモードごとに異なった関数が設定されます。こ
の関数は引数なしで呼ばれますが、コメントがあるときにはその開始位置にポ
イントを置いて、新規コメントの挿入時には行末にポイントを置いて呼ばれま
す。戻り値は、コメントを始めるべき桁位置です。たとえば、Lispモードでは、
この字下げ用フック関数は、既存のコメントのセミコロンの個数とまえの行の
コードに基づいて計算を行います。



File: emacs-ja.info, Node: Balanced Editing, Next: Symbol Completion, Prev: Comments, Up: Programs

括弧の対応を保った編集
======================

`M-('
     つぎの（1つ以上の）S式を括弧で囲む（`insert-parentheses'）。
`M-)'
     つぎの閉じ括弧のうしろへ移動してから字下げし直す
     （`move-past-close-and-reindent'）。

コマンド`M-('（`insert-parenthesis'）と`M-)'
（`move-past-close-and-reindent'）は、括弧の対応をつねに保ったまま編集
するために設計されました。`M-('は一対の括弧を挿入します。引数がなけれ
ば`()'を挿入しますが、引数を指定すると、つぎのその個数分のS式を括弧で
囲みます。ポイントは開き括弧の直後に置かれます。コマンド`M-)'は、閉じ
括弧のまえにある字下げを削除しながら閉じ括弧のうしろにポイントを移動し、
そのあと、`C-j'で字下げします。

たとえば、`( F O O )'と打つかわりに`M-( F O O'と打てば、カーソルが閉じ
括弧のまえにくることを除けば同じ効果を得られます。

`M-('は、直前の文字の構文クラスによっては、開き括弧のまえに空白を1個挿
入することがあります。これを禁止したければ、`parens-require-spaces'に
`nil'を設定してください。



File: emacs-ja.info, Node: Symbol Completion, Next: Which Function, Prev: Balanced Editing, Up: Programs

シンボル名の補完
================

通常、補完はミニバッファで行われます。しかし、ある種の補完は任意のバッ
ファで利用できます。それはシンボル名に対する補完です。

`M-TAB'は、ポイント直前の部分的なシンボルを、意味のあるシンボル名の集
合から補完するコマンドを実行します。部分的な名前から補完された追加文字
はポイント位置に挿入されます。

バッファ内の部分的な名前に対して、複数個の補完候補があり、しかも、追加
できる共通部分がない場合には、補完候補一覧を別のウィンドウに表示します。

ほとんどのプログラム言語向けメジャーモードでは、`M-TAB'はコマンド
`complete-symbol'を実行します。この関数には、2種類の補完機能があります。
通常、このコマンドはタグテーブル（*Note Tags::）に基づいて補完を行いま
す。 数引数（値は無関係）を指定すると、当該言語のinfoファイルの索引に
並べられた名前を対象として補完を行います。すなわち、プログラム中で定義
されたシンボル名を補完するには引数なしで`M-TAB'を使い、標準ライブラリ
関数の名前を補完するには`C-u M-TAB'を使います。もちろん、infoに基づい
た補完は、使用言語の標準ライブラリ関数に対するinfoファイルがあり、かつ、
それがインストールされている場合にだけ動作します。

Emacs Lispモードでは、補完対象の名前空間は、関数定義、値や属性を持つ
Emacs中の特殊なシンボルから成ります。しかし、部分的なシンボルの直前に
開き括弧があれば、関数定義を持つシンボルだけを補完対象とします。これを
実現するコマンドは`lisp-complete-symbol'です。

テキスト（text）モードとその関連モードでは、`M-TAB'はスペルチェッカの
辞書に基づいた補完を行います。*Note Spelling::。



File: emacs-ja.info, Node: Which Function, Next: Documentation, Prev: Symbol Completion, Up: Programs

関数名表示モード（which-functionモード）
========================================

関数名表示（which-function）モードは、バッファ内を動き廻るに従って現在
の関数名をモード行に表示するマイナモードです。

関数名表示（which-function）モードをオン（あるいはオフ）にするには、コ
マンド`M-x which-function-mode'を使います。このコマンドはグローバルで
す。つまり、既存のバッファでもこれから作るバッファでも、すべてのバッファ
に通用します。しかし、`which-func-modes'の値で指定された特定のメジャー
モードでのみ効果があります。（`which-func-modes'のデフォルト値は`t'で
あり、関数名表示（which-function）モードの支援方法を知っているすべての
メジャーモードに適用されることを意味する。具体的には、imenuを使えるメ
ジャーモード。）



File: emacs-ja.info, Node: Documentation, Next: Change Log, Prev: Which Function, Up: Programs

説明文書用コマンド
==================

Emacsで実行するLispコードを編集するときには、関数や変数の説明文字列を
表示するコマンド、`C-h f'（`describe-function'）や`C-h v'
（`describe-variable'）を利用できます。これらのコマンドは、説明文字列
を表示したい関数や変数の名前をミニバッファから読み取り、ウィンドウに説
明文字列を表示します。

たいへん便利なことに、これらのコマンドはポイント近傍のコードから、デフォ
ルトの引数を選択します。`C-h f'は、ポイントを含むもっとも内側のリスト
で呼ばれる関数をデフォルトとします。`C-h v'は、ポイントの周辺にあるか
隣接するシンボル名をデフォルトとします。

Emacs Lispコードに対しては、eldocモードも使えます。このマイナモードは、
ポイント位置で呼び出されている関数の引数リストを、たえずエコー領域に表
示します。（いいかえれば、ポイントを含む関数呼び出しを探し、その関数の
引数リストを表示する。）eldocマイナモードは、Emacs LispモードとLisp対
話（lisp-interaction）モードだけに適用できます。この機能をオン／オフす
るには、コマンド`M-x eldoc-mode'を使います。

C、Lisp、その他言語のシンボルのinfo文書を見るには`C-h C-i'
（`info-lookup-symbol'）を使います。ミニバッファでシンボルを指定します。
デフォルトは、バッファ中のポイント位置にあるシンボルです。シンボルに対
する説明文書を探す場所、つまり、どのinfoファイルのどの索引を探せばよい
かは、メジャーモードが決定します。また、ファイル名に対する説明文書を探
すには`M-x info-lookup-file'を使います。

`M-x manual-entry'コマンドを使って、オペレーティングシステムのコマンド、
ライブラリ関数、システムコールの『マニュアルページ』を読むことができま
す。このコマンドは、マニュアルページを清書するために`man'プログラムを
実行します。システムが許せば非同期に実行するので、マニュアルページが清
書されるまで、編集を継続できます（MS-DOSやMS-Windows 3.xでは、非同期的
なサブプロセスを実行できない。このため、これらのシステムでは`man'の終
了をEmacsが待つあいだは編集できない）。結果は、`*Man TOPIC*'という名前
のバッファに入ります。これらのバッファではマン（man）モードと呼ばれる
特別なメジャーモードが使われ、スクロールや他のマニュアルページの調査を
容易に行えます。より詳しくは、マニュアルページ用のバッファで、`C-h m'
と打ってください。

長いマニュアルページでは、適切なフェイスを設定するにはとても時間がかか
ります。さまざまなフォントや表示色を表示できる環境であれば、デフォルト
でマニュアルページにフェイスを用いるようになっています。変数
`Man-fontify-manpage-flag'に`nil'を設定すれば、マニュアルページにおけ
るフェイスの使用をオフにできます。

他の方法でマニュアルページのテキストをEmacsバッファに挿入した場合、
`M-x manual-entry'と同じ変換を施すには、そこで`M-x
Man-fontify-manpage'コマンドを実行します。

GNUプロジェクトでは最終的に、ほとんどのマニュアルページをinfoで閲覧可
能なよりよく構成されたマニュアルに置き換えることを望んでいます。*Note
Misc Help::。この作業は、ほんの一部が完了しただけなので、まだマニュア
ルページを読めることは有益です。



File: emacs-ja.info, Node: Change Log, Next: Tags, Prev: Documentation, Up: Programs

変更記録
========

コマンド`C-x 4 a'は、編集中のファイルに対する新たな項目を変更記録ファ
イルに追加します（`add-change-log-entry-other-window'）。

変更記録ファイルは、プログラムを変更した日付やその理由を時間順に記録し
たもので、個々の変更を記述した項目の並びから成ります。通常は、編集して
いるファイルと同じディレクトリ、あるいは、その親ディレクトリに置いた
`ChangeLog'と呼ばれるファイルに保存されています。1つの`ChangeLog'ファ
イルで、このファイルを置いたディレクトリやそのサブディレクトリに置いた
全ファイルの変更を記録できます。

変更記録項目は、名前、（`user-mail-address'から得られた）電子メイルア
ドレス、現在の日付と時刻から成るヘッダ行で始まります。変更記録内の各行
はヘッダ行を除いて、つねに空白かタブで始まります。1つの項目は"小項目"
から構成され、各小項目は空白と星印で始まる行で始まります。以下は、1993
年5月付けの2つの項目で、それぞれに2つの小項目があります。

     1993-05-25  Richard Stallman  <rms@gnu.org>

             * man.el: Rename symbols `man-*' to `Man-*'.
             (manual-entry): Make prompt string clearer.

             * simple.el (blink-matching-paren-distance):
             Change default to 12,000.

     1993-05-24  Richard Stallman  <rms@gnu.org>

             * vc.el (minor-mode-map-alist): Don't use it if it's void.
             (vc-cancel-version): Doc fix.

（Emacsの以前の版では、日付の形式が異なる。）

1つの項目で複数の変更を記述できます。各変更について、それぞれの小項目
を用意しなくてはいけません。通常、小項目のあいだには空行がなくてはいけ
ません。小項目が関連している（場所は異なるが同じ変更の一部分の）場合に
は、それらのあいだには空行を入れずに一塊にしておきます。上記の2番目の
項目には、このようにしてまとめた2つの小項目が含まれています。

`C-x 4 a'は、変更記録ファイルを訪問して、最新の項目が今日の日付で当人
の名前のものでなければ、新たに項目を作成します。また、現在のファイルに
対する新たな小項目も作成します。多くの言語に対して、変更された関数名や
その他のオブジェクトを推測することもできます。

変更記録ファイルは、変更記録（change-log）モードで訪問します。このメ
ジャーモードでは、（空行で区切らない）ひとまとまりの小項目群を段落とし
て扱い、各項目をページとして扱います。これにより項目の編集が容易になり
ます。`C-j'や自動詰め込みにより、新たな行は直前の行と同様に字下げされ
ます。これは項目内容を入力するのに便利です。

プログラムの変更を掌握し、変更記録を維持する他の手段としては、版管理
（バージョンコントロール）システムがあります。*Note Log Buffer::。



File: emacs-ja.info, Node: Tags, Next: Emerge, Prev: Change Log, Up: Programs

タグテーブル
============

"タグテーブル"とは、複数のファイルで構成されるプログラムが、どのように
各ファイルに分割されているのか記述したものです。これは、プログラムを構
成するファイル名、そのファイルに入っている関数の名前（または、名前の付
いた別の単位）やファイル内の位置の一覧です。こうして関連するファイルを
まとめておけば、全ファイルを対象とした探索や置換をコマンド1つで行えま
す。また、関数名とその位置を記録してあるので、関数がどのファイルに入っ
ているか調べて関数定義をみつけだす`M-.'のようなコマンドを実現できます。

タグテーブルは、"タグテーブルファイル"と呼ばれるファイルに格納されます。
このファイルの慣習的な名前は`TAGS'です。

タグテーブルの各項目は、タグ名、タグが（暗黙に）定義されているファイル
の名前、そして、ファイル中でタグが定義されている位置を記録しています。

もとのプログラムファイルから、どんな名前がタグテーブルに記録されるかは、
プログラム言語によって異なります。一般的には、すべての関数やサブルーチ
ンを含み、大域変数、データ型、あると便利なその他の情報などを含むことも
あります。記録された個々の名前を"タグ"と呼びます。

* Menu:

* Tag Syntax::		Tag syntax for various types of code and text files.  
* Create Tags Table::	Creating a tags table with `etags'.
* Select Tags Table::	How to visit a tags table.
* Find Tag::		Commands to find the definition of a specific tag. 
* Tags Search::		Using a tags table for searching and replacing.
* List Tags::		Listing and finding tags defined in a file.



File: emacs-ja.info, Node: Tag Syntax, Next: Create Tags Table, Up: Tags

ソースファイルのタグ構文
------------------------

ここでは、広く一般に使われている言語に対するタグ構文の定義を紹介します。

   * Cのコードでは、関数やtypedefで定義される型はタグであり、`struct'、
     `union'、`enum'の定義もやはりタグである。また、タグテーブルを作成
     するときにオプション`--no-defines'を指定しなければ、`#define'によ
     るマクロ定義や`enum'の定数もタグとして扱う。同様に、大域変数も
     `--no-globals'を指定しない限りタグになる。`--no-globals'と
     `--no-defines'を指定すると、タグテーブルファイルはかなり小さくな
     る。

   * C++のコードでは、Cのコードのタグ構成要素に加えて、メンバ関数もタ
     グとして認識される。`--members'オプションを指定すれば、メンバ変数
     もタグになる。クラス内の変数と関数に対するタグには、それぞれ、
     `CLASS::VARIABLE'、`CLASS::FUNCTION'と名前が付く。

   * Javaのコードでは、C++のタグ構成要素に加えて、`extends'と
     `implements'に現れる名前もタグとして含む。クラス内の変数と関数に
     対するタグには、それぞれ、`CLASS.VARIABLE'、`CLASS.FUNCTION'と名
     前が付く。

   * LaTeXのテキストでは、`\chapter'、`\section'、`\subsection'、
     `\subsubsection'、`\eqno'、`\label'、`\ref'、`\cite'、`\bibitem'、
     `\part'、`\appendix'、`\entry'、`\index'のコマンドの引数がタグに
     なる。

     その他のLaTeXコマンドでも、`etags'を起動するまえに、環境変数
     `TEXTAGS'にそれらのコマンドを指定しておけばタグの対象になる。この
     環境変数の値は、コマンド名をコロンで区切った並び。たとえば、
     （bourneシェルでは）

          TEXTAGS="def:newcommand:newenvironment"
          export TEXTAGS

     とすると、`\def'、`\newcommand'、`\newenvironment'のコマンドの引
     数もタグの対象になる。

   * Lispコードでは、`defun'で定義した関数、`defvar'や`defconst'で定義
     した変数、および、一般に0桁目から`(def'で始まる任意の式の最初の引
     数がタグ。

   * Schemeコードでは、`def'で定義されるものと、名前が`def'で始まるも
     のがタグに含まれる。また、ファイル内のトップレベルで`set!'を使っ
     て値が設定される変数もタグ。

他にも以下の言語で使えます。

   * アセンブリコードでは、行の先頭から始まりコロンが続くラベルはタグ。

   * BisonやYaccの入力ファイルでは、各構文規則で定義する非終端記号をタ
     グとする。ファイル内のCコードの部分に対しては、Cのコードとしてタ
     グの解析を行う。

   * Cobolでは、段落名、すなわち、8桁目から始まりピリオドが続く任意の
     単語がタグ。

   * Erlangコードでは、ファイル内で定義された関数、レコード、マクロが
     タグ。

   * Fortranコードでは、関数、サブルーチン、ブロックデータがタグ。

   * Objective-Cコードでは、クラス、クラスカテゴリ、メソッド、プロトコ
     ルの定義がタグ。

   * Pascalコードでは、関数と手続きがタグ。

   * Perlコードでは、キーワード`sub'で定義される手続きがタグ。

   * Postscriptコードでは、関数（演算子）がタグ。

   * Prologコードでは、左端に現れる名前がタグ。

正規表現に基づいてタグを生成する方法（*Note Create Tags Table::）もあ
るので、上記以外の形式や言語を扱うこともできます。



File: emacs-ja.info, Node: Create Tags Table, Next: Select Tags Table, Prev: Tag Syntax, Up: Tags

タグテーブルの作成
------------------

タグテーブルファイルを作成するには、`etags'プログラムを使います。
`etags'は、数種類の言語について、構文を解析しタグを取り出すことができ
ます。*Note Tag Syntax::。つぎのように実行します。

     etags INPUTFILES...

`etags'は指定されたファイルを読み、カレント作業ディレクトリの`TAGS'と
いう名前のファイルにタグテーブルを書き出します。`etags'は、ファイル名
とその内容から自動的に使用言語を識別します。後述の`--language=NAME'オ
プションで、言語を明示することもできます。

ファイルを変更するなどしてタグテーブルの内容が古くなった場合、テーブル
を更新するには、最初にタグテーブルを作成した手順を繰り返します。頻繁に
更新する必要はありません。

タグテーブルに記録できなかったり、誤ったファイルを記録してしまった場合、
Emacsはタグの定義をみつけることはできません。しかし、（タグの定義を含
んだファイルを多少編集するなどしたために）タグテーブルに記録された位置
が多少ズレている程度ならば、タグをみつけるのに通常より少し時間がかかる
だけです。記録された位置が大幅に狂っていたとしても、Emacsはタグをみつ
けることができますが、そのためにファイル全体を調べなくてはなりません。

ですから、新しいタグを定義したとき、タグの定義を別のファイルに移動した
とき、ファイルを相当変更したときには、タグテーブルの更新が必要です。し
かし、ファイルを編集するつどタグテーブルを更新する必要はありませんし、
毎日更新する必要すらないでしょう。

タグテーブルに別のタグテーブルを取り込むこともできます。取り込むタグファ
イル名をオプション`--include=FILE'で指定してタグファイルを作成します。
このように作成したタグファイルには、指定したソースファイルに加えて、取
り込んだタグファイルに記録されていたファイルも含まれます。

`etags'を実行するときに相対ファイル名でソースファイルを指定すると、タ
グファイルには、タグファイルを書き出したときのディレクトリを基準にした
ファイル名が記録されます。こうした場合、タグファイルとソースファイルを
含んだディレクトリ木構造全体を移動することができ、しかも、タグファイル
はソースファイルを正しく指し続けます。

`etags'の引数として絶対ファイル名を指定すると、タグファイルには絶対ファ
イル名が記録されます。こうした場合、ソースファイルが同じ場所にある限り、
タグファイルを移動してもタグファイルは同じファイルを指し続けます。絶対
ファイル名は、`/'、あるいは、MS-DOSとMS-Windowsでは`DEVICE:/'で始まり
ます。

非常に多数のファイルからタグテーブルを作成する場合、コマンド行の長さを
制限しているシステムもあるので、ファイル名をコマンドラインで指定すると
きに問題が起こる可能性があります。この制限を回避するもっとも単純な方法
は、つぎのように、ファイル名を指定する位置にダッシュを打って、`etags'
に標準入力からファイル名を読み込ませることです。

     find . -name "*.[chCH]" -print | etags -

オプション`--language=NAME'を使えば、言語を明示的に指定できます。この
オプションはファイル名と混ぜていくつでも使用できます。それぞれ、あとに
続くファイル名に適用されます。`--language=auto'を指定すると、`etags'は
ファイル名とその内容からふたたび使用言語を推測します。
`--language=none'を指定すれば、言語に依存した処理をいっさい行わないよ
うになります。すると、`etags'は正規表現による一致だけに基づいてタグを
認識します。`etags'が知っている言語と、言語を推測するファイル名規則を
表示するには、`etags --help'を指定します。

`--regex'オプションは、正規表現による一致に基づいてタグを認識させる一
般的な方法です。このオプションとファイル名を自由に混ぜて使用できます。
各`--regex'オプションは、それ以前に指定した正規表現に追加され、オプショ
ンのあとにあるファイルに適用されます。オプションの構文はつぎのとおりで
す。

     --regex=/TAGREGEXP[/NAMEREGEXP]/

ここで、TAGREGEXPは、行に一致させてタグを取り出すために使われます。こ
れはつねに位置が固定されています。つまり、`^'が前置されているかのよう
に扱われます。字下げ分を考慮したければ、正規表現を`[ \t]*'で始めて、行
頭の任意個の空白に一致するようにします。正規表現においては、`\'は直後
の文字をクォートし、`\t'はタブ文字を表します。`etags'では、これら以外
にはCで使われるエスケープシーケンスを扱えないことに注意してください。

`etags'の正規表現の構文は、Emacsのものと同じで、"反復回数演算子"
（interval operator）が拡張されています。この演算子は、`grep'や`ed'で
使えるものと同じ動作をします。反復回数演算子の構文は`\{M,N\}'であり、
直前の正規表現のM回以上N回以下の繰り返しに一致します。

TAGREGEXPがタグとして認識したい部分よりも長く一致するようにはしないで
ください。TAGREGEXPに一致する部分が必要以上に長くなるのが避けられない
ならば、タグの範囲を狭めるためにNAMEREGEXPを追加するとよいかもしれませ
ん。正規表現を利用した例をいくつか紹介しましょう。

`-R'オプションは、それまでに`--regex'オプションで定義したすべての正規
表現を削除します。つぎの使用例からもわかるように、オプションのあとに続
くファイルに適用されます。

     etags --regex=/REG1/ voo.doo --regex=/REG2/ \
         bar.ber -R --lang=lisp los.er

この例では、`etags'は、`voo.doo'と`bar.ber'に対しては、その内容から使
用言語を推定します。さらに、`voo.doo'から余分にタグを認識するために
REG1を使い、`bar.ber'から余分にタグを認識するためにはREG1とREG2の両方
を使います。`los.er'からタグを認識するには、Lispのタグ構文規則だけを使
い、正規表現による一致はいっさい使いません。

別の例を示しましょう。ここでは、シェルが解釈しないように正規表現をクォー
トします。

   * Emacsのソースファイルに含まれる`DEFVAR'マクロをタグとする。

          --regex='/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/'

   * VHDLファイルからタグを取り出す（この例は本来は単一の長い行だが、
     印刷の関係で分割してある）。

          --language=none
          --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/'
          --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
          \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'

   * Tclファイルからタグを取り出す（この例はNAMEREGEXPの使用例でもあ
     る）。

          --lang=none --regex='/proc[ \t]+\([^ \t]+\)/\1/'

他のオプション一覧を表示するには、`etags --help'を実行してください。



File: emacs-ja.info, Node: Select Tags Table, Next: Find Tag, Prev: Create Tags Table, Up: Tags

タグテーブルの選択
------------------

Emacsでは、いつでも1つの"選択された"タグテーブルがあり、タグテーブルを
使って動作するコマンドは選択されたタグテーブルを使用します。タグテーブ
ルを選択するには、`M-x visit-tags-table'と打ちます。すると、タグテーブ
ルファイル名を聞いてきます。デフォルトのファイル名は、デフォルトディレ
クトリの`TAGS'です。

このコマンドは、ファイル名を変数`tags-file-name'に格納するだけです。タ
グテーブルを使おうとしない限り、Emacsは実際にはタグテーブルの内容を読
み込みません。`visit-tags-table'を使わずに、自分自身でこの変数にファイ
ル名を設定してもかまいません。この変数の初期値は`nil'です。これは、タ
グテーブルを使うすべてのコマンドに、使用するタグテーブルファイルを尋ね
させることになります。

すでにタグテーブルを読み込んであるときに`visit-tags-table'を使うと、2
つの選択肢があります。現在のタグテーブルリストに新たにタグテーブルを追
加するか、タグテーブルリストを新規に始めるかです。タグコマンドは、現在
のリストにあるすべてのタグテーブルを使用します。新たなタグテーブルリス
トを始めると、他のタグテーブルの*かわり*に新たなタグテーブルが使われま
す。現在のリストに新たなタグテーブルを追加すると、他のタグテーブルと*
ともに*新たなものも使われます。タグコマンドがタグテーブルリストを走査
するときには、つねにリストの先頭から始めるわけではありません。現在のファ
イルを記録しているタグテーブルがあれば、まずそれから始めてリストの末尾
まで進みます。そして、リストの先頭からリストに含まれるすべてのタグテー
ブルを調べ終るまで走査を続けます。

変数`tags-table-list'に文字列のリストを設定すれば、タグテーブルの正確
なリストをあらかじめ指定できます。たとえば、つぎのようにします。

     (setq tags-table-list
           '("~/emacs" "/usr/local/lib/emacs/src"))

この設定例では、タグコマンドは、個人の`~/emacs'ディレクトリと
`/usr/local/lib/emacs/src'ディレクトリの（2つの）`TAGS'ファイルを見に
いきます。上で述べたように、タグファイルを使う順番は、対象としているファ
イルやそのファイルを記述しているタグテーブルに依存します。

`tags-file-name'と`tags-table-list'の両方に値を設定してはいけません。



File: emacs-ja.info, Node: Find Tag, Next: Tags Search, Prev: Select Tags Table, Up: Tags

タグの探索
----------

タグテーブルで実現されるもっとも重要な機能は、指定したタグの定義を探し
出すことです。

`M-. TAG RET'
     タグTAGの最初の定義を探す（`find-tag'）。
`C-u M-.'
     最後に指定したタグのつぎの定義を探す。
`C-u - M-.'
     まえにみつかったタグに戻る。
`C-M-. PATTERN RET'
     名前がPATTERNに一致するタグを探す（`find-tag-regexp'）。
`C-u C-M-.'
     最後に使用したパターンに一致するつぎのタグを探する。
`C-x 4 . TAG RET'
     タグTAGの最初の定義を探し、別のウィンドウに表示する
     （`find-tag-other-window'）。
`C-x 5 . TAG RET'
     タグTAGの最初の定義を探し、バッファを選択するための新たなフレーム
     を作る。（`find-tag-other-frame'）。
`M-*'
     まえに`M-.'を起動した場所へ戻る。

`M-.'（`find-tag'）は、指定したタグの定義を探すコマンドです。まず、タ
グテーブルの中で文字列としてタグ名を探し、タグテーブルの情報を用いて、
定義されているファイルの名前とファイル内でのおおよその文字位置を求めま
す。続いて、`find-tag'はそのソースファイルを訪れて、ポイントをおおよそ
の文字位置に移動してから、範囲を広げながらタグの定義を探します。

（単にRETと打って）引数を指定しないと、ポイントの直前または周辺にあるS
式をTAG引数として使います。S式に関しては、*Note Lists::。

コマンド`M-.'にタグの名前を完全に与える必要はありません。その一部分で
十分です。というのは、`M-.'は、部分文字列としてTAGを含むタグをタグテー
ブルで探すからです。もちろん、部分一致よりも全一致のほうが望ましいです。
同じ部分文字列に一致する別のタグを探すには、`C-u M-.'のように
`find-tag'に数引数を指定します。こうするとタグ名を聞いてきませんが、最
後に使ったものと同じ部分文字列を含む別のタグをタグテーブルから探します。
もし本物のMETAキーが使えるのであれば、`C-u M-.'のかわりに`M-0 M-.'と打
つほうが簡単でしょう。

バッファの切り替えを伴う他のコマンドと同様に、`find-tag'にも新たなバッ
ファを別のウィンドウに表示したり、新規作成したフレームに表示する変種が
あります。前者は`C-x 4 .'であり、コマンド`find-tag-other-window'を起動
します。後者は`C-x 5 .'であり、`find-tag-other-frame'を起動します。

最近にみつけたタグ位置に戻るには、`C-u - M-.'を使います。より一般的に
は、`M-.'に負の数引数を指定します。このコマンドは、別のバッファへも移
動します。`C-x 4 .'に負の数引数を指定すると、別のウィンドウでまえのタ
グ位置に戻ります。

最近にみつけたタグ位置に戻るだけでなく、タグを*探したとき*の場所へ戻る
こともできます。それには、コマンド`pop-tag-mark'を起動する`M-*'を使い
ます。典型的な使い方では、`M-.'で何かの定義を調べてから、`M-*'でもとの
場所に戻ります。

`C-u - M-.'と`M-*'のどちらも、変数`find-tag-marker-ring-length'で指定
される深さまで、辿った経路を引き返せます。

コマンド`C-M-.'（`find-tag-regexp'）は、指定した正規表現に一致するタグ
を訪れます。部分文字列ではなく正規表現に一致するものであることを除けば、
`M-.'と同じです。



File: emacs-ja.info, Node: Tags Search, Next: List Tags, Prev: Find Tag, Up: Tags

タグテーブルを用いた探索と置換
------------------------------

ここで紹介するコマンドは、選択されたタグテーブルに記録されているすべて
のファイルを1つ1つ訪れては探索を行います。これらのコマンドに対しては、
タグテーブルは探索対象となる一連のファイルを指定するだけです。

`M-x tags-search RET REGEXP RET'
     選択されたタグテーブル内の各ファイルから指定された正規表現を探索
     する。
`M-x tags-query-replace RET REGEXP RET REPLACEMENT RET'
     選択されたタグテーブル内の各ファイルに対して、
     `query-replace-regexp'を実行する。
`M-,'
     ポイント位置から上記のコマンドのいずれかを再実行する
     （`tags-loop-continue'）。

`M-x tags-search'は、ミニバッファで正規表現を読み取り、選択されたタグ
テーブル内のすべてのファイル1つ1つについて、正規表現に一致する部分を探
します。このコマンドは探索しているファイル名を表示するので、進行状況が
わかります。正規表現に一致する部分がみつかると、`tags-search'はすぐに
戻ります。

一致する部分をみつけたあとに、残りも探したくなるでしょう。つぎの一致を
探すには、`M-,'（`tags-loop-continue'）と打って、`tags-search'を再開し
ます。これは、カレントバッファの残りを探索してから、タグテーブルの残り
のファイルについても探索します。

`M-x tags-query-replace'は、タグテーブル内のすべてのファイルを対象に、
`query-replace-regexp'を実行します。このコマンドは、通常の`M-x
query-replace-regexp' （問い合わせ型置換）と同じく、探索すべき正規表現
と置換文字列を読み取ります。そして、`M-x tags-search'のように探索を行
い、利用者の入力に応じて一致部分を処理することを繰り返します。問い合わ
せ型置換について詳しくは、*Note Replace::。

`M-x tags-query-replace'を一度起動するだけで、タグテーブル内の全ファイ
ルの置換を行うことができます。しかし、一時的に置換作業から抜け出して、
問い合わせ型置換とは関係ないことを行えると便利です。`M-,'と打てば、問
い合わせ型置換を再開できます。このコマンドは、最後に行ったタグの探索コ
マンドか置換コマンドを再開します。

ここで紹介したコマンドは、`find-tag'系列のコマンドよりも、幅広い探索を
実行します。`find-tag'コマンドは、指定した部分文字列や正規表現に一致す
るタグの定義だけをみつけます。コマンド`tags-search'と
`tags-query-replace'は、通常の探索コマンドや置換コマンドがカレントバッ
ファで行うように、正規表現に一致するあらゆる部分を探し出します。

これらのコマンドは、（Emacsバッファにまだ訪れていないものに対しては）
探索すべきファイル用に一時的なバッファを作成します。一致部分がみつから
なければバッファはただちに消されますが、みつかれば存続します。

`tags-search'は、`grep'プログラムにたいへんよく似ていると思われたかも
しれません。Emacsの下位プロセスとして`grep'を実行して、Emacsに一致した
行を1つずつ表示させることもできます。これは、コンパイルを実行するのと
同じように動作します。`grep'が一致を検出したソース箇所を探すことは、コ
ンパイルエラーを探すのと同様に動作します。*Note Compilation::。
        


