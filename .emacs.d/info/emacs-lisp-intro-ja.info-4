Info file: emacs-lisp-intro-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-lisp-intro.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


































INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs Lisp Intro: (eintr).
  			A simple introduction to Emacs Lisp programming.
END-INFO-DIR-ENTRY


これはプログラマではない人のための `Emacs Lisp プログラミング' 解説書
である．

Edition 2.04, 2001 Dec 17

Copyright (C) 1990, '91, '92, '93, '94, '95, '97, 2001 Free Software
Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Section being the Preface, with the Front-Cover Texts being
no Front-Cover Texts, and with the Back-Cover Texts being no
Back-Cover Texts.  A copy of the license is included in the section
entitled "GNU Free Documentation License".















File: emacs-lisp-intro-ja.info, Node: zap-to-char, Next: kill-region, Prev: Storing Text, Up: Cutting & Storing Text

`zap-to-char'
=============

関数`zap-to-char'は、GNU Emacsの第19版と第21版ではわずかに変更された．
しかし，`zap-to-char' は他の関数 `kill-region' を呼び出す．この関数は
第21版では大幅に書き換えられた．

Emacs 19 の `kill-region' は複雑だが，ここでは重要ではないので省略する．

Emacs 21 の `kill-region' は Emacs 19 よりも読みやすくなっている．そし
て，とても重要なエラーハンドリングという考え方が含まれているので，ざっ
と紹介することになるだろう．

しかし，まずは `zap-to-char' を紹介しよう．

以下は、第19版での関数の実装の完全なテキストである。

     (defun zap-to-char (arg char)  ; version 19 implementation
       "Kill up to and including ARG'th occurrence of CHAR.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "*p\ncZap to char: ")
       (kill-region (point)
                    (progn
                      (search-forward
                       (char-to-string char) nil nil arg)
                      (point))))



File: emacs-lisp-intro-ja.info, Node: zap-to-char interactive, Next: zap-to-char body, Prev: Complete zap-to-char, Up: zap-to-char

`interactive'式
---------------

コマンド`zap-to-char'の`interactive'式はつぎのとおりである。

     (interactive "*p\ncZap to char: ")

`"*p\ncZap to char: "'のように二重引用符に囲まれた引数があり、3つの部
分から成る。最初の部分はもっとも簡単でアスタリスク`*'であり、バッファ
が読み出し専用だった場合にエラーを発生させる。つまり、読み出し専用バッ
ファで`zap-to-char'を使うと、テキストを削除できずに、「Buffer is
read-only（バッファは読み出し専用）」というエラーメッセージを受け取り、
端末のベルも鳴る。

第21版ではアスタリスク `*' を持たないように改良されました．第19版でも
この関数は同じように動作すいます．しかし，読み出し専用バッファからテキ
ストを削除するのではなく，キルリングに削除されるはずだったテキストをコ
ピーするのです．両版で，エラーメッセージが表示されます．

しかし，第19版の改良では `interactive' の改良の誤りのために読み出し専
用バンファからテキストをコピーします．`interactive' のドキュメントによ
るとアスタリスク `*' は `zap-to-char' がバッファが読み出し専用の時，何
かをしないようにすべきなのです．つまり，関数はテキストをキルリングにコ
ピーすべきではないのです．コピーするのはバグなのです．

第21版では `interactive' が適切に改良されました．だから，アスタリスク 
`*' は interactive の仕様から削除されなければなりませんでした．`*' を
挿入し関数定義を評価すると，`zap-to-char' を読み出し専用バッファで実行
することになります．しかし，テキストはコピーできません．

その変更とドキュメントの変更を除くと2つのバージョンにおける
`zap-to-char' の機能は同じです．

さて，interactive の仕様の説明を続けよう．

`"*p\ncZap to char: "' の2番目の部分は `p'である．この部分は改行`\n'で
終わる。`p'は、関数の第1引数には「処理した前置引数（processed prefix）」
の値を渡すことを意味する。前置引数は、`C-u'に続けて数、あるいは、`M-'
と数をタイプして渡す。引数なしで対話的に関数を呼び出した場合には、この
引数には1が渡される。

`"*p\ncZap to char: "'の3番目の部分は `cZap to char:'である。この部分
では、小文字の`c'により、`interactive'はプロンプトがあり、引数は文字で
あることを期待する。プロンプトは`c'のあとに続く文字列`Zap to char: 'で
ある（コロンのうしろの空白は、見やすくするためである）。

これらにより、ユーザーに問い合わせて`zap-to-char'へ渡す正しい型の引数
を準備する。



File: emacs-lisp-intro-ja.info, Node: zap-to-char body, Next: search-forward, Prev: zap-to-char interactive, Up: zap-to-char

`zap-to-char'の本体
-------------------

関数`zap-to-char'の本体には、カーソルの現在位置から指定文字を含んだテ
キストをキル（つまり、削除）するコードがある。コードの最初の部分はつぎ
のとおりである。

     (kill-region (point) ...

`(point)'はカーソルの現在位置である。

コードのつぎの部分は、`progn'を使った式である。`progn'の本体は、
`search-forward'と`point'の呼び出しから成る。

`search-forward'を説明してからのほうが`progn'の動作を理解しやすいので、
`search-forward'を説明してから`progn'を説明する。



File: emacs-lisp-intro-ja.info, Node: search-forward, Next: progn, Prev: zap-to-char body, Up: zap-to-char

関数`search-forward'
--------------------

関数`search-forward'は、`zap-to-char'にて削除する指定文字を探すために
使われる。この探索に成功すると、`search-forward'は、探索文字列の最後の
文字の直後にポイントを置く（`zap-to-char'では、探索文字列は1文字であ
る）。逆向きに探索した場合には、探索文字列の最初の文字の直前にポイント
を置く。さらに、`search-forward'は、真として`t'を返す（したがって、ポ
イントの移動は「副作用」である）。

`zap-to-char'では、関数`search-forward'をつぎのように使う。

     (search-forward (char-to-string char) nil nil arg)

関数`search-forward'は4つの引数を取る。

  1. 第1引数は探す対象となるものであり、`"z"'のような文字列である必要
     がある。

     `zap-to-char'に渡される引数は単独の文字である。コンピュータの構成
     方法のために、Lispインタープリタは単独の文字と文字列を区別するか
     もしれない。コンピュータ内部では、単独の文字は、1文字の文字列とは
     異なる電気的な形式となる（単独の文字は、コンピュータ内部では、し
     ばしば、ちょうど1バイトで記録される。一方、文字列は長かったりする
     ので、コンピュータはそれに対応できる必要がある）。関数
     `search-forward'は文字列を探すので、関数`zap-to-char'が引数として
     受け取った文字は、コンピュータ内部では、ある形式から別の形式に変
     換する必要がある。さもないと、関数`search-forward'は失敗する。関
     数`char-to-string'を使って、この変換を行う。

  2. 第2引数は探索範囲を限定し、バッファ内の位置を指定する。この場合、
     バッファの最後まで探索してよいので、探索範囲を限定せず、第2引数は
     `nil'である。

  3. 第3引数は、探索に失敗した場合にどうするかを指定する。エラーを通知
     する（かつ、メッセージを表示する）か、`nil'を返す。第3引数に`nil'
     を指定すると、探索に失敗すると関数はエラーを通知する。

  4. `search-forward'の第4引数は、繰り返し回数、つまり、文字列の出現を
     何回探すかを指定する。この引数は省略でき、繰り返し回数を指定しな
     いと1である。この引数が負の場合には、逆向きに探索する。

`search-forward'式の概略はつぎのとおりである。

     (search-forward "探索文字列"
                     探索範囲
                     探索失敗時の動作
                     繰り返し回数)

では、`progn'を説明しよう。



File: emacs-lisp-intro-ja.info, Node: progn, Next: Summing up zap-to-char, Prev: search-forward, Up: zap-to-char

The `progn' Special Form
------------------------

スペシャルフォーム `progn'
--------------------------

`progn'は、個々の引数を順番に評価して最後のものの値を返すスペシャルフォー
ムである。最後以外の式は、それらの副作用のためだけに評価される。それら
が返す値は捨てられる。

`progn'式の雛型はとても簡単である。

     (progn
       本体...)

`zap-to-char'では、`progn'式は2つのことを行う。正しい位置にポイントを
置くことと、`kill-region'がどこまでを削除するかがわかるようにポイント
の位置を返すことである。

`progn'の第1引数は`search-forward'である。`search-forward'は、文字列を
探しあてると検索文字列の最後の文字の直後にポイントを置く（ここでは、検
索文字列は1文字長である）。逆向きに検索した場合は、`search-forward'は
検索文字列の最初の文字の直前にポイントを置く。ポイントの移動は副作用で
ある。

`progn'の2番目で最後の引数は、式`(point)'である。この式はポイントの値
を返し、ここでは、`search-forward'が移動した位置である。`progn'式がこ
の値を返し、`kill-region'の第2引数として`kill-region'に渡される。



File: emacs-lisp-intro-ja.info, Node: Summing up zap-to-char, Prev: progn, Up: zap-to-char

`zap-to-char'のまとめ
---------------------

`search-forward'と`progn'の動作がわかったので、関数`zap-to-char'全体と
しての動作を理解しよう。

`kill-region'の第1引数は、コマンド`zap-to-char'を与えたときのカーソル
の位置、つまり、そのときのポイントの値である。`progn'の中で、探索関数
が削除する文字の直後にポイントを移動し、`point'がその位置の値を返す。
関数`kill-region'は、ポイントの2つの値を組み合わせて、最初のものをリー
ジョンの始まり、あとのものをリージョンの終わりと解釈してリージョンを削
除する。

式`search-forward'と`point'を2つ続けて余分な2つの引数として書くと、2つ
の引数を取るコマンド`kill-region'は失敗するので、スペシャルフォーム
`progn'が必要なのである。`progn'式は、`kill-region'に対しては1つの引数
となり、`kill-region'が第2引数に必要とする1つの値を返す。



File: emacs-lisp-intro-ja.info, Node: kill-region, Next: Digression into C, Prev: zap-to-char, Up: Cutting & Storing Text

`kill-region'
=============

関数 `zap-to-char' は関数 `kill-region' を使います．この関数はリージョ
ンからテキストを切取り，テキストを後で利用できるようにキルリングへコピー
します．

Emacs 21 ではこの関数は `condition-case' と`copy-region-as-kill' を仕
様しています．`condition-case' は重要なスペシャルフォームです．

要するに，関数 `kill-region' は `condition-case' を呼び出します．この
関数は3つの引数を取ります．この関数では，最初の引数は何もしません．2番
目の引数は正常に終了した時の処理を含みます．3番目の引数はエラーが生じ
た時に呼ばれるコードを含みます．

* Menu:

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* delete-and-extract-region::   Doing the work.



File: emacs-lisp-intro-ja.info, Node: Complete kill-region, Next: condition-case, Prev: kill-region, Up: kill-region

`kill-region' の定義
--------------------

すぐに `condition-case' を知ることになるでしょう．最初に，コメントを加
えた `kill-region' の完全な定義を見ていきます．

     (defun kill-region (beg end)
       "Kill between point and mark.
     The text is deleted but saved in the kill ring."
       (interactive "r")

       ;; 1. `condition-case' は3つの引数を取ります．
       ;;    最初に引数がここにあるように nil であれば
       ;;    エラーシグナルに関する情報は
       ;;    他の関数で使用されるように保存することをしません．
       (condition-case nil

           ;; 2. 'condition-case' の2番目の引数は
           ;;    正常に終了した時に何をするべきかを知らせます．

           ;;    関数 `delete-and-extract-region' は大抵正常に機能します．
           ;;    もしリージョンの最初と終わりが両方とも同じであれば，
           ;;    変数 `string' は空か nil になるでしょう．
           (let ((string (delete-and-extract-region beg end)))

             ;; `when' は `else-part' を取らない `if' です．
             ;; Emacs は通常 `last-command' の値を
             ;; 前のコマンドの値にします．
             ;; `kill-append' は新しいテキストを古いものに連結します．
             ;; `kill-new' はテキストをキルリングの新しい要素として挿入します．
             (when string
               (if (eq last-command 'kill-region)
                   ;; if true, prepend string
                   (kill-append string (< end beg))
                 (kill-new string)))
             (setq this-command 'kill-region))

         ;; 3. `condition-case' の3番目の引数はエラー時に
         ;;    何をすべきかを指定します．
         ;;    3番目の引数は条件部分と本体部分を含みます．
         ;;    もし条件が合えば (この例では
         ;;    テキストかバッファが読み出し専用であれば)
         ;;    本体部分が実行されます．
         ((buffer-read-only text-read-only) ;; 条件部分
          ;; 一致すれば
          (copy-region-as-kill beg end)
          (if kill-read-only-ok            ;; 大抵この変数は nil である．
              (message "Read only text copied to kill ring")
            ;; そうでなければ，バッファが読み出し専用であるというエラーを
            ;; 表示する
            (barf-if-buffer-read-only)
             ;; そして，どんな場合でもテキストが読み出し専用であることを知
             ;; らせる．
            (signal 'text-read-only (list (current-buffer)))))))



File: emacs-lisp-intro-ja.info, Node: condition-case, Next: delete-and-extract-region, Prev: Complete kill-region, Up: kill-region

`condition-case'
----------------

以前見た (*Note Generate an Error Message: Making Errors.) ように，
Emacs Lisp は式を評価して問題が生じた時に，ヘルプを与えます．専門的に
言うと"エラーを知らせる"のです．大抵はコンピュータはプログラムを停止さ
せメッセージを表示します．

しかし，いくつかのプログラムでは複雑な動作を保証します．単にエラーで停
止すべきではないのです．関数 `kill-region' で，最もありそうなエラーは
読み出し専用のテキストをキルしようとして削除できないことです．だから，
関数 `kill-region' ではこの状況を処理するためのコードを含みます．この
コードは関数 `kill-region' の本体を構成し，`condition-case' の内部にあ
るのです．

`condition-case' のテンプレートは以下のようになります．

     (condition-case
       VAR
       BODYFORM
       ERROR-HANDLER...)

2番目の引数 BODYFORM は簡単です．スペシャルフォームである
`condition-case' は BODYFORM のコードを評価させます．もしエラーが起こ
れば，スペシャルフォームはコードの値を返し，もし何かあれば副作用を生じ
させます．

簡単に言うと，`condition-case' の BODYFORM 部分はすべてが正常に機能し
た時に何が起きるかを決定するのです．

しかし，もしエラーが起これば，その他の部分の途中で，1つかそれ以上のエ
ラーシグナルを決定し，返します．

`condition case' の3番目の引数はエラーを処理する部分です．エラーを処理
する部分はCONDITION-NAME と BODY という2つの部分を持ちます．もし，エラー
ハンドラーの CONDITION-NAME 部分がエラーによって生じた名前と一致すれば，
エラーを処理する BODY 部分が実行されます．

予期していると思いますが，エラーハンドラーの CONDITION-NAME 部分は1つ
か条件名のリストのどちらかになります．

`condition-case' 式は1つ以上のエラーハンドラーを含むかもしれません．エ
ラーが起こった時，最初に適用できるものが実行されます．

最後に，`condition-case' の最初の引数，VAR は時々，エラーに関する情報
を含む変数になっています．しかし，その引数が nil であれば，
`kill-region' の場合のようにその情報は破棄されます．

要するに関数 `kill-region' の `condition-case'部分は以下のように動作す
るのです．

     もしエラーが無ければ, このコードが実行される
         しかし, エラーなら, このコードが実行される.



File: emacs-lisp-intro-ja.info, Node: delete-and-extract-region, Prev: condition-case, Up: kill-region

`delete-and-extract-region'
---------------------------

`condition-case' 式は2つの部分を持ちます．1つ目は正常に動作すると期待
されている部分です．しかし，エラーが生じると，もう一つの部分が評価され
ます．

最初に，`kill-region' のコードを正常に動作するものとして見てみよう．こ
れは関数の核心である．このコードは下記のようになる．

     (let ((string (delete-and-extract-region beg end)))
       (when string
         (if (eq last-command 'kill-region)
             (kill-append string (< end beg))
           (kill-new string)))
       (setq this-command 'kill-region))

新しい関数 `delete-and-extract-region'， `kill-append'，`kill-new'と新
しい変数 `last-command' と `this-command' があるために複雑に思えます．

関数 `delete-and-extract-region' は簡単です．これは組込み関数であり，
リージョンのテキストを削除し，そのテキストを返します．これは実際にテキ
ストを削除する関数なのです．(そして，不可能であれば，エラーを返します)

この `let' 式で `delete-and-extract-region' が返すテキストはローカル変
数 `string' に保存されます．これはバッファから削除されたテキストです．
(具体的には，変数はポイント位置から切り出されたテキストになります．要
は変数とは単にテキストの略称なのです．)

もし変数 `string' がテキストを含むのであれば，そのテキストはキルリング
に追加されます．削除されたテキストが無ければ変数の値は`nil' になります．

このコードでは変数 `string' がテキストを含むかどうかを`when' を用いて
確認しています．`when' は単にプログラマの利便性のためだけにあります．
`when' は else 部分のない `if' です．頭の中で，`when' を `if'に置き換
えるとどうなるか理解できるでしょう．それは Lisp のインタープリタがして
いることです．

技術的に言うと，`when' は Lisp マクロです．Lisp "macro" は新しい制御や
他の言語機能を実現できる．インタープリタに順に変数を処理する他の Lisp 
式をどのように処理するかを伝えます．この例では，"他の式"とは`if' 式で
す．Lisp マクロに関する詳細は*Note Macros: (elisp)Macros を参照くださ
い．C言語でもマクロがあります．違いはありますが，両者とも便利なもので
す．*Note `delete-and-extract-region': Digressing into C: Digression
into C でCマクロを簡単に見ることができます．

文字列が内容を含んでいれば，他の条件式が実行されます．これは，then と
else 部分を持つ `if' である．

     (if (eq last-command 'kill-region)
         (kill-append string (< end beg))
       (kill-new string)))

もし前のコマンドが `kill-region' であれば，then 部分が評価されます．も
しそうでなければ，else 部分が評価されます．

`last-command' はまだ紹介していないEmacsに標準の変数です．通常は，関数
が実行されると，Emacsは変数 `last-command' に前のコマンドを設定します．

この部分の定義では，`if' 式は前のコマンドが `kill-region' だったかどう
かを確認しています．もしそうだったら，

     (kill-append string (< end beg))

すぐ前にキルリングに切り出されたテキストに新しく切り出されたテキストの
コピーを連結します．(もし `(< end beg))' 式が真であれば，
`kill-append' は文字列をすぐ前に切り出したテキストの先頭に追加し
ます．詳細については*Note The `kill-append' function: kill-append functionを参照ください．)

もしテキストをヤンクすれば，つまり貼り付けると，一度に両方を得る．こう
して，2つの単語を連続して削除し，ヤンクすると，1度のヤンクを実行するこ
とで，適当な順番で両方の単語を得ることができる．(`(< end
beg))' 式は順序が正しくなるようにしているのです．)

一方で，前のコマンドが `kill-region' でなければ，関数`kill-new' が呼ば
れ，テキストをキルリングの最新の位置に追加します．そして，変数 
`kill-ring-yank-pointer' にその位置を保存します．



File: emacs-lisp-intro-ja.info, Node: Digression into C, Next: defvar, Prev: kill-region, Up: Cutting & Storing Text

`delete-and-extract-region': Cへ回り道
======================================

コマンド`zap-to-char'は関数`kill-region'を使い、それはさらに
`copy-region-as-kill'と`delete-region'という2つの関数を使っている。関
数`copy-region-as-kill'はつぎの節で説明するが、リージョンのコピーをキ
ルリングに保存して取り出せるようにする（*Note copy-region-as-kill::）。

関数`delete-region'はリージョンの内容を削除するが、その内容を戻すこと
はできない。

これまでに説明したコードと異なり、`delete-region'はEmacs Lispで書かか
れていない。Cで書かかれており、GNU Emacsシステムの基本操作関数の1つで
ある。とても簡単なので、Lispから回り道して、ここで説明することにする。

Emacsのほとんどの基本操作関数と同様に、`delete-region'は、Cのマクロ、
コードの雛型となるマクロを用いて書かれている。マクロの最初の部分はつぎ
のとおりである。

     DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
            Sdelete_and_extract_region, 2, 2, 0,
       "Delete the text between START and END and return it.")
       (start, end)
          Lisp_Object start, end;
     {
       validate_region (&start, &end);
       return del_range_1 (XINT (start), XINT (end), 1, 1);
     }

マクロを詳細に踏み込むようなことはしないが，このマクロは単語`DEFUN' で
開始することが指摘しておこう．この単語 `DEFUN' はLisp の `defun' と同
じ目的で作られているため，選ばれたものです．`DEFUN' は括弧の中に7つの
部分を取っています．

   * 最初の部分はLispでの関数名であり、ここでは、
     `delete-and-extract-region'である。

   * The second part is the name of the function in C,
     `Fdelete_and_extract_region'.  By convention, it starts with `F'.
     Since C does not use hyphens in names, underscores are used
     instead.  2番目の部分はCでの関数名であり、
     `Fdelete_and_extract_region'である。慣習的に`F'で始める。Cでは名
     前としてハイフンを使えないので、かわりに下線を使う。

   * 3番目の部分は、この関数を内部で使用するための情報を記録したCの構
     造体の定数の名前である。これはCでの関数名であるが、`F'のかわりに
     `S'で始める。

   * 4番目と5番目の部分は、関数が取りえる引数の最小個数と最大個数であ
     る。この関数は必ず2つの引数を必要とする。

   * 6番目の部分は、Lispで書いた関数の`interactive'の引数とほとんど同
     じであり、文字に続けてプロンプトがあってもよい。Lisp との唯一の違
     いはマクロが引数無しで呼ばれた時である．つまり，このマクロで `0'
     (null 文字) を書くような時だ．

     もし引数を指定していたなら，それを引用符の間に置いたことだろう．
     `goto-char' の C マクロはこの位置に関数が無引数の時のために，バッ
     ファの位置を指定できるようプロンプトを表示するように `"NGoto
     char: "' を置いてある．

   * 7番目の部分は説明文字列であり、Emacs Lispで書いた関数と同じもので
     あるが、各改行は、`\n'に続けてバックスラッシュと改行で書く必要が
     ある。そうして，`goto-char' のドキュメントの最初の2行は下記のよう
     になる．

            "Set point to POSITION, a number or marker.\n\
          Beginning of buffer is position (point-min), end is (point-max).

Cのマクロでは、オブジェクトの種類を指定する文とともに仮引数があり、さ
らに、マクロの「本体」とも呼ぶべきものが続く。
`delete-and-extract-region'の本体はつぎの2行から成る。

     validate_region (&start, &end);
     return del_range_1 (XINT (start), XINT (end), 1, 1);

最初の関数 `validate_region' はリージョンの開始と先頭を示す値が適当な
値で範囲内にあるかどうかを確認しています．2番目の関数`del_range_1' は
実際にテキストを削除する．

`del_range_1' は複雑な関数であり，詳細は述べない．この関数はバッファを
更新し，他のことはしない．

しかし，`del_range' へ渡る2つの引数は見ておく価値がある．引数には
`XINT (start)' と `XINT (end)' がある．

C 言語に関する限り，`start' と `end' は削除される (1) (*Note
Digression into C-Footnotes::) リージョンの最初と最後の位置を示す2つの
整数である．

Emacs の初期バージョンでは，これら2つの数は32ビット長でした．しかし，
コードはゆっくりと他の長さを扱えるように書き直されてきました．利用でき
るビットの3番目は情報のタイプを特定できるように遣われます．そして，4ビッ
ト目はコンピュータのメモリを扱うために使われます．残ったビットは"内容" 
を示すために使われます．

`XINT' は C マクロであり，ビットの長い部分から適当な部分を切り出すので
す．つまり，4つ以外のビットは破棄される．

`delete-and-extract-region' のコマンドは下記のようになります．

     del_range_1 (XINT (start), XINT (end), 1, 1);

これは リージョンの開始位置 `start' と終了位置 `end' の間を削除します．

Lisp を書く人の視点だと，Emacs はとても単純です．しかし，正常に動作さ
せるために，たくさんの複雑な部分が隠れているのです．


File: emacs-lisp-intro-ja.info  Node: Digression into C-Footnotes, Up: Digression into C

(1) より正確に，より深く理解できるように述べておくと，2つの引数は
`Lisp_Object' タイプである．これは，Cの整数タイプの代わりとなることが
できる



File: emacs-lisp-intro-ja.info, Node: defvar, Next: copy-region-as-kill, Prev: Digression into C, Up: Cutting & Storing Text

`defvar'による変数の初期化
==========================

関数 `delete-and-extract-region' と異なり、関数`copy-region-as-kill'は
Emacs Lispで書かれている。内部に含まれる2つの関数 `kill-append' と 
`kill-new' はバッファのリージョンのコピーを変数`kill-ring'にコピーする。
本節では、変数 `kill-ring' の作成とスペシャルフォーム`defvar' を使った
初期化の方法を説明する。

（`kill-ring'はふさわしくない名称であることを再度指摘しておく。バッファ
から切り取ったテキストは戻すことができる。キルリングは死体のリングでは
なく、復活できるテキストのリングである。）

Emacs Lispでは、`kill-ring'のような変数は、スペシャルフォーム`defvar'
を用いて作成し初期化する。この名称は「define variable（変数を定義する）」
からきている。

スペシャルフォーム`defvar'は、変数の値を設定するという意味では`setq'に
似ている。しかし、`setq'とは2つの点で異なる。まず、値を持っていない変
数にのみ値を設定することである。変数にすでに値があれば、`defvar'は既存
の値を書き換えない。第二に、`defvar'は説明文字列を有することである。

他のスペシャルフォーム `defcustom' はカスタマイズできる変数のためにあ
る．`defvar' よりも多くの機能を持つ．(*Note Setting Variables with
`defcustom': defcustom.)

* Menu:

* See variable current value::
* defvar and asterisk::         An old-time convention.



File: emacs-lisp-intro-ja.info, Node: See variable current value, Next: defvar and asterisk, Prev: defvar, Up: defvar

変数の現在値を知る
------------------

任意の変数の現在の値は、関数`describe-variable'を使って調べることがで
き、普通、`C-h v'とタイプすれば起動できる。`C-h v'とタイプして問い合わ
せに`kill-ring'（に続けてRET）とタイプすれば、今のキルリングに何が入っ
ているかがわかるが、とても多量であろう。一方、本書を読む以外の操作を
Emacsで行っていなければ、キルリングには何もないであろう。`kill-ring' 
のドキュメントを見てみよう．

     Documentation:
     List of killed text sequences.
     Since the kill ring is supposed to interact nicely with cut-and-paste
     facilities offered by window systems, use of this variable should
     interact nicely with `interprogram-cut-function' and
     `interprogram-paste-function'.  The functions `kill-new',
     `kill-append', and `current-kill' are supposed to implement this
     interaction; you may want to use them instead of manipulating the kill
     ring directly.

キルリングはつぎのように`defvar'で定義してある。

     (defvar kill-ring nil
       "List of killed text sequences.
     ...")

この変数定義では、変数に初期値`nil'を設定している。何も保存していない
ときには、コマンド`yank'で何も戻ってほしくないので、この値には意味があ
る。説明文字列は、`defun'の説明文字列と同じである。`apropos'のようなあ
る種のコマンドは説明文の最初の1行しか表示しないので、`defun'の説明文字
列と同様に説明文の最初の行は完全な文にしておく。また、`C-h v'
（`describe-variable'）で表示したときに変にならないように、続く行は字
下げしない。



File: emacs-lisp-intro-ja.info, Node: defvar and asterisk, Prev: See variable current value, Up: defvar

`defvar' とアスタリスク
-----------------------

過去に Emacs はスペシャルフォーム `defvar' をユーザが変更しないような
内部変数とユーザが変更する変数の両方を定義するために使っていました．今
でも `defvar' をユーザがカスタマイズできる変数として利用できますが，代
わりに `defcustom' を使うようにしてください．このスペシャルフォームは
カスタマイズで利用できるするためのスペシャルフォームです．(*Note
Setting Variables with `defcustom': defcustom)．

スペシャルフォーム `defvar' を使って変数を定義するとき，アスタリスク 
`*' をドキュメントの最初に入力しておくことで，すぐに設定できる変数であ
ると区別できる．例えば，

     (defvar shell-command-default-error-buffer nil
       "*Buffer name for `shell-command' ... error output.
     ... ")

`shell-command-default-error-buffer' の値は、コマンド`edit-options'を
使って一時的に変更できる(そして，今でもできる)ことを意味する。

しかし，`edit-options' を使って設定した値は編集期間しか有効ではない．
セッション間で新しい値は保存されない．そのため，`.emacs' ファイルで変
更したり，`customize' を使って設定していなければ，Emacs を開始するたび
に，元の値が読み込まれる．

私にとって，コマンド `edit-options' の主な用法は `.emacs' ファイルで設
定したい値を試してみることだ．私はそのリストを見てみることを強く勧める．
(*Note Editing Variable Values: (emacs)Edit Options.)



File: emacs-lisp-intro-ja.info, Node: copy-region-as-kill, Next: cons & search-fwd Review, Prev: defvar, Up: Cutting & Storing Text

`copy-region-as-kill'
=====================

関数`copy-region-as-kill'は、バッファからリージョンのテキストをコピー
し(`kill-append' か `kill-new' を介して) 変数`kill-ring'に保存する。

コマンド`kill-region'の直後に`copy-region-as-kill'を呼ぶと、Emacsは、
新たにコピーしたテキストを直前にコピーしたテキストに追加する。つまり、
そのテキストを復元すると、そのテキストと直前のテキストをまとめて得るこ
とになる。一方で、`copy-region-as-kill'のまえに別のコマンドを実行した
場合には、この関数はテキストを独立した項目としてキルリングに保存する。

* Menu:

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::    The body of `copy-region-as-kill'.



File: emacs-lisp-intro-ja.info, Node: Complete copy-region-as-kill, Next: copy-region-as-kill body, Prev: copy-region-as-kill, Up: copy-region-as-kill

関数 `copy-region-as-kill' の定義
---------------------------------

ここに第21版での関数 `copy-region-as-kill'の完全なテキストを示す．

     (defun copy-region-as-kill (beg end)
       "Save the region as if killed, but don't kill it.
     In Transient Mark mode, deactivate the mark.
     If `interprogram-cut-function' is non-nil, also save
     the text for a window system cut and paste."
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (buffer-substring beg end) (< end beg))
         (kill-new (buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)

この関数も部分部分に分解できる。

     (defun copy-region-as-kill (引数リスト)
       "説明文..."
       (interactive "r")
       本体...)

引数は`beg'と`end'であり、`"r"'が指定された対話的関数であるので、2つの
引数はリージョンの始まりと終わりを参照する必要がある。本書を始めから読
んでいる読者ならば、関数のこの部分を理解するのは簡単であろう。

単語「kill」が通常の意味と異なることを思い出せば、説明文の内容に混乱す
ることもないであろう。暫定マークとコメント `interprogram-cut-function' 
はある副作用を説明している．

一度マークをセットすると，バッファにはいつもリージョンがあることになる．
もし希望すれば，一時的にリージョンをハイライトするために暫定マークモー
ドを利用できる．(いつでもリージョンをハイライトしたい人なんていないだ
ろう．だから，暫定モードマークは適当な時だけハイライトする．多くの人は
暫定マークモードをオフにしているので，リージョンは決してハイライトされ
ない．)

ウィンドウシステムでは，異なるプログラム間でコピーやカット，ペーストで
きる．例えば Xウィンドウシステムでは関数`interprogram-cut-function' は 
`x-select-text' である．これは，Emacs のキルリングと同等ものである．

関数 `copy-region-as-kill' の本体は `if' で始まる．ここでは，2つの異な
る状況，コマンドが以前の `kill-region' の直後に実行されたかどうか，を
区別するためにある．最初の例では，新しいリージョンは以前コピーされたテ
キストに追加される．そうでなければ，キルリングの先頭に前回のものとは別
のテキストとして追加される．

この関数の最後の2行は暫定マークモードがオンの時，リージョンがハイライ
トされないようにしている．

`copy-region-as-kill'の本体は詳しく説明する価値がある。



File: emacs-lisp-intro-ja.info, Node: copy-region-as-kill body, Prev: Complete copy-region-as-kill, Up: copy-region-as-kill

`copy-region-as-kill'の本体
---------------------------

関数`copy-region-as-kill'は、関数 `kill-region' (*Note `kill-region':
kill-region.)とほとんど同じように動作する．両者とも連続してキルしたテ
キストは1つの断片にまとめるように書かれている。キルリングからテキスト
を取り出すと、1つの断片として得ることになる。さらに、カーソルの現在位
置から終わりに向けたキルでは直前にコピーしたテキストの末尾に追加し、先
頭向けのコピーでは直前にコピーしたテキストの先頭に追加する。このように
して、テキスト内の語順は正しく保たれる。

`kill-region'と同様に，関数 `copy-region-as-kill' は変数`last-command' 
をEmacsが以前実行したコマンドを確認するために使う．

* Menu:

* last-command & this-command::
* kill-append function::
* kill-new function::




File: emacs-lisp-intro-ja.info, Node: last-command & this-command, Next: kill-append function, Prev: copy-region-as-kill body, Up: copy-region-as-kill body

`last-command' and `this-command'
.................................

通常、関数が実行されると、Emacsは、`this-command'の値に実行する関数
（ここでは、`copy-region-as-kill'）を設定する。同時に、`this-command'
の直前の値を`last-command'に設定する。

関数`copy-region-as-kill'の本体の始めの部分では、`last-command'の値が
`kill-region'かどうかを`if'式で調べている。そうならば、`if'式の真の場
合の動作が評価される。そこでは、関数`kill-append'を使って、この呼び出
しでコピーするテキストをキルリングの先頭要素（CAR）に連結する。一方、
`last-command'の値が`kill-region'でなければ、関数`copy-region-as-kill'
は新たな要素を関数 `kill-new' を使ってキルリングに追加する。

まだ説明していない関数`eq'を用いているが、`if'式はつぎのように読める。

       (if (eq last-command 'kill-region)
           ;; 真の場合の動作
           (kill-append (buffer-substring beg end) (< end beg))
         ;; 偽の場合の動作
         (kill-new (buffer-substring beg end)))

関数`eq'は、第1引数が第2引数と同じLispオブジェクトかどうかを検査する。
関数`eq'は、等しいかどうかを検査する関数`equal'に似ているが、2つの表現
がコンピュータ内部で実際に同じオブジェクトかどうかを検査する。`equal'
は、2つの式の構造と内容が同じかどうかを検査する。

以前のコマンドが `kill-region' だったら Emacs Lisp インタープリタは関
数 `kill-append' を呼び出します．



File: emacs-lisp-intro-ja.info, Node: kill-append function, Next: kill-new function, Prev: last-command & this-command, Up: copy-region-as-kill body

関数`kill-append'
.................

関数`kill-append'はつぎのとおりである。

     (defun kill-append (string before-p)
       "Append STRING to the end of the latest kill in the kill ring.
     If BEFORE-P is non-nil, prepend STRING to the kill.
     If `interprogram-cut-function' is set, pass the resulting kill to
     it."
       (kill-new (if before-p
                     (concat string (car kill-ring))
                   (concat (car kill-ring) string))
                 t))

関数 `kill-append' はかなり単純である．この関数は関数`kill-new' を使用
し，すぐに詳細が分かるだろう．

最初に `kill-new' の2つの引数の1つである条件部分を見てみよう．関数
`setcar'は、キルリングのCARに新たなテキストを連結するために`concat'を
使っている。テキストを先頭に挿入するのか末尾に追加するのかは、`if'式の
結果に依存する。

     (if before-p                            ; 判定条件
         (concat string (car kill-ring))     ; 真の場合の動作
       (concat (car kill-ring) string))      ; 偽の場合の動作

直前のコマンドでキルしたリージョンの直前のリージョンをキルしたときには、
直前のキルで保存したテキストの先頭に挿入するべきである。逆に、直前にキ
ルしたリージョンの直後に続くテキストをキルした場合には、直前のテキスト
の末尾に追加するべきである。`if'式では、新たに保存するテキストを直前に
保存したテキストの先頭に挿入するか末尾に追加するかを述語`before-p'を用
いて決めている。

シンボル`before-p'は、`kill-append'の引数の名前の1つである。関数
`kill-append'が評価されると、実引数を評価した結果の値に束縛される。こ
こでは、式`(< end beg)'である。この式では、このコマンドでキルしたテキ
ストが直前のコマンドでキルしたテキストのまえにあるか、うしろにあるかを
直接には決定しない。変数`end'の値が変数`beg'の値より小さいかどうかのみ
を決定する。そうであった場合には、バッファの先頭に向けてである可能性が
高い。すると、述語式`(< end beg)'の評価結果は真となり、テキストは直前
のテキストの先頭に挿入される。一方、変数`end'の値が変数`beg'の値より大
きければ、テキストは直前のテキストの末尾に追加される。

新たに保存するテキストを先頭に挿入するときには、既存のテキストのまえに
新たなテキストを連結する。

     (concat string (car kill-ring))

テキストを追加する場合には、既存のテキストのうしろに連結する。

     (concat (car kill-ring) string))

この動作を理解するには、まず、関数`concat'を復習しておく必要がある。関
数`concat'は、2つの文字列を繋げる。結果も文字列である。たとえば、

     (concat "abc" "def")
          => "abcdef"

     (concat "new "
             (car '("first element" "second element")))
          => "new first element"

     (concat (car
             '("first element" "second element")) " modified")
          => "first element modified"

これで`kill-append'の動作を理解でき、キルリングの内容を変更することが
わかる。キルリングはリストであり、各要素は保存したテキストである。関数
`kill-append' は関数 `setcar' を使う代わりに，`kill-new' を使っている．



File: emacs-lisp-intro-ja.info, Node: kill-new function, Prev: kill-append function, Up: copy-region-as-kill body

関数 `kill-new'
...............

関数 `kill-new' は以下のようになる．

     (defun kill-new (string &optional replace)
       "Make STRING the latest kill in the kill ring.
     Set the kill-ring-yank pointer to point to it.
     If `interprogram-cut-function' is non-nil, apply it to STRING.
     Optional second argument REPLACE non-nil means that STRING will replace
     the front of the kill ring, rather than being added to the list."
       (and (fboundp 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))
       (if (and replace kill-ring)
           (setcar kill-ring string)
         (setq kill-ring (cons string kill-ring))
         (if (> (length kill-ring) kill-ring-max)
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
       (setq kill-ring-yank-pointer kill-ring)
       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

いつものようにこの関数を部分に分けてみていこう．

ドキュメントの最初の行には意味がある．

     Make STRING the latest kill in the kill ring.

しばらくドキュメントの残りは飛ばしていこう．

コードの `menu-bar-update-yank-menu' を呼び出している最初の2行も飛ばそ
う．そうすると，下記のように説明できる．

重要な行は下記である：

       (if (and replace kill-ring)
           ;; 真の場合には
           (setcar kill-ring string)
         ;; 偽の場合には
         (setq kill-ring (cons string kill-ring))
         (if (> (length kill-ring) kill-ring-max)
             ;; キルリングが溢れるのを避ける
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
       (setq kill-ring-yank-pointer kill-ring)
       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

条件部分は `(and replace kill-ring)' である．これは，2つの条
件が合致すれば真となる．つまり，キルリングが何かを含んでいて，変数
`replace' が真の時，この条件は真となる．

関数 `kill-append' は `replace' を真に設定する．そうして，キルリングが
少なくとも1要素を含んでいれば `setcar' 式が実行される．

     (setcar kill-ring string)

関数 `setcar' は実際に `kill-ring' の最初の要素を`string'の値に変更す
る．この関数は最初の要素を置き換える．

一方，キルリングが空であるか置換に失敗したなら，条件の偽の部分が実行さ
れる：

     (setq kill-ring (cons string kill-ring))
     (if (> (length kill-ring) kill-ring-max)
         (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))

この式はまずキルリングに `string' を新しい要素として先頭に追加すること
で新しいキルリングを構成する．そうして，2番目の `if' 文が実行される．
この2番目の `if' 文はキルリングが長くなりすぎるのを防いでいる．

これらの2つの式を順番に見ていこう．

偽の場合の動作の`setq'の行では、キルした文字列をもとのキルリングに追加
した結果をキルリングの新たな値に設定する。

つぎの例からこの動作を理解できる。

     (setq example-list '("here is a clause" "another clause"))

`C-x C-e'でこの式を評価してから、`example-list'を評価するとつぎのよう
な結果になる。

     example-list
          => ("here is a clause" "another clause")

このリストに新たな要素を追加するには、つぎの式を評価すればよい。

     (setq example-list (cons "a third clause" example-list))

`example-list'を評価すると、その値はつぎのとおりである。

     example-list
          => ("a third clause" "here is a clause" "another clause")

つまり、`cons'で「the third clause」をリストに追加したのである。

以上は、関数内で`setq'と`cons'とが行うことと同じである．その行を改めて
つぎに記しておく。

     (setq kill-ring (cons string kill-ring))

`if' 文の2番目へ進もう．この式はキルリングが長くなりすぎるのを防いでい
る．この部分は下記のようになっている．

     (if (> (length kill-ring) kill-ring-max)
         (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))

このコードでは、キルリングの長さが許された最大長よりも大きいかどうかを
検査する。最大長は`kill-ring-max'の値である（デフォルトは60）。キルリ
ングの長さが長すぎる場合には、キルリングの最後の要素を`nil'に設定する。
これには、2つの関数`nthcdr'と`setcdr'を使う。

`setcdr'についてはすでに説明した（*Note setcdr::）。`setcar'がリストの
CARを設定するように、`setcdr'はリストのCDRを設定する。しかし、ここでは
`setcdr'はキルリング全体のCDRを設定するのではない。関数`nthcdr'が使わ
れていて、キルリングの最後の要素の直前のCDRを設定するのである。つまり、
最後の要素の直前のCDRはキルリングの最後の要素であるから、キルリングの
最後の要素を設定することになる。

関数`nthcdr'は、リストのCDRを繰り返し取るように動作する。つまり、CDRの
CDRのCDRの...のCDRを取る。N回繰り返した結果を返す。

したがって、たとえば、4要素リストを3要素リストにするには、最後の要素の
直前のCDRを`nil'にしてリストを短くすればよい。

つぎの3つの式を順に評価すれば、これを理解できるであろう。まず、`trees'
の値として`(maple oak pine birch)'を設定する。つぎに、2つめのCDRのCDR
を`nil'にしてから、`trees'の値を見てみる。

     (setq trees '(maple oak pine birch))
          => (maple oak pine birch)

     (setcdr (nthcdr 2 trees) nil)
          => nil

     trees
          => (maple oak pine)

（`setcdr'式が返す値は、CDRを`nil'に設定したので、`nil'である。）

`kill-new'では、関数`nthcdr'は、キルリングの許された最大長引く1回だけ
CDRを取り、その要素（キルリングの残りの要素）のCDRに`nil'を設定する。
これにより、キルリングが長くなり過ぎるのを防ぐ。

関数`copy-region-as-kill'の最後の行の直前はつぎのとおりである。

     (setq kill-ring-yank-pointer kill-ring)

`kill-ring-yank-pointer' は `kill-ring' が設定されるグローバル変数であ
る．

`kill-ring-yank-pointer' は `pointer' と呼ばれるが，キルリングのような
変数である．しかし，変数がどのように使われるか理解しやすいように変数名
は選ばれた．この変数は `yank'や`yank-pop' (*Note Yanking Text Back:
Yanking.) のような関数で使われる．

関数の本体である最初の2行に話を戻そう．

       (and (fboundp 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))

これは最初の要素が関数 `and' である式である．

スペシャルフォーム `and' は 1つの引数が `nil' を返し，`and' 式が `nil' 
を返すまで順番に引数を評価する．しかし，どの引数も `nil' を返さなけれ
ば，最後の引数を評価した時の値が返ることになる．(そのような値は `nil' 
ではないので，Emacs Lisp では真と考える)．言い換えると，`and'式はその
引数が真であれば1つの真値だけを返すのである．．

この例では，最初に `menu-bar-update-yank-menu' が関数として存在するか
を確認する．もし存在すれば，それを呼ぶ．関数 `fboundp' はシンボルの関
数定義が"ボイド(無)で無ければ"真を返す．もしシンボルの関数定義が無であっ
たなら，わざとエラーを作成したように(*Note Generate an Error Message:
Making Errors.)，エラーメッセージが表示される．

要するに，`and' は以下のような `if' 式なのである．

     if THE-MENU-BAR-FUNCTION-EXISTS
       then EXECUTE-IT

`menu-bar-update-yank-menu' はメニューの Edit にある `Select and
Paste' を実現している関数の一つである．このメニューでは，マウスを使い，
以前にコピーしたさまざまなテキストを見て，貼り付けるものを選択できる．

最後に，関数 `kill-new' の最後の式はウィンドウシステム上の別のプログラ
ムでコピーやペーストができるように，新しくコピーした文字を保存します．
例えば，Xウィンドウシステムでは関数 `x-select-text' が文字列を取り，X 
で扱われるメモリに保存します．これで，Xtermのような他のプログラムでペー
ストできる．

この式は以下のようである．

       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

`interprogram-cut-function' が存在すると，Emacs は `funcall' をある関
数を第1引数，残りの引数を渡して実行します．(ついでに，私が見る限りでは，
この `if' 式はこの関数の最初の部分と同様に `and' 式で置き換えることが
できる．)

ここで，ウィンドウシステムや他のプログラムについて説明するつもりはない．
ここでは単に，GNU Emacs が他のプログラムと簡単にうまく機能できるような
仕組みであるとだけ覚えておいて欲しい．

This code for placing text in the kill ring, either concatenated with
an existing element or as a new element, leads us to the code for
bringing back text that has been cut out of the buffer--the yank
commands.  However, before discussing the yank commands, it is better
to learn how lists are implemented in a computer.  This will make
clear such mysteries as the use of the term `pointer'.  テキストをキル
リングに，既存の要素に連結するか，新しい要素として，追加し、バッファか
ら切り取ったテキストを復元するヤンクコマンドのコードの説明に進める。し
かし、ヤンクコマンドを説明するまえに、コンピュータでのリストの実装方法
を学んでおくのがよいであろう。そうすれば、「ポインタ」などの用語の不可
解さが明らかになる。



File: emacs-lisp-intro-ja.info, Node: cons & search-fwd Review, Next: search Exercises, Prev: copy-region-as-kill, Up: Cutting & Storing Text

復　習
======

これまでに説明した関数のいくつかを以下にまとめておく。

`car'
`cdr'
     `car'はリストの先頭要素を返す。`cdr'はリストの2番目以降の要素を返
     す。

     たとえば、

          (car '(1 2 3 4 5 6 7))
               => 1
          (cdr '(1 2 3 4 5 6 7))
               => (2 3 4 5 6 7)

`cons'
     `cons'は、第1引数を第2引数のまえに置いたリストを作る。

     たとえば、

          (cons 1 '(2 3 4))
               => (1 2 3 4)

`nthcdr'
     リストに`cdr'を「n」回適用した結果を返す。

     たとえば、

          (nthcdr 3 '(1 2 3 4 5 6 7))
               => (4 5 6 7)

`setcar'
`setcdr'
     `setcar'はリストの先頭要素を変更する。`setcdr'はリストの2番目以降
     の要素を変更する。

     たとえば、

          (setq triple '(1 2 3))

          (setcar triple '37)

          triple
               => (37 2 3)

          (setcdr triple '("foo" "bar"))

          triple
               => (37 "foo" "bar")

`progn'
     引数を順番に評価し、最後のものの値を返す。

     たとえば、

          (progn 1 2 3 4)
               => 4

`save-restriction'
     カレントバッファで有効になっているナロイングを記録し、引数を評価
     し終えたら、もとのナロイングに戻す。

`search-forward'
     文字列を探し、それがみつかればポイントを移動する。

     4つの引数を取る。

       1. 探すべき文字列。

       2. 探索範囲の制限。省略できる。

       3. 探索に失敗した場合に`nil'を返すかエラーメッセージを返すか指
          定する。省略できる。

       4. 探索を何回行うかを指定する。省略できる。負の場合には、逆向き
          に（先頭へ向けて）探索する。

`kill-region'
`delete-region'
`copy-region-as-kill'

     `kill-region'は、ポイントとマークのあいだのテキストをバッファから
     切り取り、ヤンクで復元できるように、キルリングにそのテキストを保
     存する。

     `delete-and-extract-region' は、ポイントとマークのあいだのテキス
     トをバッファから取りさり、破棄する。復元することはできない。

     `copy-region-as-kill'はポイントとマークのあいだのテキストをキルリ
     ングにコピーし、キルリングからそのテキストを復元できるようにする。
     この関数は、バッファからテキストを取りさったりしない。



File: emacs-lisp-intro-ja.info, Node: search Exercises, Prev: cons & search-fwd Review, Up: Cutting & Storing Text

探索の演習問題
==============

   * 文字列を探す対話的関数を書いてみよ。文字列を探しあてた場合には、
     その直後にポイントを移動してメッセージ「Found!」を表示する（この
     関数の名前には`search-forward'を使わないこと。さもないと、Emacsの
     既存の`search-forward'を書き換えてしまう。かわりに、`test-search'
     のような名前を使う）。

   * キルリングに第3要素があれば、それをエコー領域に表示する関数を書い
     てみよ。キルリングに第3要素がなければ、適切なメッセージを表示せよ。



File: emacs-lisp-intro-ja.info, Node: List Implementation, Next: Yanking, Prev: Cutting & Storing Text, Up: Top

リストの実装方法
****************

Lispでは、アトムは単純な方法で記録されている。現実の実装が単純ではない
としても、理論的には単純である。たとえば、アトム`rose'は、`r'、`o'、
`s'、`e'の4つの連続した文字として記録されている。一方で、リストは異なっ
た方法で記録されている。その機構は同様に単純であるが、その考え方に慣れ
るには時間がかかる。リストは一連のポインタ対を用いて記録されている。ポ
インタ対の最初のポインタはアトムやリストを指し、ポインタ対の2番目のポ
インタはつぎの対やシンボル、あるいは、リストの終わりを表す`nil'を指す。

ポインタ自身は、とても単純で、それが指すもののアドレスである。したがっ
て、リストは一連のアドレス対として記録される。

* Menu:

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::



File: emacs-lisp-intro-ja.info, Node: Lists diagrammed, Next: Symbols as Chest, Prev: List Implementation, Up: List Implementation

リストの図解
============

たとえば、リスト`(rose violet buttercup)'には3つの要素、`rose'、
`violet'、`buttercup'がある。コンピュータ内部では、`rose'のアドレスは、
アトム`violet'の場所を示すアドレスを与えるアドレスとともにメモリに記録
されている。（`violet'の場所を示す）アドレスは、アトム`buttercup'の場
所を示すアドレスを与えるアドレスとともに記録されている。

複雑に聞こえるであろうが、図で表せば簡単である。

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup



図では、各箱は、メモリアドレス形式のLispオブジェクトを保持するコンピュー
タのメモリを表す。箱、つまり、アドレスは対になっている。各矢印は、アト
ムや他のアドレスの対のアドレスで表されるものを指す。最初の箱は`rose'の
アドレスであり、矢印は`rose'を指す。2番目の箱は、つぎの箱の対のアドレ
スであり、その先頭部分は`violet'のアドレスであり、2番目の部分はつぎの
対のアドレスである。最後の箱はシンボル`nil'を指し、リストの終わりを表
す。

`setq'などの関数で変数にリストを設定すると、変数には最初の箱のアドレス
を設定する。つぎの式

     (setq bouquet '(rose violet buttercup))

を評価するとつぎのような状況になる。

     bouquet
          |
          |     ___ ___      ___ ___      ___ ___
           --> |___|___|--> |___|___|--> |___|___|--> nil
                 |            |            |
                 |            |            |
                  --> rose     --> violet   --> buttercup



この例では、シンボル`bouquet'は、最初の箱の対のアドレスを保持する。

同じリストを異なる箱表記方法で示すこともできる。

     bouquet
      |
      |    --------------       ---------------       ----------------
      |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
       -->| rose  |   o------->| violet |   o------->| butter- |  nil |
          |       |      |     |        |      |     | cup     |      |
           --------------       ---------------       ----------------



(リストであるようなシンボルは多くのアドレスのペアからなる．しかし，個々
のシンボルの構造はアドレスである．シンボル `bouquet' はアドレスを入れ
た箱のグループからなり，1つは `bouquet' のアドレス，2つ目はシンボルに
割り当てられた関数定義のアドレス，3番目はリスト `(rose violet
buttercup)' の最初のペアのアドレスを入れた箱のアドレスなどとなっている．
ここで，シンボルの3番目のアドレスはリストのアドレス箱の最初のペアを指
している)

シンボルにリストのCDRを設定しても、リスト自体は変わらない。シンボルは
リストを辿ったアドレスを持つだけである（専門用語では、CARやCDRは「非破
壊的」である）。したがって、つぎの式を評価すると

     (setq flowers (cdr bouquet))

つぎのようになる。


     bouquet        flowers
       |              |
       |     ___ ___  |     ___ ___      ___ ___
        --> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
               --> rose       --> violet   --> buttercup




`flowers'の値は`(violet buttercup)'であり、つまり、シンボル`flowers'は、
`violet'のアドレスを最初の箱に、`buttercup'のアドレスを2番目の箱に持つ
ような箱の対のアドレスを保持する。

アドレスを収めた箱の対を"コンスセル（cons cell）"とか"ドットペアー
（dotted pair）"と呼ぶ。コンスセルやドットペアーについて詳しくは、
*Note Dotted Pair Notation: (elisp)Dotted Pair Notationや*Note List
Type: (elisp)List Type。

関数`cons'は、上に示した一連のアドレスのまえにアドレスの新たな対を加え
る。たとえば、つぎの式

     (setq bouquet (cons 'lily bouquet))

を評価すると、つぎのようになる。


     bouquet                       flowers
       |                             |
       |     ___ ___        ___ ___  |     ___ ___       ___ ___
        --> |   |   |      |   |   |  --> |   |   |     |   |   |
            |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
              |              |              |             |
              |              |              |             |
               --> lily      --> rose       --> violet    --> buttercup




しかし、つぎの式を評価するとわかるように、これによりシンボル`flowers'
の値が変更されることはない。

     (eq (cdr (cdr bouquet)) flowers)

は、真を表す`t'を返す。

再設定しない限り、`flowers'の値は`(violet buttercup)'である。つまり、
`flowers'は、最初の部分に`violet'のアドレスを収めたコンスセルのアドレ
スを持つ。さらに、すでに存在するいかなるコンスセルも変更しない。それら
はそのまま存続する。

したがって、LispでリストのCDRを取り出すと、一連のコンスセルの中のつぎ
のコンスセルのアドレスを得るのである。リストのCARを取り出すと、リスト
の先頭要素のアドレスを得る。新たな要素をリストに`cons'すると、リストの
まえに新たなコンスセルを置くのである。以上がすべてである。Lispの根底に
ある構造は、とても単純なのである。

一連のコンスセルの最後のアドレスは何を指すのであろう？　それは空リスト、
つまり、`nil'のアドレスである。

まとめると、Lispの変数に値を設定すると、変数が参照するリストのアドレス
が設定される。



File: emacs-lisp-intro-ja.info, Node: Symbols as Chest, Next: List Exercise, Prev: Lists diagrammed, Up: List Implementation

箪笥の引き出しに見立てたシンボル
================================

始めの節では、シンボルを箪笥と考えればよいと述べた。関数定義はある引き
出しに入れてあり、値は別の引き出しに入れてあるのである。関数定義を収め
た引き出しの中身を変えることなく、値を収めた引き出しの中身を変更でき、
その逆もそうである。

実際、各引き出しに収められているのは、値や関数定義のアドレスである。屋
根裏部屋でみつけた古い箪笥の引き出しから、宝物を埋めた場所を記した地図
をみつけるようなものである。

（シンボルには、名前、関数定義、値に加えて、その他の情報を記録するため
の"属性リスト（property list）"を収める引き出しもある。ここでは属性リ
ストについては説明しないので、*Note Property Lists: (elisp)Property
Listsを参照。）

Here is a fanciful representation: 仮想的な表現をつぎに示す。


                  箪笥の引き出し                 引き出しの中身

                 __   o0O0o   __
               /                 \
              ---------------------
             |    シンボル名の     |            [map to]
             |       場所          |             bouquet
             |                     |
             +---------------------+
             |     関数定義の      |
             |       場所          |             なし
             |                     |
             +---------------------+
             |      変数の値の     |            [map to]
             |         場所        |             (rose violet buttercup)
             |                     |
             +---------------------+
             |    属性リストの     |
             |        場所         |             [本書では説明しない]
             |                     |
             +---------------------+
             |/                   \|




変数`kill-ring'と変数`kill-ring-yank-pointer'のどちらもポインタである。
しかし、キルリング自体は、実際にその要素から構成されている。
`kill-ring'は、リストを指すというよりは、リストそのもののようにいう。
逆に、`kill-ring-yank-pointer'はリストを指すというようにいう。

同じものを2つの異なる方式で呼ぶのは、最初は、混乱のもとであるが、熟考
すると意味のあることがわかる。キルリングは、Emacsバッファから切り取っ
た情報を保持する完全なデータ構造を一般的に意味する。一方で、
`kill-ring-yank-pointer'は、挿入される先頭要素（CAR）となるキルリング
の部分を指すのである。

関数`rotate-yank-pointer'は、`kill-ring-yank-pointer'が指すキルリング
の要素を変更する。キルリングの最後の要素のつぎを指すようなときには、自
動的にキルリングの先頭要素を指すようにする。このようにしてリストをリン
グに変換している。関数`rotate-yank-pointer'自体のコードは難しくはない
が、こまごましたことを含む。この関数と、さらに簡単な関数`yank'と
`yank-pop'は、付録で説明する。*Note Kill Ring::。



File: emacs-lisp-intro-ja.info, Node: yank nthcdr Exercises, Prev: kill-ring-yank-pointer, Up: Yanking

`yank'と`nthcdr'の演習問題
==========================

   * `C-h v'（`describe-variable'）を使って、読者のキルリングの内容を
     調べてみよ。キルリングにいくつか項目を追加してから、その値を再度
     調べてみよ。`M-y'（`yank-pop'）を使って、キルリング全体を調べてみ
     よ。読者のキルリングには項目はいくつあるか？　`kill-ring-max'の値
     を調べてみよ。読者のキルリングは満杯になっているか、あるいは、テ
     キスト断片をさらに保存できるかどうかを調べてみよ。

   * `nthcdr'と`car'を使って、リストの先頭要素、第2要素、第3要素、第4
     要素を返す一連の式を作ってみよ。



File: emacs-lisp-intro-ja.info, Node: Loops & Recursion, Next: Regexp Search, Prev: Yanking, Up: Top

ループと再帰
************

Emacs Lispには、式や一連の式を繰り返し評価する主要な方法が2つあり、
`while'ループを使う方法と"再帰（recursion）"を使う方法である。

繰り返しはとても重要である。たとえば、4つの文だけ先へ進むには、1つの文
のみ先へ進むだけのプログラムを書き、それを4回繰り返せばよい。人間は繰
り返し回数をまちがえたり処理を誤ったりするが、コンピュータが飽きたり疲
れたりすることはないので、繰り返し動作が有害な結果を生むことはない。

問題を解決したりするのにとてもパワフルな再帰を使うことは可能だが (1)
(*Note Loops & Recursion-Footnotes::)，ほとんどの人は `while' ループや
同種の関数を使って Emacs Lisp 関数を書く．

* Menu:

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::


File: emacs-lisp-intro-ja.info  Node: Loops & Recursion-Footnotes, Up: Loops & Recursion

(1) 精神的にもコンピュータのリソース的にも節約し無駄を省くために，再帰
関数を書くことは可能である．たまたま，精神的に楽をするために，容易に思
い付く方法を使うと，時にコンピュータのリソースを非常に多く使ってしまう
ことがある．Emacs は今となっては古いマシンでも動作させるために，デフォ
ルトの設定値で機能的に制限してある．`max-specpdl-size' や 
`max-lisp-eval-depth' を変更したくなるかもしれない．私の 
`.emacs' ファイルでは，デフォルト値の15〜30番の値に変更してある



File: emacs-lisp-intro-ja.info, Node: while, Next: dolist dotimes, Prev: Loops & Recursion, Up: Loops & Recursion

`while'
=======

スペシャルフォーム`while'は、第1引数を評価した結果が真か偽かを検査する。
これは、Lispインタープリタが`if'に対して行うことに似ているが、その検査
後にインタープリタが行うことは異なる。

`while'式では、第1引数を評価した結果が偽ならば、Lispインタープリタは式
の残りの部分（式の"本体"）を飛び越し、それらを評価しない。しかし、値が
真ならば、Lispインタープリタは式の本体を評価し、再度、第1引数が真か偽
かを検査する。第1引数を再度評価した結果が真ならば、Lispインタープリタ
は式の本体を再度評価する。

`while'式の雛型はつぎのとおりである。

     (while 判定条件
       本体...)

* Menu:

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A `while' loop that uses a list.
* print-elements-of-list::      Uses `while', `car', `cdr'.
* Incrementing Loop::           A loop with an incrementing counter.
* Decrementing Loop::           A loop with a decrementing counter.



File: emacs-lisp-intro-ja.info, Node: Looping with while, Next: Loop Example, Prev: while, Up: while

`while' を使ったループ
----------------------

評価したときに`while'式の判定条件が真を返す限り、本体を繰り返し評価す
る。飛行機が旋回（ループ）するように、Lispインタープリタが同じことを何
度も何度も繰り返すので、この処理をループと呼ぶ。判定条件の評価結果が偽
ならば、Lispインタープリタは`while'式の残りを評価せず「ループから出る」。

明らかに、`while'の第1引数の評価結果がつねに真ならば、それに続く本体は
何度も何度も...何度も...永久に評価される。逆に、評価結果がけっして真に
ならなければ、本体の式はけっして評価されない。`while'ループを書く工程
は、続く式を評価したい回数だけ真を返し、そのあとは偽を返すような判定条
件を選ぶことである。

`while'を評価した結果返される値は、判定条件の値である。この帰結として
興味深いことは、エラーなしに評価される`while'ループは、1回繰り返そうが
100回繰り返そうがまったく繰り返さなくても、`nil'、つまり、偽を返すこと
である。正しく評価できた`while'式は、けっして真を返さない！　つまり、
`while'はつねに副作用のために評価されるのであり、`while'ループの本体の
式を評価した効果だけのためである。これは意味のあることである。ほしいの
は単なる繰り返し動作ではなく、ループの式を繰り返し評価したときの効果が
ほしいのである。



File: emacs-lisp-intro-ja.info, Node: Loop Example, Next: print-elements-of-list, Prev: Looping with while, Up: while

A `while' ループとリスト
------------------------

`while'ループを制御する一般的な方法は、リストに要素があるかどうかを検
査することである。要素があればループを繰り返すが、要素がなければ繰り返
しを終える。これは重要な技法なので、例示のために短い例を作ることにする。

リストに要素があるかどうかを検査する簡単な方法は、リストを評価すること
である。要素がなければ、空リストであるから空リスト`()'が返され、これは
偽を意味する`nil'の同義語である。一方、リストに要素があれば、評価する
とこれらの要素を返す。Emacs Lispインタープリタは、`nil'以外の値を真と
解釈するので、要素を返すリストは`while'ループの検査では真になる。

たとえば、つぎの`setq'式を評価すれば、変数`empty-list'に`nil'を設定で
きる。

     (setq empty-list ())

`setq'式を評価しておけば、いつものようにシンボルの直後にカーソルを置い
て`C-x C-e'とタイプすれば変数`empty-list'を評価できる。エコー領域には
`nil'と表示される。

     empty-list

一方、つぎの2つの式を評価するとわかるように、要素を持つリストを変数に
設定して、その変数を評価するとリストが表示される。

     (setq animals '(gazelle giraffe lion tiger))

     animals

したがって、リスト`animals'に要素があるかどうかを検査する`while'ループ
を書くと、ループの始めの部分はつぎのようになる。

     (while animals
            ...

`while'が第1引数を検査するとき、変数`animals'が評価される。これはリス
トを返す。リストに要素がある限り、`while'は検査結果は真であると解釈す
る。しかし、リストが空になると検査結果は偽であると解釈する。

`while'ループが永久に廻り続けるのを防ぐには、最終的にリストが空になる
ような機構を与える必要がある。しばしば使われる技法は、`while'式の中の
式の1つで、リストの値にリストのCDRを設定することである。関数`cdr'を評
価するたびに、リストは短くなり、最終的には空リストになる。その時点で
`while'ループの検査は偽を返し、`while'の引数はそれ以上評価されなくなる。

たとえば、つぎの式で、動物のリストを束縛した変数`animals'にもとのリス
トのCDRを設定できる。

     (setq animals (cdr animals))

まえの式を評価してからこの式を評価すると、エコー領域に `(giraffe lion
tiger)' と表示される。この式を再度評価すると、エコー領域に`(lion
tiger)'と表示される。さらに評価すると`(tiger)'となり、さらに評価すると
空リストになり`nil'と表示される。

関数`cdr'を繰り返し使って最終的に判定条件が偽になるような`while'ループ
の雛型はつぎのようになる。

     (while リストが空かどうか検査
       本体...
       リストのCDRをリストに設定)

この検査と`cdr'の利用は、リスト全体を調べてリストの各要素を1行に表示す
る関数で使える。



File: emacs-lisp-intro-ja.info, Node: print-elements-of-list, Next: Incrementing Loop, Prev: Loop Example, Up: while

例：`print-elements-of-list'
----------------------------

関数`print-elements-of-list'はリストを用いた`while'ループの例である。

この関数は、複数行出力する。Emacs 21 かそれ以上のバージョンでこのマニュ
アルを読んでいるなら，いつものようにInfo 上で続く式を評価できる．

もしEmacs の古いバージョンを使っているのであれば，必要な式を
`*scratch*' バッファにコピーして，そこで評価する必要がある．これは古い
バージョンのEmacsではエコー領域が1行しか無いためである．

式をコピーするには、リージョンの始めを`C-SPC'（`set-mark-command'）で
マークし、カーソルをリージョンの終わりに移動してから、`M-w'
（`copy-region-as-kill'）を使ってリージョンをコピーする。つぎに、バッ
ファ`*scratch*'にて、`C-y'（`yank'）とタイプすればその式を取り出せる。

バッファ`*scratch*'に式をコピーしてから、各式を順番に評価する。最後の
式`(print-elements-of-list animals)'は、必ず、`C-u C-x C-e'とタイプし
て、つまり、`eval-last-sexp'に引数を与えて評価すること。これにより、評
価結果は、エコー領域ではなく、バッファ`*scratch*'に表示される（さもな
いと、エコー領域には、`^Jgiraffe^J^Jgazelle^J^Jlion^J^Jtiger^Jnil' の
ように表示される。ここで、`^J'は改行のことである．)

もしEmacs 21以降を使っていれば，これらの式をInfoバッファで直接評価し，
エコー領域で結果を見ることができる．

     (setq animals '(gazelle giraffe lion tiger))

     (defun print-elements-of-list (list)
       "Print each element of LIST on a line of its own."
       (while list
         (print (car list))
         (setq list (cdr list))))

     (print-elements-of-list animals)

When you evaluate the three expressions in sequence, you will see
this: 3つの式を順番に評価すると、つぎのように表示される。

     giraffe

     gazelle

     lion

     tiger
     nil

リストの各要素が（関数`print'の動作により）1行に表示され、最後に関数が
返した値が表示される。関数の最後の式は`while'ループであり、`while'ルー
プはつねに`nil' を返すので、リストの最後の要素のあとに、`nil'が表示さ
れる。



File: emacs-lisp-intro-ja.info, Node: Incrementing Loop, Next: Decrementing Loop, Prev: print-elements-of-list, Up: while

増加カウンタによるループ
------------------------

終了すべきときに止まらないループは無意味である。ループをリストで制御す
る以外に、ループを止める一般的な方法は、必要回数の繰り返しを完了したら
偽を返すような第1引数を書くことである。つまり、ループにカウンタ、ルー
プの繰り返し回数を数える式を持たせるのである。

`(< count desired-number)'のように判定条件を記述すれば、`count'の値が
繰り返し回数`desired-number'より小さければ真を返し、`count'の値が
`desired-number'に等しいか大きければ偽を返す。カウンタを増加させる式は
`(setq count (1+ count))'のような簡単な`setq'でよく、`1+'は引数に1を加
えるEmacs Lispの組み込み関数である（式`(1+ count)'は、`(+ count 1)'と
同じ結果をもたらし、人間にも読みやすい）。

カウンタを増加して制御する`while'ループの雛型はつぎのようになる。

     SET-COUNT-TO-INITIAL-VALUE
     (while (< count desired-number)         ; 判定条件
       BODY...
       (setq count (1+ count)))              ; 1増やす

`count'の初期値を設定する必要があることに注意してほしい。普通は1に設定
する。

* Menu:

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.



File: emacs-lisp-intro-ja.info, Node: Incrementing Example, Next: Inc Example parts, Prev: Incrementing Loop, Up: Incrementing Loop

増加カウンタの例
................

浜辺で遊んでいるときに、つぎに示すように、最初の行には小石を1個、つぎ
の行には2個、そのつぎの行には3個というように、小石で三角形を作ろうと考
えたとする。


                    *
                   * *
                  * * *
                 * * * *


（約2500年前に、ピタゴラスや他の人達は、このような問題を考察して数論の
始まりを築いた。）

7行の三角形を作るには何個の小石が必要か知りたいとしよう。

明らかに、必要なことは数1から7までを加算することである。これには2つの
方法がある。最小数1から始めて、1、2、3、4のように加算する。あるいは、
最大数から始めて、7、6、5、4のように加算する。いずれの方法も、`while'
ループを書く一般的な方法の例示になるので、増やしながらの加算と減らしな
がらの加算の2つの例を書くことにする。まずは、1、2、3、4と加算する例か
ら始める。

数個の数を加算するだけならば、もっとも簡単な方法は、それらをいっきに加
算することである。しかし、あらかじめ何個の数を加算するかわかっていなかっ
たり、非常に多くの数の加算にも対処したければ、複雑な処理をいっきに行う
のではなく、単純な処理を繰り返すような加算にする必要がある。

たとえば、小石の個数をいっきに加算するかわりに、最初は1行目の小石の個
数1を2行目の個数2に加え、これらの総和を3行目の個数3に加える。つぎに、4
行目の個数4を1行目から3行目までの総和に加えるということを繰り返す。

処理の重要な点は、繰り返しの各段階の動作は単純であることである。この例
では、各段階では、2つの数、つまり、その行の小石の個数とそれまでの総和
を加算するだけである。最後の行をそれまでの総和に加算するまで、2つの数
の加算処理を繰り返し繰り返し実行するのである。より複雑なループでは、各
段階の動作は単純ではないかもしれないが、すべてをいっきに行うよりは簡単
である。



File: emacs-lisp-intro-ja.info, Node: Inc Example parts, Next: Inc Example altogether, Prev: Incrementing Example, Up: Incrementing Loop

関数定義の各部分
................

以上の分析により、関数定義の骨格がわかる。まず、小石の総数を保持する変
数`total'が必要である。これは、関数が返す値である。

つぎに、関数には引数が必要である。この引数は三角形の行数である。これを
`number-of-rows'としよう。

最後に、カウンタとして使う変数が必要である。この変数を`counter'と命名
してもよいが、より適した`row-number'を使おう。カウンタが数えるのは行数
であり、プログラムではできる限りわかりやすい名前を使うべきだからである。

Lispインタープリタが関数内の式の評価を始めるときには、`total'には何も
加算していないので、`total'の値は0になっているべきである。続いて、関数
では、1行目の小石の個数を総和に加算し、2行目の小石の個数を総和に加算し、
3行目の小石の個数を総和に加算し、ということを、加算すべき行がなくなる
まで行う。

`total'と`row-number'のどちらも、関数の内部だけで使うので、`let'でロー
カル変数として宣言し初期値を与える。明らかに、`total'の初期値は0である。
また、第1行から始めるので、`row-number'の初期値は1である。つまり、
`let'文はつぎのようになる。

       (let ((total 0)
             (row-number 1))
         本体...)

内部変数を宣言しそれらに初期値を束縛したら、`while'ループを始められる。
判定条件の式は、`row-number'が`number-of-rows'より小さいか等しい限りは
真を返す必要がある（行の番号が三角形の行数より小さい場合に限り真を返す
判定条件だと、最後の行が総和に加算されない。したがって、行の番号は三角
形の行数より小さいか等しい必要がある）。

Lispには、第1引数が第2引数より小さいか等しいときに真を返し、それ以外の
ときには偽を返す関数`<='がある。したがって、`while'が判定条件として評
価する式はつぎのようになる。

     (<= row-number number-of-rows)

小石の総数は、すでにわかっている総数に行の小石の個数を加算することを繰
り返して計算できる。行の小石の個数はその行の番号に等しいので、総数は、
総数に行番号を加算すれば計算できる（より複雑な状況では、行の小石の個数
は、より複雑な方法で行の番号に関係する。そのような場合には、行の番号を
適当な式で置き換える）。

     (setq total (+ total row-number))

これにより、`total'の新たな値は、行の小石の個数をそれまでの総数に加え
たものになる。

`total'の値を設定したあと、ループのつぎの繰り返しのための条件を確立す
る必要がある。これには、カウンタとして働く変数`row-number'の値を増やせ
ばよい。変数`row-number'を増やしたあと、`while'ループの判定条件により、
その値が`number-of-rows'より小さいか等しいかどうか検査する。もしそうな
らば、変数`row-number'の新たな値をループのまえの段階での`total'に加え
る。

Emacs Lispの組み込み関数`1+'は数に1を加えるので、つぎの式で変数
`row-number'を増加できる。

     (setq row-number (1+ row-number))



