Info file: flex-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `flex-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.
















This file documents Version 2.3.7 - 2.5.4 of the Flex lexical scanner
generator.

This is Edition 1.03, February 1993, 
of the `Flex Version 2.3.7 - 2.5.4 Manual'.

Copyright (C) 1992, 1993 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.








File: flex-ja.info, Node: Top, Next: Introduction, Prev: (dir), Up: (dir)

Flex
****

Flexは、入力として高級記述言語を受け取り、出力としてC言語で記述された
スキャナを生成する、字句スキャナ生成プログラムです。Flex自身が、標準の
Unixユーティリティと比較してより高速に動作しますし、生成されるスキャナ
もより高速です。また、POSIX、Lexとの互換性も十分備えています。

これは、1993年2月発行、エディション1.03のFlex 2.3.7マニュアルです。
Flex 2.5の新機能に関する情報も追加してあります。Flex 2.5の新機能に関す
る節の名前には、「（Flex 2.5の補足情報）」と書かれています。

============================================================================
* Menu:

* Introduction:: Flexの必要性とその機能* Invoking Flex:: Flexの起動方
法、コマンドライン・オプション* Flex Descriptions:: Flex記述言語*
Interfacing to Flex:: FlexスキャナとC言語の結合* Other Flex Features:: 
追加的なFlex機能、一般的ではないFlex機能* Optimization:: Flexスキャナ
の最適化方法* More Examples:: Flexを使うための実例* Flex and Lex::
FlexとLexの相違点、性能、POSIX標準への準拠度* Useful Code:: ユーザ・ス
キャナの中で使うことのできるコード* Summary:: オプション、変数などの要
約* Index:: インデックス

 -- The Detailed Node Listing ---

Flex入門

* Problem Solving::             問題解決手段としてのFlex
* General Programming::         一般的なプログラミング・ツールとしてのFlex

Flexの起動

* Command Line Switches::       Flexのコマンドライン・オプション
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）

Flex記述言語

* Comments::                    Flexのコメント・スタイルの説明
* Optional C Code::             Flex定義の先頭のCコード・セクションの説明
* Definitions::                 Flexにおける定義の書き方
* %%::                          区切り文字%%の意味
* Rules::                       Flexファイルのルール・セクション
* Pattern Matching::            パターン・マッチングに使われる部分
* Regular Expressions::         パターンのマッチング
* Start States::                ある条件にもとづいてパターン・マッチング・
                                ルールを活性化させる方法
* %option (Flex 2.5)::          %option指示子の説明

パターン・セクション

* Characters::                  Flexにおける文字、特殊文字
* Strings::                     Flexにおける文字列、特殊文字列
* Character Classes::           文字クラスの説明、その使い方
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）

スタート状態

* Start States Explained::      スタート状態の宣言、スキャナに対する効果
* Activating States::           スタート状態の活性化方法
* Start State Notes::           不当な宣言、排他的スタート状態のパワーに
                                関する注
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
* Start State Example::         スタート状態の使用例

Flexとのインターフェイス

* Flex and C::                  CとFlexのインターフェイス
* Flex and C (Flex 2.5)::       同上（Flex 2.5の補足情報）
* An Example of Flex and C::    フィルタにおける文字列代替
* Flex and Bison::              FlexとBisonの協同
* Another Example of Flex and Bison::  FlexとBisonのもう１つの実例
* Flex and C++ (Flex 2.5)::     C++とFlexのインターフェイス
                                （Flex 2.5の補足情報）

FlexとBison

* Interfacing Flex and Bison::  一般的な方法
* YYSTYPE and yylval::          単なる整数以上の情報の渡し方

FlexとBisonのもう１つの実例

* The Database Language::       データベース言語の定義
* The Implementation::          言語を解析するファイル
* Notes on the Implementation:: この実装を選択した理由に関する（簡単な）注

Flexの他の特徴

* Case Insensitive Scanners::   大文字・小文字を区別するスキャナ
* Interactive Scanners::        ユーザから入力を受け取るスキャナ
* Table Compression and Scanner Speed::  テーブル圧縮とスキャナのスピード
* Translation Tables::          文字をグループ化する別の方法
* Multiple Input Buffers::      複数の入力ストリームを受け付ける方法
* End-Of-File Rules::           EOFを処理するための特殊なルール

大文字・小文字を区別しないスキャナ

* The -i Switch::               入力において大文字・小文字を無視する方法

複数の入力バッファ

* Buffer Manipulation::         バッファ操作関数
* Buffer Manipulation (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Example of Multiple Buffers::  複数バッファを使う実例

スキャナの最適化

* Optimizing for Speed::        ファスト・スキャナを作るためのフラグ、
                                関連するトピック
* Optimizing for Size::         サイズの小さいスキャナの作り方

スピードの最適化

* Removing Backtracking::       バックトラッキングの除去による性能の
                                飛躍的向上

Flexを使うその他の実例

* Example-Counting Words::      wc風のユーティリティ
* Example-Pascal Lexical Scanner::  本物の言語をスキャンする実例
* Example-Jargon Converter::    専門用語ファイルのTexinfo形式への変換

FlexとLex

* Flex::                        Flex
* Lex::                         Lex

Flex 

* Flex and POSIX::              FlexとPOSIX
* Flex and POSIX (Flex 2.5)::   FlexとPOSIX（Flex 2.5の補足情報）

役に立つコードの抜粋

* Handling Comments::           コメントの処理
* Handling Strings::            文字列の処理
* Handling Numbers::            数値の処理
* Multiple Scanners::           複数のスキャナ
* Miscellaneous::               その他

要約

* Switches Summary::            Flexコマンドライン・オプションの要約
* Switches Summary (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Summary or Flex Variables and Functions::  Flex変数、Flex関数の要約
* Summary or Flex Variables and Functions (Flex 2.5)::
                                             同上（Flex 2.5の補足情報）
* Summary of Flex Characters::  演算子、特殊文字、エスケープ・シーケンス
                                以外の文字をその文字自身として受け付ける
* Summary of Flex Rules::       Flexルールの２つの構成要素

========================================================================







File: flex-ja.info, Node: Introduction, Next: Invoking Flex, Prev: Top, Up: Top

Flex入門
********

     この章では字句スキャン処理の概念を紹介し、Flexのようなツールの必
     要性を指摘します。この章の後半部分でFlexを紹介し、Flexを使うこと
     のできる状況の実例をいくつか紹介します。

UnixおよびCの世界では、ファイルは通常個々のバイトが連続したものとして
扱われます。個々のバイトを集めてどのようにグループ化するかという点は、
プログラマが決めることです。このような抽象化は非常に強力です。というの
は、どのようなファイルであってもこの抽象化方法によって表現することがで
きるからです。しかしこの方法には短所もあり、プログラマはほとんど常に生
のファイルに対して構造をあてはめなければなりません。言葉を変えると、ファ
イルをより意味のある部分に分割しなければならないということです。例えば、
コンパイラのある部分はファイルから連続した文字を受け取り、構文チェッカ
が理解することのできる構成要素、例えば、数値、キーワード、文字列などに
グループ化します。このようなことを行う理由は、コンパイラの言語パーサが
処理を行うのは、連続した文字に対してではなく、その言語のシンボルが連続
したものに対してだからです。

データベース・アプリケーションや、バイナリ・ファイルを扱うアプリケーショ
ンは、扱うデータに対してある固定されたフォーマットというものを持ってい
ることが多く、そのフォーマットを使って入力データから意味を導き出します。
テキストを入力するプログラムは通常これとは反対で、入力を単語やシンボル
に分割しなければならないことが多いのですが、通常これらの単語やシンボル
がどのように配置されているかを示す決まった構造というものは存在しません。
したがって、テキスト処理を行うプログラムは、入力された情報を意味のある
シンボルに分割するために、"字句解析"もしくは"字句スキャン"と呼ばれる処
理を行う部分を持っていることが多く、そこで入力情報の分割が行われます。
このようなことを行う関数群のことを字句アナライザもしくは字句スキャナ、
あるいは短く「スキャナ」と呼びます。

一般的に、スキャナを作成するのは、プログラマにとって難しいことでも面白
いことでもないのですが、時間のかかる作業になることはあります。普及して
いるプログラミング言語のほとんどは、スキャナの作成を支援する機能が不十
分です。というのは、連続した文字を単語、トークン、シンボルに分割する組
み込みの機能を持っていないからです。通常はこのような仕事を行うライブラ
リ・ルーチンが存在しますが、柔軟でなかったり、使いにくいものであったり、
あるいは、ルーチンとのやりとりにあまりに多くのコードが必要になったりす
ることが多いために、実装上の細かな点によって根本的な問題が不明瞭にされ
てしまいます。

１つの良い例が、C言語で許されているすべての数値型（浮動小数、10進整数、
16進整数、8進整数）を処理するスキャナをC言語で記述する場合です。これは
非常に難しいということはありませんが、出来上がったコードは通常美しいと
はとても言えないものでしょうし、その保守や拡張は容易でないことが多いの
です。

ほとんどのプログラマが即座に断言するように、他人の書いたコードを保守す
るのは通常あまり楽しい作業ではありません。さらに、美しくないコードを保
守するのは、楽しいというにはほど遠いものです。このように、スキャナを書
くことが退屈で、その保守が難しいとなると、スキャナの作成をより容易にし
てくれる方法を考えようとするに足る理由のあったことが読者にもお分かりい
ただけるでしょう。

Flexは、このような問題への答なのです。

========================================================================
* Menu:

* Problem Solving:: 問題解決手段としてのFlex * General Programming:: 
一般的なプログラミング・ツールとしてのFlex
========================================================================



File: flex-ja.info, Node: Problem Solving, Next: General Programming, Prev: Introduction, Up: Introduction

問題解決手段としてのFlex
========================

Flexはプログラマに対して、字句解析処理部分をきれいに記述し、その記述に
したがった効率的な字句スキャナを生成する方法を提供します。プログラマは
Flexに対して、必要なスキャナに関する記述情報を提供します。Flexはその記
述情報を使って、C言語で書かれたスキャナを生成します。記述に使われる言
語は上級言語であり、スキャナの記述に関してはC言語よりもはるかに適して
います。その上級言語を使うことで、プログラマは、文字をどのようにグルー
プ化し、グループ化が完了した時にどのようなアクションを発生させるかを指
定することができます。

*注：*このマニュアルのほとんどの部分はFlex、Lexの両方を対象にしていま
す。Lexは（Flexには劣りますが）ほとんどのUnixシステム上にある標準のス
キャナ生成ユーティリティです。両者の間に違いがある場合には、Flexを優先
させています。Lexについては*Note 標準Lex: Lexで簡単に説明してあります。

ここでも１つの良い例がコンパイラです。前に議論したように、コンパイラの
構文チェッカは、文字が連続したものではなく、言語文法の構成要素を表すトー
クンが連続したものを、入力として受け取る必要があります。Flexはこのよう
な場合に最適です。Flexによって生成されたスキャナが構文チェッカとファイ
ルの仲介役となり、構文チェッカが次の意味のあるトークンを要求するのを待
ちます。Flexはファイルを読み、プログラマが与える記述にしたがって文字を
グループ化して、マッチしたトークンを返却します。この処理は、スキャナも
しくはパーサが終了するまで続きます。

Cのコンパイラを作成する場合、このようなことを行うために必要となるFlex
の記述情報は、コードの行数にして100行から300行くらいになるかもしれませ
ん。この記述情報のほとんどは、シンボル・テーブルの管理、識別子の検索、
型のマッピング、ある数の値等の追加情報の返却を行うための補助的なCコー
ドになるでしょう。こうしたコード自体は記述情報の一部ではありませんが、
通常、コンパイラによって必要とされるものです。

概念的にはFlexは、原材料（文字）を取り込み、消費者（パーサ等）がすぐに
使うことができる完成品（トークン）を製造する工場のようなものです。



File: flex-ja.info, Node: General Programming, Prev: Problem Solving, Up: Introduction

一般的なプログラミング・ツールとしてのFlex
==========================================

Flexはコンパイラにしか使えないということはありません。読者のコンピュー
タ上にある、ファイルを読み込んだり、なんらかの形で文字のグループを処理
する必要のあるすべてのプログラム、特に、変換フィルタや言語ツールのこと
を考えてみてください。こうしたプログラムのほとんどすべてを、Flex単体、
もしくはFlexと他のツールの組み合わせによって作成することができます。

１つの良い例が文字数のカウントです。例えば、ファイルの中の全行数、個々
の文字の出現回数、`foo'という単語の出現回数を調べるプログラムを作成し
たいとしましょう。標準的なツール（`grep'、`sed'、`awk'、`perl'等）で作
成することも、C言語のプログラムを書いて作成することもできますが、Flex
で作成することも可能です。他の例として、特定のキーワードを探す必要のあ
る、メール・リーダがあります。この場合でも、標準ツールで実現することも、
FlexとC言語で実現することもできます。

Flexを使うことで、プログラマは、スキャナの開発やファイルを構成する文字
の処理にかかる時間を大幅に減らすことができます。ほとんどの場合、Flexに
対する入力情報は、既存のプログラミング言語で記述されたコードと比較して、
より理解しやすく、少なくとも同程度の移植性があり、保守もより簡単です。
それだけでなく、Flexでスキャナを開発するのにかかる時間は、既存のプログ
ラミング言語で同等のスキャナを開発する場合と比べきわめて短くてすむので、
Flexは、プロトタイピングや、一度しか使わないプログラムやフィルタの開発
に最適です。



File: flex-ja.info, Node: Invoking Flex, Next: Flex Descriptions, Prev: Introduction, Up: Top

Flexの起動
**********

     この章ではFlexを起動する基本的な方法を説明し、Flexで使用可能なコ
     マンドライン・オプションを簡単に説明します。

Flexは記述情報を含むファイルを入力として受け取り、スキャナ機能を持つC
のファイルに変換します。Flexを起動するためのコマンド行は以下のようにな
ります。

     flex [-bcdfinpstvFILT8] [-C[efmF]] [-SSKELETON] [FILE ...]

一般的には、単に`flex'に続けて処理すべきファイル名を入力することで実行
されます。

     flex myfile.l

記述情報ファイル名の末尾の`.l'は、`myfile'がFlexもしくはLexの記述ファ
イルであることを示唆する慣例的な方法です。名前付けの慣例としてもう一つ
よく見られるのが、末尾に`.lex'を使うことです。例えば、以下のようになり
ます。

     flex myfile.lex

Flexは記述情報ファイル（`myfile.l'）を読み込み、そこに記述されたパター
ンを認識するスキャナ機能を持つ`lex.yy.c'という名前のC言語ファイルを生
成します。記述情報の中になんらかのエラーがあれば、Flexは対応するエラー・
メッセージを`stderr'に出力します。

========================================================================
* Menu:

* Command Line Switches:: Flexのコマンドライン・オプション
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）
========================================================================



File: flex-ja.info, Node: Command Line Switches, Prev: Invoking Flex, Up: Invoking Flex

コマンドライン・オプション
==========================

Flexのコマンドライン・オプションは以下のような意味を持ちます。

`-b'
     `-b'オプションを指定すると`lex.backtrack'というファイルが生成され
     ます。このファイルはスキャナの記述情報を最適化する際に使用されま
     す。詳細については、*Note Optimizing for Speed::。

`-c'
     このオプションはPOSIXとの互換性のために提供されているだけで、実際
     には何もしません。POSIXでは、`-c'オプションはC言語によるアクショ
     ンが使用されることを意味します。

`-d'
     このオプションを指定するとデバッグが可能になります。これにより生
     成されるスキャナは、実行中にスキャナの状態情報を`stderr'に出力し
     ます。

`-f'
     Flexに対して*ファスト*・スキャナ（*fast* scanner）と*フル*・スキャ
     ナ（*full* scanner）のどちらを生成するかを指示します。詳細につい
     ては、*Note Table Compression and Scanner Speed::。`-f'（小文字）
     オプションと`-F'（大文字）オプションとは異なる効果を持つ点に注意
     してください。

`-i'
     Flexに対して大文字、小文字を区別しないスキャナを生成するよう指示
     します。詳細については、*Note Case Insensitive Scanners::。

`-n'
     このオプションはFlexにとっては何の意味も持たず、POSIXとの互換性の
     ためにのみ提供されています。POSIXでは、このフラグは`-v'オプション
     による出力を抑制するために使用されます。POSIXでのデフォルトは、テー
     ブル・サイズが指定されない限りこのような出力を抑制するというもの
     です。Flexではテーブル・サイズは意味を持たないので、このフラグは
     冗長です。

`-p'
     `-p'オプションが指定されると、Flexは性能レポートを`stderr'に出力
     します。スキャナの性能を向上させる方法に関する議論については、
     *Note Optimizing for Speed::。

`-s'
     Flexスキャナがマッチするものを見つけることができなかった場合のデ
     フォルトのアクションは、そのマッチされなかった入力情報を`stdout'
     に出力することです。`-s'オプションはこのようなアクションを抑制し、
     その代わりに入力情報がマッチしなかった時点でスキャナを異常終了さ
     せます。

`-t'
     このオプションが指定された場合、Flexは生成されたスキャナをファイ
     ル`lex.yy.c'にではなく`stdout'に出力します。

`-v'
     Flexに対して*冗長*モードで動作するよう指示します。

`-F'
     Flexに対して*ファスト*・スキャナ（*fast* scanner）を生成するよう
     指示します。詳細については、*Note スキャナの最適化: Optimization。
     `-F'（大文字）は`-f'（小文字）とは異なる効果を持つ点に注意してく
     ださい。`-f'と`-F'の相違点に関する情報については、*Note Table
     Compression and Scanner Speed::。

`-I'
     このオプションはFlexに対して*対話型*スキャナを生成するよう指示し
     ます。詳細については、*Note Interactive Scanners::。

`-L'
     デフォルトでは、デバッグを支援するために、Flexは生成されたスキャ
     ナのコード中に`#line'指示子を書き込みます。このオプションによって
     `#line'指示子の書き込みは行われなくなります。

`-T'
     Flexに対して"トレース"・モードで動作するよう指示します。Flexは多
     くのメッセージを`stderr'に出力するようになります。こうしたメッセー
     ジは、Flexを非常によく理解しているユーザ以外には無意味でしょう。

`-8'
     このオプションは、Flexに対して8ビット入力を受け付けるスキャナを生
     成するよう指示します。

`-C[efmF]'
     これらのオプションは、スキャン処理用のテーブルをどのように圧縮す
     るかを制御します。詳細については、*Note スキャナの最適化:
     Optimization。

`-SSKELETON_FILE'
     Flexに対して、生成するスキャナのベースとしてSKELETON_FILEにより指
     定されるスケルトン・ファイルを使用するよう指示します。主に、Flex
     自体をデバッグするために使用されます。




File: flex-ja.info, Node: Command Line Switches (Flex 2.5), Prev: Command Line Switches, Up: Invoking Flex

コマンドライン・オプション（Flex 2.5の補足情報）
================================================

Flex 2.5では、前節（*Note Command Line Switches::）で説明されていない、
以下のオプションもサポートされています。

`-h'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指
     示します。

`-l'
     AT&Tにより実装されたlexとの互換性を最大限に提供します。このオプショ
     ンは、性能面でかなりの悪影響を及ぼします。また、このオプションを、
     `-f'、`-F'、`-Cf'、`-CF'、`-+'オプションと同時に指定することはで
     きません。FlexとLexの（非）互換性の問題については、*Note Flex and
     Lex::を参照してください。

`-w'
     このオプションが指定されると、Flexは、警告メッセージを出力しませ
     ん。

`-B'
     Flexに対してバッチ・スキャナを生成するよう指示します。これは、対
     話型スキャナを生成するよう指示する`-I'オプションの否定です。

`-V'
     Flexに対してバージョン番号を出力するよう指示します。

`-7'
     Flexに対して7ビット・スキャナを生成するよう指示します。これは、
     `-8'オプションの否定です。内部的に生成されるテーブルのサイズは、
     `-8'オプションが指定された場合と比較して半分になりますが、生成さ
     れるスキャナは、8ビット文字を含む入力を処理することができなくなり
     ます。`-Cf'、`-CF'が指定されていない場合は、明示的に`-7'を指定し
     ない限り、8ビット・スキャナが生成されます。

`-+'
     Flexに対してC++スキャナ・クラスを生成するよう指示します。C++スキャ
     ナについては、*Note Flex and C++ (Flex 2.5)::を参照してください。

`-?'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指
     示します。（`-h'オプションと同じです）。

`-Ca'
     このオプションは、スキャン処理用のテーブルを`long int'の配列とし
     て定義するようFlexに通知します（デフォルトでは`short int'型の配列
     となります）。RISCマシンによっては、`long int'の方が高速に処理さ
     れるため、スキャナの性能向上が期待できますが、その反面、テーブル
     のサイズは大きくなります。

`-Cr'
     このオプションを指定して生成されたスキャナは、入力に`read()'シス
     テム・コールを使います。デフォルトでは、対話型スキャナの場合は
     `getc()'が、バッチ（非対話型）・スキャナの場合は`fread()'が使われ
     ます。

`-oFILE'
     このオプションが指定されると、Flexは生成されたスキャナをFILEによ
     り指定されるファイルに出力します。デフォルトでは、スキャナはファ
     イル`lex.yy.c'に出力されます。

`-PPREFIX'
     Flexにより生成されるスキャナのソース・ファイルの中では、大域変数
     や大域関数の名前の先頭に接頭辞`yy'が付けられます。このオプション
     が指定されると、`yy'の代わりに、PREFIXにより指定される文字列が接
     頭辞として使用されます。また、`-o'オプションが指定されない場合の
     スキャナ・ファイル名`lex.yy.c'も、`lex.PREFIX.c'となります。

     以下に、このオプションにより影響を受ける名前の一覧を示します。

          yy_create_buffer
          yy_delete_buffer
          yy_scan_buffer
          yy_scan_string
          yy_scan_bytes
          yy_flex_debug
          yy_init_buffer
          yy_flush_buffer
          yy_load_buffer_state
          yy_switch_to_buffer
          yyin
          yyleng
          yylex
          yylineno
          yyout
          yyrestart
          yytext
          yywrap

     `-+'オプションが指定されている場合は、影響を受けるのは`yywrap'と
     `yyFlexLexer'の２つだけです。

     このオプションにより、`yywrap()'の名前が変更されてしまう点に注意
     してください。プログラムをリンクするためには、`PREFIXwrap'という
     名前の関数を作成する必要があります。この関数を作成したくない場合
     には、スキャナ定義ファイルの中で、`%option noyywrap'を指定して、
     リンク時に`-lfl'オプションを指定します。`%option'指示子については、
     *Note %option (Flex 2.5)::を参照してください。

`--help'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指
     示します。（`-h'オプションと同じです）。

`--version'
     Flexに対してバージョン番号を出力するよう指示します。（`-V'オプショ
     ンと同じです）。



File: flex-ja.info, Node: Flex Descriptions, Next: Interfacing to Flex, Prev: Invoking Flex, Up: Top

Flex記述言語
************

     この章では、スキャナ定義の構成要素を説明し、その使用例を示します。
     Flexを効率的に使用するためには、定義の個々の要素を完全に理解する
     ことが非常に重要です。したがって、初めてFlexを使うユーザには、時
     間をかけてこの章を読むことをお勧めします。

Flexスキャナ定義のほとんどの要素は、必須要素ではありません。全体的な定
義フォーマットは以下のようになります。

     定義、初期Cコード
     %%
     ルール 
     %%
     他のCコード

各々について、以下において詳細に説明します。

========================================================================
* Menu:

* Comments:: Flexのコメント・スタイルの説明* Optional C Code:: Flex定
義の先頭のCコード・セクションの説明* Definitions:: Flexにおける定義の
書き方* %%:: 区切り文字%%の意味* Rules:: Flexファイルのルール・セクショ
ン* Pattern Matching:: パターン・マッチングに使われる部分* Regular
Expressions:: パターンのマッチング* Start States:: ある条件にもとづい
てパターン・マッチング・ルールを活性化させる方法
* %option (Flex 2.5)::          %option指示子の説明
========================================================================



File: flex-ja.info, Node: Comments, Next: Optional C Code, Prev: Flex Descriptions, Up: Flex Descriptions

コメント
========

Cのコードが記述できるところには、どこにでもコメントを記述することがで
きます。コメントの書式は、Cのコメントの規則に従います。コメントは、記
述情報に影響を与えることはありません。Cスタイルのコメントは以下のよう
になります。

     /*
     ...
     */

これに加えて、Flexでは`#'で始まるコメントも許されます。このようなコメ
ントは`lex.yy.c'にはコピーされませんので、この形式のコメントを使うこと
は*お勧めできません*。

*注：*C以外の言語（例えばPascal）のコードを生成するLexも存在します。こ
のようなLexではコメントの書式はおそらく異なるでしょう。Flexの場合はCの
コードしか生成しません。



File: flex-ja.info, Node: Optional C Code, Next: Definitions, Prev: Comments, Up: Flex Descriptions

オプションのCコード
===================

プログラマは、２つの異なる方法を用いて、スキャナの中に直接Cのコードを
含めることができます。第１の方法は、"「定義、初期Cコード」"セクション
（最初の`%%'より前の部分）にコードを含めることです。第２の方法は、"
「他のCコード」"セクション（２番目の`%%'より後ろの部分）にコードを含め
ることです。どちらの場合も、コードはそのまま`lex.yy.c'にコピーされます
ので、正当なコードでなければなりません。

第１のセクション中のCコードは以下の形式になります。


     %{ 
        C CODE
        ...
     %}

ここで`%{...%}'というペアが、Cコード・ブロックの先頭と末尾を示すために
使われています。この形式のコードと定義は、"「定義、初期Cコード」"セク
ションのどこにでも自由に記述することができます。定義については次の節で
説明します。

Cのコードが最初のカラムから始まるのでなければ、`%{...%}'というペアは必
要ありません。しかし普通は、分かりやすくするために記述しておいた方が良
いでしょう。もう１つのポイントは、`#ifdef'等のように最左端のカラムから
始まらなければならず、かつ、通常はスキャナ記述情報の先頭に置かれる必要
のあるものが存在するという点です。こうした場合、`%{...%}'に囲まれてい
ないと、Flexはそれを定義の一部であると見なすでしょう。これが、常に
`%{...%}'を使うもう１つの理由です。

最後の（"「他のCコード」"）セクション内のコードは、そのままコピーされ
ます。ここには特別な宣言は必要ありません。



File: flex-ja.info, Node: Definitions, Next: %%, Prev: Optional C Code, Up: Flex Descriptions

定義
====

定義セクションにおいて、プログラマは、ある文字のグループに一意な識別子
を与え、その識別子がその文字グループに置き換えられるようにすることがで
きます。定義は以下のような形式になります。

     DEFINITION_NAME    DEFINITION

DEFINITION_NAMEは*最初*のカラムから始まらなければならず、そうしないと
その定義は`lex.yy.c'にそのままコピーされてしまうということに注意してく
ださい。以下に一般的な定義をいくつか挙げます。

     DIGIT     [0-9]
     LETTER    [a-z]
     IDENT     [a-z_][a-z0-9_]*
     ALPHANUM  {LETTER}|{DIGIT}

DEFINITION NAMEは、そのグループの一意な識別子でなければなりません。ま
た、DEFINITIONはルール・セクション（後述）において正当なものであれば何
でも構いません。ルール・セクションや（上の例の`ALPHANUM'の定義において
示されるように）別の定義中において使われる場合には、定義は`{ }'によっ
て囲まれていなければなりません。

FlexとLexの非常に重要な相違点に、定義を展開する時、Flexは字義どおりに
丸括弧( )で囲むのに対して、Lexは囲まないという点があります。 (1)
(*Note Definitions-Footnotes::) これは、`^'、`<<EOF>>'、`$'、`/'を定義
中に入れることができないことを意味しています。というのは、前述の文字は
丸括弧( )で囲まれた部分に入れることができないからです。詳細は、*Note
Characters::および*Note Flex and Lex::において説明します。

例えば、

     FUNCTION ^[a-zA-Z_][a-zA-Z0-9_]*"("
     %%
     {FUNCTION}  printf("got a function\n");

は、以下のようなプログラミング・スタイルを使っている場合の、Cの関数宣
言にマッチするように見えます。

     int
     foo()
     {
        ...
     }

しかし実際にはうまくいきません。というのは、`{FUNCTION}'が展開されると、

     (^[a-zA-Z_][a-zA-Z0-9_]*)

のようになりますが、これは不正だからです。このような種類の問題に関する
説明については、*Note Flex and POSIX::を参照してください。



File: flex-ja.info  Node: Definitions-Footnotes, Up: Definitions

(1) 訳注：Flex 2.5では、`-l'オプションを指定して生成されたスキャ
ナは、Lexの場合と同じように、定義を展開する時に丸括弧( )で囲みません。


File: flex-ja.info, Node: %%, Next: Rules, Prev: Definitions, Up: Flex Descriptions

%%
==

２つのパーセント記号が、スキャナ記述情報のルール・セクションの先頭と末
尾を示します。すべてのFlex記述情報は、少なくともルール・セクションの先
頭を示す`%%'を含んでいなければなりません。



File: flex-ja.info, Node: Rules, Next: Pattern Matching, Prev: %%, Up: Flex Descriptions

ルール
======

ルールはFlexの心臓部です。ルールを書くことによって、プログラマは、スキャ
ナが何を実行するべきであるかをFlexに通知します。

通常、ルールは２つの部分から構成されます。

     PATTERN       ACTIONS

このうちPATTERNが何を認識するべきかを定義し、ACTIONSがその何かを認識し
た時に何を実行するべきであるかをスキャナに知らせます。PATTERNの部分は
空白によって区切られます。これは、空白をマッチさせたい場合には、それを
引用符で囲む必要があるということを意味しています。

スキャナは、マッチするものを２つ以上見つけた場合、以下の２つのルールを
使ってどれを受け入れるかを決めます。

  1. 後続コンテキスト（trailing context）も含めて最も長いものを受け入
     れる。
  2. マッチするものがすべて同じ長さの場合、スキャナ定義中に最初に記述
     されたものを受け入れる。

ACTIONSは、空（コードなし）にするか、もしくは、１つ以上のCの文を含む単
一のコード行、`{...}'または`%{...%}'で囲まれた１行以上のコード、単一の
垂直棒（`|'）のいずれかを記述することができます。以下にいくつか例を挙
げます。

     hi         |
     bonjour    |
     hello      printf("hello!\n");
     goodbye    {  printf("goodbye!\n"); }
     konnichiwa {                   
                    LINE 1      
                    ...             
                    LINE N      
                } 
     sayonara   printf("lex will not "); printf("print this\n");

どの行も複数の文を含むことができます。`|'は、そのルールにマッチするも
のが見つかった場合、次に現れるルールのアクション部に記述されているアク
ションが実行されるべきであることをFlexに通知します。

*注：*ほとんどのバージョンのLexは、`{'と`}'のペアの外部では単一の文し
か許しません（例えば上の`sayonara'ルールは許されません）。また、C以外
の言語をターゲットにしているLexでは、`{'と`}'のペアは、例えばPascalの
場合の`begin...end'のように、異なるシンボルに置き換える必要があるかも
しれません。

ルールにマッチしなかった入力に対するデフォルトのアクションは、それを
`stdout'に出力することであり、一方、マッチしたパターンに対するデフォル
トのアクションは、それを破棄することであるという点に注意してください。
これは、最も単純なFlexの定義が

     %%

であることを意味しています。これは、入力を変更せずそのまま`stdout'へ出
力するものです。別の単純な例として以下のようなものがあります。

     %%
     foobar

この場合、入力の中から`foobar'という文字の並びをすべて取り除き、取り除
いた結果を`stdout'に出力します。



File: flex-ja.info, Node: Pattern Matching, Next: Regular Expressions, Prev: Rules, Up: Flex Descriptions

パターン・セクション
====================

パターン・セクションは、"正規表現"と呼ばれる仕組みを使って実際のマッチ
ング処理を実行します。正規表現は、文字列、文字、文字集合（"クラス"）、
および演算子から構成されています。正規表現を構成する要素については次節
以降で説明します。また正規表現自体については、*Note Regular
Expressions::において議論します。

========================================================================
* Menu:

* Characters:: Flexにおける文字、特殊文字* Strings:: Flexにおける文字
列、特殊文字列* Character Classes:: 文字クラスの説明、その使い方
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）
========================================================================



File: flex-ja.info, Node: Characters, Next: Strings, Prev: Pattern Matching, Up: Pattern Matching

文字
----

いくつかの文字はFlexにとって特別の意味があり、その文字を単独で使ったの
では、その文字自体を表すことができません。以下に、Flexにおける特殊文字
とその意味を表にして示します。


     `文字'
          Flexによる解釈

     `.'
          ピリオドは改行（`\n'）*以外*の任意の文字を表します。

     `\'
          バックスラッシュはエスケープ文字です。エスケープ・シーケンス
          はANSI Cのものと同一です。

     `[ ]'
          角括弧[ ]は複数の文字を"文字クラス"にグループ化します。詳細
          については、*Note Flexにおける文字のグループ化: Character
          Classes。

     `^'
          文字クラスの内部では^は否定を意味します。詳細については、
          *Note Flexにおける文字のグループ化: Character Classes。文字
          クラスの外部では、^は行の先頭を意味し、ルールの先頭にのみ置
          くことができます。例を以下に示します。

               `[^AB]'
                    否定クラスです。

               `^foo'
                    行の先頭にある`foo'という文字の並びにのみマッチし
                    ます。

               `foo^'
                    この場合、`^'は普通の文字であるとみなされます。こ
                    のような時には、希望どおりの結果が*確実*に得られる
                    ようにするために、特別な意味を持つ文字の前にバック
                    スラッシュ`\'を置くのが良いでしょう。このような文
                    字の並びを"エスケープ・シーケンス"と呼びます。エス
                    ケープ・シーケンスについてはこの節の最後で説明しま
                    す。

     `-'
          ハイフンは文字クラスの内部において文字の範囲を表します。文字
          クラスの外部では、ハイフンはそれ自身を表します。詳細について
          は、*Note Flexにおける文字のグループ化: Character Classes。

     `{ }'
          大括弧{ }は、定義の参照、複数行のアクションの囲み、またはあ
          る範囲にわたる繰り返しの定義を行います。例を挙げると、定義
          `FOO'があって、それをルールの中で参照したい場合に`{FOO}'を使
          います。

          与えられたパターンのある範囲にわたる繰り返しを定義するには、
          以下のような`{ REPETITION LIST }'を使います。

               %%
               f{2,5}  /* fの２回以上５回以下の繰り返し */
                       /* にマッチ                      */
               f{2,}   /* fの２回以上の繰り返しにマッチ */
               f{2}    /* fの２回の繰り返しにマッチ     */

          この用法の解釈において、 FlexとLexの間にはいくつかの相違点が
          あります。詳細については、*Note Flex and POSIX::を参照してく
          ださい。

     `( )'
          丸括弧( )を使って優先順位を変更することができます。また、定
          義が展開される時には、その定義は暗黙のうちに丸括弧( )で囲ま
          れることに注意してください。 (1) (*Note
          Characters-Footnotes::) このため、Lexとは非互換なところがで
          てきます。この点については、*Note Flex and POSIX::と*Note
          Definitions::で説明しています。

     `""'
          二重引用符記号は文字列を表します。引用符の内側の文字列だけが
          マッチの対象になります。したがって、

               %%
               "string"

          は`"string"'にではなく、`string'にマッチします。

     `/'
          スラッシュは後続コンテキスト（trailing context）を設定します。
          これは、あるパターンの後ろに特定の文字の並びが続く場合のみ、
          そのパターンを認識したいという状況です。つまり、スラッシュ
          `/'は「"ルック・アヘッド"（その先を見る）」演算子として機能
          するということです。例を挙げると、

               `abcDEF'
                    `abcDEF' を認識します。

               `abc/DEF'
                    `abc'の後ろに`DEF'が続く場合に限り、`abc'を認識し
                    ます。`DEF'の部分は、あたかもまだ読まれてはいない
                    かのように扱われ、マッチの対象になりません。

          *注：*１つのルールの中では`/'は１つだけ許されます。つまり、

               abc/def/hijkl

          は不正です。

     `< >'
          かぎ括弧< >はスタート状態を参照します。また、EOFシンボル
          （`<<EOF>>'）にも使われます。完全な説明については、*Note
          Start States::と*Note End-Of-File Rules::を参照してください。

     `? + *'
          `?'、`+'、`*'は、ある*正規表現*が現れることのできる回数を設
          定します。`?'は０回もしくは１回（その正規表現が現れることは
          必須ではないということ）を意味します。`+'は１回以上を意味し
          ます。`*'は０回以上を意味します。例えば、

               `a?'
                    ０個もしくは１個の`a'にマッチします。

               `a+'
                    １個以上の`a'にマッチします。

               `a*'
                    ０個以上の`a'にマッチします。

               `(ABC)+'
                    `ABC'という文字の並びが１回以上続くものにマッチし
                    ます。

               `[abQrS]?'
                    ０個もしくは１個の、（５つの文字`abQrS'から構成さ
                    れる）この文字クラスのメンバにマッチします。文字ク
                    ラスに関する詳細については、*Note Flexにおける文字
                    のグループ化: Character Classesを参照してください。

               `{NUM}*'
                    ０個以上の`NUM'にマッチします。ここでの`NUM'は定義
                    です。定義に関する詳細については、*Note
                    Definitions::を参照してください。

     `|'
          OR演算子、および、特別なアクションを表します。例えば、

                  apples|oranges

          は`apples'もしくは`oranges'のいずれかにマッチし、

               apples         |
               oranges        printf("fruit!\n"); 

          は、`apples'と`oranges'の両方に対して同一の*アクション*を実
          行します。

     `$'
          ドル記号は行末を意味します。例えば、

                  end$

          はその直後が行末である場合にのみ`end'という文字の並びにマッ
          チします。これは、後ろに続くのが行末のマーカである場合のみ
          `end'にマッチする

                  end/\n

          とまったく同じです。


こうした文字のいずれかをその文字自身として表したい場合には、引用符で囲
むか、（後に示す表で説明する）エスケープ・シーケンスとして表さなければ
なりません。

Flexには３種類のエスケープ・シーケンスがあります。バックスラッシュ`\'
に続けて8進数を使うもの、`\x'に続けて16進数を使うもの、`\LETTER'という
表記法によってある１文字、または、特別な表示不可の文字を表すものの３つ
です。Cをよく知っている人であれば、この３つがANSI Cのエスケープ・シー
ケンスであることに気がつくことでしょう。数値によるエスケープ・シーケン
スは、100パーセント移植性があるわけではなく、保守を困難にするので、避
けるべきです。

以下に、
文字の使用に関する要約を示します。
この表中では、
`c'が単一の文字を、
`NNN'が8進定数を、
`HH'が16進定数を表します。


                         Flexにおける文字
     ============+========================================+============
       文字      |                  意味                  | 例
     ============+========================================+============
        c        | cが演算子でない場合は、文字c自体       | a
        .        | 改行（\n）以外の任意の文字             | .  
       "c"       | c                                      | "^", "$"
        \b       | バックスペース       （BS）            | [\b]
        \t       | 水平タブ             （HT）            | [\t]
        \n       | 改行                 （NL）            | [\n]
        \v       | 垂直タブ             （VT）            | [\v] 
        \f       | 頁送り               （FF）            | [\f]
        \r       | キャリッジ・リターン （CR）            | [\r]
        \\       | 単一バックスラッシュ                   | \\, \\b
        \"       | 単一引用符                             | \"
        \0       | NUL文字                                | \0
        \c       | cが上記以外の文字の場合、文字c自体     | \w
        \xHH     | 16進数HHを値として持つ文字             | \x1B 
        \NNN     | 8進数NNNを値として持つ文字             | \033





**注：*いくつかのバージョンのLexでは、
`\0'を正しく認識、またはマッチしません。これは、`\0'がNUL、つまりC文字
列の終端文字だからです。Flexでは、NULをマッチの対象にしても問題はあり
ませんが、性能には若干影響します。*

さらに付け加えると、`^'演算子と`<<EOF>>'はルールの先頭にのみ置くことが
できます。また、これらと`$'、`/'は丸括弧( )の内部に置くことはできませ
ん。このことはまた、定義の正当性にも影響を及ぼします。というのは、展開
される時に定義は字義どおりに丸括弧( )で囲まれるからです。 (2) (*Note
Characters-Footnotes::) 詳細については、*Note Definitions::と*Note
Flex and POSIX::を参照してください。



File: flex-ja.info  Node: Characters-Footnotes, Up: Characters

(1) 訳注：Flex 2.5では、`-l'オプションを指定して生成さ
れたスキャナは、Lexの場合と同じように、定義を展開する時に丸
括弧( )で囲みません。

(2) 訳注：Flex 2.5では、`-l'オプションを指定して生成されたスキャ
ナは、Lexの場合と同じように、定義を展開する時に丸括弧( )で囲みません。


File: flex-ja.info, Node: Strings, Next: Character Classes, Prev: Characters, Up: Pattern Matching

Flexにおける文字列
------------------

"文字列"とは、（常に、というわけではありませんが）多くの場合、引用符に
よって囲まれる文字のグループです。エスケープ・シーケンスが使われない限
り、文字列には改行や表示不可の文字を含めることはできません。

`-i' オプション（詳細については、*Note Case Insensitive Scanners::）を
使わない限り、大文字・小文字の区別も含めた*字義どおり*の文字列に対して
マッチが行われます。引用符付きの文字列については、引用符は認識される文
字列には*含まれません*。

例えば、

     string
     StrING
     "STRING"
     \"string\"

はすべて正当な文字列であり、最後のものは引用符も含めてマッチされます。
Flexにおいては文字列には引用符は*必須*ではありません。したがって、キー
ワードのグループにマッチさせる場合、

     begin
     end
     pointer
      ...

と

     "begin"
     "end"
     "pointer"
      ...

のいずれも正当です。



File: flex-ja.info, Node: Character Classes, Prev: Strings, Up: Pattern Matching

Flexにおける文字のグループ化
----------------------------

Flexでは、文字をグループ化して"文字クラス"にすることができます。文字ク
ラスは、文字のグループを角括弧[ ]で囲むことにより作成されます。どのよ
うな文字でも正当です（表示不可の文字についてはエスケープ・シーケンスを
使います）。また、文字の範囲をハイフン`-'を使って指定することができま
す。文字クラスがルールの中で使われている場合には、Flexはそのクラスの任
意のメンバとマッチさせ、あたかも単一文字が使われているかのように振る舞
います。例えば、

     [a-z]
     [A-Z]*

において、最初の例は`a'から`z'までの任意の単一文字にマッチします。第２
の例は`A'から`Z'までの任意の文字が０個以上並んだものにマッチします。

*否定*文字クラスを表す正規表現を書くこともできます。否定文字クラスは、
（`\n'も含めて）文字クラスのメンバ*以外*であれば何にでもマッチします。
これを行うには、否定すべきクラスの先頭に`^'を置きます。（クラスの外部
では`^'は異なる意味を持つことに注意してください。）以下に、正当なクラ
スの例をいくつか挙げます。

     `[abc]'
          `a'、`b'、`c'のいずれかにマッチします。

     `[abc\n]'
          `a'、`b'、`c'、`\n'のいずれかにマッチします。

     `[a-z]'
          ASCII値が`a'から`z'までの範囲にある任意の文字、すなわち、任
          意の英小文字にマッチします。

     `[^a-z]'
          `a'から`z'までの範囲にある文字*以外*の任意の文字にマッチしま
          す。

     `[ABcd]'
          `A'、`B'、`c'、`d'のいずれかにマッチします。

*注：*Flex、およびいくつかのバージョンのLexは、クラス内における逆方向
の範囲を扱うことができません。したがって、

     %% [z-a9-0] はエラー・メッセージを出力します。逆方向の範囲は指定
しないでください。




File: flex-ja.info, Node: Character Class Expressions (Flex 2.5), Prev: Character Classes, Up: Pattern Matching

Flexにおける文字のグループ化（Flex 2.5の補足情報）
--------------------------------------------------

Flex 2.5では、文字クラスの中に"文字クラス式"を含めることができます。

文字クラス式は、形式的には、ある文字集合を識別する名前を`[:'と`:]'で囲
んだものです。Flex 2.5では、以下の文字クラス式が有効です。

     [:alnum:] [:alpha:] [:blank:]
     [:cntrl:] [:digit:] [:graph:]
     [:lower:] [:print:] [:punct:]
     [:space:] [:upper:] [:xdigit:]

文字クラス式[:XXX:]は、ANSI Cの`isXXX()'関数がゼロ以外の値を返す文字の
集合に対応します。唯一の例外は[:blank:]で、`isblank'は（POSIXでは定義
されているものの）ANSI Cでは定義されていないため、Flexでは、マクロ
`IS_BLANK'を

     #define IS_BLANK(c) ((c) == ' ' || (c) == '\t')

のように定義して、これが真となる文字の集合（すなわち、スペースとタブ）
を文字クラス式[:blank:]に対応させています。

文字クラス式を使えば、

     [a-zA-Z]
     [0-9]

を

     [[:alpha:]]
     [[:digit:]]

と書くことができます。

また、文字クラスの中に複数の文字クラス式を含めることができますので、

     [a-zA-Z0-9]

を、

     [[:alpha:][:digit:]]

と書くこともできます（もっとも、この例の場合は、[[:alnum:]]と書くほう
が良いでしょう）。



File: flex-ja.info, Node: Regular Expressions, Next: Start States, Prev: Pattern Matching, Up: Flex Descriptions

正規表現
========

Flexの文字、文字列、クラス、定義、および演算子を組み合わせることで、"
正規表現"として知られているものが作られます。（基本単位が数と演算子で
ある）数学表現と同じように、基本的な要素は単純なもの（文字、演算子、文
字列、クラス、および定義）ですが、要素を組み合わせることでより複雑な表
現式を作ることができます。例えば、`c'は単一文字の正規表現で、`c'にマッ
チします。`cc'は２つの正規表現をつないだものを含む正規表現で、`cc'にマッ
チします。`c*'は、単一文字の正規表現`c'と、それに続く演算子`*'から構成
される正規表現で、０個以上の`c'にマッチします。正規表現の真のパワーは、
個々の要素よりもむしろ、組み合わせ可能な方法の中にあります。

次の表は、
Flexで利用可能な正規表現をすべて示したものです。
表中において、
`c'は
（エスケープ・シーケンスを含む）
任意の単一文字を、
`r'は任意の正規表現を、
`s'は文字列を表します。
表はグループ別に編成してあり、
優先度の最も高いものが一番上にあります。

  

                           Flexにおける正規表現
     =============+=============================================+================
     正規表現     |           マッチの対象                      |   例        
     =============+=============================================+================
        c         | 特殊文字を除く任意の文字                    |  A、\n、a
        .         | 改行を除く任意の文字                        |    abc.*
        [s]       | クラスs中にある任意の文字                   |    [abc]
        [^s]      | クラスs中にない任意の文字                   |    [^abc]
        r*        | ０個以上のr                                 |  (a|b)*、[abc]*
        r+        | １個以上のr                                 |    (a|b)+
        r?        | ０個または１個のr                           |  (a|[b-q])?
        r{x,y}    | x個以上y個以下のr                           |   foo{1,5}
                  | （abc{1,3}は、abと１個以上３個以下のc）     |
        "s"       | 字義どおりの文字列s                         |    "***"
        \c        | （\cがANSI Cにおいて特別な意味を持たない    |    \"  \*
                  |   場合）c                                   |
        (r)       | r - 丸括弧()はグループ化のためのもの        |    (Aa|b)      
                  |                                             |
        r1r2      | r1の後ろにr2が続くもの                      | Aa、(A|a)[0-9]
                  |                                             |
        r1|r2     | r1またはr2                                  |     A|B
                  |                                             |
        r1/r2     | r2が後ろに続くという条件を満足するr1        |    abc/123
        ^         | 行頭                                        |    ^abc
        $         | 行末                                        |    abc$
                  |                                             |
        <start>r  | スタート状態（start状態の時、rがアクティブ）|  <command>"*/"
        <<EOF>>   | ファイルの終端（End-Of-Fileルールを参照）   |    <<EOF>>




Unixにおいてパターン検索が必要な場合には正規表現がよく使われますが、ア
プリケーションが異なると、正規表現もよく似てはいるもののまったく同一で
はないという点に注意してください。例えば、Flex、`egrep'、`Emacs'はいず
れもパターン検索のテンプレートとして正規表現を使いますが、それぞれが理
解する正規表現は少しずつ異なります。特に、Flexでは定義が使われますが、
`egrep'や`Emacs'では使われませんし、`egrep'や`Emacs'は単語の先頭と末尾
にマッチさせるための`\<'と`\>'とを提供していますが、Flexは提供していま
せん。さらに、`Emacs'はバッファの先頭に対するマッチングや「ファジー」
なマッチング等を行うための、特別な`\LETTER'シーケンスをほかにも数多く
提供しています。



File: flex-ja.info, Node: Start States, Prev: Regular Expressions, Up: Flex Descriptions

スタート状態
============

なんらかの条件に基づいて、パターン・マッチング処理のルールを活性化する
ことが便利な時があります。例えば、いくつかのコンピュータ言語では、重複
しているスキャン・ルールの曖昧さを取り除くのを支援するために、パース状
態を使います。別の例としては、ある特定の入力が見つかったあとでだけ、あ
るルールを活性化したいという場合があります。このような状況に対処するた
めに、Flexは"スタート条件"または"スタート状態"と呼ばれる単純なシステム
を提供しています。

========================================================================
* Menu:

* Start States Explained:: スタート状態の宣言、スキャナに対する効果*
Activating States:: スタート状態の活性化方法* Start State Notes:: 不当
な宣言、排他的スタート状態のパワーに関する注
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
* Start State Example::         スタート状態の使用例
========================================================================



File: flex-ja.info, Node: Start States Explained, Next: Activating States, Prev: Start States, Up: Start States

スタート状態の説明
------------------

スタート状態は、あるルールがアクティブになるのはいつであるかをFlexに通
知するブール値のようなものです。スタート状態は、定義セクションにおいて
（排他的スタート状態の場合）`%x' 、または（包含的スタート状態の場合）
`%s'を使って宣言されます。

     %x START_STATE_NAME
     %s START_STATE_NAME

START_STATE_NAMEは一意な名前でなければならない点に注意してください。つ
まり、他のスタート状態や定義が同じ名前を持ってはならないということです。
スタート状態は、１つの状態の名前、または、カンマで区切られた複数の状態
の名前をかぎ括弧< >で囲むことによって、ルール・セクションで参照されま
す。スタート状態の参照はルールの先頭になければならず、１つのルール中に
は１対のかぎ括弧< >のみ許されます。このことは、

     %x state1
     %s state2
     %x state3 state4
     %%
     <state1>"foo"
     <state2,state3,state4>"bar"

が正当であり、

     integer [-+]?[0-9]*
     %x integer
     %s state1,state2,state3
     %%
     <integer>"foo"
     "bar"<state1>
     <state1>"bar"<state2,state3>

はすべて不当であることを意味しています。`integer'については同じ名前を
持つ定義が存在し、それ以外のものについてはスタート状態の参照の位置が正
しくないか、複数の参照が存在するからです。

これまでのところでは、Flexが異なる２種類のスタート状態をサポートしてい
る事実から目をそらしてきました。２つのスタート状態とは、"包含的スター
ト状態"（`%s'）と"排他的スタート状態"（`%x'）のことです。これら２つの
相違点は、排他的スタート状態が活性化された場合は、その状態に属するルー
ル*だけ*が活性化されるのに対して、包含的スタート状態の場合は、その状態
に属するルールとスタート状態への参照を持たないルールの両方が活性化され
るという点にあります。この違いを示す例を挙げると、以下のようになります。

     %s state1
     %%
     <state1>"one" printf("two");
     "three"       printf("four");

この場合、`state1'状態が活性化されている場合は`one'を`two'に置き換え、
*`state1'状態が活性化されているか否かにかかわらず*`three'を`four'に置
き換えます。デフォルトのルールにより、その他のテキストは`stdout'に出力
されます。これに対して、

     %x state1
     %%
     <state1>"one" printf("two");
     "three"       printf("four");

は、`state1'状態が活性化されている時は`one'を`two'に置き換え、
*`state1'状態が活性化されていない時のみ*`three'を`four'に置き換えます。
デフォルトのルールにより、その他のテキストは`stdout'に出力されます。

このことは、排他的スタート状態が使われる場合には、マッチしないテキスト
が`stdout'に出力されてはならないのであれば、すべての可能な入力にマッチ
するルールを、*個々*の排他的スタート状態が持たなければならないことを意
味しています。包含的スタート状態の場合は、あらゆる状態において有効な、
スタート状態への参照を持たないルールを１つ持つ必要があります。

*注：* 排他的スタート状態はPOSIXの一部であるにもかかわらず、Lexではサ
ポートしていません。



File: flex-ja.info, Node: Activating States, Next: Start State Notes, Prev: Start States Explained, Up: Start States

状態の活性化
------------

スタート状態の名前を並べただけではあまり役に立ちません。つまり、スター
ト状態がいつ活性化されるのかということも制御しなければなりません。活性
化は、アクションの中、または、記述情報内の追加的なCコードを記述する領
域の中において、`BEGIN'を使うことで実現されます。使い方は以下のとおり
です。

     BEGIN(START_STATE_NAME);

例を挙げると、以下のようになります。

     %x COMMENT
     %%
     "{"            BEGIN(COMMENT);
     <COMMENT>"$R"  
     <COMMENT>"$I"  
     <COMMENT>"$M"  
         ...  
     <COMMENT>"}"   BEGIN(INITIAL);

この場合、Pascalのコメントの先頭部分を見つけると`COMMENT'状態に移行し、
コンパイラ・オプションを認識するようになります。`BEGIN'は最初の`%%'の
直後（最初のルールの前）において使うこともでき、この場合は`yylex()'は
常に指定された状態で開始されます。

上の例においては、定義されていない`INITIAL'という状態があることに注意
してください。この状態は常に利用可能で、*活性化された状態が１つも存在
しない時*のスキャナの初期状態を表します。つまり、`BEGIN(INITIAL)'によっ
て、スキャナの状態が効果的に（もちろん、その時点においてスキャンしてい
る箇所を維持したまま）リセットされることを意味しています。



File: flex-ja.info, Node: Start State Notes, Next: Start State Example, Prev: Activating States, Up: Start States

スタート状態に関する注
----------------------

以下に、スタート状態の使用に関する注をいくつか示します。

   * 特殊文字

     １つのルールにおいては、単一のスタート状態、または、カンマで区切
     られたスタート状態のリストのみを使用することができます。また、こ
     うしたスタート状態の指定はルールの先頭になければなりません。次に
     示すものは正当です。

          %x state1
          %s state2
          %%
          <state1> "something"
          <state2> "another thing"
          <state, state2> "something else"

     しかし、次に示すものは不当です。

          %x state1
          %s state2
          %%
          wrong<state1>
          <state1><state2>"wrong"
          <state2>"wrong"<state1>

   * 排他的スタート状態

     排他的スタート状態は、他のすべての状態を「無効」にするので、強力
     です。これは、スキャナの内部においてもう１つのスキャナを効果的に
     定義することができることを意味しています。これにより例えば、スター
     ト状態次第で、CとPascalの両方をスキャンするスキャナを定義すること
     が、理論的には可能になります。以下のようなコードが持つ効果を想像
     してみてください。

          %x PASCAL
          %x C
          %%
          <PASCAL>begin     return(OPEN_BLOCK);
          <PASCAL>end       return(CLOSE_BLOCK);
          <C>{              return(OPEN_BLOCK);
          <C>}              return(CLOSE_BLOCK);

   * スタート状態の名前

     前述のとおり、スタート状態はそれ自身の名前空間を持っていません。
     その理由は、スタート状態が`#define'とほとんど同じ方法で整数値とし
     て定義されているからです。このことは、整数値と同様、スタート状態
     の「スタック」のようなものを作成することが可能であることを意味し
     ています。例えば、

          %{
              int last_state[MAX_STATES]
              int state_count = 0;
          %}
          %x FOO BAR baz
          %%
          FOO        {
                        last_state[state_count] = FOO;
                        state_count++; 
                        BEGIN(baz);
                     }
          BAR        {
                        last_state[state_count] = BAR;
                        state_count++; 
                        BEGIN(baz);
                     }
          <baz>RULE 1
               ...  
          <baz>RULE N
          <baz>END   {
                        statecount--;
                        BEGIN(last_state[statecount]);
                     } 

     は`FOO'と`BAR'の両方によって`baz'状態を活性化させ、`<baz>END'とい
     うルールによって１つ前の状態に戻します。こうした「状態スタック」
     は将来、Flexの特徴的な機能になるかもしれません。 (1) (*Note Start
     State Notes-Footnotes::)



File: flex-ja.info  Node: Start State Notes-Footnotes, Up: Start State Notes

(1) 訳注：Flex 2.5は、スタート状態スタックをサポートしています。
次節（*Note Start State Notes (Flex 2.5)::）を参照してください。



File: flex-ja.info, Node: Start State Notes (Flex 2.5), Next: Start State Example, Prev: Start State Notes, Up: Start States

スタート状態に関する注（Flex 2.5の補足情報）
--------------------------------------------

Flex 2.5では、以下の新機能を利用することができます。

   * ワイルド・カード

     スタート状態`<*>'には特殊な意味があり、すべてのスタート状態にマッ
     チします。

     例えば、

          %x state1
          %%
          <state1>"one" printf("two");
          <*>"three"    printf("four");

     は、

          %s state1
          %%
          <state1>"one" printf("two");
          "three"	      printf("four");

     と同じ意味になります。

   * カレントなスタート状態

     マクロ`YY_START'により、カレントなスタート状態を参照することがで
     きます。

     前節（*Note Start State Notes::）の「スタート状態の名前」に示した
     例では、カレントなスタート状態を配列`last_state'に格納する処理を、
     以下のように記述していますが、

          FOO        {
                        last_state[state_count] = FOO;
                        ...
                     }

     この代入は、

                        last_state[state_count] = YY_START;

     のように書き換えることができます。

     Lexとの互換性のために、`YYSTATE'が、`YY_START'の別名として定義さ
     れています。

   * スタート状態のスコープ

     スタート状態のスコープを定義することができます。これにより、同じ
     スタート状態において複数のルールが存在する時に、その個々のルール
     にスタート状態を指定する必要がなくなります。

     スタート状態のスコープの形式は、以下のとおりです。

          <START_STATES>{
          ...
          }

     ここで、START_STATESは、単一のスタート状態、または、カンマで区切
     られたスタート状態のリストです。スタート状態のスコープの境界は、
     `{'と`}'によって指定されます。スタート状態のスコープを入れ子にす
     ることも可能です。

     *Note Activating States::に示した例を、スタート状態のスコープを使っ
     て書き直すと、以下のようになります。

          %x COMMENT
          %%
          "{"            BEGIN(COMMENT);
          <COMMENT>{
              "$R"  
              "$I"  
              "$M"  
              ...  
              "}"        BEGIN(INITIAL);
          }

   * スタート状態スタック

     スキャナ定義ファイルで`%option stack'を指定すると、スタート状態ス
     タックを利用できます。スタート状態スタックを操作するために、以下
     の関数が提供されています。

     `void yy_push_state(int NEW_STATE)'
          カレントなスタート状態をスタート状態スタックにプッシュし、
          NEW_STATE状態に遷移します。

     `void yy_pop_state()'
          スタート状態スタックからスタート状態をポップし、そのポップさ
          れたスタート状態に遷移します。

     `int yy_top_state()'
          スタート状態スタックの先頭にあるスタート状態を返します（スター
          ト状態スタックの内容は変更されません）。

     前節（*Note Start State Notes::）の「スタート状態の名前」に示した
     例を、スタート状態スタックを使って書き直すと以下のようになります。

          %option stack
          %x FOO BAR baz
          %%
          FOO        {
                        yy_push_state(baz);
                     }
          BAR        {
                        yy_push_state(baz);
                     }
          <baz>RULE 1
               ...  
          <baz>RULE N
          <baz>END   {
                        yy_pop_state();
                     } 



File: flex-ja.info, Node: Start State Example, Prev: Start State Notes, Up: Start States

スタート状態の使用例
--------------------

プログラミングにおいて、何かをする方法を学ぶのに最良の方法は、実際にそ
れをやってみることです。そのことに留意し、スタート状態をどのように使う
ことができるかを示す実例を以下に挙げます。


     /*
      * dates.lex: 日付の異なる形式を識別するために
      *            スタート状態を使用する例
      */

     %{
     #include <ctype.h>

     char month[20],dow[20],day[20],year[20];

     %}

     skip of|the|[ \t,]* /* この文字の並びを無視する */

     mon  (mon(day)?)    /* 曜日の名前の長い形式と短い形式の */
     tue  (tue(sday)?)   /* どちらにもマッチするよう設定する */
     wed  (wed(nesday)?)
     thu  (thu(rsday)?)
     fri  (fri(day)?)
     sat  (sat(urday)?)
     sun  (sun(day)?)

      /* 以下はすべての可能な曜日を表す */

     day_of_the_week ({mon}|{tue}|{wed}|{thu}|{fri}|{sat}|{sun})

     jan  (jan(uary)?)   /* すべての月について同様のことを行う */
     feb  (feb(ruary)?)
     mar  (mar(ch)?)
     apr  (apr(il)?)
     may  (may)
     jun  (jun(e)?)
     jul  (jul(y)?)
     aug  (aug(ust)?)
     sep  (sep(tember)?)
     oct  (oct(ober)?)
     nov  (nov(ember)?)
     dec  (dec(ember)?)

      /* 以下はすべての可能な月の名前を表す */

     first_half  ({jan}|{feb}|{mar}|{apr}|{may}|{jun})
     second_half ({jul}|{aug}|{sep}|{oct}|{nov}|{dec})
     month       {first_half}|{second_half}

      /*
       * 日、月、年の数値形式
       * これらは重複しているため、正しくパースするには、
       * スタート状態と日付の形式に関するある程度の知識
       * が必要であることに注意
       */

     nday         [1-9]|[1-2][0-9]|3[0-1] 
     nmonth       [1-9]|1[0-2]
     nyear        [0-9]{1,4}

      /* 年と日のための拡張子 */

     year_ext    (ad|AD|bc|BC)?
     day_ext     (st|nd|rd|th)?

       /*
        * このプログラムの最後にあるルールを使ってすべての無関係な
        * テキストを処理するために、非排他的なスタート状態を使う。
        * こうしないと、個々のスタート状態のブロックにルールを追加
        * しなければならなくなる。規模の大きいスキャナにおいては、
        * これは実行可能な選択肢であることが多い。なぜなら、ルール
        * の追加はスキャナのスピードに影響を与えないからである。
        * ここでは、簡潔さを優先させることにする
        */

     %s LONG SHORT
     %s DAY MONTH   /* 長い形式の日付のために追加した状態 */
     %s YEAR_FIRST YEAR_LAST YFMONTH YLMONTH

     %%

      /*
       * 曜日は常に最初に置かれ、後ろに続く日付の修飾子として
       * 機能するものと仮定される。よって、曜日は複数の日付形式
       * の間で共用可能である
       */

     <LONG>{day_of_the_week} strcpy(dow,yytext); 

      /*
       * 月-日-年という形式の日付を処理する
       * パース状態は
       * LONG->[月にマッチ]->DAY->LONG
       * のように遷移する
       */

     <LONG>{month}         strcpy(month,yytext); BEGIN(DAY);
     <DAY>{nday}{day_ext}  strcpy(day,yytext);   BEGIN(LONG);  

      /*
       * 日-月-年という形式の日付を処理する
       * パース状態は
       * LONG->[日にマッチ]->MONTH->LONG
       * のように遷移する
       */

     <LONG>{nday}{day_ext} strcpy(day,yytext);   BEGIN(MONTH);
     <MONTH>{month}        strcpy(month,yytext); BEGIN(LONG);

      /*
       * 日付の年の部分は最後に置かれるものと考えられる。したがって、
       * 年を見つけたらパースされた日付を表示することができる。もち
       * ろん、日付として不当なものであればゴミが出力されることになる
       */

     <LONG>{nyear}{year_ext} {
                               printf("Long:\n");
                               printf("  DOW   : %s \n",dow);
                               printf("  Day   : %s \n",day);
                               printf("  Month : %s \n",month);
                               printf("  Year  : %s \n",yytext);
                               strcpy(dow,"");
                               strcpy(day,"");
                               strcpy(month,"");
                             }

      /*
       * 日-月-年という形式の日付を処理する
       * SHORT状態で数値形式の日を見つけた場合は、年が日付の最後の部分
       * になると仮定する
       * パース状態は
       * SHORT->[日にマッチ]->YEAR_LAST->YLMONTH->SHORT
       * のように遷移する
       */

     <SHORT>{nday}        strcpy(day,yytext);  BEGIN(YEAR_LAST);
     <YEAR_LAST>{nmonth}  strcpy(month,yytext);BEGIN(YLMONTH);
     <YLMONTH>{nyear}     strcpy(year,yytext); BEGIN(SHORT);

      /*
       * 年-月-日という形式の日付を処理する
       * SHORT状態で数値形式の年を見つけた場合は、日が日付の最後の部分
       * になると仮定する
       * パース状態は
       * SHORT->[年にマッチ]->YEAR_FIRST->YFMONTH->SHORT 
       * のように遷移する
       */

     <SHORT>{nyear}        strcpy(year,yytext); BEGIN(YEAR_FIRST);
     <YEAR_FIRST>{nmonth}  strcpy(month,yytext);BEGIN(YFMONTH);
     <YFMONTH>{nday}       strcpy(day,yytext);  BEGIN(SHORT);

      /*
       * 数値形式の日付では、年は最初になることも最後になることも可能。
       * したがって、パースしたものをいつ表示すべきかを示すのに改行を使う
       */

     <SHORT>\n               {
                               printf("Short:\n");
                               printf("  Day   : %s \n",day);
                               printf("  Month : %s \n",month);
                               printf("  Year  : %s \n",year);
                               strcpy(year,""); 
                               strcpy(day,"");
                               strcpy(month,"");
                             }

      /*
       * 以下により、短い（数字）形式と長い（英数字）形式とを切り換える
       */

     long\n     BEGIN(LONG);
     short\n    BEGIN(SHORT);

      /*
       * 以下のルールは、無関係なテキストを見つけて破棄する
       * （マッチされたテキストはデフォルトではECHOされないが、
       *   マッチされなかったテキストはECHOされる。ピリオドは
       *   改行以外のすべての文字を見つける。改行は\nによって
       *   見つけられる）
       */

     {skip}*
     \n
     .  

この実例は、様々な形式の日付をスキャンし、構成単位に分割します。例えば、
以下のものを正しくスキャンし、日付の個々の部分を識別します。

     short
     1989:12:23
     1989:11:12
     23:12:1989
     11:12:1989
     1989/12/23
     1989/11/12
     23/12/1989
     11/12/1989
     1989-12-23
     1989-11-12
     23-12-1989
     11-12-1989
     long
     Friday the 5th of January, 1989
     Friday, 5th of January, 1989
     Friday, January 5th, 1989
     Fri, January 5th, 1989
     Fri, Jan 5th, 1989
     Fri, Jan 5, 1989
     FriJan 5, 1989
     FriJan5, 1989
     FriJan51989
     Jan51989

ファイルの最初の部分では、月、および、日付の異なる部分に使われる数字形
式を単に定義しています。この実例では、ある特定の方法でスキャン処理が進
行するよう強制するために、スタート状態を使います。例えば、行の先頭で
`1989'を見つければ、それが日と月の組み合わせではなく年であり、したがっ
て、日付の次の部分が月に違いないことが分り、スキャン処理がそのとおりに
進むよう強制します。このことにより、非常に単純な状態駆動のパーサを効果
的に作成したことになり、日付をその構成要素にうまく分割することができる
ようになります（このスキャナの内部で起こっていることをフロー・チャート
に描いてみれば、このことが明瞭に見てとれるでしょう）。

このマニュアル中の他の実例と同様に、この実例も

     flex -i dates.lex
     cc -o dates lex.yy.c -lfl

を実行することによりコンパイルすることができます。また、`examples'サブ
ディレクトリにおいて単に`make dates'を実行することにより、コンパイルす
ることもできます。




File: flex-ja.info, Node: %option (Flex 2.5), Prev: Start States, Up: Flex Descriptions

%option（Flex 2.5の補足情報）
=============================

Flex 2.5では、スキャナ定義ファイルの中で様々なオプションを指定すること
ができます。オプションを指定するには、スキャナ定義ファイルの先頭（最初
の`%%'よりも前の部分）に、`%option'指示子を記述します。

ほとんどの`%option'指示子は、以下の形式で指定されます。

     %option OPTION_NAME

オプションOPTION_NAMEの指定を無効にするためには、オプション名の前に
`no'を付けます。

     %option noOPTION_NAME


以下に、コマンドライン・オプションと同等の効果を持つ`%option'指示子を
示します。各コマンドライン・オプションの意味については、*Note Command
Line Switches::と*Note Command Line Switches (Flex 2.5)::を参照してく
ださい。

`%option 7bit'
     -7オプション

`%option 8bit'
     -8オプション

`%option align'
     -Caオプション

`%option backup'
     -bオプション

`%option batch'
     -Bオプション

`%option c++'
     -+オプション

`%option caseful'
     -iオプションの否定

`%option case-sensitive'
     -iオプションの否定

`%option case-insensitive'
     -iオプション

`%option caseless'
     -iオプション

`%option debug'
     -dオプション

`%option default'
     -sオプションの否定

`%option ecs'
     -Ceオプション

`%option fast'
     -Fオプション

`%option full'
     -fオプション

`%option interactive'
     -Iオプション

`%option lex-compat'
     -lオプション

`%option meta-ecs'
     -Cmオプション

`%option output="FILE"'
     -oFILEオプション

`%option perf-report'
     -pオプション

`%option prefix="PREFIX"'
     -PPREFIXオプション

`%option read'
     -Crオプション

`%option stdout'
     -tオプション

`%option verbose'
     -vオプション

`%option warn'
     -wオプションの否定


次に、コマンドライン・オプションでは代替できない`%option'指示子を示し
ます。

`%option array'
     `yytext'を`char'の配列として定義します。これは、`%array'と同じで
     す。

`%option always-interactive'
     入力を常に対話的に扱うスキャナを生成するよう指示します。これと
     `%option never-interactive'のどちらも指定されない場合、生成された
     スキャナは、ファイルをオープンするたびに`isatty()'を呼び出して、
     入力を対話的に（１文字ずつ）読み込むべきか否かを決定します。

`%option main'
     生成されるスキャナに、以下のような`main()'関数を組み込むよう指示
     します。

          int main()
          	{
          	yylex();
          	return 0;
          	}

     これは、暗黙のうちに`%option noyywrap'を指定します。

`%option never-interactive'
     入力を常に対話的に扱わないスキャナを生成するよう指示します。これ
     と`%option always-interactive'のどちらも指定されない場合、生成さ
     れたスキャナは、ファイルをオープンするたびに`isatty()'を呼び出し
     て、入力を対話的に（１文字ずつ）読み込むべきか否かを決定します。

`%option pointer'
     `yytext'を`char'に対するポインタとして定義します。これは、
     `%pointer'と同じです。

`%option reject'
     スキャナ定義ファイルの中で`REJECT'が使われていることを、Flexに通
     知します。Flexは通常、定義ファイルの中で`REJECT'が使われているか
     否かを自分で調査しますが、この`%option'指示子の指定は、Flex自身に
     よる判定結果に優先します。

`%option stack'
     スタート状態スタック（*Note Start State Notes (Flex 2.5)::を参照）
     を使用するためには、この`%option'指示子を指定しなければなりません。

`%option stdinit'
     `yyin'を`stdin'で、`yyout'を`stdout'で、それぞれ初期化します。こ
     の`%option'指示子が指定されない場合、あるいは、`%option
     nostdinit'が指定された場合、`yyin'と`yyout'は、`(FILE *)0'（NULL
     ポインタ）で初期化されます。

`%option unput'
     `%option *no*unput'が指定されると、生成されるスキャナの中に、関数
     `unput()'が組み込まれません。 (1) (*Note %option (Flex
     2.5)-Footnotes::)

`%option yy_pop_state'
     `%option *no*yy_pop_state'が指定されると、生成されるスキャナの中
     に、関数`yy_pop_state()'が組み込まれません。ただし、`%option
     stack'が指定されていない場合は、`%option *no*yy_pop_state'の指定
     の有無にかかわらず、関数`yy_pop_state()'は組み込まれません。

`%option yy_push_state'
     `%option *no*yy_push_state'が指定されると、生成されるスキャナの中
     に、関数`yy_push_state()'が組み込まれません。ただし、`%option
     stack'が指定されていない場合は、`%option *no*yy_push_state'の指定
     の有無にかかわらず、関数`yy_push_state()'は組み込まれません。

`%option yy_scan_buffer'
     `%option *no*yy_scan_buffer'が指定されると、生成されるスキャナの
     中に、関数`yy_scan_buffer()'が組み込まれません。

`%option yy_scan_bytes'
     `%option *no*yy_scan_bytes'が指定されると、生成されるスキャナの中
     に、関数`yy_scan_bytes()'が組み込まれません。

`%option yy_scan_string'
     `%option *no*yy_scan_string'が指定されると、生成されるスキャナの
     中に、関数`yy_scan_string()'が組み込まれません。

`%option yy_top_state'
     `%option *no*yy_top_state'が指定されると、生成されるスキャナの中
     に、関数`yy_top_state()'が組み込まれません。ただし、`%option
     stack'が指定されていない場合は、`%option *no*yy_top_state'の指定
     の有無にかかわらず、関数`yy_top_state()'は組み込まれません。

`%option yyclass="CLASSNAME"'
     これは、`-+'オプションが指定されている場合（すなわち、C++スキャナ
     を生成する場合）のみ有効です。これにより、CLASSNAMEにより指定され
     る名前のクラスが、`yyFlexLexer'のサブクラスとして定義されます。実
     際にスキャン処理を実行するコードは、クラスCLASSNAMEのメンバ関数
     `yylex()'（`CLASSNAME::yylex()'）に実装されます。詳細については、
     *Note Flex and C++ (Flex 2.5)::を参照してください。

`%option yylineno'
     入力の行数をカウントして大域変数`yylineno'に保持するスキャナを生
     成するよう指示します。

`%option yymore'
     スキャナ定義ファイルの中で`yymore()'が使われていることを、Flexに
     通知します。Flexは通常、定義ファイルの中で`yymore()'が使われてい
     るか否かを自分で調査しますが、この`%option'指示子の指定は、Flex自
     身による判定結果に優先します。

`%option yywrap'
     `%option *no*yywrap'が指定されると、`yywrap()'はマクロとして、

          #define yywrap() 1

     のように定義されます。この結果、ファイルの終端を検出した時に、ス
     キャナは、ほかにスキャンすべきファイルは存在しないと判断するよう
     になります。




