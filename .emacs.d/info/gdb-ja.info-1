Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.





File: gdb-ja.info, Node: Top, Next: Summary, Prev: (dir), Up: (dir)

Debugging with GDB
******************

このファイルには、GNUのシンボリック・デバッガであるGDBのことが説明して
あります。

Seventh版、February 1999、GDBバージョン4.18

Copyright (C) 1988-1999 Free Software Foundation, Inc.
* Menu:

* Summary::                     GDBの要約
* Sample Session::              GDBセッションのサンプル

* Invocation::                  GDBの起動・終了
* Commands::                    GDBコマンド
* Running::                     GDB配下でのプログラムの実行
* Stopping::                    停止と継続
* Stack::                       スタックの検査
* Source::                      ソース・ファイルの検査
* Data::                        データの検査
* Languages::                   異なる言語の使用


* Symbols::                     シンボル・テーブルの検査
* Altering::                    実行の変更
* GDB Files::                   GDBファイル
* Targets::                     デバッグ・ターゲットの指定
* Controlling GDB::             GDBの制御
* Sequences::                   一連のコマンドのグループ化
* Emacs::                       GNU Emacsの中でのGDBの使用

* GDB Bugs::                    GDBのバグ報告

* Formatting Documentation::    GDBドキュメントのフォーマットと印刷


* Command Line Editing::        コマンドライン編集
* Using History Interactively:: ヒストリの対話的な使用
* Installing GDB::              GDBのインストール
* Index::                       インデックス

 -- The Detailed Node Listing ---

GDBの要約

* Free Software::               フリー・ソフトウェア
* Contributors::                GDBに貢献した人々

GDBの起動・終了

* Invoking GDB::                GDBの起動
* Quitting GDB::                GDBの終了
* Shell Commands::              GDBの中でのシェル・コマンドの使用

GDBの起動

* File Options::                ファイルの選択
* Mode Options::                モードの選択

GDBコマンド

* Command Syntax::              GDBに対するコマンドの指定
* Completion::                  コマンド名の補完
* Help::                        ヘルプの表示

GDB配下でのプログラムの実行

* Compilation::                 デバッグのためのコンパイル
* Starting::                    ユーザ・プログラムの起動
* Arguments::                   ユーザ・プログラムの引数
* Environment::                 ユーザ・プログラムの環境

* Working Directory::           ユーザ・プログラムの作業ディレクトリ
* Input/Output::                ユーザ・プログラムの入出力
* Attach::                      既に実行中のプロセスのデバッグ
* Kill Process::                子プロセスの終了
* Process Information::         追加のプロセス情報

* Threads::                     マルチスレッド・プログラムのデバッグ
* Processes::                   マルチプロセス・プログラムのデバッグ

停止と継続

* Breakpoints::                 ブレイクポイント、ウォッチポイント、キャッチポイント
* Continuing and Stepping::     実行の再開
* Signals::                     シグナル
* Thread Stops::                マルチスレッド・プログラムの停止と起動

ブレイクポイント、ウォッチポイント、キャッチポイント

* Set Breaks::                  ブレイクポイントの設定
* Set Watchpoints::             ウォッチポイントの設定
* Set Catchpoints::             キャッチポイントの設定
* Delete Breaks::               ブレイクポイントの削除
* Disabling::                   ブレイクポイントの無効化
* Conditions::                  ブレイクポイントの成立条件
* Break Commands::              ブレイクポイント・コマンド・リスト
* Breakpoint Menus::            ブレイクポイント・メニュー

スタックの検査

* Frames::                      スタック・フレーム
* Backtrace::                   バックトレース
* Selection::                   フレームの選択
* Frame Info::                  フレームに関する情報
* Alpha/MIPS Stack::            Alpha/MIPSマシンの関数スタック

ソース・ファイルの検査

* List::                        ソース行の表示
* Search::                      ソース・ファイル内の検索
* Source Path::                 ソース・ディレクトリの指定
* Machine Code::                ソースとマシン・コード

データの検査

* Expressions::                 式
* Variables::                   プログラム変数
* Arrays::                      人工配列
* Output Formats::              出力フォーマット
* Memory::                      メモリの調査
* Auto Display::                自動表示
* Print Settings::              表示設定
* Value History::               値ヒストリ
* Convenience Vars::            コンビニエンス変数
* Registers::                   レジスタ
* Floating Point Hardware::     浮動小数ハードウェア

異なる言語の使用

* Setting::                     ソース言語の切り替え
* Show::                        言語の表示
* Checks::                      型と範囲のチェック

* Support::                     サポートされる言語

ソース言語の切り替え

* Filenames::                   ファイル拡張子と言語
* Manually::                    手作業による作業言語の設定
* Automatically::               GDBによる作業言語の推定

型と範囲のチェック

* Type Checking::               型チェックの概要
* Range Checking::              範囲チェックの概要

サポートされる言語

* C::                           C/C++

C言語サポート

* C Operators::                 C演算子

C言語サポート

* C Operators::                 C/C++演算子
* C Constants::                 C/C++定数
* Cplus expressions::           C++式
* C Defaults::                  C/C++のデフォルト設定
* C Checks::                    C/C++の型チェックと範囲チェック
* Debugging C::                 GDBとC
* Debugging C plus plus::       C++用のGDB機能

Modula-2

* M2 Operators::                組み込み演算子
* Built-In Func/Proc::          組み込み関数と組み込みプロシージャ
* M2 Constants::                Modula-2定数
* M2 Defaults::                 Modula-2デフォルト設定
* Deviations::                  標準Modula-2との差異
* M2 Checks::                   Modula-2の型チェックと範囲チェック
* M2 Scope::                    スコープ演算子`::'と`.'
* GDB/M2::                      GDBとModula-2

実行の変更

* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続
* Signaling::                   ユーザ・プログラムへのシグナルの通知
* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用

GDBファイル

* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー

デバッグ・ターゲットの指定

* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド
* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ

リモート・デバッグ

* Remote Serial::               GDBリモート・シリアル・プロトコル

* i960-Nindy Remote::		GDBとリモートi960（Nindy）

* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル

* VxWorks Remote::		GDBとVxWorks

* ST2000 Remote::               GDBとTandem ST2000

* Hitachi Remote::              GDBと日立のマイクロ・プロセッサ

* MIPS Remote::			GDBとMIPSボード

* Simulator::                   シミュレートされたCPUターゲット

GDBの制御

* Prompt::                      プロンプト
* Editing::                     コマンド編集
* History::                     コマンド・ヒストリ
* Screen Size::                 画面サイズ
* Numbers::                     数値
* Messages/Warnings::           オプションの警告およびメッセージ

一連のコマンドのグループ化

* Define::                      ユーザ定義コマンド
* Hooks::                       ユーザ定義コマンド・フック
* Command Files::               コマンド・ファイル
* Output::                      制御された出力を得るためのコマンド

GDBのバグ報告

* Bug Criteria::                本当にバグを見つけたのかどうかを知る方法
* Bug Reporting::               バグの報告方法

GDBのインストール

* Separate Objdir::             異なるディレクトリでのGDBのコンパイル
* Config Names::                ホストとターゲットの名前の指定
* Configure Options::           configureオプションの要約




File: gdb-ja.info, Node: Summary, Next: Sample Session, Prev: Top, Up: Top

GDBの要約
*********

GDBのようなデバッガの目的は、実行中のプログラムの内部において何が起こっ
ているのか、あるいは、プログラムがクラッシュしたときに何をしていたのか
を知ることができるようにすることにあります。

GDBは、実際のバグを発見できるようにするために4つのこと（さらに、これら
を支援するために他のことも）行います。

   * ユーザ・プログラムを、その動作に影響を与える可能性のある様々なこ
     とを指定して起動する

   * 指定された条件が成立したときにユーザ・プログラムを停止する

   * 停止したときにユーザ・プログラムが何を行っていたかを調べる

   * ユーザ・プログラムの内部を変更することによって、1つのバグの影響を
     試験的に修正して、ほかのバグについて調べる

GDBを使ってCおよびC++で記述されたプログラムをデバッグすることができま
す。詳細については、*Note C and C++: C。

Modula-2とChillのサポートはまだ部分的なものです。Modula-2に関する情報
については、*Note Modula-2: Modula-2。Chillに関するドキュメントはまだ
ありません。

集合、サブ範囲（subrange）、ファイル変数、入れ子関数を使っているPascal
プログラムをデバッグすることは、現時点ではできません。Pascalの構文を使っ
て、式の入力、変数の値の表示、およびそれに類することを実行することを、
GDBはサポートしていません。

GDBは、Fortranで記述されたプログラムのデバッグに使うことができます。し
かし、Fortranの構文を使って、式の入力、変数の値の表示、およびそれに類
する機能を実行することは、まだサポートされていません。変数によっては、
末尾にアンダースコアを付けて参照する必要のある場合があります。


* Menu:

* Free Software::               フリー・ソフトウェア
* Contributors::                GDBに貢献した人々



File: gdb-ja.info, Node: Free Software, Next: Contributors, Prev: Summary, Up: Summary

フリー・ソフトウェア
====================

GDBは"フリー・ソフトウェア"であり、GNU General Public License （GPL）
により保護されています。あなたは、GPLによって、ライセンスされたプログ
ラムをコピーしたり改造したりする自由を与えられます。しかし、コピーを入
手した人は誰でも、そのコピーとともに、そのコピーを修正する自由を手に入
れますし（つまりソース・コードを入手することができなければならないとい
うことです）、また、さらにそのコピーを配布する自由も手に入れます。通常、
ソフトウェア会社は、著作権によりユーザの自由を妨げます。Free Software
FoundationはGPLを使ってこれらの自由を保護します。

基本的には、GPLは、「あなたはこれらの自由を与えられるが、これらの自由
をほかの誰からも奪うことはできない」と主張するライセンスです。



File: gdb-ja.info, Node: Contributors, Prev: Free Software, Up: Summary

GDBに貢献した人々
=================

Richard Stallmanは、GDB、および、その他の多くのGNU プログラムの最初の
開発者です。ほかにも多くの人々がGDBの開発に貢献してきました。この節で
は、主要な貢献者を紹介したいと思います。フリー・ソフトウェアの素晴らし
い点の1つは、誰もがそれに貢献する自由があるということです。残念ながら、
ここですべての人を紹介することはできません。GDB ディストリビューション
に含まれる`ChangeLog' というファイルにおおまかな紹介を載せてあります。

バージョン2.0よりもずっと前の変更内容は、いつのまにか紛失してしまいま
した。

     *お願い:* このセクションへの追加は大歓迎です。あなたやあなたの友
     人（公平を期すため、あなたの敵も加えておきましょう）が不当にもこ
     のリストから除外されているのであれば、喜んで名前を付け加えます。

彼らの多大な労働が感謝されていないと思われないように、最初に、GDBの主
要なリリースを通じてGDBの面倒を見てきた人々に特に感謝します。その人々
とは、Jim Blandy（リリース4.18）、Jason Molenda（リリース4.17）、Stan
Shebs（リリース4.14）、Fred Fish（リリース4.16, 4.15, 4.13, 4.12,
4.11, 4.10, 4.9）、Stu GrossmanとJohn Gilmore（リリース4.8, 4.7, 4.6,
4.5, 4.4）、John Gilmore（リリース4.3, 4.2, 4.1, 4.0, 3.9）、Jim
Kingdon（リリース3.5, 3.4, 3.3）、Randy Smith（リリース3.2, 3.1, 3.0） 
です。

Richard Stallmanは、様々な機会にPeter TerMaat、Chris Hanson、Richard
Mlynarikの支援を受けながら、2.8までのリリースを担当しました。

Michael Tiemannは、GDBにおけるGNU C++サポートのほとんどを開発してくれ
ました。C++のサポートについては、Per Bothnerからも重要な貢献がありまし
た。James ClarkはGNU C++のデマングラ（demangler）を開発してくれました。
C++についての初期の仕事はPeter TerMaatによるものです（彼はまた、リリー
ス3.0までの一般的なアップデート作業の多くを担当してくれました）。

GDB 4は、複数のオブジェクト・ファイル・フォーマットを調べるのに BFD サ
ブルーチン・ライブラリを使用しています。BFDは、David V. Henkel-Wallace、
Rich Pixley、Steve Chamberlain、John Gilmoreによる共同プロジェクトです。

David Johnsonは、最初のCOFFサポートを開発してくれました。Pace Willison
は最初のカプセル化されたCOFF （encapsulated COFF）のサポートを開発して
くれました。

Harris Computer Systems社のBrent Bensonは、DWARF 2のサポート部分を提供
してくれました。

Adam de BoorとBradley DavisはISI Optimum Vのサポート部分を提供してくれ
ました。Per Bothner、引地信之、Alessandro Forinは、MIPSのサポート部分
を提供してくれました。Jean-Daniel FeketeはSun 386iのサポート部分を提供
してくれました。Chris HansonはHP9000サポートを改善してくれました。引地
信之と長谷井智之は、Sony/News OS 3のサポート部分を提供してくれました。
David JohnsonはEncore Umaxのサポート部分を提供してくれました。Jyrki
KuoppalaはAltos 3068のサポート部分を提供してくれました。Jeff LawはHP
PAとSOMのサポート部分を提供してくれました。Keith PackardはNS32Kのサポー
ト部分を提供してくれました。Doug RabsonはAcorn Risc Machineのサポート
部分を提供してくれました。Bob RuskはHarris Nighthawk CX-UXのサポート部
分を提供してくれました。Chris SmithはConvexのサポート（および、Fortran
デバッグのサポート）部分を提供してくれました。Jonathan StoneはPyramid
のサポート部分を提供してくれました。Michael TiemannはSPARCのサポート部
分を提供してくれました。Tim TuckerはGould NP1とGould Powernodeのサポー
ト部分を提供してくれました。Pace WillisonはIntel 386のサポート部分を提
供してくれました。Jay VosburghはSymmetryのサポート部分を提供してくれま
した。

Andreas SchwabはM68K Linuxのサポート部分を提供してくれました。

Rich SchaeferとPeter SchauerはSunOS共用ライブラリのサポートを手伝って
くれました。

Jay FenlasonとRoland McGrathは、GDBとGASがいくつかのマシン命令セットに
関して共通の認識を持つようにしてくれました。

Patrick Duval、Ted Goldstein、Vikram Koka、Glenn Engelはリモート・デバッ
グ機能の開発を手伝ってくれました。Intel社、Wind River Systems 社、AMD
社、ARM社はそれぞれ、i960、VxWorks、A29K UDI、RDIターゲット用のリモー
ト・デバッグ・モジュールを提供してくれました。

Brian Foxは、コマンドライン編集やコマンドライン・ヒストリを提供する
readlineライブラリの開発者です。

SUNY BuffaloのAndrew Beersは言語切り替えのソース・コードとModula-2サポー
トを開発し、このマニュアルのプログラミング言語関連（Languages）の章を
提供してくれました。

Fred FishはUnix System Vr4サポートのほとんどを開発してくれました。彼は
また、C++のオーバーロードされたシンボルを扱えるようコマンド補完機能を
拡張してくれました。

Hitachi America, Ltd.は、H8/300プロセッサ、H8/500プロセッサ、および、
Super-Hプロセッサのサポートを後援してくれました。

NECは、v850プロセッサ、Vr4xxxプロセッサ、および、Vr5xxxプロセッサのサ
ポートを後援してくれました。

Mitsubishi（三菱）は、D10Vプロセッサ、D30Vプロセッサ、および、M32R/Dプ
ロセッサのサポートを後援してくれました。

Toshiba（東芝）は、TX39 Mipsプロセッサのサポートを後援してくれました。

Matsushita（松下）は、MN10200プロセッサとMN10300プロセッサのサポートを
後援してくれました。

Fujitsu（富士通）は、SPARCliteプロセッサとFR30プロセッサのサポートを後
援してくれました。

Kung Hsu、Jeff Law、Rick Sladkeyはハードウェア・ウォッチポイントのサポー
トを追加してくれました。

Michael Snyderはトレースポイントのサポートを追加してくれました。

Stu Grossmanはgdbserverを開発してくれました。

Jim Kingdon、Peter Schauer、Ian Taylor、Stu GrossmanはGDB全体にわたっ
て、ほとんど数えることができないほどのバグ・フィックスとソース・コード
の整理を行ってくれました。

Hewlett-Packard社のBen Krepp、Richard Title、John Bishop、Susan
Macchia、Kathy Mann、Satish Pai、India Paul、Steve Rehrauer、Elena
Zannoniは、PA-RISC 2.0アーキテクチャ、HP-UX 10.20、10.30、11.0(narrow
mode)、HPによるカーネル・スレッドの実装、HP aC++コンパイラ、および、端
末ユーザ・インターフェイスの各サポート部分を提供してくれました。また、
このマニュアルの中のHP固有の情報は、Kim Haaseにより提供されたものです。

Cygnus Solutions社は、1991年以降、GDBの保守作業とGDBの多くの開発作業を
後援しています。フルタイムでGDBに関わる仕事をしたCygnusのエンジニアは、
Mark Alexander、Jim Blandy、Per Bothner、Edith Epstein、Chris Faylor、
Fred Fish、Martin Hunt、Jim Ingham、John Gilmore、Stu Grossman、Kung
Hsu、Jim Kingdon、John Metzler、Fernando Nasser、Geoffrey Noer、Dawn
Perchik、Rich Pixley、Zdenek Radouch、Keith Seitz、Stan Shebs、David
Taylor、Elena Zannoniです。さらに、Dave Brolley、Ian Carmichael、Steve
Chamberlain、Nick Clifton、JT Conklin、Stan Cox、DJ Delorie、Ulrich
Drepper、Frank Eigler、Doug Evans、Sean Fagan、David Henkel-Wallace、
Richard Henderson、Jeff Holcomb、Jeff Law、Jim Lemke、Tom Lord、Bob
Manson、Michael Meissner、Jason Merrill、Catherine Moore、Drew Moseley、
Ken Raeburn、Gavin Romig-Koch、Rob Savoye、Jamie Smith、Mike Stump、
Ian Taylor、Angela Thomas、Michael Tiemann、Tom Tromey、Ron Unrau、Jim
Wilson、David Zuhnは、大小様々な貢献をしてくれました。




File: gdb-ja.info, Node: Sample Session, Next: Invocation, Prev: Summary, Up: Top

GDBセッションのサンプル
***********************

その気になれば、このマニュアルを使ってGDBのすべてを学習することももち
ろん可能ですが、GDBを使い始めるには、いくつかのコマンドを知っていれば
十分です。本章では、そのようなコマンドについて説明します。



汎用的なマクロ・プロセッサであるGNU `m4'には、かつて、まだ正式なバージョ
ンがリリースされる以前に、次のような不具合がありました。引用を表わす文
字列をデフォルトとは異なるものに変更すると、あるマクロ定義の内部に入れ
子状態になっている他のマクロ定義を取り出すために使われるコマンドが、正
しく動作しなくなることがある、という不具合です。以下の短い`m4'セッショ
ンでは、`0000'に展開されるマクロ`foo'を定義しています。さらに、`m4'の
組み込みコマンド`defn'を使って、マクロ`bar'に同一の定義を与えています。
ところが、引用の開始文字列を`<QUOTE>'に、引用の終了文字列を`<UNQUOTE>'
にそれぞれ変更すると、全く同一の手順で新しい同義語`baz'を定義しようと
しても、うまくいかないのです。

     $ cd gnu/m4
     $ ./m4
     define(foo,0000)

     foo
     0000
     define(bar,defn(`foo'))

     bar
     0000
     changequote(<QUOTE>,<UNQUOTE>)

     define(baz,defn(<QUOTE>foo<UNQUOTE>))
     baz
     C-d
     m4: End of input: 0: fatal error: EOF in string

ここでGDBを使って、何が起こっているのか調べてみましょう。

     $ gdb m4
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see 
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty" 
      for details.

     GDB 4.18, Copyright 1999 Free Software Foundation, Inc...
     (gdb)

GDBは、必要なときに他のシンボルを見つけるのに最低限必要となるシンボル
情報しか読み込みません。その結果、最初のプロンプトが表示されるまでの時
間が極めて短いのです。ここで、出力情報がこのマニュアルの紙幅に収まるよ
うにするために、GDBに対して表示幅を通常よりも狭くするよう指示を出して
みましょう。

     (gdb) set width 70

`m4'の組み込みコマンドである`changequote'がどのように動作するのかを調
べてみる必要があります。ソースを見ると、関連するサブルーチンが
`m4_changequote'であることがわかります。そこで、GDBの`break'コマンドで
ブレイクポイントを設定してみます。

     (gdb) break m4_changequote
     Breakpoint 1 at 0x62f4: file builtin.c, line 879.

`run'コマンドを使って、GDBの管理下で`m4'を走らせます。`m4_changequote'
サブルーチンに到達するまでは、プログラムは通常どおりの動作をします。

     (gdb) run
     Starting program: /work/Editorial/gdb/gnu/m4/m4
     define(foo,0000)

     foo
     0000

ブレイクポイントでプログラムを停止させるために`changequote'を実行する
と、GDBは`m4'の実行を停止し、停止した箇所のコンテキスト情報を表示しま
す。

     changequote(<QUOTE>,<UNQUOTE>)

     Breakpoint 1, m4_changequote (argc=3, argv=0x33c70) 
         at builtin.c:879
     879         if (bad_argc(TOKEN_DATA_TEXT(argv[0]),argc,1,3))

次に`n'（`next'）コマンドを実行すると、現在停止している関数の中で1行だ
け処理が実行されます。

     (gdb) n
     882         set_quotes((argc >= 2) ? TOKEN_DATA_TEXT(argv[1])\
      : nil,

`set_quotes'というのは、いわくありげなサブルーチンです。`next'コマンド
の代わりに`s'（`step'）コマンドを使うことで、このサブルーチンの中に入
ることができます。`step'コマンドは、それが*どの*サブルーチンの中にある
かということにかかわりなく、次の1行に移動します。この場合、次の1行は
`set_quotes'の中ですから、そこへ移動することになります。

     (gdb) s
     set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     530         if (lquote != def_lquote)

`m4'がその中で現在停止しているサブルーチン（および、そのサブルーチンへ
の引数）が表示されています。これをスタック・フレーム表示と呼びます。そ
れは、スタックの状態を要約した情報を表示しています。`backtrace'コマン
ド（あるいは、`bt'と省略することもできます）を使って、現在、スタック全
体の中のどこにいるかを知ることもできます。`backtrace'コマンドは、アク
ティブなサブルーチンのスタック・フレームを表示します。

     (gdb) bt
     #0  set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     #1  0x6344 in m4_changequote (argc=3, argv=0x33c70) 
         at builtin.c:882
     #2  0x8174 in expand_macro (sym=0x33320) at macro.c:242
     #3  0x7a88 in expand_token (obs=0x0, t=209696, td=0xf7fffa30)
         at macro.c:71
     #4  0x79dc in expand_input () at macro.c:40
     #5  0x2930 in main (argc=0, argv=0xf7fffb20) at m4.c:195

次に、2、3行先に進んで、何が起こっているのかを見てみましょう。最初の2
回は、`s'コマンドを使います。続く2回は、`xstrdup'サブルーチンの中に入っ
てしまうのを防ぐために、`n'コマンドを使います。

     (gdb) s
     0x3b5c  532         if (rquote != def_rquote)
     (gdb) s
     0x3b80  535         lquote = (lq == nil || *lq == '\0') ?  \
     def_lquote : xstrdup(lq);
     (gdb) n
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup(rq);
     (gdb) n
     538         len_lquote = strlen(rquote);

最後に表示された行は、少し妙な感じがします。2つの変数`lquote'、
`rquote'を調べて、本当にそれが、新たに指定された引用開始文字列、引用終
了文字列であるかどうか確認することができます。値を調べるには`p'
（`print'）コマンドを使用します。

     (gdb) p lquote
     $1 = 0x35d40 "<QUOTE>"
     (gdb) p rquote
     $2 = 0x35d50 "<UNQUOTE>"

`lquote'と`rquote'は確かに引用開始文字列、引用終了文字列のようです。前
後関係を調べるには、`l'（`list'）コマンドを使って、現在停止している行
を中心にその前後10行を表示します。

     (gdb) l
     533             xfree(rquote);
     534
     535         lquote = (lq == nil || *lq == '\0') ? def_lquote\
      : xstrdup (lq);
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup (rq);
     537
     538         len_lquote = strlen(rquote);
     539         len_rquote = strlen(lquote);
     540     }
     541
     542     void

`len_lquote'と`len_rquote'に値を設定している行を実行させてから、それら
の値を調べてみましょう。

     (gdb) n
     539         len_rquote = strlen(lquote);
     (gdb) n
     540     }
     (gdb) p len_lquote
     $3 = 9
     (gdb) p len_rquote
     $4 = 7

`len_lquote'と`len_rquote'が、それぞれ`lquote'と`rquote'の長さであると
すると、ここに表示されている値は明らかに誤りです。`p'コマンドを使って、
正しい値を設定することができます。`p'コマンドによって任意の式の値を表
示することができますが、ここでいう「式」には、サブルーチンの呼び出しや、
値の割り当ても含まれます。

     (gdb) p len_lquote=strlen(lquote)
     $5 = 7
     (gdb) p len_rquote=strlen(rquote)
     $6 = 9

新しい引用文字列をセットした状態で、`m4'の組み込みコマンド`defn'を使用
しようとすると発生する問題を修正するには、これだけで十分でしょうか?
`c'（`continue'）コマンドを使えば、`m4'に処理を継続させて、実際に問題
を発生させていた例を実行することができます。

     (gdb) c
     Continuing.

     define(baz,defn(<QUOTE>foo<UNQUOTE>))

     baz
     0000

今度はうまくいきました。新たにセットされた引用文字列は、デフォルトの引
用文字列と同じように機能しました。問題の原因は、プログラム内の2箇所の
タイプ・ミスで、長さの設定が正しく行われていないことにあったようです。
EOFを入力して、`m4'を終了させましょう。

     C-d
     Program exited normally.

`Program exited normally.'というメッセージは、GDBが出力したもので、
`m4'の実行が終了したことを意味しています。GDBの`quit'コマンドで、GDBセッ
ションを終了することができます。

     (gdb) quit



File: gdb-ja.info, Node: Invocation, Next: Commands, Prev: Sample Session, Up: Top

GDBの起動・終了
***************

本章では、GDBの起動方法、終了方法を説明します。基本は、以下の2つです。

   * `gdb'と入力してGDBを起動する
   * `quit'または`C-d'を入力してGDBを終了する

* Menu:

* Invoking GDB::                GDBの起動
* Quitting GDB::                GDBの終了
* Shell Commands::              GDBの中でのシェル・コマンドの使用



File: gdb-ja.info, Node: Invoking GDB, Next: Quitting GDB, Prev: Invocation, Up: Invocation

GDBの起動
=========


`gdb'というプログラムを実行することで、GDBが起動されます。ひとたび起動
されると、GDBは終了を指示されるまで、端末からのコマンド入力を受け付け
ます。

あるいは、最初からGDBのデバッグ環境を指定するために、様々な引数やオプ
ションを指定して`gdb'プログラムを実行することもできます。

ここで説明するコマンドライン・オプションは、様々な状況に対応するために
設計されたものです。環境によっては、ここで説明するオプションのいくつか
は、事実上使用できない場合もあります。

GDBの最も基本的な起動方法は、デバッグされる実行プログラムの名前を引数
に指定することです。

     gdb PROGRAM

起動時に、実行プログラム名とともに、コア・ファイルの名前を指定すること
もできます。

     gdb PROGRAM CORE

あるいは、既に実行中のプロセスをデバッグする場合には、そのプロセスIDを
第2引数に指定することもできます。

     gdb PROGRAM 1234

ここでは、GDBはプロセスID `1234'のプロセスにアタッチします（ただし、
`1234'という名前のファイルが存在しないというのが条件です。GDBは、まず
コア・ファイルの存在を確認します）。

このような第2引数の利用が可能であるためには、かなり完成されたオペレー
ティング・システムが必要になります。ボード・コンピュータに接続して、リ
モート・デバッガとしてGDBを使用する場合には、そもそも「プロセス」とい
う概念がないかもしれませんし、多くの場合、コア・ダンプというものもない
でしょう。

`gdb'を起動すると、GDBの無保証性を説明する文章が表示されますが、
`-silent'オプションを指定することで、これを表示しないようにすることも
できます。

     gdb -silent

コマンドライン・オプションを指定することで、GDBの起動方法をさらに制御
することができます。GDB自身に、使用可能なオプションを表示させることが
できます。


     gdb -help

のようにgdbプログラムを実行することで、使用可能なオプションがすべて、
その使用方法についての簡単な説明付きで表示されます（短縮して、`gdb -h'
という形で実行しても同じ結果が得られます）。

ユーザの指定したすべてのオプションと引数は、順番に処理されます。`-x'オ
プションが指定されている場合は特別で、順序の違いに意味がでてきます。

* Menu:


* File Options::                ファイルの選択
* Mode Options::                モードの選択




File: gdb-ja.info, Node: File Options, Next: Mode Options, Prev: Invoking GDB, Up: Invoking GDB

ファイルの選択
--------------

起動されたGDBは、指定された引数のうちオプション以外のものは、実行ファ
イル名およびコア・ファイル名（あるいはプロセスID）であると解釈します。
これは、`-se'オプションと`-c'オプションが指定されたのと同じことです
（GDBは、対応するオプション・フラグを持たない最初の引数を`-se'オプショ
ン付きと同等とみなし、同じく対応するオプション・フラグを持たない第2の
引数があれば、これを`-c'オプション付きと同等とみなします）。

多くのオプションには、完全形と短縮形があります。以下の一覧では、その両
方を示します。オプション名は、他のオプションと区別がつけば、最後まで記
述しなくても、GDBによって正しく認識されます（オプション名には`-'ではな
く`--'を使うことも可能ですが、ここでは一般的な慣例にしたがうこととしま
す）。

`-symbols FILE'
`-s FILE'
     FILEで指定されるファイルからシンボル・テーブルを読み込みます。

`-exec FILE'
`-e FILE'
     可能であれば、FILEで指定されるファイルを、実行ファイルとして使い
     ます。また、このファイルを、コア・ダンプとともにデータを解析する
     ために使います。

`-se FILE'
     FILEで指定されるファイルからシンボル・テーブルを読み込み、かつ、
     このファイルを実行ファイルとして使います。

`-core FILE'
`-c FILE'
     FILEで指定されるファイルを解析すべきコア・ダンプとして使います。

`-c NUMBER'
     NUMBERで指定されるプロセスIDを持つプロセスに接続します。これは、
     `attach'コマンドを実行するのと同等です（ただし、NUMBERで指定され
     る名前のコア・ダンプ形式のファイルが存在する場合は、そのファイル
     をコア・ダンプとして読み込みます）。

`-command FILE'
`-x FILE'
     FILEで指定されるファイル内に記述されたGDBコマンドを実行します。
     *Note Command files: Command Files。

`-directory DIRECTORY'
`-d DIRECTORY'
     ソース・ファイルを検索するパスにDIRECTORYで指定されるディレクトリ
     を追加します。

`-m'
`-mapped'
     *注意: このオプションは、
     すべてのシステムでサポートされているわけではない、
     オペレーティング・システムのある機能に依存しています。*
     システム上で、
     `mmap'システム・コールによるファイルのメモリへのマッピングが使用可能である場合、
     このオプションを使うことで、
     プログラムのシンボル情報を再利用可能なファイルとしてカレント・ディレクトリに書き出させることができます。
     仮にデバッグ中のプログラム名が`/tmp/fred'であるとすると、
     マップされたシンボル・ファイルは`./fred.syms'となります。
     この後のGDBデバッグ・セッションは、
     このファイルの存在を検出し、
     そこから迅速にシンボル情報をマップします。
     この場合、
     実行プログラムからシンボル情報を読み込むことはありません。

     `.syms'ファイルは、GDBが実行されるホスト・マシンに固有のものです。
     このファイルは、内部のGDBシンボル・テーブルのイメージをそのまま保
     存したものです。これを、複数のホスト・プラットフォーム上において、
     共有することはできません。

`-r'
`-readnow'
     シンボル・ファイル内のシンボル・テーブル全体をただちに読み込みま
     す。デフォルトの動作では、シンボル情報は必要になるたびに徐々に読
     み込まれます。このオプションを使うと起動までに時間がかかるように
     なりますが、その後の処理は速くなります。

`-mapped'オプションと`-readnow'オプションは、完全なシンボル情報を含む
`.syms'ファイルを作成するために、通常は一緒に指定されます（`.syms'ファ
イルに関する詳細については、*Note Commands to specify files: Files）。
後に使用する目的で`.syms'を作成するだけで、それ以外には何もしないよう
にするためのGDBの単純な起動方法は、以下のとおりです。

     	gdb -batch -nx -mapped -readnow programname



File: gdb-ja.info, Node: Mode Options, Prev: File Options, Up: Invoking GDB

モードの選択
------------

GDBを様々なモードで実行することが可能です。例えば、batchモードやquiet
モードなどがあります。

`-nx'
`-n'
     初期化ファイルに記述されたコマンドを実行しません（通常、初期化ファ
     イルは`.gdbinit'という名前です。ただし、PC上では`gdb.ini'となりま
     す）。通常は、すべてのコマンド・オプションと引数が処理された後に、
     初期化ファイル内のコマンドが実行されます。*Note Command files:
     Command Files。

`-quiet'
`-q'
     紹介メッセージおよびコピーライト・メッセージを表示しません。これ
     らのメッセージは、batchモードでも表示されません。

`-batch'
     batchモードで実行されます。`-x'オプションで指定されたすべてのコマ
     ンド・ファイルを処理した後、終了コード`0'で終了します（`-n'オプショ
     ンによって禁止されていなければ、初期化ファイル内に記述されている
     すべてのコマンドも実行されます）。コマンド・ファイルに記述された
     GDBコマンドの実行中にエラーが発生した場合には、`0'以外の終了コー
     ドで終了します。

     batchモードはGDBをフィルタとして実行する場合に便利です。例えば、
     あるプログラムを別のコンピュータ上にダウンロードして実行する場合
     などです。このような使い方の邪魔にならないよう、

          Program exited normally.

     というメッセージは、batchモードでは表示されません（通常このメッセー
     ジは、GDBの管理下で実行中のプログラムが終了するときに、必ず表示さ
     れます）。

`-cd DIRECTORY'
     カレント・ディレクトリではなく、DIRECTORYで指定されたディレクトリ
     を作業ディレクトリとして、GDBを実行します。

`-fullname'
`-f'
     GNU EmacsがGDBをサブ・プロセスとして起動するとき、このオプション
     を指定します。このオプションは、スタック・フレームを表示するとき
     には、必ず完全なファイル名と行番号を標準的な認識可能な書式で出力
     するようGDBに対して指示するものです（スタック・フレームは、例えば、
     プログラムの実行が停止されたときに必ず表示されます）。認識可能な
     書式とは、先頭に2つの`\032'文字、続いてコロンで区切られたファイル
     名、行番号、桁位置、最後に改行、というものです。Emacs-GDBインター
     フェイス・プログラムは、フレームに対応するソース・コードを表示さ
     せる命令として、2つの`\032'文字を使用します。

`-b BPS'
     GDBによってリモート・デバッグ用に使用されるシリアル・インターフェ
     イスの回線速度（ボーレートあるいはBPS）を設定します。

`-tty DEVICE'
     プログラムの標準入力および標準出力としてDEVICEを使用して実行しま
     す。




File: gdb-ja.info, Node: Quitting GDB, Next: Shell Commands, Prev: Invoking GDB, Up: Invocation

GDBの終了
=========

`quit'
     GDBを終了するためには、`quit'コマンド（省略形は`q'）を使用するか、
     あるいは、ファイルの終端文字（通常は`C-d'）を入力します。
     EXPRESSIONを指定しない場合、GDBは正常終了します。EXPRESSIONが指定
     された場合、EXPRESSIONの評価結果をエラー・コードとして終了します。

割り込み（多くの場合`C-c'）はGDBを終了させません。割り込みは通常、実行
中のGDBコマンドを終了させ、GDBのコマンド・レベルに復帰させます。割り込
み文字は、いつ入力しても安全です。というのは、割り込みの発生が危険であ
る間は、GDBが割り込みの発生を抑止するからです。

アタッチされたプロセスやデバイスを制御するためにGDBを使用していた場合、
`detach'コマンドでそれを解放することができます（*Note Debugging an
already-running process: Attach.）。



File: gdb-ja.info, Node: Shell Commands, Prev: Quitting GDB, Up: Invocation

シェル・コマンド
================

デバッグ・セッションの途中でシェル・コマンドを実行する必要がある場合、
GDBを終了したり一時停止させたりする必要はありません。`shell'コマンドを
使用することができます。

`shell COMMAND STRING'
     COMMAND STRINGで指定されるコマンド文字列を実行するために標準シェ
     ルを起動します。`SHELL'環境変数が設定されていれば、その値が実行さ
     れるべきシェルを決定します。`SHELL'環境変数が設定されていなければ、
     GDBは`/bin/sh'を実行します。

開発環境ではしばしば`make'ユーティリティが必要とされます。GDB内部で
`make'ユーティリティを使用する場合は、`shell'コマンドを使用する必要は
ありません。

`make MAKE-ARGS'
     MAKE-ARGSで指定される引数とともに`make'プログラムを実行します。こ
     れは、`shell make MAKE-ARGS'を実行するのと同じことです。



File: gdb-ja.info, Node: Commands, Next: Running, Prev: Invocation, Up: Top

GDB コマンド
************

GDBコマンドの名前は、最初の2、3文字に省略することができます。ただし、
省略されたコマンド名があいまいであってはなりません。さらに、同じGDBコ
マンドを連続して使用する場合には、RETキーを押すだけで十分です。また、
TABキーを押すことで、途中まで入力されたコマンド名を補完させることがで
きます（複数の補完候補がある場合には、その一覧を表示します）。

* Menu:

* Command Syntax::              GDBに対するコマンドの指定
* Completion::                  コマンド名の補完
* Help::                        ヘルプの表示



File: gdb-ja.info, Node: Command Syntax, Next: Completion, Prev: Commands, Up: Commands

コマンドの構文
==============

GDBコマンドは1行で入力されます。1行の長さには上限がありません。行は、
コマンド名で始まり、コマンド名によって意味が決まる引数がそれに続きます。
例えば、`step'コマンドは`step'を実行する回数を引数に取ります。例えば、
`step 5'のようになります。`step'コマンドは引数なしでも実行可能です。コ
マンドによっては、全く引数を受け付けないものもあります。

GDBコマンド名は省略可能です。ただし、省略された名前があいまいなもので
はあってはなりません。省略形は、それぞれのコマンドのドキュメント内に記
載されています。場合によっては、あいまいな省略形も許されることがありま
す。例えば、`s'は、文字`s'で始まるコマンドがほかにも存在するにもかかわ
らず、`step'コマンドの省略形として特別に定義されています。ある省略形が
使用可能か否かは、それを`help'コマンドへの引数として使用することで判定
可能です。

GDBへの入力として空行を与える（RETキーだけを押す）ことは、1つ前に実行
したコマンドを繰り返すということを意味します。ただし、いくつかのコマン
ド（例えば、`run'コマンド）は、この方法で実行を繰り返すことはできませ
ん。意図に反して再実行してしまうと問題を引き起こす可能性があるため、繰
り返し実行してほしくないようなコマンドの場合です。

`list'コマンドと`x'コマンドは、RETキーにより繰り返し実行すると、新たに
引数が生成されて実行されるので、前回実行されたときと全く同様の状態で繰
り返し実行されるわけではありません。こうすることで、ソース・コードの内
容やメモリの内容を容易に調べることができます。

GDBは、別の用途でもRETキーを使用します。`more'ユーティリティと同様の方
法で、長い出力を分割して表示する場合です（*Note Screen size: Screen
Size.）。このような場合、RETキーを余分に押してしまうことは往々にしてあ
りえるので、GDBはこのような表示方法を使用しているコマンドについては、
RETキーによる繰り返し実行を行いません。

テキストの中に`#'記号があると、そこから行末まではコメントになります。
コメントの部分は実行されません。これは、特にコマンド・ファイルの中で便
利です（*Note Command files: Command Files.）。



File: gdb-ja.info, Node: Completion, Next: Help, Prev: Command Syntax, Up: Commands

コマンド名の補完
================

途中まで入力されたコマンド名は、それがあいまいでなければ、GDBが残りの
部分を補完してくれます。また、いつでも、コマンド名の補完候補の一覧を表
示してくれます。この機能は、GDBコマンド名、GDBサブ・コマンド名、ユーザ・
プログラムのシンボル名に対して有効です。

GDBに単語の残りの部分を補完させたい場合には、TABキーを押します。補完候
補が1つしか存在しない場合、GDBは残りの部分を補完し、ユーザがコマンドを
（RETキーを押すことで）完結させるのを待ちます。例えば、ユーザが以下の
ように入力したとしましょう。

     (gdb) info bre TAB

GDBは`breakpoints'という単語の残りの部分を補完します。なぜなら、`info'
コマンドのサブ・コマンドのうち、`bre'で始まるのはこの単語だけだからで
す。

     (gdb) info breakpoints

この時点で、ユーザはRETキーを押して`info breakpoints'コマンドを実行す
るか、あるいは`breakpoints'コマンドが実行したいコマンドではなかった場
合には、バックスペース・キーを押してこれを消去してから、他の文字を入力
することができます（最初から`info breakpoints'コマンドを実行するつもり
であれば、コマンド名補完機能ではなくコマンド名の省略形を利用して、
`info bre'と入力した後、ただちにRETキーを押してもいいでしょう）。

TABキーが押されたときに、2つ以上の補完候補が存在する場合、GDBはベル音
を鳴らします。さらにいくつか文字を入力してから補完を再度試みることも可
能ですし、単に続けてTABキーを押すことも可能です。後者の場合、GDBは補完
候補の全一覧を表示します。例えば、`make_'で始まる名前を持つサブルーチ
ンにブレイクポイントを設定したいような場合に、`b make_'まで入力してTAB
キーを入力したところベル音が鳴ったとしましょう。ここで続けてTABキーを
入力すると、プログラム内の`make_'で始まるすべてのサブルーチン名が表示
されます。例えば、以下のように入力したとします。

     (gdb) b make_ TAB

ここでGDBはベル音を鳴らします。もう一度TABキーを入力すると、以下のよう
に表示されます。

     make_a_section_from_file     make_environ               
     make_abs_section             make_function_type         
     make_blockvector             make_pointer_type          
     make_cleanup                 make_reference_type        
     make_command                 make_symbol_completion_list
     (gdb) b make_

補完候補を表示した後、ユーザが続きを入力できるよう、GDBは途中まで入力
された文字列（ここでは`b make_'）を再表示します。

最初から補完候補の一覧を表示したいのであれば、TABキーを2回押す代わりに
`M-?'を入力することもできます。ここで、`M-?'というのは`META ?'を意味し
ます。これを入力するには、キーボード上にMETAシフト・キーとして指定され
たキーがあれば、それを押しながら`?'を入力します。METAシフト・キーがな
い場合には、ESCキーを押した後、`?'を入力します。

ときには、入力したい文字列が、論理的には『単語』であっても、GDBが通常
は単語の一部に含めない括弧のような文字を含む場合があります。このような
場合に単語の補完機能を使用するためには、GDBコマンド内において、そのよ
うな単語を`'' （単一引用符）で囲みます。

このようなことが必要になる可能性が最も高いのは、C++関数名を入力すると
きでしょう。これは、C++が関数のオーバーローディング（引数の型の違いに
よって識別される、同一の名前を持つ関数の複数の定義）をサポートしている
からです。例えば、関数`name'にブレイクポイントを設定する場合、それが
`int'型のパラメータを取る`name(int)'なのか、それとも`float'型のパラメー
タを取る`name(float)'なのかをはっきりさせる必要があります。このような
場合に単語の補完機能を使用するには、単一引用符`''を関数名の前に入力し
ます。こうすることによって、TABキーまたは`M-?'キーが押されて単語補完が
要求されたときに、補完候補の決定には通常よりも多くのことを検討する必要
のあることがGDBに通知されます。

     (gdb) b 'bubble( M-?
     bubble(double,double)    bubble(int,int)
     (gdb) b 'bubble(

場合によっては、名前の補完をするには引用符を使用する必要があるというこ
とを、GDBが自分で認識できることもあります。このような場合、ユーザが引
用符を入力していなくても、GDBが（可能な限り補完を行いつつ）引用符を挿
入してくれます。

     (gdb) b bub TAB
GDBは入力された1行を以下のように変更し、
     ベル音を鳴らします。
     (gdb) b 'bubble(

一般的には、オーバーロードされたシンボルに対して補完が要求された際に引
数リストがまだ入力されていないと、GDBは、引用符が必要であると判断しま
す（そして実際に挿入します）。

オーバーロードされた関数に関する情報については、*Note C++ expressions:
Cplus expressions.。コマンド`set overload-resolution off'を使用すれば、
オーバーロードの解決を無効化することができます。*Note GDB features for
C++: Debugging C plus plus.。




File: gdb-ja.info, Node: Help, Prev: Completion, Up: Commands

ヘルプの表示
============

`help'コマンドを使うことで、GDBコマンドに関するヘルプ情報をGDB自身に表
示させることができます。

`help'
`h'
     `help'コマンド（省略形は`h'）を引数なしで実行することで、コマンド
     のクラス名の簡単な一覧を表示させることができます。

          (gdb) help
          List of classes of commands:

          running -- Running the program
          stack -- Examining the stack
          data -- Examining data
          breakpoints -- Making program stop at certain points
          files -- Specifying and examining files
          status -- Status inquiries
          support -- Support facilities
          user-defined -- User-defined commands
          aliases -- Aliases of other commands
          obscure -- Obscure features

          Type "help" followed by a class name for a list of 
          commands in that class.
          Type "help" followed by command name for full 
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

`help CLASS'
     一般的なクラス名を引数に指定することで、そのクラスに属するコマン
     ドの一覧を表示させることができます。`status'クラスを指定した場合
     の表示例を以下に示します。

          (gdb) help status
          Status inquiries.

          List of commands:

          show -- Generic command for showing things set
           with "set"
          info -- Generic command for printing status

          Type "help" followed by command name for full 
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

`help COMMAND'
     `help'の引数にコマンド名を指定することで、そのコマンドの使用法に
     関する簡単な説明が表示されます。

`complete ARGS'
     `complete ARGS'コマンドにコマンド名の先頭の部分を指定すると、コマ
     ンド名の補完候補の一覧を表示します。ARGSには、補完されるべきコマ
     ンド名の先頭の文字列を指定します。例えば、

          complete i

     は、以下のような結果を表示します。

          info
          inspect
          ignore

     これは、GNU Emacsでの使用を想定したものです。

`help'コマンドに加えて、GDBの`info'コマンドおよび`show'コマンドを使用
することで、ユーザ・プログラムの状態やGDBの状態を問い合わせることがで
きます。どちらのコマンドも、多くの観点からの問い合わせをサポートしてい
ます。このマニュアルでは、それぞれを適切と思われる箇所で紹介しています。
索引の`info'や`show'の部分に、それぞれのサブ・コマンドの紹介されている
ページが示されています。*Note Index::。

`info'
     このコマンド
     （省略形は`i'）
     は、
     ユーザ・プログラムの状態を表わす情報を表示するものです。
     例えば、
     `info args'によってユーザ・プログラムに与えられた引数を、
     `info registers'によって現在使用中のレジスタの一覧を、
     `info breakpoints'によってユーザが設定したブレイクポイントの一覧を、
     それぞれ表示することができます。
     `help info'によって、
     `info'コマンドのサブ・コマンドの完全な一覧が表示されます。

`set'
     `set'コマンドによって、ある式の評価結果を環境変数に割り当てること
     ができます。例えば、GDBのプロンプト文字列を$記号に変更するには、
     `set prompt $'を実行します。

`show'
     `info'コマンドとは異なり、`show'コマンドはGDB自身の状態を表わす情
     報を表示するものです。`show'コマンドで表示可能な状態はすべて、対
     応する`set'コマンドで変更可能です。例えば、数値の表示に使用する基
     数は`set radix'コマンドで制御できます。現在どの基数が使用されてい
     るかを単に知るためには、`show radix'コマンドを使用します。

     変更可能なすべてのパラメータとそれらの現在の値を表示するためには、
     `show'コマンドを引数なしで実行します。また、`info set'コマンドを
     使用することもできます。どちらのコマンドも、同じ情報を出力します。

以下に、対応する`set'コマンドを持たないという意味で例外的である、3つの
`show'サブ・コマンドを示します。

`show version'
     実行中のGDBのバージョンを表示します。GDBに関する障害レポートには、
     この情報を含める必要があります。もしも異なるバージョンのGDBを複数
     使用しているのであれば、ときには現在実行しているGDBのバージョンを
     はっきりさせたいこともあるでしょう。GDBのバージョンが上がるにつれ、
     新しいコマンドが導入され、古いコマンドはサポートされなくなるかも
     しれません。バージョン番号は、GDBの起動の際にも表示されます。

`show copying'
     GDBのコピー作成許可に関する情報が表示されます。

`show warranty'
     GNUの『無保証（NO WARRANTY）』声明文が表示されます。



File: gdb-ja.info, Node: Running, Next: Stopping, Prev: Commands, Up: Top

GDB配下でのプログラムの実行
***************************

プログラムをGDB配下で実行するには、コンパイル時にデバッグ情報を生成す
る必要があります。ユーザが選択した環境で、必要に応じて引数を指定して、
GDBを起動することができます。プログラムの入力元と出力先をリダイレクト
すること、既に実行中のプロセスをデバッグすること、子プロセスを終了させ
ることもできます。

* Menu:

* Compilation::                 デバッグのためのコンパイル
* Starting::                    ユーザ・プログラムの起動
* Arguments::                   ユーザ・プログラムの引数
* Environment::                 ユーザ・プログラムの環境

* Working Directory::           ユーザ・プログラムの作業ディレクトリ
* Input/Output::                ユーザ・プログラムの入出力
* Attach::                      既に実行中のプロセスのデバッグ
* Kill Process::                子プロセスの終了
* Process Information::         追加のプロセス情報

* Threads::                     マルチスレッド・プログラムのデバッグ
* Processes::                   マルチプロセス・プログラムのデバッグ



File: gdb-ja.info, Node: Compilation, Next: Starting, Prev: Running, Up: Running

デバッグのためのコンパイル
==========================

プログラムを効率的にデバッグするためには、そのプログラムのコンパイル時
にデバッグ情報を生成する必要があります。このデバッグ情報はオブジェクト・
ファイルに格納されます。この情報は、個々の変数や関数の型、ソース・コー
ド内の行番号と実行形式コードのアドレスとの対応などを含みます。

デバッグ情報の生成を要求するには、コンパイラの実行時に`-g'オプションを
指定します。

多くのCコンパイラでは、`-g'オプションと`-O'オプションを同時に指定する
ことができません。このようなコンパイラでは、デバッグ情報付きの最適化さ
れた実行ファイルを生成することができません。

GNUのCコンパイラであるGCCは、`-O'オプションの有無にかかわらず、`-g'オ
プションが指定できます。したがって、最適化されたコードをデバッグするこ
とが可能です。プログラムをコンパイルするときには、*常に*`-g'オプション
を指定することをお勧めします。自分のプログラムは正しいと思うかもしれま
せんが、自分の幸運を信じて疑わないというのは無意味なことです。

`-g -O'オプションを指定してコンパイルされたプログラムをデバッグすると
きには、オプティマイザがコードを再調整していることを忘れないでください。
デバッガは、実際に存在するコードの情報を表示します。実行されるパスがソー
ス・ファイルの記述と一致していなくても、あまり驚かないでください。これ
は極端な例ですが、定義されているが実際には使われていない変数を、GDBは
認識しません。なぜなら、コンパイラの最適化処理により、そのような変数は
削除されるからです。

命令スケジューリング機能を持つマシンなどでは、`-g'を指定してコンパイル
されたプログラムでは正しく動作することが、`-g -O'を指定してコンパイル
されたプログラムでは正しく動作しないということがあります。`-g -O'を指
定してコンパイルされたプログラムのデバッグで何かおかしな点があれば、
`-g'だけを指定してコンパイルしてみてください。これで問題が解決するよう
であれば、（再現環境と一緒に）障害として私たちに報告してください。

古いバージョンのGNU Cコンパイラは、
デバッグ情報の生成のためのオプションの1つとして
`-gg'をサポートしていました。
現在のGDBはこのオプションをサポートしていません。
お手元のGNU Cコンパイラにこのオプションがあるようであれば、
それは使わないでください。



File: gdb-ja.info, Node: Starting, Next: Arguments, Prev: Compilation, Up: Running

ユーザ・プログラムの起動
========================

`run'
`r'
     GDB配下でユーザ・プログラムの実行を開始するには`run'コマンドを使
     用してください。（VxWorks以外の環境では）最初にプログラム名を指定
     する必要があります。これには、GDBへの引数を使用する方法（*Note
     Getting In and Out of GDB: Invocation.）と、`file'コマンドまたは
     `exec-file'コマンドを使用する方法（*Note Commands to specify
     files: Files.）とがあります。


プロセスをサポートする環境でプログラムを実行している場合、`run'コマン
ドは下位プロセスを生成し、そのプロセスにプログラムを実行させます（プロ
セスをサポートしていない環境では、`run'コマンドはプログラムの先頭アド
レスにジャンプします）。

プログラムの実行は、上位プロセスから受け取る情報によって影響されます。
GDBはこの情報を指定する手段を提供しています。これは、ユーザ・プログラ
ムが起動される*前*に実行されていなければなりません（ユーザ・プログラム
の実行後にその情報を変更することも可能ですが、その変更結果は、次にプロ
グラムを実行したときに初めて有効になります）。この情報は、4つに分類す
ることができます。

*引数*
     ユーザ・プログラムに与える引数を、`run'コマンドへの引数として指定
     します。ターゲット上でシェルが使用可能であれば、引数を表現するの
     に通常使用する手法（例えば、ワイルドカード拡張や変数による代替な
     ど）が利用できるよう、シェルを経由して引数を渡します。UNIXシステ
     ムでは、`SHELL'環境変数によって、使用されるシェルを選択することが
     できます。*Note Your program's arguments: Arguments。

*環境*
     ユーザ・プログラムは通常、GDBの環境を継承します。GDBの`set
     environment'コマンドと`unset environment'コマンドを使用して、ユー
     ザ・プログラムの実行に影響する環境の一部を変更することができます。
     *Note Your program's environment: Environment。

*作業ディレクトリ*
     ユーザ・プログラムはGDBの作業ディレクトリを継承します。GDBの作業
     ディレクトリは、GDBの`cd'コマンドで設定可能です。*Note Your
     program's working directory: Working Directory。

*標準入力、標準出力*
     ユーザ・プログラムは通常、GDBが標準入力、標準出力として使用してい
     るのと同一のデバイスを、標準入力、標準出力として使用します。`run'
     コマンドのコマンド・ライン上で、標準入力、標準出力をリダイレクト
     することも可能です。また、`tty'コマンドによって別のデバイスを割り
     当てることも可能です。*Note Your program's input and output:
     Input/Output。

     *注意:* 入出力のリダイレクトは機能しますが、デバッグ中のプログラ
     ムの出力を、パイプを使用して他のプログラムに渡すことはできません。
     このようなことをすると、GDBは誤って、別のプログラムのデバッグを開
     始してしまうでしょう。

`run'コマンドを実行すると、ユーザ・プログラムはすぐに実行を始めます。
プログラムを停止させる方法については、*Note Stopping and continuing:
Stopping。プログラムが停止すると、`print'コマンドまたは`call'コマンド
を使用して、プログラム内の関数を呼び出すことができます。*Note
Examining Data: Data。

GDBが最後にシンボル情報を読み込んだ後に、シンボル・ファイルの修正タイ
ムスタンプが変更されている場合、GDBはシンボル・テーブルを破棄し再読み
込みを行います。この場合、GDBは、その時点におけるブレイクポイントの設
定を保持しようと試みます。



File: gdb-ja.info, Node: Arguments, Next: Environment, Prev: Starting, Up: Running

ユーザ・プログラムの引数
========================

ユーザ・プログラムへの引数は、`run'コマンドへの引数によって指定可能で
す。それはまずシェルに渡され、ワイルドカードの展開やI/Oのリダイレクト
の後、プログラムに渡されます。`SHELL'環境変数によって、GDBの使用するシェ
ルが指定されます。`SHELL'環境変数が定義されていないと、GDBは`/bin/sh'
を使用します。

引数を指定せずに`run'コマンドを実行すると、前回`run'コマンドを実行した
ときの引数、または、`set args'コマンドでセットされた引数が使用されます。

`set args'
     ユーザ・プログラムが次に実行されるときに使用される引数を指定しま
     す。`set args'が引数なしで実行された場合、`run'コマンドは、ユーザ・
     プログラムを引数なしで実行します。一度プログラムに引数を指定して
     実行すると、次にプログラムを引数なしで実行する唯一の方法は、`run'
     コマンドを実行する前に`set args'コマンドを実行することです。

`show args'
     ユーザ・プログラムが実行されるときに渡される引数を表示します。



File: gdb-ja.info, Node: Environment, Next: Working Directory, Prev: Arguments, Up: Running

ユーザ・プログラムの環境
========================

"環境"とは、環境変数とその値の集合のことです。環境変数は、慣例として、
ユーザ名、ユーザのホーム・ディレクトリ、端末タイプ、実行プログラムのサー
チ・パスなどを記録します。通常、環境変数はシェル上で設定され、ユーザの
実行するすべてのプログラムによって継承されます。デバッグ時には、GDBを
終了・再起動せずに環境を変更して、ユーザ・プログラムを実行できると便利
でしょう。

`path DIRECTORY'
     DIRECTORYで指定されるディレクトリを環境変数`PATH' （実行ファイル
     のサーチ・パス）の先頭に追加します。これは、GDBとユーザ・プログラ
     ムの両方に対して有効です。`:' （コロン）またはスペースで区切られ
     た複数のディレクトリを指定することもできます。環境変数`PATH'の中
     に既にDIRECTORYが含まれている場合には、DIRECTORYは環境変数`PATH'
     の先頭に移動されます。これにより、DIRECTORYはより早く検索されるこ
     とになります。

     文字列`$cwd'によって、GDBがパスを検索する時点における作業ディレク
     トリを参照することができます。`.'  （ピリオド）を使用すると、
     `path'コマンドを実行したディレクトリを参照することになります。
     DIRECTORY引数に`.'  （ピリオド）が含まれていると、GDBはまずそれを
     （カレント・ディレクトリに）置き換えてから、サーチ・パスに追加し
     ます。

`show paths'
     実行ファイルを検索するパスの一覧（環境変数`PATH'の値）を表示しま
     す。

`show environment [VARNAME]'
     ユーザ・プログラム起動時に渡される環境変数VARNAMEの値を表示します。
     VARNAMEが指定されない場合は、プログラムに渡されるすべての環境変数
     の名前と値が表示されます。`environment'は`env'に省略可能です。

`set environment VARNAME [=] VALUE'
     環境変数VARNAMEの値としてVALUEをセットします。値の変更はユーザ・
     プログラムに対してのみ有効で、GDBに対しては無効です。VALUEには任
     意の文字列が指定可能です。環境変数の値は単なる文字列であり、その
     解釈はユーザ・プログラムに委ねられています。VALUEは必須パラメータ
     ではありません。省略された場合には、変数には空文字列がセットされ
     ます。

     例えば、以下のコマンドは、後にUNIXプログラムが実行されるときのユー
     ザ名として`foo'をセットします（`='の前後のスペースは見やすくする
     ためのもので、実際には必要ありません）。

          set env USER = foo

`unset environment VARNAME'
     ユーザ・プログラムに渡される環境から、環境変数VARNAMEを削除します。
     これは、`set env VARNAME ='とは異なります。`unset environment'は、
     環境変数の値として空文字列をセットするのではなく、環境変数そのも
     のを環境から削除します。

*注意:* GDBは、環境変数`SHELL'により指定されるシェル（環境変数`SHELL'
が設定されていない場合には`/bin/sh'）を使用してプログラムを実行します。
`SHELL'環境変数の指定するシェルが初期化ファイルを実行するものである場
合（例えば、C-shellの`.cshrc'、BASHの`.bashrc'）、初期化ファイルの中で
設定された環境変数はユーザ・プログラムに影響を与えます。環境変数の設定
は、`.login'や`.profile'のように、ユーザがシステム内に入るときに実行さ
れるファイルに移したほうがよいでしょう。



File: gdb-ja.info, Node: Working Directory, Next: Input/Output, Prev: Environment, Up: Running

ユーザ・プログラムの作業ディレクトリ
====================================

`run'コマンドで実行されるユーザ・プログラムは、実行時のGDBの作業ディレ
クトリを継承します。GDBの作業ディレクトリは、もともと親プロセス（通常
はシェル）から継承したものですが、`cd'コマンドによって、GDBの中から新
しい作業ディレクトリを指定することができます。

GDBの作業ディレクトリは、GDBによって操作されるファイルを指定するコマン
ドに対して、デフォルト・ディレクトリとして機能します。*Note Commands
to specify files: Files。

`cd DIRECTORY'
     GDBの作業ディレクトリをDIRECTORYにします。

`pwd'
     GDBの作業ディレクトリを表示します。



File: gdb-ja.info, Node: Input/Output, Next: Attach, Prev: Working Directory, Up: Running

ユーザ・プログラムの入出力
==========================

GDB配下で実行されるプログラムは、デフォルトでは、GDBと同一の端末に対し
て入出力を行います。GDBは、ユーザとのやりとりのために、端末モードをGDB
用に変更します。このとき、ユーザ・プログラムが使用していた端末モードは
記録され、ユーザ・プログラムを継続実行すると、そのモードに戻ります。

`info terminal'
     ユーザ・プログラムが使用している端末モードに関してGDBが記録してい
     る情報を表示します。

`run'コマンドにおいてシェルのリダイレクト機能を使用することによって、
ユーザ・プログラムの入出力をリダイレクトすることが可能です。例えば、

     run > outfile

はユーザ・プログラムの実行を開始し、その出力をファイル`outfile'に書き
込みます。

ユーザ・プログラムの入出力先を指定する別の方法に、`tty'コマンドがあり
ます。このコマンドはファイル名を引数として取り、そのファイルを後に実行
される`run'コマンドのデフォルトの入出力先とします。このコマンドはまた、
後の`run'コマンドにより生成される子プロセスを制御する端末を変更します。
例えば、

     tty /dev/ttyb

は、それ以降に実行される`run'コマンドによって起動されるプロセスのデフォ
ルトの入出力先および制御端末を`/dev/ttyb'端末とします。

`run'コマンド実行時に明示的にリダイレクト先を指定することで、`tty'コマ
ンドで指定された入出力装置を変更することができますが、制御端末の設定は
変更できません。

`tty'コマンドを使用した場合も、`run'コマンドで入力をリダイレクトした場
合も、ユーザ・プログラムの入力元だけが変更されます。これらのコマンドを
実行しても、GDBの入力元は、ユーザの使用している端末のままです。



File: gdb-ja.info, Node: Attach, Next: Kill Process, Prev: Input/Output, Up: Running

既に実行中のプロセスのデバッグ
==============================

`attach PROCESS-ID'
     GDBの外で起動され、既に実行中のプロセスにアタッチします（`info
     files'コマンドで、現在デバッグ対象となっているプログラムの情報が
     表示されます）。このコマンドは、プロセスIDを引数に取ります。UNIX
     プロセスのプロセスIDを知るのに通常使用する方法は、`ps'ユーティリ
     ティ、または、シェル・コマンドの`jobs -l'の実行です。

     `attach'コマンドを実行後RETキーを押しても、コマンドは再実行されま
     せん。

`attach'コマンドを使用するには、プロセスをサポートする環境でユーザ・プ
ログラムを実行する必要があります。例えば、オペレーティング・システムの
存在しないボード・コンピュータのような環境で動作するプログラムに対して、
`attach'コマンドを使うことはできません。さらに、ユーザは、プロセスに対
してシグナルを送信する権利を持っている必要があります。

`attach'コマンドを使用すると、デバッガは、まずカレントな作業ディレクト
リの中で、プロセスにより実行されているプログラムを見つけようとします。
（プログラムが見つからなければ）次に、ソース・ファイルのサーチ・パス
（*Note Specifying source directories: Source Path.）を使用して、プロ
グラムを見つけようとします。`file'コマンドを使用して、プログラムをロー
ドすることも可能です。*Note Commands to Specify Files: Files。

指定されたプロセスをデバッグする準備が整った後に、GDBが最初にすること
は、そのプロセスを停止することです。`run'コマンドを使用してプロセスを
起動した場合は、通常使用可能なすべてのGDBコマンドを使用して、アタッチ
されたプロセスの状態を調べたり変更したりすることができます。ブレイクポ
イントの設定、ステップ実行、継続実行、記憶域の内容の変更が可能です。プ
ロセスの実行を継続したいのであれば、GDBがプロセスにアタッチした後に、
`continue'コマンドを使用することができます。

`detach'
     アタッチされたプロセスのデバッグが終了した場合には、`detach'コマ
     ンドを使用してそのプロセスをGDBの管理から解放することができます。
     プロセスからディタッチしても、そのプロセスは実行を継続します。
     `detach'コマンド実行後は、ディタッチされたプロセスとGDBは互いに完
     全に依存関係がなくなり、`attach'コマンドによる別のプロセスへのア
     タッチや、`run'コマンドによる別のプロセスの起動が可能になります。
     `detach'コマンドを実行後RETキーを押しても、`detach'コマンドは再実
     行されません。

プロセスがアタッチされている状態で、GDBを終了したり`run'コマンドを使用
したりすると、アタッチされたプロセスを終了させてしまいます。デフォルト
の状態では、このようなことを実行しようとすると、GDBが確認を求めてきま
す。この確認処理を行うか否かは、`set confirm'コマンドで設定可能です
（*Note Optional warnings and messages: Messages/Warnings.）。



File: gdb-ja.info, Node: Kill Process, Next: Process Information, Prev: Kill Process, Up: Running

子プロセスの終了
================

`kill'
     GDB配下で実行しているユーザ・プログラムのプロセスを終了させます。

このコマンドは、実行中のプロセスではなく、コア・ダンプをデバッグしたい
ときに便利です。GDBは、ユーザ・プログラムの実行中は、コア・ダンプ・ファ
イルを無視します。

いくつかのオペレーティング・システム上では、GDBの管理下でブレイクポイ
ントを設定されている状態のプログラムを、GDBの外で実行することができま
せん。このような場合、`kill'コマンドを使用することで、デバッガの外での
プログラムの実行が可能になります。

`kill'コマンドは、プログラムを再コンパイル、再リンクしたい場合にも便利
です。というのは、多くのシステムでは、プロセスとして実行中の実行ファイ
ルを更新することはできないからです。次に`run'コマンドを実行したときに、
GDBは、実行ファイルが変更されていることを認識し、シンボル・テーブルを
再度読み込みます（この際、その時点でのブレイクポイントの設定を維持しよ
うと試みます）。



File: gdb-ja.info, Node: Process Information, Next: Threads, Prev: Kill Process, Up: Running

プロセス情報
============

いくつかのオペレーティング・システムは、`/proc'と呼ばれる便利な機能を
提供しています。これは、ファイル・システム関連のサブルーチンを使用して、
実行中プロセスのイメージを調べるのに使用することができます。GDBが、こ
の機能を持つオペレーティング・システム用に構成されていれば、`info
proc'コマンドを使用することで、ユーザ・プログラムを実行しているプロセ
スに関するいくつかの情報を知ることができます。`info proc'は、`procfs'
をサポートするSVR4システム上でのみ機能します。

`info proc'
     プロセスに関して入手可能な情報を要約して出力します。

`info proc mappings'
     プログラムがアクセスすることのできるアドレス範囲を表示します。出
     力情報には、それぞれのアドレス範囲に対してユーザ・プログラムが持
     つ読み込み権、書き込み権、実行権の情報が含まれます。

`info proc times'
     ユーザ・プログラムおよびその子（プロセス）の起動時刻、ユーザ・レ
     ベルのCPU消費時間、システム・レベルのCPU消費時間を表示します。

`info proc id'
     ユーザ・プログラムに関連のあるプロセスのID情報を表示します。ユー
     ザ・プログラムのプロセスID、親（プロセス）のプロセスID、プロセス・
     グループID、セッションIDを出力します。

`info proc status'
     プロセスの状態に関する一般的な情報を出力します。プロセスが停止し
     ている場合は、停止した理由、（シグナルを受信した場合には）受信し
     たシグナルが出力情報に含まれます。

`info proc all'
     プロセスに関する上記の情報をすべて表示します。



File: gdb-ja.info, Node: Threads, Next: Processes, Prev: Threads, Up: Running

マルチスレッド・プログラムのデバッグ
====================================

HP-UXやSolarisのようなオペレーティング・システムにおいては、1つのプロ
グラムが複数の"スレッド"を実行することができます。「スレッド」の正確な
意味は、オペレーティング・システムによって異なります。しかし、一般的に
は、1つのアドレス空間を共有するという点を除けば、プログラム内のマルチ
スレッドは、マルチプロセスと類似しています（アドレス空間の共有とは、複
数のスレッドが同一の変数の値を参照したり変更したりすることが可能である
ということです）。その一方で、個々のスレッドは自分用のレジスタ、実行ス
タック、そしておそらくはプライベート・メモリを持ちます。

GDBは、マルチスレッド・プログラムのデバッグ用に、以下のような便利な機
能を提供しています。

   * 新規スレッド生成の自動的な通知
   * スレッドを切り替えるコマンド`thread THREADNO'
   * 既存のスレッドに関する情報を問い合わせるコマンド`info threads'
   * 1つのコマンドを複数のスレッドに対して実行するコマンド`thread apply [THREADNO] [ALL] ARGS'
   * スレッド固有のブレイクポイント

     *注意:* これらの機能は、スレッドをサポートするオペレーティング・
     システム用に構成されたすべてのGDBで使用可能なわけではありません。
     GDBがスレッドをサポートしていない環境では、これらのコマンドは無効
     です。例えば、スレッドをサポートしていないシステム上でGDBの`info
     threads'コマンドを実行しても何も表示されませんし、`thread'コマン
     ドの実行は常に拒絶されます。

          (gdb) info threads
          (gdb) thread 1
          Thread ID 1 not known.  Use the "info threads" command to
          see the IDs of currently known threads.

GDBのスレッド・デバッグ機能により、ユーザ・プログラムの実行中に、すべ
てのスレッドを観察することができます。ただし、GDBに制御権のある状態で
は、特定の1つのスレッドだけがデバッグの対象となります。このスレッドは、
"カレント・スレッド"と呼ばれます。デバッグ用のコマンドは、カレント・ス
レッドの立場から見たプログラムの情報を表示します。

ユーザ・プログラム内部において新しいスレッドの存在を検出すると、GDBは、
`[New SYSTAG]'という形式で、ターゲット・システム上におけるこのスレッド
のIDを表示します。ここでSYSTAGとはスレッドのIDで、その形式はシステムに
よって異なります。例えば、LynxOS上では、GDBが新しいスレッドを検出する
と、

     [New process 35 thread 27]

のように表示されます。一方、SGIのシステム上では、SYSTAGは単に`process
368'のような形式で、これ以外の情報は含まれません。


GDBは、ユーザ・プログラム内の個々のスレッドに対して、デバッグ用の整数
値のスレッド番号を独自に割り当てます。

`info threads'
     その時点においてユーザ・プログラム中に存在するすべてのスレッドに
     関する要約を表示します。個々のスレッドに関して、以下の情報が（列
     挙された順に）表示されます。

       1. GDBにより割り当てられたスレッド番号

       2. ターゲット・システムのスレッドID（SYSTAG）

       3. スレッドのカレントなスタック・フレームの要約

     GDBにより割り当てられたスレッド番号の左のアスタリスク`*'は、その
     スレッドがカレント・スレッドであることを意味しています。

     以下に例を示します。

     (gdb) info threads
       3 process 35 thread 27  0x34e5 in sigpause ()
       2 process 35 thread 23  0x34e5 in sigpause ()
     * 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
         at threadtest.c:68

`thread THREADNO'
     スレッド番号THREADNOを割り当てられたスレッドをカレント・スレッド
     とします。このコマンドの引数THREADNOは、`info threads'コマンドの
     出力の最初のフィールドに表示される、GDB内部のスレッド番号です。
     GDBは、指定されたスレッドのシステム上のIDとカレントなスタック・フ
     レームの要約を表示します。

          (gdb) thread 2
          [Switching to process 35 thread 23]
          0x34e5 in sigpause ()

     `[New ...]'メッセージと同様、`Switching to'の後ろに表示される情報
     の形式は、そのシステムにおけるスレッドの識別方法に依存します。

`thread apply [THREADNO] [ALL]  ARGS'
     `thread apply'コマンドにより、1つのコマンドを1つ以上のスレッドに
     対して実行することができます。実行対象となるスレッドのスレッド番
     号を、引数THREADNOに指定します。THREADNOは、`info threads'コマン
     ドの出力の最初のフィールドに表示される、GDB内部のスレッド番号です。
     すべてのスレッドに対してコマンドを実行するには、`thread apply
     all' ARGSコマンドを使用してください。

GDBがユーザ・プログラムを停止させるとき、その理由がブレイクポイントで
あれシグナルの受信であれ、ブレイクポイントに到達したスレッド、または、
シグナルを受信したスレッドが自動的に選択されます。GDBは、`[Switching
to SYSTAG]'という形式のメッセージでそのスレッドを示し、コンテキスト切
り替えの発生に注意を促します。

複数スレッドを持つプログラムの停止時や起動時のGDBの動作の詳細について
は、*Note Stopping and starting multi-thread programs: Thread Stops。

また、複数スレッドを持つプログラムの中におけるウォッチポイントについて
は、*Note Setting watchpoints: Set Watchpoints。



File: gdb-ja.info, Node: Processes, Next: Processes, Prev: Threads, Up: Running

マルチプロセス・プログラムのデバッグ
====================================

`fork'関数を使用して新たにプロセスを生成するプログラムのデバッグに関し
ては、GDBは特別な機能を提供していません。プログラムが`fork'を実行する
とき、GDB は引き続き親プロセスのデバッグを継続し、子プロセスは妨げられ
ることなく実行を続けます。子プロセスが実行するコードにブレイクポイント
を設定してあると、子プロセスは`SIGTRAP'シグナルを受信し、（そのシグナ
ルをキャッチする処理がなければ）子プロセスは終了してしまいます。

しかし、子プロセスをデバッグしたい場合には、それほど困難ではない回避策
があります。`fork'の呼び出し後に子プロセスが実行するソース・コードの中
に、`sleep'関数の呼び出しを加えてください。GDBに子プロセスのデバッグを
させる理由がないときに遅延が発生することのないように、特定の環境変数が
設定されているときのみ、あるいは、特定のファイルが存在するときのみ、
`sleep'関数を呼び出すようにするとよいでしょう。子プロセスが`sleep'を呼
び出している間に、`ps'ユーティリティを使用して子プロセスのプロセスIDを
獲得します。次に、GDBに対して（親プロセスもデバッグするのであれば、新
たにGDBを起動して、そのGDBに対して）、子プロセスにアタッチするよう指示
してください（*Note Attach::）。これ以降は、通常の方法でプロセスにアタッ
チした場合と全く同様に、子プロセスのデバッグが可能です。



File: gdb-ja.info, Node: Stopping, Next: Stack, Prev: Running, Up: Top

停止と継続
**********

デバッガを使用する主な目的は、プログラムが終了してしまう前に停止させた
り、問題のあるプログラムを調査して何が悪いのかを調べたりすることにあり
ます。

GDB内部においてプログラムが停止する原因はいくつかあります。例えば、シ
グナルの受信、ブレイクポイントへの到達、`step'コマンドのようなGDBコマ
ンドの実行後の新しい行への到達などです。プログラムが停止すると、変数の
値の調査や設定、新しいブレイクポイントの設定、既存のブレイクポイントの
削除などを行った後に、プログラムの実行を継続することができます。通常、
GDBが表示するメッセージは、ユーザ・プログラムの状態について多くの情報
を提供してくれます。ユーザはいつでも明示的にこれらの情報を要求すること
ができます。

`info program'
     ユーザ・プログラムの状態に関する情報を表示します。表示される情報
     は、そのプログラムの実行状態（実行中か否か）、そのプログラムのプ
     ロセス、プログラムが停止した理由です。

* Menu:

* Breakpoints::                 ブレイクポイント、ウォッチポイント、キャッチポイント
* Continuing and Stepping::     実行の再開
* Signals::                     シグナル

* Thread Stops::                マルチスレッド・プログラムの停止と起動




File: gdb-ja.info, Node: Breakpoints, Next: Continuing and Stepping, Prev: Stopping, Up: Stopping

ブレイクポイント、ウォッチポイント、キャッチポイント
====================================================

"ブレイクポイント"によって、プログラム内のある特定の箇所に到達するたび
に、プログラムを停止することができます。個々のブレイクポイントについて、
そのブレイクポイントにおいてプログラムを停止させるためには満足されなけ
ればならない、より詳細な条件を設定することができます。ブレイクポイント
の設定は、いくつかある`break'コマンドのいずれかによって行います（*Note
Setting breakpoints: Set Breaks.）。行番号、関数名、プログラム内におけ
る正確なアドレスを指定することで、プログラムのどこで停止するかを指定す
ることができます。

HP-UX、SunOS 4.x、SVR4、Alpha OSF/1上では、実行開始前に共用ライブラリ
内にブレイクポイントを設定することもできます。HP-UXシステムでは、ちょっ
とした制約があります。プログラムによって直接呼び出されるのではない共用
ライブラリ・ルーチン（例えば、`pthread_create'の呼び出しにおいて、引数
として指定されるルーチン）にブレイクポイントをセットするためには、その
プログラムの実行が開始されるまで待たなければなりません。

"ウォッチポイント"は、ある式の値が変化したときにユーザ・プログラムを停
止させる、特別なブレイクポイントです。ウォッチポイントは、他のブレイク
ポイントと同じように管理することができますが、設定だけは特別なコマンド
で行います（*Note Setting watchpoints: Set Watchpoints.）。有効化、無
効化、および削除を行うときに使用する各コマンドは、対象がブレイクポイン
トであってもウォッチポイントであっても同一です。

ブレイクポイントでGDBが停止するたびに、常に自動的にユーザ・プログラム
内のある値を表示させるようにすることができます。*Note Automatic
display: Auto Display。

"キャッチポイント"は、C++の例外の発生やライブラリのローディングのよう
なある種のイベントが発生したときに、ユーザ・プログラムを停止させる、ま
た別の特殊なブレイクポイントです。ウォッチポイントと同様、キャッチポイ
ントを設定するために使用する特別なコマンドがあります。（*Note Setting
catchpoints: Set Catchpoints.）。しかし、この点を除けば、キャッチポイ
ントを他のブレイクポイントと同様に管理することができます。（ユーザ・プ
ログラムがシグナルを受信したときに停止するようにするためには、`handle'
コマンドを使用します。*Note Signals: Signals.）。

ユーザが新規に作成した個々のブレイクポイント、ウォッチポイント、キャッ
チポイントに対して、GDBは番号を割り当てます。この番号は1から始まる連続
する整数値です。ブレイクポイントの様々な側面を制御するコマンドの多くに
おいて、変更を加えたいブレイクポイントを指定するのにこの番号を使用しま
す。個々のブレイクポイントを"有効化"、"無効化"することができます。無効
化されたブレイクポイントは、再度有効化されるまで、ユーザ・プログラムの
実行に影響を与えません。

* Menu:

* Set Breaks::                  ブレイクポイントの設定
* Set Watchpoints::             ウォッチポイントの設定
* Set Catchpoints::             キャッチポイントの設定
* Delete Breaks::               ブレイクポイントの削除
* Disabling::                   ブレイクポイントの無効化
* Conditions::                  ブレイクポイントの成立条件
* Break Commands::              ブレイクポイント・コマンド・リスト
* Breakpoint Menus::            ブレイクポイント・メニュー




