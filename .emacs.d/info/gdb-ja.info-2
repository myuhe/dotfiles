Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.





File: gdb-ja.info, Node: Set Breaks, Next: Set Watchpoints, Prev: Breakpoints, Up: Breakpoints

ブレイクポイントの設定
----------------------


ブレイクポイントは、`break'コマンド（省略形は`b'）によって設定されます。
デバッガのコンビニエンス変数`$bpnum'に、最後に設定されたブレイクポイン
トの番号が記録されます。コンビニエンス変数の使用方法については、*Note
Convenience variables: Convenience Vars。

ブレイクポイントの設定箇所を指定する方法はいくつかあります。

`break FUNCTION'
     関数FUNCTIONのエントリにブレイクポイントを設定します。ソース言語
     が（例えばC++のように）シンボルのオーバーロード機能を持つ場合、
     FUNCTIONは、プログラムを停止させる可能性を持つ1つ以上の箇所を指す
     ことがあります。このような状況に関する説明については、*Note
     Breakpoint menus: Breakpoint Menus。

`break +OFFSET'
`break -OFFSET'
     その時点において選択されているフレームにおいて実行が停止している
     箇所から、指定された行数だけ先または手前にブレイクポイントを設定
     します。

`break LINENUM'
     カレントなソース・ファイル内のLINENUMで指定される行番号を持つ行に、
     ブレイクポイントを設定します。ここで「カレントなソース・ファイル」
     とは、最後にソース・コードが表示されたファイルを指します。このブ
     レイクポイントは、その行に対応するコードが実行される直前に、ユー
     ザ・プログラムを停止させます。

`break FILENAME:LINENUM'
     FILENAMEで指定されるソース・ファイルのLINENUMで指定される番号の行
     に、ブレイクポイントを設定します。

`break FILENAME:FUNCTION'
     FILENAMEで指定されるソース・ファイル内のFUNCTIONで指定される関数
     エントリにブレイクポイントを設定します。同じ名前の関数が複数のファ
     イルに存在する場合以外は、ファイル名と関数名を同時に指定する必要
     はありません。

`break *ADDRESS'
     ADDRESSで指定されるアドレスにブレイクポイントを設定します。これは、
     プログラムの中の、デバッグ情報やソース・ファイルが手に入らない部
     分にブレイクポイントを設定するのに使用できます。

`break'
     引数なしで実行されると、`break'コマンドは、選択されたスタック・フ
     レーム内において次に実行される命令にブレイクポイントを設定します
     （*Note Examining the Stack: Stack.）。最下位にあるスタック・フレー
     ム以外のフレームが選択されていると、このブレイクポイントは、制御
     がそのフレームに戻ってきた時点で、ユーザ・プログラムを停止させま
     す。これが持つ効果は、選択されたフレームの下位にあるフレームにお
     いて`finish'コマンドを実行するのと似ています。ただし、1つ異なるの
     は、`finish'コマンドがアクティブなブレイクポイントを残さないとい
     う点です。最下位のスタック・フレームにおいて引数なしで`break'コマ
     ンドを実行した場合、そのときに停止していた箇所に次に到達したとき
     に、GDBはユーザ・プログラムを停止させます。これは、ループの内部で
     は便利でしょう。

     GDBは通常、実行を再開したときに、最低でも1命令が実行されるまでの
     間は、ブレイクポイントの存在を無視します。そうでなければ、ブレイ
     クポイントで停止した後、そのブレイクポイントを無効にしない限り、
     先へ進めないことになってしまいます。この規則は、ユーザ・プログラ
     ムが停止したときに、既にそのブレイクポイントが存在したか否かにか
     かわらず、適用されます。

`break ... if COND'
     CONDで指定される条件式付きでブレイクポイントを設定します。そのブ
     レイクポイントに達すると、必ず条件式CONDが評価されます。評価結果
     がゼロでない場合、すなわち、評価結果が真である場合のみ、ユーザ・
     プログラムを停止します。`...'の部分には、これまでに説明してきた停
     止箇所を指定するための引数のいずれかが入ります（`...'は省略も可能
     です）。ブレイクポイントの条件式の詳細については、*Note Break
     conditions: Conditions。

`tbreak ARGS'
     プログラムを1回だけ停止させるブレイクポイントを設定します。ARGSの
     部分は`break'コマンドと同様であり、ブレイクポイントも同じように設
     定されますが、`tbreak'により設定されたブレイクポイントは、プログ
     ラムが最初にそこで停止した後に自動的に削除されます。*Note
     Disabling breakpoints: Disabling。

`hbreak ARGS'
     ハードウェアの持つ機能を利用したブレイクポイントを設定します。
     ARGSの部分は`break'コマンドと同様であり、ブレイクポイントも同じよ
     うに設定されますが、`hbreak'により設定されるブレイクポイントは、
     ハードウェアによるサポートを必要とします。ターゲット・ハードウェ
     アによっては、このような機能を持たないものもあるでしょう。これの
     主な目的は、EPROM/ROMコードのデバッグであり、ユーザはある命令にブ
     レイクポイントを設定するのに、その命令を変更する必要がありません。
     これは、SPARClite DSUの提供するトラップ発生機能と組み合わせて使用
     することができます。DSUは、デバッグ・レジスタに割り当てられたデー
     タ・アドレスまたは命令アドレスをプログラムがアクセスすると、トラッ
     プを発生させます。ハードウェアの提供するブレイクポイント・レジス
     タは、データ・ブレイクポイントを2つまでしか取れないので、3つ以上
     使用しようとすると、GDBはそれを拒絶します。このような場合、不要に
     なったハードウェア・ブレイクポイントを削除または無効化してから、
     新しいハードウェア・ブレイクポイントを設定してください。*Note
     Break conditions: Conditions。

`thbreak ARGS'
     ハードウェアの機能を利用して、プログラムを1回だけ停止させるブレイ
     クポイントを設定します。ARGSの部分は`hbreak'コマンドと同様であり、
     ブレイクポイントも同じように設定されます。しかし、`tbreak'コマン
     ドの場合と同様、最初にプログラムがそこで停止した後に、このブレイ
     クポイントは自動的に削除されます。また、`hbreak'コマンドの場合と
     同様、このブレイクポイントはハードウェアによるサポートを必要とす
     るものであり、ターゲット・ハードウェアによっては、そのような機能
     がないこともあるでしょう。*Note Disabling breakpoints: Disabling。
     また、*Note Break conditions: Conditions。

`rbreak REGEX'
     REGEXで指定される正規表現にマッチするすべての関数にブレイクポイン
     トを設定します。このコマンドは、正規表現にマッチしたすべての関数
     に無条件ブレイクポイントを設定し、設定されたすべてのブレイクポイ
     ントの一覧を表示します。設定されたブレイクポイントは、`break'コマ
     ンドで設定されたブレイクポイントと同様に扱われます。他のすべての
     ブレイクポイントと同様の方法で、削除、無効化、および条件の設定が
     可能です。

     C++プログラムのデバッグにおいて、あるオーバーロードされたメンバ関
     数が、特別なクラスだけが持つメンバ関数というわけではない場合、そ
     のメンバ関数にブレイクポイントを設定するのに、`rbreak'コマンドは
     便利です。

`info breakpoints [N]'
`info break [N]'
`info watchpoints [N]'
     設定された後、削除されていない、すべてのブレイクポイント、ウォッ
     チポイント、キャッチポイントの一覧を表示します。個々のブレイクポ
     イントについて、以下の情報が表示されます。

     *ブレイクポイント番号*
     *タイプ*
          ブレイクポイント、ウォッチポイント、または、キャッチポイント
     *廃棄*
          ブレイクポイントに次に到達したときに、無効化または削除される
          べくマークされているか否かを示します。
     *有効／無効*
          有効なブレイクポイントを`y'、有効でないブレイクポイントを`n'
          で示します。
     *アドレス*
          ユーザ・プログラム内のブレイクポイントの位置をメモリ・アドレ
          スとして示します。
     *対象*
          ユーザ・プログラムのソース内におけるブレイクポイントの位置を、
          ファイル名および行番号で示します。

     ブレイクポイントが条件付きのものである場合、`info break'コマンド
     は、そのブレイクポイントに関する情報の次の行に、その条件を表示し
     ます。ブレイクポイント・コマンドがあれば、続いてそれが表示されま
     す。

     `info break'コマンドに引数としてブレイクポイント番号Nが指定される
     と、その番号に対応するブレイクポイントだけが表示されます。コンビ
     ニエンス変数`$_'、および、`x'コマンドのデフォルトの参照アドレスに
     は、一覧の中で最後に表示されたブレイクポイントのアドレスが設定さ
     れます（*Note Examining memory: Memory.）。

     `info break'コマンドは、ブレイクポイントに到達した回数を表示しま
     す。これは、`ignore'コマンドと組み合わせると便利です。まず、
     `ignore'コマンドによってブレイクポイントへの到達をかなりの回数無
     視するよう設定します。プログラムを実行し、`info break'コマンドの
     出力結果から何回ブレイクポイントに到達したかを調べます。再度プロ
     グラムを実行し、今度は前回の実行時に到達した回数より1だけ少ない回
     数だけ無視するように設定します。こうすることで、前回の実行時にそ
     のブレイクポイントに最後に到達したときと同じ状態でプログラムを停
     止させることが簡単にできます。

GDBでは、ユーザ・プログラム内の同一箇所に何度でもブレイクポイントを設
定することができます。これは、くだらないことでも、無意味なことでもあり
ません。設定されるブレイクポイントが条件付きのものである場合、これはむ
しろ有用です（*Note Break conditions: Conditions.）。

GDB自身が、特別な目的でユーザ・プログラム内部にブレイクポイントを設定
することがあります。例えば、（Cプログラムにおける）`longjmp'を適切に処
理するためなどです。これらの内部的なブレイクポイントには`-1'から始まる
負の番号が割り当てられます。`info breakpoints'コマンドは、このようなブ
レイクポイントを表示しません。

これらのブレイクポイントは、GDBの保守コマンド`maint info breakpoints'
で表示することができます。

`maint info breakpoints'
     `info breakpoints'コマンドと同様の形式で呼び出され、ユーザが明示
     的に設定したブレイクポイントと、GDBが内部的な目的で使用しているブ
     レイクポイントの両方を表示します。内部的なブレイクポイントは、負
     のブレイクポイント番号で示されます。タイプ欄にブレイクポイントの
     種類が表示されます。

     `breakpoint'
          明示的に設定された普通のブレイクポイント

     `watchpoint'
          明示的に設定された普通のウォッチポイント

     `longjmp'
          `longjmp'が呼び出されたときに正しくステップ処理ができるよう
          に、内部的に設定されたブレイクポイント

     `longjmp resume'
          `longjmp'のターゲットとなる箇所に内部的に設定されたブレイク
          ポイント

     `until'
          GDBの`until'コマンドで一時的に使用される内部的なブレイクポイント

     `finish'
          GDBの`finish'コマンドで一時的に使用される内部的なブレイクポイント





File: gdb-ja.info, Node: Set Watchpoints, Next: Set Catchpoints, Prev: Set Breaks, Up: Breakpoints

ウォッチポイントの設定
----------------------


ウォッチポイントを設定することで、ある式の値が変化したときに、プログラ
ムの実行を停止させることができます。その値の変更が、プログラムのどの部
分で行われるかをあらかじめ知っている必要はありません。

システムによって、ウォッチポイントがソフトウェアによって実装されている
こともあれば、ハードウェアによって実装されていることもあります。GDBは、
ユーザ・プログラムをシングル・ステップ実行して、そのたびに変数の値をテ
ストすることによって、ソフトウェア・ウォッチポイントを実現しています。
これは、通常の実行と比較すると、何百倍も遅くなります。（それでも、プロ
グラムのどの部分が問題を発生させたのか全く手掛りのない誤りを見つけるこ
とができるのであれば、十分価値のあることかもしれません）。

HP-UXやLinuxのようなシステム上のGDBには、ハードウェア・ウォッチポイン
トのサポートも組み込まれています。これを使用すれば、ユーザ・プログラム
の実行が遅くなることはありません。

`watch EXPR'
     EXPRで指定される式に対してウォッチポイントを設定します。プログラ
     ムが式の値を書き換えるときに、GDBはプログラムの実行を停止させます。

`rwatch EXPR'
     EXPRで指定される対象が読み込みアクセスされるときにプログラムを停
     止させるウォッチポイントを設定します。2つめのウォッチポイントとし
     て設定するのであれば、1つめのウォッチポイントも`rwatch'コマンドで
     設定されていなければなりません。

`awatch EXPR'
     EXPRで指定される対象が読み込みアクセス、書き込みアクセスされると
     きにプログラムを停止させるウォッチポイントを設定します。2つめの
     ウォッチポイントとして設定するのであれば、1つめのウォッチポイント
     も`awatch'コマンドで設定されていなければなりません。

`info watchpoints'
     ウォッチポイント、ブレイクポイント、キャッチポイントの一覧を表示
     します。これは、`info break'と同じです。

GDBは、可能であれば、"ハードウェア・ウォッチポイント"を設定します。ハー
ドウェア・ウォッチポイントをセットした場合は高速な実行が可能であり、デ
バッガは、変更を引き起こした命令のところで、値の変更を報告することがで
きます。ハードウェア・ウォッチポイントを設定できない場合、GDBは、ソフ
トウェア・ウォッチポイントを設定します。これは、実行速度も遅く、値の変
更は、その変更が実際に発生した後に、その変更を引き起こした命令のところ
ではなく、1つ後ろの文のところで報告されます

`watch'コマンドを実行すると、ハードウェア・ウォッチポイントの設定が可
能な場合には、GDBは、以下のような報告を行います。

     Hardware watchpoint NUM: EXPR

@noindent

SPARClite DSUは、デバッグ・レジスタに割り当てられたデータ・アドレスや
命令アドレスにプログラムがアクセスすると、トラップを発生させます。デー
タ・アドレスについては、DSUが`watch'コマンドを支援しています。しかし、
ハードウェアの提供するブレイクポイント・レジスタは、データ・ウォッチポ
イントを2つまでしか取れず、その2つは同じ種類のウォッチポイントでなけれ
ばなりません。例えば、2つのウォッチポイントを、両方とも`watch'コマンド
で設定すること、両方とも`rwatch'コマンドで設定すること、*あるいは*、両
方とも`awatch'コマンドで設定することは可能ですが、それぞれを異なるコマ
ンドで設定することはできません。異なる種類のウォッチポイントを同時に設
定しようとしても、コマンドの実行をGDBが拒否します。このような場合、使
用しないウォッチポイント・コマンドを削除または無効化してから、新しい
ウォッチポイント・コマンドを設定してください。

`print'や`call'を使用して関数を対話的に呼び出すと、それまでにセットさ
れていたウォッチポイントはいずれも、GDBが別の種類のブレイクポイントに
到達するか、あるいは、関数の呼び出しが終了するまでの間は、効果を持たな
くなります。

     *注意:* マルチスレッド・プログラムでは、ウォッチポイントの有用性
     は限定されます。現在のウォッチポイントの実装では、GDBは、*単一ス
     レッドの中* でしか式の値を監視することができません。カレント・ス
     レッドの処理の結果としてのみ、その式の値が変更されること（かつ、
     他のスレッドがカレント・スレッドにはならないこと）が確実であれば、
     通常どおり、ウォッチポイントを使用することができます。しかし、カ
     レント・スレッド以外のスレッドが式の値を変更することがあると、GDB
     は、その変更に気付かないかもしれません。



File: gdb-ja.info, Node: Set Catchpoints, Next: Delete Breaks, Prev: Set Watchpoints, Up: Breakpoints

キャッチポイントの設定
----------------------

"キャッチポイント"を使用することによって、C++例外や共用ライブラリのロー
ディングのような、ある種のプログラム・イベントが発生したときに、デバッ
ガを停止させることができます。キャッチポイントを設定するには、`catch'
コマンドを使用します。

`catch EVENT'
     EVENTで指定されるイベントが発生したときに停止します。EVENTは、以
     下のいずれかです。
     `throw'
          C++例外の発生。

     `catch'
          C++例外のキャッチ。

     `exec'
          `exec'の呼び出し。現在これは、HP-UXにおいてのみ利用可能です。

     `fork'
          `fork'の呼び出し。現在これは、HP-UXにおいてのみ利用可能です。

     `vfork'
          `vfork'の呼び出し。現在これは、HP-UXにおいてのみ利用可能です。

     `load'
     `load LIBNAME'
          任意の共用ライブラリの動的なローディング、あるいは、LIBNAME
          で指定されるライブラリのローディング。現在これは、HP-UXにお
          いてのみ利用可能です。

     `unload'
     `unload LIBNAME'
          動的にロードされた任意の共用ライブラリのアンローディング、あ
          るいは、LIBNAMEで指定されるライブラリのアンローディング。現
          在これは、HP-UXにおいてのみ利用可能です。

`tcatch EVENT'
     1回だけ停止させるキャッチポイントを設定します。最初にイベントが捕
     捉された後に、キャッチポイントは自動的に削除されます。

カレントなキャッチポイントの一覧を表示するには、`info break'コマンドを
使用します。

現在、GDBにおけるC++の例外処理（`catch throw'と`catch catch'）にはいく
つかの制限があります。

   * 関数を対話的に呼び出すと、GDBは通常、その関数が実行を終了したとき
     に、ユーザに制御を戻します。しかし、その関数呼び出しが例外を発生
     させると、ユーザへ制御を戻すメカニズムが実行されないことがありま
     す。この場合、ユーザ・プログラムは、アボートするか、あるいは、ブ
     レイクポイントへの到達、GDBが監視しているシグナルの受信、そのプロ
     グラム自体の終了などのイベントが発生するまで、継続実行されること
     になります。これは、例外に対するキャッチポイントを設定してある場
     合にもあてはまります。対話的な関数呼び出しの間は、例外に対するキャッ
     チポイントは無効化されています。

   * 対話的に例外を発生させることはできません。

   * 対話的に例外ハンドラを組み込むことはできません。

`catch'コマンドが、例外処理をデバッグする手段としては最適なものではな
いような場合もあります。どこで例外が発生したのかを正確に知りたい場合、
例外ハンドラが呼び出される*前*にプログラムを停止させた方がよいでしょう。
なぜなら、スタック・ポインタの調整が行われる前のスタックの状態を見るこ
とができるからです。例外ハンドラの内部にブレイクポイントを設定してしま
うと、どこで例外が発生したのかを調べるのは簡単ではないでしょう。

例外ハンドラが呼び出される直前で停止させるには、実装に関する知識が若干
必要になります。GNU C++の場合、以下のようなANSI Cインターフェイスを持
つ`__raise_exception'というライブラリ関数を呼び出すことで例外を発生さ
せます。

         /* ADDRは例外識別子が格納される領域
            IDは例外識別子 */
         void __raise_exception (void **ADDR, void *ID);

スタック・ポインタの調整が行われる前に、すべての例外をデバッガにキャッ
チさせるには、`__raise_exception'にブレイクポイントを設定します（*Note
Breakpoints; watchpoints; and exceptions: Breakpoints.）。

IDの値に依存する条件を付けたブレイクポイント（*Note Conditions: (Break
conditions)Conditions.）を使用することで、特定の例外が発生したときにだ
けユーザ・プログラムを停止させることができます。複数の条件付きブレイク
ポイントを設定することで、複数の例外の中のどれかが発生したときにユーザ・
プログラムを停止させることもできます。




File: gdb-ja.info, Node: Delete Breaks, Next: Disabling, Prev: Set Catchpoints, Up: Breakpoints

ブレイクポイントの削除
----------------------

ブレイクポイント、ウォッチポイント、キャッチポイントがプログラムを1回
停止させた後、同じところで再びプログラムを停止させたくない場合、それら
を取り除くことがしばしば必要になります。これが、ブレイクポイントの"削
除"と呼ばれるものです。削除されたブレイクポイントはもはや存在しなくな
り、それが存在したという記録も残りません。

`clear'コマンドを使用する場合、ブレイクポイントを、それがプログラム内
部のどこに存在するかを指定することによって削除します。`delete'コマンド
の場合は、ブレイクポイント番号を指定することで、個々のブレイクポイント、
ウォッチポイント、キャッチポイントを削除することができます。

ブレイクポイントで停止した後、先へ進むために、そのブレイクポイントを削
除する必要はありません。ユーザが実行アドレスを変更することなく継続実行
する場合、最初に実行される命令に設定されているブレイクポイントを、GDB
は自動的に無視します。

`clear'
     選択されているスタック・フレーム内において次に実行される命令に設
     定されているブレイクポイントを削除します（*Note Selecting a
     frame: Selection.）。最下位にあるフレームが選択されている場合、ユー
     ザ・プログラムが停止した箇所に設定されているブレイクポイントを削
     除するのに便利な方法です。

`clear FUNCTION'
`clear FILENAME:FUNCTION'
     FUNCTIONで指定される関数のエントリに設定されているブレイクポイン
     トを削除します。

`clear LINENUM'
`clear FILENAME:LINENUM'
     指定された行、または、その行内に記述されたコードに設定されたブレ
     イクポイントを削除します。

`delete [breakpoints] [BNUMS...]'
     引数で指定された番号を持つブレイクポイント、ウォッチポイント、キャッ
     チポイントを削除します。引数が指定されない場合、すべてのブレイク
     ポイントを削除します（`set confirm off'コマンドが事前に実行されて
     いない場合、GDBは、削除してもよいかどうか確認を求めてきます）。こ
     のコマンドの省略形は`d'です。



File: gdb-ja.info, Node: Disabling, Next: Conditions, Prev: Delete Breaks, Up: Breakpoints

ブレイクポイントの無効化
------------------------

ブレイクポイント、ウォッチポイント、キャッチポイントを削除するのではな
く、"無効化"したい場合もあるでしょう。無効化によって、ブレイクポイント
は、それがあたかも削除されたかのように機能しなくなりますが、後に再度"
有効化"することができるよう、そのブレイクポイントに関する情報は記憶さ
れます。

ブレイクポイント、ウォッチポイント、キャッチポイントは、`enable'コマン
ドと`disable'コマンドによって有効化、無効化されます。これらのコマンド
には、引数として1つ以上のブレイクポイント番号を指定することも可能です。
指定すべき番号が分からない場合は、`info break'コマンド、または、`info
watch'コマンドによってブレイクポイント、ウォッチポイント、キャッチポイ
ントの一覧を表示させてください。

ブレイクポイント、ウォッチポイント、キャッチポイントは、有効／無効とい
う観点から見て、4つの異なる状態を持つことができます。

   * 有効。ブレイクポイントはユーザ・プログラムを停止させます。`break'
     コマンドで設定されたブレイクポイントの初期状態はこの状態です。
   * 無効。ブレイクポイントはユーザ・プログラムの実行に影響を与えませ
     ん。
   * 1回有効。ブレイクポイントはユーザ・プログラムを停止させますが、停
     止後、そのブレイクポイントは無効状態になります。`tbreak'コマンド
     で設定されたブレイクポイントの初期状態はこの状態です。
   * 1回有効（削除）。ブレイクポイントはユーザ・プログラムを停止させま
     すが、停止直後に、そのブレイクポイントは完全に削除されます。

以下のコマンドを使用することで、ブレイクポイント、ウォッチポイント、
キャッチポイントの有効化、無効化が可能です。

`disable [breakpoints] [BNUMS...]'
     指定されたブレイクポイントを無効化します。番号が1つも指定されない
     場合は、すべてのブレイクポイントが無効化されます。無効化されたブ
     レイクポイントは何ら影響力を持ちませんが、そのブレイクポイントに
     関する情報まで削除されるわけではありません。そのブレイクポイント
     を無視する回数、ブレイクポイント成立の条件、ブレイクポイント・コ
     マンドなどのオプションは、後にそのブレイクポイントが有効化される
     場合に備えて、記憶されています。`disable'コマンドは`dis'と省略す
     ることができます。

`enable [breakpoints] [BNUMS...]'
     指定されたブレイクポイント（または、すべての定義済みブレイクポイ
     ント）を有効化します。有効化されたブレイクポイントは、再びユーザ・
     プログラムを停止させることができるようになります。

`enable [breakpoints] once BNUMS...'
     指定されたブレイクポイントを一時的に有効化します。このコマンドで
     有効化されたブレイクポイントはどれも、最初にプログラムを停止させ
     た直後に、GDBによって無効化されます。

`enable [breakpoints] delete BNUMS...'
     1回だけプログラムを停止させ、その直後に削除されるような設定で、指
     定されたブレイクポイントを有効化します。このコマンドで有効化され
     たブレイクポイントはどれも、最初にプログラムを停止させた直後に、
     GDBによって削除されます。

`tbreak'コマンド（*Note Setting breakpoints: Set Breaks.）で設定された
ブレイクポイントを除き、ユーザによって設定されたブレイクポイントの初期
状態は有効状態です。その後、ユーザが上記のコマンドのいずれかを使用した
場合に限り、無効化されたり有効化されたりします（`until'コマンドは、独
自にブレイクポイントを設定、削除することができますが、ユーザの設定した
他のブレイクポイントの状態は変更しません。*Note Continuing and
stepping: Continuing and Stepping.）。



File: gdb-ja.info, Node: Conditions, Next: Break Commands, Prev: Disabling, Up: Breakpoints

ブレイクポイントの成立条件
--------------------------

最も単純なブレイクポイントは、指定された箇所にプログラムが到達するたび
に、プログラムの実行を停止させます。ブレイクポイントに対して"条件"を指
定することも可能です。ここで、「条件」とは、プログラムが記述された言語
で表現された真偽値を表す式のことです（*Note Expressions: Expressions.）。
条件付きのブレイクポイントにプログラムが到達するたびに、その式が評価さ
れます。そして、その結果が*真*であった場合だけ、プログラムは停止します。

これは、
プログラムの正当性を検査するために診断式を使用するのとは逆になります。
診断式の場合は、
成立しないとき、
すなわち条件が偽であるときに、
プログラムを停止させます。
C言語でASSERTという診断式をテストするためには、
しかるべきブレイクポイントに`! ASSERT'という条件を設定します。

ウォッチポイントに対して条件を設定することもできます。もともとウォッチ
ポイントは、ある式の値を検査するものですから、これは必要ないかもしれま
せん。しかし、ある変数の新しい値がある特定の値に等しいか否かを検査する
のは条件式のほうに任せて、ウォッチポイントの対象そのものは単にその変数
の名前にしてしまうという設定の方が簡単でしょう。

ブレイクポイントの成立条件に副作用を持たせたり、場合によってはプログラ
ム内部の関数を呼び出させたりすることもできます。プログラムの進行状況を
ログに取る関数を呼び出したり、特別なデータ構造をフォーマットして表示す
るユーザ定義の関数を使用したい場合などに便利です。この効果は、同じアド
レスに有効なブレイクポイントが別に設定されていない限り、完全に予測可能
です（別のブレイクポイントが設定されていると、GDBはこのブレイクポイン
トを先に検出し、他のブレイクポイントで設定した条件式をチェックすること
なくプログラムを停止させてしまうかもしれません）。あるブレイクポイント
に到達したときに、副作用を持つ処理を実行させるためには、ブレイクポイン
ト・コマンドの方がより便利であり、より柔軟でしょう（*Note Breakpoint
command lists: Break Commands.）。

ブレイクポイントの成立条件は、ブレイクポイントを設定する際に、`break' 
コマンドの引数に`if'を使用することによって、設定できます。*Note
Setting breakpoints: Set Breaks。ブレイクポイントの成立条件は、
`condition'コマンドによっていつでも変更できます。`watch'コマンドは、
`if'キーワードを認識しません。ウォッチポイントに対して条件を追加設定す
る唯一の方法は、`condition'コマンドを使うことです。

`condition BNUM EXPRESSION'
     BNUMで指定される番号のブレイクポイント、ウォッチポイント、キャッ
     チポイントの成立条件として、EXPRESSIONを指定します。条件を設定し
     た後、番号BNUMのブレイクポイントは、EXPRESSIONの値が真（C言語の場
     合はゼロ以外の値）であるときのみ、ユーザ・プログラムを停止させま
     す。`condition'コマンドを使用すると、GDBはただちにEXPRESSIONの構
     文の正当性、および、EXPRESSIONの中で使用されるシンボル参照の、ブ
     レイクポイントのコンテキストにおける有効性をチェックします。しか
     し、`condition'コマンドが実行されるときに、EXPRESSIONの値がGDBに
     よって実際に評価されるわけではありません。*Note Expressions:
     Expressions。

`condition BNUM'
     BNUMで指定される番号のブレイクポイントから条件を削除します。実行
     後、それは通常の無条件ブレイクポイントになります。

ブレイクポイント成立条件の特別なものに、ブレイクポイントに到達した回数
がある数に達したときにプログラムを停止させるというものがあります。これ
は大変便利なので、それを実現するための特別な方法が提供されています。そ
れは、ブレイクポイントの"通過カウント" （ignore count）を使用する方法
です。すべてのブレイクポイントは、通過カウントと呼ばれる整数値を持って
います。ほとんどの場合、この通過カウントの値はゼロであり、何ら影響力を
持ちません。しかし、通過カウントとして正の値を持つブレイクポイントに到
達すると、ユーザ・プログラムはそこで停止せず、単に通過カウントの値を1
減少させて処理を継続します。したがって、通過カウントがNであると、ユー
ザ・プログラムがそのブレイクポイントに到達した回数がN以下の間は、その
ブレイクポイントにおいてプログラムは停止しません。

`ignore BNUM COUNT'
     BNUMで指定される番号のブレイクポイントの通過カウントをCOUNTで指定
     される値に設定します。ブレイクポイントへの到達回数がCOUNT以下の間、
     ユーザ・プログラムは停止しません。この間、GDBは、通過カウントの値
     を1減少させる以外には何もしません。

     次にブレイクポイントに到達したときにプログラムを停止させるには、
     COUNTにゼロを指定してください。

     ブレイクポイントで停止した後に`continue'コマンドを使用して実行を
     再開する場合、`ignore'コマンドを使用することなく、直接`continue'
     コマンドの引数に通過カウントを指定することができます。*Note
     Continuing and stepping: Continuing and Stepping。

     ブレイクポイントが通過カウントとして正の値を持ち、かつ、成立条件
     を持つ場合、成立条件はチェックされません。通過カウントが0に達する
     と、GDBは成立条件のチェックを再開します。

     `$foo-- <= 0'のように、
     評価のたびに値の減少するコンビニエンス変数を使用した評価式によって、
     通過カウントと同様の効果を達成することができます。
     *Note Convenience variables: Convenience Vars。

通過カウントは、ブレイクポイント、ウォッチポイント、キャッチポイントに
適用されます。



File: gdb-ja.info, Node: Break Commands, Next: Breakpoint Menus, Prev: Conditions, Up: Breakpoints

ブレイクポイント・コマンド・リスト
----------------------------------

ブレイクポイント（あるいは、ウォッチポイント、キャッチポイント）に対し
て、それによってプログラムが停止したときに実行される一連のコマンドを指
定することができます。例えば、ある特定の式の値を表示したり、他のブレイ
クポイントを有効化したりできると便利なこともあるでしょう。

`commands [BNUM]'
`... COMMAND-LIST ...'
`end'
     BNUMで指定される番号を持つブレイクポイントに対して一連のコマンド
     を指定します。コマンド自体は、次の行以下に記述します。コマンドの
     記述を終了するには、`end'だけから成る1行を記述します。

     ブレイクポイントからすべてのコマンドを削除するには、`commands'行
     に続いて（コマンドを1つも指定せずに）`end'を記述します。

     引数BNUMが指定されない場合、`commands'は、最後に設定されたブレイ
     クポイント、ウォッチポイント、キャッチポイントを対象とします（最
     後に到達したブレイクポイントではありません）。

COMMAND-LISTの記述中は、RETキーが持つ、最後に実行されたコマンドを繰り
返し実行する機能は無効です。

ブレイクポイント・コマンドを使用してプログラムの実行を再開することがで
きます。`continue'、`step'、または、実行を再開させるその他の任意のコマ
ンドを使用してください。

コマンド・リストの中で、実行を再開するコマンドの後に記述されているもの
は無視されます。というのは、プログラムが実行を再開すると（たとえそれが
`next'コマンドや`step'コマンドによるものであっても）別のブレイクポイン
トに到達する可能性があり、そのブレイクポイントがコマンド・リストを持っ
ていると、どちらのリストを実行するべきかあいまいになるからです。

コマンド・リストの先頭に指定されたコマンドが`silent'であると、ブレイク
ポイントで停止したときに通常出力されるメッセージは表示されません。これ
は、ある特定のメッセージを出力して実行を継続するようなブレイクポイント
を設定するのに望ましいでしょう。コマンド・リスト中の後続のコマンドがど
れもメッセージを出力しない場合、ブレイクポイントに到達したことをユーザ
に示す情報は何も表示されないことになります。`silent'はブレイクポイント・
コマンド・リストの先頭においてのみ意味を持ちます。

`echo'、`output'、`printf'の各コマンドを使用することで、細かく管理され
た出力を表示することができます。これらのコマンドは、`silent'指定のブレ
イクポイントで使うと便利です。*Note Commands for controlled output:
Output。

例えば、ブレイクポイント・コマンドを使用して、`foo'へのエントリにおい
て`x'が正の値を持つときに、その値を表示するには以下のようにします。

     break foo if x>0
     commands
     silent
     printf "x is %d\n",x
     cont
     end

ブレイクポイント・コマンドの1つの応用として、あるバグの持つ影響を取り
除いて、他のバグを見つけるためにテストを継続することができます。誤りの
ある行の次の行にブレイクポイントを設定し、その条件の中で誤りの発生を検
査し、ブレイクポイント・コマンドの中で修正の必要な変数に正しい値を割り
当てます。コマンド・リストの最後には`continue'コマンドを記述して、プロ
グラムが停止しないようにします。また、プログラムの先頭には`silent'コマ
ンドを記述し、何も出力されないようにします。以下に例を挙げます。

     break 403
     commands
     silent
     set x = y + 4
     cont
     end



File: gdb-ja.info, Node: Breakpoint Menus, Prev: Break Commands, Up: Breakpoints

ブレイクポイント・メニュー
--------------------------

プログラミング言語によっては（特にC++の場合）、異なるコンテキストにお
いて使用するために、同一の関数名を複数回定義することが可能です。これは、
"オーバーローディング"と呼ばれます。関数名がオーバーロードされている場
合、`break FUNCTION'だけでは、どこにブレイクポイントを設定したいのかを
GDBに正しく指定するのに十分ではありません。このような場合には、ブレイ
クポイントを設定したい関数がどれであるかを正確に指定するために、`break
FUNCTION(TYPES)'のような形式を使用することができます。このような形式を
使用しないと、GDBは候補となりえるブレイクポイントの一覧を番号付きのメ
ニューとして表示し、プロンプト`>'によってユーザの選択を待ちます。先頭
の2つの選択肢は常に、`[0] cancel'と`[1] all'です。`1'を入力すると、候
補となるすべての関数のそれぞれの定義に対してブレイクポイントを設定しま
す。また、`0'を入力すると、新たにブレイクポイントを設定することなく
`break'コマンドを終了します。

例えば、以下に示すセッションの抜粋は、オーバーロードされたシンボル
`String::after'に対してブレイクポイントを設定しようとした場合を示して
います。ここでは、この関数名を持つ関数定義の中から3つを選択しています。

     (gdb) b String::after
     [0] cancel
     [1] all
     [2] file:String.cc; line number:867
     [3] file:String.cc; line number:860
     [4] file:String.cc; line number:875
     [5] file:String.cc; line number:853
     [6] file:String.cc; line number:846
     [7] file:String.cc; line number:735
     > 2 4 6
     Breakpoint 1 at 0xb26c: file String.cc, line 867.
     Breakpoint 2 at 0xb344: file String.cc, line 875.
     Breakpoint 3 at 0xafcc: file String.cc, line 846.
     Multiple breakpoints were set.
     Use the "delete" command to delete unwanted
      breakpoints.
     (gdb)




File: gdb-ja.info, Node: Continuing and Stepping, Next: Signals, Prev: Breakpoints, Up: Stopping

継続実行とステップ実行
======================

"継続実行"とは、ユーザ・プログラムの実行を再開して、それが正常に終了す
るまで実行させることを指します。一方、"ステップ実行"とは、ユーザ・プロ
グラムを1「ステップ」だけ実行することを指します。ここで「ステップ」と
は、（使用されるコマンドによって）1行のソース・コードを指すこともあり
ますし、1マシン命令を指すこともあります。継続実行の場合でもステップ実
行の場合でも、ブレイクポイントやシグナルが原因となって、正常終了する前
にユーザ・プログラムが停止することがあります（シグナルによってプログラ
ムが停止した場合、実行を再開するには`handle'コマンドまたは`signal 0' 
コマンドを使用するとよいでしょう。*Note Signals: Signals）。

`continue [IGNORE-COUNT]'
`c [IGNORE-COUNT]'
`fg [IGNORE-COUNT]'
     ユーザ・プログラムが最後に停止した箇所から、プログラムの実行を再
     開します。停止箇所に設定されているブレイクポイントは無視されます。
     オプションの引数IGNORE-COUNTによって、停止箇所のブレイクポイント
     を無視する回数を指定することができます。これは`ignore'コマンドと
     似た効果を持ちます（*Note Break conditions: Conditions.）。

     引数IGNORE-COUNTは、ユーザ・プログラムがブレイクポイントによって
     停止した場合にのみ意味を持ちます。これ以外の場合には、`continue'
     コマンドへの引数は無視されます。

     `c'および`fg'は、簡便さのためだけに提供されている同義コマンドで、
     `continue'コマンドと全く同様の動作をします。

別の箇所で実行を再開するには、呼び出し関数に戻る`return'コマンド
（*Note Returning from a function: Returning.）、または、ユーザ・プロ
グラム内の任意の箇所へ移動する`jump'コマンド（*Note Continuing at a
different address: Jumping.）を使用することができます。

ステップ実行を使用する典型的なテクニックは、問題があると思われる関数や
プログラム部分の先頭にブレイクポイント(*Note Breakpoints; watchpoints;
and catchpoints: Breakpoints.)  を設定し、ブレイクポイントで停止するま
でプログラムを実行させた後、問題が再現するまで、関連しそうな変数の値を
調べながら、疑わしい部分を1行ずつ実行することです。

`step'
     異なるソース行に到達するまでユーザ・プログラムを継続実行した後、
     プログラムを停止させ、GDBに制御を戻します。このコマンドの省略形は
     `s'です。

          *注意:* デバッグ情報なしでコンパイルされた関数の内部にいると
          きに`step'コマンドを使用すると、デバッグ情報付きの関数に達す
          るまでプログラムの実行は継続されます。同様に、`step'コマンド
          がデバッグ情報なしでコンパイルされた関数の内部へ入って、停止
          することはありません。デバッグ情報を持たない関数の内部でステッ
          プ実行を行うには、後述の`stepi'コマンドを使用してください。

     `step'コマンドは、ソース・コード行の最初の命令においてのみ停止す
     るようになりました。これにより、以前のバージョンで発生していた、
     `switch'文や`for'文などにおいて複数回停止してしまうという問題が回
     避されています。同じ行の中にデバッグ情報を持つ関数への呼び出しが
     あると、`step'コマンドは続けて停止します。

     さらに、`step'コマンドは、サブルーチンが行番号情報を持つ場合に限
     り、サブルーチンの内部に入り込むようになりました。サブルーチンが
     行番号情報を持たない場合、`step'コマンドは`next'コマンドと同様の
     動作をします。これにより、MIPSマシン上で`cc -gl'を使用した場合に
     発生していた問題が回避されています。以前のバージョンでは、サブルー
     チンが何らかのデバッグ情報を持っていれば、その内部に入り込んでい
     ました。

`step COUNT'
     `step'コマンドによるステップ実行をCOUNT回繰り返します。ステップ実
     行をCOUNT回繰り返し終わる前に、ブレイクポイントに到達するか、ある
     いは、ステップ実行とは関連のないシグナルが発生した場合には、ただ
     ちにステップ実行を中断して停止します。

`next [COUNT]'
     カレントな（最下位の）スタック・フレーム上において、ソース・コー
     ド上の次の行まで実行します。これは`step'コマンドと似ていますが、
     `next'コマンドは、ソース・コード上に関数呼び出しが存在すると、そ
     の関数を停止することなく最後まで実行します。プログラムが停止する
     のは、`next'コマンドを実行したときと同一のスタック・フレーム上に
     おいて、ソース・コード上の異なる行まで実行が継続されたときです。
     このコマンドの省略形は`n'です。

     引数COUNTは、`step'コマンドの場合と同様、繰り返し回数です。


     `next'コマンドは、ソース・コード行の最初の命令においてのみ停止す
     るようになりました。これにより、以前のバージョンで発生していた、
     `switch'文や`for'文などにおいて複数回停止してしまうという問題が回
     避されています。

`finish'
     選択されているスタック・フレーム上の関数が復帰するまで、実行を継
     続します。戻り値があれば、それを表示します。

     `return'コマンド（*Note Returning from a function: Returning.）と
     比較してみてください。

`until'
`u'
     カレントなスタック・フレーム上において、カレント行よりも後ろにあ
     る行に到達するまで実行を継続します。このコマンドは、ループ内にお
     いて複数回ステップ実行をするのを回避するために使用されます。これ
     は`next'コマンドに似ていますが、唯一の相違点は、`until'コマンドに
     よってジャンプ命令が実行された場合、プログラム・カウンタの値がジャ
     ンプ命令のアドレスより大きくなるまで、プログラムが継続実行される
     という点です。

     これは、ステップ実行によってループ内の最後の行に到達した後に
     `until'コマンドを実行することで、ループから抜け出るまでプログラム
     を継続実行させることができるということを意味しています。これに対
     して、ループ内の最後の行で`next'コマンドを実行すると、プログラム
     はループの先頭に戻ってしまうので、ループ内の処理を繰り返すことを
     余儀なくされます。

     `until'コマンドの実行により、プログラムがカレントなスタック・フレー
     ムから抜け出ようとすると、そこで`until'コマンドはプログラムを停止
     します。

     実行されるマシン・コードの順序がソース行の順序と一致しない場合、
     `until'コマンドは直観にいくらか反するような結果をもたらすかもしれ
     ません。例えば、以下に挙げるデバッグ・セッションからの抜粋では、
     `f' （`frame'）コマンドによって、プログラムが`206'行めにおいて停
     止していることが示されています。ところが、`until'コマンドを実行す
     ると、`195'行めで停止してしまいます。

          (gdb) f
          #0  main (argc=4, argv=0xf7fffae8) at m4.c:206
          206                 expand_input();
          (gdb) until
          195             for ( ; argc > 0; NEXTARG) {

     これは、コンパイラが、実行の効率を高めるために、C言語では`for'ルー
     プ本体の前に記述されているループ終了のための条件判定を、ループの
     先頭ではなく末尾で行うコードを生成したためです。この判定式にまで
     処理が進んだとき、`until'コマンドはあたかもループの先頭に戻ったか
     のように見えます。しかしながら、実際のマシン・コードのレベルでは、
     前の命令に戻ったわけではありません。

     引数のない`until'コマンドは、1命令ごとのステップ実行によって実現
     されるため、引数付きの`until'コマンドに比べて処理性能が劣ります。

`until LOCATION'
`u LOCATION'
     LOCATIONで指定される箇所に到達するか、カレントなスタック・フレー
     ムを抜け出るまで、ユーザ・プログラムを継続実行します。LOCATIONは
     `break'コマンドの受け付ける形式の引数です（*Note Setting
     breakpoints: Set Breaks.）。この形式による`until'コマンドはブレイ
     クポイントを使用するため、引数のない`until'コマンドより処理性能が
     優れています。

`stepi'
`si'
     1マシン命令を実行した後、停止してデバッガに戻ります。

     マシン命令単位でステップ実行する場合、`display/i $pc'を使用すると
     便利なことがしばしばあります。これは、ユーザ・プログラムが停止す
     るたびに、次に実行される命令をGDBに自動的に表示させます。*Note
     Automatic display: Auto Display。

     引数として、`step'コマンドと同様、繰り返し回数を取ります。

`nexti'
`ni'
     1マシン命令を実行しますが、それが関数の呼び出しである場合は、関数
     から復帰するまで実行を継続します。

     引数として、`next'コマンドと同様、繰り返し回数を取ります。



File: gdb-ja.info, Node: Signals, Next: Thread Stops, Prev: Continuing and Stepping, Up: Stopping

シグナル
========

シグナルは、プログラム内で発生する非同期イベントです。オペレーティング・
システムによって、使用可能なシグナルの種類が定義され、それぞれに名前と
番号が割り当てられます。例えば、UNIXにおいては、割り込み（通常は、
`Ctrl'キーを押しながら`C'を押す）を入力したときにプログラムが受信する
`SIGINT'、その使用領域からかけ離れたメモリ域を参照したときにプログラム
が受信する`SIGSEGV'、アラームのタイムアウト時に発生する（プログラムか
らアラームを要求した場合にのみ発生する）`SIGALRM'シグナルなどがありま
す。

`SIGALRM'など、いくつかのシグナルは、プログラムの正常な機能の一部です。
`SIGSEGV'などの他のシグナルは、エラーを意味します。これらのシグナルは、
プログラムが事前にそれを処理する何らかの方法を指定しないと、"致命的"な
（プログラムを即座に終了させる）ものとなります。`SIGINT'はユーザ・プロ
グラム内部のエラーを意味するものではありませんが、通常は致命的なもので
あり、割り込みの目的であるプログラムの終了を実現することができます。

GDBは、ユーザ・プログラム内部における任意のシグナル発生を検出すること
ができます。ユーザは、個々のシグナルの発生時に何を実行するかを、GDBに
対して事前に指定することができます。

通常GDBは、`SIGALRM'のようなエラーではないシグナルを無視するよう（これ
らのシグナルがユーザ・プログラムの中で持っている役割を妨害することのな
いよう）設定されています。その一方で、エラーのシグナルが発生した場合に
はすぐにユーザ・プログラムを停止させるよう設定されています。これらの設
定は`handle'コマンドによって変更することができます。

`info signals'
     すべてのシグナルを一覧にして表示します。また、個々のシグナルにつ
     いて、GDBがそれをどのように処理するよう設定されているかを表示しま
     す。このコマンドを使用して、定義済みのすべてのシグナルのシグナル
     番号を知ることができます。

     `info handle'は、`info signals'に対して設定された新しい別名です。

`handle SIGNAL KEYWORDS...'
     GDBがSIGNALで指定されるシグナルを処理する方法を変更します。SIGNAL
     には、シグナル番号またはシグナル名称（先頭の`SIG'は省略可能）を指
     定します。キーワードKEYWORDSによって、どのように変更するかを指定
     します。

`handle'コマンドが受け付けるキーワードには省略形を使用することができま
す。省略しない場合、キーワードは以下のようになります。

`nostop'
     GDBに対して、このシグナルが発生してもユーザ・プログラムを停止しな
     いよう指示します。GDBは、シグナルを受信したことをメッセージ出力に
     よってユーザに通知することができます。

`stop'
     GDBに対して、このシグナルが発生するとユーザ・プログラムを停止する
     よう指示します。これは、`print'キーワードを暗黙のうちに含みます。

`print'
     GDBに対して、このシグナルが発生するとメッセージを表示するよう指示
     します。

`noprint'
     GDB に対して、このシグナルが発生したことを知らせないよう指示しま
     す。これは、`nostop'キーワードを暗黙のうちに含みます。

`pass'
     GDBに対して、このシグナルの発生をユーザ・プログラムが検出できるよ
     うにするよう指示します。ユーザ・プログラムはシグナルを処理するこ
     とができます。致命的で処理できないシグナルが発生した場合、ユーザ・
     プログラムは停止するかもしれません。

`nopass'
     GDBに対して、このシグナルの発生をユーザ・プログラムが検出できない
     ようにするよう指示します。

シグナルによってユーザ・プログラムが停止した場合、実行を継続するまでそ
のシグナルは検出されません。*その時点において*、そのシグナルに対して
`pass'キーワードが有効であれば、ユーザ・プログラムは、実行継続時にシグ
ナルを検出します。言い換えれば、GDBがシグナルの発生を報告してきたとき、
`handle'コマンドに`pass'キーワードまたは`nopass'キーワードを指定するこ
とで、実行を継続したときにプログラムにそのシグナルを検出させるか否かを
制御することができます。

また、
`signal'コマンドを使用することによって、
ユーザ・プログラムがシグナルを検出できないようにしたり、
通常は検出できないシグナルを検出できるようにしたり、
あるいは任意の時点で任意のシグナルをユーザ・プログラムに検出させたりすることができます。
例えば、
ユーザ・プログラムが何らかのメモリ参照エラーによって停止した場合、
ユーザは、
さらに実行を継続しようとして、
問題のある変数に正しい値を設定して継続実行しようとするかもしれません。
しかし、
実行継続直後に検出される致命的なシグナルのために、
おそらくユーザ・プログラムはすぐに終了してしまうでしょう。
このようなことを回避したければ、
`signal 0'コマンドによって実行を継続することができます。
*Note Giving your program a signal: Signaling。



File: gdb-ja.info, Node: Thread Stops, Prev: Signals, Up: Stopping

マルチスレッド・プログラムの停止と起動
======================================

ユーザ・プログラムが複数のスレッド（*Note Debugging programs with
multiple threads: Threads.）を持つ場合、すべてのスレッドにブレイクポイ
ントを設定するか、特定のスレッドにブレイクポイントを設定するかを選択す
ることができます。

`break LINESPEC thread THREADNO'
`break LINESPEC thread THREADNO if ...'
     LINESPECはソース行を指定します。記述方法はいくつかありますが、ど
     の方法を使っても結果的にはソース行を指定することになります。

     `break'コマンドに修飾子`thread THREADNO'を使用することで、ある特
     定のスレッドがこのブレイクポイントに到達したときだけGDBがプログラ
     ムを停止するよう、指定することができます。ここでTHREADNOは、GDBに
     よって割り当てられるスレッド識別番号で、`info threads'コマンドに
     よる出力の最初の欄に表示されるものです。

     ブレイクポイントを設定する際に`thread THREADNO'を指定しなければ、
     そのブレイクポイントはユーザ・プログラム内部の*すべて*のスレッド
     に適用されます。

     条件付きのブレイクポイントに対しても`thread'識別子を使用すること
     ができます。この場合、以下のように`thread THREADNO'をブレイクポイ
     ント成立条件の前に記述してください。

          (gdb) break frik.c:13 thread 28 if bartab > lim


いかなる理由によるのであれGDB配下においてユーザ・プログラムが停止した
場合、カレント・スレッドだけではなく、*すべて*の実行スレッドが停止しま
す。これにより、知らないうちに状態の変化が発生することを心配することな
く、スレッドの切り替えも含めて、プログラム全体の状態を検査することがで
きます。

逆に、プログラムの実行を再開したときには、*すべて*のスレッドが実行を開
始します。これは、`step'コマンドや`next'コマンドによる*シングル・ステッ
プ実行の場合でも同様*です。

特にGDBは、すべてのスレッドの歩調を合わせてシングル・ステップ実行する
ことはできません。スレッドのスケジューリングは、デバッグ対象のマシンの
オペレーティング・システムに依存する（GDBが管理するわけではない）ので、
カレント・スレッドがシングル・ステップの実行を完了する前に、他のスレッ
ドは複数の文を実行してしまうかもしれません。また、プログラムが停止する
とき、他のスレッドは2つの文の間の境界のところでぴったり停止するよりも、
文の途中で停止してしまう方が一般的です。

また、継続実行やステップ実行の結果、プログラムが別のスレッド内で停止し
てしまうこともありえます。最初のスレッドがユーザの要求した処理を完了す
る前に、他のスレッドがブレイクポイントに到達した場合、シグナルを受信し
た場合、例外が発生した場合には、常にこのようなことが発生します。

OSによっては、OSスケジューラをロックすることによって、ただ1つのスレッ
ドだけが実行されるようにすることができます。

`set scheduler-locking MODE'
     スケジューラのロッキング・モード（locking mode）を設定します。
     `off'の場合は、ロックのメカニズムは機能せず、任意の時点において、
     どのスレッドも実行される可能性を持ちます。`on'の場合は、再始動
     （resume）されるスレッドの優先順位が低い場合には、カレント・スレッ
     ドだけが実行を継続することができます。`step'モードでは、シングル・
     ステップ実行のための最適化が行われます。ステップ実行をしている間、
     他のスレッドが「プロンプトを横取りする」ことがないよう、カレント・
     スレッドに占有権が与えられます。また、ステップ実行をしている間、
     他のスレッドはきわめて稀にしか（あるいは、まったく）実行するチャ
     ンスを与えられません。`next'コマンドによって関数呼び出しの次の行
     まで処理を進めると、他のスレッドが実行される可能性は高くなります。
     また、`continue'、`until'、`finish'のようなコマンドを使用すると、
     他のスレッドは完全に自由に実行されることができます。しかし、その
     タイムスライスの中でブレイクポイントに到達しない限り、他のスレッ
     ドが、デバッグの対象となっているスレッドから、GDBプロンプトを横取
     りすることはありません。

`show scheduler-locking'
     スケジューラの現在のロッキング・モードを表示します。





File: gdb-ja.info, Node: Stack, Next: Source, Prev: Stopping, Up: Top

スタックの検査
**************

ユーザ・プログラムが停止したとき、まず最初に、どこで停止したのか、そし
て、どのようにしてそこに到達したのかを知る必要があるでしょう。

ユーザ・プログラムが関数呼び出しを行うたびに、その呼び出しに関する情報
が生成されます。その情報には、ユーザ・プログラム内においてその呼び出し
が発生した場所、関数呼び出しの引数、呼び出された関数内部のローカル変数
などが含まれます。その情報は、"スタック・フレーム"と呼ばれるデータ・ブ
ロックに保存されます。スタック・フレームは、"呼び出しスタック"と呼ばれ
るメモリ域に割り当てられます。

ユーザ・プログラムが停止すると、スタックを検査するGDBコマンドを使用し
て、この情報をすべて見ることができます。

GDBは1つのスタック・フレームを"選択"していて、多くのGDBコマンドはこの
選択されたフレームを暗黙のうちに参照します。特に、GDBに対してユーザ・
プログラム内部の変数の値を問い合わせると、GDBは選択されたフレームの内
部においてその値を探そうとします。関心のあるフレームを選択するための特
別なGDBコマンドが提供されています。*Note Selecting a frame: Selection。

ユーザ・プログラムが停止すると、GDBはその時点において実行中のフレーム
を自動的に選択し、`frame'コマンド（*Note Information about a frame:
Frame Info.）のように、そのフレームに関する情報を簡潔に表示します。

* Menu:

* Frames::                      スタック・フレーム
* Backtrace::                   バックトレース
* Selection::                   フレームの選択
* Frame Info::                  フレームに関する情報
* Alpha/MIPS Stack::            Alpha/MIPSマシンの関数スタック




File: gdb-ja.info, Node: Frames, Next: Backtrace, Prev: Stack, Up: Stack

スタック・フレーム
==================

呼び出しスタックは、"スタック・フレーム"、または短縮して"フレーム"と呼
ばれる、連続した小部分に分割されます。個々のフレームは、ある関数に対す
る1回の呼び出しに関連するデータです。フレームには、関数への引数、関数
のローカル変数、関数の実行アドレスなどの情報が含まれます。

ユーザ・プログラムが起動されたとき、スタックには`main'関数のフレームが
1つ存在するだけです。これは、"初期"フレームまたは「"最上位のフレーム"」
と呼ばれます。関数が呼び出されるたびに、新たにフレームが作成されます。
関数が復帰すると、その関数を呼び出したときに生成されたフレームが取り除
かれます。関数が再帰的に呼び出される場合、1つの関数に対して多くのフレー
ムが生成されるということもありえます。実際に実行中の関数に対応するフレー
ムは、「"最下位のフレーム"」と呼ばれます。これは、存在するすべてのスタッ
ク・フレームの中で、最も新しく作成されたものです。

ユーザ・プログラムの内部においては、スタック・フレームはアドレスによっ
て識別されます。スタック・フレームは多くのバイトから構成され、それぞれ
がそれ自身のアドレスを持っています。そのアドレスがフレームのアドレスと
なるような1バイトを選択する慣習的な方法を、すべての種類のコンピュータ
が提供しています。通常、あるフレーム内部で実行中は、そのフレームのアド
レスが"フレーム・ポインタ・レジスタ"と呼ばれるレジスタに格納されていま
す。

GDBは、既存のスタック・フレームのすべてに番号を割り当てます。最下位の
フレームは0で、それを呼び出したフレームは1となります。以下、最下位のフ
レームを起点として、順番に値を割り当てていきます。これらの番号はユーザ・
プログラム内部には実際には存在しません。これらの番号は、GDBコマンドで
スタック・フレームを指定することができるように、GDBによって割り当てら
れたものです。

コンパイラによっては、スタック・フレームを使用しなくても実行可能なよう
に関数をコンパイルする方法を提供しているものもあります（例えば、`gcc'
のオプション`-fomit-frame-pointer'を指定すると、フレームを持たない関数
が生成されます）。これは、フレームをセットアップする時間を節約するため
に、頻繁に利用されるライブラリ関数に対してしばしば適用されます。これら
の関数の呼び出しを処理するためにGDBが提供する機能は限られています。最
下位のフレームの関数呼び出しがスタック・フレームを持たない場合、GDBは、
あたかもそれが通常どおりに番号0のフレームを持つものとみなして、関数呼
び出しの連鎖を跡づけることができるようにします。しかしながら、最下位以
外のスタック位置に存在する、フレームを持たない関数に対しては、GDBは特
別な処置を取りません。

`frame ARGS'
     `frame'コマンドによって、あるスタック・フレームから別のスタック・
     フレームに移動し、選択したスタック・フレームを表示させることがで
     きます。ARGSは、フレームのアドレスまたはスタック・フレーム番号で
     す。引数なしで実行すると、`frame'コマンドはカレントなスタック・フ
     レームを表示します。

`select-frame'
     `select-frame'コマンドによって、フレームを表示することなく、ある
     スタック・フレームから別のスタック・フレームに移動することができ
     ます。これは、`frame'コマンドから、表示処理を取り除いたものです。



File: gdb-ja.info, Node: Backtrace, Next: Selection, Prev: Frames, Up: Stack

バックトレース
==============

バックトレースとは、ユーザ・プログラムが現在いる箇所にどのようにして到
達したかを示す要約情報です。複数のフレームが存在する場合、1フレームの
情報を1行に表示します。現在実行中のフレーム（番号0のフレーム）を先頭に、
それを呼び出したフレーム（番号1のフレーム）を次行に、以降、同様にスタッ
クをさかのぼって情報を表示します。

`backtrace'
`bt'
     全スタックのバックトレースを表示します。スタック内のすべてのフレー
     ムが、1行に1フレームずつ表示されます。

     システムの割り込み文字（通常は、`Ctrl'キーを押しながら`C'を押す）
     によって、いつでもバックトレースを停止することができます。

`backtrace N'
`bt N'
     引数のない`backtrace'コマンドと似ていますが、最下位のフレームから
     数えてN個のフレームだけが表示されます。

`backtrace -N'
`bt -N'
     引数のない`backtrace'コマンドと似ていますが、最上位のフレームから
     数えてN個のフレームだけが表示されます。

`backtrace'の別名としては、ほかに`where'や`info stack' （省略形は`info
s'）があります。

`backtrace'コマンドの出力結果の各行に、フレーム番号と関数名が表示され
ます。`set print address off'コマンドを実行していなければ、プログラム・
カウンタの値も表示されます。`backtrace'コマンドの出力結果では、関数へ
の引数に加えて、ソース・ファイル名や行番号も表示されます。プログラム・
カウンタが、行番号で指定される行の最初のコードを指している場合、その値
は省略されます。

以下に`backtrace'の例を示します。これは、`bt 3'の出力であり、したがっ
て最下位のフレームから3フレームが表示されています。

     #0  m4_traceon (obs=0x24eb0, argc=1, argv=0x2b8c8) 
         at builtin.c:993
     #1  0x6e38 in expand_macro (sym=0x2b600) at macro.c:242
     #2  0x6840 in expand_token (obs=0x0, t=177664, td=0xf7fffb08)
         at macro.c:71
     (More stack frames follow...)

番号0のフレームを表示する行の先頭には、プログラム・カウンタの値があり
ません。これは、`builtin.c'の`993'行めの最初のコードにおいてユーザ・プ
ログラムが停止したことを表わしています。



File: gdb-ja.info, Node: Selection, Next: Frame Info, Prev: Backtrace, Up: Stack

フレームの選択
==============

スタックやユーザ・プログラム内の他のデータを調べるためのほとんどのコマ
ンドは、それが実行された時点において選択されているスタック・フレーム上
で動作します。以下に、スタック・フレームを選択するためのコマンドを列挙
します。どのコマンドも、それによって選択されたスタック・フレームに関す
る簡単な説明を最後に表示します。

`frame N'
`f N'
     番号Nのフレームを選択します。最下位の（現在実行中の）フレームが番
     号0のフレーム、最下位のフレームを呼び出したフレームが番号1のフレー
     ム、以下同様となります。最も大きい番号を持つフレームは`main'のフ
     レームです。

`frame ADDR'
`f ADDR'
     アドレスADDRのフレームを選択します。スタック・フレームの連鎖がバ
     グのために破壊されてしまって、GDBがすべてのフレームに正しく番号を
     割り当てられないような場合に、この方法が役に立ちます。さらに、ユー
     ザ・プログラムが複数のスタックを持ち、スタックの切り替えを行うよ
     うな場合にも有効です。

     SPARCアーキテクチャでは、フレームを任意に選択するには、フレーム・
     ポインタ、スタック・ポインタの2つのアドレスを`frame'に指定する必
     要があります。

     MIPS、Alphaの両アーキテクチャでは、スタック・ポインタ、プログラム・
     カウンタの2つのアドレスが必要です。

     29kアーキテクチャでは、レジスタ・スタック・ポインタ、プログラム・
     カウンタ、メモリ・スタック・ポインタの3つのアドレスが必要です。

`up N'
     スタックをNフレームだけ上へ移動します。Nが正の値の場合、最上位の
     フレームに向かって移動します。これは、より大きいフレーム番号を持
     ち、より長く存在しているフレームへの移動です。Nのデフォルト値は、
     0です。

`down N'
     スタックをNフレームだけ下へ移動します。Nが正の値の場合、最下位の
     フレームに向かって移動します。これは、より小さいフレーム番号を持
     ち、より最近作成されたフレームへの移動です。Nのデフォルト値は1で
     す。`down'の省略形は`do'です。

これらのコマンドはいずれも、最後にフレームに関する情報を2行で表示しま
す。1行めには、フレーム番号、関数名、引数、ソース・ファイル名、そのフ
レーム内において実行停止中の行番号が表示されます。2行めには、実行停止
中のソース行が表示されます。

以下に、例を示します。

     (gdb) up
     #1  0x22f0 in main (argc=1, argv=0xf7fffbf4, env=0xf7fffbfc)
         at env.c:10
     10              read_input_file (argv[i]);

この情報が表示された後で、`list'コマンドを引数なしで実行すると、フレー
ム内で実行停止中の行を中心に10行のソース行が表示されます。*Note
Printing source lines: List。

`up-silently N'
`down-silently N'
     これら2つのコマンドは、それぞれ、`up'コマンド、`down'コマンドの変
     種です。相違点は、ここに挙げた2つのコマンドが、新しいフレームに関
     する情報を表示することなく実行されるという点にあります。これらは、
     情報の出力が不必要で邪魔ですらある、GDBのコマンド・スクリプトの中
     での使用を主に想定したものです。



File: gdb-ja.info, Node: Frame Info, Next: Alpha/MIPS Stack, Prev: Selection, Up: Stack

フレームに関する情報
====================

既に挙げたもの以外にも、選択されたフレームに関する情報を表示するコマン
ドがいくつかあります。

`frame'
`f'
     このコマンドは、引数なしで実行されると、別のフレームを選択するの
     ではなく、その時点において選択中のフレームに関する簡単な説明を表
     示します。このコマンドの省略形は`f'です。引数付きの場合、このコマ
     ンドはスタック・フレームを選択するのに使用されます。*Note
     Selecting a frame: Selection。

`info frame'
`info f'
     このコマンドは、選択されたフレームに関する詳細な情報を表示します。
     表示される情報には、以下のようなものがあります。

        * フレームのアドレス
        * 1つ下位の（選択されたフレームによって呼び出された）フレーム
          のアドレス
        * 1つ上位の（選択されたフレームを呼び出した）フレームのアドレ
          ス
        * 選択されたフレームに対応するソース・コードを記述した言語
        * フレームの引数のアドレス
        * 退避されているプログラム・カウンタ（呼び出し側フレームの実行
          アドレス）
        * 退避されているレジスタ

     これらの詳細な情報は、何か問題が発生して、スタックの形式が通常の
     慣習に合致しなくなった場合に、役に立ちます。

`info frame ADDR'
`info f ADDR'
     アドレスADDRのフレームに関する詳細な情報を、そのフレームを選択す
     ることなく表示します。このコマンドによって、その時点において選択
     されていたフレームとは異なるフレームが選択されてしまうことはあり
     ません。このコマンドでは、`frame'コマンドに指定するのと同様のアド
     レスを（アーキテクチャによっては複数）指定する必要があります。
     *Note Selecting a frame: Selection。

`info args'
     選択中のフレームの引数を、1行に1つずつ表示します。

`info locals'
     選択中のフレームのローカル変数を、1行に1つずつ表示します。これら
     はすべて、選択中のフレームの実行箇所においてアクセス可能な（静的
     変数または自動変数として宣言された）変数です。

`info catch'
     選択中のスタック・フレームの実行箇所においてアクティブな状態にあ
     る、すべての例外ハンドラの一覧を表示します。他の例外ハンドラを参
     照したい場合は、関連するフレームに（`up'コマンド、`down'コマンド、
     `frame'コマンドを使用して）移動してから、`info catch'を実行します。
     *Note Setting catchpoints: Set Catchpoints。



File: gdb-ja.info, Node: Alpha/MIPS Stack, Prev: Frame Info, Up: Stack

MIPS/Alphaマシンの関数スタック
==============================

AlphaベースのコンピュータとMIPSベースのコンピュータは、変わったスタッ
ク・フレームを使用しています。そのため、関数の先頭を見つけるために、
GDBはときどきオブジェクト・コードを逆方向に検索する必要があります。

応答時間を改善するために（特に、このような検索を実行するのに、速度の遅
いシリアル回線を使用するほかない、組み込みアプリケーションの場合）、以
下に列挙するコマンドを使用して検索量を制限するとよいでしょう。

`set heuristic-fence-post LIMIT'
     関数の先頭を検索するためにGDBが検査するバイト数を、最高でLIMITバ
     イトに制限します。LIMITに0 （デフォルト）を指定すると、無制限に検
     索することを意味します。LIMITに0以外の値を指定すると、その値が大
     きければ大きいほど検索バイト数も多くなり、したがって検索の実行に
     より長い時間がかかります。

`show heuristic-fence-post'
     現在の検索制限値を表示します。

これらのコマンドは、GDBが、Alphaプロセッサ上、または、MIPSプロセッサ上
においてプログラムをデバッグするよう構成されている場合に*のみ*使用する
ことができます。




File: gdb-ja.info, Node: Source, Next: Data, Prev: Stack, Up: Top

ソース・ファイルの検査
**********************

GDBは、ユーザ・プログラムのソース・コードの一部を表示することができま
す。これは、プログラムの中に記録されているデバッグ情報によって、そのプ
ログラムをビルドするのに使用されたソース・ファイルをGDBが知ることがで
きるからです。ユーザ・プログラムが停止すると、GDBは自発的にプログラム
が停止した行を表示します。同様に、ユーザがあるスタック・フレーム
（*Note Selecting a frame: Selection.）を選択すると、そのフレームにお
いて実行が停止している行をGDBは表示します。明示的にコマンドを使用する
ことで、ソース・ファイルの他の部分を表示することも可能です。

GNU Emacsインターフェイス経由でGDBを使用しているユーザは、Emacsの提供
する機能を使ってソース・ファイルを参照する方を好むかもしれません。これ
については、*Note Using GDB under GNU Emacs: Emacs。

* Menu:

* List::                        ソース行の表示
* Search::                      ソース・ファイル内の検索

* Source Path::                 ソース・ディレクトリの指定
* Machine Code::                ソースとマシン・コード



File: gdb-ja.info, Node: List, Next: Search, Prev: Source, Up: Source

ソース行の表示
==============

ソース・ファイル内の行を表示するには、`list'コマンド（省略形は`l'）を
使用します。デフォルトでは、10行が表示されます。ソース・ファイルのどの
部分を表示するかを指定する方法がいくつかあります。

最もよく使われる`list'コマンドの形式を以下に示します。

`list LINENUM'
     現在のソース・ファイルの行番号LINENUMを中心に、その前後の行を表示
     します。

`list FUNCTION'
     関数FUNCTIONの先頭を中心に、その前後の行を表示します。

`list'
     ソース・ファイル行の続きを表示します。既に表示された最後の行が
     `list'コマンドによって表示されたのであれば、その最後の行の次の行
     以降が表示されます。しかし、既に表示された最後の行が、スタック・
     フレーム（*Note Examining the Stack: Stack.）の表示の一部として1
     行だけ表示されたのであれば、その行の前後の行が表示されます。

`list -'
     前回表示された行の前に位置する行を表示します。

`list'コマンドを上記の形式のいずれかによって実行すると、GDBはデフォル
トでは10行のソース行を表示します。これは`set listsize'コマンドによって
変更することができます。

`set listsize COUNT'
     `list'コマンドで表示される行数をCOUNTに設定します（`list'コマンド
     の引数で他の値が明示的に指定された場合は、この設定は効力を持ちま
     せん）。

`show listsize'
     `list'コマンドが表示する行数を表示します。

`list'コマンドを実行後、RETキーによって`list'コマンドを実行した場合、
引数は破棄されます。したがって、これは単に`list'と入力して実行したのと
同じことになります。同じ行が繰り返し表示されるよりも、この方が役に立つ
でしょう。ただし、引数`-'は例外となります。この引数は繰り返し実行の際
にも維持されるので、繰り返し実行することで、ソース・ファイルの内容がさ
かのぼって表示されていきます。

一般的には、`list'コマンドは、ユーザによって0個、1個、または2個の"行指
定"（"linespec"）が与えられることを期待しています。ここで行指定とは、
ソース行を指定するものです。いくつかの記述方法がありますが、いずれも結
果的には何らかのソース行を指定するものです。`list'コマンドの引数として
使用できる引数の完全な説明を以下に示します。

`list LINESPEC'
     LINESPECによって指定される行を中心に、その前後の行を表示します。

`list FIRST,LAST'
     FIRST行からLAST行までを表示します。両引数はいずれも行指定です。

`list ,LAST'
     LAST行までを表示します。

`list FIRST,'
     FIRST行以降を表示します。

`list +'
     最後に表示された行の次の行以降を表示します。

`list -'
     最後に表示された行の前の行以前を表示します。

`list'
     前述のとおり。

以下に、ソースの特定の1行を指定する方法を示します。これは、いずれも行
指定です。

`NUMBER'
     現在のソース・ファイルの行番号NUMBERの行を指定します。`list'コマ
     ンドの引数に2つの行指定がある場合、2つめの行指定は、最初の行指定
     と同一のソース・ファイルを指定します。

`+OFFSET'
     最後に表示された行からOFFSETで指定される行数だけ下にある行を指定
     します。2つの行指定を引数として持つ`list'コマンドにおいて、これが
     2つめの行指定として使用される場合、最初の行指定からOFFSETで指定さ
     れる行数だけ下の行を指定します。

`-OFFSET'
     最後に表示された行からOFFSETで指定される行数だけ上にある行を指定
     します。

`FILENAME:NUMBER'
     ソース・ファイルFILENAMEの行番号NUMBERの行を指定します。

`FUNCTION'
     関数FUNCTIONの本体の先頭行を指定します。例えばC言語では、左括弧
     （`{'）のある行を指します。

`FILENAME:FUNCTION'
     ファイルFILENAME内の関数FUNCTIONの本体を開始する左括弧（`{'）のあ
     る行を指定します。異なるソース・ファイルの中に同一の名前の関数が
     複数ある場合にのみ、あいまいさを回避するために、関数名とともにファ
     イル名を指定する必要があります。

`*ADDRESS'
     プログラム・アドレスADDRESSを含む行を指定します。ADDRESSには任意
     の式を指定することができます。



File: gdb-ja.info, Node: Search, Next: Source Path, Prev: List, Up: Source

ソース・ファイル内の検索
========================

カレントなソース・ファイル内において正規表現による検索を行うためのコマ
ンドが2つあります。

`forward-search REGEXP'
`search REGEXP'
     `forward-search REGEXP'コマンドは、最後に`list'コマンドによって表
     示された行の1つ下の行から、1行ずつ正規表現REGEXPによる検索を行い
     ます。正規表現にマッチするものが見つかると、その行を表示します。
     `search REGEXP'という同義のコマンドを使うこともできます。コマンド
     名は、省略して`fo'とすることができます。

`reverse-search REGEXP'
     `reverse-search REGEXP'コマンドは、最後に`list'コマンドによって表
     示された行の1つ上の行から、1行ずつ逆方向に向かって正規表現REGEXP
     による検索を行います。正規表現にマッチするものが見つかると、その
     行を表示します。コマンド名は、省略して`rev'とすることができます。



File: gdb-ja.info, Node: Source Path, Next: Machine Code, Prev: Search, Up: Source

ソース・ディレクトリの指定
==========================

実行形式プログラムは、それがコンパイルされたソース・ファイルの名前だけ
を記録して、ソース・ファイルの存在するディレクトリ名を記録しないことが
あります。また、ディレクトリ名が記録された場合でも、コンパイル時とデバッ
グ時との間に、そのディレクトリが移動してしまっている可能性があります。
GDBは、ソース・ファイルを検索すべきディレクトリの一覧を持っています。
これは、"ソース・パス"と呼ばれます。GDBは、ソース・ファイルが必要なと
きにはいつでも、それが見つかるまで、このリストの中のすべてのディレクト
リを、リストの中に記述されている順に探します。実行ファイルのサーチ・パ
スは、この目的では*使用されない*ことに気をつけてください。またカレント
な作業ディレクトリも、それがたまたまソース・パスの中にある場合を除けば、
この目的で使用されることはありません。

GDBがソース・パスの中でソース・ファイルを見つけることができない場合、
プログラムがディレクトリ名を記録してあれば、そのディレクトリも検索され
ます。ソース・パスにディレクトリの指定がなく、コンパイルされたディレク
トリの名前も記録されていない場合、GDBは最後の手段としてカレント・ディ
レクトリを探します。

ソース・パスを空にした場合、または、再調整した場合、ソース・ファイルを
見つけた場所や個々の行のファイル内の位置のような、GDBが内部でキャッシュ
している情報は消去されます。

GDBを起動した時点では、ソース・パスにはディレクトリの指定がありません。
ディレクトリをソース・パスに追加するには、`directory'コマンドを使用し
てください。

`directory DIRNAME ...'
`dir DIRNAME ...'
     ディレクトリDIRNAMEをソース・パスの先頭に追加します。個々のディレ
     クトリをコロン`:'または空白で区切ることによって、複数のディレクト
     リをこのコマンドに渡すことができます。ソース・パスの中に既に存在
     するディレクトリを指定することもできます。この場合、そのディレク
     トリの、ソース・パスの中での位置が前に移動するので、GDBはそのディ
     レクトリの中を以前よりも早く検索することになります。

     （コンパイル時のディレクトリが記録されていれば）それを指すのに文
     字列`$cdir'を使うことができます。また、カレントな作業ディレクトリ
     を指すには、文字列`$cwd'を使うことができます。`$cwd'と`.'  （ピリ
     オド）とは同じではありません。前者は、GDBセッション内においてカレ
     ントな作業ディレクトリが変更された場合、変更されたディレクトリを
     指します。これに対して後者は、ソース・パスへの追加を行ったときに、
     その時点におけるカレント・ディレクトリに展開されてしまいます。

`directory'
     ソース・パスの内容を再び空にします。ソース・パスを空にする前に、
     確認を求めてきます。


`show directories'
     ソース・パスを表示します。ソース・パスに含まれるディレクトリ名を
     見ることができます。

ソース・パスの中に、不要となってしまったディレクトリが混在していると、
GDBが誤ったバージョンのソースを見つけてしまい、混乱をもたらすことがあ
ります。以下の手順によって、正常な状態にすることができます。

  1. ソース・パスを空にするために、`directory'コマンドを引数なしで実行
     します。

  2. ソース・パス中に含めたいディレクトリが組み込まれるよう、
     `directory'コマンドに適切な引数を指定して実行します。すべてのディ
     レクトリを、1回のコマンド実行で追加することができます。



File: gdb-ja.info, Node: Machine Code, Prev: Source Path, Up: Source

ソースとマシン・コード
======================

`info line'コマンドを使用してソース行をプログラム・アドレスに（あるい
は、プログラム・アドレスをソース行に）対応付けすることができます。また、
`disassemble'コマンドを使用して、あるアドレス範囲をマシン命令として表
示することもできます。GNU Emacsモードで実行されている場合、現在の`info
line'コマンドは、指定された行を示す矢印を表示します。また、`info line'
コマンドは、アドレスを16進形式だけではなくシンボリック形式でも表示しま
す。

`info line LINESPEC'
     ソース行LINESPECに対応するコンパイル済みコードの開始アドレス、終
     了アドレスを表示します。`list'コマンド（*Note Printing source
     lines: List.）が理解できる任意の形式によってソース行を指定するこ
     とができます。

例えば、`info line'コマンドによって、関数`m4_changequote'の最初の行に
対応するオブジェクト・コードの位置を知ることができます。

     (gdb) info line m4_changecom
     Line 895 of "builtin.c" starts at pc 0x634c and ends at 0x6350.

また、（LINESPECの形式として`*ADDR'を使用することで）ある特定のアドレ
スがどのソース行に含まれているのかを問い合わせることができます。

     (gdb) info line *0x63ff
     Line 926 of "builtin.c" starts at pc 0x63e4 and ends at 0x6404.

`info line'の実行後、`x'コマンドのデフォルト・アドレスは、その行の先頭
アドレスに変更されます。これにより、マシン・コードの調査を開始するには
`x/i'を実行するだけで十分となります（*Note Examining memory: Memory.）。
また、このアドレスはコンビニエンス変数`$_'の値として保存されます
（*Note Convenience variables: Convenience Vars.）。

`disassemble'
     この特殊コマンドは、あるメモリ範囲をマシン命令としてダンプ出力し
     ます。デフォルトのメモリ範囲は、選択されたフレームにおいてプログ
     ラム・カウンタが指している箇所を含む関数です。このコマンドに引数
     を1つ渡すと、それはプログラム・カウンタ値を指定することになります。
     GDBは、その値が指す箇所を含んでいる関数をダンプ出力します。2つの
     引数を渡すと、ダンプ出力するアドレス範囲（1つめのアドレスは含まれ
     ますが、2つめのアドレスは含まれません）を指定することになります。

以下の例は、あるアドレス範囲のHP PA-RISC 2.0コードを逆アセンブルした結
果を示しています。

     (gdb) disas 0x32c4 0x32e4
     Dump of assembler code from 0x32c4 to 0x32e4:
     0x32c4 <main+204>:      addil 0,dp
     0x32c8 <main+208>:      ldw 0x22c(sr0,r1),r26
     0x32cc <main+212>:      ldil 0x3000,r31
     0x32d0 <main+216>:      ble 0x3f8(sr4,r31)
     0x32d4 <main+220>:      ldo 0(r31),rp
     0x32d8 <main+224>:      addil -0x800,dp
     0x32dc <main+228>:      ldo 0x588(r1),r26
     0x32e0 <main+232>:      ldil 0x3000,r31
     End of assembler dump.


アーキテクチャによっては、一般に使用される命令ニーモニックを複数持つも
のや、異なる構文を持つものがあります。

`set assembly-language INSTRUCTION-SET'
     `disassemble'コマンドまたは`x/i'コマンドによってプログラムの逆ア
     センブルを行う際に使用する命令セットを選択します。

     現在のところ、このコマンドは、Intel x86ファミリに対してのみ定義さ
     れています。INSTRUCTION-SETは、`i386'と`i8086'のいずれかにセット
     することができます。デフォルトは`i386'です。




File: gdb-ja.info, Node: Data, Next: Languages, Prev: Source, Up: Top

データの検査
************

ユーザ・プログラムの中のデータを調べる通常の方法は、`print'コマンド
（省略形は`p'）、またはそれと同義のコマンドである`inspect'コマンドを使
用することです。これは、ユーザ・プログラムが記述された言語（*Note
Using GDB with Different Languages: Languages.）による式を評価し、その
値を出力するものです。

`print EXP'
`print /F EXP'
     EXPは（ソース言語による）式です。デフォルトでは、EXPの値は、EXPの
     データ型にとって適切な形式で表示されます。`/F'を指定することで、
     他の形式を選択することも可能です。`/F'のFは形式を指定する文字です。
     *Note Output formats: Output Formats.。

`print'
`print /F'
     EXPを省略すると、GDBは"値ヒストリ" （*Note Value history: Value
     History.）の最後の値を再表示します。これは、同じ値を異なる形式で
     調べるのに便利です。

データを調べるためのより低レベルの方法は、`x'コマンドを使うことです。
これは、指定されたアドレスのメモリ上のデータを、指定された形式で表示す
るものです。*Note Examining memory: Memory。

型に関する情報に関心があるとき、また、構造体やクラスのフィールドがどの
ように宣言されているかという点に関心があるときは、`print'コマンドでは
なく`ptype EXP'コマンドを使用してください。*Note Examining the Symbol
Table: Symbols。

* Menu:

* Expressions::                 式
* Variables::                   プログラム変数
* Arrays::                      人工配列
* Output Formats::              出力フォーマット
* Memory::                      メモリの調査
* Auto Display::                自動表示
* Print Settings::              表示設定
* Value History::               値ヒストリ
* Convenience Vars::            コンビニエンス変数
* Registers::                   レジスタ
* Floating Point Hardware::     浮動小数ハードウェア




File: gdb-ja.info, Node: Expressions, Next: Variables, Prev: Data, Up: Data

式
==

`print'コマンド、および、ほかの多くのGDBコマンドは、式を受け取って、そ
の値を評価します。ユーザの使用しているプログラミング言語によって定義さ
れている定数、変数、演算子は、いずれもGDBにおける式の中で有効です。こ
れには、条件式、関数呼び出し、キャスト、文字列定数が含まれます。しかし、
プリプロセッサの`#define'コマンドによって定義されるシンボルは、残念な
がら含まれません。

現在のGDBは、ユーザの入力する式において配列定数をサポートします。その
構文は、{ELEMENT, ELEMENT...}です。例えば、コマンド`print {1, 2, 3}'を
使用して、ターゲット・プログラム内で`malloc()'によって獲得されたメモリ
内に配列を作成することができます。

C言語は大変広汎に使用されているので、このマニュアルの中で示される例の
中の式はC言語で記述されています。他の言語での式の使い方に関する情報に
ついては、*Note Using GDB with Different Languages: Languages。

この節では、プログラミング言語によらずGDBの式で使用できる演算子を説明
します。

キャストは、C言語のみならず、すべての言語でサポートされています。これ
は、メモリ内のあるアドレスにある構造体を調べるのに、数値をポインタにキャ
ストするのが大変便利であるからです。

プログラミング言語によらず共通に使用可能な演算子に加えて、GDBは以下の
演算子をサポートしています。

`@'
     `@'は、メモリの一部を配列として処理するための2項演算子です。詳細
     については、*Note Artificial arrays: Arrays。

`::'
     `::'によって、それを定義している関数またはファイルを特定して、変
     数を指定することができます。*Note Program variables: Variables。

`{TYPE} ADDR'
     ADDRで示されるメモリ上のアドレスに格納されている、TYPEで示される
     型のオブジェクトを参照します。ADDRには、評価結果が整数値またはポ
     インタになるような任意の式を指定することができます（ただし、2項演
     算子の前後には、キャストを使う場合と同様の括弧が必要です）。これ
     は、ADDRの位置に通常存在するデータの型がいかなるものであろうとも、
     使用することができます。



File: gdb-ja.info, Node: Variables, Next: Arrays, Prev: Expressions, Up: Data

プログラム変数
==============

最も一般的に使用される式は、ユーザ・プログラム内部の変数名です。

式の中の変数は、選択されたスタック・フレーム（*Note Selecting a frame:
Selection.）内において解釈されます。これは、以下の2つのいずれかとなり
ます。

   * グローバル変数（または、ファイル・スコープの静的変数）

あるいは

   * プログラム言語のスコープ規則によって、そのフレームの実行中の箇所
     から可視の変数

つまり、以下の例において、ユーザ・プログラムが関数`foo'を実行中は、変
数`a'を調べたり使用したりすることができますが、変数`b'を使用したり調べ
たりすることができるのは、`b'が宣言されているブロックの内部をユーザ・
プログラムが実行中である場合に限られます。

     foo (a)
          int a;
     {
       bar (a);
       {
         int b = test ();
         bar (b);
       }
     }

ただし、これには1つ例外があります。特定の1ソース・ファイルをスコープと
する変数や関数は、たとえ現在の実行箇所がそのファイルの中ではなくても、
参照することができます。しかし、このような変数または関数が（異なるソー
ス・ファイル中に）同じ名前で複数個存在するということがありえます。この
ような場合、その名前を参照すると予期できない結果をもたらします。2つの
コロンを並べる記法によって、特定の関数またはファイルの中の静的変数を指
定することができます。

     FILE::VARIABLE
     FUNCTION::VARIABLE

ここでFILEまたはFUNCTIONは、静的変数VARIABLEのコンテキスト名です。ファ
イル名の場合は、引用符を使用することによって、GDBがファイル名を確実に1
つの単語として解釈するようにさせることができます。例えば、ファイル
`f2.c'の中で定義されたグローバル変数`x'の値を表示するには、

     (gdb) p 'f2.c'::x

のようにします。

このような`::'の用途が、これと非常によく似ているC++における`::'の用途
と衝突することは非常に稀です。GDBは、式の内部においてC++のスコープ解釈
演算子の使用もサポートしています。

     *注意:* ときどき、新しいスコープに入った直後やスコープから出る直
前に、関数内部の特定の箇所から見ると、ローカル変数の値が正しくないよう
に見えることがあります。マシン命令単位でステップ実行を行っているときに、
このような問題を経験することがあるかもしれません。これは、ほとんどのマ
シンでは、（ローカル変数定義を含む）スタック・フレームのセットアップに
複数の命令が必要となるからです。マシン命令単位でステップ実行を行う場合、
スタック・フレームが完全に構築されるまでの間は、変数の値が正しくないよ
うに見えることがあります。スコープから出るときには、スタック・フレーム
を破棄するのに、通常複数のマシン命令が必要とされます。それらの命令群の
中をステップ実行し始めた後には、ローカル変数の定義は既に存在しなくなっ
ているかもしれません。

このようなことは、コンパイラが重要な最適化を実施する場合にも、発生する
可能性があります。常に正確な値が見えることを確実にするためには、コンパ
イルの際に、すべての最適化を行わないようにします。



File: gdb-ja.info, Node: Arrays, Next: Output Formats, Prev: Variables, Up: Data

人工配列
========

メモリ内に連続的に配置されている同一型のオブジェクトを表示することが役
に立つことがよくあります。配列の一部や動的にサイズの決定される配列にア
クセスするのに、そこへのポインタしかプログラム内部に存在しないような場
合です。

これは、2項演算子`@'を使用して、連続したメモリ範囲を"人工配列"として参
照することで可能です。`@'の左側のオペランドは、参照したい配列の最初の
要素で、かつ、1個のオブジェクトでなければなりません。また、右側のオペ
ランドは、その配列の中の参照したい部分の長さでなければなりません。結果
は、その要素がすべて左側の引数と同型である配列の値です。第1の要素は左
側の引数そのものです。第2の要素は、第1の要素を保持するメモリ域の直後の
メモリ上から取られます。これ以降の要素も同様です。以下に例を示します。
プログラムが以下のようになっているとしましょう。

     int *array = (int *) malloc (len * sizeof (int));

以下を実行することで、`array'の内容を表示することができます。

     p *array@len

`@'の左側のオペランドは、メモリ上に実在するものでなければなりません。
このような方法で`@'によって作成された配列の値は、配列の添字付けの見地
からは他の配列と同様に振る舞い、式の中で使用された場合は強制的にポイン
タとして扱われます。人工配列は、一度表示された後、値ヒストリ（*Note
Value history: Value History.）を通して式の中に現れることがよくありま
す。

人工配列を作成するもう1つの方法は、キャストを使用することです。これに
よって、ある値を配列として解釈し直します。この値は、メモリ上に実在する
ものでなくてもかまいません。
     (gdb) p/x (short[2])0x12345678
     $1 = {0x1234, 0x5678}

ユーザの便宜を考慮して、（例えば、`(TYPE[])VALUE'のように）配列の長さ
が省略された場合その値を満たすサイズを（`sizeof(VALUE)/sizeof(TYPE)'の
ように）GDBが計算します。
     (gdb) p/x (short[])0x12345678
     $2 = {0x1234, 0x5678}

ときには、人工配列の機構では十分でないことがあります。かなり複雑なデー
タ構造では、関心のある要素が連続的に並んでいないことがあります。例えば、
配列の中のポインタの値に関心がある場合です。このような状況において役に
立つ回避策の1つに、関心のある値のうち最初のものを表示する式の中のカウ
ンタとしてコンビニエンス変数（*Note Convenience variables: Convenience
Vars.）を使用し、RETキーによってその式を繰り返し実行することです。例え
ば、構造体へのポインタの配列`dtab'があり、個々の構造体のフィールド`fv'
の値に関心があるとしましょう。以下に、この場合の例を示します。

     set $i = 0
     p dtab[$i++]->fv
     RET
     RET
     ...



