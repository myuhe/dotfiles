Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.





File: gdb-ja.info, Node: Output Formats, Next: Memory, Prev: Arrays, Up: Data

出力フォーマット
================

デフォルトでは、GDBはデータの型にしたがって値を表示します。ときには、
これが望ましくない場合もあります。例えば、数値を16進で表示したい場合や
ポインタを10進で表示したい場合があるでしょう。あるいは、メモリ内のある
特定のアドレスのデータを文字列や命令として表示させたい場合もあるでしょ
う。このようなことをするためには、値を表示するときに"出力フォーマット"
を指定します。

出力フォーマットの最も単純な使用方法は、既に評価済みの値の表示方法を指
定することです。これは、`print'コマンドの最初の引数をスラッシュとフォー
マット文字で開始することで行います。サポートされているフォーマット文字
は、以下のとおりです。

`x'
     値を整数値とみなし、16進で表示します。

`d'
     値を符号付き10進の整数値として表示します。

`u'
     値を符号なし10進の整数値として表示します。

`o'
     値を8進の整数値として表示します。

`t'
     値を2進の整数値として表示します。`t'はtwoを省略したものです。 (1)
     (*Note Output Formats-Footnotes::)

`a'
     値を、16進の絶対アドレス、および、そのアドレスより前にあるシンボ
     ルのうち最も近い位置にあるものからのオフセット・アドレスとして表
     示します。このフォーマットを使用することで、未知のアドレスがどこ
     に（どの関数の中に）あるのかを知ることができます。

          (gdb) p/a 0x54320
          $3 = 0x54320 <_initialize_vx+396>

`c'
     値を整数値とみなし、文字定数として表示します。

`f'
     値を浮動小数点数値とみなし、典型的な浮動小数点の構文で出力します。

例えば、プログラム・カウンタの値を16進数で表示する（*Note Registers::）
には、以下を実行してください。

     p/x $pc

スラッシュの前にはスペースが必要ではないことに注意してください。これは、
GDBのコマンド名にはスラッシュを含めることができないからです。

値ヒストリの最後の値を異なる形式で再表示するには、`print'コマンドに対
して式を指定せずにフォーマットだけを指定して実行します。例えば、`p/x'
を実行すると最後の値を16進で再表示します。


File: gdb-ja.info  Node: Output Formats-Footnotes, Up: Output Formats

(1) 原注：フォーマット文字`b'は使用できません。フォーマット
文字は`x'コマンドでも共通して使用されますが、`x'コマン
ドでは、`b'はbyteの省略形として使用されているためです。
*Note Examining memory: Memory。



File: gdb-ja.info, Node: Memory, Next: Auto Display, Prev: Output Formats, Up: Data

メモリの調査
============

コマンド`x' （examineのx）を使用することで、ユーザ・プログラム内のデー
タ型にかかわらず、メモリ上の値をいくつかの形式で調べることができます。

`x/NFU ADDR'
`x ADDR'
`x'
     メモリ上の値を調べるには`x'コマンドを使用してください。

N、F、Uはいずれも、どれだけのメモリをどのようにフォーマットして表示す
るかを指定するための、必須ではないパラメータです。ADDRは、メモリの表示
を開始するアドレスを指定する式です。NFUの部分にデフォルトを使用するの
であれば、スラッシュ`/'は必要ありません。いくつかのコマンドによって、
ADDRに対して便利なデフォルト値を指定することができます。

N（繰り返し回数）
     繰り返し回数は10進の整数値です。デフォルトは1です。これによって、
     （単位Uの）メモリをどれだけ表示するかを指定します。

F（表示フォーマット）
     表示フォーマットには、`print'コマンドによって使用されるフォーマッ
     ト、`s'（NULL文字で終了する文字列）、`i'（マシン命令）のいずれか
     を指定します。初期状態では、デフォルトは`x' （16進）です。デフォ
     ルトは、`x'コマンドまたは`print'コマンドを実行するたびに変更され
     ます。

U（メモリ・サイズの単位）
     単位の大きさは以下のいずれかになります。

     `b'
          バイト
     `h'
          ハーフ・ワード（2バイト）
     `w'
          ワード（4バイト）--これが初期状態のデフォルトです。
     `g'
          ジャイアント・ワード（8バイト）

     `x'コマンド実行時に単位の大きさを指定するたびに、その大きさが、次
     に`x'コマンドを実行する際のデフォルトになります（フォーマット`s'
     および`i'については、単位の大きさは無視されます。これらについては、
     通常、単位の大きさを指定しません）。

ADDR（表示を開始するアドレス）
     ADDRは、GDBにメモリの表示を開始させたいアドレスです。この式は、必
     ずしもポインタ値を持つ必要はありません（ポインタ値を持つことも可
     能です）。これは常に、メモリ内のある1バイトを指す整数値のアドレス
     として解釈されます。式に関する詳細については、*Note Expressions:
     Expressions。ADDRのデフォルトは通常、最後に調べられたアドレスの次
     のアドレスになります。しかし、ほかのコマンドによってもデフォルト
     のアドレスが設定されます。該当するコマンドは、`info breakpoints' 
     （デフォルトは、最後に表示されたブレイクポイントのアドレスに設定
     されます）、`info line' （デフォルトは、行の先頭アドレスに設定さ
     れます）、および`print'コマンド（メモリ内の値を表示するのに使用し
     た場合）です。

例えば、`x/3uh 0x54320'は、先頭アドレス`0x54320'から始めて、メモリ上の
3個のハーフ・ワード（`h'）の値を、符号なし10進整数値（`u'）としてフォー
マットして表示するよう求める要求です。また、`x/4xw $sp'は、スタック・
ポインタ（`$sp'については、*Note Registers::）の上位4ワード（`w'）のメ
モリの内容を16進（`x'）で表示します。

単位の大きさを示す文字と出力フォーマットを指定する文字とは異なるので、
単位の大きさとフォーマットのどちらが前にくるべきかを記憶しておく必要は
ありません。どちらを先に記述しても動作します。`4xw'という出力指定と
`4wx'という出力指定とは、全く同一の意味を持ちます（ただし、繰り返し回
数Nは最初に指定しなければなりません。`wx4'ではうまく動きません）。

単位の大きさUは、フォーマット`s'および`i'については無視されますが、繰
り返し回数Nを使用したいことがあるかもしれません。例えば、`3i'はオペラ
ンドも含めて3つのマシン命令を表示したいということを指定しています。
`disassemble'コマンドは、マシン命令を調べる別の方法を提供してくれます。
*Note Source and machine code: Machine Code。

`x'コマンドへの引数のデフォルトはすべて、`x'コマンドを使用してメモリ上
を連続的に参照するために最少の情報だけを指定すればよいように設計されて
います。例えば、`x/3i ADDR'によってマシン命令を調べた後、`x/7'とするだ
けで、続く7個のマシン命令を調べることができます。RETキーによって`x'コ
マンドを繰り返し実行する場合は、前回の繰り返し回数Nが再度使用されます。
その他の引数も、後続の`x'コマンド使用時のデフォルトになります。

`x'コマンドによって表示されるアドレスや内容は、値ヒストリに保存されま
せん。これらの数がしばしば膨大になり、邪魔になるからです。その代わりに
GDBは、これらの値をコンビニエンス変数`$_'および`$__'の値として、後続の
式の内部で使用できるようにします。`x'コマンドを実行後、最後に調べられ
たアドレスは、コンビニエンス変数`$_'の値として式の中で使用することがで
きます。また、GDBによって調べられたそのアドレスの内容は、コンビニエン
ス変数`$__'の値として使用可能です。

`x'コマンドに繰り返し回数が指定されている場合、保存されるのは、最後に
表示されたメモリ単位のアドレスとその内容です。これは、最後の出力行にい
くつかのメモリ単位が表示されている場合は、最後に表示されたアドレス値と
一致しません。



File: gdb-ja.info, Node: Auto Display, Next: Print Settings, Prev: Memory, Up: Data

自動表示
========

ある1つの式の値を（それがどのように変化するかを見るために）頻繁に表示
したい場合は、その式を"自動表示リスト"に加えて、ユーザ・プログラムが停
止するたびに、GDBがその値を表示するようにするとよいでしょう。リストに
加えられた個々の式には、それを識別するための番号が割り当てられます。あ
る式をリストから削除する際に、その番号を指定します。自動表示は、例えば
以下のように表示されます。

     2: foo = 38
     3: bar[5] = (struct hack *) 0x3804

ここでは、項目番号、式、および、その式の現在の値が表示されます。`x'コ
マンドや`print'コマンドによって手動で表示を要求する場合と同様、好みの
出力フォーマットを指定することができます。実は、`display'コマンドは、
ユーザのフォーマットの指定の詳細度によって、`print'コマンドと`x'コマン
ドのいずれを使用するかを決定しています。単位の大きさが指定された場合や、
`x'コマンドでしかサポートされていない2つのフォーマット（`i'と`s'）のい
ずれかが指定された場合には、`x'コマンドが使用されます。それ以外の場合
は、`print'コマンドが使用されます。

`display EXP'
     ユーザ・プログラムが停止するたびに表示される式のリストに、式EXPを
     追加します。*Note Expressions: Expressions。

     コマンドの実行後にRETキーを押しても、`display'コマンドは繰り返し
     実行されません。

`display/FMT EXP'
     FMTの部分に、大きさや繰り返し回数は指定せず、出力フォーマットだけ
     を指定した場合は、式EXPを自動表示リストに追加して、出力時のフォー
     マットが常に、指定されたフォーマットFMTになるよう調整します。
     *Note Output formats: Output Formats。

`display/FMT ADDR'
     FMTの部分に`i'、`s'を指定した場合、あるいは、単位の大きさ、単位の
     数を指定した場合は、ユーザ・プログラムが停止するたびに調べるメモ
     リ・アドレスとして式ADDRを追加します。ここで「調べる」というのは、
     実際には`x/FMT ADDR'を実行することを意味します。*Note Examining
     memory: Memory。

例えば、`display/i $pc'は、ユーザ・プログラムが停止するたびに、次に実
行されるマシン命令を見るのに便利です（`$pc'は、プログラム・カウンタを
指すのに一般に使用される名前です。*Note Registers::）。

`undisplay DNUMS...'
`delete display DNUMS...'
     表示すべき式のリストから、項目番号DNUMSに対応する要素を削除します。

     `undisplay'コマンドを実行後にRETキーを押しても、コマンドは再実行
     されません（仮に再実行されてしまうとすると、`No display number
     ...'というエラーになるだけです）。

`disable display DNUMS...'
     項目番号DNUMSの表示を不可にします。表示不可にされた表示項目は自動
     的には表示されませんが、削除されたわけではありません。後に、表示
     可能にすることができます。

`enable display DNUMS...'
     項目番号DNUMSの表示を可能にします。これにより、表示不可が指定され
     るまで、式の自動表示が再度有効になります。

`display'
     リスト上の式のカレントな値を表示します。これは、ユーザ・プログラ
     ムが停止したときに実行されるのと同一の処理です。

`info display'
     自動的に表示されるよう設定された式のリストを表示します。個々の式
     の項目番号は表示されますが、値は表示されません。このリストには、
     表示不可になっている式も含まれ、そのことが分かるようにマーク付け
     されています。また、表示されるリストには、その時点ではアクセスで
     きない自動変数を参照しているために、その時点では値を表示すること
     のできない式も含まれます。

表示される式がローカル変数への参照を含む場合、そのローカル変数がセット
アップされているコンテキストの範囲外では、その式は無意味です。このよう
な式は、その中の変数の1つでも定義されないコンテキストが実行開始される
と表示不可になります。例えば、引数`last_char'を取る関数の内部で
`display last_char'コマンドを実行すると、その関数の内部でユーザ・プロ
グラムが実行を停止し続ける間は、GDBはこの引数を表示します。ほかの箇所
（`last_char'という変数が存在しない箇所）で停止したときには、自動的に
表示不可となります。次にユーザ・プログラムが`last_char'が意味を持つ箇
所で停止したときには、再びその式の表示を可能にすることができます。



File: gdb-ja.info, Node: Print Settings, Next: Value History, Prev: Auto Display, Up: Data

表示設定
========

GDBは、配列、構造体、シンボルをどのように表示するかを制御するための方
法を提供しています。

これらの設定は、どのプログラミング言語で記述されたプログラムのデバッグ
にも便利です。

`set print address'
`set print address on'
     これによりGDBは、メモリ・アドレスの内容を表示する場合でも、スタッ
     ク・トレース、構造体の値、ポインタの値、ブレイクポイントなどの位
     置を示すアドレスを表示します。デフォルトは`on'です。例として、
     `set print address on'のときのスタック・フレームの表示結果を示し
     ます。

          (gdb) f
          #0  set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
              at input.c:530
          530         if (lquote != def_lquote)

`set print address off'
     アドレスの内容を表示するときには、そのアドレスを表示しません。例
     えば、`set print address off'のときに前の例と同一のスタック・フレー
     ムを表示すると、以下のようになります。

          (gdb) set print addr off
          (gdb) f
          #0  set_quotes (lq="<<", rq=">>") at input.c:530
          530         if (lquote != def_lquote)

     `set print address off'を使用することで、GDBのインターフェイスか
     らマシンに依存する表示を取り除くことができます。例えば、`print
     address off'を指定してあれば、ポインタ引数の有無にかかわらず、す
     べてのマシン上において同一のバックトレース情報を得るはずです。

`show print address'
     アドレスが表示されるか否かを示します。

GDBがシンボリックなアドレスを表示する際には通常、そのアドレスの前にあ
る最も近い位置のシンボルと、そのシンボルからのオフセットを表示します。
そのシンボルによってアドレスが一意に決まらない場合（例えば、単一のファ
イル内でのみ有効な名前である場合）には、確認の必要があるかもしれません。
1つの方法は、例えば`info line *0x4537'のように、`info line'コマンドを
実行することです。または、シンボリックなアドレスを表示するときに、一緒
にソース・ファイルや行番号を表示するようGDBを設定する方法もあります。

`set print symbol-filename on'
     シンボリックな形式のアドレスの表示において、そのシンボルのソース・
     ファイル名と行番号を表示するようGDBに通知します。

`set print symbol-filename off'
     シンボルのソース・ファイル名と行番号を表示しません。これがデフォ
     ルトです。

`show print symbol-filename'
     シンボリックな形式でのアドレス表示において、GDBがそのシンボルのソー
     ス・ファイル名と行番号を表示するか否かを示します。

シンボルのソース・ファイル名と行番号を表示するのが役に立つもう1つの状
況として、コードを逆アセンブルする場合があります。GDBが、個々の命令に
対応する行番号とソース・ファイルを表示してくれます。

また、アドレスをシンボリック形式で表示させるのは、そのアドレスと、その
アドレスより前にあるシンボルのうち、そのアドレスに最も近い位置にあるも
のとの間が適度に接近している場合に限定させたいこともあるもでしょう。

`set print max-symbolic-offset MAX-OFFSET'
     アドレスと、そのアドレスより前にある最も近いシンボルの間のオフセッ
     トがMAX-OFFSET未満のときのみ、そのアドレスをシンボリックな形式で
     表示するようGDBに通知します。デフォルトは0で、これはGDBに対して、
     アドレスより前にシンボルがある場合には、常にそのアドレスをシンボ
     リックな形式で表示するよう通知します。

`show print max-symbolic-offset'
     GDBがシンボリックなアドレスを表示する上限となる、最大のオフセット
     値を問い合わせます。

あるポインタがどこを指しているか定かではない場合には、`set print
symbol-filename on'を試みてください。こうすれば、`p/a POINTER'を使用し
て、そのポインタが指している変数の名前とソース・ファイル上の位置が分か
ります。これは、アドレスをシンボリック形式で解釈します。例えば以下の例
では、ある変数`ptt'がファイル`hi2.c'内で定義された別の変数`t'を指して
いることを、value{GDBN}が教えてくれています。

     (gdb) set print symbol-filename on
     (gdb) p/a ptt
     $4 = 0xe008 <t in hi2.c>

     *注意:* ローカル変数を指すポインタについては、たとえ適切な`set
     print'オプションが有効になっていても、`p/a'はそのポインタによって
     参照される変数のシンボル名やファイル名を表示しません。

異なる種類のオブジェクトについては、他の設定によって表示方法が制御され
ます。

`set print array'
`set print array on'
     配列をきれいに表示します。このフォーマットは読むのには便利ですが、
     より多くのスペースを取ります。デフォルトは`off'です。

`set print array off'
     配列を詰め込み形式で表示します。

`show print array'
     配列の表示方法として、詰め込み形式ときれいな形式のどちらが選択さ
     れているかを示します。

`set print elements NUMBER-OF-ELEMENTS'
     GDBによって表示される配列の要素の数に上限を設定します。GDBが大き
     な配列を表示している際に、表示された要素の数が`set print
     elements'コマンドで設定された数に達すると、そこで表示が停止されま
     す。この上限は、文字列の表示にも適用されます。NUMBER-OF-ELEMENTS
     に0をセットすると、要素は無制限に表示されます。

`show print elements'
     大きな配列を表示する際にGDBが表示する要素数を示します。0の場合、
     表示される要素数に制限はありません。

`set print null-stop'
     最初にNULLが検出された時点で、GDBに文字配列の表示を停止させます。
     これは、大きな配列が実際には短い文字列しか含んでいないときに役に
     立ちます。

`set print pretty on'
     構造体を表示する際に、インデントされた形式で1行に1メンバずつGDBに
     表示させます。以下に例を示します。

          $1 = {
            next = 0x0,
            flags = {
              sweet = 1,
              sour = 1
            },
            meat = 0x54 "Pork"
          }

`set print pretty off'
     構造体を詰め込み形式でGDBに表示させます。以下に例を示します。

          $1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
          meat = 0x54 "Pork"}

     これがデフォルトの形式です。

`show print pretty'
     GDBが、構造体を表示するのにどちらの形式を使用しているかを示します。

`set print sevenbit-strings on'
     7ビット文字だけを使用して表示します。このオプションがセットされて
     いると、GDBは（文字列内または単一文字内の）8ビット文字を`\'NNNと
     いう表記法で表示します。この設定は、英語（ASCII）環境において、文
     字の最上位ビットをマーカや「メタ」ビットとして使用する場合に最適
     です。

`set print sevenbit-strings off'
     8ビット文字を表示します。これにより文字セットの使用が国際的になり
     ます。これがデフォルトです。

`show print sevenbit-strings'
     GDBが7ビット文字だけを表示するか否かを示します。

`set print union on'
     GDBに対して、構造体の中に含まれている共用体を表示するよう通知しま
     す。これが、デフォルトの設定です。

`set print union off'
     GDBに対して、構造体の中に含まれている共用体を表示しないよう通知し
     ます。

`show print union'
     GDBに対して、構造体の中に含まれている共用体を表示するか否かを問い
     合わせます。

     例えば、以下のように宣言されている場合、

          typedef enum {Tree, Bug} Species;
          typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
          typedef enum {Caterpillar, Cocoon, Butterfly} 
                        Bug_forms;

          struct thing {
            Species it;
            union {
              Tree_forms tree;
              Bug_forms bug;
            } form;
          };

          struct thing foo = {Tree, {Acorn}};

     `set print union on'が有効な場合、`p foo'は以下のような表示を行い
     ます。

          $1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}

     また、`set print union off'が有効な場合、`p foo'は以下のような表
     示を行います。

          $1 = {it = Tree, form = {...}}

以下の設定は、C++プログラムをデバッグしているときに関係があります。

`set print demangle'
`set print demangle on'
     C++のシンボル名を、型セーフ（type-safe）なリンクのためにアセンブ
     ラ、リンカに渡されるエンコードされた（mangled）形式ではなく、ソー
     スに記述された形式で表示します。デフォルトは`on'です。

`show print demangle'
     C++のシンボル名が、エンコードされた（mangled）形式、ソース
     （demangled）形式のいずれの形式で表示されるかを示します。

`set print asm-demangle'
`set print asm-demangle on'
     C++のシンボル名を、命令の逆アセンブル時のようにアセンブラ・コード
     で表示しているときにも、エンコードされた（mangled）形式ではなく、
     ソース形式で表示します。デフォルトは`off'です。

`show print asm-demangle'
     アセンブラ・コードの表示において、C++シンボル名をエンコードされた
     （mangled）形式、ソース（demangled）形式のいずれの形式で表示する
     かを示します。

`set demangle-style STYLE'
     C++シンボル名を表現するために様々なコンパイラによって使用されるい
     くつかのエンコーディング方式の中から1つを選択します。現在STYLEと
     して選択可能であるのは、以下のとおりです。

     `auto'
          GDBがユーザ・プログラムを解析してデコーディング方式を決定することを許します。

     `gnu'
          GNU C++（`g++'）エンコーディング・アルゴリズムに基づいてデコー
          ドします。これが、デフォルトです。

     `hp'
          HP ANSI C++（`aCC'）エンコーディング・アルゴリズムに基づいて
          デコードします。

     `lucid'
          Lucid C++（`lcc'）エンコーディング・アルゴリズムに基づいてデ
          コードします。

     `arm'
          `C++ Annotated Reference Manual'に記述されているアルゴリズム
          を使用してデコードします。*注意:* この設定だけでは、`cfront'
          によって生成された実行モジュールをデバッグするのに十分ではあ
          りません。これを可能にするためには、GDBをさらに拡張する必要
          があります。

     STYLEを指定しないと、指定可能なフォーマットの一覧が表示されます。

`show demangle-style'
     C++シンボルをデコードするのに現在使用されているエンコーディング方
     式を示します。

`set print object'
`set print object on'
     オブジェクトへのポインタを表示する際に、仮想関数テーブルを使用し
     て、*宣言*された型ではなく、オブジェクトの*実際*の（派生された）
     型を表示します。

`set print object off'
     仮想関数テーブルは参照せず、オブジェクトの宣言された型だけを表示
     します。これがデフォルトの設定です。

`show print object'
     オブジェクトの実際の型と宣言された型のどちらが表示されるかを示し
     ます。

`set print static-members'
`set print static-members on'
     C++のオブジェクトを表示する際、静的メンバを表示します。デフォルト
     は`on'です。

`set print static-members off'
     C++のオブジェクトを表示する際、静的メンバを表示しません。

`show print static-members'
     C++の静的メンバが表示されるか否かを示します。

`set print vtbl'
`set print vtbl on'
     C++の仮想関数テーブルをきれいな形式で表示します。デフォルトは
     `off'です。

`set print vtbl off'
     C++の仮想関数テーブルをきれいな形式で表示しません。

`show print vtbl'
     C++の仮想関数テーブルをきれいな形式で表示するか否かを示します。



File: gdb-ja.info, Node: Value History, Next: Convenience Vars, Prev: Print Settings, Up: Data

値ヒストリ
==========

`print'コマンドにより表示された値は、GDBの"値ヒストリ"に保存されます。
これによりユーザは、これらの値をほかの式の中で参照することができます。
値は、シンボル・テーブルが（例えば、`file'コマンドや`symbol-file'コマ
ンドにより）再読み込みされるか破棄されるまで、維持されます。シンボル・
テーブルが変更されると、値ヒストリが破棄されるのは、その中の値が、シン
ボル・テーブル内で定義されている型を参照しているかもしれないからです。

表示される値は"ヒストリ番号"を与えられ、この番号によって参照することが
できます。この番号は1から始まる連続した整数です。`print'コマンドは、値
に割り当てられたヒストリ番号を、値の前に`$NUM = 'という形で表示します。
ここで、NUMがそのヒストリ番号です。

値ヒストリの中の任意の値を参照するには、`$'に続けてヒストリ番号を指定
します。`print'コマンドが出力に付加するラベルは、ユーザにこのことを知
らせるためのものです。`$'単体では、ヒストリ内の最も新しい値を参照し、
`$$'はその1つ前の値を参照します。`$$N'は、最新のものから数えてN番目の
値を参照します。`$$2'は`$$'の1つ前の値を参照し、`$$1'は`$$'と同一、
`$$0'は`$'と同一です。

例えば、ユーザがたった今、構造体へのポインタを表示し、今度はその構造体
の内容を見たいと考えているとしましょう。この場合は、

     p *$

を実行すれば十分です。

また、連結された構造体があり、そのメンバの`next'が次の構造体を指すポイ
ンタであるとすると、次の構造体の内容を表示するには、

     p *$.next

とします。

このように連結された構造体を次々に表示するには、このコマンドを繰り返し
実行すればよく、それはRETキーによって可能です。

このヒストリは、式ではなく、値を記録するという点に注意してください。
`x'の値が4のときに、以下のコマンドを実行すると、`print'コマンドによっ
て値ヒストリに記録される値は、`x'の値が変化したにもかかわらず4のままで
す。

     print x
     set x=5

`show values'
     値ヒストリ内の最新の10個の値を、項目番号付きで表示します。これは、
     `p $$9'を10回実行するようなものですが、両者の違いは、`show
     values'がヒストリを変更しないという点にあります。

`show values N'
     値ヒストリ内の項目番号Nを中心に、その前後の10個の値を表示します。

`show values +'
     値ヒストリ内の値のうち最後に表示されたものの直後にある10個の値を
     表示します。値が存在しない場合には、何も表示されません。

`show values N'を繰り返し実行するのにRETキーを押すことは、`show values
+'を実行するのと全く同じ結果をもたらします。



File: gdb-ja.info, Node: Convenience Vars, Next: Registers, Prev: Value History, Up: Data

コンビニエンス変数
==================

GDBの"コンビニエンス変数"は、GDBの中にある値を保持しておいて、それを後
に参照するという目的で使用することができます。これらの変数は、GDB内部
においてのみ存在するものです。それらはユーザ・プログラムの中に存在する
ものではなく、コンビニエンス変数を設定してもユーザ・プログラムの実行に
は直接影響を与えません。したがって、ユーザはこれを自由に使用することが
できます。

コンビニエンス変数名は、先頭が`$'で始まります。`$'で始まる名前は、あら
かじめ定義されたマシン固有のレジスタ名（*Note Registers::）と一致しな
い限り、コンビニエンス変数の名前として使用することができます（これに対
して、値ヒストリの参照名では`$'に続けて*番号*を記述します。*Note Value
history: Value History）。

ユーザ・プログラムの中で変数に値を設定するのと同じように、代入式を使用
してコンビニエンス変数に値を保存することができます。例えば、
`object_ptr'が指すオブジェクトが保持する値を`$foo'に保存するには、以下
のようにします。

     set $foo = *object_ptr

コンビニエンス変数は、最初に使用されたときに生成されますが、新しい値を
割り当てるまで、その値は空（`void'）です。値は、いつでも代入することに
よって変更可能です。

コンビニエンス変数には決まった型はありません。コンビニエンス変数には、
既に異なる型のデータが割り当てられている場合でも、構造体や配列を含めた
任意の型のデータを割り当てることができます。コンビニエンス変数は、式と
して使用される場合には、その時点における値の型を持ちます。

`show convenience'
     それまでに使用されたコンビニエンス変数とその値の一覧を表示します。
     省略形は、`show con'です。

コンビニエンス変数の1つの使い方に、インクリメントされるカウンタや先へ
進んでいくポインタとしての使い方があります。例えば、構造体配列の中の連
続する要素のあるフィールドの値を表示したい場合、以下のコマンドをRETキー
で繰り返し実行します。

     set $i = 0
     print bar[$i++]->contents

@noindent

GDBによって、いくつかのコンビニエンス変数が自動的に作成され、役に立ち
そうな値が設定されます。

`$_'
     `$_'変数には、`x'コマンドによって最後に調べられたアドレスが自動的
     に設定されます（*Note Examining memory: Memory.）。`x'コマンドに
     よって調べられるデフォルトのアドレスを提供する他のコマンドも、
     `$_'にそのアドレスを設定します。このようなコマンドには、`info
     line'や`info breakpoint'があります。`$_'の型は、`x'コマンドによっ
     て設定された場合は`$__'の型へのポインタであり、それ以外の場合は
     `void *'です。

`$__'
     `$__'変数には、`x'コマンドによって最後に調べられたアドレス位置に
     ある値が自動的に設定されます。型は、データが表示されたフォーマッ
     トに適合するように選択されます。

`$_exitcode'
     `$_exitcode'変数には、デバッグされているプログラムが終了した際の
     終了コードが自動的に設定されます。




File: gdb-ja.info, Node: Registers, Next: Floating Point Hardware, Prev: Convenience Vars, Up: Data

レジスタ
========

マシン・レジスタの内容は、先頭が`$'で始まる名前を持つ変数として、式の
中で参照することができます。レジスタの名前は、マシンによって異なります。
`info registers'コマンドを使用することで、そのマシンで使用されているレ
ジスタの名前を知ることができます。

`info registers'
     （選択されたスタック・フレームにおける）浮動小数点レジスタを除く
     すべてのレジスタの名前と値を表示します。

`info all-registers'
     浮動小数点レジスタも含めてすべてのレジスタの名前と値を表示します。

`info registers REGNAME ...'
     指定されたレジスタREGNAMEの相対化された値（"relativized" value）
     を表示します。以下に詳しく述べるように、レジスタの値は、通常は、
     選択されたスタック・フレームと関係を持つ相対的な値です。REGNAMEに
     は、ユーザの使用しているマシン上において有効な任意のレジスタの値
     が設定可能です。先頭の`$'は、あってもなくてもかまいません。

GDBは、そのマシン・アーキテクチャが持つレジスタの正規のニーモニックと
衝突しない限り、ほとんどのマシン上（の式の中）において利用可能な、4つ
の「標準的」なレジスタ名を持っています。レジスタ名`$pc'と`$sp'は、プロ
グラム・カウンタ・レジスタとスタック・ポインタを指すために使われます。
`$fp'は、カレントなスタック・フレームへのポインタを保持するレジスタを
指すために使われます。`$ps'は、プロセッサの状態を保持するレジスタを指
すために使われます。例えば、プログラム・カウンタの値を16進数で表示する
には、以下のように実行します。

     p/x $pc

また、次に実行される命令を表示するには、以下のように実行します。

     x/i $pc

さらに、スタック・ポインタ (1) (*Note Registers-Footnotes::) に4を加え
るには、以下のように実行します。

     set $sp += 4

可能な場合にはいつでも、これら4つの標準的なレジスタ名が使用可能です。
ユーザのマシンが異なる正規のニーモニックを使用している場合でも、名前の
衝突さえ起こらなければ、使用可能です。`info registers'コマンドにより、
正規名を見ることができます。例えば、SPARC上で`info registers'コマンド
を実行すると、プロセッサ・ステータス・レジスタは`$psr'と表示されますが、
このレジスタを`$ps'として参照することもできます。

レジスタがこの方法で調べられるとき、GDBは普通のレジスタの内容を常に整
数値とみなします。マシンによっては、浮動小数点値以外を保持できないレジ
スタを持つものがあります。このようなレジスタは、浮動小数点値を持つもの
とみなされます。普通のレジスタの内容を浮動小数点値として参照する方法は
ありません（`print/f $REGNAME'により、浮動小数点値として値を*表示する*
ことはできます）。

レジスタには、rawとvirtualの2つの異なるデータ形式を取るものがあります。
これは、オペレーティング・システムによってレジスタの内容が保存されると
きのデータ形式が、ユーザ・プログラムが通常認識しているものと同じではな
いことを意味しています。例えば、68881浮動小数点コプロセッサのレジスタ
の値は常にextended （raw）形式で保存されていますが、C言語によるプログ
ラムは通常double （virtual）形式を想定しています。このような場合、GDB
は通常（ユーザ・プログラムにとって意味のある形式である）virtual形式だ
けを扱いますが、`info registers'コマンドはデータを両方の形式で表示して
くれます。

通常、
レジスタの値は、
選択されたスタック・フレーム
（*Note Selecting a frame: Selection.）
と関係を持つ相対的な値です。
これは、
ユーザにレジスタの値として見えるものは、
選択されたフレームから呼び出されているすべてのスタック・フレームが終了し、
退避されたレジスタの値が復元されたときに、
そのレジスタが持つであろう値です。
ハードウェア・レジスタの本当の値を知りたければ、
最下位のフレームを
（`frame 0'で）
選択しなければなりません。

しかし、GDBは、コンパイラが生成したコードから、どこにレジスタが保存さ
れているかを推論する必要があります。退避されていないレジスタがある場合
や、GDBが退避されたレジスタを見つけることができない場合は、どのスタッ
ク・フレームを選択していても結果は同じです。

`set rstack_high_address ADDRESS'
     AMD 29000ファミリ・プロセッサでは、レジスタは「レジスタ・スタック」
     と呼ばれるところに退避されます。GDBには、このスタックの大きさを知
     ることはできません。通常GDBは、スタックは十分に大きいと想定します。
     このために、実際には存在しないメモリ位置を、GDBが参照してしまうこ
     とがありえます。必要であれば、`set rstack_high_address'コマンドに
     よってレジスタ・スタックの最終アドレスを指定することによって、こ
     の問題を回避することができます。引数はアドレスでなければなりませ
     ん。`0x'を先頭に記述することで、アドレスを16進数で指定することが
     できます。

`show rstack_high_address'
     AMD 29000ファミリ・プロセッサにおけるレジスタ・スタックのカレント
     な上限を表示します。



File: gdb-ja.info  Node: Registers-Footnotes, Up: Registers

(1) 原注：これは、スタックがメモリの下位方向に伸長するマシン（最近のほ
とんどのマシンがそうです）上において、スタックから1ワードを取り除く方
法です。これは、最下位のスタック・フレームが選択されていることを想定し
ています。これ以外のスタック・フレームが選択されているときには、
`$sp'に値を設定することは許されません。マシン・アーキテクチャに依
存することなくスタックからフレーム全体を取り除くには、`return'を
使用します。*Note Returning from a function: Returning。


File: gdb-ja.info, Node: Floating Point Hardware, Prev: Registers, Up: Data

浮動小数ハードウェア
====================

構成によっては、GDBは浮動小数ハードウェアの状態について、より詳しい情
報を提供することができます。

`info float'
     浮動小数ユニットに関するハードウェア依存の情報を表示します。浮動
     小数チップの種類によって、表示内容やレイアウトは変わります。現在、
     `info float'はARMマシンとx86マシンにおいてサポートされています。



File: gdb-ja.info, Node: Languages, Next: C, Prev: Data, Up: Top

異なる言語の使用
****************

異なるプログラミング言語であっても共通点があるのが普通ですが、その表記
法が全く同様であるということはめったにありません。例えば、ポインタ`p'
の指す値を取り出す方法は、ANSI Cでは`*p'ですが、Modula-2では`p^'です。
値の表現方法（および表示方法）もまた異なります。16進数は、Cでは`0x1ae'
のようになりますが、Modula-2では`1AEH'のようになります。

いくつかの言語については、言語固有の情報がGDBに組み込まれており、これ
により、プログラムを記述した言語を使って上記のような操作を記述したり、
プログラムを記述した言語の構文にしたがってGDBに値を出力させることがで
きます。式を記述するのに使用される言語を、"作業言語"と呼びます。

* Menu:

* Setting::                     ソース言語の切り替え
* Show::                        言語の表示
* Checks::                      型と範囲のチェック

* Support::                     サポートされる言語



File: gdb-ja.info, Node: Setting, Next: Show, Prev: Languages, Up: Languages

ソース言語の切り替え
====================

作業言語を制御する方法は2つあります。GDBに自動的に設定させる方法と、ユー
ザが手作業で選択する方法です。どちらの目的でも、`set language'コマンド
を使用することができます。起動時のデフォルトでは、GDBが言語を自動的に
設定するようになっています。作業言語は、ユーザの入力する式がどのように
解釈されるか、あるいは、値がどのように表示されるかを決定します。

この作業言語とは別に、GDBの認識しているすべてのソース・ファイルには、
それ自体の作業言語があります。オブジェクト・ファイルのフォーマットによっ
ては、ソース・ファイルの記述言語を示す情報を、コンパイラが書き込んでい
ることがあるかもしれません。しかし、ほとんどの場合、GDBはファイル名か
ら言語を推定します。ソース・ファイルの言語の種類が、C++シンボル名がデ
コード（demangle）されるか否かを制御します。これにより`backtrace'は、
個々のフレームを、その対応する言語にしたがって適切に表示することができ
ます。GDBの中から、ソース・ファイルの言語を設定することはできません。

他の言語で記述されたソースからCのソースを生成する、`cfront'や`f2c'のよ
うなプログラムをユーザが使用する場合には、このことが問題となるでしょう。
このような場合には、生成されるCの出力に`#line'指示子を使用するよう、そ
のプログラムを設定してください。こうすることによって、GDBは、元になっ
たプログラムのソース・コードが記述された言語を正しく知ることができ、生
成されたCのコードではなく、元になったソース・コードを表示します。

* Menu:

* Filenames::                   ファイル拡張子と言語
* Manually::                    手作業による作業言語の設定
* Automatically::               GDBによるソース言語の推定



File: gdb-ja.info, Node: Filenames, Next: Manually, Prev: Setting, Up: Setting

ファイル拡張子と言語のリスト
----------------------------

ソース・ファイル名が以下のいずれかの拡張子を持つ場合、GDBはその言語を
以下に示すものと推定します。


`.c'
     Cソース・ファイル

`.C'
`.cc'
`.cp'
`.cpp'
`.cxx'
`.c++'
     C++ソース・ファイル

`.f'
`.F'
     Fortranソース・ファイル

`.ch'
`.c186'
`.c286'
     CHILLソース・ファイル

`.mod'
     Modula-2ソース・ファイル

`.s'
`.S'
     アセンブラ言語のソース・ファイル。この場合、実際の動作はほとんどC
     言語と同様ですが、ステップ実行時に、関数呼び出しのための事前処理
     部をGDBはスキップしません。

さらに、言語に対してファイル名の拡張子を関連付けすることも可能です。
*Note Displaying the language: Show。



File: gdb-ja.info, Node: Manually, Next: Automatically, Prev: Filenames, Up: Setting

作業言語の設定
--------------

GDBに言語を自動的に設定させる場合、ユーザのデバッグ・セッションとユー
ザのプログラムにおいて、式は同様に解釈されます。

もしそうしたければ、言語を手作業で設定することもできます。そのためには、
コマンド`set language LANG'を実行します。ここで、LANGは、`c'や
`modula-2' のような言語名です。サポートされている言語のリストは、`set
language'で表示させることができます。

言語を手作業で設定すると、GDBは、作業言語を自動的に更新することができ
なくなります。このことは、作業言語がソースの言語と同一ではなく、かつ、
ある式がどちらの言語でも有効でありながら、その意味が異なるような状況で
プログラムをデバッグしようとしたときに、混乱をもたらす可能性があります。
例えば、カレントなソース・ファイルがC言語で記述されていて、GDBがそれを
Modula-2として解析している場合に、

     print a = b + c

のようなコマンドを実行すると、その結果は意図したものとは異なるものにな
るでしょう。これはC言語では、`b'と`c'とを加算して、その結果を`a'に入れ
るということを意味し、表示される結果は、`a'の値となります。Modula-2で
は、これは`a'と`b+c'の結果を比較して`BOOLEAN'型の値を出力することを意
味します。



File: gdb-ja.info, Node: Automatically, Prev: Manually, Up: Setting

GDBによるソース言語の推定
-------------------------

GDBに作業言語を自動的に設定させるには、`set language local'または`set
language auto'を使用します。この場合、GDBは作業言語を推定します。つま
り、ユーザ・プログラムが（通常はブレイクポイントに達することによって）
あるフレーム内部で停止したとき、GDBは、そのフレーム内の関数に対して記
録されている言語を作業言語として設定します。フレームの言語が不明の場合
（つまり、そのフレームに対応する関数またはブロックが、既知ではない拡張
子を持つソース・ファイルにおいて定義されている場合）、カレントな作業言
語は変更されず、GDBは警告メッセージを出力します。

このようなことは、全体がただ1つの言語で記述されているほとんどのプログ
ラムにおいては不要であると思われるでしょう。しかし、あるソース言語で記
述されたプログラム・モジュールやライブラリは、他のソース言語で記述され
たメイン・プログラムから使用することができます。このような場合に`set
language auto'を使用することで、作業言語を手作業で設定する必要がなくな
ります。



File: gdb-ja.info, Node: Show, Next: Show, Prev: Setting, Up: Languages

言語の表示
==========

以下のコマンドは、作業言語、および、ソース・ファイルの記述言語を知りた
いときに役に立ちます。

`show language'
     カレントな作業言語を表示します。`print'コマンドなどによってユーザ・
     プログラム内部の変数を含む式を作成したり評価したりするには、この
     コマンドによって示される言語を使用します。

`info frame'
     選択されているフレームのソース言語を表示します。このフレームの中
     の識別子を使用すると、この言語が作業言語になります。このコマンド
     により表示される他の情報について知りたい場合は、*Note Information
     about a frame: Frame Info。

`info source'
     選択されているソース・ファイルのソース言語を表示します。このコマ
     ンドにより表示される他の情報のことを知りたい場合は、*Note
     Examining the Symbol Table: Symbols。

普通ではない状況においては、標準のリストに含まれない拡張子を持つソース・
ファイルがあるかもしれません。この場合には、その拡張子を特定の言語に明
示的に関連付けすることができます。

`set extension-language .EXT LANGUAGE'
     拡張子.EXTを持つソース・ファイルは、ソース言語LANGUAGE によって記
     述されているものと想定するよう設定します。

`info extensions'
     すべてのファイル拡張子と、その拡張子に関連付けされた言語を一覧表
     示します。



File: gdb-ja.info, Node: Checks, Next: Support, Prev: Show, Up: Languages

型と範囲のチェック
==================

     *注意:* 現在のリリースでは、型チェックと範囲チェックを行うGDBコマ
     ンドは組み込まれていますが、それらは実際には何も実行しません。こ
     のセクションでは、これらのコマンドが本来持つべく意図されている機
     能について記述してあります。

いくつかの言語は、一連のコンパイル時チェック、実行時チェックによって、
一般によく見られるエラーの発生を防ぐように設計されています。これらの
チェックには、関数や演算子への引数の型のチェックや、数学的操作の結果の
オーバーフローを実行時に確実に検出することなどが含まれています。このよ
うなチェックは、型の不一致を排除したり、ユーザ・プログラムの実行時に範
囲エラーをチェックしたりすることによって、コンパイル後のプログラムの正
しさを確かなものにするのに役に立ちます。

GDBは、ユーザが望むのであれば、上記のような条件のチェックを行います。
GDBはユーザ・プログラムの文をチェックすることはしませんが、例えば、
`print'コマンドによる評価を目的としてGDBに直接入力された式をチェックす
ることはできます。作業言語の場合と同様に、GDBが自動的にチェックを行う
か否かを、ユーザ・プログラムのソース言語によって決定することもできます。
サポートされている言語のデフォルトの設定については、*Note Supported
languages: Support。

* Menu:

* Type Checking::               型チェックの概要
* Range Checking::              範囲チェックの概要



File: gdb-ja.info, Node: Type Checking, Next: Range Checking, Prev: Checks, Up: Checks

型チェックの概要
----------------

いくつかの言語、例えばModula-2などは、強く型付けされています。これは、
演算子や関数への引数は正しい型でなくてはならず、そうでない場合にはエラー
が発生するということを意味しています。このようなチェックは、型の不一致
のエラーが実行時に問題を発生させるのを防いでくれます。例えば、1+2は

     1 + 2 => 3
ですが、1+2.3は
     error--> 1 + 2.3

のようにエラーになります。

第2の例がエラーになるのは、`CARDINAL'型の1は`REAL'型の2.3と型の互換性
がないからです。

GDBコマンドの中で使われる式については、ユーザがGDBの型チェック機能に対
して、以下のような指示を出すことができます。

   * チェックを行わない
   * あらゆる不一致をエラーとして扱い、式を破棄する
   * 型の不一致が発生したときには警告メッセージを出力するだけで、式の
     評価を実行する

最後の指示が選択された場合、GDBは上記の第2の（エラー）例のような式でも
評価しますが、その際には警告メッセージを出力します。

型チェックをしないよう指示した場合でも、型に関係のある原因によってGDB
が式の評価ができなくなる場合がありえます。例えば、GDBは`int'の値と
`struct foo'の値を加算する方法を知りません。こうした特定の型エラーは、
使用されている言語に起因するものではなく、この例のように、そもそも評価
することが意味をなさないような式に起因するものです。

個々の言語は、それが型に関してどの程度厳密であるかを定義しています。例
えば、Modula-2とCはいずれも、算術演算子への引数としては数値を要求しま
す。Cでは、列挙型とポインタは数値として表わすことができますので、これ
らは算術演算子への正当な引数となります。特定の言語に関する詳細について
は、*Note Supported languages: Support。

GDBは、型チェック機能を制御するためのコマンドをさらにいくつか提供して
います。

`set check type auto'
     カレントな作業言語に応じて、型チェックを実行する、または、実行し
     ないよう設定します。個々の言語のデフォルトの設定については、*Note
     Supported languages: Support。

`set check type on'
`set check type off'
     カレントな作業言語のデフォルトの設定を無視して、型チェックを実行
     する、または、実行しないよう設定します。その設定が言語のデフォル
     トと一致しない場合は、警告メッセージが出力されます。型チェックを
     実行するよう設定されているときの式の評価において型の不一致が発生
     した場合には、GDBはメッセージを出力して式の評価を終了させます。

`set check type warn'
     型チェック機能に警告メッセージを出力させますが、式の評価自体は常
     に実行するよう試みさせます。式の評価は、他の原因のために不可能に
     なる場合もあります。例えば、GDBには数値と構造体の加算はできません。

`show type'
     型チェック機能のカレントな設定と、GDBがそれを自動的に設定している
     か否かを表示します。



File: gdb-ja.info, Node: Range Checking, Prev: Type Checking, Up: Checks

範囲チェックの概要
------------------

いくつかの言語（例えば、Modula-2）では、型の上限を超えるとエラーになり
ます。このチェックは、実行時に行われます。このような範囲チェックは、計
算結果がオーバーフローしたり、配列の要素へのアクセス時に使うインデック
スが配列の上限を超えたりすることがないことを確実にすることによって、プ
ログラムの正しさを確かなものにすることを意図したものです。

GDBコマンドの中で使う式については、範囲エラーの扱いを以下のいずれかに
するようGDBに指示することができます。

   * 範囲エラーを無視する
   * 範囲エラーを常にエラーとして扱い、式を破棄する
   * 警告メッセージを出力するだけで、式を評価する

範囲エラーは、数値がオーバフローした場合、配列インデックスの上限を超え
た場合、どの型のメンバでもない定数が入力された場合に発生します。しかし、
言語の中には、数値のオーバフローをエラーとして扱わないものもあります。
C言語の多くの実装では、数学的演算によるオーバフローは、結果の値を「一
巡」させて小さな値にします。例えば、Mが整数値の最大値、Sが整数値の最小
値とすると、

     M + 1 => S

になります。

これも個々の言語に固有な性質であり、場合によっては、個々のコンパイラや
マシンに固有な性質であることもあります。特定の言語に関する詳細について
は、*Note Supported languages: Support。

GDBは、範囲チェック機能を制御するためのコマンドをさらにいくつか提供し
ています。

`set check range auto'
     カレントな作業言語に応じて、範囲チェックを実行する、または、実行
     しないよう設定します。個々の言語のデフォルトの設定については、
     *Note Supported languages: Support。

`set check range on'
`set check range off'
     カレントな作業言語のデフォルトの設定を無視して、範囲チェックを実
     行する、または、実行しないよう設定します。設定が言語のデフォルト
     とは異なる場合は、警告メッセージが出力されます。範囲エラーが発生
     した場合は、メッセージが表示され、式の評価は終了させられます。

`set check range warn'
     GDBの範囲チェック機能が範囲エラーを検出した場合、メッセージを出力
     し、式の評価を試みます。例えば、プロセスが、自分の所有していない
     メモリをアクセスした場合（多くのUnixシステムで典型的に見られる例
     です）など、他の理由によって式の評価が不可能な場合があります。

`show range'
     範囲チェック機能のカレントな設定と、それがGDBによって自動的に設定
     されているのか否かを表示します。



File: gdb-ja.info, Node: Support, Next: Support, Prev: Checks, Up: Languages

サポートされる言語
==================

GDBは、C、C++、Fortran、Chill、アセンブリ言語、Modula-2をサポートして
います。いくつかのGDBの機能は、使用されている言語にかかわらず、式の中
で使用できます。GDBの`@'演算子、`::'演算子、および`{type}addr' （*Note
Expressions: Expressions.）は、サポートされている任意の言語において使
用することができます。

次節以降で、個々のソース言語がGDBによってどの程度までサポートされてい
るのかを詳しく説明します。これらの節は、言語についてのチュートリアルや
リファレンスとなることを意図したものではありません。むしろ、GDBの式解
析機能が受け付ける式や、異なる言語における正しい入出力フォーマットのリ
ファレンス・ガイドとしてのみ役に立つものです。個々の言語については良い
書籍が数多く出ています。言語についてのリファレンスやチュートリアルが必
要な場合は、これらの書籍を参照してください。

* Menu:

* C::                           C/C++
* Modula-2::                    Modula-2



File: gdb-ja.info, Node: C, Prev: Support, Up: Support

C/C++
-----

CとC++は密接に関連しているので、GDBの機能の多くは両方の言語に適用でき
ます。このようなものについては、2つの言語を一緒に議論します。


C++のデバッグ機能は、C++コンパイラとGDBによって協同で実装されています。
したがって、C++のコードを効率よくデバッグするには、GNU `g++'、HP ANSI
C++コンパイラ（`aCC'）などの、サポートされているC++コンパイラで、C++の
プログラムをコンパイルする必要があります。

GNU C++を使用する場合、最高の結果を引き出すには、stabsデバッグ・フォー
マットを使用してください。`g++'のコマンドライン・オプション`-gstabs'、
または、`-gstabs+'によって、このフォーマットを明示的に選択することがで
きます。詳細については、*Note Options for Debugging Your Program or
GNU CC: (gcc.info)Debugging Options の部分を参照してください。


* Menu:

* C Operators::                 C/C++演算子
* C Constants::                 C/C++定数
* Cplus expressions::           C++式
* C Defaults::                  C/C++のデフォルト設定
* C Checks::                    C/C++の型チェックと範囲チェック

* Debugging C::                 GDBとC
* Debugging C plus plus::       C++用のGDB機能



File: gdb-ja.info, Node: C Operators, Prev: C, Up: C

C/C++演算子
-----------

演算子は、特定の型の値に対して定義されなければなりません。例えば、`+'
は数値に対しては定義されていますが、構造体に対しては定義されていません。
演算子は、型のグループに対して定義されることがよくあります。

C/C++に対しては、以下の定義が有効です。

   * *整数型*には、任意の記憶クラス指定子を持つ`int'が含まれます。
     `char'、`enum'も整数型です。

   * *浮動小数点型*には、`float'と`double'が含まれます。

   * *ポインタ型*には、型TYPEに対して`(TYPE *)'により定義されるすべて
     の型が含まれます。

   * *スカラ型*には、上記のすべてが含まれます。

以下の演算子がサポートされています。これらは優先順位の低いものから順に
並べられています。

`,'
     カンマ、あるいは、順序付けの演算子です。カンマによって区切られた
     リストの中の式は、左から右の順で評価されます。最後に評価された式
     の結果が、式全体の評価結果になります。

`='
     代入。代入された値が、代入式の値になります。スカラ型に対して定義
     されています。

`OP='
     `A OP= B'という形式の式において使用され、
     `A = A OP B'に変換されます。
     `OP='と`='は、
     同一の優先順位を持ちます。
     OPには、
     `|'、
     `^'、
     `&'、
     `<<'、
     `>>'、
     `+'、
     `-'、
     `*'、
     `/'、
     `%'の各演算子が使用できます。

`?:'
     3項演算子です。`A ? B : C'は、Aが真であればB、偽であればCとみなす
     ことができます。Aは整数型でなければなりません。

`||'
     論理ORです。整数型に対して定義されています。

`&&'
     論理ANDです。整数型に対して定義されています。

`|'
     ビットごとのORです。整数型に対して定義されています。

`^'
     ビットごとの排他的ORです。整数型に対して定義されています。

`&'
     ビットごとのANDです。整数型に対して定義されています。

`==、!='
     等価、および、不等価です。スカラ型に対して定義されています。これ
     らの式の値は、偽のときはゼロであり、真のときはゼロ以外の値となり
     ます。

`<、>、<=、>='
     未満、超過、以下、以上です。スカラ型に対して定義されています。こ
     れらの式の値は、偽のときはゼロであり、真のときはゼロ以外の値とな
     ります。

`<<、>>'
     左シフト、右シフトです。整数型に対して定義されています。

`@'
     GDBの「人工配列」演算子です（*Note Expressions: Expressions.）。

`+、-'
     加算および減算です。整数型、浮動小数点型、ポインタ型に対して定義
     されています。

`*、/、%'
     乗算、除算、剰余です。乗算と除算は、整数型と浮動小数点型に対して
     定義されています。剰余は、整数型に対して定義されています。

`++, --'
     インクリメント、デクリメントです。変数の前にある場合は、式の中で
     その変数が使用される前に実行されます。変数の後ろにある場合は、変
     数の値が使用された後に実行されます。

`*'
     ポインタの間接参照です。ポインタ型に対して定義されています。`++'
     と同一の優先度を持ちます。

`&'
     アドレス参照演算子です。変数に対して定義されています。`++'と同一
     の優先順位を持ちます。

     C++のデバッグでは、C++言語そのものにおいては許されていないような
     `&'の使用法を、GDBは実装しています。C++の（`&REF'により宣言される）
     参照変数が格納されているアドレスを調べるのに、`&(&REF)' （あるい
     は、もしそうしたいのであれば単に`&&REF'）を使用することができます。

`-'
     マイナス（負）です。整数型と浮動小数点型に対して定義されています。
     `++'と同一の優先順位を持ちます。

`!'
     論理NOTです。整数型に対して定義されています。`++'と同一の優先順位
     を持ちます。

`~'
     ビットごとのNOT （補数）演算子です。整数型に対して定義されていま
     す。`++'と同一の優先順位を持ちます。

`., ->'
     構造体のメンバ、ポインタの指す構造体のメンバをそれぞれ指定する演
     算子です。便宜上、GDBは両者を同一のものとして扱い、格納されている
     型情報をもとに、ポインタによる間接参照の必要性を判断します。構造
     体（`struct'）および共用体（`union'）に対して定義されています。


`[]'
     配列のインデックスです。`A[I]'は、`*(A+I)'として定義されています。
     `->'と同一の優先順位を持ちます。

`()'
     関数のパラメータ・リストです。`->'と同一の優先順位を持ちます。

`::'
     C++のスコープ解決演算子です。構造体（`struct'）、共用体（`union'）、
     クラス（`class'）に対して定義されています。

`::'
     2重コロンはまた、GDBのスコープ演算子も表わします（*Note
     Expressions: Expressions.）。上記の`::'と同一の優先順位を持ちます。


* Menu:

* C Constants::             



File: gdb-ja.info, Node: C Constants, Next: C Constants, Prev: C Operators, Up: C Operators

C/C++定数
---------

GDBでは、以下のような方法によって、C/C++の定数を表わすことができます。

   * 整数型定数は、数字の連続したものです。8進数定数は、先頭の`0' （ゼ
     ロ）により指定されます。16進数定数は、先頭の`0x'または`0X'により
     指定されます。定数は、文字`l' （エル）により終わることもあります。
     この場合、定数が`long'型の値として扱われるべきことを意味します。

   * 浮動小数点型定数は、
     連続した数字、
     その後ろに小数点、
     さらにその後ろに数字という形式です。
     場合によっては、
     最後に指数部が付くこともあります。
     指数部は、
     `e[[+]|-]NNN'という形式を取ります。
     ここで、
     NNNは連続した数字です。
     `+'は、
     正の指数を示す記号で、
     必ずしも必要ではありません。

   * 列挙型定数は、列挙識別子、またはそれに対応する整数値より構成され
     ます。

   * 文字型定数は、単一引用符（`''）によって囲まれた単一の文字、あるい
     は、その文字に対応する序数（通常は、ASCII値）です。引用符の中の単
     一文字は、文字または"エスケープ・シーケンス"によって表わすことが
     できます。エスケープ・シーケンスには2つの表記方法があります。第1
     の形式は`\NNN'で、NNNはその文字の序数を表わす8進数です。第2の形式
     は`\X'で、`X'はあらかじめ定義された特別な文字です。例えば、`\n'は
     改行を表わします。

   * 文字列型定数は、連続した文字定数が2重引用符（`"'）で囲まれたもの
     です。

   * ポインタ型定数は、整数値です。定数へのポインタを、Cの`&'演算子を
     使用して記述することができます。

   * 配列定数は、括弧`{'と`}'で囲まれ、カンマで区切られたリストです。
     例えば、`{1,2,3}'は3つの整数値を要素として持つ配列です。`{{1,2},
     {3,4}, {5,6}}'は、3×2の配列です。また、`{&"hi", &"there",
     &"fred"}'は3つのポインタを要素として持つ配列です。

* Menu:

* Cplus expressions::           
* C Defaults::                  
* C Checks::                    

* Debugging C::                 



File: gdb-ja.info, Node: Cplus expressions, Next: Cplus expressions, Prev: C Constants, Up: C Constants

C++式
-----

GDBが持っている、式を処理する機能は、C++のほとんどの式を解釈することが
できます。

     *注意:* GDBは、適切なコンパイラが使用されている場合のみ、C++のコー
     ドをデバッグすることができます。典型的な例を挙げると、C++のデバッ
     グでは、シンボル・テーブルの中の追加的なデバッグ情報に依存するた
     め、特別なサポートが必要になるということがあります。使用されるコ
     ンパイラが、a.out、MIPS ECOFF、RS/6000 XCOFF、ELFを、シンボル・テー
     ブルに対するstabs拡張付きで生成することができるのであれば、以下に
     列挙する機能を使用することができます（GNU CCの場合は、`-gstabs'オ
     プションを使用して明示的にstabsデバッグ拡張を要求することができま
     す）。一方、オブジェクト・コードのフォーマットが、標準COFFやELFの
     DWARFである場合には、GDBの提供するほとんどのC++サポートは機能*し
     ません*。


  1. メンバ関数の呼び出しが許されます。以下のような式を使用することが
     できます。

          count = aml->GetOriginal(x, y)

  2. メンバ関数が（選択されたスタック・フレームの中で）アクティブな場
     合、入力された式は、そのメンバ関数と同一の名前空間を利用すること
     ができます。すなわち、GDBは、C++と同様の規則にしたがって、クラス・
     インスタンスへのポインタ`this'への暗黙の参照を許します。

  3. オーバーロードされた関数を呼び出すことができます。GDBは、正しい定
     義の関数呼び出しを決定します。ただし、制限が一点あります。実際に
     呼び出したい関数が要求する型の引数を使用しなければなりません。GDB
     は、コンストラクタやユーザ定義の型演算子を必要とするような変換を
     実行しません。


  4. GDBは、C++の参照変数として宣言された変数を理解します。C++のソース・
     コードで参照変数を使用するのと同一の方法で、参照変数を式の中で使
     用することができます。参照変数は自動的に間接参照されます。

     GDBがフレームを表示する際に表示されるパラメータ一覧の中では、参照
     変数の値は（他の変数とは異なり）表示されません。これにより、表示
     が雑然となることを回避できます。というのは、参照変数は大きい構造
     体に対して使用されることが多いからです。参照変数の*アドレス*は、
     `set print address off'を指定しない限り、常に表示されます。

  5. GDBはC++の名前解決演算子`::'をサポートしています。プログラム中と
     同様に、式の中でこれを使用することができます。あるスコープが別の
     スコープの中で定義されることがありえるため、必要であれば`::'を繰
     り返し使用することができます。例えば、`SCOPE1::SCOPE2::NAME'とい
     う具合です。GDBはまた、CおよびC++のデバッグにおいて、ソース・ファ
     イルを指定することで名前のスコープを解決することを許します（*Note
     Program variables: Variables.）。




File: gdb-ja.info, Node: C Defaults, Next: C Defaults, Prev: Cplus expressions, Up: C Constants

C/C++のデフォルト
-----------------

GDBが自動的に型チェックや範囲チェックの設定を行うことを許すと、作業言
語がCやC++に変更されるときにはいつも、それらの設定はデフォルトで`off'
になります。これは、作業言語を選択したのがユーザであってもGDBであって
も同様です。

GDBが自動的に言語の設定を行うことを許すと、GDBは、名前が`.c'、`.C'、
`.cc'などで終わるソース・ファイルを認識していて、これらのファイルから
コンパイルされたコードの実行を開始するときに、作業言語をCまたはC++に設
定します。詳細については、*Note Having GDB infer the source language:
Automatically。



File: gdb-ja.info, Node: C Checks, Next: Debugging C, Prev: C Defaults, Up: C Constants

C/C++の型チェックと範囲チェック
-------------------------------

デフォルトでは、GDBがCやC++の式を解析するときには、型チェックは行われ
ません。しかし、ユーザが型チェックを有効にすると、GDBは以下の条件が成
立するときに、2つの変数の型が一致しているとみなします。

   * 2つの変数が構造を持ち、同一の構造体タグ、共用体タグ、または列挙型
     タグを持つ。

   * 2つの変数が同一の型名を持つ、あるいは、`typedef'によって同一の型
     に宣言されている型を持つ。


範囲チェックは、onに設定されている場合、数学的演算において実行されます。
配列のインデックスは、それ自体は配列ではないポインタのインデックスとし
て使用されることが多いため、チェックされません。



File: gdb-ja.info, Node: Debugging C, Next: Debugging C, Prev: C Checks, Up: C Constants

GDBとC
------

`set print union'コマンドと`show print union'コマンドは共用体型
（`union'）に適用されます。`on'に設定されると、構造体（`struct'）やク
ラス（`class'）の内部にある共用体（`union'）はすべて表示されます。`on'
でない場合、それは`{...}'と表示されます。

`@'オペレータは、ポインタとメモリ割り当て関数によって作られた動的配列
のデバッグに役に立ちます。*Note Expressions: Expressions。

* Menu:

* Debugging C plus plus::       



File: gdb-ja.info, Node: Debugging C plus plus, Next: Debugging C plus plus, Prev: Debugging C, Up: Debugging C

C++用のGDB機能
--------------

GDBのコマンドの中には、C++を使用しているときに特に役に立つものがあり、
また、C++専用に特に設計されたものがあります。以下に、その要約を示しま
す。

`breakpoint menus'
     名前がオーバーロードされている関数の内部にブレイクポイントを設定
     したい場合、関心のある関数定義を指定するのに、GDBのブレイクポイン
     ト・メニューが役に立ちます。*Note Breakpoint menus: Breakpoint
     Menus。

`rbreak REGEX'
     あるオーバーロードされたメンバ関数が、特別なクラスだけが持つメン
     バ関数というわけではない場合、そのメンバ関数にブレイクポイントを
     設定するのに、正規表現によるブレイクポイントの設定が役に立ちます。
     *Note Setting breakpoints: Set Breaks。

`catch throw'
`catch catch'
     C++の例外処理をデバッグするのに使用します。*Note Setting
     catchpoints: Set Catchpoints。

`ptype TYPENAME'
     型TYPENAMEに関して、継承関係などの情報を表示します。*Note
     Examining the Symbol Table: Symbols。

`set print demangle'
`show print demangle'
`set print asm-demangle'
`show print asm-demangle'
     コードをC++のソースとして表示する場合と、逆アセンブル処理の結果を
     表示する場合に、C++のシンボルをソース形式で表示するか否かを制御し
     ます。*Note Print settings: Print Settings。

`set print object'
`show print object'
     オブジェクトの型を表示する際に、派生した（実際の）型と宣言された
     型のどちらを表示するかを選択します。*Note Print settings: Print
     Settings。

`set print vtbl'
`show print vtbl'
     仮想関数テーブルの表示形式を制御します。*Note Print settings:
     Print Settings。

`オーバーロードされたシンボル名'
     オーバーロードされたシンボルを宣言するのにC++において使用されるの
     と同一の表記法を使用して、オーバーロードされたシンボル定義のうち、
     特定のものを指定することができます。単にSYMBOLと入力するのではな
     く、`SYMBOL(TYPES)'と入力してください。GDBコマンドラインの単語補
     完機能を使用して、利用可能な選択肢を一覧表示させたり、型のリスト
     を完結させたりすることができます。この機能の使用方法の詳細につい
     ては、*Note Command completion: Completion。



File: gdb-ja.info, Node: Modula-2, Prev: Debugging C, Up: Debugging C

Modula-2
--------

Modula-2をサポートするために開発されたGDBの拡張機能は、（現在開発中の）
GNU Modula-2コンパイラによって生成されたコードだけをサポートします。他
のModula-2コンパイラは現在サポートされていません。他のModula-2コンパイ
ラが生成した実行形式モジュールをデバッグしようとすると、おそらく、GDB
が実行モジュールのシンボル・テーブルを読み込もうとしたところでエラーに
なるでしょう。

* Menu:

* M2 Operators::                組み込み演算子
* Built-In Func/Proc::          組み込み関数と組み込みプロシージャ
* M2 Constants::                Modula-2定数
* M2 Defaults::                 Modula-2デフォルト設定
* Deviations::                  標準Modula-2との差異
* M2 Checks::                   Modula-2の型チェックと範囲チェック
* M2 Scope::                    スコープ演算子`::'と`.'
* GDB/M2::                      GDBとModula-2



File: gdb-ja.info, Node: M2 Operators, Next: Built-In Func/Proc, Prev: Modula-2, Up: Modula-2

Modula-2演算子
..............

演算子は、特定の型の値に対して定義されなければなりません。例えば、`+'
は数値に対して定義され、構造体に対しては定義されません。演算子は、型の
グループに対して定義されることがよくあります。Modula-2においては、以下
の定義が有効です。


   * *整数型*は、`INTEGER'、`CARDINAL'、およびそのサブ範囲（subrange）
     から成ります。

   * *文字型*は、`CHAR'とそのサブ範囲から成ります。

   * *浮動小数点型*は、`REAL'から成ります。

   * *ポインタ型*は、`POINTER TO TYPE' のように宣言された任意の型から
     成ります。

   * *スカラ型*は、上記のすべての型から成ります。

   * *集合型*は、`SET'、`BITSET'から成ります。

   * *ブール型*は、`BOOLEAN'から成ります。

以下の演算子がサポートされています。ここでは、優先順位の低いものから順
に並べています。

`,'
     関数の引数の区切り記号、または、配列のインデックスの区切り記号で
     す。

`:='
     代入です。VAR `:=' VALUEの値はVALUEです。

`<、>'
     未満、超過です。整数型、浮動小数点型、列挙型に対して定義されてい
     ます。

`<=、>='
     整数型、浮動小数点型、列挙型に対しては、以下、以上を表わします。
     集合型に対しては、集合の包含関係を表わします。`<'と同一の優先順位
     を持ちます。

`=、<>、#'
     スカラ型に対して定義されている等価および2種類の不等価です。`<'と
     同一の優先順位を持ちます。GDBスクリプトの中では、`#'がスクリプト
     のコメント記号でもあるため、不等価としては`<>'だけが使用可能です。

`IN'
     集合のメンバを表わします。集合型、およびそのメンバの型に対して定
     義されています。`<'と同一の優先順位を持ちます。

`OR'
     ブール型のOR （disjunction）です。ブール型に対して定義されていま
     す。

`AND、&'
     ブール型のAND （conjunction）です。ブール型に対して定義されていま
     す。

`@'
     GDBの「人工配列」演算子です（*Note Expressions: Expressions.）。

`+、-'
     整数型、浮動小数点型に対しては、加算、減算を表わします。集合型に
     対しては、和集合（union）、差集合（difference）を表わします。

`*'
     整数型、浮動小数点型に対しては、乗算を表わします。集合型に対して
     は、積集合（intersection）を表わします。

`/'
     浮動小数点型に対しては、除算を表わします。集合型に対しては、対称
     的差集合（symmetric difference）を表わします。`*'と同一の優先順位
     を持ちます。

`DIV、MOD'
     整数型の除算における商と剰余を表わします。整数型に対して定義され
     ています。`*'と同一の優先順位を持ちます。

`-'
     マイナス（負）です。`INTEGER'、`REAL'型のデータに対して定義されて
     います。

`^'
     ポインタの間接参照です。ポインタ型に対して定義されています。

`NOT'
     ブール型のNOTです。ブール型に対して定義されています。`^'と同一の
     優先順位を持ちます。

`.'
     `RECORD'フィールドの区切り記号です。`RECORD'データに対して定義さ
     れます。`^'と同一の優先順位を持ちます。

`[]'
     配列のインデックスを指定します。`ARRAY'型のデータに対して定義され
     ています。`^'と同一の優先順位を持ちます。

`()'
     プロシージャの引数リストを指定します。`PROCEDURE'オブジェクトに対
     して定義されています。`^'と同一の優先順位を持ちます。

`::、.'
     GDBおよびModula-2のスコープ指定演算子です。

     *注意:* 集合、および集合に対する操作は、まだサポートされていませ
     ん。このため、GDBは`IN'演算子、あるいは、集合に対して`+'、`-'、
     `*'、`/'、`='、`<>'、`#'、`<='、`>='のいずれかの演算子が使用され
     た場合、これをエラーとして扱います。



File: gdb-ja.info, Node: Built-In Func/Proc, Next: M2 Constants, Prev: M2 Operators, Up: Modula-2

組み込み関数と組み込みプロシージャ
..................................

Modula-2では、いくつかの組み込みプロシージャ、組み込み関数が使用できま
す。これらの説明にあたり、以下のメタ変数を使用します。


A
     `ARRAY'型の変数を表わします。

C
     `CHAR'型の定数、または変数を表わします。

I
     整数型の変数、または定数を表わします。

M
     集合に属する識別子を表わします。通常、同一関数の中でメタ変数Sとと
     もに使用されます。Sの型は、`SET OF MTYPE'でなければなりません（こ
     こでのMTYPEはMの型です）。

N
     整数型または浮動小数点型の、変数または定数を表わします。

R
     浮動小数点型の変数または定数を表わします。

T
     型を表わします。

V
     変数を表わします。

X
     多くの型の中の1つの型の、変数または定数を表わします。詳細について
     は、関数の説明の部分を参照してください。

また、すべてのModula-2の組み込みプロシージャは、以下に説明する値を返し
ます。

`ABS(N)'
     値Nの絶対値を返します。

`CAP(C)'
     Cが小文字であれば、それを大文字にして返します。Cが小文字でなけれ
     ば、Cをそのまま返します。

`CHR(I)'
     序数がIである文字を返します。

`DEC(V)'
     変数Vの値から1を引きます。新しい値を返します。

`DEC(V,I)'
     変数Vの値からIで示される値を引きます。新しい値を返します。

`EXCL(M,S)'
     集合Sから要素Mを取り除きます。新しい集合を返します。

`FLOAT(I)'
     整数値Iに等しい浮動小数点値を返します。

`HIGH(A)'
     配列Aの最後の要素のインデックスを返します。

`INC(V)'
     変数Vの値に1を加えます。新しい値を返します。

`INC(V,I)'
     変数Vの値にIで示される値を加えます。新しい値を返します。

`INCL(M,S)'
     集合Sに要素Mが存在しない場合、要素Mを追加します。新しい集合を返し
     ます。

`MAX(T)'
     型Tの最大値を返します。

`MIN(T)'
     型Tの最小値を返します。

`ODD(I)'
     Iが奇数であればブール型の`TRUE'を返します。

`ORD(X)'
     引数の序数値を返します。例えば、文字の序数値は、（ASCII文字セット
     をサポートするマシン上では）そのASCII値です。ここでXは、整数型、
     文字型、列挙型のような順序を持つ型でなければなりません。

`SIZE(X)'
     引数のサイズを返します。Xは変数または型のいずれかです。

`TRUNC(R)'
     Rの整数部を返します。

`VAL(T,I)'
     型Tのメンバのうち、その序数値がIであるものを返します。

     *注意:* 集合、および集合に対する操作はまだサポートされていません。
     したがって、`INCL'プロシージャ、`EXCL'プロシージャを使用すると、
     GDBはエラーとして扱います。



File: gdb-ja.info, Node: M2 Constants, Next: M2 Defaults, Prev: Built-In Func/Proc, Up: Modula-2

定数
....

GDBでは、Modula-2の定数を以下のような方法で表現することができます。


   * 整数型の定数は、単に数字が連続したものです。式の中で使用された場
     合、定数は、式の他の部分と互換性のある型を持つものとみなされます。
     16進数の整数は末尾に`H'を付加することで、また、8進数の整数は末尾
     に`B'を付加することで指定されます。

   * 浮動小数点型の定数は、連続した数字、その後ろに小数点、さらにその
     後ろに連続した数字が続くものです。場合によっては、この後ろに指数
     部を指定することができます。指数部の形式は`E[+|-]NNN'で、
     `[+|-]NNN'の部分で希望する指数を指定します。浮動小数点型定数のす
     べての数字は、有効な10進数値でなければなりません。

   * 文字型定数は、単一引用符（`''）または2重引用符（`"'）で囲まれた単
     一文字より成ります。文字型定数は、その文字の序数値（通常はASCII値）
     の後ろに`C'を付加することで表現することもできます。

   * 文字列型定数は、単一引用符（`''）または2重引用符（`"'）で囲まれた
     連続する文字から成ります。C言語のスタイルでのエスケープ・シーケン
     スも使用できます。エスケープ・シーケンスに関する簡単な説明につい
     ては、*Note C and C++ constants: C Constants。

   * 列挙型定数は、列挙識別子から成ります。

   * ブール型定数は、識別子`TRUE'および`FALSE'から成ります。

   * ポインタ型定数は、整数値だけから成ります。

   * 集合型定数は、まだサポートされていません。



File: gdb-ja.info, Node: M2 Defaults, Next: Deviations, Prev: M2 Constants, Up: Modula-2

Modula-2デフォルト
..................

型チェックと範囲チェックがGDBにより自動的に設定される場合、作業言語が
Modula-2に変わるたびに、それらはデフォルトで`on'に設定されます。これは、
作業言語を選択したのがユーザであろうとGDBであろうと同様です。

GDBに自動的に言語を設定させると、ファイル名の末尾が`.mod'であるファイ
ルからコンパイルされたコードに入るたびに、作業言語はModula-2に設定され
ます。詳細については、*Note Having GDB set the language automatically:
Automatically。



File: gdb-ja.info, Node: Deviations, Next: M2 Checks, Prev: M2 Defaults, Up: Modula-2

標準Modula-2との差異
....................

Modula-2プログラムのデバッグを容易にするために2、3の修正が施されていま
す。これは主に、型に対する厳密性を緩めることによって実現されています。

   * 標準Modula-2とは異なり、ポインタ型定数は整数値から作成することが
     できます。これにより、デバッグ中にポインタ変数の値を変更すること
     ができるようになります（標準Modula-2では、ポインタ変数に格納され
     ている実際のアドレスを知ることはできません。ポインタ変数内のアド
     レスは、他のポインタ変数、または、ポインタを返す式を直接的に代入
     することによってのみ修正することができます）。

   * 表示不可の文字を表わすのに、C言語のエスケープ・シーケンスを文字列
     や文字において使用することができます。GDBはこれらのエスケープ・シー
     ケンスを埋め込んだまま文字列を表示します。表示不可の単一文字は、
     `CHR(NNN)'という形式で表示されます。

   * 代入演算子（`:='）は、右側の引数の値を返します。

   * すべての組み込みプロシージャは、引数を修正し、*さらに*それを返し
     ます。



File: gdb-ja.info, Node: M2 Checks, Next: M2 Scope, Prev: Deviations, Up: Modula-2

Modula-2の型チェックと範囲チェック
..................................

     *注意:* GDBは現在のところ、型チェック、範囲チェックをまだ実装して
     いません。

GDBは、以下のいずれかの条件が成立するとき、2つのModula-2変数の型が等し
いとみなします。

   * 2つの型が、`TYPE T1 = T2'文によって等しいと宣言されている型である。

   * 2つの型が同一行において宣言されている（注：これはGNU Modula-2コン
     パイラにおいては正しいのですが、他のコンパイラにおいては正しくな
     い可能性があります）。

型チェックが有効である限り、等しくない型の変数を組み合わせようとする試
みはすべてエラーとなります。

範囲チェックは、数学的操作、代入、配列のインデックス境界、およびすべて
の組み込み関数、組み込みプロシージャにおいて実行されます。



File: gdb-ja.info, Node: M2 Scope, Next: GDB/M2, Prev: M2 Checks, Up: Modula-2

スコープ演算子`::'と`.'
.......................

Modula-2のスコープ演算子（`.'）とGDBのスコープ演算子（`::'）との間には
2、3の微妙な相違点があります。この2つは似た構文を持っています。


     MODULE . ID
     SCOPE :: ID

ここで、SCOPEはモジュール名またはプロシージャ名、MODULEはモジュール名、
IDはユーザ・プログラムの中で宣言された任意の（異なるモジュール以外の）
識別子です。

`::'演算子を使用すると、GDBはSCOPEによって指定されたスコープにおいて識
別子IDを探します。指定されたスコープにおいてそれを見つけることができな
いと、GDBはSCOPEによって指定されたスコープを包含するすべてのスコープを
探します。

`.'演算子を使用すると、GDBはカレントなスコープにおいて、MODUEによって
指定された定義モジュールから取り込まれた、IDによって指定される識別子を
探します。この演算子では、識別子IDが定義モジュールMODULEから取り込まれ
ていない場合やMODULEにおいてIDが識別子でない場合は、エラーになります。



File: gdb-ja.info, Node: GDB/M2, Prev: M2 Scope, Up: Modula-2

GDBとModula-2
.............

GDBコマンドの中には、Modula-2プログラムのデバッグにはほとんど役に立た
ないものがいくつかあります。`set print'、`show print'の5つのサブ・コマ
ンド`vtbl'、`demangle'、`asm-demangle'、`object'、`union'はC/C++にのみ
適用されます。最初の4つはC++に適用され、最後の1つはCの共用体（`union'）
に適用されます。これらは、Modula-2において直接類似するものが存在しませ
ん。

`@'演算子（*Note Expressions: Expressions.）は、どの言語においても使用
することができますが、Modula-2においてはあまり役に立ちません。この演算
子は、"動的配列"のデバッグを支援することを目的とするものですが、C/C++
では作成できる動的配列は、Modula-2では作成できません。しかし、整数値定
数によってアドレスを指定することができるので、`{TYPE}ADREXP'は役に立ち
ます（*Note Expressions: Expressions.）。

GDBスクリプトの中では、Modula-2の不等価演算子`#'はコメントの開始記号と
して解釈されます。代わりに`<>'を使用してください。



File: gdb-ja.info, Node: Symbols, Next: Altering, Prev: C, Up: Top

シンボル・テーブルの検査
************************

ここで説明するコマンドによって、ユーザ・プログラムの中で定義されている
シンボル情報（変数名、関数名、型名）に関する問い合わせを行うことができ
ます。この情報はユーザ・プログラムのテキストに固有のもので、プログラム
の実行時に変わるものではありません。GDBはこの情報を、ユーザ・プログラ
ムのシンボル・テーブルの中、または、GDB起動時に指定されたファイル
（*Note Choosing files: File Options.）の中で見つけるか、ファイル管理
コマンド（*Note Commands to specify files: Files.）の実行によって見つ
けます。

ときには、参照する必要のあるシンボルの中に、GDBが通常は単語の区切り文
字として扱う文字が含まれていることがあるかもしれません。特に多いのが、
他のソース・ファイルの中の静的変数を参照する場合です（*Note Program
variables: Variables.）。ファイル名は、オブジェクト・ファイルの中にデ
バッグ・シンボルとして記録されていますが、GDBは通常、典型的なファイル
名、例えば`foo.c'を解析して、3つの単語`foo'、`.'（ピリオド）、`c'であ
るとみなします。GDBが`foo.c'を単一のシンボルであると認識できるようにす
るには、それを単一引用符で囲みます。例えば、

     p 'foo.c'::x

は、`x'の値をファイル`foo.c'のスコープの中で検索します。

`info address SYMBOL'
     SYMBOLで指定されるシンボルのデータがどこに格納されているかを示し
     ます。レジスタ変数の場合は、それがどのレジスタに入っているかを示
     します。レジスタ変数ではないローカル変数の場合は、その変数が常に
     格納されている位置の、スタック・フレーム内におけるオフセット値を
     表示します。

     `print &SYMBOL'との相違に注意してください。`print &SYMBOL'はレジ
     スタ変数に対しては機能しませんし、スタック内のローカル変数に対し
     て実行すると、その変数のカレントなインスタンスの存在するアドレス
     そのものが表示されます。

`whatis EXP'
     式EXPのデータ型を表示します。EXPは実際には評価されず、EXP内の副作
     用を持つ操作（例えば、代入や関数呼び出し）は実行されません。*Note
     Expressions: Expressions。

`whatis'
     値ヒストリの最後の値である`$'のデータ型を表示します。

`ptype TYPENAME'
     データ型TYPENAMEの説明を表示します。TYPENAMEは型の名前です。Cで記
     述されたコードの場合は、`class CLASS-NAME'、`struct STRUCT-TAG'、
     `union UNION-TAG'、`enum ENUM-TAG'という形式を取ることができます。

`ptype EXP'
`ptype'
     式EXPの型に関する説明を表示します。単に型の名前を表示するだけでは
     なく、詳細な説明も表示するという点で、`ptype'は`whatis'と異なりま
     す。

     例えば、変数宣言

          struct complex {double real; double imag;} v;

     に対して、`whatis'、`ptype'はそれぞれ以下のような出力をもたらしま
     す。

          (gdb) whatis v
          type = struct complex
          (gdb) ptype v
          type = struct complex {
              double real;
              double imag;
          }

     `whatis'と同様、引数なしで`ptype'を使用すると、値ヒストリの最後の
     値である`$'の型を参照することになります。

`info types REGEXP'
`info types'
     その名前がREGEXPで指定される正規表現にマッチするすべての型（ある
     いは、引数を指定しなければ、ユーザ・プログラム中のすべての型）の
     簡単な説明を表示します。個々の型の完全な名前は、それ自体が1つの完
     全な行を構成するものとみなして、マッチされます。したがって、`i
     type value'は、ユーザ・プログラムの中で、その名前が文字列`value'
     を含むすべての型に関する情報を表示し、`i type ^value$'は、名前が
     `value'そのものである型に関する情報だけを表示します。

     このコマンドは`ptype'とは2つの点で異なります。まず第1に`whatis'と
     同様、詳細な情報を表示しません。第2に、型が定義されているすべての
     ソース・ファイルを一覧表示します。

`info source'
     カレントなソース・ファイル、すなわち、カレントな実行箇所を含む関
     数のソース・ファイルの、ファイル名とそれが記述された言語の名前を
     表示します。

`info sources'
     ユーザ・プログラムのソース・ファイルのうち、デバッグ情報の存在す
     るものすべての名前を、2つの一覧にして表示します。2つの一覧とは、
     シンボルが既に読み込まれたファイルの一覧と、後に必要なときにシン
     ボルが読み込まれるファイルの一覧です。

`info functions'
     すべての定義済み関数の名前とデータ型を表示します。

`info functions REGEXP'
     その名前がREGEXPで指定される正規表現にマッチする部分を持つすべて
     の定義済み関数の名前とデータ型を表示します。したがって、`info fun
     step'は、その名前が文字列`step'を含むすべての関数を見つけ、`info
     fun ^step'は、名前が文字列`step'で始まるすべての関数を見つけます。

`info variables'
     関数の外部で宣言されているすべての変数（つまり、ローカル変数を除
     く変数）の名前とデータ型を表示します。

`info variables REGEXP'
     その名前が正規表現REGEXPにマッチする部分を持つすべての（ローカル
     変数を除く）変数の名前とデータ型を表示します。


     いくつかのシステムにおいては、ユーザ・プログラムの停止・再起動を
     伴うことなく、そのユーザ・プログラムを構成する個々のオブジェクト・
     ファイルを更新することができます。例えば、VxWorksでは、欠陥のある
     オブジェクト・ファイルを再コンパイルして、実行を継続することがで
     きます。このようなマシン上でプログラムを実行しているのであれば、
     自動的に再リンクされたモジュールのシンボルをGDBに再ロードさせるこ
     とができます。

     `set symbol-reloading on'
          ある特定の名前を持つオブジェクト・ファイルが再検出されたとき
          に、対応するソース・ファイルのシンボル定義を入れ替えます。

     `set symbol-reloading off'
          同じ名前を持つオブジェクト・ファイルを再検出したときに、シン
          ボル定義を入れ替えません。これがデフォルトの状態です。モジュー
          ルの自動再リンクを許しているシステム上でプログラムを実行して
          いるのでない場合は、`symbol-reloading'の設定はoffのままにす
          るべきです。さもないと、（異なるディレクトリやライブラリの中
          にある）同じ名前を持ついくつかのモジュールを含むような大きな
          プログラムをリンクする際に、GDB はシンボルを破棄してしまうか
          もしれません。

     `show symbol-reloading'
          `symbol-reloading'のカレントな設定（`on'または`off'）を表示
          します。


`maint print symbols FILENAME'
`maint print psymbols FILENAME'
`maint print msymbols FILENAME'
     デバッグ・シンボル・データのダンプをファイルFILENAMEの中に書き込
     みます。これらのコマンドは、GDBのシンボル読み込みコードをデバッグ
     するのに使われています。デバッグ・データを持つシンボルだけがダン
     プに含まれます。`maint print symbols'を使用すると、GDBは、完全な
     詳細情報を入手済みのすべてのシンボルの情報をダンプに含めます。つ
     まり、ファイルFILENAMEには、GDBがそのシンボルを読み込み済みのファ
     イルに対応するシンボルが反映されます。`info sources'コマンドを使
     用することで、これらのファイルがどれであるかを知ることができます。
     代わりに`maint print psymbols'を使用すると、GDB が部分的にしか知
     らないシンボルに関する情報もダンプの中に含まれます。これは、GDBが
     ざっと読みはしたものの、まだ完全には読み込んでいないファイルに定
     義されているシンボルに関する情報です。最後に`maint print
     msymbols'では、GDBが何らかのシンボル情報を読み込んだオブジェクト・
     ファイルから、最小限必要とされるシンボル情報がダンプされます。GDB
     がどのようにしてシンボルを読み込むかについては、*Note Commands to
     specify files: Files （の`symbol-file'の説明の部分）を参照してく
     ださい。



