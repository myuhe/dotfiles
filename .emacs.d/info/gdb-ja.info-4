Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.





File: gdb-ja.info, Node: Altering, Next: GDB Files, Prev: Symbols, Up: Top

実行の変更
**********

ユーザ・プログラムの中に誤りのある箇所を見つけると、その明らかな誤りを
訂正することで、その後の実行が正しく行われるかどうかを知りたくなるでしょ
う。GDBにはプログラムの実行に変化を与える機能があり、これを使って実験
することで、その答を知ることができます。

例えば、変数やメモリ上のある箇所に新しい値を格納すること、ユーザ・プロ
グラムにシグナルを送ること、ユーザ・プログラムを異なるアドレスで再起動
すること、関数が完全に終了する前に呼び出し元に戻ることなどが可能です。

* Menu:

* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続
* Signaling::                   ユーザ・プログラムへのシグナルの通知

* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用



File: gdb-ja.info, Node: Assignment, Next: Jumping, Prev: Altering, Up: Altering

変数への代入
============

ある変数の値を変更するには、代入式を評価します。*Note Expressions:
Expressions。例えば、

     print x=4

は、変数`x'に値4を格納してから、その代入式の値（すなわち4）を表示しま
す。サポートされている言語の演算子の詳細情報については、*Note Using
GDB with Different Languages: Languages。

代入の結果を表示させることに関心がなければ、`print'コマンドの代わりに
`set'コマンドを使用してください。実際のところ`set'コマンドは、式の値が
表示もされず、値ヒストリ（*Note Value history: Value History.）にも入
らないということを除けば、`print'コマンドと同等です。式は、その結果の
入手だけを目的として評価されます。

`set'コマンドの引数となる文字列の先頭の部分が、`set'コマンドのサブ・コ
マンドの名前と一致してしまうような場合には、ただの`set'コマンドではな
く`set variable'コマンドを使用してください。このコマンドは、サブ・コマ
ンドを持たないという点を除けば、`set'コマンドと同等です。例えば、ユー
ザ・プログラムに`width'という変数がある場合、`set width=13'によってこ
の変数に値を設定しようとするとエラーになります。これは、GDBが`set
width'というコマンドを持っているためです。

     (gdb) whatis width
     type = double
     (gdb) p width
     $4 = 13
     (gdb) set width=47
     Invalid syntax in expression.

ここで不正な表現となっているのは、もちろん`=47'の部分です。プログラム
内の変数`width'に値を設定するには、以下のようにしてください。

     (gdb) set var width=47

GDBは、代入時の暗黙の型変換をC言語よりも多くサポートしています。整数値
を自由にポインタ型変数に格納できますし、その逆もできます。また、任意の
構造体を、同じサイズの別の構造体、または、より小さいサイズの別の構造体
に変換することができます。

メモリ上の任意の箇所に値を格納するには、指定されたアドレスにおいて指定
された型の値を生成するために、`{...}'を使用します（*Note Expressions:
Expressions.）。例えば`{int}0x83040'は、メモリ・アドレス`0x83040'を整
数値として参照します（メモリ上における、ある特定のサイズと表現を示唆し
ています）。また、

     set {int}0x83040 = 4

は、そのメモリ・アドレスに値4を格納します。



File: gdb-ja.info, Node: Jumping, Next: Signaling, Prev: Assignment, Up: Altering

異なるアドレスにおける処理継続
==============================

通常、ユーザ・プログラムを継続実行するには、`continue'コマンドを使用し
て、停止した箇所から継続実行させます。以下のコマンドを使用することで、
ユーザが選択したアドレスにおいて実行を継続させることができます。

`jump LINESPEC'
     LINESPECで指定される行において、実行を再開します。その行にブレイ
     クポイントが設定されている場合には、実行は再びすぐに停止します。
     LINESPECの形式については、*Note Printing source lines: List。一般
     的な慣例として、`jump'コマンドは、`tbreak'コマンドと組み合わせて
     使用されます。*Note Setting breakpoints: Set Breaks。

     `jump'コマンドは、カレントなスタック・フレーム、スタック・ポイン
     タ、メモリ内の任意の箇所の内容、プログラム・カウンタを除くレジス
     タの内容を変更しません。LINESPECで指定される行が、現在実行されて
     いる関数とは異なる関数の中にある場合、それら2つの関数が異なるパター
     ンの引数やローカル変数を期待していると、奇妙な結果が発生するかも
     しれません。このため、指定された行が、現在実行されている関数の中
     にない場合、`jump'コマンドは実行の確認を求めてきます。しかし、ユー
     ザがプログラムのマシン言語によるコードを熟知していたとしても、奇
     妙な結果の発生することが予想されます。

`jump *ADDRESS'
     ADDRESSで指定されるアドレスにある命令から、実行を再開します。

レジスタ`$pc'に新しい値を設定することで、`jump'コマンドとほとんど同等
の効果を実現することができます。両者の違いは、レジスタ`$pc'に値を設定
しただけでは、ユーザ・プログラムの実行は再開されないという点にあります。
ユーザが実行を*継続するとき*に、プログラムが実行を再開するアドレスが変
更されるだけです。例えば、

     set $pc = 0x485

を実行すると、次に`continue'コマンドやステップ実行を行うコマンドが実行
されるとき、ユーザ・プログラムが停止したアドレスにある命令ではなく、ア
ドレス`0x485'にある命令から実行されることになります。*Note Continuing
and stepping: Continuing and Stepping。

`jump'コマンドが最も一般的に使用されるのは、既に実行されたプログラム部
分を、さらに多くのブレイクポイントを設定した状態で再実行する場合でしょ
う。これにより、実行される処理の内容をさらに詳しく調べることができます。



File: gdb-ja.info, Node: Signaling, Next: Returning, Prev: Jumping, Up: Altering

ユーザ・プログラムへのシグナルの通知
====================================

`signal SIGNAL'
     実行を停止した箇所からユーザ・プログラムを再開させますが、すぐに
     SIGNALで指定されるシグナルを通知します。SIGNALには、シグナルの名
     前または番号を指定できます。例えば、多くのシステムにおいて、
     `signal 2'と`signal SIGINT'はどちらも、割り込みシグナルを通知する
     方法です。

     一方、
     SIGNALが0であれば、
     シグナルを通知することなく実行を継続します。
     ユーザ・プログラムがシグナルのために停止し、
     通常であれば、
     `continue'コマンドによって実行を再開するとそのシグナルを検知してしまうような場合に便利です。
     `signal 0'を実行すると、
     プログラムはシグナルを受信することなく実行を再開します。

     `signal'を実行した後、RETキーを押しても、繰り返し実行は行われませ
     ん。

`signal'コマンドを実行することは、シェルから`kill'ユーティリティを実行
するのと同じではありません。`kill'によってシグナルを送ると、GDBはシグ
ナル処理テーブルによって何をするべきかを決定します（*Note Signals::）。
一方、`signal'コマンドは、ユーザ・プログラムに直接シグナルを渡します。




File: gdb-ja.info, Node: Returning, Next: Calling, Prev: Signaling, Up: Altering

関数からの復帰
==============

`return'
`return EXPRESSION'
     `return'コマンドによって、呼び出されている関数の実行をキャンセル
     することができます。式EXPRESSIONを引数に指定すると、その値が関数
     の戻り値として使用されます。

`return'を実行すると、GDBは選択されているスタック・フレーム（および、
その下位にあるすべてのフレーム）を破棄します。破棄されたフレームは、実
行を完結する前に復帰したのだと考えればよいでしょう。戻り値を指定したい
のであれば、その値を`return'への引数として渡してください。

このコマンドは、選択されているスタック・フレーム（*Note Selecting a
frame: Selection.）、および、その下位にあるすべてのフレームをポップし
て、もともと選択されていたフレームを呼び出したフレームを、最下位のフレー
ムにします。つまり、そのフレームが選択されることになります。指定された
値は、関数から戻り値を返すのに使用されるレジスタに格納されます。

`return'コマンドは実行を再開しません。関数から復帰した直後の状態で、プ
ログラムを停止したままにします。これに対して、`finish'コマンド（*Note
Continuing and stepping: Continuing and Stepping.）は、選択されている
スタック・フレームが自然に復帰するまで、実行を再開、継続します。



File: gdb-ja.info, Node: Calling, Next: Patching, Prev: Returning, Up: Altering

プログラム関数の呼び出し
========================

`call EXPR'
     `void'型の戻り値を表示することなく、式EXPRを評価します。

ユーザ・プログラムの中からある関数を呼び出したいが、void型の戻り値を出
力させたくない場合、この`print'コマンドの変種を使用することができます。
`void'型でない戻り値は表示され、値ヒストリに保存されます。

A29Kでは、ユーザに制御される変数`call_scratch_address'によって、GDBが
デバッグ対象の関数を呼び出すときに使用するスクラッチ領域が指定されます。
通常はスクラッチ領域をスタック上に置きますが、この方法は命令空間とデー
タ空間を別々に持つシステム上では機能しないため、これが必要になります。



File: gdb-ja.info, Node: Patching, Prev: Calling, Up: Altering

プログラムへのパッチ適用
========================

デフォルトでは、GDBはユーザ・プログラムの実行コードを持つファイル（あ
るいは、コア・ファイル）を書き込み不可の状態でオープンします。これによ
り、マシン・コードを誤って変更してしまうことを防ぐことができます。しか
し、ユーザ・プログラムのバイナリに意図的にパッチを適用することもできな
くなってしまいます。

バイナリにパッチを適用したいのであれば、`set write'コマンドによって明
示的にそのことを指定することができます。例えば、内部的なデバッグ・フラ
グを立てたり、緊急の修正を行いたいということがあるでしょう。

`set write on'
`set write off'
     `set write on'を指定すると、GDBは実行ファイルやコア・ファイルを、
     読み込み、書き込みともに可能な状態でオープンします。`set write
     off' （デフォルト）を指定すると、GDBはこれらのファイルを読み込み
     しかできない状態でオープンします。

     既にファイルをロード済みの場合、`set write'の設定を変更後、その変
     更を反映させるためには、（`exec-file'コマンド、`core-file'コマン
     ドを使用して）、そのファイルを再ロードしなければなりません。

`show write'
     実行ファイル、コア・ファイルが、読み込みだけではなく書き込みもで
     きる状態でオープンされる設定になっているか否かを表示します。



File: gdb-ja.info, Node: GDB Files, Next: Targets, Prev: Altering, Up: Top

GDBファイル
***********

GDBはデバッグ対象となるプログラムのファイル名を知っている必要がありま
す。これは、プログラムのシンボル・テーブルを読み込むためでもあり、また、
プログラムを起動するためでもあります。過去に生成されたコア・ダンプをデ
バッグするには、GDBにコア・ダンプ・ファイルの名前を教えてやらなければ
なりません。

* Menu:

* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー



File: gdb-ja.info, Node: Files, Next: Symbol Errors, Prev: GDB Files, Up: GDB Files

ファイルを指定するコマンド
==========================

実行ファイルやコア・ダンプ・ファイルの名前を指定したい場合があります。
これは通常、GDBの起動コマンドへの引数を利用して、起動時に行います
（*Note Getting In and Out of GDB: Invocation.）。

ときには、GDBのセッション中に、異なるファイルに切り替える必要がでてく
ることがあります。あるいは、GDBを起動するときに、使いたいファイルの名
前を指定するのを忘れたということもあるかもしれません。このような場合に、
新しいファイルを指定するGDBコマンドが便利です。

`file FILENAME'
     FILENAMEで指定されるプログラムをデバッグ対象にします。そのプログ
     ラムは、シンボル情報とメモリ内容を獲得するために読み込まれます。
     また、ユーザが`run'コマンドを使用したときに実行されます。ユーザが
     ディレクトリを指定せず、そのファイルがGDBの作業ディレクトリに見つ
     からない場合、シェルが実行すべきファイルを探すときと同様、GDBは、
     ファイルを探すべきディレクトリのリストとして環境変数`PATH'の値を
     使用します。`path'コマンドによって、GDB、ユーザ・プログラムの両方
     について、この変数の値を変更することができます。

     ファイルをメモリにマップすることのできるシステムでは、補助的なファ
     イル`FILENAME.syms'に、ファイルFILENAMEのシンボル・テーブル情報が
     格納されることがあります。このような場合、GDBは、`FILENAME.syms'
     というファイルからシンボル・テーブルをメモリ上にマップすることで、
     起動に要する時間を短くします。詳細については、（以下に説明する
     `file'コマンド、`symbol-file'コマンド、`add-symbol-file'コマンド
     を実行する際にコマンドライン上で使用可能な）ファイル・オプション
     の`-mapped'、`-readnow'の説明を参照してください。

`file'
     `file'コマンドを引数なしで実行すると、GDBは実行ファイル、シンボル・
     テーブルに関して保持している情報をすべて破棄します。

`exec-file [ FILENAME ]'
     実行するプログラムがFILENAMEで指定されるファイル内に存在する（た
     だし、シンボル・テーブルはそこには存在しない）ということを指定し
     ます。GDBは、必要であれば、ユーザ・プログラムの存在場所を見つける
     ために、環境変数`PATH'を使用します。FILENAMEを指定しないと、実行
     ファイルに関して保持している情報を破棄するよう指示したことになり
     ます。

`symbol-file [ FILENAME ]'
     FILENAMEで指定されるファイルからシンボル・テーブル情報を読み込み
     ます。必要な場合には`PATH'が検索されます。同一のファイルから、シ
     ンボル・テーブルと実行プログラムの両方を獲得する場合には、`file'
     コマンドを使用してください。

     `symbol-file'を引数なしで実行すると、GDBがユーザ・プログラムのシ
     ンボル・テーブルに関して持っている情報は消去されます。

     `symbol-file'コマンドが実行されると、それまでGDBが保持していたコ
     ンビニエンス変数、値ヒストリ、すべてのブレイクポイント、自動表示
     式は破棄されます。その理由は、これらの情報の中に、GDBが破棄した古
     いシンボル・テーブルのデータの一部である、シンボルやデータ型を記
     録する内部データへのポインタが含まれているかもしれないからです。

     `symbol-file'を一度実行した後にRETキーを押しても、`symbol-file'の
     実行は繰り返されません。

     GDBは、特定の環境用に構成されると、その環境において生成される標準
     フォーマットのデバッグ情報を理解するようになります。GNUコンパイラ
     を使うこともできますし、ローカルな環境の規約に従う他のコンパイラ
     を使用することもできます。通常は、GNUコンパイラを使用しているとき
     に最高の結果を引き出すことができます。例えば`gcc'を使用すると、最
     適化されたコードに対してデバッグ情報を生成することができます。

     COFFを使用する古いSVR3システムを除外すれば、ほとんどの種類のオブ
     ジェクト・ファイルでは、`symbol-file'コマンドを実行しても、通常は、
     ただちにシンボル・テーブルの全体が読み込まれるわけではありません。
     実際に存在するソース・ファイルとシンボルを知るために、シンボル・
     テーブルを素早く調べるだけです。詳細な情報は、後にそれが必要になっ
     たときに、一度に1ソース・ファイルずつ読み込まれます。

     2段階に分けて読み込むという手法は、GDBの起動時間の短縮を目的とし
     ています。ほとんどの場合、このような手法が採用されているというこ
     とに気付くことはありません。せいぜい、特定のソース・ファイルに関
     するシンボル・テーブルの詳細が読み込まれている間、たまに停止する
     くらいです（もしそうしたいのであれば、`set verbose'コマンドを使う
     ことによって、このようにして停止しているときにはメッセージを表示
     させることもできます。*Note Optional warnings and messages:
     Messages/Warnings）。

     COFFについては、まだこの2段階方式を実装していません。シンボル・テー
     ブルがCOFFフォーマットで格納されている場合、`symbol-file'コマンド
     はシンボル・テーブル・データの全体をただちに読み込みます。COFFの
     stabs拡張フォーマット（stabs-in-COFF）では、デバッグ情報が実際に
     はstabsフォーマットの内部に存在するため、2段階方式が実装されてい
     ることに注意してください。

`symbol-file FILENAME [ -readnow ] [ -mapped ]'
`file FILENAME [ -readnow ] [ -mapped ]'
     GDBが確実にシンボル・テーブル全体を保持しているようにしたいのであ
     れば、シンボル・テーブル情報を読み込む任意のコマンド実行時に
     `-readnow'オプションを使用することで、2段階によるシンボル・テーブ
     ル読み込み方式を使わないようにさせることができます。

     `mmap'システム・コールによるファイルのメモリへのマッピングがシス
     テム上において有効な場合、もう1つのオプション`-mapped'を使って、
     GDBに対して、再利用可能なファイルの中にユーザ・プログラムのシンボ
     ルを書き込ませることができます。後のGDBデバッグ・セッションは、
     （プログラムに変更がない場合）実行プログラムからシンボル・テーブ
     ルを読み込むのに時間を費やすことなく、この補助シンボル・ファイル
     からシンボル情報をマップします。`-mapped'オプションを使用すること
     は、コマンドライン・オプション`-mapped'を指定してGDBを起動するの
     と同じ効果を持ちます。

     補助シンボル・ファイルがユーザ・プログラムのシンボル情報をすべて
     確実に持つように、両方のオプションを同時に指定することもできます。

     MYPROGという名前のプログラムの補助シンボル・ファイルは、
     `MYPROG.syms'という名前になります。このファイルが存在すると、（そ
     れが、対応する実行ファイルよりも新しい限り）ユーザがMYPROGをデバッ
     グしようとすると、GDBは常にそのファイルを使おうとします。特別なオ
     プションやコマンドは必要ありません。

     `.syms'ファイルは、GDBを実行したホスト・マシンに固有のものです。
     それは、GDB内部におけるシンボル・テーブルの正確なイメージを保持し
     ています。複数のホスト・プラットフォーム間で共用することはできま
     せん。


`core-file [ FILENAME ]'
     「メモリ上のイメージ」として使用されるコア・ダンプ・ファイルの存
     在場所を指定します。伝統的に、コア・ファイルは、それを生成したプ
     ロセスのアドレス空間の一部だけを保持しています。GDBは、実行ファイ
     ルそのものにアクセスすることによって、保持されていない部分を獲得
     することができます。

     `core-file'を引数なしで実行すると、コア・ファイルを一切使用しない
     ことを指定したことになります。

     ユーザ・プログラムが実際にGDBの管理下で実行中の場合は、コア・ファ
     イルは無視されることに注意してください。したがって、ある時点まで
     ユーザ・プログラムを実行させた後に、コア・ファイルをデバッグした
     くなったような場合、プログラムを実行しているサブ・プロセスを終了
     させなければなりません。サブ・プロセスの終了は、`kill'コマンドで
     行います（*Note Killing the child process: Kill Process.）。

`add-symbol-file FILENAME ADDRESS'
`add-symbol-file FILENAME ADDRESS [ -readnow ] [ -mapped ]'
     `add-symbol-file'コマンドは、FILENAMEで指定されるファイルから追加
     的なシンボル・テーブル情報を読み込みます。FILENAMEで指定されるファ
     イルが（何か別の方法によって）実行中のプログラムの中に動的にロー
     ドされた場合に、このコマンドを使用します。ADDRESSは、ファイルがロー
     ドされたメモリ・アドレスでなければなりません。GDBは独力でこのアド
     レスを知ることはできません。ADDRESSは式として指定することもできま
     す。

     FILENAMEで指定されるファイルのシンボル・テーブルは、もともと
     `symbol-file'コマンドによって読み込まれたシンボル・テーブルに追加
     されます。`add-symbol-file'コマンドは何回でも使用することができま
     す。新たに読み込まれたシンボル・テーブルのデータは、古いデータに
     追加されていきます。古いシンボル・データをすべて破棄するには、
     `symbol-file'コマンドを使用してください。

     `add-symbol-file'コマンドを実行した後にRETキーを押しても、
     `add-symbol-file'コマンドは繰り返し実行されません。

     `symbol-file'コマンドと同様、`-mapped'オプションと`-readnow'オプ
     ション使用して、FILENAMEで指定されるファイルのシンボル・テーブル
     情報をGDBがどのように管理するかを変更することができます。

`add-shared-symbol-file'
     `add-shared-symbol-file'コマンドは、Motorola 88k用のHarris' CXUX
     オペレーティング・システム上でのみ使用することができます。GDBは自
     動的に共有ライブラリを探しますが、GDBがユーザの共有ライブラリを見
     つけてくれない場合には、`add-shared-symbol-file'コマンドを実行で
     きます。このコマンドは引数を取りません。

`section'
     `section'コマンドは、実行ファイルのSECTIONセクションのベース・ア
     ドレスをADDRに変更します。これは、（a.outフォーマットのように）実
     行ファイルがセクション・アドレスを保持していない場合や、ファイル
     の中で指定されているアドレスが誤っている場合に使うことができます。
     個々のセクションは、個別に変更されなければなりません。`info
     files'コマンドによって、すべてのセクションとそのアドレスを一覧表
     示することができます。

`info files'
`info target'
     `info files'と`info target'は同義です。両方とも、カレント・ターゲッ
     ト（*Note Specifying a Debugging Target: Targets.）に関する情報を
     表示します。表示される情報には、GDBが現在使用中の実行ファイルやコ
     ア・ダンプ・ファイルの名前、シンボルがそこからロードされたファイ
     ルの名前を含みます。`help target'コマンドは、カレントなターゲット
     ではなく、すべての可能なターゲットを一覧表示します。

ファイルを指定するすべてのコマンドは、引数として、絶対パスによるファイ
ル名と相対パスによるファイル名のどちらでも受け付けます。GDBは、常にファ
イル名を絶対パス名に変換して、絶対パスの形で記憶します。

GDBは、HP-UX、SunOS、SVr4、Irix 5、IBM RS/6000の共有ライブラリをサポー
トします。ユーザが`run'コマンドを実行したり、コア・ファイルを調べよう
とすると、GDBは自動的に共有ライブラリからシンボル定義をロードします
（ユーザが`run'コマンドを発行するまでは、共有ライブラリ内部の関数への
参照があっても、GDBにはそれを理解することができません。コア・ファイル
をデバッグしている場合は、この限りではありません）。

`info share'
`info sharedlibrary'
     現在ロードされている共有ライブラリの名前を表示します。

`sharedlibrary REGEX'
`share REGEX'

     UNIXの正規表現にマッチするファイルに対応する、共有オブジェクト・
     ライブラリのシンボルをロードします。自動的にロードされるファイル
     と同様、ユーザ・プログラムによってコア・ファイルのために必要とさ
     れる共有ライブラリ、または`run'コマンド実行時に必要とされる共有ラ
     イブラリだけがロードされます。REGEXが省略されると、ユーザ・プログ
     ラムによって必要とされるすべての共有ライブラリがロードされます。





File: gdb-ja.info, Node: Symbol Errors, Prev: Files, Up: GDB Files

シンボル・ファイル読み込み時のエラー
====================================

シンボル・ファイルの読み込み中に、GDBはときどき問題にぶつかることがあ
ります。例えば、認識できないシンボル・タイプを見つけたり、コンパイラの
出力に既知の問題を発見することがあります。デフォルトでは、このようなエ
ラーがあったことを、GDBはユーザに知らせません。なぜなら、このようなエ
ラーは比較的よく見られるものであり、コンパイラのデバッグをしているよう
な人々だけが関心を持つようなものだからです。もし、正しく構築されていな
いシンボル・テーブルに関する情報を見ることに関心があれば、`set
complaints'コマンドを使用することで、何回問題が発生しようと個々のタイ
プの問題について1回だけメッセージを出力するよう指示することができます
し、また、何回問題発生したかを見るためにより多くのメッセージを表示する
よう指示することもできます（*Note Optional warnings and messages:
Messages/Warnings.）。

現在のバージョンで表示されるメッセージとその意味を以下に記します。

`inner block not inside outer block in SYMBOL'

     シンボル情報は、シンボルのスコープの先頭と末尾の位置を示します
     （例えば、ある関数の先頭、あるいは、ブロックの先頭など）。このエ
     ラーは、内側のスコープのブロックが、外側のスコープのブロックに完
     全に包含されていないことを意味しています。

     GDBは、内側のブロックが外側のブロックと同一のスコープを持つものと
     して扱うことで、この問題を回避します。外側のブロックが関数でない
     場合には、エラー・メッセージのSYMBOLの部分が``(don't know)''のよ
     うに表示されることがあります。

`block at ADDRESS out of order'

     シンボルのスコープとなるブロックに関する情報は、アドレスの低い方
     から昇順に並んでいなければなりません。このエラーは、そうなってい
     ないということを示しています。

     GDBはこの問題を回避することはせず、読み込もうとしているソース・ファ
     イルのシンボルを見つけるのに支障が出ます（`set verbose on'を指定
     することで、どのソース・ファイルが関係しているかを知ることができ
     ます。*Note Optional warnings and messages: Messages/Warnings）。

`bad block start address patched'

     シンボルのスコープとなるブロックに関する情報の中の開始アドレスが、
     1つ前のソース行のアドレスより小さい値です。これは、SunOS 4.1.1 
     （および、それ以前のバージョン）のCコンパイラで発生することが分かっ
     ています。

     GDBは、シンボルのスコープとなるブロックが1つ前のソース行から始ま
     るものとして扱うことによって、この問題を回避します。

`bad string table offset in symbol N'

     シンボル番号Nのシンボルが持っている文字列テーブルへのポインタが、
     文字列テーブルのサイズを超える値です。

     GDBは、このシンボルが`foo'という名前を持つものとみなすことによっ
     て、この問題を回避します。この結果、多くのシンボルが`foo'という名
     前を持つことになってしまうと、他の問題が発生する可能性があります。

`unknown symbol type `0xNN''

     シンボル情報の中に、どのようにして読み取ればよいのかGDBには分から
     ないような、新しいデータ型が含まれています。`0xNN'は理解できなかっ
     たシンボルの型を16進数で表わしたものです。

     GDBは、このようなシンボル情報を無視することによって、このエラーを
     回避します。通常、プログラムのデバッグを行うことは可能になります
     が、ある特定のシンボルにアクセスすることができなくなります。この
     ような問題にぶつかり、それをデバッグしたいのであれば、`gdb'自身を
     使って`gdb'をデバッグすることができます。この場合、シンボル
     `complain'にブレイクポイントを設定し、関数`read_dbx_symtab'まで実
     行してから、`*bufp'によってシンボルを参照します。

`stub type has NULL name'
     GDBは、ある構造体またはクラスに関する完全な定義を見つけることがで
     きませんでした。

`const/volatile indicator missing (ok if using g++ v1.x), got...'

     あるC++のメンバ関数に関するシンボル情報に、より新しいコンパイラを
     使用した場合には生成されるいくつかの情報が欠けています。

`info mismatch between compiler and debugger'

     GDBは、コンパイラが生成した型の指定を解析できませんでした。



File: gdb-ja.info, Node: Targets, Next: Controlling GDB, Prev: GDB Files, Up: Top

デバッグ・ターゲットの指定
**************************

"ターゲット"とは、ユーザ・プログラムが持つ実行環境を指します。多くの場
合、GDBはユーザ・プログラムと同一のホスト環境上で実行されます。この場
合には、`file'コマンドや`core'コマンドを実行すると、その副作用としてデ
バッグ・ターゲットが指定されます。例えば、物理的に離れた位置にあるホス
ト・マシン上でGDBを実行したい場合や、シリアル・ポート経由でスタンドア
ロン・システムを制御したい場合、または、TCP/IP接続を利用してリアルタイ
ム・システムを制御したい場合などのように、より多くの柔軟性が必要とされ
る場合、`target'コマンドを使うことによって、GDBに設定されたターゲット
の種類の中から1つを指定することができます（*Note Commands for managing
targets: Target Commands.）。

* Menu:

* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド
* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ




File: gdb-ja.info, Node: Active Targets, Next: Target Commands, Prev: Targets, Up: Targets

アクティブ・ターゲット
======================

ターゲットには3つのクラスがあります。プロセス、コア・ファイル、そして、
実行ファイルです。GDBは同時に、1クラスにつき1つ、全体で最高で3つまでア
クティブなターゲットを持つことができます。これにより、（例えば）コア・
ファイルに対して行ったデバッグ作業を破棄することなく、プロセスを起動し
てその動作を調べることができます。

例えば、`gdb a.out'を実行すると、実行ファイル`a.out'が唯一のアクティブ
なターゲットになります。コア・ファイル（おそらくは、前回実行したときに
クラッシュしてコア・ダンプしたもの）を併せて指定すると、GDBは2つのター
ゲットを持ち、メモリ・アドレスを知る必要がある場合には、それを知るため
に2つのターゲットを並行して使用します。この場合、まずコア・ファイルを
参照し、次に実行ファイルを参照します。（典型的には、これら2つのクラス
のターゲットは相互に補完的です。というのも、コア・ファイルには、プログ
ラムが持っている変数などの読み書き可能なメモリ域の内容とマシン・ステー
タスだけがあり、実行ファイルには、プログラムのテキストと初期化されたデー
タだけがあるからです）。

`run'コマンドを実行すると、ユーザの実行ファイルはアクティブなプロセス・
ターゲットにもなります。プロセス・ターゲットがアクティブな間は、メモリ・
アドレスを要求するすべてのGDBコマンドは、プロセス・ターゲットを参照し
ます。アクティブなコア・ファイル・ターゲットや実行ファイル・ターゲット
の中のアドレスは、プロセス・ターゲットがアクティブな間は、隠された状態
になります。

新しいコア・ファイル・ターゲットや実行ファイル・ターゲットを選択するに
は、`core-file'コマンドや`exec-file'コマンドを使用します（*Note
Commands to specify files: Files.）。既に実行中のプロセスをターゲット
として指定するには、`attach'コマンドを使用します（*Note Debugging an
already-running process: Attach.）。



File: gdb-ja.info, Node: Target Commands, Next: Byte Order, Prev: Active Targets, Up: Targets

ターゲットを管理するコマンド
============================

`target TYPE PARAMETERS'
     GDBのホスト環境をターゲット・マシンまたはターゲット・プロセスに接
     続します。ターゲットとは、典型的には、デバッグ機能と通信するため
     のプロトコルを指します。引数TYPEによって、ターゲット・マシンの種
     類またはプロトコルを指定します。

     PARAMETERSはターゲット・プロトコルによって解釈されるものですが、
     典型的には、接続すべきデバイス名やホスト名、プロセス番号、ボーレー
     トなどが含まれます。

     `target'コマンドを実行した後にRETキーを押しても、`target'コマンド
     は再実行されません。

`help target'
     利用可能なすべてのターゲットの名前を表示します。現在選択されてい
     るターゲットを表示させるには、`info target'コマンドまたは`info
     files'コマンドを使用します（*Note Commands to specify files:
     Files.）。

`help target NAME'
     ある特定のターゲットに関する説明を表示します。選択時に必要となる
     パラメータも表示されます。

`set gnutarget ARGS'
     GDBは、自分で持っているライブラリBFDを使用してユーザ・ファイルを
     読み込みます。GDBは、"実行ファイル"、"コア・ファイル"、".oファイ
     ル"のどれを自分が読み込んでいるのかを知っています。しかし、`set
     gnutarget'コマンドを使用して、ファイルのフォーマットを指定するこ
     ともできます。ほとんどの`target'コマンドとは異なり、`gnutarget'に
     おける`target'は、マシンではなくプログラムです。

     *注意:* `set gnutarget'でファイル・フォーマットを指定するには、実
     際のBFD名を知っている必要があります。

     *Note Commands to specify files: Files。

`show gnutarget'
     `gnutarget'がどのようなファイル・フォーマットを読むよう設定されて
     いるかを表示させるには、`show gnutarget'コマンドを使用します。
     `gnutarget'を設定していない場合、個々のファイルのフォーマットを
     GDBが自動的に決定します。この場合、`show gnutarget'を実行すると
     `The current BDF target is "auto"' と表示されます。

以下に、一般的なターゲットをいくつか示します（GDBの構成によって、利用
可能であったり利用不可であったりします）。

`target exec PROGRAM'
     実行ファイルです。`target exec PROGRAM'は`exec-file PROGRAM'と同
     じです。

`target core FILENAME'
     コア・ダンプ・ファイルです。`target core FILENAME'は`core-file
     FILENAME'と同じです。

`target remote DEV'
     GDB固有のプロトコルによる、リモートのシリアル・ターゲットです。引
     数DEVによって、接続を確立するために使用するシリアル装置（例えば、
     `/dev/ttya'）を指定します。*Note Remote debugging: Remote。
     `target remote'は、`load'コマンドもサポートするようになりました。
     これは、スタブをターゲット・システム上に持っていく方法が別にあり、
     かつ、ダウンロードが実行されたときに破壊されないようなメモリ域に
     それを置くことができる場合にのみ役に立ちます。

`target sim'
     CPUシミュレータです。*Note Simulated CPU Target: Simulator。

以下のターゲットはすべて、特定のCPUに固有のものであり、特定の構成にお
いてのみ利用可能です。


`target abug DEV'
     M68K用のABug ROMモニタです。

`target adapt DEV'
     A29K用のAdaptモニタです。

`target amd-eb DEV SPEED PROG'
     シリアル回線により接続されている、リモートのPCに組み込まれたAMD
     EB29Kボードです。`target remote'の場合と同様、DEVはシリアル装置で
     す。SPEEDによって回線速度を指定することができます。PROGは、デバッ
     グ対象となるプログラムをPC上のDOSから見た場合の名前です。*Note
     The EBMON protocol for AMD29K: EB29K Remote。

`target array DEV'
     Array Tech LSI33K RAIDコントローラ・ボードです。

`target bug DEV'
     MVME187（m88k）ボード上で動作するBUGモニタです。

`target cpu32bug DEV'
     CPU32（M68K）ボード上で動作するCPU32BUGモニタです。

`target dbug DEV'
     Motorola ColdFire用のdBUG ROMモニタです。

`target ddb DEV'
     Mips Vr4300用のNEC DDBモニタです。

`target dink32 DEV'
     PowerPC用のDINK32 ROMモニタです。

`target e7000 DEV'
     日立H8、SH用のE7000エミュレータです。

`target es1800 DEV'
     M68K用のES-1800エミュレータです。

`target est DEV'
     CPU32（M68K）ボード上で動作するEST-300 ICEモニタです。

`target hms DEV'
     ユーザのホストにシリアル回線で接続された日立のSH、H8/300、H8/500 
     ボードです。特別なコマンドである`device'と`speed'によって、使用さ
     れるシリアル回線と通信速度を制御します。*Note GDB and Hitachi
     Microprocessors: Hitachi Remote。

`target lsi DEV'
     Mips用のLSI ROMモニタです。

`target m32r DEV'
     三菱M32R/D ROMモニタです。

`target mips DEV'
     Mips用のIDT/SIM ROMモニタです。

`target mon960 DEV'
     Intel i960用のMON960モニタです。

`target nindy DEVICENAME'
     Nindy Monitorにより制御されるIntel 960ボードです。DEVICENAMEは、
     接続に使用するシリアル装置の名前です。例えば`/dev/ttya'です。
     *Note GDB with a remote i960 (Nindy): i960-Nindy Remote。

`target nrom DEV'
     NetROM ROMエミュレータです。このターゲットは、ダウンロードのみサ
     ポートしています。

`target op50n DEV'
     OKI HPPAボード上で動作するOP50Nモニタです。

`target pmon DEV'
     Mips用のPMON ROMモニタです。

`target ppcbug DEV'
`target ppcbug1 DEV'
     PowerPC用のPPCBUG ROMモニタです。

`target r3900 DEV'
     東芝R3900 Mips用のDensan DVE-R3900 ROMモニタです。

`target rdi DEV'
     RDIライブラリ・インターフェイスを経由したARM Angelモニタです。
 
`target rdp DEV'
     ARM Demonモニタです。

`target rom68k DEV'
     M68K IDPボード上で動作するROM 68Kモニタです。

`target rombug DEV'
     OS/9000用のROMBUG ROMモニタです。

`target sds DEV'
     （MotorolaのADSなどの）PowerPCボード上で動作するSDSモニタです。

`target sparclite DEV'
     ロードするためだけの目的で使用される、富士通のsparcliteボードです。
     プログラムをデバッグするためには、さらに別のコマンドを使用しなけ
     ればなりません。一例を挙げると、GDBの標準的なリモート・プロトコル
     を使用するtarget remote DEVです。

`target sh3 DEV'
`target sh3e DEV'
     日立SH-3、SH-3Eターゲット・システムです。

`target st2000 DEV SPEED'
     Tandem STDBUGプロトコルを実行しているTandem ST2000電話交換機です。
     DEVは、ST2000のシリアル回線に接続されている装置の名前です。SPEED
     は通信回線の速度です。GDBがST2000にTCPまたはTelnetで接続するよう
     構成されている場合、引数は使用されません。*Note GDB with a Tandem
     ST2000: ST2000 Remote。

`target udi KEYWORD'
     AMD UDIプロトコルを使用するRemote AMD29Kターゲットです。引数
     KEYWORDが、使用する29Kボードまたはシミュレータを指定します。*Note
     The UDI protocol for AMD29K: UDI29K Remote。

`target vxworks MACHINENAME'
     TCP/IPで接続されたVxWorksシステムです。引数MACHINENAMEは、ターゲッ
     ト・システムのマシン名またはIPアドレスです。*Note GDB and
     VxWorks: VxWorks Remote。

`target w89k DEV'
     Winbond HPPAボード上で動作するW89Kモニタです。


GDBの構成によって、利用可能なターゲットも異なるものになります。構成次
第で、ターゲットの数は多くなったり少なくなったりします。

多くのリモート・ターゲットでは、接続に成功すると、実行プログラムのコー
ドをダウンロードすることが必要となります。


`load FILENAME'
     構成によってGDBに組み込まれたリモート・デバッグ機能によっては、
     `load'コマンドが使用可能になります。これが利用可能な場合、実行ファ
     イルFILENAMEが（例えば、ダウンロードやダイナミック・リンクによっ
     て）リモート・システム上でデバッグできるようになることを意味しま
     す。また、`load'コマンドは`add-symbol-file'コマンドと同様、ファイ
     ルFILENAMEのシンボル・テーブルをGDB内に記録します。

     GDBが`load'コマンドを提供していない場合、それを実行しようとすると
     「`You can't do that when your target is ...'」というエラー・メッ
     セージが表示されます。

     実行ファイルの中で指定されたアドレスに、ファイルはロードされます。
     オブジェクト・ファイルのフォーマットによっては、プログラムをリン
     クするときに、ファイルをロードするアドレスを指定できるものもあり
     ます。これ以外のフォーマット（例えば、a.out）では、オブジェクト・
     ファイルのフォーマットによって固定的にアドレスが指定されます。

     VxWorksで`load'コマンドを実行すると、FILENAMEで指定される実行ファ
     イルがカレントなターゲット・システム上で動的にリンクされ、シンボ
     ルがGDBに追加されます。

     Intel 960ボードのNindyインターフェイスでは、`load'コマンドは
     FILENAMEで指定されるファイルを960側にダウンロードし、そのシンボル
     をGDBに追加します。

     日立のSH、H8/300、H8/500ボード（*Note GDB and Hitachi
     Microprocessors: Hitachi Remote.）に対するリモート・デバッグを選
     択すると、`load'コマンドはユーザ・プログラムを日立ボードにダウン
     ロードし、（`file'コマンドと同様）ユーザのホスト・マシン上のGDBの
     カレントなターゲット実行ファイルとしてオープンします。

     `load'コマンドを実行した後にRETキーを押しても、`load'コマンドは繰
     り返し実行されません。



File: gdb-ja.info, Node: Byte Order, Next: Remote, Prev: Target Commands, Up: Targets

ターゲットのバイト・オーダの選択
================================

MIPS、PowerPC、Hitachi SHなどのプロセッサは、ビッグ・エンディアン、リ
トル・エンディアンのどちらのバイト・オーダでも実行することができます。
通常は、実行ファイルまたはシンボルの中に、エンディアン種別を指定するビッ
トがあるので、どちらを使用するかを気にする必要はありません。しかし、
GDBの認識しているプロセッサのエンディアン種別を手作業で調整することが
できれば、便利なこともあるでしょう。

`set endian big'
     GDBに対して、ターゲットはビッグ・エンディアンであると想定するよう
     指示します。

`set endian little'
     GDBに対して、ターゲットはリトル・エンディアンであると想定するよう
     指示します。

`set endian auto'
     GDBに対して、実行ファイルに関連付けされているバイト・オーダを使用
     するよう指示します。

`show endian'
     GDBが認識している、ターゲットの現在のバイト・オーダ種別を表示しま
     す。


これらのコマンドは、ホスト上でのシンボリック・データの解釈を調整するだ
けであり、ターゲット・システムに対しては全く何の影響も持たないというこ
とに注意してください。



File: gdb-ja.info, Node: Remote, Prev: Byte Order, Up: Targets

リモート・デバッグ
==================

通常の方法でGDBを実行させることのできないマシン上で実行中のプログラム
をデバッグするには、リモート・デバッグ機能を使うのが便利です。例えば、
オペレーティング・システムのカーネルのデバッグや、フル機能を持つデバッ
ガを実行するのに十分な機能を持つ汎用的なオペレーティング・システムを持
たない小規模なシステムでのデバッグでは、ユーザはリモート・デバッグ機能
を使うことになるかもしれません。

GDBは、その構成によっては、特別なシリアル・インターフェイスやTCP/IPイ
ンターフェイスを持ち、これを特定のデバッグ・ターゲット用に使用すること
ができます。さらに、GDBには汎用的なシリアル・プロトコルが組み込まれて
おり（GDB固有のもので、特定のターゲット・システムに固有なものではあり
ません）、リモート・スタブを作成すれば、これを使用することができます。
リモート・スタブとは、GDBと通信するためにリモート・システム上で動作す
るコードです。

GDBの構成によっては、他のリモート・ターゲットが利用可能な場合もありま
す。利用可能なリモート・ターゲットを一覧表示させるには、`help target'
コマンドを使用します。

* Menu:

* Remote Serial::               GDBリモート・シリアル・プロトコル
* i960-Nindy Remote::		GDBとリモートi960（Nindy）
* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル
* VxWorks Remote::		GDBとVxWorks
* ST2000 Remote::               GDBとTandem ST2000
* Hitachi Remote::              GDBと日立のマイクロ・プロセッサ
* MIPS Remote::			GDBとMIPSボード
* Sparclet Remote::             GDBとSparcletボード
* Simulator::                   シミュレートされたCPUターゲット





File: gdb-ja.info, Node: Remote Serial

GDBリモート・シリアル・プロトコル
---------------------------------

他のマシン上で実行中のプログラムをデバッグするには（"ターゲット"・マシ
ンをデバッグするには）、そのプログラムを単独で実行するために通常必要と
なる事前条件をすべて整える必要があります。例えば、Cのプログラムの場合、

  1. Cの実行環境をセットアップするためのスタートアップ・ルーチンが必要
     です。これは通常`crt0'のような名前を持っています。スタートアップ・
     ルーチンは、ハードウェアの供給元から提供されることもありますし、
     ユーザが自分で書かなければならないこともあります。

  2. ユーザ・プログラムからのサブルーチン呼び出しをサポートするために、
     入出力の管理などを行うCのサブルーチン・ライブラリが必要になるかも
     しれません。

  3. ユーザ・プログラムを他のマシンに持っていく手段、例えばダウンロー
     ド・プログラムが必要です。これはハードウェアの供給元から提供され
     ることが多いのですが、ハードウェアのドキュメントをもとにユーザが
     自分で作成しなければならないこともあります。

次に、ユーザ・プログラムがシリアル・ポートを使って、GDBを実行中のマシ
ン（"ホスト"・マシン）と通信できるように準備します。一般的には、以下の
ような形になります。

*ホスト上では：*
     GDBは既にこのプロトコルの使い方を理解しています。他の設定がすべて
     終了した後、単に`target remote'コマンドを使用するだけです（*Note
     Specifying a Debugging Target: Targets.）。

*ターゲット上では：*
     ユーザ・プログラムに、GDBリモート・シリアル・プロトコルを実装した
     特別なサブルーチンをいくつかリンクする必要があります。これらのサ
     ブルーチンを含むファイルは、"デバッグ・スタブ"と呼ばれます。

     特定のリモート・ターゲットでは、ユーザ・プログラムにスタブをリン
     クする代わりに、`gdbserver'という補助プログラムを使うこともできま
     す。詳細については、*Note Using the `gdbserver' program: Server。

デバッグ・スタブはリモート・マシンのアーキテクチャに固有のものです。例
えば、SPARCボード上のプログラムをデバッグするには`sparc-stub.c'を使い
ます。

以下に実際に使えるスタブを列挙します。これらは、GDBとともに配布されて
います。


`i386-stub.c'
     Intel 386アーキテクチャ、およびその互換アーキテクチャ用です。

`m68k-stub.c'
     Motorola 680x0アーキテクチャ用です。

`sh-stub.c'
     日立SHアーキテクチャ用です。

`sparc-stub.c'
     SPARCアーキテクチャ用です。

`sparcl-stub.c'
     富士通SPARCLITEアーキテクチャ用です。


GDBとともに配布されるREADMEファイルには、新しく追加された他のスタブの
ことが記されているかもしれません。

* Menu:

* Stub Contents::       スタブの提供する機能
* Bootstrapping::       スタブに対する必須作業
* Debug Session::       ここまでのまとめ
* Protocol::            通信プロトコルの概略
* Server::		gdbserverプログラムの使用
* NetWare::		gdbserve.nlmプログラムの使用



File: gdb-ja.info, Node: Stub Contents

スタブの提供する機能
....................

各アーキテクチャ用のデバッグ・スタブは、3つのサブルーチンを提供します。

`set_debug_traps'
     このルーチンは、ユーザ・プログラムが停止したときに
     `handle_exception'が実行されるよう設定します。ユーザ・プログラム
     は、その先頭付近でこのサブルーチンを明示的に呼び出さなければなり
     ません。

`handle_exception'
     これが中心的な仕事をする部分ですが、ユーザ・プログラムはこれを明
     示的には呼び出しません。セットアップ・コードによって、トラップが
     発生したときに`handle_exception'が実行されるよう設定されます。

     ユーザ・プログラムが実行中に（例えば、ブレイクポイントで）停止す
     ると、`handle_exception'が制御権を獲得し、ホスト・マシン上のGDBと
     の通信を行います。これが、通信プロトコルが実装されている部分です。
     `handle_exception'は、ターゲット・マシン上でGDBの代理として機能し
     ます。それはまず、ユーザ・プログラムの状態に関する情報を要約して
     送ることから始めます。次に、GDBが必要とする情報を入手して転送する
     処理を継続します。これは、ユーザ・プログラムの実行を再開させるよ
     うなGDBコマンドが実行されるまで続きます。そのようなコマンドが実行
     されると、`handle_exception'は、制御をターゲット・マシン上のユー
     ザ・コードに戻します。

`breakpoint'
     ユーザ・プログラムにブレイクポイントを持たせるには、この補助的な
     サブルーチンを使います。特定の状況においては、これがGDBが制御を獲
     得する唯一の方法です。例えば、ユーザのターゲット・マシンに割り込
     みを発生させるボタンのようなものがあれば、このサブルーチンを呼び
     出す必要はありません。割り込みボタンを押すことで、制御は
     `handle_exception'に、つまり事実上GDBに渡されます。マシンによって
     は、シリアル・ポートから文字を受け取るだけでトラップが発生するこ
     ともあります。このような場合には、ユーザ・プログラム自身から
     `breakpoint'を呼び出す必要はなく、ホストのGDBセッションから
     `target remote'を実行するだけで制御を得ることができます。

     これらのどのケースにも該当しない場合、あるいは、デバッグ・セッショ
     ンの開始箇所としてあらかじめ決めてあるところでユーザ・プログラム
     が停止することを単に確実にしたいのであれば、`breakpoint'を呼び出
     してください。



File: gdb-ja.info, Node: Bootstrapping

スタブに対する必須作業
......................

GDBとともに配布されるデバッグ用スタブは、特定のチップのアーキテクチャ
用にセットアップされたものですが、デバッグのターゲット・マシンに関して
それ以外の情報は持っていません。

まず最初に、どのようにしてシリアル・ポートと通信するかをスタブに教えて
やる必要があります。

`int getDebugChar()'
     シリアル・ポートから単一文字を読み込むサブルーチンとしてこれを書
     きます。これは、ターゲット・システム上の`getchar'と同一かもしれま
     せん。これら2つを区別したい場合を考慮して、異なる名前が使われてい
     ます。

`void putDebugChar(int)'
     シリアル・ポートに単一文字を書き込むサブルーチンとしてこれを書き
     ます。これは、ターゲット・システム上の`putchar'と同一かもしれませ
     ん。これら2つを区別したい場合を考慮して、異なる名前が使われていま
     す。

実行中のユーザ・プログラムをGDBが停止できるようにしたいのであれば、割
り込み駆動型のシリアル・ドライバを使用して、`^C' （control-C文字、すな
わち`\003'）を受信したときに停止するよう設定する必要があります。GDBは
この文字を使って、リモート・システムに対して停止するよう通知します。

デバッグ・ターゲットが適切なステータス情報をGDBに対して返せるようにす
るためには、おそらく標準のスタブを変更する必要があるでしょう。最も美し
くなく、しかし最も手っ取り早くこれを実現する方法は、ブレイクポイント命
令を実行することです（この方法が「美しくない」のは、GDBが`SIGINT'では
なく`SIGTRAP'を報告してくる点にあります）。

ユーザが提供する必要のあるルーチンには、ほかに以下のようなものがありま
す。

`void exceptionHandler (int EXCEPTION_NUMBER, void *EXCEPTION_ADDRESS)'
     例外処理テーブルにEXCEPTION_ADDRESSを組み込むよう、この関数を書き
     ます。ユーザがこれを提供しなければならないのは、スタブにはターゲッ
     ト・システム上の例外処理テーブルがどのようなものになるかを知る手
     段がないからです（例えば、プロセッサのテーブルはROM上にあり、その
     中のエントリがRAM上のテーブルを指す、という形になっているかもしれ
     ません）。EXCEPTION_NUMBER は例外番号で、これは変更される必要があ
     ります。例外番号の意味は、アーキテクチャに依存します（例えば、0に
     よる除算、境界を無視したメモリ・アクセス等は、異なる番号によって
     表わされるかもしれません）。この例外が発生したとき、制御は直接
     EXCEPTION_ADDRESSに渡されなければならず、また、プロセッサの状態
     （スタック、レジスタなど）はプロセッサ例外が発生したときの状態と
     同じでなければなりません。したがって、EXCEPTION_ADDRESSに到達する
     のにジャンプ命令を使用したいのであれば、サブルーチン・ジャンプで
     はなく、ただのジャンプ命令を使わなければなりません。

     386では、ハンドラが実行されているときに割り込みがマスクされるよう、
     EXCEPTION_ADDRESSは割り込みゲートとして組み込まれる必要があります。
     そのゲートは特権レベル0 （最も高いレベル）でなければなりません。
     SPARC用のスタブや68k用のスタブは、`exceptionHandler'の助けを借り
     なくても自分で割り込みをマスクすることができます。

`void flush_i_cache()'
     （sparc、sparcliteのみ）ターゲット・マシンに命令キャッシュがある
     場合、それをフラッシュするようこのサブルーチンを書きます。命令キャッ
     シュがない場合には、このサブルーチンは何もしないものになるかもし
     れません。

     命令キャッシュを持つターゲット・マシン上のGDBは、ユーザ・プログラ
     ムが安定した状態にあることがこの関数によって保証されることを必要
     とします。

また、次のライブラリ・ルーチンが使用可能であることを確かめなければなり
ません。

`void *memset(void *, int, int)'
     あるメモリ領域に既知の値を設定する標準ライブラリ関数`memset'です。
     フリーの`libc.a'を持っていれば、そこに`memset'があります。フリー
     の`libc.a'がなければ、`memset'をハードウェアの供給元から入手する
     か、自分で作成する必要があります。

GNU Cコンパイラを使っていないのであれば、他の標準ライブラリ・サブルー
チンも必要になるかもしれません。これは、スタブによっても異なりますが、
一般的にスタブは、`gcc'がインライン・コードとして生成する共通ライブラ
リ・サブルーチンを使用する可能性があります。



File: gdb-ja.info, Node: Debug Session

ここまでのまとめ
................

要約すると、ユーザ・プログラムをデバッグする準備が整った後、以下の手順
に従わなければなりません。

  1. 下位レベルのサポート・ルーチンがあることを確認します（*Note What
     you must do for the stub: Bootstrapping.）。
          `getDebugChar', `putDebugChar',
          `flush_i_cache', `memset', `exceptionHandler'.

  2. ユーザ・プログラムの先頭付近に以下の行を挿入します。

          set_debug_traps();
          breakpoint();

  3. 680x0のスタブに限り、`exceptionHook'という変数を提供する必要があ
     ります。通常は、以下のように使います。

          void (*exceptionHook)() = 0;

     しかし、`set_debug_traps'が呼び出される前に、ユーザ・プログラム内
     のある関数を指すようこの変数を設定すると、トラップ（例えば、バス・
     エラー）で停止した後にGDBが処理を継続実行するときに、その関数が呼
     び出されます。`exceptionHook'によって指される関数は、1つの引数付
     きで呼び出されます。それは、`int'型の例外番号です。

  4. ユーザ・プログラム、ターゲット・アーキテクチャ用のGDBデバッグ・ス
     タブ、サポート・サブルーチンをコンパイルしリンクします。

  5. ターゲット・マシンとGDBホストとの間がシリアル接続されていることを
     確認します。また、ホスト上のシリアル・ポートの名前を調べます。

  6. ターゲット・マシンにユーザ・プログラムをダウンロードし（あるいは、
     製造元の提供する手段によってターゲット・マシンにユーザ・プログラ
     ムを持っていき）、起動します。

  7. リモート・デバッグを開始するには、ホスト・マシン上でGDBを実行し、
     リモート・マシン上で実行中のプログラムを実行ファイルとして指定し
     ます。これにより、ユーザ・プログラムのシンボルとテキスト域の内容
     を見つける方法がGDBに通知されます。

     次に`target remote'コマンドを使って通信を確立します。引数には、シ
     リアル回線に接続された装置名または（通常はターゲットと接続された
     シリアル回線を持つ端末サーバの）TCPポートを指定することで、ターゲッ
     ト・マシンとの通信方法を指定します。例えば、`/dev/ttyb'という名前
     の装置に接続されているシリアル回線を使うには、

          target remote /dev/ttyb

     とします。

     TCP接続を使うには、`HOST:PORT'という形式の引数を使用します。例え
     ば、`manyfarms'という名前の端末サーバのポート2828に接続するには、

          target remote manyfarms:2828

     とします。

@noindent

ここまでくると、データの値の調査、変更、リモート・プログラムのステップ
実行、継続実行に通常使用するすべてのコマンドを使用することができます。

リモート・プログラムの実行を再開し、デバッグするのをやめるには、
`detach'コマンドを使います。

GDBがリモート・プログラムを待っているときにはいつでも、割り込み文字
（多くの場合C-C）を入力すると、GDBはそのプログラムを停止しようとします。
これは成功することも失敗することもありますが、その成否は、リモート・シ
ステムのハードウェアやシリアル・ドライバにも依存します。割り込み文字を
再度入力すると、GDBは以下のプロンプトを表示します。

     Interrupted while waiting for the program.
     Give up (and stop debugging it)?  (y or n)

ここで`y'を入力すると、GDBはリモート・デバッグ・セッションを破棄します
（後になって再実行したくなった場合には、接続するために`target remote'
を再度使用します）。`n'を入力すると、GDBは再び待ち状態になります。



File: gdb-ja.info, Node: Protocol

通信プロトコル
..............

GDBとともに提供されるスタブ・ファイルは、ターゲット側の通信プロトコル
を実装します。そしてGDB側の通信プロトコルは、GDBのソース・ファイル
`remote.c'に実装されています。通常は、これらのサブルーチンに通信処理を
任せて、詳細を無視することができます（独自のスタブ・ファイルを作成する
ときでも、詳細については無視して、既存のスタブ・ファイルをもとにして作
成を始めることができます。`sparc-stub.c'が最もよく整理されており、した
がって最も読みやすくなっています）。

しかし、場合によっては、プロトコルについて何かを知る必要が出てくること
もあるでしょう。例えば、ターゲット・マシンにシリアル・ポートが1つしか
なく、GDBに対して送られてきたパケットを検出したときに、ユーザ・プログ
ラムが何か特別なことをするようにしたい場合です。

（単一文字による確認メッセージを除く）すべてのGDBコマンドとそれに対す
る応答は、チェックサムを含むパケットとして送信されます。パケットは、文
字`$'で始まり、文字`#'に2桁のチェックサム値が続いて終わります。

     $PACKET INFO#CHECKSUM

ここで、CHECKSUMはPACKET INFOのすべての文字の値を合計したものを256で割っ
た余りとして計算されます。

ホスト・マシンまたはターゲット・マシンがパケットを受信したとき、最初に
期待される応答は確認メッセージです。これは単一文字で、（パッケージが正
しく受信されたことを示す）`+'または（再送要求を示す）`-'です。

ホスト（GDB）がコマンドを送信し、ターゲット（ユーザ・プログラムに組み
込まれたデバッグ・スタブ）が応答としてデータを送信します。ターゲットは、
ユーザ・プログラムが停止したときにも、データを送信します。

コマンド・パケットは最初の文字で区別されます。最初の文字がコマンドの種
類を表わします。

以下に、現在サポートされているコマンドをいくつか列挙します（コマンドの
完全なリストについては`gdb/remote.c'を参照してください）。

`g'
     CPUレジスタの値を要求します。

`G'
     CPUレジスタの値を設定します。

`mADDR,COUNT'
     ADDRで示される位置からCOUNTで示されるバイト数を読み込みます。

`MADDR,COUNT:...'
     ADDRで示される位置からCOUNTで示されるバイト数を書き込みます。

`c'
`cADDR'
     カレントなアドレス（ADDRが指定されているのであれば、それによって
     指定されるアドレスから）実行を再開します。

`s'
`sADDR'
     プログラム・カウンタの指すカレントな箇所から（ADDRが指定されてい
     るのであれば、それによって指定されるアドレスから）ターゲット・プ
     ログラムを1命令だけステップ実行します。

`k'
     ターゲット・プログラムを終了させます。

`?'
     最後に受信したシグナルを報告します。GDBのシグナル処理コマンドを利
     用できるように、デバッグ・スタブの中のある関数が、CPUトラップを対
     応するPOSIXシグナル値として報告してきます。

`T'
     リモートのスタブに対して、GDBがシングル・ステップ処理や条件付きブ
     レイクポイントに関する迅速な決定を下すのに必要となるレジスタの情
     報だけを送信するようにさせます。これによって、ステップ実行中の1命
     令ごとにすべてのレジスタの情報を入手する必要がなくなります。

     現在のGDBは、レジスタへのライト・スルー・キャッシュを実装していて、
     ターゲットが実行された場合のみ、レジスタを再度読み込みます。

シリアル接続に問題がある場合には、`set remotedebug'コマンドを使うこと
ができます。これによりGDBは、シリアル回線経由でリモート・マシンとの間
で送受信したすべてのパケットを報告するようになります。パケット・デバッ
グ用の情報はGDBの標準出力ストリームに表示されます。`set remotedebug
off'によってこの設定が解除され、`show remotedebug'によって現在の設定が
表示されます。



File: gdb-ja.info, Node: Server

`gdbserver'プログラムの使用
...........................

`gdbserver'は、UNIX系システム用の制御プログラムで、これにより、通常の
デバッグ用スタブをリンクすることなく、`target remote'コマンドによって、
ユーザ・プログラムをリモートのGDBに接続することができます。

`gdbserver'は、デバッグ用スタブに完全に取って代わるものではありません。
`gdbserver'は、GDBが必要とするのと同様のオペレーティング・システムの機
能を基本的には必要とするからです。実際、リモートのGDBと接続するために
`gdbserver'を実行できるシステムであれば、GDBをローカルに実行することも
可能です。それでも、`gdbserver'はGDBと比較するとかなりサイズが小さいの
で、便利なことがあります。また、`gdbserver'の移植はGDB全体の移植よりも
簡単なので、`gdbserver'を使うことで、新しいシステムでの作業をより早く
開始することができます、最後に、リアル・タイム・システムの開発をしてい
る場合、リアル・タイムな操作に関わるトレードオフのために、例えばクロス・
コンパイルなどによって、他のシステム上で可能な限り多くの開発作業を行っ
たほうが便利であるということがあるでしょう。デバッグ作業に関しても、
`gdbserver'を使うことでこれと同じような選択を行うことができます。

GDBと`gdbserver'は、シリアル回線またはTCP接続を経由して、標準的なGDBリ
モート・シリアル・プロトコルによって通信します。

*ターゲット・マシンでは：*
     デバッグしたいプログラムのコピーが1つ必要です。`gdbserver'はユー
     ザ・プログラムのシンボル・テーブルを必要とはしませんので、スペー
     スの節約が必要であれば、プログラムをストリップすることができます。
     ホスト・システム上のGDBが、シンボルに関するすべての処理を実行しま
     す。

     `gdbserver'を使うには、GDBとの通信方法、ユーザ・プログラムの名前、
     ユーザ・プログラムへの引数を教えてやる必要があります。構文は、以
     下のとおりです。

          target> gdbserver COMM PROGRAM [ ARGS ... ]

     COMMは（シリアル回線を使うための）装置名、あるいは、TCPのホスト名
     とポート番号です。例えば、`foo.txt'という引数を指定してEmacsをデ
     バッグし、シリアル・ポート`/dev/com1'経由でGDBと通信するには、以
     下のように実行します。

          target> gdbserver /dev/com1 emacs foo.txt

     `gdbserver'は、ホスト側のGDBが通信してくるのを受動的に待ちます。

     シリアル回線の代わりにTCP接続を使うには、以下のようにします。

          target> gdbserver host:2345 emacs foo.txt

     前の例との唯一の違いは第1引数です。これは、ホストのGDBとTCPによっ
     て接続することを指定しています。`host:2345'は、マシン`host'からロー
     カルのTCPポート2345へのTCP接続を`gdbserver'が期待していることを意
     味します（現在のバージョンでは、`host'の部分は無視されます）。ター
     ゲット・システム上で既に使われているTCPポートでなければ、任意の番
     号をポート番号として選択できます（例えば、`23'は`telnet'に予約さ
     れています） (1) (*Note Server-Footnotes::)。ここで指定したのと同
     じポート番号を、ホスト上のGDBの`target remote'コマンドで使わなけ
     ればなりません。

*GDBのホスト・マシンでは：*
     GDBはシンボル情報、
     デバッグ情報を必要とするので、
     ストリップされていないユーザ・プログラムのコピーが必要です。
     通常どおり、
     第1引数にユーザ・プログラムのローカル・コピーの名前を指定してGDBを起動します
     （シリアル回線の速度が9600 bps以外であれば、
     `--baud'オプションも必要になります）。
     その後、
     `target remote'コマンドによって`gdbserver'との通信を確立します。
     引数には、
     装置名
     （通常は`/dev/ttyb'のようなシリアル装置）、
     または、
     `HOST:PORT'という形式でのTCPポート記述子を指定します。
     例えば、

          (gdb) target remote /dev/ttyb

     では、シリアル回線`/dev/ttyb'を介して`gdbserver'と通信します。ま
     た、

          (gdb) target remote the-target:2345

     では、
     ホスト`the-target'上のポート2345に対するTCP接続によって通信します。
     TCP接続を使う場合には、
     `target remote'コマンドを実行する前に、
     `gdbserver'を起動しておかなければなりません。
     そうしないと、エラーになります。
     エラー・テキストの内容はホスト・システムによって異なりますが、
     通常は`Connection refused'のような内容です。



File: gdb-ja.info  Node: Server-Footnotes, Up: Server

(1) 原注：他のサービスによって使用されているポート番号を選択する
と、`gdbserver'はエラー・メッセージを出力して終了します。


File: gdb-ja.info, Node: NetWare

`gdbserve.nlm'プログラムの使用
..............................

`gdbserve.nlm'はNetWareシステムでの制御プログラムです。これによって、
`target remote'コマンドでユーザ・プログラムをリモートのGDBに接続するこ
とができます。

GDBと`gdbserve.nlm'は、標準のGDBリモート・シリアル・プロトコルを使って、
シリアル回線経由で通信します。

*ターゲット・マシンでは：*
     デバッグしたいプログラムのコピーが1つ必要です。`gdbserve.nlm'はユー
     ザ・プログラムのシンボル・テーブルを必要とはしませんので、スペー
     スの節約が必要であれば、プログラムをストリップすることができます。
     ホスト・システム上のGDBが、シンボルに関わるすべての処理を実行しま
     す。

     `gdbserve.nlm'を使うには、GDBとの通信方法、ユーザ・プログラムの名
     前、ユーザ・プログラムの引数を教えてやる必要があります。構文は、
     以下のとおりです。

          load gdbserve [ BOARD=BOARD ] [ PORT=PORT ]
                        [ BAUD=BAUD ] PROGRAM [ ARGS ... ]

     BOARDとPORTがシリアル回線を指定します。BAUDは接続に使われるボーレー
     トを指定します。PORTとNODEのデフォルト値は0、BAUDのデフォルト値は
     9600 bpsです。

     例えば、`foo.txt'という引数を指定してEmacsをデバッグし、シリアル・
     ポート番号2、ボード1を経由して19200 bpsの接続でGDBと通信するには、
     以下のように実行します。

          load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt

*GDBのホスト・マシンでは：*
     GDBはシンボル情報、
     デバッグ情報を必要とするので、
     ストリップされていないユーザ・プログラムのコピーが必要です。
     通常どおり、
     第1引数にユーザ・プログラムのローカル・コピーの名前を指定してGDBを起動します
     （シリアル回線の速度が9600 bps以外であれば、
     `--baud'オプションも必要になります）。
     その後、
     `target remote'コマンドによって
     `gdbserve.nlm'との通信を確立します。
     引数には、
     装置名
     （通常は`/dev/ttyb'のようなシリアル装置）
     を指定します。
     例えば、

          (gdb) target remote /dev/ttyb

     は、シリアル回線`/dev/ttyb'を経由して`gdbserve.nlm'と通信します。




File: gdb-ja.info, Node: i960-Nindy Remote

GDBとリモートi960（Nindy）
--------------------------

"Nindy"は、Intel 960ターゲット・システム用のROM Monitorプログラムです。
Nindyを使ってリモートのIntel 960を制御するようGDBが構成されている場合、
いくつかの方法によってGDBに960との接続方法を教えることができます。

   * シリアル・ポート、Nindyプロトコルのバージョン、通信スピードを指定
     するコマンドライン・オプションによる方法

   * 起動時のプロンプトに答える方法

   * GDBセッション中の任意の時点で`target'コマンドを使う方法（*Note
     Commands for managing targets: Target Commands）


* Menu:

* Nindy Startup::               Nindy使用時の起動方法
* Nindy Options::               Nindy用のオプション
* Nindy Reset::                 Nindy resetコマンド



File: gdb-ja.info, Node: Nindy Startup

Nindy使用時の起動方法
.....................

コマンドライン・オプションを一切使わずに`gdb'を起動すると、通常のGDBプ
ロンプトが表示される*前*に、使用するシリアル・ポートを指定するよう促さ
れます。

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:  

このプロンプトに対して、使いたいシリアル・ポートを示す（`/dev/tty'の後
ろの）サフィックスを入力します。もしそうしたいのであれば、プロンプトに
空行で答えることによって、Nindyとの接続を確立せずに起動することもでき
ます。この場合、後にNindyと接続したいときには`target'コマンドを使いま
す（*Note Commands for managing targets: Target Commands.）。



File: gdb-ja.info, Node: Nindy Options

Nindy用のオプション
...................

接続されたNindy-960ボードとのGDBセッションを開始するための起動オプショ
ンを以下に示します。

`-r PORT'
     ターゲット・システムとの接続に使用されるシリアル・インターフェイ
     スのシリアル・ポート名を指定します。このオプションは、GDBがIntel
     960ターゲット・アーキテクチャ用に構成されているときのみ利用可能で
     す。PORTは、完全なパス名（例：`-r /dev/ttya'）、`/dev'配下のデバ
     イス名（例：`-r ttya'）、`tty'固有の一意なサフィックス（例：`-r
     a'）のいずれによっても指定することができます。

`-O'
     （ゼロではなく、英大文字のOです）。GDBがターゲット・システムと接
     続する際に、古いNindyモニタ・プロトコルを使用すべきであることを指
     定します。このオプションは、GDBがIntel 960ターゲット・アーキテク
     チャ用に構成されているときのみ利用可能です。

          *注意*：`-O'を指定したにもかかわらず、実際にはより新しいプロ
          トコルを期待しているターゲット・システムに接続しようとした場
          合、接続は失敗します。この失敗は、あたかも通信速度の不一致が
          原因であるかのように見えてしまいます。GDBは、異なる回線速度
          によって再接続を繰り返し試みます。割り込みによって、この処理
          を中断させることができます。

`-brk'
     接続する前にNindyターゲットをリセットするために、ターゲット・シス
     テムに対して最初に`BREAK'信号を送信するよう、GDBに対して指定しま
     す。

          *注意*：多くのターゲット・システムは、このオプションが必要と
          するハードウェアを備えていません。このオプションは、少数のボー
          ドでしか機能しません。

標準の`-b'オプションが、シリアル・ポート上で使用される回線速度を制御し
ます。



File: gdb-ja.info, Node: Nindy Reset

Nindy resetコマンド
...................

`reset'
     ターゲットがNindyである場合、このコマンドはBREAK信号をリモートの
     ターゲット・システムに送信します。これは、BREAK信号を受信したとき
     にハード・リセット（または、その他の興味深いアクション）を実行す
     る回路がターゲットに備わっている場合にのみ役に立ちます。



File: gdb-ja.info, Node: UDI29K Remote

AMD29K用のUDIプロトコル
-----------------------

GDBは、a29kプロセッサ・ファミリをデバッグするためのAMD UDI （Universal
Debugger Interface）プロトコルをサポートしています。MiniMONモニタを実
行するAMDターゲットという構成を使うには、AMD社から無料で入手可能な
`MONTIP'プログラムが必要になります。また、AMD社から入手可能なUDI準拠の
a29kシミュレータ・プログラム`ISSTIP'とともにGDBを使うこともできます。

`target udi KEYWORD'
     リモートのa29kボードまたはシミュレータへのUDIインターフェイスを選
     択します。KEYWORDは、AMD構成ファイル`udi_soc'内のエントリです。こ
     のファイルには、a29kターゲットに接続するときに使われるパラメータ
     を指定するキーワード・エントリが含まれます。`udi_soc'ファイルが作
     業ディレクトリにない場合には、環境変数`UDICONF'にそのパス名を設定
     しなければなりません。



File: gdb-ja.info, Node: EB29K Remote

AMD29KのEBMONプロトコル
-----------------------


AMD社は、PC組み込み用の29K開発ボードを、DOS上で動作する`EBMON'というモ
ニタ・プログラムとともに配布しています。この開発システムは、省略して
EB29Kと呼ばれます。UNIXシステム上のGDBを使ってEB29Kボード上でプログラ
ムを実行するには、まず（EB29Kを組み込んだ）PCとUNIXシステムのシリアル・
ポートの間をシリアル回線で接続しなければなりません。以下の節では、PCの
`COM1'ポートとUNIXシステムの`/dev/ttya'との間をケーブルで接続してある
ものと仮定します。

* Menu:

* Comms (EB29K)::               通信セットアップ
* gdb-EB29K::                   EB29Kクロス・デバッグ
* Remote Log::                  リモート・ログ



File: gdb-ja.info, Node: Comms (EB29K)

通信セットアップ
................

PC上のDOSで以下のように実行することによって、PCのポートをセットアップ
します。

     C:\> MODE com1:9600,n,8,1,none

MS DOS 4.0上で実行されているこの例では、PCポートを通信速度9600 bps、パ
リティ・ビットなし、データ・ビット数8、ストップ・ビット数1、リトライな
しに設定しています。UNIX側を設定する際には、同一の通信パラメータを使わ
なければなりません。

シリアル回線のUNIX側にPCの制御権を与えるには、DOSコンソール上で以下の
ように実行します。

     C:\> CTTY com1

（後に、DOSコンソールに制御を戻したいときには、`CTTY con'コマンドを使
うことができます。ただし、制御権を持っている装置からこのコマンドを送信
する必要があります。ここでの例では、`COM1'に接続されているシリアル回線
を通して送信することになります）。

UNIXのホストからは、PCと通信するのに`tip'や`cu'のような通信プログラム
を使います。以下に例を示します。

     cu -s 9600 -l /dev/ttya

ここで示されている`cu'オプションはそれぞれ、使用する回線速度とシリアル・
ポートを指定しています。`tip'コマンドを使った場合は、コマンドラインは
以下のようなものになるでしょう。

     tip -9600 /dev/ttya

ここで`tip'への引数として指定した`/dev/ttya'の部分には、システムによっ
て異なる名前を指定する必要があるかもしれません。使用するポートを含む通
信パラメータは、"remote"記述ファイルにおいて`tip'コマンドへの引数と関
連付けられます。通常このファイルは、システム・テーブル`/etc/remote'で
す。

`tip'接続または`cu'接続を使用してDOSの作業ディレクトリを29Kプログラム
が存在するディレクトリに変更し、PCプログラム`EBMON' （AMD社からボード
とともに提供されるEB29K制御プログラム）を起動します。以下に示す例によ
く似た、`EBMON'プロンプト`#'で終わる`EBMON'の初期画面が表示されるはず
です。

     C:\> G:

     G:\> CD \usr\joe\work29k

     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.

     Enter '?' or 'H' for help

     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000

     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff

     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800

     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes

     # ~.

続いて、`cu'プログラムまたは`tip'プログラムを終了させます（上の例では、
`EBMON'プロンプトにおいて`~.'を入力することで終了させています）。
`EBMON'は、GDBが制御権を獲得できる状態で、実行を継続します。

この例では、PCとUNIXシステムの両方に同一の29Kプログラムが確実に存在す
るようにするのに、おそらく最も便利であろうと思われる方法を使うことを仮
定しました。それは、PC/NFSによる接続で、UNIXホストのファイル・システム
の1つをPCの`G:'ドライブとする方法です。PC/NFS、あるいは、2つのシステム
間を接続する類似の方法がない場合、フロッピ・ディスクによる転送など、
UNIXシステムからPCへ29Kプログラムを転送するための他の手段を準備する必
要があります。GDBは、シリアル回線経由で29Kプログラムをダウンロードする
ことは*しません*。



File: gdb-ja.info, Node: gdb-EB29K

EB29Kクロス・デバッグ
.....................

最後に、UNIXシステム上の29Kプログラムが存在するディレクトリに`cd'コマ
ンドによって移動して、GDBを起動します。引数には、29Kプログラムの名前を
指定します。

     cd /usr/joe/work29k
     gdb myfoo

これで`target'コマンドが使えるようになります。

     target amd-eb /dev/ttya 9600 MYFOO

この例では、ユーザ・プログラムは`myfoo'と呼ばれるファイルであると仮定
しています。`target amd-eb'に対して最後の引数として指定するファイル名
は、DOS上でのプログラム名でなければならない点に注意してください。この
例では単に`MYFOO'となっていますが、DOSのパス名を含むこともできますし、
転送メカニズムによっては、UNIX側での名前とは似ても似つかないものになる
こともあるでしょう。

ここまでくると、好きなようにブレイクポイントを設定することができます。
29Kボード上でのプログラムの実行を監視する準備が整えば、GDBの`run'コマ
ンドを使います。

リモート・プログラムのデバッグを停止するには、GDBの`detach'コマンドを
使います。

PCの制御をPCコンソールに戻すには、GDBセッションが終了した後に、`EBMON'
にアタッチするために、もう一度`tip'または`cu'を使います。その後、`q'コ
マンドによって`EBMON'をシャットダウンし、DOSのコマンドライン・インター
プリタに制御を戻します。`CTTY con'と入力して、入力されたコマンドがメイ
ンのDOSコンソールによって受け取られるようにし、`~.'を入力して`tip'また
は`cu'を終了させます。



File: gdb-ja.info, Node: Remote Log

リモート・ログ
..............

`target amd-eb'コマンドは、接続に関わる問題のデバッグを支援するため、
カレントな作業ディレクトリに`eb.log'というファイルを作成します。
`eb.log'は、`EBMON'に送信されたコマンドのエコーを含む、`EBMON'からのす
べての出力を記録します。別のウィンドウ内でこのファイルに対して`tail
-f'を実行すると、`EBMON'に関わる問題やPC側での予期せぬイベントを理解す
る助けになることがよくあります。




File: gdb-ja.info, Node: ST2000 Remote

GDBとTandem ST2000
------------------

ST2000をホスト・システムに接続する方法については、製造元のマニュアルを
参照してください。ST2000が物理的に接続されれば、それをデバッグ環境とし
て確立するには、以下を実行します。

     target st2000 DEV SPEED

DEVは通常、シリアル回線によってST2000と接続される`/dev/ttya'のようなシ
リアル装置の名前です。代わりに、`HOSTNAME:PORTNUMBER'という構文を使っ
て（例えば、端末多重化装置経由で接続されたシリアル回線への）TCP接続と
してDEVを指定することもできます。

このターゲットに対して、`load'コマンドと`attach'コマンドは定義されて*
いません*。通常スタンドアロンで操作している場合と同様、ST2000にユーザ・
プログラムをロードしなければなりません。GDBは（シンボルのような）デバッ
グ用の情報を、ホスト・コンピュータ上にある別のデバッグ・バージョンのプ
ログラムから読みとります。

ST2000での作業を支援するために、以下の補助的なGDBコマンドが利用可能で
す。

`st2000 COMMAND'
     STDBUGモニタにCOMMANDを送信します。利用できるコマンドについては、
     製造元のマニュアルを参照してください。

`connect'
     STDBUGコマンド・モニタに対して制御端末を接続します。STDBUGの操作
     が終了した後、`RET~.'  （Returnキーに続いて、チルダとピリオドを入
     力）、または、`RET~C-d' （Returnキーに続いて、チルダとControl-Dを
     入力）のいずれかを入力することによってGDBコマンド・プロンプトに戻
     ります。



File: gdb-ja.info, Node: VxWorks Remote

GDBとVxWorks
------------

開発者は、GDBを使用することによって、ネットワークに接続されたVxWorks端
末上のタスクを、UNIXのホストから起動してデバッグすることができます。
VxWorksシェルから起動され、既に実行中の状態のタスクをデバッグすること
もできます。GDBは、UNIXホスト上で実行されるコードとVxWorksターゲット上
で実行されるコードの両方を使います。`gdb'は、UNIXホスト上にインストー
ルされて実行されます（ホスト上のプログラムをデバッグするのに使うGDBと
区別するために、`vxgdb'という名前でインストールされることもあります）。

`VxWorks-timeout ARGS'
     すべてのVxWorksベースのターゲットが、`vxworks-timeout'オプション
     をサポートするようになりました。このオプションはユーザによってセッ
     トされるもので、ARGSは、GDBがRPCの応答を待つ秒数を表わします。実
     際のVxWorksターゲットが速度の遅いソフトウェア・シミュレータであっ
     たり、帯域の小さいネットワーク回線を介して遠距離にある場合などに
     使うとよいでしょう。

VxWorksとの接続に関する以下の情報は、このマニュアルの作成時における最
新の情報です。新しくリリースされたVxWorksでは、手順が変更されているか
もしれません。

VxWorks上でGDBを使うためには、VxWorksカーネルを再構築して、VxWorksライ
ブラリ`rdb.a'の中のリモート・デバッグ用のインターフェイス・ルーチンを
組み込む必要があります。そのためには、VxWorksのコンフィギュレーション・
ファイル`configAll.h'の中で`INCLUDE_RDB'を定義して、VxWorksカーネルを
再構築します。この結果として生成されるカーネルには`rdb.a'が組み込まれ、
VxWorksの起動時にソース・デバッグ用のタスク`tRdbTask'が起動されます。
VxWorksの構成や再構築に関する詳細については、製造元のマニュアルを参照
してください。

VxWorksシステム・イメージへの`rdb.a'の組み込みが終わり、UNIXの実行ファ
イル・サーチ・パスにGDBの存在するパスを加えれば、GDBを実行するための準
備は完了です。UNIXホストから`gdb' （インストールの方法によっては
`vxgdb'）を実行します。

GDBが起動されて、以下のプロンプトを表示します。

     (vxgdb)

* Menu:

* VxWorks Connection::          VxWorksへの接続
* VxWorks Download::            VxWorksダウンロード
* VxWorks Attach::              タスクの実行



File: gdb-ja.info, Node: VxWorks Connection

VxWorksへの接続
...............

GDBの`target'コマンドによって、ネットワーク上のVxWorksターゲットに接続
します。`tt'というホスト名を持つターゲットに接続するには、以下のように
します。

     (vxgdb) target vxworks tt

GDBは以下のようなメッセージを表示します。

     Attaching remote machine across net... 
     Connected to tt.

続いてGDBは、最後にVxWorksターゲットが起動されたときより後にロードされ
たオブジェクト・モジュールのシンボル・テーブルを読み込もうと試みます。
GDBは、コマンドのサーチ・パスに含まれているディレクトリを探索すること
によって、これらのファイルを見つけます（*Note Your program's
environment: Environment.）。オブジェクト・ファイルを見つけることがで
きない場合には、以下のようなメッセージを表示します。

     prog.o: No such file or directory.

このような場合には、GDBの`path'コマンドによって適切なディレクトリを検
索パスに加えてから、再度`target'コマンドを実行します。



File: gdb-ja.info, Node: VxWorks Download

VxWorksダウンロード
...................

VxWorksターゲットに接続済みの状態で、まだロードされていないオブジェク
トをデバッグしたい場合には、GDBの`load'コマンドを使ってUNIXからVxWorks
へ追加的にファイルをダウンロードすることができます。`load'コマンドの引
数として指定されたオブジェクト・ファイルは、実際には2回オープンされま
す。まず、コードをダウンロードするためにVxWorksターゲットによってオー
プンされ、次にシンボル・テーブルを読み込むためにGDBによってオープンさ
れます。2つのシステム上のカレントな作業ディレクトリが異なると、問題が
発生します。両方のシステムが同一のファイル・システムをNFSマウントして
いるのであれば、絶対パスを使うことで問題を回避することができます。そう
でない場合は、両方のシステム上で、オブジェクト・ファイルが存在するディ
レクトリを作業ディレクトリにして、パスを一切使わずにファイル名だけでファ
イルを参照するのが、最も簡単でしょう。例えば、プログラム`prog.o'が、
VxWorksでは`VXPATH/vw/demo/rdb'に存在し、ホストでは
`HOSTPATH/vw/demo/rdb'に存在するとしましょう。このプログラムをロードす
るには、VxWorks上で以下のように実行します。

     -> cd "VXPATH/vw/demo/rdb"

GDB上では、以下のように実行します。

     (vxgdb) cd HOSTPATH/vw/demo/rdb 
     (vxgdb) load prog.o

GDBは次のような応答を表示します。

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

ソース・ファイルを編集して再コンパイルした後に、`load'コマンドを使って
オブジェクト・モジュールを再ロードすることもできます。ただし、これを行
うと、GDBはその時点で定義されているすべてのブレイクポイント、自動表示
設定、コンビニエンス変数を削除し、値ヒストリを初期化してしまいますので、
注意してください（これは、ターゲット・システムのシンボル・テーブルを参
照するデバッガのデータ構造の完全性を保つために必要です）。



File: gdb-ja.info, Node: VxWorks Attach

タスクの実行
............

以下のように`attach'コマンドを使うことで、既存のタスクにアタッチするこ
とも可能です。

     (vxgdb) attach TASK

TASKは、VxWorksの16進数のタスクIDです。アタッチするときに、タスクは実
行中であってもサスペンドされていても構いません。実行中であったタスクは、
アタッチされたときにサスペンドされます。



File: gdb-ja.info, Node: Sparclet Remote

GDB と Sparclet
---------------

開発者は、GDBを使うことによって、Sparcletターゲット上で実行中のタスク
をUnixホストからデバッグできるようになります。GDBは、Unixホスト上で実
行されるコードとSparcletターゲット上で実行されるコードの両方を使用しま
す。`gdb'は、Unixホスト上にインストールされて実行されます。

`timeout ARGS'
     GDBはオプション`remotetimeout'をサポートするようになりました。こ
     のオプションはユーザによって設定されるもので、ARGSはGDBが応答を待
     つ秒数を表わします。

デバッグ用にコンパイルする際には、デバッグ情報を得るために"-g"オプショ
ンを、また、ターゲット上でロードしたい位置にプログラムを再配置するため
に"-Ttext"オプションを指定します。各セクションのサイズを小さくするため
に、"-n"または"-N"オプションを加えるのも良いでしょう。

     sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N

アドレスが意図したものと一致しているかどうかを検証するのに、objdumpを
使うことができます。

     sparclet-aout-objdump --headers --syms prog

GDBが見つかるようにUnixの実行サーチ・パスを設定すれば、GDBを実行するた
めの準備は完了です。Unixホストから`gdb' （インストールの方法によっては、
`sparclet-aout-gdb'）を実行します。

GDBが起動されて、以下のプロンプトを表示します。

     (gdbslet)

* Menu:

* Sparclet File::                デバッグするファイルの選択
* Sparclet Connection::          Sparcletへの接続
* Sparclet Download::            Sparcletダウンロード
* Sparclet Execution::           実行とデバッグ



