Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.





File: gdb-ja.info, Node: Sparclet File

デバッグするファイルの選択
..........................

GDBの`file'コマンドによって、デバッグするプログラムを選択することがで
きます。

     (gdbslet) file prog

このコマンドを実行すると、GDBは`prog'のシンボル・テーブルを読み込もう
とします。GDBは、コマンド・サーチ・パスに含まれるディレクトリを探索す
ることによって、そのファイルを見つけます。そのファイルがデバッグ情報付
き（オプション"-g"）でコンパイルされた場合は、ソース・ファイルも探しま
す。GDBは、ディレクトリ・サーチ・パス（*Note Your program's
environment: Environment.）に含まれるディレクトリを探索することによっ
て、そのソース・ファイルを見つけます。ファイルが見つからない場合には、
次のようなメッセージを表示します。

     prog: No such file or directory.

このメッセージが表示された場合には、GDBの`path'コマンドと`dir'コマンド
を使って適切なディレクトリをサーチ・パスに加えてから、`target'コマンド
を再実行します。



File: gdb-ja.info, Node: Sparclet Connection

Sparcletへの接続
................

GDBの`target'コマンドによってSparcletターゲットに接続することができま
す。シリアル・ポート"`ttya'"でターゲットに接続するには、以下のように入
力します。

     (gdbslet) target sparclet /dev/ttya
     Remote target sparclet connected to /dev/ttya
     main () at ../prog.c:3 

GDBは以下のようなメッセージを表示します。

     Connected to ttya.



File: gdb-ja.info, Node: Sparclet Download

Sparcletダウンロード
....................

Sparcletターゲットへの接続が完了すると、GDBの`load'コマンドを使って、
ホストからターゲットへファイルをダウンロードすることができます。ファイ
ル名とロード・オフセットを、`load'コマンドへの引数として渡さなければな
りません。ファイル形式はaoutですので、プログラムはその開始アドレスにロー
ドされなければなりません。開始アドレスの値を知るにはobjdumpを使うこと
ができます。ロード・オフセットとは、ファイルの個々のセクションのVMA
（仮想メモリ・アドレス）に加算されるオフセットのことです。例えば、プロ
グラム`prog'が、textセクションのアドレス0x12010000、dataセクションのア
ドレス0x12010160、bssセクションのアドレス0x12010170にリンクされている
とすると、GDBでは以下のように入力します。

     (gdbslet) load prog 0x12010000
     Loading section .text, size 0xdb0 vma 0x12010000

プログラムがリンクされたアドレスとは異なるアドレスにコードがロードされ
た場合、どこにシンボル・テーブルをマップするかをGDBに通知するために、
`section'コマンドと`add-symbol-file'コマンドを使う必要があるかもしれま
せん。



File: gdb-ja.info, Node: Sparclet Execution

実行とデバッグ
..............

以上により、GDBの実行制御コマンドである`b'、`step'、`run'などを使って
タスクのデバッグを開始することができます。コマンドの一覧については、
GDBのマニュアルを参照してください。

     (gdbslet) b main
     Breakpoint 1 at 0x12010000: file prog.c, line 3.
     (gdbslet) run 
     Starting program: prog
     Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
     3        char *symarg = 0;
     (gdbslet) step
     4        char *execarg = "hello!";
     (gdbslet)                           




File: gdb-ja.info, Node: Hitachi Remote

GDBと日立のマイクロ・プロセッサ
-------------------------------

日立のSH、H8/300、H8/500と通信するためには、GDBは以下の情報を知ってい
る必要があります。

  1. ユーザは、日立マイクロ・プロセッサへのリモート・デバッグ用インター
     フェイスである`target hms'と、日立SHや日立300Hのインサーキット・
     エミュレータであるtarget`e7000'のどちらを使用したいかということ
     （GDBが日立SH、H8/300、H8/500用に特に構成されている場合には、
     `target hms'がデフォルトです）。

  2. ホストと日立ボードを接続しているシリアル装置（デフォルトは、ホス
     ト上で利用できる最初のシリアル装置です）

  3. シリアル装置で使用する速度

* Menu:

* Hitachi Boards::      日立ボードへの接続
* Hitachi ICE::         E7000インサーキット・エミュレータの使用
* Hitachi Special::     日立マイクロ・プロセッサ用の特別なGDBコマンド



File: gdb-ja.info, Node: Hitachi Boards

日立ボードへの接続
..................

シリアル装置を明示的に指定する必要があれば、そのための専用コマンドであ
る、`gdb'の`device PORT'コマンドを使用します。PORTのデフォルトは、ホス
ト上で最初に利用可能なポートです。これはUNIXホスト上でのみ必要であり、
そこでは典型的には`/dev/ttya'という名前になります。

`gdb'には、
通信速度を設定するための専用コマンド`speed BPS'があります。
このコマンドもまた
UNIXホストからのみ使用されるものです。
DOSホストでは通常どおり、
GDBからではなくDOSの`mode'コマンドによって回線速度を設定します
（例えば、
9600 bpsの接続を確立するには`mode com2:9600,n,8,1,p'のように実行します）。

`device'コマンドと`speed'コマンドは、日立マイクロ・プロセッサ・プログ
ラムのデバッグにUNIXホストを使う場合のみ利用可能です。DOSホストを使う
場合、GDBは、PCのシリアル・ポート経由で開発ボードと通信するのに、
`asynctsr'と呼ばれる補助的な常駐プログラムに依存します。DOS側でシリア
ル・ポートの設定をする場合にも、DOSの`mode'コマンドを使わなければなり
ません。




File: gdb-ja.info, Node: Hitachi ICE

E7000インサーキット・エミュレータの使用
.......................................

E7000インサーキット・エミュレータを使って、日立SHまたはH8/300H用のコー
ドを開発することができます。`target e7000'コマンドを以下のいずれかの形
式で使って、GDBをE7000に接続します。

`target e7000 PORT SPEED'
     E7000がシリアル・ポートに接続されている場合は、この形式を使ってく
     ださい。引数PORTが、使用するシリアル・ポートを指定します（例えば、
     `com2'）。3番目の引数は、秒あたりのビット数による回線速度です（例
     えば、`9600'）。

`target e7000 HOSTNAME'
     E7000がTCP/IPネットワーク上のホストとしてインストールされている場
     合、ホスト名だけを指定することもできます。GDBは接続に`telnet'を使
     います。



File: gdb-ja.info, Node: Hitachi Special

日立マイクロ・プロセッサ用の特別なGDBコマンド
.............................................

いくつかのGDBコマンドは、H8/300またはH8/500用に構成された場合にのみ利
用可能です。

`set machine h8300'
`set machine h8300h'
     `set machine'コマンドによって、2種類のH8/300アーキテクチャのどち
     らか一方にあわせてGDBを調整します。`show machine'コマンドによって、
     現在有効なアーキテクチャを調べることができます。

`set memory MOD'
`show memory'
     `set memory'コマンドによって、使用中のH8/500メモリ・モデル（MOD）
     を指定します。`show memory'コマンドによって、現在有効なメモリ・モ
     デルを調べます。MODに指定可能な値は、`small'、`big'、`medium'、
     `compact'のいずれかです。




File: gdb-ja.info, Node: MIPS Remote

GDBとリモートMIPSボード
-----------------------

GDBは、MIPSのリモート・デバッグ用のプロトコルを使って、シリアル回線に
接続されたMIPSボードと通信することができます。これは、GDBを
`--target=mips-idt-ecoff'によって構成することによって、利用することが
できます。

ターゲット・ボードとの接続を指定するには、以下のGDBコマンドを使用しま
す。

`target mips PORT'
     ボード上でプログラムを実行するには、引数にユーザ・プログラムの名
     前を指定して`gdb'を起動します。ボードに接続するには、`target mips
     PORT'コマンドを使用します。PORTは、ボードに接続されているシリアル・
     ポートの名前です。プログラムがまだボードにダウンロードされていな
     いのであれば、`load'コマンドを使ってダウンロードすることができま
     す。その後、通常利用できるすべてのGDBコマンドを使うことができます。

     例えば以下の手順では、デバッガを使うことによって、シリアル・ポー
     トを経由してターゲット・ボードに接続した後に、PROGと呼ばれるプロ
     グラムをロードして実行しています。

          host$ gdb PROG
          GDB is free software and ...
          (gdb) target mips /dev/ttyb
          (gdb) load PROG
          (gdb) run

`target mips HOSTNAME:PORTNUMBER'
     GDBのホスト構成によっては、`HOSTNAME:PORTNUMBER'という構文を使う
     ことで、シリアル・ポートの代わりに（例えば、端末多重化装置によっ
     て管理されているシリアル回線への）TCP接続を指定することができます。

`target pmon PORT'

`target ddb PORT'

`target lsi PORT'



GDBは、MIPSターゲットに対して、以下の特別なコマンドもサポートしていま
す。

`set processor ARGS'
`show processor'
     プロセッサの種類に固有のレジスタにアクセスしたい場合には、`set
     processor'コマンドを使ってMIPSプロセッサの種類を設定します。例え
     ば、`set processor r3041'は、3041チップで有効なCPOレジスタを使う
     よう、GDBに対して通知します。GDBが使っているMIPSプロセッサの種類
     を知るには、`show processor'コマンドを使います。GDBが使っているレ
     ジスタを知るには、`info reg'コマンドを使います。

`set mipsfpu double'
`set mipsfpu single'
`set mipsfpu none'
`show mipsfpu'
     MIPS浮動小数点コプロセッサをサポートしないターゲット・ボードを使
     う場合は、`set mipsfpu none'コマンドを使う必要があります（このよ
     うなことが必要な場合には、初期化ファイルの中にそのコマンドを入れ
     てしまってもよいでしょう）。これによって、浮動小数値を返す関数の
     戻り値を見つける方法をGDBに知らせます。またこれにより、ボード上で
     関数を呼び出すときに、GDBは浮動小数点レジスタの内容を退避する必要
     がなくなります。R4650プロセッサ上にあるような、単精度浮動小数だけ
     をサポートする浮動小数点コプロセッサを使っている場合には、`set
     mipsfpu single'コマンドを使います。デフォルトの倍精度浮動小数点コ
     プロセッサは、`set mipsfpu double'によって選択することができます。

     以前のバージョンでは、有効な選択肢は、倍精度浮動小数コプロセッサ
     を使う設定と浮動小数点コプロセッサを使わない設定だけでした。した
     がって、`set mipsfpu on'で倍精度浮動小数コプロセッサが選択され、
     `set mipsfpu off'で浮動小数点コプロセッサを使わないという設定が選
     択されていました。

     他の場合と同様、`mipsfpu'変数に関する設定は、`show mipsfpu'によっ
     て問い合わせることができます。

`set remotedebug N'
`show remotedebug'
     `remotedebug'変数を設定することによって、ボードとの通信に関するい
     くつかのデバッグ用の情報を見ることができます。`set remotedebug 1'
     によって値`1'を設定すると、すべてのパケットが表示されます。値を
     `2'に設定すると、すべての文字が表示されます。`show remotedebug'コ
     マンドによって、いつでも現在の設定値を調べることができます。

`set timeout SECONDS'
`set retransmit-timeout SECONDS'
`show timeout'
`show retransmit-timeout'
     MIPSリモート・プロトコルにおけるパケット待ちの状態でのタイムアウ
     ト時間を、`set timeout SECONDS'コマンドで制御することができます。
     デフォルトは5秒です。同様に、パケットに対する確認（ACK）を待って
     いる状態でのタイムアウト時間を、`set retransmit-timeout SECONDS'
     コマンドで制御することができます。デフォルトは3秒です。それぞれの
     値を`show timeout'と`show retransmit-timeout'で調べることができま
     す（どちらのコマンドも、GDBが`--target=mips-idt-ecoff'用に構成さ
     れている場合*のみ*使用可能です）。

     `set timeout'で設定されたタイムアウト時間は、ユーザ・プログラムが
     停止するのをGDBが待っている間は適用されません。この場合には、GDB
     は永遠に待ち続けます。これは、停止するまでにプログラムがどの程度
     長く実行を継続するのかを知る方法がないからです。



File: gdb-ja.info, Node: Simulator

シミュレートされたCPUターゲット
-------------------------------

構成によっては、ユーザ・プログラムをデバッグする際にハードウェアCPUの
代わりに使うことのできるCPUシミュレータが、GDBの中に組み込まれています。
現在のところ、ARM、D10V、D30V、FR30、H8/300、H8/500、i960、M32R、MIPS、
MN10200、MN10300、PowerPC、SH、Sparc、V850、W65、Z8000 用のシミュレー
タが利用できます。


Z8000系については、`target sim'によって、Z8002 （Z8000アーキテクチャの、
セグメントを持たない変種）またはZ8001 （セグメントを持つ変種）をシミュ
レートします。シミュレータは、オブジェクト・コードを調べることで、どち
らのアーキテクチャが適切であるかを認識します。

`target sim ARGS'
     シミュレートされたCPU上でプログラムをデバッグします。シミュレータ
     がセットアップ・オプションをサポートしている場合は、それをARGSの
     部分に指定します。

このターゲットを指定した後には、ホスト・コンピュータ上のプログラムをデ
バッグするのと同様の方法で、シミュレートされたCPU用のプログラムをデバッ
グすることができます。新しいプログラムのイメージをロードするには`file'
コマンドを使い、ユーザ・プログラムを実行するには`run'コマンドを使う、
という具合です。

Z8000シミュレータでは、通常のマシン・レジスタ（`info reg' を参照）がす
べて利用可能であるだけでなく、特別な名前を持つレジスタとして、3つの追
加情報が提供されています。

`cycles'
     シミュレータ内のクロック・ティックをカウントします。

`insts'
     シミュレータ内で実行された命令をカウントします。

`time'
     1/60秒を単位とする実行時間を示します。

これらの変数は、
GDBの式の中で普通に参照することができます。
例えば、
`b fputc if $cycles>5000'は、
シミュレートされたクロック・ティックが最低5,000回発生した後に停止するような、
条件付きブレイクポイントを設定します。




File: gdb-ja.info, Node: Controlling GDB, Next: Sequences, Prev: Targets, Up: Top

GDBの制御
*********

`set'コマンドによってGDBの操作方法を変更することができます。GDBによる
データの表示方法を変更するコマンドについては、*Note Print settings:
Print Settings.。この章では、その他の設定について説明します。

* Menu:

* Prompt::                      プロンプト
* Editing::                     コマンド編集
* History::                     コマンド・ヒストリ
* Screen Size::                 画面サイズ
* Numbers::                     数値
* Messages/Warnings::           オプションの警告およびメッセージ



File: gdb-ja.info, Node: Prompt, Next: Editing, Prev: Controlling GDB, Up: Controlling GDB

プロンプト
==========


GDBは、"プロンプト"と呼ばれる文字列を表示することで、コマンドを受け付
ける用意ができたことを示します。通常、この文字列は`(gdb)'です。`set
prompt'コマンドによって、プロンプトの文字列を変更することができます。
例えば、GDBを使ってGDB自体をデバッグしているときには、どちらか一方の
GDBセッションのプロンプトを変更して、どちらのGDBとやりとりしているのか
区別できるようにすると便利です。

*注:* 以前のバージョンとは異なり、現在の`set prompt'は、ユーザが設定し
たプロンプトの後ろに空白を追加しません。ユーザは、空白で終わるプロンプ
ト、空白で終わらないプロンプトのいずれでも設定することができます。

`set prompt NEWPROMPT'
     今後はNEWPROMPTをプロンプトとして使用するよう、GDBに指示します

`show prompt'
     `Gdb's prompt is: YOUR-PROMPT' という形式の1行を表示します



File: gdb-ja.info, Node: Editing, Next: History, Prev: Prompt, Up: Controlling GDB

コマンド編集
============

GDBは入力コマンドを"readline"インターフェイスによって読み込みます。こ
のGNUライブラリを使うことで、ユーザに対してコマンドライン・インターフェ
イスを提供するプログラムは、統一された振る舞いをするようになります。こ
れを使うことの利点としては、GNU Emacsスタイルまたは"vi"スタイルによる
コマンドのインライン編集、`csh'スタイルのヒストリ代替、複数のデバッグ・
セッションにまたがるコマンド・ヒストリの保存と呼び出しができるようにな
ることが挙げられます。

`set'コマンドによって、GDBにおけるコマンドライン編集の振る舞いを制御す
ることができます。

`set editing'
`set editing on'
     コマンドライン編集を使用可能にします（コマンドライン編集は、デフォ
     ルトの状態で使用可能です）。

`set editing off'
     コマンドライン編集を使用不可にします。

`show editing'
     コマンドライン編集が使用可能かどうかを示します。



File: gdb-ja.info, Node: History, Next: Screen Size, Prev: Editing, Up: Controlling GDB

コマンド・ヒストリ
==================

デバッグ・セッション中にユーザが入力したコマンドをGDBに記録させること
ができるため、ユーザは実際に何が実行されたかを確実に知ることができます。
以下のコマンドを使って、GDBのコマンド・ヒストリ機能を管理します。

`set history filename FNAME'
     GDBコマンド・ヒストリ・ファイルの名前をFNAMEに設定します。GDBは、
     最初にこのファイルからコマンド・ヒストリ・リストの初期値を読み込
     み、終了時には、このファイルにセッション中のコマンド・ヒストリを
     書き込みます。コマンド・ヒストリ・リストには、ヒストリ展開機能、
     あるいは、後に列挙するヒストリ・コマンド編集文字によってアクセス
     することができます。このファイル名は、デフォルトでは環境変数
     `GDBHISTFILE'の値になりますが、この変数が設定されていない場合には
     `./.gdb_history'になります。

`set history save'
`set history save on'
     コマンド・ヒストリをファイルの中に記録します。ファイルの名前は
     `set history filename'コマンドで指定可能です。デフォルトでは、こ
     のオプションは使用不可の状態になっています。

`set history save off'
     コマンド・ヒストリをファイルの中に記録するのを停止します。

`set history size SIZE'
     GDBがヒストリ・リストの中に記録するコマンドの数を設定します。デフォ
     ルトでは、この値は環境変数`HISTSIZE'の値に設定されますが、この変
     数が設定されていない場合は256になります。

ヒストリ展開機能により、文字`!'には特別な意味が割り当てられます。*Note
Event Designators::。

`!'は、C言語における論理NOTの演算子でもあるので、ヒストリ展開機能はデ
フォルトではoffになっています。`set history expansion on'コマンドによっ
てヒストリ展開を利用できるようにした場合には、（`!'を式の中で論理NOTと
して使うのであれば）`!'の後ろに空白かタブを入れることによって、それが
展開されないようにする必要のある場合があります。ヒストリ展開が有効になっ
ている場合でも、readlineのヒストリ機能は、`!='や`!('という文字列を置き
換えようとはしません。

ヒストリ展開を制御するコマンドには、以下のようなものがあります。

`set history expansion on'
`set history expansion'
     ヒストリ展開を使用可能にします。ヒストリ展開はデフォルトでは使用
     不可です。

`set history expansion off'
     ヒストリ展開を使用不可にします。

     readlineのコードには、ヒストリ編集機能やヒストリ展開機能に関する、
     より完全なドキュメントが付属しています。GNU Emacsや`vi'のことをよ
     く知らない人は、このドキュメントを読むとよいでしょう。*Note
     Command Line Editing::。

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     これらのコマンドは、GDBのヒストリ・パラメータの状態を表示します。
     単に`show history'を実行すると、4つのパラメータの状態がすべて表示
     されます。

`show commands'
     コマンド・ヒストリ中の最後の10個のコマンドを表示します。

`show commands N'
     コマンド番号Nのコマンドを中心に、その前後の10個のコマンドを表示し
     ます。

`show commands +'
     最後に表示されたコマンドに続く10個のコマンドを表示します。



File: gdb-ja.info, Node: Screen Size, Next: Numbers, Prev: History, Up: Controlling GDB

画面サイズ
==========

GDBのコマンドは、大量の情報を画面上に出力することがあります。大量の情
報をすべて読むのを支援するために、GDBは1ページ分の情報を出力するたびに、
出力を停止してユーザからの入力を求めます。出力を継続したい場合はRETキー
を押し、残りの出力を破棄したい場合は`q'を入力します。また、画面幅の設
定によって、どこで行を折り返すかが決まります。GDBは、単純に次の行に折
り返すのではなく、出力の内容に応じて読みやすいところで折り返すよう試み
ます。

通常GDBは、termcapデータベースと`TERM'環境変数の値、さらに、`stty
rows'、`stty cols'の設定から、画面の大きさを知っています。この結果が正
しくない場合、`set height'コマンドと`set width'コマンドで画面の大きさ
の設定を変更することができます。

`set height LPP'
`show height'
`set width CPL'
`show width'
     これらの`set'コマンドは、画面の高さをLPP行に、幅をCPL桁に指定しま
     す。関連する`show'コマンドが、現在の設定を表示します。

     ゼロ行の高さを指定すると、GDBは出力がどんなに長くても、出力途中で
     一時停止することをしません。これは、出力先がファイルやエディタの
     バッファである場合に便利です。

     同様に、`set width 0'を指定することによって、GDBに行の折り返しを
     行わせないようにすることもできます。



File: gdb-ja.info, Node: Numbers, Next: Messages/Warnings, Prev: Screen Size, Up: Controlling GDB

数値
====

GDBに対して8進、10進、16進の数値を慣例にしたがって入力することはいつで
も可能です。8進数は`0'で始まります。10進数は`.'で終わります。16進数は
`0x'で始まります。このどれにも該当しないものは、デフォルトで10進数とし
て入力されます。同様に、数値を表示するときも、特定のフォーマットが指定
されていなければ、デフォルトで10進数として表示されます。`set radix'コ
マンドによって、入力、出力の両方のデフォルトを変更することができます。

`set input-radix BASE'
     数値入力のデフォルトの基数を設定します。サポートされる選択肢は10
     進数の8、10、16です。BASE自身はあいまいにならないように指定するか、
     あるいは、現在のデフォルトの基数を使用して指定します。例えば、

          set radix 012
          set radix 10.
          set radix 0xa

     は基数を10進数に設定します。一方、`set radix 10'は、現在の基数を
     （それがどれであれ）変更しません。

`set output-radix BASE'
     数値の表示に使うデフォルトの基数を設定します。サポートされるBASE
     の選択肢は10進数の8、10、16です。BASE自身はあいまいにならないよう
     に指定するか、あるいは、現在のデフォルトの基数を使用して指定しま
     す。

`show input-radix'
     数値の入力に現在使われているデフォルトの基数を表示します。

`show output-radix'
     数値の表示に現在使われているデフォルトの基数を表示します。



File: gdb-ja.info, Node: Messages/Warnings, Prev: Numbers, Up: Controlling GDB

オプションの警告およびメッセージ
================================

デフォルトでは、GDBは内部の動作に関する情報を表示しません。性能の遅い
マシンで実行している場合には、`set verbose'コマンドを使うとよいでしょ
う。これによって、GDBは、長い内部処理を実行するときにメッセージを出力
することで、クラッシュと勘違いされないようにします。

現在のところ、`set verbose'コマンドによって制御されるメッセージは、ソー
ス・ファイルのシンボル・テーブルを読み込み中であることを知らせるメッセー
ジです。*Note Commands to specify files: Filesの`symbol-file'を参照し
てください。

`set verbose on'
     GDBが特定の情報メッセージを出力するようにします。

`set verbose off'
     GDBが特定の情報メッセージを出力しないようにします。

`show verbose'
     `set verbose'がon、offのどちらの状態であるかを表示します。

デフォルトでは、オブジェクト・ファイルのシンボル・テーブルに問題を検出
しても、GDBはメッセージを出力しません。しかし、コンパイラをデバッグし
ているようなときには、このような情報があると便利かもしれません（*Note
Errors reading symbol files: Symbol Errors.）。

`set complaints LIMIT'
     異常な型のシンボルを検出するたびにGDBが出力するメッセージの総数を
     LIMIT個とします。LIMIT個のメッセージを表示すると、その後は問題を
     検出してもメッセージを表示しないようになります。メッセージを1つも
     出力させないようにするには、LIMITにゼロを指定してください。メッセー
     ジの出力が抑止されないようにするには、LIMITに大きな値を設定してく
     ださい。

`show complaints'
     GDBが何個までシンボル異常に関するメッセージを出力できるよう設定されているかを表示します。

デフォルトでは、GDBは慎重に動作し、コマンドを本当に実行するのか確認す
るために、ときには馬鹿げているとさえ思えるような質問を多く尋ねてきます。
例えば、既に実行中のプログラムを実行しようとすると、次のように質問して
きます。

     (gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

ユーザが、実行したコマンドの結果を何がなんでも見てみたいのであれば、こ
の「機能」を抑止することができます。

`set confirm off'
     確認要求を行わないようにします。

`set confirm on'
     確認要求を行うようにします（デフォルト）。

`show confirm'
     確認要求の現在の設定を表示します。



File: gdb-ja.info, Node: Sequences, Next: Emacs, Prev: Controlling GDB, Up: Top

一連のコマンドのグループ化
**************************

ブレイクポイント・コマンド（*Note Breakpoint command lists: Break
Commands.）とは別に、一連のコマンドを一括して実行するために保存する2つ
の方法を、GDBは提供しています。ユーザ定義コマンドとコマンド・ファイル
がそれです。

* Menu:

* Define::                      ユーザ定義コマンド
* Hooks::                       ユーザ定義コマンド・フック
* Command Files::               コマンド・ファイル
* Output::                      制御された出力を得るためのコマンド



File: gdb-ja.info, Node: Define, Next: Hooks, Prev: Sequences, Up: Sequences

ユーザ定義コマンド
==================

"ユーザ定義コマンド"とは、一連のGDBコマンドに単一コマンドとしての名前
を新たに割り当てたものです。これは、`define'コマンドによって行われます。
ユーザ・コマンドは、空白で区切られた引数を最高で10個まで受け取ることが
できます。引数は、ユーザ・コマンドの中で、$ARG0...$ARG9としてアクセス
することができます。簡単な例を以下に示します。

     define adder
       print $arg0 + $arg1 + $arg2

このコマンドを実行するには、以下のようにします。

     adder 1 2 3

上の例では、`adder'というコマンドを定義しています。このコマンドは、3つ
の引数の合計を表示します。引数は文字列で代用されますので、変数を参照す
ることもできますし、複雑な式を使うこともできます。また、下位関数の呼び
出しを行うこともできます。

`define COMMANDNAME'
     COMMANDNAMEという名前のコマンドを定義します。同じ名前のコマンドが
     既に存在する場合は、再定義の確認を求められます。

     コマンドの定義は、`define'コマンドに続いて与えられる、他のGDBコマ
     ンド行から構成されます。これらのコマンドの末尾は、`end'を含む行に
     よって示されます。

`if'
     引数として、評価の対象となる式を1つだけ取ります。その後に一連のコ
     マンドが続きますが、これらのコマンドは、式の評価結果が真（ゼロ以
     外の値）である場合にだけ実行されます。さらに、`else'行が続くこと
     があり、この場合は、`else'行の後に、式の評価結果が偽であった場合
     にだけ実行される一連のコマンドが続きます。末尾は、`end'を含む行に
     よって示されます。

`while'
     構文は`if'と似ています。引数として、評価の対象となる式を1つだけ取
     ります。その後には、実行されるべきコマンドが1行に1つずつ続き、最
     後に`end'がなければなりません。コマンドは、式の評価結果が真である
     限り、繰り返し実行されます。

`document COMMANDNAME'
     ユーザ定義コマンドCOMMANDNAMEのドキュメントを記述します。このドキュ
     メントは`help'コマンドによってアクセスできます。コマンド
     COMMANDNAMEは既に定義済みでなければなりません。このコマンドは、
     `define'コマンドが一連のコマンド定義を読み込むのと同様に、`end'で
     終わる一連のドキュメントを読み込みます。`document'コマンドの実行
     が完了すると、コマンドCOMMANDNAMEに対して`help'コマンドを実行する
     と、ユーザの記述したドキュメントが表示されます。

     `document'コマンドを再度実行することによって、コマンドのドキュメ
     ントを変更することができます。`define'コマンドによってコマンドを
     再定義しても、ドキュメントは変更されません。

`help user-defined'
     すべてのユーザ定義コマンドを一覧表示します。個々のコマンドにドキュ
     メントがあれば、その1行目が表示されます。

`show user'
`show user COMMANDNAME'
     COMMANDNAMEで指定されるコマンドを定義するのに使われたGDBコマンド
     を表示します（ドキュメントは表示されません）。COMMANDNAMEを指定し
     ないと、すべてのユーザ定義コマンドの定義が表示されます。

ユーザ定義コマンドが実行されるときに、定義内のコマンドは表示されません。
定義内のコマンドがどれか1つでもエラーになると、ユーザ定義コマンドの実
行が停止されます。

対話的に使われている場合には確認を求めてくるようなコマンドも、ユーザ定
義コマンドの内部で使われている場合には確認を求めることなく処理を継続し
ます。通常は実行中の処理に関してメッセージを表示するGDBコマンドの多く
が、ユーザ定義コマンドの中から呼び出されている場合にはメッセージを表示
しません。



File: gdb-ja.info, Node: Hooks, Next: Command Files, Prev: Define, Up: Sequences

ユーザ定義コマンド・フック
==========================

特別な種類のユーザ定義コマンドである、*フック*を定義することができます。
`hook-foo'というユーザ定義コマンドが存在すると、`foo'というコマンドを
実行するときにはいつも、`foo'コマンドが実行される前に（引数のない）
`hook-foo'が実行されます。

また、仮想コマンドである`stop'が存在します。（`hook-stop'を）定義する
と、ユーザ・プログラムの実行が停止するたびに、その定義内のコマンドが実
行されます。実行タイミングは、ブレイクポイント・コマンドの実行、自動表
示対象の表示、および、スタック・フレームの表示の直前です。

例えば、シングル・ステップ実行をしている際には`SIGALRM'シグナルを無視
し、通常の実行時には通常どおり処理したい場合には、以下のように定義しま
す。

     define hook-stop
     handle SIGALRM nopass
     end

     define hook-run
     handle SIGALRM pass
     end

     define hook-continue
     handle SIGLARM pass
     end

GDBのコマンドのうち、その名前が1つの単語から成るものには、フックを定義
することができます。ただし、コマンド・エイリアスにフックを定義すること
はできません。フックは、コマンドの基本名に対して定義しなければなりませ
ん。例えば、`bt'ではなく`backtrace'を使います。フックの実行中にエラー
が発生すると、GDBコマンドは停止します。（ユーザが実際に入力したコマン
ドが実行する機会を与えられる前に）GDBはプロンプトを表示します。

既知のコマンドのいずれにも対応しないフックを定義しようとすると、
`define'コマンドは警告メッセージを表示します。



File: gdb-ja.info, Node: Command Files, Next: Output, Prev: Hooks, Up: Sequences

コマンド・ファイル
==================

GDBのコマンド・ファイルとは、各行がGDBコマンドとなっているファイルのこ
とです。（行の先頭が`#'の）コメントも含めることができます。コマンド・
ファイル内の空行は何も実行しません。それは、端末上での実行の場合とは異
なり、最後に実行されたコマンドの繰り返しを意味しません。

GDBを起動すると、自動的に"初期化ファイル"からコマンドを読み込んで実行
します。これは、Unix上では`.gdbinit'という名前のファイルであり、
DOS/Windows上では`gdb.ini'という名前のファイルです。GDBは、ユーザのホー
ム・ディレクトリに初期化ファイルがあればまずそれを読み込み、続いてコマ
ンンドライン・オプションとオペランドを処理した後、カレントな作業ディレ
クトリに初期化ファイルがあればそれを読み込みます。このように動くのは、
ユーザのホーム・ディレクトリに初期化ファイルを置くことで、コマンドライ
ン上のオプションやオペランドの処理に影響を与える（`set complaints'のよ
うな）オプションを設定することができるようにするためです。`-nx'オプショ
ンを使用すると、初期化ファイルは実行されません。*Note Choosing modes:
Mode Options.。

GDBのいくつかの構成では、初期化ファイルは異なる名前で知られています
（このような環境では、特別な形式のGDBが他の形式のGDBと共存する必要があ
り、そのために特別なバージョンのGDBの初期化ファイルには異なる名前が付
けられます）。特別な名前の初期化ファイルを持つ環境には、以下のようなも
のがあります。

   * VxWorks（Wind River Systems社のリアルタイムOS）: `.vxgdbinit'

   * OS68K（Enea Data Systems社のリアルタイムOS）: `.os68gdbinit'

   * ES-1800（Ericsson Telecom社のAB M68000エミュレータ）:
     `.esgdbinit'

また、`source'コマンドによって、コマンド・ファイルの実行を要求すること
もできます。

`source FILENAME'
     コマンド・ファイルFILENAMEを実行します。

コマンド・ファイルの各行は順番に実行されます。コマンドの実行時に、その
コマンドは表示されません。どれか1つでもコマンドがエラーになると、コマ
ンド・ファイルの実行は停止されます。

対話的に使われている場合には確認を求めてくるようなコマンドも、コマンド・
ファイル内で使われている場合は確認を求めることなく処理を継続します。通
常は実行中の処理についてメッセージを表示するGDBコマンドの多くが、コマ
ンド・ファイルの中から呼び出されている場合にはメッセージを表示しません。



File: gdb-ja.info, Node: Output, Prev: Command Files, Up: Sequences

制御された出力を得るためのコマンド
==================================

コマンド・ファイルやユーザ定義コマンドの実行中には、通常のGDBの出力は
抑止されます。唯一出力されるのは、定義内のコマンドが明示的に表示するメッ
セージだけです。ここでは、ユーザが希望するとおりの出力を生成するのに役
に立つ、3つのコマンドについて説明します。

`echo TEXT'
     TEXTを表示します。
     通常は表示されない文字も、
     Cのエスケープ・シーケンスを使うことでTEXTの中に含めることができます。
     例えば、
     改行コードを表示するには`\n'を使います。
     *明示的に指定しない限り、
     改行コードは表示されません。*
     標準的なCのエスケープ・シーケンスに加えて、
     バックスラッシュの後ろに空白を置くことで、
     空白が表わされます。
     これは、
     先頭や末尾に空白のある文字列を表示するのに便利です。
     というのは、
     こうしないと、
     引数の先頭や末尾の空白は削除されるからです。
     ` and foo = 'を表示するには、
     `echo \ and foo = \ 'を実行してください。

     Cと同様、TEXTの末尾にバックスラッシュを置くことで、コマンドを次の
     行以降に継続することができます。例えば、

          echo This is some text\n\
          which is continued\n\
          onto several lines.\n

     は

          echo This is some text\n
          echo which is continued\n
          echo onto several lines.\n

     と同じ出力をもたらします。

`output EXPRESSION'
     EXPRESSIONの値を表示し、それ以外には何も表示しません。改行コード
     も、`$NN = 'も表示されません。EXPRESSIONの値は値ヒストリには入り
     ません。式の詳細については、*Note Expressions: Expressions。

`output/FMT EXPRESSION'
     EXPRESSIONの値を、FMTで指定されるフォーマットで表示します。
     `print'コマンドと同じフォーマットを指定することができます。詳細に
     ついては、*Note Output formats: Output Formats。

`printf STRING, EXPRESSIONS...'
     STRINGで指定された文字列にしたがってEXPRESSIONSの値を表示します。
     複数のEXPRESSIONSはカンマで区切られ、数値かポインタのいずれかを指
     定できます。これらの値は、ユーザ・プログラムからCのサブルーチン

          printf (STRING, EXPRESSIONS...);

     を実行した場合と同様に、STRINGの指定にしたがって表示されます。

     例えば、次のようにして2つの値を16進数で表示することができます。

          printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo

     フォーマットを指定する文字列の中で使えるバックスラッシュ・エスケー
     プ・シーケンスは、バックスラッシュとそれに続く単一文字から構成さ
     れる簡単なものだけです。



File: gdb-ja.info, Node: Emacs, Next: Installing GDB, Prev: Sequences, Up: Top

GNU Emacsの中でのGDBの使用
**************************

GDBでデバッグ中のプログラムのソース・ファイルをGNU Emacsを使って参照
（および編集）するための、特別なインターフェイスが提供されています。

このインターフェイスを使うには、Emacsの中で`M-x gdb'コマンドを使います。
デバッグしたい実行ファイルを引数として指定してください。このコマンドは、
GDBをEmacsのサブプロセスとして起動し、新しく作成したEmacsバッファを通
じて入出力を行います。

Emacsの中でのGDBの使い方は、通常のGDBの使い方とほぼ同様ですが、2つ相違
点があります。

   * 「端末」へのすべての入出力はEmacsバッファへ送られる。

これは、GDBコマンドとその出力、および、デバッグ対象のユーザ・プログラ
ムによる入出力の両方に適用されます。

以前に実行したコマンド・テキストをコピーして再入力することができるので
便利です。出力された部分に関しても同様のことができます。

EmacsのShellモードで利用可能なすべての機能を、ユーザ・プログラムとのや
りとりで使うことができます。特に、通常どおりにシグナルを送信することが
できます。例えば、`C-c C-c'で割り込みシグナルを、`C-c C-z'でストップ・
シグナルを発生させることができます。

   * GDBはEmacsを使ってソース・コードを表示する。

GDBがスタック・フレームを表示するときにはいつでも、Emacsがそのフレーム
のソース・ファイルを自動的に見つけて、カレント行の左側の余白に矢印
（`=>'）を表示します。Emacsはソース・コードを別バッファに表示し、スク
リーンを2つに分けて、GDBセッションとソースをともに表示します。

GDBの`list'コマンドや`search'コマンドを明示的に使えば、通常どおりの出
力を生成することもできますが、これらをEmacsから使う理由はおそらくない
でしょう。

     *注意:* ユーザ・プログラムの存在するディレクトリがユーザのカレン
     ト・ディレクトリでない場合、ソース・ファイルの存在場所について
     Emacsは簡単に混乱に陥ります。このような場合、ソースを表示するため
     の追加のディスプレイ・バッファは表示されません。GDBは、ユーザの環
     境変数`PATH'のリストの中にあるディレクトリを探索してプログラムを
     見つけ出しますので、GDBの入出力セッションは通常どおり進行します。
     しかしEmacsは、このような状況においてソース・ファイルを見つけ出す
     のに十分な情報をGDBから受け取っていません。この問題を回避するには、
     ユーザ・プログラムの存在するディレクトリからGDBモードを開始するか、
     `M-x gdb'の引数の入力を求められたときに、絶対パスでファイル名を指
     定します。

     Emacsの既存のGDBバッファから、デバッグ対象をどこかほかの場所にあ
     るプログラムに変更する目的でGDBの`file'コマンドを使うと、同様の混
     乱の発生することがあります。

デフォルトでは、`M-x gdb'は`gdb'という名前のプログラムを呼び出します。
別の名前でGDBを呼び出す必要がある場合（例えば、異なる構成のGDBを別の名
前で持っているような場合）は、Emacsの`gdb-command-name'という変数を設
定します。例えば

     (setq gdb-command-name "mygdb")

（を`ESC ESC'に続けて入力するか、あるいは、`*scratch*'バッファまたは
`.emacs'ファイルに入力することで）Emacsは`gdb'の代わりに「`mygdb'」と
いう名前のプログラムを呼び出します。

GDBのI/Oバッファでは、標準的なShellモードのコマンドに加えて、以下のよ
うな特別なEmacsコマンドを使うことができます。

`C-h m'
     EmacsのGDBモードの機能に関する説明を表示します。

`M-s'
     GDBの`step'コマンドのように、ソース行を1行実行します。さらに、カ
     レントなファイルとその中における位置を示すために、表示ウィンドウ
     を更新します。

`M-n'
     GDBの`next'コマンドのように、関数呼び出しをすべてスキップして、現
     在の関数内の次のソース行まで実行を進めます。さらに、カレントなファ
     イルとその中における位置を示すために、表示ウィンドウを更新します。

`M-i'
     GDBの`stepi'コマンドのように、1命令を実行します。必要に応じて表示
     ウィンドウを更新します。

`M-x gdb-nexti'
     GDBの`nexti'コマンドを使って、次の命令まで実行します。必要に応じ
     て表示ウィンドウを更新します。

`C-c C-f'
     GDBの`finish'コマンドのように、選択されたスタック・フレームを終了
     するまで実行を継続します。

`M-c'
     GDBの`continue'コマンドのように、ユーザ・プログラムの実行を継続し
     ます。

     *注意:* Emacs v19では、このコマンドは`C-c C-p'です。

`M-u'
     GDBの`up'コマンドのように、数値引数によって示される数だけ上位のフ
     レームに移動します（*Note Numeric Arguments:
     (Emacs)Arguments. (1) (*Note Emacs-Footnotes::)）。

     *注意:* Emacs v19では、このコマンドは`C-c C-u'です。

`M-d'
     GDBの`down'コマンドのように、数値引数によって示される数だけ下位の
     フレームに移動します。

     *注意:* Emacs v19では、このコマンドは`C-c C-d'です。

`C-x &'
     カーソルの位置にある数値を読み取り、GDBのI/Oバッファの末尾に挿入
     します。例えば、以前に表示されたアドレスの前後のコードを逆アセン
     ブルしたいとしましょう。この場合、まず`disassemble'と入力し、次に
     表示されたアドレスのところにカーソルを移動し、`disassemble'への引
     数を`C-x &'で読み取ります。

     `gdb-print-command'リストの要素を定義することによって、これをさら
     にカスタマイズすることができます。これが定義されていると、`C-x &'
     で入手した数値が挿入される前に、それをフォーマットしたり、処理し
     たりすることができるようになります。`C-x &'に数値引数を指定すると、
     特別なフォーマット処理を必要としているという意味になり、その数値
     がリストの要素を取得するためのインデックスとなります。リストの要
     素が文字列の場合は、挿入される数値はEmacsの`format'関数によって
     フォーマットされます。リストの要素が文字列以外の場合は、その数値
     が、対応するリスト要素への引数として渡されます。

どのソース・ファイルが表示されている場合でも、Emacsの`C-x SPC'
（`gdb-break'）コマンドは、ポイントの置かれているソース行にブレイクポ
イントを設定するようGDBに対して指示します。

ソースを表示中のバッファを誤って削除してしまった場合に、それを再表示さ
せる簡単な方法は、GDBバッファの中で`f'コマンドを入力して、フレーム表示
を要求することです。Emacs配下では、カレント・フレームのコンテキストを
表示するために必要であれば、ソース・バッファが再作成されます。

Emacsによって表示されるソース・ファイルは、通常どおりの方法でソース・
ファイルにアクセスする、普通のEmacsバッファによって表示されます。そう
したいのであれば、これらのバッファの中でファイルの編集を行うこともでき
ますが、GDBとEmacsの間で行番号に関する情報が交換されていることを頭に入
れておいてください。テキストに行を挿入したり、削除したりすると、GDBの
認識しているソース行番号は、実際のコードと正しく対応しなくなってしまい
ます。



File: gdb-ja.info  Node: Emacs-Footnotes, Up: Emacs

(1) 訳注：`GNU Emacs 19 マニュアル'（星雲社）の「ニューメリッ
ク引数」、`GNU Emacs マニュアル'（共立出版）の「数引数」に、
日本語訳があります。



File: gdb-ja.info, Node: GDB Bugs, Next: Installing GDB, Prev: Emacs, Up: Top

GDBのバグ報告
*************

ユーザからのバグ報告は、GDBの信頼性を向上させるのに重要な役割を果たし
ています。

バグを報告することで、その問題の解決につながり、結果として報告者自ら利
益を得ることができるかもしれません。もちろん、何の解決にもつながらない
こともあります。しかし、いずれにしても、バグ報告の主要な意義は、次のバー
ジョンのGDBをより良いものにすることで、コミュニティ全体の役に立つとい
う点にあります。バグ報告は、GDBの保守作業へのユーザからの貢献です。

バグ報告がその目的とするところを首尾よく達成できるようにするためには、
バグを修正することを可能にするような情報が提供されなければなりません。

* Menu:

* Bug Criteria::                本当にバグを見つけたのかどうかを知る方法
* Bug Reporting::               バグの報告方法



File: gdb-ja.info, Node: Bug Criteria, Next: Bug Reporting, Prev: Emacs, Up: Emacs

本当にバグを見つけたのかどうかを知る方法
========================================

発見した現象がバグかどうかよく分からない場合には、以下のガイドラインを
参照してください。

   * 入力された情報が何であれ、デバッガが致命的なシグナルを受信するの
     であれば、それはGDBのバグです。信頼性のあるデバッガは決してクラッ
     シュなどしません。

   * 正当な入力に対してGDBがエラー・メッセージを出力するのであれば、そ
     れはバグです。（クロス・デバッグを行っている場合には、ターゲット
     への接続に問題がある可能性もあるということに注意してください。）

   * 不正な入力に対してGDBがエラー・メッセージを出力しないのであれば、
     それはバグです。ただし、ユーザにとって「不正な入力」に思えるもの
     が、実は「拡張機能」であったり「古くから使われている用法のサポー
     ト」であったりすることもあります。

   * デバッグ・ツールに関する経験が豊富なユーザからのGDBの改善提案は、
     どのような場合でも歓迎です。 (1) (*Note Bug Criteria-Footnotes::)


File: gdb-ja.info  Node: Bug Criteria-Footnotes, Up: Bug Criteria

(1) 訳注：この日本語の翻訳マニュアルへの改善提案は、
<ki@home.email.ne.jp>に送ってください。



File: gdb-ja.info, Node: Bug Reporting, Prev: Bug Criteria, Up: Emacs

バグの報告方法
==============

いくつかの企業や個人がGNUのソフトウェアをサポートしています。こうした
サポート組織からGDBを入手したのであれば、まずその組織に連絡することを
お勧めします。

サポートを提供している多くの企業、個人の連絡先情報が、GNU Emacsディス
トリビューションの`etc/SERVICE'ファイルに記載されています。

どのような場合でも、GDBのバグ報告を（英語で）以下のアドレスに送ること
をお勧めします。 (1) (*Note Bug Reporting-Footnotes::)

     bug-gdb@prep.ai.mit.edu

*`info-gdb'、`help-gdb'、および、いかなるニュースグループにもバグ報告
を送ることはしないでください。* GDBユーザのほとんどは、バグ報告を受け
取りたいと考えてはいません。バグ報告を受け取りたいと思っている人は、
`bug-gdb'の配信を受けるようにしているはずです。

メーリング・リスト`bug-gdb'には、リピータとして機能する`gnu.gdb.bug'と
いうニュースグループがあります。このメーリング・リストとニュースグルー
プは、全く同一のメッセージを配信しています。メーリング・リストではなく
ニュースグループにバグ報告を流そうと考える人がよくいます。これはうまく
機能するように見えますが、1つ重大な問題があります。ニュースグループへ
の投稿では、送信者へのメール・パスが分からないことがよくあります。した
がって、もっと多くの情報が必要になったときに、バグの報告者と連絡を取る
ことができない可能性があります。こういうことがあるので、メーリング・リ
ストへのバグ報告の方が望ましいのです。

最後の手段として、バグ報告を（英語で）紙に書いて下記に郵送するという方
法があります。

     GNU Debugger Bugs
     Free Software Foundation Inc.
     59 Temple Place - Suite 330
     Boston, MA 02111-1307
     USA


役に立つバグ報告を行うための最も根本的な原則は、*すべての事実を報告す
る*ことです。ある事実を書くべきか省くべきかよく分からない場合は、書く
ようにしてください。

事実が省略されてしまうことがよくありますが、これはバグ報告者が、自分に
は問題の原因は既に分かっていると考え、いくつかの細かい点は関係がないと
仮定してしまうからです。したがって、例の中で使った変数の名前などは重要
ではないと、報告者は考えます。おそらくそうかもしれません。しかし、完全
にそうであるとも言い切れません。メモリの参照がデタラメな場所を指してい
るというバグで、それがたまたまメモリ上においてその名前が置かれている箇
所から値を取り出しているということがあるかもしれません。名前が異なれば、
そこの内容は、バグが存在するにもかかわらずデバッガが正しく動作してしま
うような値になるかもしれません。このようなことがないよう、特定の完全な
実例を提供してください。バグの報告者にとっては、このようにするのが最も
簡単なはずであり、かつ、それが最も役に立つのです。

バグ報告の目的は、そのバグを修正することができるようにすることにある、
という点を頭に入れておいてください。そのバグが、以前に報告されたものと
同じであるという可能性もありますが、バグ報告が完全なもので、必要な情報
がすべて含まれたものでなければ、バグの報告者にも私たちにもそのことを知
ることができません。

ときどき、2、3の大雑把な事実だけを記述して、「何か思い当たることはあり
ますか?」と聞いてくる人がいます。このようなバグ報告は役に立ちません。
このような報告には、より適切なバグ報告を送るよう報告者に注意する場合を
除いて、*返事をすることを拒否する*よう強くお願いします。

バグを修正できるようにするためには、報告者は以下の情報をすべて含めるべ
きです。

   * GDBのバージョン。GDBのバージョンは、引数を指定せずにGDBを起動する
     と、表示されます。また、いつでも`show version'コマンドで表示させ
     ることができます。

     この情報がないと、カレント・バージョンのGDBを使ってバグを探すこと
     に意味があるのかどうかを知ることができません。

   * 使っているマシンのタイプ、オペレーティング・システムの名前とバー
     ジョン番号。

   * GDBをコンパイルするのに使われたコンパイラ（および、そのバージョ
     ン）。例えば、gcc--2.8.1。

   * デバッグ対象のプログラムをコンパイルするのに使われたコンパイラ
     （および、そのバージョン）。例えば、gcc--2.8.1、あるいは、
     HP92453-01 A.10.32.03 HP Cコンパイラ。GCCについては、`gcc
     --version'によってこの情報を知ることができます。他のコンパイラに
     ついては、そのドキュメントを参照してください。

   * バグを見つけたプログラムをコンパイルする際に、コンパイラに渡した
     コマンド引数。例えば、`-O'オプションを使ったか否かなど。何か重要
     な点を省いてしまうことがないよう、すべての引数を記述してください。
     `Makefile'のコピー（あるいは、`make'からの出力）を添付すれば十分
     でしょう。

     引数が何であったのかを私たちが推測しようとしても、おそらく誤った
     推測をしてしまうでしょう。そうなると、バグは再現しないかもしれま
     せん。

   * バグを再現することのできる、完全な入力スクリプトとすべての必要な
     ソース・ファイル。

   * 発見された、正しくないと思われる動作の説明。例えば、「致命的なシ
     グナルを受信する」など。

     もちろん、GDBが致命的なシグナルを受信するというバグであれば、私た
     ちも間違いなくそれに気がつくでしょう。しかし、出力が正しくないと
     いうバグであれば、紛れもない誤りでなければ、私たちはそれに気付か
     ないかもしれません。私たちが間違いをする可能性を排除するようにし
     てください。

     たとえ致命的なシグナルを受信するような問題であっても、報告者はそ
     のことを明示的に報告するべきです。何か奇妙なことが起こっていると
     仮定しましょう。例えば、報告者が使っているGDBにちぐはぐなところが
     あるとか、報告者のシステム上にあるCライブラリのバグだった、という
     ような場合です（こういうことは、実際にありました！）。このような
     場合、報告者のGDBはクラッシュしても、私たちのところではクラッシュ
     しません。クラッシュするはずであると報告されていれば、私たちのGDB
     がクラッシュしなくても、「私たちのところではバグが発生しない」と
     いうことを知ることができます。クラッシュするはずであるという報告
     がなければ、実際の現象から何も結論を引き出すことができません。

   * もしGDBのソースへの修正を提案したいのであれば、コンテキスト付きの
     差分情報を送ってください。GDBのソースについて何か議論する場合も、
     行番号に言及するのではなく、コンテキストに言及してください。

     私たちが開発中のソースの行番号は、報告者の持っているソースの行番
     号とは一致しないでしょう。報告者から見たソースの行番号は、私たち
     にとって役に立つ情報を提供してくれません。

以下に、バグ報告に必要ではない情報をいくつか列挙します。

   * バグの包括的な説明。

     バグを見つけると、多くの時間をかけて、入力ファイルをどのように変
     更するとバグが発生しなくなり、どのように変更した場合はバグが発生
     し続けるかを調べる人がよくいます。

     これは多くの場合、時間のかかる作業であり、しかもあまり役に立ちま
     せん。というのは、私たちがバグを見つけるのは、デバッガでブレイク
     ポイントを使いながら1つの実例を実行させることによってであり、一連
     の実例からの純粋な演繹によってではないからです。時間を無駄にせず、
     何かほかのことに使うようお勧めします。

     もちろん、一番最初にバグを見つけたときの実例の*代わり*となる、もっ
     と単純な実例を見つけることができるのであれば、私たちにとっても便
     利です。出力におけるエラーはより発見しやすいものですし、デバッガ
     配下で実行させる方が時間がかかりません。

     しかし、単純化は絶対に必要というわけでもありません。こういうこと
     をしたくないのであれば、バグを発見したときのテスト・ケース全体を
     送って、バグの報告を行ってください。

   * バグに対するパッチ。

     バグに対するパッチは、それが良いものであれば、役に立ちます。しか
     し、パッチがあれば十分であるとみなして、テスト・ケースのような必
     要な情報を送るのを省かないでください。提供されたパッチに問題があ
     り、別の方法で問題を修正することにする場合もありますし、提供され
     たパッチを全く理解できないということもあるかもしれません。

     GDBのような複雑なプログラムでは、コード中のある特定のパスを通るよ
     うな実例を作成するのは困難なことがあります。報告者が実例を送って
     くれなければ、私たちには実例を作成することができず、したがって、
     バグが修正されたことを検証することができなくなってしまいます。

     また、報告者の送ってくれたパッチがどのような問題を修正しようとし
     ているのか私たちに理解できない場合、あるいは、なぜそのパッチが改
     善になるのか私たちが理解できない場合、そのパッチを組み込むことは
     しません。テスト・ケースが1つでもあれば、そうしたことを理解するの
     に役立つでしょう。

   * バグが何であるか、あるいは、何に依存しているかに関する推測。

     このような推測は普通は間違っているものです。私たちですら、デバッ
     ガを使って事実を見出すまでは、このような点に関して正しく推測する
     ことはできないのです。






File: gdb-ja.info  Node: Bug Reporting-Footnotes, Up: Bug Reporting

(1) 訳注：この日本語の翻訳マニュアルのバグは、日本語（か英語）で、
<ki@home.email.ne.jp>に報告してください。



File: gdb-ja.info, Node: Command Line Editing

コマンドライン編集
******************

この章では、GNUのコマンドライン編集インターフェイスの基本的な特徴につ
いて説明します。

* Menu:

* Introduction and Notation::	表記法
* Readline Interaction::	行編集のための最小限のコマンド・セット
* Readline Init File::		ユーザの見地からのReadlineのカスタマイズ
* Bindable Readline Commands::	バインディングを行うために利用可能なほとんどの
                                Readlineコマンドの説明
* Readline vi Mode::		Readlineをviエディタのように振る舞わせる方法の
                                簡単な説明



File: gdb-ja.info, Node: Introduction and Notation

行編集入門
==========

以下のパラグラフでは、キー・ストロークを表わすために使用される表記法に
ついて説明します。

C-kは、Control-Kという意味です。これは、コントロール・キーが押されたま
まの状態でキーkが押されたときに生成される文字を表わします。

M-kは、Meta-Kという意味です。これは、メタ・キー（があるものとして、そ
れ）が押されたままの状態でキーkが押されたときに生成される文字を表わし
ます。メタ・キーがない場合、最初にESCキーを押し、次にキーkを押すことで、
同等のキー・ストロークを生成することができます。どちらの手順も、キーk
を"メタ化"する、といいます。

M-C-kは、Meta-Control-Kという意味です。これは、C-kを"メタ化"することに
より生成される文字を指します。

さらに、いくつかのキーには名前があります。DEL、ESC、LFD、SPC、RET、TAB
は、この文章の中でも、初期化ファイルの中でも、各々のキーを表わします
（*Note Readline Init File::）。



File: gdb-ja.info, Node: Readline Interaction

Readlineの操作
==============

対話的なセッションにおいて、長いテキストを1行に記述した後で、その行の
先頭の単語のスペルが間違っていたことに気が付くことがよくあります。
Readlineライブラリは、入力したテキストを操作するための一連のコマンドを
提供しており、これによって、その行の大部分を入力し直すことなく、タイプ・
ミスしたところだけを修正することができます。これらの編集コマンドを使っ
て、修正が必要なところにカーソルを移動させ、テキストを削除したり、修正
テキストを挿入したりします。その行の修正が終われば、単にRETURNを押しま
す。RETURNを押すのに、行末にいる必要はありません。カーソルが行内のどこ
にあろうと、その行全体が入力として受け付けられます。

* Menu:

* Readline Bare Essentials::	Readlineについて最低限知っていなければならないこと
* Readline Movement Commands::	入力行の中での移動
* Readline Killing Commands::	テキストの削除と再入手
* Readline Arguments::		コマンドへの数値引数の指定
* Searching::			以前の行の中の検索
 


File: gdb-ja.info, Node: Readline Bare Essentials

Readlineの基本
--------------

行内に文字を入力するには、
単にその文字をタイプします。
タイプされた文字はカーソルの位置に表示され、
カーソルは1桁分右へ移動します。
1文字打ち間違えた場合は、
削除文字（erase character）を使って、
後退しながら打ち間違えた文字を削除することができます。

ときには、
本当は入力したかった文字を入力せず、
その誤りに気が付くことなく、
さらに数文字を入力してしまうということがあります。
このような場合には、
C-bによってカーソルを左に移動し、
誤りを訂正することができます。
訂正後、
C-fによってカーソルを右に移動することができます。

行の途中にテキストを追加すると、
挿入されたテキストのためのスペースを空けるために、
カーソルの右側にある文字が右方向に押しやられることに気がつくでしょう。
同様に、
カーソル位置にあるテキストを削除すると、
文字が削除されたために生じる空白を埋めるために、
カーソルの右側にある文字が左方向に引き戻されます。
入力行のテキストを編集するための最も基本的な操作の一覧を以下に示します。

C-b
     1文字戻ります。
C-f
     1文字進みます。
DEL
     カーソルの左にある文字を削除します。
C-d
     カーソル位置にある文字を削除します。
表示可能な文字
     行内のカーソル位置にその文字を挿入します。
C-_
     最後の編集コマンドを取り消して元に戻します。
     行内に文字が無くなるまで取り消しを繰り返すことが可能です。



File: gdb-ja.info, Node: Readline Movement Commands

Readline移動コマンド
--------------------


上記の一覧は、
ユーザが入力行を編集するのに必要な、
最も基本的なキー・ストロークを説明したものです。
ユーザの利便を考慮して、
C-b、
C-f、
C-d、
DELに加えて多くのコマンドが追加されてきました。
以下に、
行内をより迅速に動きまわるためのコマンドをいくつか示します。

C-a
     行の先頭に移動します。
C-e
     行の末尾に移動します。
M-f
     1単語分先に進みます。
     単語は、
     文字と数字から構成されます。
M-b
     1単語分前に戻ります。
C-l
     画面上の情報を消去し、
     カレント行が画面の一番上にくるようにして再表示します。

C-fが1文字分先に進むのに対して、
M-fが1単語分先に進む点に注意してください。
大まかな慣例として、
コントロール・キーを使うと文字単位の操作になり、
メタ・キーを使うと単語単位の操作になります。



File: gdb-ja.info, Node: Readline Killing Commands

Readlineキル（kill）コマンド
----------------------------


テキストを"キル（kill）"するとは、
行からテキストを削除し、
その際に、
そのテキストを後に引き出して行内に"再挿入（yank）"することができるように退避しておくことを指します。
あるコマンドの説明に「テキストをキル（kill）する」という記述があれば、
後に別の箇所
（あるいは同じ箇所）
において、
そのテキストを再入手することができると考えて間違いありません。

キル（kill）コマンドを使うと、
テキストは"キル・リング（kill-ring）"に退避されます。
キル（kill）コマンドを任意の回数連続して実行すると、
キル（kill）されたテキストはすべて連結されて退避されます。
したがって、
再挿入（yank）を行うと、
そのすべてを入手することができます。
キル・リング（kill-ring）は個々の行に固有のものではありません。
以前入力した行においてキル（kill）したテキストを、
後になって別の行を入力しているときに再挿入（yank）することができます。

以下に、テキストをキル（kill）するためのコマンドを一覧で示します。

C-k
     カレントなカーソル位置から行末までのテキストをキル（kill）します。

M-d
     カーソル位置から、
     カーソルの置かれている単語の末尾までをキル（kill）します。
     カーソルが2つの単語の間にあるときは、
     次の単語の末尾までをキル（kill）します。

M-DEL
     カーソル位置から、
     カーソルの置かれている単語の先頭までをキル（kill）します。
     カーソルが2つの単語の間にあるときは、
     前の単語の先頭までをキル（kill）します。

C-w
     カーソル位置から、
     それより前にある最初の空白までをキル（kill）します。
     単語間の境界が異なるので、
     これはM-DELとは異なります。


キル（kill）されたテキストを引き出して行内へ"再挿入（yank）"する方法を、
以下に示します。
再挿入（yank）とは、
最後にキルされたテキストを、
キル・バッファからコピーすることを意味しています。

C-y
     バッファ内のカーソル位置に、
     最後にキル（kill）されたテキストを再挿入（yank）します。

M-y
     キル・リング（kill-ring）を回転させ、
     新たに一番上にきたテキストを再挿入（yank）します。
     このコマンドを実行できるのは、
     1つ前に実行したコマンドがC-yまたはM-yの場合だけです。



File: gdb-ja.info, Node: Readline Arguments

Readlineの引数
--------------

Readlineコマンドには数値引数を渡すことができます。
数値引数は、
繰り返し回数として使われたり、
引数の符号として使われたりします。
通常は先に進むようなコマンドに負の数を引数として指定すると、
前に戻るようになります。
例えば、
行の先頭までのテキストをキル（kill）するには、
`M-- C-k'としてもよいでしょう。

コマンドに数値引数を渡す通常の方法は、
コマンドの前にメタ化された数字を入力することです。
入力された最初の「数字」がマイナス記号（-）の場合、
引数の符号は負になります。
引数を開始するためには、
メタ化された数字を1つだけ入力すればよく、
残りの数字はそのまま入力することができます。
そして最後にコマンドを入力します。
例えば、
C-dコマンドに引数として10を渡すためには、
`M-1 0 C-d'と入力します。



File: gdb-ja.info, Node: Searching

ヒストリ中のコマンドの検索
--------------------------

readlineは、
コマンド・ヒストリ
(*Note Bash History Facilities::)
の中から、
指定された文字列を含む行を検索するコマンドを提供しています。
インクリメンタル（INCREMENTAL）と
非インクリメンタル（NON-INCREMENTAL）の2つの検索モードがあります。

インクリメンタル（incremental）・モードでは、
ユーザが検索文字列を入力し終わる前から検索が始まります。
検索文字列の中の文字が1つ入力されるたびに、
readlineは、
それまで入力された文字列にマッチする、
ヒストリの中の次のエントリを表示します。
インクリメンタル・モードの検索では、
検索したいヒストリ・エントリを見つけるのに本当に必要となる文字だけを入力するだけで済みます。
インクリメンタル・モードの検索を中止するのには、
ESC文字を使います。
C-jでも、
検索は中止されます。
C-gは、
インクリメンタル・モードの検索を終了させて、
元の行を表示します。
検索が中止されると、
検索文字列を含むヒストリ・エントリがカレント行となります。
検索文字列にマッチする他のエントリをヒストリ・リストから見つけるためには、
必要に応じてC-sまたはC-rを入力します。
これによって、
それまでに入力された検索文字列にマッチする次のエントリをヒストリから見つけるために、
下の方向、
または、
上の方向に検索が行われます。
Readlineコマンドにバインドされているキー・シーケンスのうち上記以外のものを入力すると、
検索は中止され、
そのコマンドが実行されます。
例えば
RETが入力されると、
検索は中止され、
そのときの行が受け入れられたことになります。
したがって、
ヒストリ・リストの中のそのコマンドが実行されます。

非インクリメンタル（non-incremental）・モードでは、
マッチするヒストリ行の検索を開始する前に、
検索文字列全体を読み込みます。
検索文字列は、
ユーザによって入力されたものでも構いませんし、
カレント行の内容の一部であっても構いません。



File: gdb-ja.info, Node: Readline Init File

Readline初期化ファイル
======================

Readlineライブラリには、
`emacs'スタイルのキー・バインディングがデフォルトで組み込まれていますが、
異なるキー・バインディングを使うこともできます。
ホーム・ディレクトリ内のファイル"inputrc"にコマンドを記述することで、
誰でもReadlineを使うプログラムをカスタマイズすることができます。
このファイルの名前は、
シェル変数`INPUTRC'の値から取られます。
環境変数`INPUTRC'の値から取られます。
この変数に値がセットされていない場合のデフォルトは、
`~/.inputrc'です。

Readlineライブラリを使うプログラムが起動されると、
初期化ファイルが読み込まれ、
キー・バインディングが設定されます。

さらに、
`C-x C-r'コマンドを実行すると、
この初期化ファイルが再読み込みされます。
初期化ファイルに変更が加えられていれば、
その変更が反映されます。

* Menu:

* Readline Init File Syntax::	inputrcファイルの中におけるコマンドの構文

* Conditional Init Constructs::	inputrcファイルの中における条件キー・バインディング

* Sample Init File::		inputrcファイルの例



File: gdb-ja.info, Node: Readline Init File Syntax

Readline初期化ファイルの構文
----------------------------

Readline初期化ファイルの中では、ほんの少数の基本的な構文だけが使用でき
ます。空行は無視されます。`#'で始まる行はコメントです。`$'で始まる行は、
条件構文を表わします（*Note Conditional Init Constructs::）。その他の
行は、変数設定とキー・バインディングを示します。

変数設定
     初期化ファイルの中で`set'コマンドを使用してReadlineの変数の値を変
     更することによって、Readlineの実行時の振る舞いを変更することがで
     きます。デフォルトのEmacsスタイルのキー・バインディングを変更して、
     `vi'の行編集コマンドを使用できるようにするには、以下のようにしま
     す。

          set editing-mode vi

     以下の変数によって、実行時の振る舞いのかなりの部分が変更可能です。


     `bell-style'
          Readlineが端末のベル音を鳴らしたいと判断した場合に、何が起こ
          るかを制御します。`none'がセットされると、Readlineはベル音を
          鳴らしません。`visible'がセットされると、視覚的なベル (1)
          (*Note Readline Init File Syntax-Footnotes::) が利用可能であ
          れば、それを使います。`audible'（デフォルト）がセットされる
          と、Readlineは、端末のベル音を鳴らそうと試みます。


     `comment-begin'
          `insert-comment'コマンドが実行されたときに、行の先頭に挿入さ
          れる文字列です。デフォルトの値は`"#"'です。

     `completion-ignore-case'
          `on'がセットされると、Readlineは、大文字・小文字を区別せずに、
          ファイル名のマッチングや補完を行います。デフォルトの値は
          `off'です。

     `completion-query-items'
          ユーザに対して補完候補の一覧を見たいかどうか問い合わせるタイ
          ミングを決定する、補完候補の数です。補完候補の数がこの値より
          も多いと、Readlineは、補完候補の一覧を見たいかどうかをユーザ
          に対して問い合わせることになります。この値よりも少ない場合は、
          問い合わせを行うことなく一覧を表示します。デフォルトの境界は
          `100'です。

     `convert-meta'
          `on'がセットされると、Readlineは、第8ビットがセットされてい
          る文字をASCIIのキー・シーケンスに変換します。これは、該当文
          字の第8ビットを落として、その前にESC文字を付加することで、メ
          タ・プレフィックス・キー・シーケンス（meta-prefixed key
          sequence）に変換することによって行われます。デフォルトの値は
          `on'です。

     `disable-completion'
          `On'がセットされると、Readlineは単語補完を抑制します。補完文
          字（completion character）は、あたかも`self-insert'にマップ
          されたかのように、行内に挿入されます。デフォルトは`off'です。

     `editing-mode'
          `editing-mode'変数は、デフォルトで使用するキー・バインディン
          グの種類を制御します。Readlineは、デフォルトの状態では、
          Emacs編集モードで起動します。このモードは、キー・ストローク
          がEmacsに非常に良く似ています。この変数は、`emacs'と`vi'のど
          ちらかに設定することができます。

     `enable-keypad'
          `on'がセットされると、Readlineは、呼び出されたときに、アプリ
          ケーション・キーパッド（application keypad）を有効にすること
          を試みます。システムによっては、矢印キーを使用できるようにす
          るために、これが必要となります。デフォルトは`off'です。

     `expand-tilde'
          `on'がセットされると、Readlineが単語補完を試みる際に、チルダ
          の展開が行われます。デフォルトは`off'です。

     `horizontal-scroll-mode'
          この変数は、`on'と`off'のどちらかに設定することができます。
          これを`on'に設定すると、1行のテキストの長さがスクリーン幅よ
          りも長い場合に、編集中の行のテキストが次の行に折り返すことな
          く、同じ行の上で水平方向にスクロールするようになります。デフォ
          ルトでは、この変数には`off'がセットされています。

     `keymap'
          Readlineが認識している、キー・バインディング・コマンドのカレ
          ントなキーマップをセットします。セットすることのできる
          `keymap'名は、`emacs'、`emacs-standard'、`emacs-meta'、
          `emacs-ctlx'、`vi'、`vi-command'、`vi-insert'です。`vi'は
          `vi-command'と同等です。また、`emacs'は`emacs-standard'と同
          等です。デフォルトの値は、`emacs'です。`editing-mode'変数の
          値も、デフォルトのキーマップに影響を及ぼします。

     `mark-directories'
          `on'がセットされると、補完されたディレクトリ名の後ろにスラッ
          シュが付加されます。デフォルトは`on'です。

     `mark-modified-lines'
          この変数に`on'がセットされると、Readlineは、変更されたヒスト
          リ行の先頭にアスタリスク（`*'）を表示します。この変数は、デ
          フォルトでは`off'です。

     `input-meta'
          `on'がセットされると、Readlineは、8ビット入力に対する端末側
          のサポートがどうであれ、8ビット入力を有効にします（読み込ま
          れた文字の第8ビットを落としません）。デフォルト値は`off'です。
          `meta-flag'は、この変数の別名です。

     `output-meta'
          `on'がセットされると、Readlineは、第8ビットがセットされてい
          る文字を、メタ・プレフィックス・エスケープ・シーケンス
          （meta-prefixed escape sequence）としてではなく、直接表示し
          ます。デフォルトは`off'です。

     `print-completions-horizontally'
          `on'がセットされると、Readlineは、マッチする補完候補をアルファ
          ベット順にソートして、画面の下向きにではなく、水平方向に並べ
          て表示します。デフォルトは`off'です。

     `show-all-if-ambiguous'
          補完関数のデフォルトの振る舞いを変更します。`on'がセットされ
          ると、複数の補完候補を持つ単語は、ベル音を鳴らすことなく、直
          ちに補完候補を一覧表示させます。デフォルト値は`off'です。

     `visible-stats'
          `on'がセットされると、補完候補を一覧表示する際に、ファイル・
          タイプを示す文字がファイル名の後ろに付加されます。デフォルト
          は`off'です。


キー・バインディング
     初期化ファイルの中でキー・バインディングを制御するための構文は単
     純です。まず、キー・バインディングを変更したいコマンドの名前を知っ
     ている必要があります。以下のセクションにおいて、コマンドの名前、
     そのコマンドにデフォルトのキー・バインディングがある場合はそのバ
     インディング、および、そのコマンドが何をするものであるかについて
     の簡単な説明を、一覧にして示します。

     コマンドの名前を知っていれば、初期化ファイルの中で、コマンドにバ
     インドしたいキーの名前、コロン、そして最後にコマンドの名前を、1行
     にして記述するだけです。キーの名前は、好みに応じて異なる方法で表
     現することができます。

     KEYNAME: FUNCTION-NAME or MACRO
          KEYNAMEは、英語で記述されたキーの名前です。例えば、以下のよ
          うになります。
               Control-u: universal-argument
               Meta-Rubout: backward-kill-word
               Control-o: "> output"

          上の例では、C-uが関数`universal-argument'にバインドされ、C-o
          がその右側に記述されたマクロ（行内に`> output'というテキスト
          を挿入するマクロ）を実行するようバインドされます。

     "KEYSEQ": FUNCTION-NAME or MACRO
          前の例のKEYNAMEとは異なり、KEYSEQには、キー・シーケンス全体
          を示す文字列を指定することができます。これは、キー・シーケン
          スを二重引用符で囲むことによって実現されます。以下の例に示す
          ように、いくつかのGNU Emacsスタイルのキー・エスケープを使う
          ことができますが、特殊文字の名前は認識されません。

               "\C-u": universal-argument
               "\C-x\C-r": re-read-init-file
               "\e[11~": "Function Key 1"

          上の例では、C-uが（最初の例と同様）関数`universal-argument'
          に、`C-x C-r'が関数`re-read-init-file'に、`ESC [ 1 1 ~'が
          `Function Key 1'というテキストを挿入するよう、それぞれバイン
          ドされています。


     キー・シーケンスを指定する際には、以下のGNU Emacsスタイルのエスケー
     プ・シーケンスが利用できます。

     ``\C-''
          コントロール・プレフィックス
     ``\M-''
          メタ・プレフィックス
     ``\e''
          エスケープ文字
     ``\\''
          バックスラッシュ
     ``\"''
          "
     ``\'''
          '

     GNU Emacsスタイルのエスケープ・シーケンスに加えて、別のバックスラッ
     シュ・エスケープ群が利用できます。

     `\a'
          警告（ベル）
     `\b'
          バックスペース
     `\d'
          削除
     `\f'
          フォーム・フィード
     `\n'
          改行
     `\r'
          復帰（carriage return）
     `\t'
          水平タブ
     `\v'
          垂直タブ
     `\NNN'
          ASCIIコードが8進数値のNNN （1個以上3個以下の数字）に相当する
          文字
     `\xNNN'
          ASCIIコードが16進数値のNNN （1個以上3個以下の数字）に相当す
          る文字

     マクロのテキストを入力する際には、マクロ定義であることを示すため
     に、単一引用符または二重引用符を使わなければなりません。引用符に
     囲まれないテキストは、関数名であると見なされます。マクロ本体にお
     いては、上記のバックスラッシュ・エスケープは展開されます。バック
     スラッシュとそれに続く文字の組み合わせがバックスラッシュ・エスケー
     プに該当しない場合、マクロのテキストの中のバックスラッシュは、`"'
     や`''も含めて、直後にある文字を引用します。例えば、以下のバインディ
     ングによって、`C-x \'は、行内に`\'を1つ挿入することになります。
          "\C-x\\": "\\"



File: gdb-ja.info  Node: Readline Init File Syntax-Footnotes, Up: Readline Init File Syntax

(1) *訳注*：ベル音を鳴らす代わりに、画面表示をフラッシュ
させることを表わしています。



File: gdb-ja.info, Node: Conditional Init Constructs

条件初期化構文
--------------

Readlineは、Cのプリプロセッサにおける条件コンパイル機能と質的に類似し
た機能を実装しています。これによって、あるテストの結果に応じてキー・バ
インディングや変数設定が実行されるようにすることができます。4種類のパー
サ指示子が使われます。

`$if'
     `$if'は、編集モード、使用されている端末、あるいは、Readlineを使用
     しているアプリケーションに応じてバインディングが行われるようにす
     ることを可能にします。`$if'の後ろに、テストされる内容が行末まで続
     きます。テストされる内容をほかのものと分離するために特別に文字を
     使う必要はありません。

     `mode'
          Readlineが`emacs'モードと`vi'モードのどちらで動作しているか
          をテストするために、`$if'指示子の一形式である`mode='が使用さ
          れます。例えば、Readlineが`emacs'モードで開始されている場合
          にのみ、`emacs-standard'や`emacs-ctlx'のキーマップでバインディ
          ングをセットするようにするために、これを`set keymap'コマンド
          と組み合わせて使用することができます。

     `term'
          `term='という形式は、端末のファンクション・キーによって特定
          のキー・シーケンスが出力されるようなバインディングを行うなど
          の目的で、端末固有のキー・バインディングを組み込むために使用
          することができます。`='の右側の単語は、端末の完全名と、端末
          の名前のうち最初の`-'までの部分の両方に対してテストされます。
          これにより、例えば`sun'は、`sun'と`sun-cmd'の両方にマッチす
          ることになります。

     `application'
          APPLICATIONは、アプリケーション固有の設定を組み込むために使
          用されます。Readlineライブラリを使用する個々のプログラムがセッ
          トするAPPLICATION NAME （アプリケーション名）をテストするこ
          とができます。特定のプログラムにとって役に立つ関数に対して
          キー・シーケンスをバインドするために、これを使用することがで
          きます。例えば以下のコマンドは、Bashにおいて、カレントな単語、
          または、1つ前の単語を引用符で囲むキー・シーケンスを追加しま
          す。
               $if Bash
               # カレントな単語、または、1つ前の単語を引用符で囲む
               "\C-xq": "\eb\"\ef\""
               $endif

`$endif'
     このコマンドは、前の例が示すように、`$if'コマンドを終わらせます。

`$else'
     `$if'指示子から枝分かれしたこの部分に記述されたコマンドは、テスト
     結果が偽であった場合に実行されます。

`$include'
     この指示子は、引数としてファイル名を1つ取り、そのファイルからコマ
     ンドとバインディングを読み込みます。
          $include /etc/inputrc



File: gdb-ja.info, Node: Sample Init File

初期化ファイルのサンプル
------------------------

以下に、inputrcファイルの実例を示します。この中では、キー・バインディ
ング、変数割り当て、条件構文の例が示されています。

     # このファイルは、Gnu Readlineライブラリを使うプログラムの行入力編集
     # の振る舞いを制御する。Gnu Readlineライブラリを使うプログラムには、
     # FTP、Bash、Gdbなどがある。
     #
     # inputrcファイルは、C-x C-rによって再読み込みすることができる。
     # '#'で始まる行は、コメントである。
     #
     # 最初に、/etc/Inputrcからシステム全体のバインディングと変数割り当て
     # を取り込む。
     $include /etc/Inputrc

     #
     # emacsモードにおける種々のバインディングをセットする。

     set editing-mode emacs 

     $if mode=emacs

     Meta-Control-h:	backward-kill-word	関数名の後ろのテキストは無視される。

     #
     # キーパッド・モードにおける矢印キー
     #
     #"\M-OD":        backward-char
     #"\M-OC":        forward-char
     #"\M-OA":        previous-history
     #"\M-OB":        next-history
     #
     # ANSIモードにおける矢印キー
     #
     "\M-[D":        backward-char
     "\M-[C":        forward-char
     "\M-[A":        previous-history
     "\M-[B":        next-history
     #
     # 8ビット・キーパッド・モードにおける矢印キー
     #
     #"\M-\C-OD":       backward-char
     #"\M-\C-OC":       forward-char
     #"\M-\C-OA":       previous-history
     #"\M-\C-OB":       next-history
     #
     # 8ビットANSIモードにおける矢印キー
     #
     #"\M-\C-[D":       backward-char
     #"\M-\C-[C":       forward-char
     #"\M-\C-[A":       previous-history
     #"\M-\C-[B":       next-history

     C-q: quoted-insert

     $endif

     # 旧スタイルのバインディング。これがたまたまデフォルトでもある。
     TAB: complete

     # シェルとのやりとりにおいて便利なマクロ
     $if Bash
     # パス（PATH）の編集
     "\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
     # 引用符で囲まれた単語を入力するための準備 -- 先頭と末尾の二重引用符
     # を挿入して、先頭の引用符の直後に移動
     "\C-x\"": "\"\"\C-b"
     # バックスラッシュを挿入
     # （シーケンスやマクロにおいて、バックスラッシュ・エスケープをテストする）
     "\C-x\\": "\\"
     # カレントな単語、または、1つ前の単語を引用符で囲む
     "\C-xq": "\eb\"\ef\""
     # バインドされていない行再表示コマンドにバインディングを追加
     "\C-xr": redraw-current-line
     # カレント行において変数を編集
     "\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
     $endif

     # 視覚的なベルが利用可能であれば、それを使う
     set bell-style visible

     # 読み込みの際に、文字の第8ビットを落とさない
     set input-meta on

     # iso-latin1文字は、プレフィックス・メタ・シーケンスに変換せず、
     # そのまま挿入する
     set convert-meta off

     # 第8ビットがセットされている文字を、メタ・プレフィックス文字として
     # ではなく、直接表示する
     set output-meta on

     # ある単語について、150を超える補完候補が存在する場合、ユーザに対して
     # すべてを表示させたいかどうかを問い合わせる
     set completion-query-items 150

     # FTP用
     $if Ftp
     "\C-xg": "get \M-?"
     "\C-xt": "put \M-?"
     "\M-.": yank-last-arg
     $endif



File: gdb-ja.info, Node: Bindable Readline Commands

バインド可能なReadlineコマンド
==============================

* Menu:

* Commands For Moving::		行の中での移動
* Commands For History::	以前の行の入手
* Commands For Text::		テキストを変更するためのコマンド
* Commands For Killing::	キル（kill）と再挿入（yank）のためのコマンド
* Numeric Arguments::		数字引数、繰り返し回数の指定
* Commands For Completion::	Readlineによる入力補完
* Keyboard Macros::		入力された文字群の保存と再実行
* Miscellaneous Commands::	その他のコマンド

このセクションでは、キー・シーケンスにバインドすることが可能なReadline
コマンドについて説明します。



File: gdb-ja.info, Node: Commands For Moving

移動のためのコマンド
--------------------
`beginning-of-line (C-a)'
     カレント行の先頭に移動します。

`end-of-line (C-e)'
     行の末尾に移動します。

`forward-char (C-f)'
     1文字分先に進みます。

`backward-char (C-b)'
     1文字分後へ戻ります。

`forward-word (M-f)'
     次の単語の末尾へ移動します。単語は、文字と数字により構成されます。

`backward-word (M-b)'
     現在カーソルが指している単語、または、1つ前の単語の先頭に移動しま
     す。単語は、文字と数字により構成されます。

`clear-screen (C-l)'
     画面を消去し、カレント行を再表示します。その際、カレント行が画面
     の一番上になるようにします。

`redraw-current-line ()'
     カレント行を再表示します。デフォルトでは、このコマンドはバインド
     されていません。




File: gdb-ja.info, Node: Commands For History

ヒストリを操作するためのコマンド
--------------------------------

`accept-line (Newline, Return)'
     カーソルの位置がどこにあっても、その行を受け取ります。この行が空
     行ではない場合、`HISTCONTROL'変数と`HISTIGNORE'変数の設定にしたがっ
     て、それをヒストリ・リストに追加します。この行がヒストリ行である
     場合は、そのヒストリ行を最初の状態に復元します。カーソルの位置が
     どこにあっても、その行を受け取ります。この行が空行ではない場合、
     それをヒストリ・リストに追加します。この行がヒストリ行である場合
     は、そのヒストリ行を最初の状態に復元します。

`previous-history (C-p)'
     ヒストリ・リストを1つ上に移動します。

`next-history (C-n)'
     ヒストリ・リストを1つ下に移動します。

`beginning-of-history (M-<)'
     ヒストリの最初の行に移動します。

`end-of-history (M->)'
     入力ヒストリの最後の行、すなわち、現在入力中の行に移動します。

`reverse-search-history (C-r)'
     カレント行から始めて上の方向へ検索を行います。必要に応じてヒスト
     リの上の方へ移動します。インクリメンタルな検索を行います。

`forward-search-history (C-s)'
     カレント行から始めて下の方向へ検索を行います。必要に応じてヒスト
     リの下の方へ移動します。インクリメンタルな検索を行います。

`non-incremental-reverse-search-history (M-p)'
     カレント行から始めて、必要に応じてヒストリの上の方へ移動しつつ、
     非インクリメンタルな検索を使って、ユーザによって提供された文字列
     を上の方向へ検索します。

`non-incremental-forward-search-history (M-n)'
     カレント行から始めて、必要に応じてヒストリの下の方へ移動しつつ、
     非インクリメンタルな検索を使って、ユーザによって提供された文字列
     を下の方向へ検索します。

`history-search-forward ()'
     カレント行の先頭からカレントなカーソル位置（ポイント）までの間の
     文字列を、ヒストリの中で下の方向へ検索します。これは、非インクリ
     メンタルな検索です。デフォルトでは、このコマンドはバインドされて
     いません。

`history-search-backward ()'
     カレント行の先頭からポイントまでの間の文字列を、ヒストリの中で上
     の方向へ検索します。これは、非インクリメンタルな検索です。デフォ
     ルトでは、このコマンドはバインドされていません。

`yank-nth-arg (M-C-y)'
     1つ前に実行されたコマンドの最初の引数（通常は、1つ前の行の2つめの
     単語）を挿入します。引数Nを指定すると、1つ前に実行されたコマンド
     のN番目の単語を挿入します（1つ前に実行されたコマンドの中の最初の
     単語を、0番目の単語とします）。負の値を引数に指定すると、1つ前に
     実行されたコマンドの後ろから数えてN番目の単語を挿入します

`yank-last-arg (M-., M-_)'
     1つ前に実行されたコマンドの最後の引数（1つ前のヒストリ・エントリ
     の最後の単語）を挿入します。引数を指定すると、`yank-nth-arg'と同
     じように動作します。`yank-last-arg'を連続して実行すると、ヒストリ・
     リストを遡って移動していきます。したがって、各行の最後の引数が順
     番に挿入されていきます。



