Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY






File: gnus-ja.info, Node: Top, Next: Starting Up, Prev: (dir), Up: (dir)

The Gnus Newsreader
*******************

Gnus を使うことによって Emacs でニュースを (それにメールも) 読むことが
できます。ニュースは NNTP、ローカルスプール、mbox ファイルなどのあらゆ
る極悪な手段を駆使して手に入れることができます。運試しをしてみようと思
うならば、すべてを同時に用いることもできます。

この説明書は No Gnus v0.11 に対応します。



Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License".

     この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契
     約書第 1.3 版またはそれ以降の版が定める条件の下で複製、配布、ある
     いは変更することを許可します。変更不可部分は指定しません。“A GNU
     Manual”は表表紙テキスト、以下の (a) は裏表紙テキストです。この利
     用許諾契約書の複写は「GNU フリー文書利用許諾契約書」という章に含ま
     れています。

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom."

     (a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を複製したり
     変更する自由があります。FSF からの複写の購入は GNU の開発とソフト
     ウェアの自由の促進を支援します。」



* Menu:

* Starting Up::              ニュースを見つけるのには苦労が伴うかもしれない
* Group Buffer::             グループを選択し、購読し、削除する
* Summary Buffer::           記事を読み、保存し、投稿する
* Article Buffer::           記事を表示し、扱う
* Composing Messages::       メールとニュースを送るための情報
* Select Methods::           Gnus はすべてのメッセージをいろいろな選択方法で読む
* Scoring::                  記事に値を付ける
* Various::                  一般的な設定
* The End::                  さらば、そしてさようなら
* Appendices::               用語、Emacs 入門、FAQ、歴史、内部構造
* GNU Free Documentation License:: この文書の利用許諾契約書
* Index::                    変数、関数、概念の索引
* Key Index::                キー索引

Other related manuals

* Message:(message-ja).      メッセージの作成
* Emacs-MIME:(emacs-mime-ja). メッセージの作成; MIME パート
* Sieve:(sieve-ja).          Emacs で Sieve スクリプトを管理する
* PGG:(pgg-ja).              Gnus で PGP/MIME を使う
* SASL:(sasl-ja).            Emacs で SASL の認証を行なう

 -- The Detailed Node Listing ---

Starting Gnus

* Finding the News::            ニュースを取得する方法を選ぶ
* The First Time::              最初に起動したときに Gnus は何をするか
* The Server is Down::          そんなとき、どうすればメールを読めるか
* Slave Gnusae::                同時に一つ以上の Gnus を作動させることができる
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* New Groups::                  Gnus が新しいグループに対して何をするか
* Changing Servers::            あるサーバーから別のサーバーへ移る必要があるかもしれない
* Startup Files::               やっかいなスタートアップファイル---`.newsrc'
* Auto Save::                   クラッシュからの回復
* The Active File::             遅い回線からのファイルの取得には時間がかかる
* Startup Variables::           変更したいと思うかもしれない変数

New Groups

* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して Gnus は何をすべきか
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる

Group Buffer

* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファーを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印を付けておいて、後で処理できる
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメーターを持たせられる
* Listing Groups::              Gnus はグループをいろいろな分け方で表示できる
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな `.newsrc' の保ち方
* Browse Foreign Server::       サーバーを概観できる。何が読めるのか見てみよう
* Exiting Gnus::                ニュースを読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割する
* Non-ASCII Group Names::       英字以外の名前のグループへのアクセス
* Searching::                   メールの検索エンジン
* Misc Group Stuff::            他にできること

Group Buffer Format

* Group Line Specification::    グループバッファーの見え方を決める
* Group Mode Line Specification::  グループバッファーのモード行
* Group Highlighting::          グループバッファーにきれいに色を付ける

Group Topics

* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックのすべてのグループに適用されるパラメーター

Misc Group Stuff

* Scanning New Messages::       Gnus に新しいメッセージが到着したかどうかを聞く
* Group Information::           グループと Gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理

Summary Buffer

* Summary Buffer Format::       概略バッファーの外観を決定する
* Summary Maneuvering::         概略バッファーを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            記事を後で送る
* Marking Articles::            記事に既読や期限切れ消去可能等の印を付ける
* Limiting::                    概略バッファーに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられるか
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Sticky Articles::             再利用しない記事バッファー
* Article Backlog::             すでに読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える
* Article Treatment::           記事バッファーはお望みどおりに目茶苦茶にできる
* MIME Commands::               記事の MIME のあれこれを操作する
* Charsets::                    文字セットのこと
* Article Commands::            記事バッファーでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファーを並べ替える
* Finding the Parent::          子記事が探せないって? 親記事を取得しなさい
* Alternative Approaches::      ディフォルトではない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる
* Various Summary Stuff::       他のどの章にも納まらなかったもの
* Exiting the Summary Buffer::  グループバッファーに戻る、または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段
* Security::                    暗号のデコードと検証
* Mailing List::                メーリングリストマイナーモード

Summary Buffer Format

* Summary Buffer Lines::        概略バッファーがどのように見えるべきかを指定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファーをきれいで素敵にする

Choosing Articles

* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数

Reply, Followup and Post

* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::

Marking Articles

* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方

Threading

* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令

Customizing Threading

* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう... でもあなたは間違っていた!

Decoding Articles

* Uuencoded Articles::          記事を uudecode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せなデコードのための変数
* Viewing Files::               デコードされた結果を見たい?

Decoding Variables

* Rule Variables::              ファイルがどのように表示されるかを決める変数
* Other Decode Variables::      他のデコードのための変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数

Article Treatment

* Article Highlighting::        記事をフルーツサラダのようにしたい
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID やアドレスなどをクリックする
* Article Button Levels::       ボタンの見え方を制御する
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys を表示する
* Article Signature::           署名って何?
* Article Miscellanea::         他のいろいろなもの

Alternative Approaches

* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動デコードする

Various Summary Stuff

* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::
* Really Various Summary Commands::  あのやっかいな思い通りにならない命令

Article Buffer

* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  読む前に記事を MIME に通す
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファーで使えるキー操作
* Misc Article::                その他

Composing Messages

* Mail::                        メールの送信と返答
* Posting Server::              どのサーバーで投稿またはメールを送信するべきか?
* POP before SMTP::             メールを読まないとメールを送信できない
* Mail and Post::               ニュースとメールを同時に送信する
* Archived Messages::           送ったメッセージを Gnus が貯めておくところ
* Posting Styles::              あなたが誰であるかを明らかにするより簡単な方法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を嫌いだと何が起こる?
* Signing and encrypting::      安全なメッセージを作るには?

Select Methods

* Server Buffer::               仮想サーバーを作って編集する
* Getting News::                USENET ニュースを Gnus で読む
* Getting Mail::                個人的なメールを Gnus で読む
* Browsing the Web::            大量のウェブの資源からメッセージを取得する
* IMAP::                        Gnus を IMAP のクライアントとして使う
* Other Sources::               ディレクトリー、ファイル、SOUP パケットを読む
* Combined Groups::             複数のグループを一つのグループに合併させる
* Email Based Diary::           日程をメールで管理する
* Gnus Unplugged::              ニュースとメールをオフラインで読む

Server Buffer

* Server Buffer Format::        このバッファーの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使うことができる
* Unavailable Servers::         接続しようとしたサーバーのいくつかは落ちているかもしれない

Getting News

* NNTP::                        NNTP サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む

NNTP

* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数
* NNTP marks::                  NNTP サーバー用の印の保存

Getting Mail

* Mail in a Newsreader::        ニュースリーダーでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              メールグループの作り方
* Mail Sources::                どこからメールを取ってくるかを Gnus に知らせる方法
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを、身の毛のよだつような分割をすることができる
* Group Mail Splitting::        グループをカスタマイズしてメールを分割する
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               要らないメールを取り除く
* Washing Mail::                取得したメールからごみを取り除く
* Duplicates::                  重複したメールを処理する
* Not Reading Mail::            メールバックエンドで別のファイルを読む
* Choosing a Mail Back End::    Gnus は色々なメール様式を読むことができる

Mail Sources

* Mail Source Specifiers::      メールのソースがどこかを指定する
* Mail Source Customization::   ものごとに影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使う

Choosing a Mail Back End

* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Babyl::                       Rmail の旧バージョンは Babyl を使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察

Browsing the Web

* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* RSS::                         RDF Site Summary を読む
* Customizing W3::              Gnus から Emacs/W3 を操作する

IMAP

* Splitting in IMAP::           nnimap でメールを分割する
* Expiring in IMAP::            nnimap によるメールの期限切れ消去
* Editing IMAP ACLs::           他の利用者のメールボックスへのアクセスを制限/許可する
* Expunging mailboxes::         「メールボックス圧縮」ボタンと等価なもの
* A note on namespaces::        Gnus で IMAP 名前空間を使う (使わない) 方法
* Debugging IMAP::              ものごとが働かないときにするべきこと

Other Sources

* Directory Groups::            ディレクトリーをニュースグループのように読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* SOUP::                        SOUP パケットを「オフライン」で読む
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通して記事を投稿する

Document Groups

* Document Server Internals::   あなた独自の文書種別を追加する方法

SOUP

* SOUP Commands::               SOUP パケットを作って送り出す命令
* SOUP Groups::                 SOUP パケットを読むためのバックエンド
* SOUP Replies::                メールとニュースを `nnsoup' に引き継がせる方法

Combined Groups

* Virtual Groups::              たくさんのグループの記事を合併する
* Kibozed Groups::              ニューススプールの中からの記事を検索する

Email Based Diary

* The NNDiary Back End::        基本的な設定と使い方
* The Gnus Diary Library::      NNDiary の上位階層にある実用的なツールキット
* Sending or Not Sending::      日程メッセージを送るときに注意すること

The NNDiary Back End

* Diary Messages::              メッセージを NNDiary で使えるようにするには
* Running NNDiary::             NNDiary には二つの動作モードがある
* Customizing NNDiary::         ベルとホイッスル

The Gnus Diary Library

* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで

Gnus Unplugged

* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               概略バッファーが変化するかもしれないエージェントの所業
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を追い払う方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and flags::             エージェントはどうフラグを維持するのか
* Agent and IMAP::              エージェントを IMAP で使う方法
* Outgoing Messages::           ニュースやメールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための `~/.gnus.el' の例
* Batching Agents::             `cron' ジョブでニュースを取得する方法
* Agent Caveats::               あなたが予想することと、それが実際にすること

Agent Categories

* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス

Agent Commands

* Group Agent Commands::        グループの設定とそれらの内容の取得
* Summary Agent Commands::      手動で選択した記事を取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択

Scoring

* Summary Score Commands::      現在のグループのためのスコア・エントリーを追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
* Score File Format::           スコアファイルには何が入っているか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            Big Sister Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア・エントリーがどこへ行くかを指示する方法
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                効果的にスコアを付ける方法
* Reverse Scoring::             歳をとった問題児は問題ではない
* Global Score Files::          地を覆い、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに翻訳する
* Advanced Scoring::            スコアの規則を作るために論理表現を使う
* Score Decays::                スコアを減衰させるのは役に立つこともある

Advanced Scoring

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限に利用する

Various

* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーの見栄えを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Compilation::                 Gnus を速くするには
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Buttons::                     たった十回たたいただけで腱鞘炎になる!
* Daemons::                     Gnus はあなたの裏で仕事をすることができる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Image Enhancements::          最新の Emacs/XEmacs は画像を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        頼んでもいない広告メールを避ける簡単な方法
* Spam Package::                Spam を濾過して処理するためのパッケージ
* The Gnus Registry::           記事を Message-ID で辿るためのパッケージ
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの

Formatting Variables

* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を変化させる
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う

Image Enhancements

* X-Face::                      ファンキーなちっちゃな白黒の絵を表示する
* Face::                        よりファンキーでちっちゃなカラーの絵を表示する
* Smileys::                     幸せな顔をまさにそのように表示する
* Picons::                      あなたが読んでいるものの絵を表示する方法
* XVarious::                    XEmacs のための Gnus の変数

Thwarting Email Spam

* The problem of spam::         背景、そして解決
* Anti-Spam Basics::            たくさんの spam を減らす簡単な方法
* SpamAssassin::                Spam 対策ツールの使い方
* Hashcash::                    CPU 時間を費やして spam 退治する

Spam Package

* Spam Package Introduction::
* Filtering Incoming Mail::
* Detecting Spam in Groups::
* Spam and Ham Processors::
* Spam Package Configuration Examples::
* Spam Back Ends::
* Extending the Spam package::
* Spam Statistics Package::

Spam Statistics Package

* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::

Appendices

* XEmacs::                      XEmacs でインストールするための要件
* History::                     どうやって Gnus が今日のようになったか
* On Writing Manuals::          なぜこれが初心者用の案内でないか
* Terminology::                 ここにあるような本当に難しい語を使う
* Customization::               あなたの要求に沿って Gnus を仕立てる
* Troubleshooting::             うまくいかないときに何を試すか
* Gnus Reference Guide::        色々な技術的なもの
* Emacs for Heathens::          Emacs の用語の手短かな紹介
* Frequently Asked Questions::  Gnus の FAQ

History

* Gnus Versions::               どんなバージョンの Gnus がリリースされているか
* Other Gnus Versions::         リリースされている他のバージョンの gnus
* Why?::                        Gnus の目的は何?
* Compatibility::               Gnus は GNUS とどれくらい互換性があるの?
* Conformity::                  Gnus はすべての標準を満たそうとする
* Emacsen::                     Gnus は少数の現代的な Emacs で実行できる
* Gnus Development::            Gnus が開発されている方法
* Contributors::                たくさんの人々
* New Features::                Gnus の新しいことに関する手がかり

New Features

* ding Gnus::                   最初の新しい Gnus である Gnus 5.0/5.1 の新しいこと
* September Gnus::              公式に Gnus 5.2/5.3 として知られているもの
* Red Gnus::                    三番目の最上のもの--Gnus 5.4/5.5
* Quassia Gnus::                2 かける 2 は 4、もしくは Gnus 5.6/5.7
* Pterodactyl Gnus::            神秘の数も P で始まるけれど。Gnus 5.8/5.9 の別名
* Oort Gnus::                   巨大な。遠く遥かな。Gnus 5.10/5.11。
* No Gnus::                     超やばい

Customization

* Slow/Expensive Connection::   ローカルの Emacs で、どこかからニュースを得る
* Slow Terminal Connection::    遠くにあるホストの Emacs を実行する
* Little Disk Space::           大きな設定ファイルを持つことは良くない
* Slow Machine::                速いマシンを買いたい気がする

Gnus Reference Guide

* Gnus Utility Functions::      共通の関数と変数
* Back End Interface::          Gnus はどうやってサーバーと通信するのか
* Score File Syntax::           スコアファイル標準の BNF 定義
* Headers::                     Gnus はヘッダーを内部的にどのように格納するか
* Ranges::                      たくさんの数を格納する便利な形式
* Group Info::                  グループ情報の形式
* Extended Interactive::        シンボル接頭引数など
* Emacs/XEmacs Code::           Gnus はすべての最新の Emacsen で動作する
* Various File Formats::        Gnus が使用するファイルの形式

Back End Interface

* Required Back End Functions:: 実装しなければならない関数
* Optional Back End Functions:: 実装しなくてもよい関数
* Error Messaging::             メッセージを発したりエラーを報告する方法
* Writing New Back Ends::       古いバックエンドの拡張
* Hooking New Back Ends Into Gnus::  Gnus 側でしなければならないこと
* Mail-like Back Ends::         メール風バックエンドのための助言

Various File Formats

* Active File Format::          使用可能な記事とグループの情報
* Newsgroups File Format::      グループの説明

Emacs for Heathens

* Keystrokes::                  文章を入力して命令を実行する
* Emacs Lisp::                  備え付けの Emacs プログラミング言語



File: gnus-ja.info, Node: Starting Up, Next: Group Buffer, Prev: Top, Up: Top

Gnus の起動
***********

Gnus を使う以前にあまり Emacs を使っていないのならば、最初に *Note
Emacs for Heathens:: を読んでください。

システム管理者が適切な設定をしていたならば、Gnus を起動してニュースを読
むのは非常に簡単です。そう、Emacs で `M-x gnus' と打つだけです。さもな
ければ、変数 `gnus-select-method' をカスタマイズしなければなりません。
これは *Note Finding the News:: で説明されています。また、投稿するため
の最低限の設定を行なうために、変数 `user-full-name' および
`user-mail-address' もカスタマイズしなければなりません。

別のフレーム (frame) で Gnus を起動したいときは、
`M-x gnus-other-frame' 命令を使うことができます。

開始時に何かがうまくいかないときは `~/.gnus.el' ファイルの中で変数をい
くつかいじくりまわさなければならないでしょう。このファイルは
`~/.emacs' と似ていますが、こちらは Gnus が起動するときに読み込まれます。

この説明書でよくわからない用語がでてきたときは、用語の章 (*Note
Terminology::) を参照してください。

* Menu:

* Finding the News::      ニュースを取得する方法を選ぶ
* The First Time::        最初に起動したときに Gnus は何をするか
* The Server is Down::    そんなとき、どうすればメールを読めるか
* Slave Gnusae::          同時に一つ以上の Gnus を作動させることができる
* Fetching a Group::      グループを読むためだけに Gnus を起動する
* New Groups::            Gnus が新しいグループに対して何をするか
* Changing Servers::      あるサーバーから別のサーバーへ移る必要があるかもしれない
* Startup Files::         やっかいなスタートアップファイル---`.newsrc'
* Auto Save::             クラッシュからの回復
* The Active File::       遅い回線からのファイルの取得には時間がかかる
* Startup Variables::     変更したいと思うかもしれない変数



File: gnus-ja.info, Node: Finding the News, Next: The First Time, Prev: Starting Up, Up: Starting Up

ニュースを見つける
==================

変数 `gnus-select-method' は Gnus がどこでニュースを探すべきかを示しま
す。この変数ははじめの要素が「方法」、二番目の要素が「場所」を表すリス
トである必要があります。この方法はあなたの基本方法 (native method) にな
ります。この方法で取ってこないグループはすべて外部 (foreign) グループで
す。

例えば NNTP サーバー `news.somewhere.edu' から毎日 (薬のように) 一定の
量のニュースを摂取したいのであれば、

     (setq gnus-select-method '(nntp "news.somewhere.edu"))

のようにすることができます。

ローカル・スプールのディレクトリーを読み込みたい場合は、

     (setq gnus-select-method '(nnspool ""))

のようにできます。

ローカルのスプールを使えるのであれば、かなりの確率でその方がずっと速い
でしょうし、それを使うべきでしょう。でも、もしあなたのサーバーが
Leafnode (それは簡単な個人用のニュースサーバーです) であるならばローカ
ルスプールを使ってはいけません。この場合は `(nntp "localhost")' にしま
しょう。

もしこの変数が設定されていなければ、Gnus は `NNTPSERVER' 環境変数を読み
にいきます。もしその変数が設定されていなければ、Gnus は
`gnus-nntpserver-file' (設定されていない場合は `/etc/nntpserver') がこ
の件に関して何かを言っていないかを調べます。もしそれも失敗したなら、
Gnus は Emacs が動作しているサーバーを NNTP サーバーとして使おうとしま
す。随分な当て推量ですけどね。

`gnus-nntp-server' が設定されていると、この変数は `gnus-select-method'
よりも優先されます。ですから `gnus-nntp-server' は `nil' に設定するべき
で、それがディフォルトです。

Gnus に NNTP サーバーの名前を対話的に指定することもできます。`gnus' に
数値でない接頭引数を渡すと (例: `C-u M-x gnus')、Gnus は
`gnus-secondary-servers' リスト (もし存在するならば) からサーバーを選ぶ
ことができるようにします。ただ単に接続したいと思ったサーバーの名前を打
つこともできます。(これは `gnus-nntp-server' を設定し、これは後の
Emacs のセッションで `M-x gnus' とすると、Gnus は同じサーバーに接続しよ
うとするということです。)

しかし、普段日常的には一つの NNTP サーバーを使い、違ったサーバー
には興味のあるグループが少ししかない場合、グループバッファー
で `B' 命令を使うことの方が良いでしょう。それは、選択可能なグループ
を表示し、その中からどれでも好きなものを購読することができます。これ
は `.newsrc' の保持をずっとやりやすくします。
*Note 外部グループ: Foreign Groups.

外部グループに対する少し違ったやり方は、変数
`gnus-secondary-select-methods' を設定する方法です。この変数に表されて
いる選択方法は、多くの点で `gnus-select-method' サーバーの選択方法と同
じように扱われます。起動中にアクティブファイルを探しにいき (もし要求さ
れていれば)、これらのサーバー上にできた新しいニュースグループは元々のグ
ループと同じように購読されます (もしくは、されません)。

例えばメールを読むために `nnmbox' バックエンド (back end) を使いたいと
きは、普通この変数を、

     (setq gnus-secondary-select-methods '((nnmbox "")))

と設定します。

注: NNTP バックエンドは印ファイル (*Note NNTP marks::) に印を保存します。
この機能は Gnus がインストールされている複数のホスト間で印を共有するこ
とを容易にしますが、新着記事の取得をちょっと遅くするかもしれません。詳
細については *Note NNTP marks:: を参照してください。



File: gnus-ja.info, Node: The First Time, Next: The Server is Down, Prev: Finding the News, Up: Starting Up

一番初め
========

起動用ファイルが存在しないときは (*Note Startup Files::)、Gnus はどのグ
ループがディフォルトで購読されているべきかを決定しようとします。

変数 `gnus-default-subscribed-newsgroups' が設定されていると、Gnus はそ
のリストの中のグループを購読し、残りを削除します。システム管理者はこの
変数を何か役に立つものに設定しておくことが望まれます。

そうでないときは、Gnus は少数の適当なグループを購読します (例:
`*.newusers')。(「適当な」はここでは「あなたが読むべきであると Lars さ
んが考えるもの」というように定義されています)

また、たいていの共通の問題の解決の手助けになるよう、Gnus に関する文書の
グループも購読することになるでしょう。

`gnus-default-subscribed-newsgroups' が `t' のときは、Gnus は新しいグルー
プを扱うのに普通の関数を使い、特別なことは何もしません。



File: gnus-ja.info, Node: The Server is Down, Next: Slave Gnusae, Prev: The First Time, Up: Starting Up

サーバーが落ちている
====================

ディフォルトのサーバーが落ちているときは、当然 Gnus の起動にいくつかの
問題が発生します。しかし、ニュースグループの他にいくつかメールのグルー
プがあるのならば、それにもかかわらず Gnus を起動する必要があるかもしれ
ません。

信頼できるプログラムの一つである Gnus は、サーバーと接続できないときは
基本選択方法なしで続けるかどうかを尋ねます。これは実際にはサーバーが存
在しないとき (例えば、アドレスを間違えた場合) やサーバーが何らかの理由
で一時的に調子がおかしくなっているときに起こります。もしそのまま続行す
ることにして、外部グループが一つも無い場合、実はグループバッファーでは
ほとんど何もできないということに気が付くでしょう。でも、ねぇ、それはあ
なたの問題です。ブブーッ!

サーバーが完全に落ちているのを知っているか、サーバーでわずらうことなく
メールだけを読みたいときは、Gnus を起動するのに `gnus-no-server' 命令を
使うことができます。急いでいるときにもぴったりでしょう。この命令は本来
のサーバーには接続しません--その代わりに、レベル 1 と 2 にあるすべての
グループを活動状態にします (基本グループでないグループはその二つのレベ
ルにしておくのが望ましいでしょう)。*Note Group Levels:: も参照してくだ
さい (訳注: `gnus-no-server' は `gnus-group-use-permanent-levels' 変数
の値を 2 に設定することに注意してください)。



File: gnus-ja.info, Node: Slave Gnusae, Next: New Groups, Prev: The Server is Down, Up: Starting Up

Gnus をスレーブにする
=====================

あなたには二つ以上の Gnus をそれぞれ別の Emacs 上で同時に動かす必要が生
じるかもしれません。違った `.newsrc' ファイルを使っているなら (例えば、
二つの違ったサーバーから読み込むために、二つの違った Gnus を動作させて
いる場合)、まったく問題はありません。それを行なえば良いだけです。

問題は、同じ `.newsrc' ファイルを使う二つの Gnus を動かそうとしたときに
起こります。

この問題に対処するために Gnus タワーのシンクタンクにいる私たちは、新し
い概念にたどりつきました。「マスター」と「スレーブ」です。(私たちはこの
概念に特許を申請しました。そして、その言葉の著作権を得ました。お互いに
関連してこれらの言葉を使いたいなら、一回使う毎に、私に $1 を送らなけれ
ばなりません。もっちろん「コンピューターアプリケーションのマスター/スレー
ブ関係」の使用料はもっと高くなります。)

とにかく、`M-x gnus' (もしくは、普段やっている方法) で Gnus を普通に起
動します。その後のスレーブ Gnus はそれぞれ `M-x gnus-slave' で起動しま
す。スレーブは普通の `.newsrc' は保存しませんが、代わりに「スレーブファ
イル」にスレーブの起動中にどのようなグループが読まれたかという情報だけ
を保存します。マスター Gnus が起動するとき、それはそれらのスレーブファ
イルを読み込み (そして消し)、それらからすべての情報を取り込みます。(ス
レーブファイルは、最終的な変更が優先されるようにそれらが作られた順番で
読まれます。)

もちろん、スレーブファイルからの情報は普通の (すなわち、マスターの)
`.newsrc' ファイルよりも優先されます。

スレーブを起動するときにもしマスターの `.newsrc*' ファイル群がセーブさ
れていなかったら、自動保存されたファイルを読むかどうかを尋ねられるかも
しれません。“yes”と答えると、マスターにセーブされていない変更はスレー
ブに反映されません。“no”と答えると、マスターで読まれたいくつかの記事
が、スレーブでは未読であると見なされるかもしれません。



File: gnus-ja.info, Node: New Groups, Next: Changing Servers, Prev: Slave Gnusae, Up: Starting Up

新しいグループ
==============

新しいニュースグループをまったく見なくても満足ならば、
`gnus-check-new-newsgroups' を `nil' に設定することができます。これを設
定した場合、起動にかかる時間が短くなります。この変数が `nil' に設定され
ていても、グループバッファーで `U' を押せばいつでも新しいグループを購読
することができます (*Note Group Maintenance::)。ディフォルトではこの変
数は `ask-server' です。この変数が `always' に設定されていると、`g' 命
令を実行したときでも Gnus はバックエンドに新しいグループを探すことを求
めます (*Note Scanning New Messages::)。

* Menu:

* Checking New Groups::         どのグループが新しいかを決定する
* Subscription Methods::        新しいグループに対して Gnus は何をすべきか
* Filtering New Groups::        Gnus に特定の新しいグループを無視させる



File: gnus-ja.info, Node: Checking New Groups, Next: Subscription Methods, Prev: New Groups, Up: New Groups

新しいグループを調べる
----------------------

Gnus は、普通はグループが新しいかどうかを、購読しているグループと削除さ
れているグループのリストとアクティブファイルを比較することにより判定し
ています。この方法は特に速いというわけではありません。
`gnus-check-new-newsgroups' が `ask-server' であると、Gnus はサーバーに、
最後に接続してから新しいグループができているかどうかを尋ねます。この方
法は速いし、安上がりです。これにより、削除されたグループのリストを保持
しておくことからから完全に開放されます。ですから、
`gnus-save-killed-list' を `nil' にすることができるでしょう。そうすれば、
起動、終了の両方、そして全体にわたって時間を節約できます。ディスク消費
量も少なくなります。それなら、どうしてこれがディフォルトではないのでしょ
う? 残念ながら、すべてのサーバーがこの命令を理解するわけではないのです。

私は今あなたが何を考えているかを当てられます。どうすればサーバーが
`ask-server' を理解するかがわかるのでしょう? え、違うのですか? あぁ、良
かった。というのは、確実な答は存在しないのです。私に言えることは、この
変数を `ask-server' に設定して、数日間新しいグループが現れるかどうかを
調べてください、ということだけです。もしいくつかのグループが現れたなら、
それで動作しています。一つも現れなければ、それは動作していません。私は、
Gnus にサーバーが `ask-server' を理解するかどうかを推量させる関数を書く
こともできますが、それは単に推量しているにすぎません。ですから、その関
数を書くことはないでしょう。他の方法としては、サーバーに `telnet' をし
て、`HELP' と打ち、サーバーが理解するコマンドの中に `NEWGROUPS' がある
かどうかを調べることもできます。もしあれば、おそらく動作するでしょう
(しかし、適切に機能を提供することなく `NEWGROUPS' をリストに含めるサー
バーもあります)。

この変数は、選択方法のリストであることもできます。そのときは、Gnus は
`ask-server' 命令をそれぞれの選択方法に対して実行し、普通の方法で購読し
ます (もしくは、しません)。これの副作用は、起動にかなり時間がかかるので、
待っている間に瞑想できることです。永久の幸福を達成するために、マントラ
“dingnusdingnusdingnus”を使ってください。



File: gnus-ja.info, Node: Subscription Methods, Next: Filtering New Groups, Prev: Checking New Groups, Up: New Groups

購読方法
--------

新しいグループに遭遇したときに Gnus が何をするかは、変数
`gnus-subscribe-newsgroup-method' によって決定されます。

この変数は関数を含んでいる必要があります。この関数は新しいグループの名
前を唯一の引数として呼ばれます。

いくつかの手軽なプレハブ関数は、以下のようになっています。

`gnus-subscribe-zombies'
     すべての新しいグループをゾンビ (zombie) にします。これがディフォル
     トになっています。後でゾンビを (`A z' によって) 概観したり、(`S
     z' によって) 適切にすべてを削除したり、(`u' によって) 購読したりで
     きます。

`gnus-subscribe-randomly'
     任意の順番ですべての新しいグループを購読します。実際には、すべての
     新しいグループはグループバッファーの『一番上』に加えられます。

`gnus-subscribe-alphabetically'
     すべての新しいグループをアルファベット順に購読します。

`gnus-subscribe-hierarchically'
     すべての新しいグループを階層的に購読します。この関数と
     `gnus-subscribe-alphabetically' の違いは少ししかありません。
     `gnus-subscribe-alphabetically' は新しいグループを厳密にアルファベッ
     ト順にならべますが、この関数はグループをその階層の中に入れます。で
     すから、`rec' の階層を `comp' の階層の前に持ってきたい場合、この関
     数はその配置をぐちゃぐちゃにはしません。もしくは、そのようなもので
     す。

`gnus-subscribe-interactively'
     新しいグループを対話的に購読します。これは Gnus が *すべて* のグルー
     プに対して尋ねることを意味しています。購読するグループは階層的に購
     読されます。

`gnus-subscribe-killed'
     すべての新しいグループを削除します。

`gnus-subscribe-topics'
     グループを、それに合致する `subscribe' トピックパラメーターを持っ
     ているグループに入れます (*Note Topic Parameters::)。例えば、以下
     のような `subscribe' パラメーター

          "nnslashdot"

     は、その正規表現に合致するすべてのグループはそのトピックの下で購読
     されるということです。

     グループに合致するトピックが無い場合、グループは最上位のトピックで
     購読されます。

上の変数と密接に関係する変数は、
`gnus-subscribe-hierarchical-interactive' です。この変数が `nil' でない
と、Gnus は階層的な方法で新しいグループを購読するかどうかを尋ねます。
Gnus はそれぞれの階層で、それを下に降りるかどうかを尋ねます。

よくある間違いは、数段落前の (`gnus-subscribe-newsgroup-method') 変数を
`gnus-subscribe-herarchical-interactive' に設定することです。これは誤り
です。これは動作しません。これはおめでたい人のすることです。ですから、
絶対にしないでください。



File: gnus-ja.info, Node: Filtering New Groups, Prev: Subscription Methods, Up: New Groups

新しいグループを選別する
------------------------

どの新しいグループが購読 (もしくは、無視) されるべきかを管理する快適で
手軽な方法は、`.newsrc' ファイルの先頭に "options" 行を挿入することです。
次は、例です。

     options -n !alt.all !rec.all sci.all

この行は、明らかにまじめで理知的で科学的な人間 (あるいは彼女はどこにで
もいる単につまらない人かもしれないけれど) が書いたものです。なぜなら、
これは `alt' と `rec' で始まる名前を持つグループはすべて無視され、
`sci' で始まる名前を持つグループはすべて購読する、ということを表してい
るからです。Gnus はこれらのグループを購読するのに普通の購読方法を使いま
せん。代わりに `gnus-subscribe-options-newsgroup-method' が使われます。
この変数はディフォルトで `gnus-subscribe-alphabetically' になります。

`.newsrc' ファイルをいじりたくない場合は、`gnus-options-subscribe' と
`gnus-options-not-subscribe' の二つの変数だけを設定することもできます。
この二つの変数は `.newsrc' ファイルの `optinos -n' 行とまったく同じこと
をします。どちらの変数も正規表現で、新しいグループは前者に合致すれば無
条件に購読され、後者に合致すると無視されます。

さらにここでおせっかいをする変数は、`gnus-auto-subscribed-groups' です。
それは `gnus-options-subscribe' とまったく同じように動作するので、本当
は余分なものです。しかし、私はこの二つがあった方が良いと思いました。も
う一方の変数は利用者がいじくるのに使われるのに対して、この変数はいくつ
かの基本的な規則を設定するためのものです。ディフォルトではこの変数はメー
ルバックエンド (`nnml', `nnbabyl', `nnfolder', `nnmbox', `nnmh' および
`nnmaildir') からできるすべての新しいグループを購読するようになっていま
す。それが嫌であれば、この変数を `nil' に設定してください。

この正規表現に合致する新しいグループは
`gnus-subscribe-options-newsgroup-method' を使って購読されます。



File: gnus-ja.info, Node: Changing Servers, Next: Startup Files, Prev: New Groups, Up: Starting Up

サーバーを換える
================

ときどき、ある NNTP サーバーから別のサーバーへ移動しなければならないこ
とがあります。このようなことはめったにおきませんが、おそらくあなたが仕
事を変えたり、使っているサーバーがとても不安定で、別のものに乗り換えた
いというときに必要になるでしょう。

サーバーを変更するのはとても簡単ですよね? `gnus-select-method' を新しい
サーバーを指し示すように変更すればいいだけですね?

*違います!*

記事の番号は違った NNTP サーバーでも (どうにかして) 同じにしてあるとい
うことはありません。そして、Gnus がどの記事を読んだかを記録する唯一の方
法は、記事番号を記録することです。ですから `gnus-select-method' を変更
したときは、`.newsrc' ファイルは役に立たなくなります。

Gnus は `.newsrc' ファイルをあるサーバー用から別のサーバー用に変換する
関数を二、三用意しています。それらには一つ共通点があります--実行にな
がーーい時間がかかることです。おそらく、どうしても必要になったとき以外
にこの関数を使おうとは思わないでしょう。

もし両方のサーバーに接続できるなら、Gnus はあなたが読んだ記事すべてに対
してヘッダー (headers) を要求して、`Message-ID' を比較し、読んだ記事と
記事の印を新しく記録します。`M-x gnus-change-server' コマンドはこれをす
べての基本グループに対して行ないます。そのコマンドは移動先の方法 (the
method) を入力することを要求します。

個々のグループを `M-x gnus-group-move-group-to-server' 命令で移動するこ
ともできます。これはあるサーバーから別のサーバーへ一つの (外部) グルー
プを移動したいときに役に立ちます。

古いサーバーと新しいサーバーの両方に接続することができないとき、印と読
んだ範囲はすべて意味が無くなります。そのようなときは `M-x
gnus-group-clear-data-on-native-groups' コマンドを使って、基本グループ
に関するデータをすべて消去することができます。このコマンドは注意して使っ
てください。

`gnus-group-clear-data' コマンドは現在のグループのすべてのデータをクリ
アします--印と既読記事のリストを消し去ります。

サーバーを変更した後で、キャッシュ階層を移動させなければ *なりません*。
というのは、キャッシュ記事は間違った記事番号になっており、それは Gnus
がどの記事を読んだとみなすかに影響します。
`gnus-group-clear-data-on-native-groups' はそれを自動で行なってしまうか
どうかを尋ねます。`gnus-group-clear-data' では `M-x
gnus-cache-move-cache' が使えます (でも気を付けて、それはすべてのグルー
プのキャッシュを移動してしまいますから)。



File: gnus-ja.info, Node: Startup Files, Next: Auto Save, Prev: Changing Servers, Up: Starting Up

起動ファイル
============

最もありふれた Unix のニュースリーダーは、`.newsrc' と呼ばれる共用の起
動ファイルを使います。このファイルは、講読しているグループと、それらの
グループにおいてどの記事が読まれたかの、すべての情報を持っています。

GNUS ではものごとが少々複雑になっています。`.newsrc' ファイルを最新のも
のにするだけではなく、`.newsrc' ファイルには合わない情報を保存しておく
ために `.newsrc.el' と呼ばれるファイルを使います。(実際は `.newsrc' ファ
イルのすべての情報を複製して保持しています。) GNUS はこれらの中で一番最
後に保存されたものを使います。これをすることにより、GNUS と他のニュース
リーダーを切り替えて使うことができます。

これはちょっと間が抜けているので、Gnus はもっと良い方法を編み出しました。
`.newsrc' と `.newsrc.el' ファイルに加えて、Gnus は `.newsrc.eld' と呼
ばれるファイルも持っています。Gnus はこれらの中で一番新しいファイルを読
みますが、`.newsrc.el' ファイルに書き込むことはありません。
`.newsrc.eld' ファイルは絶対に消すべきではありません。---それは
`.newsrc' ファイルにはないたくさんの情報を保持しています。

`gnus-save-newsrc-file' を `nil' にすることによって `.newsrc' ファイル
に書き込むのを止めることができます。そうすれば、そのファイルを削除する
ことができ、ディスク容量を節約することができ、Gnus の終了が速くなります。
しかし、そうすると他のニュースリーダーを使えなくなります。でも、ちょっ
と、誰かそうしたい人がいるでしょうか。同じように
`gnus-read-newsrc-file' を `nil' にすることによって、Gnus は `.newsrc'
ファイルとすべての `.newsrc-SERVER' ファイルを無視するようになります。
そのことは、あなたが時々違うニュースリーダーを使ったり、利用可能なグルー
プの異なるサブセットをそれらのニュースリーダーで読みたい場合に、便利な
ことがあります。

`gnus-save-killed-list' (ディフォルトは `t') が `nil' であると、Gnus は
削除されたグループを起動ファイルに保存しません。これは (起動時と終了時
の) 時間と、(ディスクの) 容量を節約します。こうすると Gnus がどのグルー
プが新しいかの記録を持っていないことになるので、新しいグループの自動購
読方法は意味が無くなります。この変数を `nil' にしたときは、
`gnus-check-new-newsgroups' を常に `nil' か `ask-server' にしておくべき
でしょう (*Note New Groups::)。この変数は正規表現であることもできます。
そのような場合は、ファイルを保存する直前にその正規表現に合致しないすべ
てのグループを消去します。これは、すべてのサーバーが `ask-server' を理
解するわけではない、といったような、いくらかあいまいな状況のときに役に
立つでしょう。

変数 `gnus-startup-file' は起動ファイルがどこにあるかを指定します。ディ
フォルト値は `~/.newsrc' で、それがどのようなものであれ、末尾に `.eld'
を付けたものが Gnus (El Dingo) の起動ファイルになります。このファイルの
バージョン制御をしたいときは `gnus-backup-startup-file' をセットしてく
ださい。それは `version-control' 変数と同じ値を取ります。

`gnus-save-newsrc-hook' は各種の newsrc ファイルのどれかを保存する前に
実行されるのに対し、`gnus-save-quick-newsrc-hook' は `.newsrc.eld' ファ
イルを保存する前に実行され、`gnus-save-standard-newsrc-hook' は
`.newsrc' ファイルを保存する前に実行されます。後の二つは普通はバージョ
ン制御を on/off するのに使われます。ディフォルトでは、起動ファイルを保
存するときにバージョン制御が行なわれます。バックアップファイルの作成を
止めたいときは、次のようにしてください。

     (defun turn-off-backup ()
       (set (make-local-variable 'backup-inhibited) t))

     (add-hook 'gnus-save-quick-newsrc-hook 'turn-off-backup)
     (add-hook 'gnus-save-standard-newsrc-hook 'turn-off-backup)

Gnus が起動すると、`gnus-site-init-file' (ディフォルトで
`.../site-lisp/gnus-init') と `gnus-init-file' (ディフォルトで
`~/.gnus') のファイルを読み込みます。これらは普通の Emacs Lisp ファイル
で、`~/.emacs' や `site-init' ファイルを Gnus 関係のもので乱雑にしない
ようにするために使うことができます。Gnus はこれらと同じ名前のファイルに、
接尾語 `.elc' と `.el' が付いているものも調べます。言い換えれば、
`gnus-init-file' を `~/.gnus' に設定すると、Gnus は `~/.gnus.elc',
`~/.gnus.el' を探し、最後に `~/.gnus' を (この順番に) 探します。`-q' ま
たは `--no-init-file' オプション (*Note Initial Options:
(emacs)Initial Options.) が指定されて Emacs が起動された場合、Gnus は
`gnus-init-file' を読み込みません。



File: gnus-ja.info, Node: Auto Save, Next: The Active File, Prev: Startup Files, Up: Starting Up

自動保存
========

何か Gnus のデータを変更すること (記事を読む、印を付ける、グループを削
除または購読する) をしたとき、変更は特別な「ドリブルバッファー」
(dribble buffer) に書き込まれます。このバッファーは Emacs が普通するよ
うに自動保存されます。`.newsrc' ファイルを保存する前に Emacs が落ちたと
きは、すべての変更をこのファイルから回復することができるでしょう。

起動時に Gnus がこのファイルの存在を発見すると、Gnus はそれを読み込むか
どうかを利用者に尋ねます。本当の起動ファイルが保存されれば、自動保存ファ
イルは削除されます。

`gnus-use-dribble-file' が `nil' であると、Gnus はドリブルバッファーを
作ったり、維持したりしません。ディフォルトは `t' です。

Gnus はドリブルファイルを `gnus-dribble-directory' に置きます。ディフォ
ルトではそのようになっていますが、この変数が `nil' であると、Gnus は
`.newsrc' ファイルの置かれているディレクトリー (これは普通は利用者のホー
ムディレクトリーです) に入っていってドリブルファイルを作ります。ドリブ
ルファイルは `.newsrc' と同じ許可属性を与えられます。

もし `gnus-always-read-dribble-file' が `nil' でなければ、Gnus は利用者
に尋ねること無く、ドリブルファイルを起動時に読み込みます。



File: gnus-ja.info, Node: The Active File, Next: Startup Variables, Prev: Auto Save, Up: Starting Up

アクティブファイル
==================

Gnus は起動したときや、実際に新しい記事が到着しているかを判定しようとす
るときに、アクティブファイルを読み込みます。これはとても大きなファイル
で、そのサーバーの活動中のグループと記事のすべてのリストが入っています。

アクティブファイルを検査する前に、Gnus は正規表現
`gnus-ignored-newsgroups' に合うすべての行を削除します。これは主に偽の
名前を持つグループを排除するために使われてきましたが、興味の無いグルー
プの階層を無視するために使うこともできます。しかし、これはお勧めできま
せん。本当のことを言うと、まったく賛成できません。代わりに、そのような
用途に用いられる変数の概略を知るために、*Note New Groups:: を参照してく
ださい。

アクティブファイルは比較的大きくなる傾向があるので、遅い回線を使ってい
るときは、アクティブファイルを読み込まないように
`gnus-read-active-file' を `nil' に設定することができます。この変数はディ
フォルトでは `some' です。

そのような時は、Gnus は実際に購読されているグループに関する情報だけを得
てやっていこうとします。

気を付けてほしいのは、あなたが山ほどのたくさんのグループを購読している
ときにこの変数を `nil' に設定すると、Gnus は速くなるどころか遅くなって
しまうということです。現状では、ニュースを 2400bps 以上のモデムを通して
読んでいるのでない限り、Gnus の速度はかなり遅くなるでしょう。

この変数は `some' という値も取ることができます。その時は、Gnus は購読し
ているグループに関する情報をだけを得ようとします。いくつかのサーバー
(`LIST ACTIVE group' 命令を使うことのできる、最新鋭の INN サーバー) で
は、非常に早くなるでしょうが、他のサーバーでは速くはありません。どのよ
うにせよ、遅い回線では `some' は `nil' よりも速く、それはもちろん `t'
よりも速くなります。

いくつかのニュースサーバー (例えば古い Leafnode や古い INN) には `LIST
ACTIVE group' 命令がありません。そういうサーバーには `nil' をこの変数の
値に設定するのが、おそらくもっとも有効でしょう。

もしこの変数が `nil' であると、Gnus は完全にがんじがらめの方法でグルー
プの情報を得ようとします。そして、これはあまり速くありません。もしそれ
が `some' で NNTP サーバーを使っているときは、Gnus はできるだけ速く命令
を出し、一撃ですべての返答を読み込みます。この方が普通はより良い結果を
もたらしますが、サーバーが `LIST ACTIVE group' 命令を理解しないなら、サー
バーにとってはあまり良いとは言えません。

Gnus の起動にあまりに時間がかかると思ったなら、この変数にこれらの三つの
違った値を試してみて、どれが一番良いかを探してください。

`some' か `nil' を使うのであれば、どちらにしろ速度を上げるためにすべて
の興味の無いグループを必ず削除するべきでしょう。

この変数は第二の (secondary) 選択方法のアクティブファイル取得にも影響す
ることに気を付けてください。



File: gnus-ja.info, Node: Startup Variables, Prev: The Active File, Up: Starting Up

起動変数
========

`gnus-load-hook'
     Gnus (のプログラム) が読み込まれるときに実行されるフックです。何度
     Gnus を起動しても、Emacs が起動してから終了するまでに普通はこのフッ
     クは一回しか実行されないことに注意してください。

`gnus-before-startup-hook'
     Gnus が起動するとき、最初に呼ばれるフックです。

`gnus-startup-hook'
     Gnus が起動された後に、一番最後に実行されるフックです。

`gnus-started-hook'
     Gnus の起動に成功した後に、一番最後に実行されるフックです。

`gnus-setup-news-hook'
     `.newsrc' ファイルを読み込んだ後で、グループバッファーを作成する前
     に実行されるフックです。

`gnus-check-bogus-newsgroups'
     もし `nil' でないと、Gnus は起動時にすべての偽グループを調べて削除
     します。「偽グループ」(bogus group) はあなたの `.newsrc' ファイル
     には存在するけれど、ニュースサーバーには実際には存在しない、という
     グループのことです。偽グループを調べるのにはかなり時間がかかるので、
     時間と資源を節約するために、この機能は使わないほうがいいでしょう。
     そして、代わりにグループバッファーで時々偽グループを調べるのが良い
     でしょう (*Note Group Maintenance::)。

`gnus-inhibit-startup-message'
     もし `nil' でないと、起動時のメッセージは表示されません。そのように
     すれば、仕事の代わりにニュースを読んでいるのを上司に気付かれにくくなるで
     しょう。この変数は `~/.gnus.el' がロードされる前に使われるので、
     `.emacs' に設定するべきである点を注意してください。

`gnus-no-groups-message'
     グループが一つも存在しないときに Gnus が表示するメッセージです。

`gnus-play-startup-jingle'
     もし `nil' でないと、起動時に Gnus の短い曲を演奏します。

`gnus-startup-jingle'
     上の変数が `nil' でないときに演奏される短い曲です。ディフォルトは
     `Tuxdemoon.Jingle4.au' です。



File: gnus-ja.info, Node: Group Buffer, Next: Summary Buffer, Prev: Starting Up, Up: Top

グループバッファー
******************

グループバッファー ("group buffer") は有効なグループを全部 (あるいは一
部を) 一覧表示します。これは Gnus を起動したときに最初に表示されるバッ
ファーで、Gnus が生きている限り決して消されることはありません。

* Menu:

* Group Buffer Format::         表示されている情報と変更の方法
* Group Maneuvering::           グループバッファーを移動するコマンド
* Selecting a Group::           実際にニュースを読む
* Subscription Commands::       購読、購読中止、消去
* Group Data::                  グループの情報を変更する
* Group Levels::                レベル? それって何?
* Group Score::                 あなたの好きなグループを見つけ出す方法
* Marking Groups::              グループに印を付けておいて、後で処理できる
* Foreign Groups::              グループの作成と修正
* Group Parameters::            グループ毎に違ったパラメーターを持たせられる
* Listing Groups::              Gnus はグループをいろいろな分け方で表示できる
* Sorting Groups::              グループの順番の配置替え
* Group Maintenance::           きれいな `.newsrc' の保ち方
* Browse Foreign Server::       サーバーを概観できる。何が読めるのか見てみよう
* Exiting Gnus::                ニュース読むのをやめて、仕事をしよう
* Group Topics::                グループを切り混ぜて、トピックごとに分割する
* Non-ASCII Group Names::       英字以外の名前のグループへのアクセス
* Searching::                   メールの検索エンジン
* Misc Group Stuff::            他にできること



File: gnus-ja.info, Node: Group Buffer Format, Next: Group Maneuvering, Prev: Group Buffer, Up: Group Buffer

グループバッファーの形式
========================

* Menu:

* Group Line Specification::    グループバッファーの見え方を決める
* Group Mode Line Specification::  グループバッファーのモード行
* Group Highlighting::          グループバッファーにきれいに色を付ける

グループモードのツールバーをカスタマイズすることができます。`M-x
customize-apropos RET gnus-group-tool-bar' を試してみてください。この機
能を利用できるのは Emacs だけですが。

ツールバーのアイコンは、今ではカーソルの位置に応じて正しく有効に、また
は無効にされるので、グループバッファー内での移動は遅くなります。これは
変数 `gnus-group-update-tool-bar' で禁止することができます。そのディフォ
ルト値は Emacs のバージョンに依存しています。



File: gnus-ja.info, Node: Group Line Specification, Next: Group Mode Line Specification, Prev: Group Buffer Format, Up: Group Buffer Format

グループ行の仕様
----------------

グループバッファーのディフォルトの形式はきれいでつまんないけど、これは
君の好きなように、サイコーにダサくすることもできます。

これがグループ行の例です。

          25: news.announce.newusers
      *    0: alt.fan.andrea-dworkin

とっても簡単でしょ?

`news.announce.newusers' には 25 の未読記事があるのがわかります。
`alt.fan.andrea-dworkin' には未読記事はないけれども、印を付けた記事がい
くつかあります (行頭のちっちゃなアスタリスクが見える?)。

この形式は `gnus-group-line-format' 変数をいじることで、どんな風に
でも変えられます。この変数は `format' の仕様風に動作します。つま
り (あのクソ) C 言語を使う人たちのため、printf の仕様とほぼ同じです。
*Note Formatting Variables::.

上記の行を生成するのは `%M%S%5y:%B%(%g%)\n' という値です。

コロンは、この行の中に必ず無くてはいけません。カーソルは何かの操作をし
た後は常にコロンのところに移動するからです。*Note Positioning
Point::. 他には何も必要ではありません--グループ名さえもです。表示されて
いる文字はすべてただの画面の飾りであり、Gnus がそれを調べることはありま
せん。Gnus は必要とするすべての実情報を、テキスト属性を使って憶えていま
す。

(もし君が、すごくヘンな、素晴らしい、表計算風のレイアウトを作ったとした
ら、みんな、君は会計の仕事が忙しくって、ニュースを読んで時間を無駄使い
したりなんかしてない、って信じてくれるよ。)

以下が使用できるフォーマット文字のリストです。

`M'
     そのグループに印の付いた記事しか無いときは、アスタリスク文字。

`S'
     そのグループが購読されているかどうか。

`L'
     購読度のレベル。

`N'
     未読記事の数。

`I'
     保留記事の数。

`T'
     印付き記事の数。

`R'
     既読記事の数。

`U'
     まだ読まれたことが無い記事の数。

`t'
     推定全記事数 (これは実際は MAX-NUMBER - MIN-NUMBER + 1)。

     Gnus がこの推定を使うのは、NNTP プロトコルは能率の良い MAX-NUMBER
     と MIN-NUMBER へのアクセスを提供するものの、本当の未読記事の数を得
     るには必ずしも能率的ではないからです。ヒステリックなレーズン (訳
     注:「歴史的な理由」のモジり) により、メールバックエンドにおいても、
     限定された同じインターフェースを使って、本当の未読記事の数を能率的
     に得ることはできるかもしれません。この制限を Gnus から取り払うこと
     はバックエンドのインターフェースを変更することを意味し、それは楽な
     仕事ではありません。

     `nnml' バックエンド (*Note Mail Spool::) には、この欠陥を巧みに補う
     「グループ圧縮」(group compaction) という機能があります。それは、記事の
     番号を 1 から順に振り直してすきまを取り除けば正しい全記事数を得ることが
     できる、という着想によります。将来は他のバックエンドもこれをサポートする
     かもしれません。全記事数をまあまあ最新の状態にしておくためには、時々グルー
     プを (またはサーバーのディレクトリーを) 圧縮する必要があるでしょう。
     *Note Misc Group Stuff::, *Note Server Commands::.

`y'
     未読でも、印付きでも、保留でもない記事の数。

`i'
     印付き記事と保留記事の数。

`g'
     グループ名のフルネーム。

`G'
     グループ名。

`C'
     グループのためのコメント (*Note Group Parameters::)、またはグルー
     プパラメーターにコメントの要素が無い場合はグループ名。

`D'
     ニュースグループの説明。これらが現れる前に、グループの説明を読む必
     要があります。それには `gnus-read-active-file' を設定するか、グルー
     プバッファーで `M-d' コマンドを使ってください。

`o'
     司会者付きの場合 `m'。

`O'
     司会者付きの場合 `(m)'。

`s'
     選択方法。

`B'
     そのグループの概略バッファーが開いているかどうか。

`n'
     どこからの選択か。(訳注: バックエンドのシンボル名)

`z'
     外部選択方法が使われている場合、`<%s:%n>' と同じ文字列。

`P'
     トピック (*Note Group Topics::) のレベルに応じた字下げ。

`c'
     短い (省略した) グループ名。`gnus-group-uncollapsed-levels' 変数は、
     どのレベルまでグループ名を全部残すかを示します。ディフォルトは 1
     です--この意味は、`gnu.emacs.gnus' のようなグループ名を
     `g.e.gnus' に短縮するということです。

`m'
     そのグループに最近新着メールが届いている場合は `%'
     (`gnus-new-mail-mark')。

`p'
     `#' (`gnus-process-mark') で、そのグループにプロセス印が付いている
     ことを示します。

`d'
     最後にいつこのグループを読んだかを示す文字列 (*Note Group
     Timestamp::)。

`F'
     キャッシュとエージェントの両方によって取得された記事がディスクに占
     める容量。値はカラム幅を最小にするために、自動的にバイト (B)、キロ
     バイト (K)、メガバイト (M)、またはギガバイト (G) に縮尺されます。
     固定幅カラム用には %7F の形式で足ります。

`u'
     利用者定義指定。フォーマット文字列中で、この次の文字はアルファベッ
     ト文字でなければいけません。Gnus は
     `gnus-user-format-function-'`X' 関数を呼び出します。ここで `X' は
     `%u' に続いている文字です。この関数は引数に一つのダミーパラメーター
     を渡されます。この関数は、他の各指定文字の情報と同様に、バッファー
     に挿入される文字列を返さなければなりません。

すべての「〜の数」の指定は、もしその情報が利用できない場合にはアスタリ
スク (`*') で埋められます--例えば、起動されていない外部グループや、不正
な基本グループの場合です。



File: gnus-ja.info, Node: Group Mode Line Specification, Next: Group Highlighting, Prev: Group Line Specification, Up: Group Buffer Format

グループモード行の仕様
----------------------

モード行は `gnus-group-mode-line-format' (*Note Mode Line
Formatting::) を設定することで変更できます。こいつは指定文字をあんまり
たくさん知っていません。

`S'
     基本ニュースサーバー。
`M'
     基本選択方法。



File: gnus-ja.info, Node: Group Highlighting, Prev: Group Mode Line Specification, Up: Group Buffer Format

グループのハイライト
--------------------

グループバッファーのハイライトは `gnus-group-highlight' 変数によって制
御されます。これは `(FORM . FACE)' のようなものを要素に持つ連想リストで
す。FORM が評価された結果が、`nil' 以外の何かになると、その行に対して
FACE が使用されます。

以下がこの変数の値の例です。これは背景が暗い設定ではきれいに見えるかも
しれません。

     (cond (window-system
            (setq custom-background-mode 'light)
            (defface my-group-face-1
              '((t (:foreground "Red" :bold t))) "First group face")
            (defface my-group-face-2
              '((t (:foreground "DarkSeaGreen4" :bold t))) "Second group face")
            (defface my-group-face-3
              '((t (:foreground "Green4" :bold t))) "Third group face")
            (defface my-group-face-4
              '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
            (defface my-group-face-5
              '((t (:foreground "Blue" :bold t))) "Fifth group face")))

     (setq gnus-group-highlight
           '(((> unread 200) . my-group-face-1)
             ((and (< level 3) (zerop unread)) . my-group-face-2)
             ((< level 3) . my-group-face-3)
             ((zerop unread) . my-group-face-4)
             (t . my-group-face-5)))

*Note Faces and Fonts:: も参照してください。

この form が評価されるときに動的に束縛されている変数には以下のものがあ
ります。

`group'
     グループ名。
`unread'
     そのグループの未読記事の数。
`method'
     選択方法。
`mailp'
     そのグループがメールのグループかどうか。
`level'
     そのグループのレベル。
`score'
     そのグループのスコア。
`ticked'
     そのグループ中の印の付いた記事の数。
`total'
     そのグループ中の全記事数。もっと正確に言うと、MAX-NUMBER マイナス
     MIN_NUMBER プラス 1。
`topic'
     トピックマイナーモードを使用している時、この変数は挿入されている現
     在のトピックに束縛されます。

この form が評価 (`eval') されるときは、ポイントは問題のグループの行頭
にあります。従って、通常の Gnus の関数のほとんどを使ってそのグループの
情報を取ってくることができます。

`gnus-group-update-hook' はグループ行が変更されたときに呼び出されます。
これは `gnus-visual' が `nil' のときは呼び出されません。このフックはディ
フォルトでは `gnus-group-highlight-line' を呼び出します。



File: gnus-ja.info, Node: Group Maneuvering, Next: Selecting a Group, Prev: Group Buffer Format, Up: Group Buffer

グループ操作
============

すべての移動コマンドは数値接頭引数を理解するので、期待する通りの動作を
します。たぶんね。

`n'
     次の未読記事のあるグループに移動します
     (`gnus-group-next-unread-group')。

`p'
`DEL'
     一つ前の未読記事のあるグループに移動します
     (`gnus-group-prev-unread-group')。

`N'
     次のグループに移動します (`gnus-group-next-group')。

`P'
     一つ前のグループに移動します (`gnus-group-prev-group')。

`M-n'
     一つ前の同じレベル (もしくはそれより小さいレベル) の未読グループに
     移動します (`gnus-group-prev-unread-group-same-level')。

`M-p'
     次の同じレベル (もしくはそれより小さいレベル) の未読グループに移動
     します (`gnus-group-next-unread-group-same-level')。

次の三つの命令はグループにジャンプするためのものです:

`j'
     グループにジャンプします (それが見えるようになっていなかったら見え
     るようにします) (`gnus-group-jump-to-group')。kill されているグルー
     プも、生きているグループと同様にジャンプできます。

`,'
     最も小さいレベルの未読グループにジャンプします
     (`gnus-group-best-unread-group')。

`.'
     最初の未読記事のあるグループにジャンプします
     (`gnus-group-first-unread-group')。

`gnus-group-goto-unread' を `nil' にすると、すべての移動コマンドは、次
の未読グループではなく次のグループに移動するようになります。そのコマン
ドが次の未読グループに移動すると言い張っていてもです。ディフォルトは
`t' です。

概略バッファーを出たときに `gnus-summary-next-group-on-exit' が`t' だっ
たら、グループバッファーで次の未読のグループに移動します。それ以外の場
合は出たグループに留まります。ディフォルトは `t' です。

     訳注: `gnus-group-goto-unread' が次の未読グループか単に次のグルー
     プのどちらに移動するかを指定するのに対して
     `gnus-summary-next-group-on-exit' は移動するかしないかを指定するた
     めに使います。ただし後者は `q' (または `Z Q',
     `gnus-summary-exit') で概略バッファーを出たときだけに効果を及ぼし
     ます。



File: gnus-ja.info, Node: Selecting a Group, Next: Subscription Commands, Prev: Group Maneuvering, Up: Group Buffer

グループの選択
==============

`SPACE'
     現在のグループを選択し、概略バッファーに切り替えて最初の未読記事を
     表示します (`gnus-group-read-group')。もしそのグループに未読記事が
     無い、もしくはこの命令に数値以外の接頭引数を与えると、Gnus はサー
     バーからこのグループのすべての古い記事を取得しようとします。N の数
     値接頭引数を与えると、Gnus の取得する記事数は N になります。N が正
     の数であれば Gnus は新しい方から N 個の記事を取得し、N が負の数で
     あれば Gnus は古い方から `abs(N)' 個の記事を取得します。

     したがって、`SPC' では普通にグループに入り、`C-u SPC' では古い記
     事が現れます。`C-u 4 2 SPC' では 42 個の最新の記事を取得し、`C-u
     - 4 2 SPC' では 42 個の最も古い記事を取得します。

     グループにいる (概略バッファーにいる) ときは、`M-g' で新しい記事を
     取得できるし、`C-u M-g' では古い記事を表示することができます。

`RET'
     現在のグループを選択し、概略バッファーに切り替えます
     (`gnus-group-select-group')。`gnus-group-read-group' と同じ引数を
     取ります--唯一の違いは、グループに入ったときに最初の未読記事を表示
     しない、ということです。

`M-RET'
     これは上記のコマンドと同じ動作をしますが、「ゴタゴタ」は最低限にし
     ようとします (`gnus-group-quick-select-group')。スコア・kill の処
     理は行なわれず、ハイライトも記事消去もしません。これは、あなたが本
     当に急いでいて、どっかのやたらでっかいグループに入らなければいけな
     いときに役に立つかもしれません。また、接頭引数に 0 を与えれば (す
     なわち `0 M-RET')、Gnus は概略バッファーを作ろうとさえしません。こ
     れは概略バッファーを作る前にスレッド表示を切り替えたいとき役に立ち
     ます (*Note Summary Generation Commands::)。

`M-SPACE'
     これは `RET' コマンドと同じ動作をするさらにもう一つのコマンドです
     が、このコマンドは記事消去と保留記事を隠す処理を行ないません
     (`gnus-group-visible-select-group')。

`C-M-RET'
     最後にこのコマンドは、現在のグループを一度限り、その内容に一切の処
     理をすることのないように選択します
     (`gnus-group-select-group-ephemerally')。スレッド表示さえも行なわ
     れません。この方法で選択した後にこのグループに対して行なったことは
     すべて、その後に影響を与えることはありません。

`gnus-large-newsgroup' 変数は、何を大きなグループと考えるべきかを Gnus
に与えます。`nil' だったら、どのグループも大きいと考えません。ディフォ
ルト値は 200 です。グループに (未読と可視の) 記事がこの数以上あれば、
Gnus はそのグループに入る前に利用者に確認を求めます。利用者はサーバーか
らいくつの記事を取得するかを指定できます。もし利用者が負の数 (-N) を指
定すれば、古い方から N 個の記事を取得します。正の数であれば、新しく到着
した方から N 個の記事を取得します。

`gnus-large-ephemeral-newsgroup' は `gnus-large-newsgroup' と同じですが、
一時ニュースグループのためにだけ使われます。

いくつかのニュースサーバーのとあるグループでは、期限切れ消去されない少
数の非常に古い記事と最新のものとの間に大きな隙間があるかもしれません。
そういう場合、そのサーバーは `LIST ACTIVE group' コマンドに対して例えば
`(1 . 30000000)' のようなデータを返すでしょう。たとえ実際には 1〜10 と
29999900〜30000000 の記事しか無くても、Gnus は最初からそのことを知って
いるわけではないので 30000000 通の記事を受け取るための準備をします。し
かしそれでは何百メガバイトのメモリーを消費してしまうし、場合によっては
Emacs を立ち往生させてしまうかもしれません。もしそのようなサーバーを使
うのであれば、変数 `gnus-newsgroup-maximum-articles' を正の数に設定して
ください。値は、あらゆるグループでその数の最新の記事以外を Gnus が無視
することを意味します。例えば 10000 という数は Gnus に 29990001〜
30000000 の記事だけを取得させるようにします (最新の記事番号が 30000000
だった場合です)。この変数に数値を設定すると、非常に古い記事を読むことが
できなくなってしまうかもしれないことに注意してください。変数
`gnus-newsgroup-maximum-articles' のディフォルト値は `nil' で、その場合
Gnus は古い記事を無視しません。

もし `gnus-auto-select-first' が非-`nil' だったら、`SPACE' コマンドでグ
ループに入ったときに自動的に記事を選択します。どの記事が選択されるかは、
変数 `gnus-auto-select-subject' で制御されます。この変数に設定できる有
効な値は:

`unread'
     最初の未読記事の表題の行にポイントを移動させます。

`first'
     最初の記事の表題の行にポイントを移動させます。

`unseen'
     まだ読まれたことが無い最初の記事の表題の行にポイントを移動させます。

`unseen-or-unread'
     まだ読まれたことが無い最初の記事があれば、その記事の表題の行にポイ
     ントを移動させ、無かったら最初の未読記事の表題の行にポイントを移動
     させます。

`best'
     スコアが最も高い未読記事の表題の行にポイントを移動させます。

この変数は関数であることもできます。その場合、その関数は表題の行にポイ
ントを移動させるために呼ばれます。

もしあるグループで自動記事選択をやめたいのであれば (例えばでっかい記事
のあるバイナリーグループでは、とか)、グループが選択されたときに呼び出さ
れる `gnus-select-group-hook' の中で変数 `gnus-auto-select-first' を
`nil' に設定することができます。



File: gnus-ja.info, Node: Subscription Commands, Next: Group Data, Prev: Selecting a Group, Up: Group Buffer

購読制御コマンド
================

`S t'
`u'
     現在のグループを購読する/しないを切り替えます
     (`gnus-group-unsubscribe-current-group')。

`S s'
`U'
     グループを購読するかどうかを確認し、購読します。すでに購読するよう
     になっている場合には、購読を止めます
     (`gnus-group-unsubscribe-group')。

`S k'
`C-k'
     現在のグループを kill します (`gnus-group-kill-group')。

`S y'
`C-y'
     最後に kill したグループを yank します (`gnus-group-yank-group')。

`C-x C-t'
     二つのグループの順序を置き換えます
     (`gnus-group-transpose-groups')。これは本当は購読コマンドではあり
     ませんが、kill と yank を何度か続ける代わりにこのコマンドが使えま
     す。

`S w'
`C-w'
     リージョン内のすべてのグループを kill します
     (`gnus-group-kill-region')。

`S z'
     すべてのゾンビグループを kill します
     (`gnus-group-kill-all-zombies')。

`S C-k'
     あるレベルのグループをすべて kill します
     (`gnus-group-kill-level')。kill した後、これらのグループを yank で
     戻すことはできないので、このコマンドはいくらか注意して使ってくださ
     い。このコマンドが本当に便利になるのは、`.newsrc' に捨ててしまいた
     い未購読のグループがたくさんあるときだけです。レベル 7 で `S C-k'
     を行なうと、`.newsrc' ファイル中にメッセージ番号がない未購読グルー
     プをすべて kill します。

*Note Group Levels:: も参照してください。



File: gnus-ja.info, Node: Group Data, Next: Group Levels, Prev: Subscription Commands, Up: Group Buffer

グループデータ
==============

`c'
     そのグループ内のすべての無印の記事を既読にします
     (`gnus-group-catchup-current')。グループバッファーから既読にした場
     合は `gnus-group-catchup-group-hook' が呼び出されます。

`C'
     そのグループの全記事を、印付きの記事も含めて既読にします
     (`gnus-group-catchup-current-all')。

`M-c'
     現在のグループのすべてのデータをクリアします--印と既読記事のリスト
     を消し去ります (`gnus-group-clear-data')。

`M-x gnus-group-clear-data-on-native-groups'
     もし NNTP サーバーを別のものに切り替えたとすると、すべての印と既読
     情報はもう役には立ちません。このコマンドを使って基本グループのすべ
     てのデータをクリアすることができます。注意して使ってね。



File: gnus-ja.info, Node: Group Levels, Next: Group Score, Prev: Group Data, Up: Group Buffer

グループレベル
==============

すべてのグループは「購読度」("subscribedness") のレベルを持ちます。例え
ば、あるグループがレベル 2 だとすれば、それはレベル 5 のグループよりも
「より購読している」ということです。Gnus に対して、あるレベルかそれより
小さいレベルのグループのみ一覧表示するように頼むこともできるし (*Note
Listing Groups::)、あるレベルかそれより小さいレベルのグループの新着記事
のみを確認することもできます (*Note Scanning New Messages::)。

忘れないで: グループのレベルが大きいほど、重要度は低くなるということ。

`S l'
     現在のグループのレベルを設定します。数値の接頭引数が与えられると、
     そこから N 個のグループのレベルが設定されます。レベルを入力するた
     めのプロンプトが出ます。

Gnus はレベル 1 から `gnus-level-subscribed' (この値を含む) (ディフォル
トは 5) までのグループを購読、`gnus-level-subscribed' (この値を含まない)
から `gnus-level-unsubscribed' (この値を含む) (ディフォルトは 7) までの
グループを非購読、`gnus-level-zombie' をゾンビ (歩く屍) (ディフォルトは
8)、`gnus-level-killed' を kill されている (完全に死んでいる) (ディフォ
ルトは 9) と判断します。Gnus は購読と非購読のグループはまったく同様に扱
いますが、ゾンビと kill グループは、どの記事を読んだか、存在するかなど
の情報を一切持ちません。この死んでいるグループと生きているグループの区
別は、別にそれがきれいだからとか賢いからというわけではなく、純粋に効率
的な理由のためです。

メール用のグループは (もしあれば) 非常に小さいレベル (例えば 1 か 2) に
しておくことをお勧めします。

次の Gnus のディフォルトの動作の説明は、ことによると、これらのレベルの
すべてを理解する助けになるかもしれません。ディフォルトでは、Gnus は講読
している空でないグループを表示しますが、`L' を叩くことによって空のグルー
プや非講読のグループも表示させることができます。つまり、非講読のグルー
プは隠されている、と言っても良いでしょう。

ゾンビと kill グループは、ディフォルトでは隠されている点で非講読のグルー
プに似ています。しかし、Gnus がニュースサーバーに対してゾンビと kill グ
ループに関する情報 (記事数、未読記事数) の問い合わせをしない点で、購読
および非購読のグループとは違っています。ふつう、あなたは興味の無いグルー
プを `C-k' で kill しますよね。もし、ほとんどのグループが kill されてい
ると、Gnus は速くなります。

なぜ Gnus はゾンビと kill グループを区別するのでしょう?  ええと、サーバー
に新しいグループができると、Gnus はディフォルトでそれをゾンビにします。
これは、あなたがふつうは新しいグループに煩わされないことを意味しますが、
あなたは `A z' で新しいグループのリストを得ることができます。あなたは好
みのものを講読し、要らないものは kill すれば良いのです。(`A k' で kill
されたグループのリストを表示します。)

もしレベル変数で遊びたいのであれば、多少注意をしてまわる必要があります。
いったんそれを設定したら、二度とそれに触らないでください。さらに言えば、
自分で何をやっているかを正確に理解していない限り、一切触らないでくださ
い。

身近に関係する二つの変数は `gnus-level-default-subscribed' (ディフォル
トは 3) と `gnus-level-default-unsubscribed' (ディフォルトは 6) です。
これらは新しいグループが (非) 購読されたときのレベルです。もちろん、こ
れら二つの変数の値は、意味のある正しい範囲でなくてはなりません。

`gnus-keep-same-level' が `nil' 以外であれば、移動コマンドのいくつかは
同一 (あるいはそれより小さい) レベルのグループのみの移動になります。特
に、あるグループの最後の記事から次のグループに移るとき、次の同一 (ある
いはそれより小さい) レベルのグループに移動します。これは残りのグループ
を読むより先に、より重要なグループを読んでおきたいときには便利かもしれ
ません。

もしこの値が `best' だったら、最も重要な (最もレベルの値が小さい) グルー
プに移動します。

ディフォルトでは `gnus-group-default-list-level' と同じかそれより小さい
レベルのグループが、グループバッファーに一覧表示されます。

`gnus-group-list-inactive-groups' が `nil' 以外であれば、未読のグループ
にアクティブでないグループも一緒に表示します。この変数はディフォルトで
は `t' です。もしこれが `nil' であれば、アクティブでないグループは表示
されません。

`gnus-group-use-permanent-levels' が `nil' 以外であれば、いったん `g'
や `l' コマンドの接頭引数にレベルを与えると、その後のすべてのコマンドに
おいてそのレベルが「作用する」レベルになります。

Gnus は通常、`gnus-activate-level' かそれより小さいレベルのグループのみ
を起動します (つまりサーバーに問い合わせをする)。購読していないグループ
を起動したくなければ、この変数を例えば 5 に設定するとよいかもしれません。
ディフォルトは 6 です。



File: gnus-ja.info, Node: Group Score, Next: Marking Groups, Prev: Group Levels, Up: Group Buffer

グループのスコア
================

普通は重要なグループは高レベルにしておくでしょうけれども、この方法では
少々制限がきついですよね。ひょっとしたら、グループをどれくらい頻繁に読
むかによってグループバッファーを並べ替えたいなあ、なんて思いませんか?
理にかなってるでしょ?

「グループスコア」("group score") はそのためのものです。Gnus に以下で説
明されている機構で、それぞれのグループに対してスコアを指定することがで
きます。そしてグループバッファーをこのスコアを基に並べ替えることができ
ます。あるいは、スコア順で並べ替えてその後レベルで並べ替えることもでき
ます。(レベルとスコアをひとまとめにして、グループの「ランク」("rank")
と呼びます。レベルが 4 でスコアが 1 のグループは、レベルが 5 でスコアが
300 のグループよりも高いランクとなります。(レベルの方が重要度が高く、ス
コアの方は重要度が低くなります。))

頻繁に読むグループに、めったに読まないグループよりも高いスコアを与えた
いときは、`gnus-summary-exit-hook' フックに
`gnus-summary-bubble-group' 関数を追加することができます。これでバブル
並べ替えの実行結果が (並べ替えの後で) 得られるでしょう。概略モードを終
了するたびにこの活動をさせたいのであれば、同じフックに
`gnus-group-sort-groups-by-rank' または
`gnus-group-sort-groups-by-score' を追加できますが、いくらか遅くなるで
しょう。



File: gnus-ja.info, Node: Marking Groups, Next: Foreign Groups, Prev: Group Score, Up: Group Buffer

グループへの印
==============

もしいくつかのグループに対して何らかの命令を実行したい場合で、それらが
グループバッファーに連続してある場合には、通常通り命令に対して数値接頭
引数を与えるだけです。そうすればほとんどのグループ命令は、これらのグルー
プに対してあなたの命令に従います。

しかしそれらのグループが順番に並んでいない場合においても、いくつかのグ
ループに対して命令を実行することができます。単に始めにプロセス印でグルー
プに印を付けておき、そして命令を実行するだけです。

`#'
`M m'
     現在のグループに印を付ける (`gnus-group-mark-group')。

`M-#'
`M u'
     現在のグループから印を削除する (`gnus-group-unmark-group')。

`M U'
     すべてのグループから印を削除する (`gnus-group-unmark-all-groups')。

`M w'
     ポイントとマークの間のすべてのグループに印を付ける
     (`gnus-group-mark-region')。

`M b'
     バッファー内のすべてのグループに印を付ける
     (`gnus-group-mark-buffer')。

`M r'
     ある正規表現に合致するすべてのグループに印を付ける
     (`gnus-group-mark-regexp')。

*Note Process/Prefix:: も参照してください。

プロセス印が付けられているすべてのグループに対して何かの命令を実行した
いときは、`M-&' (`gnus-group-universal-argument') 命令を使うことができ
ます。プロンプトから実行したい命令を入力します。



File: gnus-ja.info, Node: Foreign Groups, Next: Group Parameters, Prev: Marking Groups, Up: Group Buffer

外部グループ
============

以下では、一般的な外部グループの作成、変更を行なうグループモードの命令
をいくつか、および特別な目的のグループを簡単に作成する命令を紹介します。
これらの命令はすべて、新規に作成したグループをポイント位置に挿入しま
す---`gnus-subscribe-newsgroup-method' は参照されません。

これらグループを編集するコマンド群で行なった変更は `~/.newsrc.eld'
(`gnus-startup-file') に格納されます。代わりの手段として、変数
`gnus-parameters' も用意されています (*Note Group Parameters::)。

`G m'
     新しいグループを作成します (`gnus-group-make-group')。Gnus はプロン
     プトを表示して、名前と方法と、場合によっては "address" の入力を求め
     てきます。より簡単に NNTP グループを購読する方法については、
     *Note Browse Foreign Server:: を参照してください。

`G M'
     一時ニュースグループを作成します
     (`gnus-group-read-ephemeral-group')。 Gnus はプロンプトを表示して、
     名前、方法および "address" の入力を求めます。

`G r'
     現在のグループの名前を、何か別のものに変更します
     (`gnus-group-rename-group')。これはある種のグループ--主にメールグ
     ループに対してのみ有効です。このコマンドはバックエンドによっては非
     常に遅いことも有り得ます。

`G c'
     グループパラメーターをカスタマイズする (`gnus-group-customize')。

`G e'
     現在のグループの選択方法を修正するためのバッファーに移動します
     (`gnus-group-edit-group-method')。

`G p'
     グループパラメーターを修正するためのバッファーに移動します
     (`gnus-group-edit-group-parameters')。

`G E'
     グループ情報を修正するためのバッファーに移動します
     (`gnus-group-edit-group')。

`G d'
     ディレクトリーグループを作成します (*Note Directory Groups::)。ディ
     レクトリー名をプロンプトで入力します
     (`gnus-group-make-directory-group')。

`G h'

     Gnus ヘルプグループを作成します (`gnus-group-make-help-group')。

`G a'
     Gnus アーカイブグループを作成します
     (`gnus-group-make-archive-group')。ディフォルトでは最も最近の記事
     を指しているグループが作成されますが
     (`gnus-group-recent-archive-directory')、接頭引数を与えるとすべて
     の記事を含むグループが `gnus-group-archive-directory' を基に作成さ
     れます。

`G k'
     kiboze グループを作成します。プロンプトで名前と、kiboze グループに
     「含めたい」グループに合う正規表現と、ヘッダーに合う文字列の組を入
     力します (`gnus-group-make-kiboze-group')。*Note Kibozed
     Groups::.

`G D'
     任意のディレクトリーを `nneething' バックエンドニュースグループであ
     るかのように読み込みます (`gnus-group-enter-directory')。
     *Note Anything Groups::.

`G f'
     何らかのファイルをもとにグループを作成します
     (`gnus-group-make-doc-group')。このコマンドに接頭引数を与えた場合、
     ファイル名とファイルタイプをプロンプトで入力します。現在サポートさ
     れているファイルタイプは `mbox', `babyl', `digest', `news',
     `rnews', `mmdf', `forward', `rfc934', `rfc822-forward',
     `mime-parts', `standard-digest', `slack-digest', `clari-briefs',
     `nsmail', `outlook', `oe-dbx' および `mailman' です。接頭引数なし
     でこのコマンドを実行すると、Gnus はファイルタイプを推測します。
     *Note Document Groups::.

`G u'
     `gnus-useful-groups' にあるグループの一つを作ります
     (`gnus-group-make-useful-group')。

`G w'
     ウェブ検索結果をもとに一時的なグループを作成しま
     す (`gnus-group-make-web-group')。このコマンドに接頭引数を与えると、
     一時的ではなく固定したグループを作成します。プロンプトで検索エンジンの種
     類 (search engine type) と検索文字列を入力します。有効な検索エンジンの種
     類には `google', `dejanews', `gmane' があります。
     *Note Web Searches::.

     もし、`google' 検索エンジンを用いる場合には、`shaving
     group:alt.sysadmin.recovery' のような合致する文字列を用いることに
     よって、検索対象を特定のグループに限定することが可能です。

`G R'
     RSS feed に基づくグループを作りま
     す (`gnus-group-make-rss-group')。URL の入力を促されます。
     *Note RSS::.

`G DEL'
     この関数は現在のグループを削除します (`gnus-group-delete-group')。
     接頭引数が与えられると、この関数はそのグループ内の全記事を本当に削
     除し、グループ自身をこの世から強制的に抹殺してしまいます。接頭引数
     は、あなたが何をやろうとしているか、本当に自信があるときにのみ使っ
     てください。まあ、このコマンドは (`nntp' グループのような) 読み出
     し専用グループには使えませんけれど。

`G V'
     新しい、新鮮な、空の `nnvirtual' グループを作成します
     (`gnus-group-make-empty-virtual')。*Note Virtual Groups::.

`G v'
     現在のグループを `nnvirtual' グループに追加します
     (`gnus-group-add-to-virtual')。これはプロセス印/接頭引数の習慣に従
     います。

さまざまな選択方法に関するさらなる情報は *Note Select Methods:: を参照
してください。

もし `gnus-activate-foreign-newsgroups' が正の数であれば、Gnus は起動時
に、この数かそれよりも小さいレベルの外部グループをすべてチェックします。
これは特に違った NNTP サーバーからたくさんのグループを購読している場合
には、しばらく時間がかかるかもしれません。*Note Group Levels:: も参照し
てください。`gnus-activate-level' も外部ニュースグループの活性化に影響
を及ぼします。

以下のコマンドは一時的なグループを作ります。それらは Group バッファーか
らだけではなく、どの Gnus バッファーからも呼ぶことができます。

`gnus-read-ephemeral-gmane-group'
     Gmane.org で一時的なグループを講読するためのコマンドです。記事は
     `gnus-gmane-group-download-format' によって指定された URL を使って
     HTTP でダウンロードされます。Gnus はグループ名と最初の記事番号およ
     び記事数の範囲を尋ねます。

`gnus-read-ephemeral-gmane-group-url'
     このコマンドは `gnus-read-ephemeral-gmane-group' に似ていますが、
     グループ名と最初の記事番号および記事数の範囲は、与えられた URL を
     元に決定されます。サポートされている URL の形式は、例えば次のよう
     なものです:
     `http://thread.gmane.org/gmane.foo.bar/12300/focus=12399',
     `http://thread.gmane.org/gmane.foo.bar/12345/',
     `http://article.gmane.org/gmane.foo.bar/12345/',
     `http://permalink.gmane.org/gmane.foo.bar/12345/', および
     `http://news.gmane.org/group/gmane.foo.bar/thread=12345'。

`gnus-read-ephemeral-emacs-bug-group'
     一時的なグループで Emacs のバグリポートを講読します。Gnus はバグの
     番号を尋ねます。ディフォルトは現在位置の番号です。URL は
     `gnus-bug-group-download-format-alist' で指定します。

`gnus-read-ephemeral-debian-bug-group'
     一時的なグループで Debian のバグリポートを講読します。
     `gnus-read-ephemeral-emacs-bug-group' に似ています。

これらのコマンドのいくつかは、記事のボタンとしても便利です。
*Note Article Buttons::.

例:
     (require 'gnus-art)
     (add-to-list
      'gnus-button-alist
      '("#\\([0-9]+\\)\\>" 1
        (string-match "\\<emacs\\>" (or gnus-newsgroup-name ""))
        gnus-read-ephemeral-emacs-bug-group 1))



File: gnus-ja.info, Node: Group Parameters, Next: Listing Groups, Prev: Foreign Groups, Up: Group Buffer

グループパラメーター
====================

グループパラメーターは、ある特定のグループに固有な情報を保持します。

グループパラメーターの修正には `G p' か `G c' 命令を使ってください (`G
p' は Lisp ベースの、`G c' は Custom ふうのインターフェースを提供しま
す)。トピックパラメーターについて読んでみることも面白いでしょう (*Note
Topic Parameters::)。加えて、`gnus-parameters' 変数を介してグループパラ
メーターを設定することもできます。下記参照してください。

以下はグループパラメーターリストの例です:

     ((to-address . "ding@gnus.org")
      (auto-expire . t))

それぞれの要素は『点対』(dotted pair)---つまり点 (dot) の前に鍵、点の後
ろに値があるもの、で構成されます。すべてのパラメーターはこの形式を取り
ますが、*例外* としてローカル変数の指定は点対ではなく通常のリスト (訳注:
後述の `(VARIABLE FORM)' の項を参照) になります。

いくつかのパラメーターは対応するカスタマイズ可能な変数を持っています。
それらは正規表現と値の連想リストです。

以下は利用可能なグループパラメーターです:

`to-address'
     フォローアップとニュースへの投稿をするときに使用されるアドレス。

          (to-address . "some@where.com")

     これは主に、閉じたメーリングリストを表わすメールグループにおいて便
     利なものです--すなわちメーリングリストに投稿する人はすべてそれを購
     読しているはず、というメーリングリストのことです。このパラメーター
     を使用すると、メールはそのメーリングリストにしか投稿されないことが
     保証されるので、参加者はあなたのフォローアップ記事を二通受け取るこ
     とはありません。

     `to-address' を指定すると、そのグループが外部グループであるかどう
     かに関わらず有効になります。例えば `fa.4ad-l' というグループがサー
     バー上にあったとしましょう。これは本当のニュースグループですが、サー
     バーはメールニュースゲートウェイを通して記事を受け付けます。つまり
     このグループに対して直接投稿することは不可能で、代わりにそのメーリ
     ングリストにメールを送信しなければなりません。

     `gnus-parameter-to-address-alist' も参照してください。

`to-list'
     そのグループで `a' を押したときに使用されるアドレス。

          (to-list . "some@where.com")

     これはフォローアップをしたときは完全に無視されます--例外はそれが
     ニュースグループを表わしているときは、`f' を押したときにメールグルー
     プのルールが適用されるということです。

     もし `a' コマンドをメールグループで実行したときに、`to-list' グルー
     プパラメーターも `to-address' もグループパラメーターも無ければ、
     `to-list' グループパラメーターは、`gnus-add-to-list' が `t' に設定
     されていればメッセージ送信時に自動的に付加されます。

     もしこのグループパラメーターが設定されていると、概略バッファーに入っ
     たときに `gnus-mailing-list-mode' が有効になります。

     `gnus-parameter-to-list-alist' も参照してください。

     
`subscribed'
     もしこのパラメーターが `t' に設定されていると、Gnus はあなたがこの
     グループを to-address と to-list パラメーターのアドレスで購読して
     いるメーリングリストであると解釈します。この情報を Gnus に与えるこ
     とは、あなたがそれらのメーリングリストに投稿するときに正しい
     Mail-Followup-To ヘッダーを生成するための (ほんの) 第一歩です。二
     歩目は `.gnus.el' に以下を入れることです。

          (setq message-subscribed-address-functions
                '(gnus-find-subscribed-addresses))

     利用できる MFT 対応機能を完全に扱うには、ここ (*Note メーリングリ
     スト: (message-ja)Mailing Lists.) を見てください。

`visible'
     グループパラメーターのリスト中に `(visible . t)' という要素があれ
     ば、そのグループはグループバッファーにおいて、未読記事があるかどう
     かに関わらず、常に表示されます。

     このパラメーターを `gnus-parameters' を介して設定することはできま
     せんが、代わりに `gnus-permanently-visible-groups' を使えば良いで
     しょう。

`broken-reply-to'
     `(broken-reply-to . t)' という要素があれば、そのグループでは
     `Reply-To' は無視され、`reply-to' が
     `gnus-boring-article-headers' の部分であれば、ヘッダーが隠されると
     いう意味です。これはある listserv によるメーリングリストを購読して
     いて、それが `Reply-To' 欄を listserv 自身に返すように付けられてい
     る場合に有効でしょう。これはおかしな振る舞いです。だからこれが要る
     んです!

`to-group'
     `(to-group . "some.group.name")' という要素は、そのグループへの投
     稿はすべて `some.group.name' に送られる、という意味です。

`newsgroup'
     グループパラメーターリストに `(newsgroup . t)' があれば、Gnus はす
     べての応答をニュース記事に対する応答であるかのように扱います。これ
     は実際にはニュースグループのミラーであるメールグループに対して有効
     です。

`gcc-self'
     グループパラメーターリストに `(gcc-self . t)' があれば、新しく作成
     するメッセージは現在のグループに `Gcc' されます。もし
     `(gcc-self . none)' があれば、`Gcc:' 欄は生成されず、
     `(gcc-self . "string")' があればこの文字列はそのまま `gcc' 欄に挿
     入されます。このパラメーターは以下で説明するどんなディフォルトの
     `Gcc' の規則よりも優先されます (*Note Archived Messages::)。

     *警告*: `nntp' (またはその種の) グループのパラメーターリストに
     `(gcc-self . t)' を加えることに効力はありません。`nntp' サーバーは
     記事を受け入れません。

`auto-expire'
     グループパラメーターに `(auto-expire . t)' のような要素があれば、す
     べての既読記事は期限切れ消去されるように印を付けられます。他の方法は、
     *Note Expiring Mail::.

     `gnus-auto-expirable-newsgroups' も参照してください。

`total-expire'
     グループパラメーターに `(total-expire . t)' のような要素があれば、
     既読記事は、期限切れ消去の印が付いていなくてもすべて期限切れ消去処
     理を施されます。注意して使用してください。未読記事、印付き記事、保
     留記事は期限切れ消去されません。

     `gnus-total-expirable-newsgroups' も参照してください。

`expiry-wait'
     グループパラメーターに `(expiry-wait . 10)' のような要素があれば、
     この値は記事を期限切れ消去するときに `nnmail-expiry-wait' と
     `nnmail-expiry-wait-function' の設定 (*Note Expiring Mail::) より
     も優先されます。この値は期限切れ消去の日数 (整数である必要はない)
     かもしくは `never' か `immediate' のシンボルを指定できます。

`expiry-target'
     期限切れ消去されるメッセージの果てる場所。このパラメーターは
     `nnmail-expiry-target' よりも優先されます。

`score-file'
     `(score-file . "file")' のような要素は、`file' を現在のグループに
     適用されるスコアファイルにします。すべての適用されるスコア・エント
     リーはこのファイルに入ります。

`adapt-file'
     `(adapt-file . "file")' のような要素は、`file' を現在のグループの
     適応ファイルにします。すべての適応スコア・エントリーはこのファイル
     に入ります。

`admin-address'
     メーリングリストから脱会するときは、脱会通知メールをそのメーリング
     リスト自身に送信してはいけません。代わりに管理用アドレスにメッセー
     ジを送信します。このパラメーターにはどこか都合の良いな管理用アドレ
     スを書いておくことができます。

`display'
     `(display . MODE)' のような要素は、グループに入るときにどの記事を
     表示するかを指定します。有効な値は、

     `all'
          未読、既読記事の両方をすべて表示します。

     `an integer'
          そのグループの最後の INTEGER 個の記事を表示します。これは
          `C-u INTEGER' でそのグループに入るのと同じです。

     `default'
          ディフォルトの記事を表示します。これは通常は未読記事と可視記
          事です。

     `配列'
          述語を満足するように記事を表示します。

          いくつか例を挙げます:

          `[unread]'
               未読の記事だけを表示します。

          `[not expire]'
               期限切れ消去可能な記事以外のすべてを表示します。

          `[and (not reply) (not expire)]'
               期限切れ消去可能とすでに返信した記事以外のすべてを表示し
               ます。

          利用できる演算子は `not', `and' および `or' です。述語
          は `tick', `unsend', `undownload', `unread',
          `dormant', `expire', `reply', `killed',
          `bookmark', `score', `save', `cache', `forward',
          `unseen' および `recent' を含みます。

     `display' パラメーターは、概略バッファーを指定した一部の組だけに制
     限するように働きます。制限を外すのは `/ w' コマンドでできます
     (*Note Limiting::)。

`comment'
     `(comment . "This is a comment")' のような要素は、そのグループに対
     する任意のコメントです。グループ行に表示することができます (*Note
     Group Line Specification::)。

`charset'
     `(charset . iso-8859-1)' のような要素は、`iso-8859-1' をディフォル
     トの文字セットにします。すなわち、文字セットを指定しないすべての記
     事に、その文字セットが使われます。

     `gnus-group-charset-alist' も見てください。

`ignored-charsets'
     `(ignored-charsets x-unknown iso-8859-1)' のような要素は、
     `iso-8859-1' と `x-unknown' を無視します。すなわち、記事のデコード
     にディフォルトの文字セットが使われます。

     `gnus-group-ignored-charsets-alist' も見てください。

`posting-style'
     このグループの追加の投稿様式をここに保存することができます (*Note
     Posting Styles::)。書式は `gnus-posting-style' 連想リストと同じで
     すが、ここにはグループ名に合致する正規表現はありません (当然です)。
     このグループの様式の要素は `gnus-posting-styles' で見つかったもの
     よりも優先されます。

     例えば、このグループのみ、かっこいい名前と署名にしたいなら、
     `gnus-posting-styles' をいじらずに、このようなものをグループパラメー
     ターに入れることができます:

          (posting-style
            (name "Funky Name")
            ("X-My-Header" "Funky Value")
            (signature "Funky Signature"))

     グループバッファーを整理するためにトピック (*Note Group Topics::)
     を使っている場合は、トピックパラメーターでも投稿様式を設定すること
     ができます。トピックパラメーターにある投稿様式は、そのトピックのす
     べてのグループに適用されます。もっと正確に言うと、あるグループのた
     めの投稿様式の設定は、そのグループおよびそれが属するすべてのトピッ
     クのパラメーターにあるすべての投稿様式の設定を、階層的に合併するこ
     とによって生成されます。

`post-method'
     もしこれが設定されていると、メッセージを送信するための選択方法とし
     て `gnus-post-method' の代わりに使われます。

`mail-source'
     これが設定されていて、かつ `mail-sources' の設定が `group' グルー
     プ・メールソース (*Note Mail Sources::) を含んでいるならば、その値
     がこのグループのメールソースになります。

`banner'
     `(banner . REGEX)' のような項目は、記事のすべての場所で正規表現
     REGEX に合致するものを削除します。REGEX の代わりにシンボル
     `signature' (最後の署名を削除) や連想リスト
     `gnus-article-banner-alist' の各要素を使うこともできます。

`sieve'
     このパラメーターは、入ってきたメールがこのグループに置くに値するか
     どうかを調べる Sieve (ふるい) テストを持ちます。このグループパラメー
     ターを元に `fileinto "group.name";' というテスト条件を本体に持つ、
     Sieve の `IF' 制御構造体が作られます。

     例えば、もし `INBOX.list.sieve' グループが `(sieve address
     sender" "sieve-admin@extundo.com")' というグループパラメーターを持っ
     ていたならば、グループパラメーターを Sieve スクリプトに変換する
     (*Note Sieve Commands::) ときに、以下の Sieve コードが作られます:

          if address "sender" "sieve-admin@extundo.com" {
                  fileinto "INBOX.list.sieve";
          }

     複数の電子メールアドレスのためのテストを生成するには、`(sieve
     address "sender" ("name@one.org" else@two.org"))' のようなグループ
     パラメーターを使ってください。Sieve スクリプト (*Note Sieve
     Commands::) を生成すると、以下のような Sieve コードが作られます:

          if address "sender" ["name@one.org", "else@two.org"] {
                  fileinto "INBOX.list.sieve";
          }

     Sieve パラメーターに関連する重要なコマンドと変数については、*Note
     Sieve Commands:: を参照してください。

     Sieve 言語は RFC 3028 で述べられています (*Note Emacs Sieve:
     (sieve-ja)Top.)。

`(agent parameters)'
     エージェントを使うようにしてあると、個々のグループでエージェントの
     振る舞いを制御するどのパラメーターも設定することができます。エージェ
     ントパラメーターについては *Note Category Syntax:: を参照してくだ
     さい。たいていの利用者は、設定に要する苦労を最小限にするために、エー
     ジェントカテゴリーかグループトピックのどちらかでエージェントパラメー
     ターを設定することを選ぶでしょう。

`(VARIABLE FORM)'
     グループに入るときに、そのグループローカルの変数を設定するグループ
     パラメーターを使用することができます。`news.answers' においてスレッ
     ド表示を行ないたくないときは、そのグループにグループパラメーターに
     `(gnus-show-threads nil)' と書けます。`gnus-show-threads' は、その
     概略バッファーの中のローカル変数になり、form の `nil' はそこで
     `eval' (評価) されます。

     この機能は VARIABLE が変数として存在する場合に限って、それを概略バッ
     ファーでローカルに設定することに注意してください。さもなければ
     form の評価だけが行なわれるでしょう。したがって、もし form を評価
     した結果を変数に設定する必要があるのならば、`defvar' などを使って、
     前もってその変数を定義しておかなければなりません。

     でも、いくつかの変数は記事バッファーか (返信、フォロー、あるいは新
     規に作られたメッセージの) メッセージバッファーで評価されます。代わ
     りに、問題の変数を `gnus-newsgroup-variables' に加えることが助けに
     なるかもしれません。したがって、グループパラメーターを介して
     `message-from-style' を設定したいならば、`~/.gnus.el' ファイルのど
     こか他のところに、次の述語が必要になるかもしれません:

          (add-to-list 'gnus-newsgroup-variables 'message-from-style)

     この機能の用途の一つは、記事の表題欄からメーリングリストの標識タグ
     をはぎ取ることです。もしニュースグループ

          nntp+news.gnus.org:gmane.text.docbook.apps

     が、すべての記事の表題に `DOC-BOOK-APPS:' というタグを持っているな
     らば、そのグループのグループパラメーターに
     `(gnus-list-identifiers "DOCBOOK-APPS:")' を入れることによって、そ
     のグループの概略バッファーに表示される記事の表題からタグをはぎ取る
     ことができます。

     これはもし必要であれば、グループ毎のフック関数としても使用できます。
     もしあるグループに入ったときにビープ音を鳴らしたければ、そのグルー
     プのパラメーターに `(dummy-variable (ding))' みたいなものを書いて
     おくこともできます。もし `dummy-variable' という変数が存在していれ
     ば (上記参照)、それに (無意味な) `(ding)' の評価結果が設定されます。

     あるいは、VARIABLE はそのグループに対してローカルになるので、この
     様式は一時的にフックを変更するために使うことができます。例えば、以
     下のものがグループパラメーターに追加されると、

          (gnus-summary-prepared-hook
            '(lambda nil (local-set-key "d" (local-key-binding "n"))))

     そのグループに入ったときに `d' キーは記事に期限切れ消去の印を付け
     ないようになります。

グループパラメーターは `gnus-parameters' 変数を介在して設定することもで
きます。でもいくつかのパラメーター、例えば `visible' は効力を発揮しませ
ん (その場合、代替として `gnus-permanently-visible-groups' を使うことが
できます)。例です:

     (setq gnus-parameters
           '(("mail\\..*"
              (gnus-show-threads nil)
              (gnus-use-scoring nil)
              (gnus-summary-line-format
               "%U%R%z%I%(%[%d:%ub%-23,23f%]%) %s\n")
              (gcc-self . t)
              (display . all))

             ("^nnimap:\\(foo.bar\\)$"
              (to-group . "\\1"))

             ("mail\\.me"
              (gnus-use-scoring  t))

             ("list\\..*"
              (total-expire . t)
              (broken-reply-to . t))))

文字列の値は、`to-group' の例が示すように、正規表現による置き換えを受け
ることがあります。

グループ名と `gnus-parameters' で指定されたこれらの正規表現の一つを比較
するときに大文字と小文字を区別するかどうかは、ディフォルトではその比較
を行なう時点での `case-fold-search' の値に依存します。一般的に
`case-fold-search' の値は `t' で、それは例えば `("INBOX\\.FOO"
(total-expire . t))' という要素が、`INBOX.FOO' グループと `INBOX.foo'
グループの両方に適用されることを意味します。これらの正規表現が常に大文
字と小文字を区別するようにしたい場合は、
`gnus-parameters-case-fold-search' 変数の値を `nil' に設定してください。
あるいは、それらが常に大文字と小文字を区別しないようにしたいなら、それ
を `t' に設定してください。

`gnus-parameters' を介することによって、グループによって異なる並べ替え
を定義することができます。これは、NNTP グループでは最新のニュースが先頭
になるように日付で、RSS グループでは表題で、それぞれ並べ替えを行なう例
です。この例の最初のグループは、news.gmane.org から取得する Debian のデ
イリーニュースです。RSS グループは RSS フィードで配信されている Debian
のウィークリーニュース
`http://packages.debian.org/unstable/newpkg_main.en.rdf' に対応します。
*Note RSS::.

     (setq
      gnus-parameters
      '(("nntp.*gmane\\.debian\\.user\\.news"
         (gnus-show-threads nil)
         (gnus-article-sort-functions '((not gnus-article-sort-by-date)))
         (gnus-use-adaptive-scoring nil)
         (gnus-use-scoring nil))
        ("nnrss.*debian"
         (gnus-show-threads nil)
         (gnus-article-sort-functions 'gnus-article-sort-by-subject)
         (gnus-use-adaptive-scoring nil)
         (gnus-use-scoring t)
         (gnus-score-find-score-files-function 'gnus-score-find-single)
         (gnus-summary-line-format "%U%R%z%d %I%(%[ %s %]%)\n"))))



File: gnus-ja.info, Node: Listing Groups, Next: Sorting Groups, Prev: Group Parameters, Up: Group Buffer

グループの一覧表示
==================

これらのコマンドは、利用できるグループをいろいろに切り分けて表示します。

`l'
`A s'
     未読記事を持つすべてのグループを表示します
     (`gnus-group-list-groups')。数値接頭引数を使うと、このコマンドは引
     数の数かそれよりも小さいレベルのグループのみを表示します。ディフォ
     ルトでは、これはレベル 5 (つまり `gnus-group-default-list-level')
     かそれより小さいレベル (すなわち購読しているグループのみ) を表示し
     ます。

`L'
`A u'
     未読記事のあるなしに関わらず、すべてのグループを表示します
     (`gnus-group-list-all-groups')。数値接頭引数を使用すると、このコマ
     ンドは引数の数かそれよりも小さいレベルのグループのみを表示します。
     ディフォルトでは 7 かそれよりも小さいレベルのグループ (すなわち購
     読、非購読のグループのみ) が表示されます。

`A l'
     未読記事があるグループのうち、指定したレベルのものだけを表示します
     (`gnus-group-list-level')。接頭引数を与えると、未読記事の無いグルー
     プも含めて表示します。

`A k'
     kill されたグループをすべて表示します (`gnus-group-list-killed')。
     接頭引数を与えると、購読または非購読のどちらにもなっていないすべて
     の利用可能なグループを表示します。これはサーバーからアクティブファ
     イルを読むことになるでしょう。

`A z'
     すべてのゾンビグループを表示します (`gnus-group-list-zombies')。

`A m'
     正規表現に合致する名前を持つグループで、未読記事のある購読グループ
     をすべて表示します (`gnus-group-list-matching')。

`A M'
     正規表現に合致するグループを表示します
     (`gnus-group-list-all-matching')。

`A A'
     今接続しているサーバーのアクティブファイルにあるグループを、本当に
     全部表示します (`gnus-group-list-active')。これはしばらく時間がか
     かることも有り得ます。たぶん `A M' を実行して、合致させたい部分を
     `.' としてすべての合致するリストを表示させた方が良いでしょう。また、
     このコマンドは (まだ) 存在しないグループも表示するかもしれませ
     ん--これは kill されたグループであるかのように表示されます。出力は
     多少割り引いて受け取ってね。

`A a'
     正規表現に合致する名前を持つグループをすべて表示します
     (`gnus-group-apropos')。

`A d'
     正規表現に合致する名前か説明文を持つグループをすべて表示します
     (`gnus-group-description-apropos')。

`A c'
     キャッシュ記事を持つグループをすべて表示します
     (`gnus-group-list-cached')。

`A ?'
     保留記事を持つグループをすべて表示します
     (`gnus-group-list-dormant')。

`A /'
     現在の選択された範囲に限定したグループを表示します
     (`gnus-group-list-limit')。

`A f'
     現在の選択されたグループを書き出します (`gnus-group-list-flush')。

`A p'
     現在の選択されたグループを加えたグループを表示します
     (`gnus-group-list-plus')。

`gnus-permanently-visible-groups' 正規表現に合致するグループは、未読記
事があるかないかに関わらず常に表示されます。あるいはグループパラメーター
において `visible' 要素を追加することでも同様の効果を得ることができます。

印付きの記事のみを持つグループは通常グループバッファーに表示されます。
もし `gnus-list-groups-with-ticked-articles' が `nil' であれば、そのグ
ループは完全に空のグループであるかのように扱われます。ディフォルトは
`t' です。



File: gnus-ja.info, Node: Sorting Groups, Next: Group Maintenance, Prev: Listing Groups, Up: Group Buffer

グループの並べ替え
==================

`C-c C-s' (`gnus-group-sort-groups') 命令は、グループバッファーを
`gnus-group-sort-function' 変数で与えられる関数に従って並べ替えます。利
用可能な並べ替え関数 (sorting function) には以下のものがあります:

`gnus-group-sort-by-alphabet'
     グループ名でアルファベット順に並べ替えます。これがディフォルトです。

`gnus-group-sort-by-real-name'
     グループを本当の (前に何も付いていない) グループ名でアルファベット
     順に並べ変えます。

`gnus-group-sort-by-level'
     グループレベルで並べ替えます。

`gnus-group-sort-by-score'
     グループのスコアで並べ替えます。*Note Group Score::.

`gnus-group-sort-by-rank'
     グループのスコアで並べ替え、次にグループレベルで並べ替えます。レベ
     ルとスコアは、ひとまとめにして「ランク」と呼ばれます。*Note Group
     Score::.

`gnus-group-sort-by-unread'
     未読記事の数で並べ替えます。

`gnus-group-sort-by-method'
     選択方法のアルファベット順で並べ替えます。

`gnus-group-sort-by-server'
     サーバー名のアルファベット順で並べ替えます。

`gnus-group-sort-function' は並べ替え関数のリストであっても構いません。
この場合、もっとも重要な並べ替えの鍵を持つ関数は最後でなくてはなりませ
ん。

ある種の並べ替え用には、直接並べ替える命令もいくつかあります。

`G S a'
     グループバッファーをグループ名のアルファベット順で並べ替えます
     (`gnus-group-sort-groups-by-alphabet')。

`G S u'
     グループバッファーを未読記事の数で並べ替えます
     (`gnus-group-sort-groups-by-unread')。

`G S l'
     グループバッファーをグループレベルで並べ替えます
     (`gnus-group-sort-groups-by-level')。

`G S v'
     グループバッファーをグループのスコアで並べ替えます
     (`gnus-group-sort-groups-by-score')。*Note Group Score::.

`G S r'
     グループバッファーをグループのランクで並べ替えます
     (`gnus-group-sort-groups-by-rank')。*Note Group Score::.

`G S m'
     グループバッファーをバックエンドの名前でアルファベット順に並べ替え
     ます (`gnus-group-sort-groups-by-method')。

`G S n'
     グループバッファーを本当の (前に何も付いていない) グループ名でアル
     ファベット順に並べ替えます
     (`gnus-group-sort-groups-by-real-name')。

以下のすべての命令はプロセス/接頭引数の習慣に従います (*Note
Process/Prefix::)。

シンボル接頭引数 (*Note Symbolic Prefixes::) が与えられたときは、これら
すべての命令は逆順で並び換えます。

また、グループの一部を並べ替えることもできます。

`G P a'
     グループをグループ名のアルファベット順で並べ替えます
     (`gnus-group-sort-selected-groups-by-alphabet')。

`G P u'
     グループを未読記事の数で並べ替えます
     (`gnus-group-sort-selected-groups-by-unread')。

`G P l'
     グループをグループレベルで並べ替えます
     (`gnus-group-sort-selected-groups-by-level')。

`G P v'
     グループをグループのスコアで並べ替えま
     す (`gnus-group-sort-selected-groups-by-score')。
     *Note Group Score::.

`G P r'
     グループをグループのランクで並べ替えます
     (`gnus-group-sort-selected-groups-by-rank')。*Note Group Score::.

`G P m'
     グループをバックエンドの名前でアルファベット順に並べ替えます
     (`gnus-group-sort-selected-groups-by-method')。

`G P n'
     グループを本当の (前に何も付いていない) グループ名でアルファベット
     順に並べ替えます (`gnus-group-sort-selected-groups-by-real-name')。

`G P s'
     グループを `gnus-group-sort-function' に従って並べ替えます。

最後に、`C-k' と `C-y' を使って、手動でグループをあちこちに移動できるこ
ともお忘れなく。



File: gnus-ja.info, Node: Group Maintenance, Next: Browse Foreign Server, Prev: Sorting Groups, Up: Group Buffer

グループの管理
==============

`b'
     不正なグループを見つけて、削除します
     (`gnus-group-check-bogus-groups')。

`F'
     新しいグループを見つけて、それらを処理します
     (`gnus-group-find-new-groups')。一回の `C-u' の後で押されると、サー
     バーに新しいグループを尋ねるために `ask-server' の方法を使います。
     二回の `C-u' の後で押されると、サーバーに新しいグループを尋ねるた
     めに最も完全であると思われる方法を用い、新しいグループをゾンビとし
     て購読します。

`C-c C-x'
     現在のグループの期限切れ消去可能な記事に対して (もしあれば) すべて
     期限切れ消去の処理を行ないます (`gnus-group-expire-articles')。こ
     れは、そのグループにしばらく存在していた期限切れ消去可能なすべての
     記事を消去するということです。(*Note Expiring Mail::)。

`C-c C-M-x'
     すべてのグループのすべての期限切れ消去可能な記事に対して、期限切れ
     消去の処理を行ないます。(`gnus-group-expire-all-groups')。



File: gnus-ja.info, Node: Browse Foreign Server, Next: Exiting Gnus, Prev: Group Maintenance, Up: Group Buffer

外部サーバーの閲覧
==================

`B'
     選択方法とサーバー名を聞かれます。Gnus はこのサーバーに接続し、そ
     こにあるグループを閲覧しようとします
     (`gnus-group-browse-foreign-server')。

利用可能なグループのリストを持った新しいバッファーが現れます。このバッ
ファーは `gnus-browse-mode' を使用します。このバッファーは通常のグルー
プバッファーにちょっと (というか、とっても) 似ています。

以下が閲覧モード (browse mode) で使用できるキー操作のリストです:

`n'
     次のグループに移動します (`gnus-group-next-group')。

`p'
     一つ前のグループに移動します (`gnus-group-prev-group')。

`SPACE'
     現在のグループに入り、最初の記事を表示します
     (`gnus-browse-read-group')。

`RET'
     現在のグループに入ります (`gnus-browse-select-group')。

`u'
     現在のグループを非購読にします。と言うよりは (訳注: このコマンドは
     トグルなので)、この場合は購読することになるのでしょうけれど
     (`gnus-browse-unsubscribe-current-group')。

`l'
`q'
     閲覧モード (browse mode) を終了します (`gnus-browse-exit')。

`d'
     現在のグループを購読にします (`gnus-browse-describe-group')。

`?'
     閲覧モード (browse mode) を簡単に説明します (まあ、大して説明する
     こともないんですけれどね) (`gnus-browse-describe-briefly')。



File: gnus-ja.info, Node: Exiting Gnus, Next: Group Topics, Prev: Browse Foreign Server, Up: Group Buffer

Gnus の終了
===========

そう、Gnus は最後 (サイコー) です (訳注: く、苦しい。原文は“Yes, Gnus
is ex(c)iting.”)。

`z'
     Gnus を中断します (`gnus-group-suspend')。これは Gnus を実際には終
     了させず、グループバッファー以外のすべてのバッファーを消すだけです。
     僕はこれのうれしさがよくわかんないんだけど、誰か分かる人います?

`q'
     Gnus を終了します (`gnus-group-exit')。

`Q'
     `.newsrc' ファイルを保存せずに Gnus を終了します
     (`gnus-group-quit')。ドリブルファイルは保存されますけれど (*Note
     Auto Save::)。

Gnus を中断するときは `gnus-suspend-gnus-hook' が呼び出されます。Gnus
を終了するときは `gnus-exit-gnus-hook' が呼び出され、さらに Gnus を終了
するときの最後として `gnus-after-exiting-gnus-hook' が呼び出されます。

Note:

     ミス Lisa Cannifax は英語の授業中、後ろに座っている少年が彼女のプ
     ラスティックの椅子の背越しに、鉛筆で繰り返し線を描くのにつられて、
     足がしびれて重くなり、意識が朦朧としてきました。



File: gnus-ja.info, Node: Group Topics, Next: Non-ASCII Group Names, Prev: Exiting Gnus, Up: Group Buffer

Group Topics
============

もしあなたがたーくさんのグループを読んでいるのであれば、グループをトピッ
ク毎に階層分けできると便利でしょう。Emacs のグループをこっちへ、セック
スのグループをあっちへ、で、残りを (え? グループが二つくらいしかないの?)
邪魔にならないようにその他のセクションに入れましょう。あるいは Emacs セッ
クスのグループを Emacs グループ、セックスグループのどちらかの副トピック
とすることさえもできます--あるいは両方に! すんごいでしょう!

これが例です:

     Gnus
       Emacs -- こいつはすげーぜ!
          3: comp.emacs
          2: alt.religion.emacs
         えっちな Emacs
          452: alt.sex.emacs
            0: comp.talk.emacs.recovery
       その他
          8: comp.binaries.fractals
         13: comp.sources.unix

この *素晴らしい* 機能を使うには、`gnus-topic' マイナーモードを (何と!)
単にスイッチオンするだけ--グループバッファーで、`t' を押してください
(これはトグルコマンドです)。

さあやってみよう。とにかく試してみて。君が戻ってくるまで、僕はここで待っ
てるからさ。ララ、タララン...、いい曲だね、これ...ラ、ラ、ラ...え? 戻っ
てきた? よし、じゃ次は `l' を押してみて。ほら。これですべてのグループが
`misc' の下に表示されました。興奮してクラクラしてこない? アツくって、い
まいましいくらいでしょ?

これをずっと有効にしたければ、グループモードのフックにこのマイナーモー
ドを追加してください。以下の行を `~/.gnus.el' ファイルに入れて、ね。

     (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

* Menu:

* Topic Commands::              超簡単対話型命令
* Topic Variables::             Lisp でトピックをカスタマイズする方法
* Topic Sorting::               トピック毎別々に並べ替える
* Topic Topology::              全世界の地図
* Topic Parameters::            あるトピックのすべてのグループに適用されるパラメーター



File: gnus-ja.info, Node: Topic Commands, Next: Topic Variables, Prev: Group Topics, Up: Group Topics

トピック命令
------------

トピックマイナーモードが有効であるときは、`T' サブマップが新しく利用で
きるようになります。さらに標準キーの中でも、定義がちょっと変わるものが
少しあります。

だいたいにおいて、次のようなトピックの操作が可能です。まず第一に、あな
たはトピックを作ることを望むでしょう。第二に、あなたはグループをトピッ
クに入れて、それらをあなたの好みの順序になるまで、あちこちに移動するこ
とを望むでしょう。第三に行なう操作は、それらの一切合切を表示したり隠す
ことでしょう。他のグループの概要を見やすくするために、あなたは副トピッ
クやグループによっては、トピックが隠れるようにする必要があるかもしれま
せんね。

ここには、あなたの好むやり方でトピックを設定するために必要になりそうな、
基本的なキーのリストがあります。

`T n'
     新しいトピック名の入力を促し、それを作成します
     (`gnus-topic-create-topic')。

`T TAB'
`TAB'
     現在のトピックの「字下げ」を行ない、その前のトピックの副トピックに
     します (`gnus-topic-indent')。接頭引数を与えると、反対にそのトピッ
     クの字下げを回復 (un-indent) します。

`M-TAB'
     現在のトピックの「字下げ回復」(un-indent) を行ない、それが現在の親
     の親の副トピックになるようにします (`gnus-topic-unindent')。

以下の二つのキーは、グループとトピックをあちこち移動するために使われま
す。それらは、よく知られているカット＆ペーストのように動作します。
`C-k' はカット、`C-y' はペーストです。もちろん、Emacs ではカット＆ペー
ストではなくて kill & yank という用語を使いますが。

`C-k'
     グループあるいはトピックを kill します (`gnus-topic-kill-group')。
     トピック内にあったグループもすべて、トピックと一緒に削除されます。

`C-y'
     直前の kill されたグループあるいはトピックを yank します
     (`gnus-topic-yank-group')。すべてのトピックは、すべてのグループの
     前に yank されることに気を付けてください。

     ですから、あるトピックをトピックのリストの先頭に移動するには、単に
     そこで `C-k' を叩きます。これはカット＆ペーストのカットに相当しま
     す。そうしたらカーソルをバッファーの先頭 (“Gnus”トピックの真下)
     に移動して、`C-y' を叩いてください。これはカット＆ペーストのペース
     トに相当します。なあんだ、簡単じゃん。

     `C-k' と `C-y' はトピックと同様にグループにも使えます。すなわち、
     あなたはグループと同じようにトピックの移動もできるのです。

あなたの望みのままにトピックを使えるようにした後で、あなたはトピックを
隠したり再び見えるようにしようと思うでしょう。そのために以下のキーを用
意しています。

`RET'
`SPACE'
     グループを選択するか、あるいはトピックを折りたたみます
     (`gnus-topic-select-group')。グループの上でこのコマンドを実行する
     と、通常通りそのグループに入ります。トピック行の上で行なうと、その
     トピックは (すでに表示されているときは) 折りたたまれるか、(すでに
     折りたたまれているときは) 展開されます。つまりトピックに対してはこ
     れはトグルコマンドです。さらに、数値の接頭引数を与えると、そのレベ
     ル (とそれよりも小さいレベル) のグループが表示されます。

さてお次は、他のコマンドのリストです。順序には特に意味はありません。

`T m'
     現在のグループを、どこか他のトピックに移動させます
     (`gnus-topic-move-group')。このコマンドはプロセス印/接頭引数の習慣
     に従います (*Note Process/Prefix::)。

`T j'
     トピックにジャンプします (`gnus-topic-jump-to-topic')。

`T c'
     現在のグループを、どこか他のトピックにコピーします
     (`gnus-topic-copy-group')。このコマンドはプロセス印/接頭引数の習慣
     に従います (*Note Process/Prefix::)。

`T h'
     現在のトピックを隠します。接頭引数が与えらると、そのトピックを永久
     に隠します。

`T s'
     現在のトピックを表示します。接頭引数が与えられると、そのトピックを
     永久に表示します。

`T D'
     グループを現在のトピックから削除します
     (`gnus-topic-remove-group')。この命令は主にいくつかのトピックに同
     じグループがあって、それをトピックの一つから取り除きたいときに役立
     ちます。あなたはグループをすべてのトピックから取り除くかもしれませ
     んが、その場合は、Gnus はあなたが次回に Gnus を起動したときにそれ
     をルートトピックに付け加えます。実際のところ、すべての新しいグルー
     プ (もちろん、それはどのトピックにも属していません) はルートトピッ
     クに現われます。

     この命令はプロセス印/接頭引数の習慣に従います (*Note
     Process/Prefix::)。

`T M'
     正規表現に合致するすべてのグループを、あるトピックに移動させます
     (`gnus-topic-move-matching')。

`T C'
     正規表現に合致するすべてのグループを、あるトピックにコピーします
     (`gnus-topic-copy-matching')。

`T H'
     空のトピックの表示・非表示を切り替えます
     (`gnus-topic-toggle-display-empty-topics')。

`T #'
     現在のトピックにあるグループすべてにプロセス印を付けます
     (`gnus-topic-mark-topic')。接頭引数が与えられない場合、このコマン
     ドは副トピックに対して再帰的に働きます。

`T M-#'
     現在のトピックにあるすべてのグループからプロセス印を消します
     (`gnus-topic-unmark-topic')。接頭引数が与えられない場合、このコマ
     ンドは副トピックに対して再帰的に働きます。

`C-c C-x'
     (もしあれば) 現在のグループかトピックかのすべての期限切れ消去可能
     記事を期限切れ消去します (`gnus-topic-expire-articles')。(*Note
     Expiring Mail::)。

`T r'
     トピックの名前を変更します (`gnus-topic-rename')。

`T DEL'
     空のトピックを削除します (`gnus-topic-delete')。

`A T'
     Gnus が知っているトピック化されたグループをすべて表示します
     (`gnus-topic-list-active')。

`T M-n'
     次のトピックに移動します (`gnus-topic-goto-next-topic')。

`T M-p'
     前のトピックに移動します (`gnus-topic-goto-previous-topic')。

`G p'
     トピックパラメーターを修正します (`gnus-topic-edit-parameters')。
     *Note Topic Parameters::.



File: gnus-ja.info, Node: Topic Variables, Next: Topic Sorting, Prev: Topic Commands, Up: Group Topics

トピック変数
------------

前の章では、どのトピックを表示するかを Gnus に言う方法を説明しました。
この章では、それぞれのトピックの何を表示するかを Gnus に言う方法を説明
します。

トピック行それ自体は、`gnus-topic-line-format' 変数の値に従って作成され
ます (*Note Formatting Variables::)。有効な要素は、

`i'
     字下げ。
`n'
     トピック名。
`v'
     見えるかどうか。
`l'
     レベル。
`g'
     トピック中のグループの数。
`a'
     トピック中の未読記事の数。
`A'
     トピックとすべての副トピックの未読記事の数。

各副トピック (と副トピック内のグループ) は、トピックレベル数の
`gnus-topic-indent-level' 倍の空白分の字下げが行なわれます。ディフォル
トは 2 です。

`gnus-topic-mode-hook' はトピックマイナーモードバッファーで呼び出されま
す。

`gnus-topic-display-empty-topics' はトピックの中に未読記事が無い場合で
もそのトピックを表示するようにします。ディフォルトは `t' です。



File: gnus-ja.info, Node: Topic Sorting, Next: Topic Topology, Prev: Topic Variables, Up: Group Topics

トピックの並べ替え
------------------

以下に示す命令で、各トピック毎に別々にグループを並べ替えることができま
す:

`T S a'
     現在のトピックをグループ名のアルファベット順に並べ替えます
     (`gnus-topic-sort-groups-by-alphabet')。

`T S u'
     現在のトピックを未読記事の数で並べ替えます
     (`gnus-topic-sort-groups-by-unread')。

`T S l'
     現在のトピックをグループのレベルで並べ替えます
     (`gnus-topic-sort-groups-by-level')。

`T S v'
     現在のトピックをグループのスコアで並べ替えます
     (`gnus-topic-sort-groups-by-score')。*Note Group Score::.

`T S r'
     現在のトピックをグループのランクで並べ替えます
     (`gnus-topic-sort-groups-by-rank')。*Note Group Score::.

`T S m'
     現在のトピックをバックエンドの名前でアルファベット順に並べ替えます
     (`gnus-topic-sort-groups-by-method')。

`T S e'
     現在のトピックをサーバーの名前でアルファベット順に並べ替えます
     (`gnus-topic-sort-groups-by-server')。

`T S s'
     現在のトピックを、変数 `gnus-group-sort-function' で与えられる関数
     に従って並べ替えます (`gnus-topic-sort-groups')。

接頭引数が与えられると、これらすべてのコマンドは逆順の並べ替えを行ない
ます。グループの並べ替えについてのさらなる情報は *Note Sorting
Groups:: を参照してください。



File: gnus-ja.info, Node: Topic Topology, Next: Topic Parameters, Prev: Topic Sorting, Up: Group Topics

トピックの位相構造
------------------

それでは、グループバッファーの例を見ていきましょう。

     Gnus
       Emacs -- こいつはすげーぜ!
          3: comp.emacs
          2: alt.religion.emacs
         えっちな Emacs
          452: alt.sex.emacs
            0: comp.talk.emacs.recovery
       その他
          8: comp.binaries.fractals
         13: comp.sources.unix

つまり、ここでは一つのトップレベルのトピック (`Gnus') があり、その下に
二つのトピックがあり、そのうちの一方の副トピック中に一つ副トピックがあ
ります (トップレベルトピックは常に一つしかありません)。この構造は、以下
のように表現できます:

     (("Gnus" visible)
      (("Emacs -- こいつはすげーぜ!" visible)
       (("えっちな Emacs" visible)))
      (("その他" visible)))

これは実に、上記の表示を行なうための、変数 `gnus-topic-topology' の値そ
のものなのです。この変数は `.newsrc.eld' ファイルに保存され、手でいじく
り回してはいけません--本当にやりたいときは別ですが。この変数は
`.newsrc.eld' ファイルから読み込まれるので、その他のスタートアップファ
イルの設定にはまったく影響を与えません。

この構造は、どのトピックがどのトピックの副トピックであるかと、どのトピッ
クが表示されているかを示しています。現在は二つの設定値---`visible' と
`invisible' を使うことができます。



File: gnus-ja.info, Node: Topic Parameters, Prev: Topic Topology, Up: Group Topics

トピックパラメーター
--------------------

トピック内のすべてのグループはグループパラメーターを、その親 (と先祖)
のトピックパラメーターから継承します。グループパラメーターとして正しい
ものはすべて、トピックパラメーターとしても正しいものです (*Note Group
Parameters::)。エージェントを使うようにしてあると、すべてのエージェント
パラメーター (*Note Category Syntax:: の Agent Parameters を参照 (訳注:
必要なら Index を使って)) は有効なトピックパラメーターでもあります。

さらに、以下のパラメーターはトピックパラメーターとしてのみ有効です:

`subscribe'
     トピックで新しいグループを購読している場合 (*Note Subscription
     Methods::)、`subscribe' トピックパラメーターはどのグループがどのト
     ピックに行くかを指定します。値はそのトピックに行くグループに合致す
     る正規表現である必要があります。

`subscribe-level'
     トピックで新しいグループを購読している場合 (`subscribe' パラメーター
     を参照)、そのグループの購読度のレベルは
     `gnus-level-default-subscribed' の代わりに `subscribe-level' トピッ
     クパラメーターの値になります。

グループパラメーターは (もちろん) トピックパラメーターよりも優先され、
副トピックのトピックパラメーターは親トピックのトピックパラメーターより
も優先されます。分かるよね。ごく普通の継承ルールです (ルール ("Rules")
はここでは名詞であって、動詞の「線を引く」ではありません。このルールに
は反対したくなるかもしれないけど、それはご自由に)。

     Gnus
       Emacs
          3: comp.emacs
          2: alt.religion.emacs
        452: alt.sex.emacs
         息抜き
          452: alt.sex.emacs
            0: comp.talk.emacs.recovery
       その他
          8: comp.binaries.fractals
         13: comp.sources.unix
        452: alt.sex.emacs

`Emacs' トピックはトピックパラメーター `(score-file . "emacs.SCORE")'
を持っています。`息抜き' トピックはトピックパラメーター
`(score-file . "relief.SCORE")' を持ち、`その他' トピックはトピックパラ
メーター `(score-file . "emacs.SCORE")' を持っています。さらに、
`alt.religion.emacs' はグループパラメーター
`(score-file . "religion.SCORE")' を持っています。

さて、ここで `息抜き' トピックの `alt.sex.emacs' グループに入ったとき、
`relief.SCORE' が基本スコアファイルとなります。もし `Emacs' トピックの
同じグループに入ると、`emacs.SCORE' が基本スコアファイルになるでしょう。
`alt.religion.emacs' グループに入れば、`religion.SCORE' が基本スコアファ
イルになるでしょう。

これってとっても簡単で自明のことのように見えるでしょ? まあ、その通りで
す。ですが問題がある場合もあります。特に `total-expiry' パラメーターに
関してです。例えばあるメールグループを二つのトピックの中に、一方は
`total-expiry' ありで、もう一方はそれなしで持っているとしましょう。ここ
で `M-x gnus-expire-all-expirable-groups' を実行すると、何が起こるでしょ
うか? Gnus は、あなたがどちらのトピックから記事を期限切れ消去したいのか
を知る方法がないため、最悪の事態が発生するかもしれません。実際、私はこ
のとき何が起こるのかは「未定義 "undefined"」である、とここに宣言します。
この手のことをやりたい場合には十分注意しなければなりません。



File: gnus-ja.info, Node: Non-ASCII Group Names, Next: Searching, Prev: Group Topics, Up: Group Buffer

英字以外の名前のグループへのアクセス
====================================

世界には、それぞれの母国語で表した名前のグループを提供するニュースサー
バーがあります。例えば、あるニュースサーバーには名前が中国語で綴られた
ニュースグループがあって、そこで人々は中国語で話をしています。もちろん
Gnus でそのようなニュースグループを講読することは可能です。Gnus は現在
`nntp' バックエンドだけでなく `nnml' バックエンドと `nnrss' バックエン
ドで非-ASCII グループ名をサポートしています。

すべてのそのようなグループ名は、サーバー側で、ある文字セットでエンコー
ドされています (NNTP サーバーでは管理者が文字セットを決めますが、他のバッ
クエンドのグループではあなたがそれを決めます)。Gnus はあなたのためにグ
ループバッファーと記事バッファーでデコードされたものを表示しなければな
りませんし、サーバーと通信するときはエンコードされたものを使う必要があ
ります。しかし Gnus は、各々の非-ASCII グループ名にどんな文字セットが使
われているかを知りません。以下の二つの変数は、まさに各グループでどんな
文字セットを使うべきかを Gnus に伝えるためのものです:

`gnus-group-name-charset-method-alist'
     選択方法と文字セットの連想リストです。ディフォルト値は `nil' です。
     その選択方法で指定されるサーバーにあるグループの名前は、すべてその
     対応する文字セットを使うものと仮定されます。例です:

          (setq gnus-group-name-charset-method-alist
                '(((nntp "news.com.cn") . cn-gb-2312)))

     この変数でグループに指定された文字セットは、同じグループに
     `gnus-group-name-charset-group-alist' 変数で指定されたものより優先
     されます (下記参照)。

     選択方法は非常に長くなる場合がありますね。このように:

          (nntp "gmane"
                (nntp-address "news.gmane.org")
                (nntp-end-of-line "\n")
                (nntp-open-connection-function
                 nntp-open-via-rlogin-and-telnet)
                (nntp-via-rlogin-command "ssh")
                (nntp-via-rlogin-command-switches
                 ("-C" "-t" "-e" "none"))
                (nntp-via-address ...))

     そのような場合、この変数の中では `(nntp "gmane")' に切り詰めること
     ができます。つまり、バックエンド名とサーバー名だけを含んでいれば十
     分です。

`gnus-group-name-charset-group-alist'
     グループ名の正規表現と、それに合致するグループのための文字セットの
     連想リストです。UTF-8 がサポートされている場合は `((".*" utf-8))'
     がディフォルト値で、それ以外の場合のディフォルトは `nil' です。例
     です:

          (setq gnus-group-name-charset-group-alist
                '(("\\.com\\.cn:" . cn-gb-2312)
                  (".*" . utf-8)))

          `gnus-group-name-charset-method-alist' で合致した場合、この変数は無
          視されることに注意してください。

これら二つの変数は `nntp' 以外のバックエンドにある非-ASCII 名のグループ
をエンコードおよびデコードする文字セットを決定するためにも使われます。
つまり、それを決めるのはあなたです。何もしなければそれらのバックエンド
のグループ名で使われる文字セットは、
`gnus-group-name-charset-group-alist' の最後の素子のせいですべて
`utf-8' になるでしょう。

さて、非-ASCII グループ名のための重要な変数がもう一つあります:

`nnmail-pathname-coding-system'
     この変数の値は coding system もしくは `nil' でなければなりません。
     ディフォルトは Emacs では `nil'、または XEmacs では `file-name' と
     いう coding system の aliasee (`file-name' を別名に持つ、ある
     coding system) です。

     `nnml' バックエンド、`nnrss' バックエンド、NNTP 印 (*Note NNTP
     marks::)、エージェント、およびキャッシュは、それらのファイルとディ
     レクトリーで非-ASCII グループ名を使います。この変数は、それらのファ
     イル名とディレクトリー名をエンコードおよびデコードするときに用いら
     れる coding system を指定する `file-name-coding-system' の値を上書
     きします。

     XEmacs (`mule' 機能付き) では、`file-name-coding-system' はファ
     イル名をエンコードおよびデコードするのに用いられる coding system を指定
     する唯一の手段です。一方 Emacs は `file-name-coding-system' の値
     が `nil' だった場合、または `nil' であ
     る `nnmail-pathname-coding-system' の値にそれが束縛される場合、
     `default-file-name-coding-system' の値を使用します。

     通常 Emacs における `default-file-name-coding-system' または
     XEmacs における `nnmail-pathname-coding-system' の値は言語環境に従っ
     て初期化されるので、その値が非-ASCII グループ名をエンコードおよび
     デコードするために適切であれば、何もする必要は無いでしょう。

     この変数 (または `default-file-name-coding-system') の値は、必ずし
     も `gnus-group-name-charset-method-alist' および
     `gnus-group-name-charset-group-alist' によって決定される値と同じで
     ある必要はありません。

     例えば中国語で綴られたニュースグループを講読したいのに、
     `default-file-name-coding-system' またはこの変数がディフォルトで
     `iso-latin-1' に初期化されてしまうのならば、それは
     `nnmail-pathname-coding-system' をカスタマイズしなければならない最
     も典型的な場合です。`utf-8' coding system はそのための良い候補です。
     あるいは `default-file-name-coding-system' またはこの変数が適切な
     値に初期化されるように、あなたのシステムの言語環境を変更しても良い
     でしょう。

記事を非-ASCII グループから他のグループにコピーまたは移動する場合、グルー
プ名をエンコードおよびデコードするための文字セットが両方のグループで同
じでなければならないことに注意してください。さもないと記事バッファーに
Newsgroups ヘッダーが正しく表示されないでしょう。



File: gnus-ja.info, Node: Searching, Next: Misc Group Stuff, Prev: Non-ASCII Group Names, Up: Group Buffer

検索
====

* Menu:

* nnir::                     IMAP を swish や namazu などで検索する
* nnmairix::                 maildir、MH、mbox を Mairix で検索する

FIXME: この節は書きかけです。

FIXME: Gnus が検索に関してできることの簡単なあらましを加える。nnir,
nnmairix, contrib/gnus-namazu の簡潔な比較もまた良いだろう。

FIXME: *Note Searching for Articles:: との違いを説明して、それらへのリ
ファレンスと逆からのリファレンスを追加する。



File: gnus-ja.info, Node: nnir, Next: nnmairix, Prev: Searching, Up: Searching

nnir
----

FIXME; まずは `nnir' にあるコメントを texi に変換する。



File: gnus-ja.info, Node: nnmairix, Prev: nnir, Up: Searching

nnmairix
--------

(訳注: Mairix は ASCII 文字しかサポートしません。)

この項は、メールに索引を付けて Gnus 内で検索するために、どうやって
mairix とバックエンド `nnmairix' を設定するかを説明します。さらに
mairix 検索に結び付けられて自動的に更新される恒久的な "賢い" (smart な)
グループを作ることができます。

* Menu:

* About mairix::                メール検索エンジン mairix について
* nnmairix requirements::       nnmairix を使うために必要なこと
* What nnmairix does::          nnmairix は実際に何をするのか?
* Setting up mairix::           mairix の設定
* Configuring nnmairix::        nnmairix バックエンドの設定
* nnmairix keyboard shortcuts:: 利用できるショートカットキー
* Propagating marks::           nnmairix グループの印を伝搬させる方法
* nnmairix tips and tricks::    ヒント、こつ、およびいくつかの例
* nnmairix caveats::            さらに知っておく必要があること



File: gnus-ja.info, Node: About mairix, Next: nnmairix requirements, Prev: nnmairix, Up: nnmairix

メール検索エンジン mairix について
..................................

Mairix はローカルに格納されたメールに索引を付けたり単語を検索するための
道具です。書いたのは Richard Curnow で GPL でライセンスされます。
Mairix は最もポピュラーな GNU/Linux の配布に付属していますが、Windows
(と cygwin)、Mac OS X および Solaris のもとでも動作します。ホームページ
は `http://www.rpcurnow.force9.co.uk/mairix/index.html' です。

`nnir' バックエンドを介して使うことができる swish++ や namazu のような
他の検索ツールほどには mairix は融通がきかないかもしれませんが、それに
は信じられないほど速いというすばらしい特長があります。現在のシステムで
は 1秒で何千通ものメールのヘッダーと記事のボディーの隅々までを容易に捜
すことができます。検索するために必要なデータベースの構築には 1〜2分かか
るかもしれませんが、一度それを完全に行なえば良いのです。それ以後、更新
は追加的 (インクリメンタル) に行なわれることもあって、本当に速いのです。
付け加えておくと、mairix の設定はとてもやさしいです。

しかし最高速で動かすために mairix は `Maildir' または `MH' の形式 (これ
は `nnml' バックエンドを含みます) で格納されたメールで使わなければなり
ません。もっとも mbox でも動作するのですけれど。Mairix は実際のメッセー
ジファイルを指し示すシンボリックリンクを「仮想」の maildir/MH フォルダー
に置くことによって検索結果を提示します (mbox を使っている場合はコピーが
作られます)。Mairix はそのような仮想フォルダーにすでに検索結果を提示し
ているので、あるメール検索の結果を提示する「賢い」メール・フォルダーを
作成するために外部のプログラムとして使用するのに非常によく適しています。
これは Kiboze グループ (*Note Kibozed Groups::) に似ていますが、はるか
に速いです。



File: gnus-ja.info, Node: nnmairix requirements, Next: What nnmairix does, Prev: About mairix, Up: nnmairix

nnmairix を使うために必要なこと
...............................

Mairix はローカルなメールを検索します--つまり mairix はメール・フォルダー
を必ず直接にアクセスできなければなりません。もしメールが別のサーバー
(例えば IMAP サーバー) にあって、たまたま shell でアクセスすることがで
きるのならば、`nnmairix' は例えば ssh を介して mairix を遠隔で動作させ
ることもできます。

加えて、`nnmairix' は Gnus のバックエンド `nnml'、`nnmaildir' および
`nnimap' だけをサポートします。`nnmairix' を使うには、必ずこれらのバッ
クエンドの一つを使わなければなりません。`nnmbox'、`nnfolder' または
`nnmh' のような他のバックエンドでは動作しないでしょう。

もしどうしても mbox を使わなければならなくて、それでも `nnmairix' を使
いたいのならば、ローカルな IMAP サーバーを立ち上げることによって
`nnimap' を介してアクセスすることができます。これはいくつかの mbox ファ
イルにアクセスするためにしてはかなり大がかりな作業になるので、もう MH
か Maildir に変えてしまいましょう。それでも mbox を使うことに本当に本当
に情熱を持っているのなら、Emacs 23 に付属している `mairix.el' パッケー
ジを研究する必要があるでしょう。



File: gnus-ja.info, Node: What nnmairix does, Next: Setting up mairix, Prev: nnmairix requirements, Up: nnmairix

nnmairix は実際に何をするのか?
..............................

バックエンド `nnmairix' は、ある検索語で mairix に尋ねたりデータベース
を更新させるために Gnus から mairix を呼ぶことを可能にします。概略バッ
ファーでメッセージを見ている間、あらかじめ用意されている mairix を呼ぶ
ためのいくつかのショートカットを使うことができます。例えば現在見ている
メッセージの送信者からのすべてのメールをすばやく探したり、メールが異なっ
たフォルダーにあっても、そのメッセージに関連している全体のスレッドを表
示するなどです。

さらに、ある mairix 検索に結び付いた恒久的な `nnmairix' グループを作る
ことができます。この例では、ある送信者から来て、かつ、ある表題行 (また
は Message-ID に基づく一つの特定のスレッドさえ) を持つメールを含むグルー
プを容易に作ることができます。これらのフォルダーで新しいメールをチェッ
クする (例えば `g' または `M-g' を押す) と、mairix を呼ぶことによってそ
れら自体が自動的に更新します。

Mairix はすでにグループを作っていて、Gnus でアクセスできるようにそれらの
メールへのリンクを用意しているのに、いったいなぜ `nnmairix' が必要
なのかと尋ねるかもしれませんね。そうではありませんか? えーと、それは動
く*かも*しれませんが、だめなことが多いでしょう--問題無しには。最も
ありそうなのは、記事数がおかしくなって、しかも時々は Gnus があるはずだと
言い張るメールがすでにキャンセルされていてアクセスできないことを思い知ら
されることでしょう。これは、ものごとが Gnus の後ろに隠れて起こっていると
き、Gnus は本当は不満に思っているという事実のためです。例え
ば IMAP サーバーで mairix を使っているのなら、もう一つの問題は
メールバックエンド自体であるかもしれません (mairix が検索グループの内容
を変えたとき、Dovecot は間違った索引ファイルについて私に不平を言いました)。
`nnmairix' を使えば、これらの問題は回避されるはずです。

実は `nnmairix' はメールバックエンドではありません--それは mairix が検
索結果を格納する「本当の」メールバックエンドと Gnus フロントエンドの間
に位置していて、むしろ実際にはラッパーに似ています。Mairix フォルダーの
ために三つの異なるメールバックエンド `nnml'、`nnmaildir' または
`nnimap' の中から選ぶことができます。`nnmairix' は検索結果をこのメール
バックエンドの `zz_mairix-<NAME>-<NUMBER>' という名前のフォルダーに格納
するために mairix バイナリーを呼びますが、それらのフォルダーは Gnus フ
ロントエンドには名前が `<NAME>' だけになって渡されます。すでにメールを
格納している既存のメールバックエンドを使うことができますが、あなたの他
のメールと並べて新しいメールグループを作る `nnmairix' が気持ち悪いので
あれば、例えば新しい `nnmaildir' または `nnml' サーバーを mairix 専用に
作ることもできます。ただし、それらのサーバーが間違って新着メールを取り
込んでしまわないようにしてください (*Note nnmairix caveats::)。もし
`nnimap' とともに IMAP サーバーで mairix をリモートに使いたいのであれば、
特別な事情が生じます--ここでは mairix フォルダーと他のメールが同じ
`nnimap' バックエンド上になければなりません。



File: gnus-ja.info, Node: Setting up mairix, Next: Configuring nnmairix, Prev: What nnmairix does, Up: nnmairix

mairix の設定
.............

まずはメールフォルダーのバックアップを作りましょう (*Note nnmairix
caveats::)。

Mairix の設定は簡単です。(少なくとも) 以下のエントリーを含む
`.mairixrc' ファイルを作ってください:

     # Your Maildir/MH base folder
     base=~/Maildir

これはすべてのメールの基点になるフォルダーです。以下のすべてのディレク
トリーはこのフォルダーを基点に相対的な値をとります。`nnmairix' を
`nnimap' で使いたい場合、この基点のディレクトリーは IMAP サーバーがメー
ルフォルダーを格納するメールディレクトリーを表すものでなければなりませ
ん!

     maildir= ... 索引を付ける maildir フォルダー ...
     mh= ... 索引を付ける nnml/mh フォルダー ...
     mbox= ... 索引を付ける mbox フォルダー ...

Mairix で索引を付けたいすべてのメールフォルダーと mbox ファイルをこれで
(基点ディレクトリーへの相対値で!) 指定します。`nnml' バックエンドはメー
ルを MH 形式で保存するので、それらのディレクトリーを `mh' 行に置いてお
かなければならないことに注意してください。さらに詳しいことについては、
この章の最後にある例と mairixrc の man ページを見てください。

     omit=zz_mairix-*

これは mairix の検索結果に偶然に索引付けをしてしまわないためのものです。
これらのフォルダーの接頭辞は、変数 `nnmairix-group-prefix' で変えること
ができます。

     mformat= ... 'maildir' または 'mh' ...
     database= ... データベース・ファイルの置き場所 ...

`mformat' の設定は mairix 検索フォルダーへの出力形式を指定します。検索
結果に `nnml' でアクセスしたい場合は、これを `mh' に設定してください。
さもなければ `maildir' を選びましょう。

要約するために、私の `.mairixrc' ファイルを短くしたものを例に挙げましょ
う:

     base=~/Maildir
     maildir=.personal:.work:.logcheck:.sent
     mh=../Mail/nnml/*...
     mbox=../mboxmail/mailarchive_year*
     mformat=maildir
     omit=zz_mairix-*
     database=~/.mairixdatabase

この場合、基点のディレクトリーは `~/Maildir' で、そこに私のすべての
Maildir フォルダーが格納されています。ご覧のようにそれぞれのフォルダー
はコロンで区切られています。なぜどのフォルダーもドットで始まるのかって?
それは私が IMAP サーバーとして Dovecot を使い、さらにそれは
`Maildir++' フォルダーを使うからです。`nnmairix' をテストするために
`~/Mail/nnml' にセーブされている `nnml' のメールもいくつか持っています。
これは `base' ディレクトリーへの相対値で指定しなければならないので
`../Mail' の表記が必要です。`*...' で終わる行は、このディレクトリーにあ
るすべてのファイルを再帰的に走査するためであることに注意してください。
三個のドット無しのワイルドカード `*' では再帰的に働きません。さらに私は
`~/mboxmail' のあたりにアーカイブされたメールを含む古い `mbox' ファイル
を持っています。その他の行の意味は言うまでもないですね。

詳細およびさらなるオプションについては `mairixrc' の man ページを見てく
ださい。とりわけワイルドカードの使い方は、今まで使っていたのとは少し違
うでしょう。

さあ、それでは最初に `mairix' を実行して索引を作りましょう。これには数
分かかるでしょう。でもあらゆる索引が追加的 (インクリメンタル) に更新を
行なうので非常に速いです。



File: gnus-ja.info, Node: Configuring nnmairix, Next: nnmairix keyboard shortcuts, Prev: Setting up mairix, Up: nnmairix

nnmairix バックエンドの設定
...........................

グループモードで `G b c' (`nnmairix-create-server-and-default-group')
をタイプしてください。これは必要なすべての情報を質問して、`nnmairix' サー
バーを外部 (foreign) グループとして作成します。以下を指定する必要がある
でしょう:

   * `nnmairix' サーバーの *名前* です--好きなものを選んでください。

   * Mairix がその検索結果を格納する *バックエンド・サーバー* の名前で
     す。これは `nnml:mymail' のような完全なサーバー名でなければなりま
     せん。今のところ `nnmaildir'、`nnimap' および `nnml' でアクセスす
     るサーバーがサポートされています。上で説明したように、ローカルに格
     納されるメールのためには、あなたがメールを格納している既存のサーバー
     にすれば良いでしょう。しかし `nnmairix' 専用に、例えば新しい
     `nnmaildir' または `nnml' サーバーを第二の (secondary) 選択方法に
     加えることもできます (*Note Finding the News::)。Mairix を IMAP サー
     バー上で遠隔動作させたいのならば、そこでそれに対応する `nnimap' サー
     バーを選ばなければなりません。

   * Mairix バイナリーを呼ぶための *コマンド* です。通常これは単に
     `mairix' で良いのですが、例えば IMAP サーバー上で mairix を遠隔動
     作させたいのであれば、`ssh SERVER mairix' のようなものにすることも
     できます。Mairix へのディフォルトのオプションを加えたい場合、それ
     をここでやっても構いません。でも、代わりに変数
     `nnmairix-mairix-search-options' を使う方が良いです。

   * *ディフォルトの検索グループ* の名前です。これは mairix のすべての
     検索結果、つまり恒久的な `nnmairix' グループに結び付けられないすべ
     ての検索結果を格納するグループです。好きなものを選んでください。

   * もしメールバックエンドが `nnimap' か `nnmaildir' だったら、
     *Maildir++* つまり隠された (= `.' で始まる ) maildir フォルダーを
     使うかどうかを尋ねられるでしょう。例えば Dovecot IMAP サーバーを使っ
     ている場合は、そこで `yes' と回答しなければなりません。それ以外の
     場合は `no' と答えるべきです。



File: gnus-ja.info, Node: nnmairix keyboard shortcuts, Next: Propagating marks, Prev: Configuring nnmairix, Up: nnmairix

利用できるショートカットキー
............................

グループモードで:

`G b c'
     `nnmairix' サーバーと、このサーバーのためのディフォルトの検索グルー
     プを作ります (`nnmairix-create-server-and-default-group')。これは
     すでに行なっておいてある必要があります (*Note Configuring
     nnmairix::)。

`G b s'
     Mairix に送られる検索語を与えます。検索結果はディフォルトの検索グ
     ループに格納され、それは自動的に表示されます (`nnmairix-search')。

`G b m'
     Mairix の検索または恒久的なグループをもっと快適に、常にグループの
     カスタマイズに似たグラフィックなウィジェットを使って作るようにしま
     す。それがどんなものかを知るには、まずは試してみてください
     (`nnmairix-widget-search')。

`G b i'
     もう一つの快適な mairix 検索コマンドですが、ミニバッファーしか使い
     ません (`nnmairix-search-interactive')。

`G b g'
     検索に関連させられた恒久的なグループを作ります
     (`nnmairix-create-search-group')。このグループを `g' または `M-g'
     で更新するときに `nnmairix' バックエンドは自動的に mairix を呼びま
     す。

`G b q'
     カーソル位置の `nnmairix' グループの検索条件を変更します
     (`nnmairix-group-change-query-this-group')。

`G b t'
     カーソル位置の `nnmairix' グループの `スレッド' パラメーターをトグ
     ルに切り替えます。つまり見つかったメッセージのすべてのスレッドを見
     たい場合に使います (`nnmairix-group-toggle-threads-this-group')。

`G b u'
     データベースを更新するために mairix バイナリーを呼びます
     (`nnmairix-update-database')。ディフォルトのパラメーターは、これを
     できるだけ速くするための `-F' および `-Q' です (これらのディフォル
     トのオプションを定義するには変数 `nnmairix-mairix-update-options'
     を見てください)。

`G b r'
     この `nnmairix' グループの記事を常に既読または未読に保つか、または
     印を変更しないようにします
     (`nnmairix-group-toggle-readmarks-this-group')。

`G b d'
     「本当の」メールバックエンドで `nnmairix' グループを作り直します
     (`nnmairix-group-delete-recreate-this-group')。`nnmairix' グループ
     の記事数がいつも間違っている場合に、これを行なうことができます。

`G b a'
     カーソル位置の `nnmairix' グループのための `allow-fast' パラメーター
     をトグルに切り替えます
     (`nnmairix-group-toggle-allowfast-this-group')。ディフォルトの
     `nnmairix' の動作は、グループを更新したり入ったときに mairix の検
     索を行なうことです。`allow-fast' パラメーターが設定されると、グルー
     プ入ったときではなく、明示的にグループを更新するときだけ mairix が
     呼ばれます。これはグループに入るときに速くなりますが、更新したとき
     とまだ mairix データベースに無いグループに入るときの期間に何かが変
     化した場合に、実体の無いシンボリックリンクを生じさせるかもしれませ
     ん。

`G b p'
     このグループの印を伝搬させるかどうかをトグルに切り替えます
     (`nnmairix-group-toggle-propmarks-this-group')。(*Note
     Propagating marks::)。

`G b o'
     印を主動で伝搬させます (`nnmairix-propagate-marks')。これは
     `nnmairix-propagate-marks-upon-close' が `nil' である場合だけ必要
     です。

概略モードで:

`$ m'
     現在のメッセージに基づいた mairix の検索またはグループを、グラフィッ
     クなウィジェットを使って作ります (`nnmairix-widget-search' と同じ
     です) (`nnmairix-widget-search-from-this-article')。

`$ g'
     現在のメッセージに基づいた検索条件で新しい検索グループを対話的に作
     ります。グラフィックなウィジェットの代わりにミニバッファーを使いま
     すが (`nnmairix-create-search-group-from-message')。

`$ t'
     現在の記事のスレッドを捜します
     (`nnmairix-search-thread-this-article')。事実上これは現在の記事の
     `m:msgid' で `nnmairix-search' を呼んでスレッドを得るためのショー
     トカットです。

`$ f'
     現在の記事の送信者からのすべてのメッセージを探します
     (`nnmairix-search-from-this-article')。これは `f:From' で
     `nnmairix-search' を呼ぶためのショートカットです。

`$ o'
     (これが使えるのは `nnmairix' グループだけです!) この記事に正しい投
     稿様式 (posting styles) とグループパラメーターを適用して返信するた
     めに、この記事が元々来たグループを特定して、そのグループでその記事
     を表示しようとします (`nnmairix-goto-original-article')。この関数
     はもし利用可能ならレジストリーを使いますが、代替手段として記事ファ
     イルの名前を分析することもできます。

`$ u'
     元の記事から、もしあれば可視記事の印 (tick mark) を取り除きます
     (`nnmairix-remove-tick-mark-original-article') (*Note nnmairix
     tips and tricks::)。



File: gnus-ja.info, Node: Propagating marks, Next: nnmairix tips and tricks, Prev: nnmairix keyboard shortcuts, Up: nnmairix

nnmairix グループの印を伝搬させる方法
.....................................

初めに: 印を伝搬させる機能を効率良く使うためには、実際にはパッチを当て
た mairix のバイナリーが必要です。そうしないといつも mairix データベー
スを更新しなければならないでしょう。パッチはここで手に入ります:

`http://www.randomsample.de/mairix-maildir-patch.tar'

このパッチには mairix v0.21 のソースコードが必要です。それに付いている
readme ファイルでどんなことも説明されています。印の伝搬を使わなくても良
いと思うならこれらのパッチを当てなくても構いませんが、それでもなお、そ
れらは maildir フラグの変更にまつわるやっかいごとを修正してもくれるので
有用でしょう。

パッチを当てた mairix のバイナリーとともに `nnmairix' をメール分割
(*Note Fancy Mail Splitting::) の代わりとして使うことができます。例えば
`david@foobar.com' からのすべてのメールをあるグループに放り込む代わりに、
単に `f:david@foobar.com' を探す検索グループを作ることができます。実の
ところこれが「賢いフォルダー」の肝心なところで、単にすべてを一つのメー
ルフォルダーに放り込んだら、分割する代わりに動的に検索結果を作るのです。
これは、したいときはいつでもフォルダーを変更できるので、より融通が効き
ます。このことは、あなたが実際のメールグループの代わりに、いつもは
`nnmairix' グループにあるメールを読むであろうことも暗示します。

しかし、一つ問題があります。`david@foobar.com' から新しいメールを受け取っ
たとすると、それは二つのグループに現れるのです。「実際」のグループ (例
えば INBOX) および `nnmairix' 検索グループです (後者は、もし mairix デー
タベースを更新してあれば)。`nnmairix' グループに入ってそのメールを読む
と既読の印が付きますが、それは `nnmairix' グループでだけです---「実際」
のメールグループでは未読のままです。

そのメールグループをキャッチアップする (すべての記事を既読にする) こと
はできます。しかしこれは退屈だし、そのための `nnmairix' グループを作っ
ていないメールを見落とすかもしれない点で事故を起こしやすいでしょう。も
ちろん最初に `nnmairix-goto-original-article' (*Note nnmairix keyboard
shortcuts::) を使ってから元のグループでそのメールを読むことはできますが、
それはもっとやっかいでしょう。

明らかに、元の記事にどうにかして印を自動的に付けることできれば、それが
最も楽なやり方でしょう。これがまさに *印の伝搬* が行なおうとしているこ
とです。

ディフォルトでは印の伝搬はしないようになっています。あるグループのため
のそれは `nnmairix-group-toggle-propmarks-this-group' (`G b p' にバイン
ドされています) で有効にすることができます。この関数はディフォルトの検
索グループで使おうとすると警告を発します。なぜかと言うとディフォルトの
検索グループは一時的な検索のためにあるので、印が偶然にこのグループから
伝搬してしまいやすいからです。もっとも本当にそれをやりたいのなら、その
警告を無視することはできます。

印の伝搬を有効にしてあると `nnmairix' グループで付けたすべての印が元の
グループに伝搬するはずです。例えば記事に可視 (tick) の印を (ディフォル
トでは `!' で) 付けると、この印は魔法のように元の記事にも付くはずです。

あなたが知っている必要がある、または無い、さらなることがらがあります:

印はすぐにではなく、グループを閉じたときだけ付けられます。これは印の伝
搬を性急に行なわない以外に maildir ファイルを扱うときのシンボリックリン
クにまつわる問題の回避もします (フラグの変更はファイル名の変化を伴うの
で)。印の伝搬を `nnmairix-propagate-marks-upon-close' を通じて制御する
こともできます (詳しくは変数の説明を見てください)。

当然ながら、あなたが印を付けたいあらゆる記事のために `nnmairix' は元の
グループを調べなければならないでしょう。元のグループを特定するために
`nnmairix' は、もし使えるなら最初にレジストリーを使います。レジストリー
は非常に速いです。したがって印の伝搬を使うなら本当にレジストリーを使え
るようにすべきです。本当に。RAM とディスクの容量に心配が無いなら
`gnus-registry-max-entries' を十分に大きな値に設定してください。大事を
取るためには、おおよそ mairix で索引を付けるメールの量を選んでください。

レジストリーを使いたくない、またはレジストリーがまだ元の記事を見たこと
が無い場合、その記事のファイル名を特定するために `nnmairix' は追加の
mairix 検索を行ないます。もちろんこれはレジストリーより遅くなります--も
しこのやり方で数百ないしは数千の印を付けると、いくらか時間がかかるかも
しれません。この状況は `nnmairix-only-use-registry' を `t' に設定するこ
とによって避けることができます。

おそらくあなたは逆方向にも印を伝搬させたいでしょう。つまり「本当の」メー
ルグループで記事に可視 (tick) 印を付けたら `nnmairix' グループにある同
じ記事も可視になって欲しいということです。いくつかのもっともな理由によ
り、これは maildir を使う場合だけ効率的に行なうことができます。すぐに矛
盾したことを言いますが、それは `nnmaildir' では働きません。なぜなら
`nnmaildir' は印を外部のしかもファイルではないところに格納するからです。
したがって `nnmairix' グループへの印の伝搬は、通常はファイル形式として
maildir を使う IMAP サーバーの場合だけ働きます。

今この設定作業を行なっているのなら
`nnmairix-propagate-marks-to-nnmairix-groups' を `t' に設定して何が起き
るか見てください。もしあなたが見るものが好きではないならば、再びそれを
`nil' に戻しましょう。一つの問題は未読記事の数を間違えることかもしれま
せん。これは元のグループで記事を消去したり、または期限切れ消去されたと
きに普通に起きます。これが起きたらそのバックエンドで `G b d' を使って、
その `nnmairix' グループを作り直してください。



File: gnus-ja.info, Node: nnmairix tips and tricks, Next: nnmairix caveats, Prev: Propagating marks, Up: nnmairix

ヒント、こつ、およびいくつかの例
................................

   * メールのチェック

     私は大事なメールのグループをグループレベル 1 にしています。Mairix
     グループのグループレベルは 5 なので、それらは起動時にチェックされ
     ません (*Note Group Levels::)。

     メールをチェックするために私は以下を使っています:

          (defun my-check-mail-mairix-update (level)
            (interactive "P")
            ;; 接頭引数が与えられなかったらレベルを 1 に設定する。
            (gnus-group-get-new-news (or level 1))
            (nnmairix-update-groups "mairixsearch" t t)
            (gnus-group-list-groups))

          (define-key gnus-group-mode-map "g" 'my-check-mail-mairix-update)

     `"mairixsearch"' の代わりにあなたの `nnmairix' サーバーの名前を使
     いましょう。詳しくは `nnmairix-update-groups' の説明を見てください。

   * 可視 (ticked) 記事のための検索グループの例

     例えばすべての可視記事のためのグループを作ることができます。そこで
     は記事が常に未読になっています:

     `G b g' をたたいてグループ名を入力し、検索条件として `F:f' を使っ
     てください。そしてスレッドを含めないようにします。

     次に `G b p' を使ってこのグループのための印の伝搬を有効にしましょ
     う。そうしたら `G b r' を二回使って「常に未読」機能を有効にします。

     これはこれで良いでしょう--しかしどうやって `nnmairix' グループの可
     視印を消したら良いでしょうか? それには二つの選択肢があります:
     `nnmairix-remove-tick-mark-original-article' (`$ u' にバインドされ
     ています) を使って元の記事から可視印を取り除くことができます。もう
     一つの可能なことは `nnmairix-propagate-marks-to-nnmairix-groups'
     を `t' に設定することです。しかし上記のこのオプションに関するコメ
     ントを見てください。もしそれが動作するなら可視印は `nnmairix' グルー
     プにあるはずで、それらはいつものように、例えば記事を既読にすること
     によって取り除くことができます。

     元の記事から可視印を取り除くと、mairix データベースを更新しかつグ
     ループを更新した後で、その記事は `nnmairix' グループから消え去るは
     ずです。幸いにまさにそれを行なうための関数があります:
     `nnmairix-update-groups' です。詳しくは前述のコードの断片と関数の
     説明を見てください。

   * メールグループの自動講読の取り扱い

     先に説明したように、すべての `nnmairix' グループは実際には
     `zz_mairix-<NAME>-<NUMBER>' の様式でメールバックエンドに格納されま
     す。それらはサーバーバッファーでそのバックエンドに入ると見ることが
     できます。これらのグループを講読してはいけません! 残念ながらこれら
     のグループは `nnmaildir' または `nnml' を使うと通常 *自動講読* に
     なります。つまり `zz_mairix*' 様式のグループが突然グループバッファー
     に現れるのを見ることになります。もしこれが起こったら単に `C-k' で
     それらのグループを kill してください。これを避けるには
     `gnus-auto-subscribed-groups' を `nil' に設定して自動講読を恒久的
     に無効にする (*Note Filtering New Groups:: か、またはもしこの機能
     を維持したいのであれば `zz_' ではじまるすべてのグループでそれを無
     効にする以下のその場しのぎの手を使ってください:

          (setq gnus-auto-subscribed-groups
                "^\\(nnml\\|nnfolder\\|nnmbox\\|nnmh\\|nnbabyl\\|nnmaildir\\).*:\\([^z]\\|z$\\|\\z[^z]\\|zz$\\|zz[^_]\\|zz_$\\).*")



File: gnus-ja.info, Node: nnmairix caveats, Prev: nnmairix tips and tricks, Up: nnmairix

さらに知っておく必要があること
..............................

   * 第二の `nnml' サーバーを、まさに nnmairix のために作ることができま
     す。しかしその場合、対応するサーバー変数 `nnml-get-new-mail' を明
     示的に `nil' に設定する必要があります。そうしておかないと新着メー
     ルがこの第二のサーバーに取り込まれてしまうかもしれません (そして、
     それらを二度と見ることはないでしょう)。サーバー定義の例です:

          (nnml "mairix" (nnml-directory "mairix") (nnml-get-new-mail nil))

     (`nnmaildir' にもサーバー変数 `get-new-mail' があるのですが、それ
     はディフォルトで `nil' なので、`nnmaildir' サーバーをまさに
     mairix 用に使う場合でも、それを明示的に設定する必要はありません。)

   * もし Gnus レジストリーを使っているなら: `nnmairix' グループでレジ
     ストリーを使う (それらのグループを
     `gnus-registry-unfollowed-groups' に含める) ことはしないでください。
     もし `gnus-registry-split-fancy-with-parent' を使っているなら *特
     別な注意* が必要です。分割されて `nnmairix' グループに入ったメール
     は、通常そのグループの新着メールをチェックしたとたんに永久に無くなっ
     てしまいます (はい、私はそれをやってしまいました...)。

   * したがって: *絶対に、断じて*「本当の」メールを `nnmairix' グループ
     に入れてはいけません (とにかくそれができるべきではありません)。

   * もし Gnus エージェント (*Note Gnus Unplugged::) を使っているなら:
     `nnmairix' グループをエージェント化しないでください (もっとも、そ
     れをやったら何が起きるか私は知りませんが)。

   * Mairix は US-ASCII 文字だけをサポートします。

   * `nnmairix' は mairix が呼ばれた後で Gnus にメールバックエンドのグ
     ループを完全に読み直させる、かなり力まかせな手段を使います--つまり
     単純にそのメールバックエンドのグループを消して作り直します。これま
     でのところ、これは何ら問題無く働き、`nnmairix' がそれ自身のもの以
     外のメールグループを削除するとは思えません。しかしとにかく本当に、
     メールフォルダーのバックアップを持つべきです。

   * すべての必要な情報はグループパラメーターに格納されます (*Note
     Group Parameters::)。これにはアクティブファイルを必要としないとい
     う利点がありますが、それは暗に `nnmairix' グループを kill すると永
     久に失われてしまうことをも意味します。

   * たくさんの `nnmairix' グループを作って kill すると、メールバックエ
     ンドのサーバーに "zz_mairix-*" という名前のグループが溜まってしま
     います。もはや不要になった古いグループを削除するには
     `nnmairix-purge-old-groups' を呼んでください。これは当然
     `zz_mairix-<NAME>-<NUMBER>' の様式ではどんな「本当の」メールもフォ
     ルダーにセーブしないことを想定していることに注意してください。
     `nnmairix' グループの接頭辞は変数 `nnmairix-group-prefix' を変更す
     ることによって変えることができます。

   * 以下は先に言及した mairix のためのパッチ (*Note Propagating
     marks::) を *使わない* 場合だけに当てはまります:

     `nnmairix' を maildir フォルダーとともに使うと問題が起きる場合があ
     ります。それは maildir がメールのフラグを `Seen' または `Replied'
     のように、それぞれ文字 `S' および `R' をメッセージのファイル名に付
     け加えることによって格納するという事実によります。これは、今のとこ
     ろ、新しいメールが届いたときだけでなくメールのフラグが変化したとき
     も、mairix のデータベースを更新しなければならないであろうことを暗
     示しています。同じことが、まだ `new' フォルダーにあるうちに索引が
     作られたものの Gnus がそのメールを見たときに `cur' に移された新し
     いメールにも当てはまります。これが起きた後でデータベースを更新しな
     いと、mairix 検索は存在しないファイルを指すシンボリックリンクをも
     たらします。Gnus では通常それらのメッセージはヘッダーに "(none)"
     が表示されて現れ、アクセスすることができません。もしこれが起こった
     場合、普通は `G b u' を使い、かつグループを更新すれば解決します。



File: gnus-ja.info, Node: Misc Group Stuff, Prev: Searching, Up: Group Buffer

その他のグループ関連
====================

* Menu:

* Scanning New Messages::       Gnus に新しいメッセージが到着したかどうかを聞く
* Group Information::           グループと Gnus に関する情報とヘルプ
* Group Timestamp::             Gnus に最後にいつグループを読んだかを記録させる
* File Commands::               Gnus のファイルの読み書き
* Sieve Commands::              Sieve スクリプトの管理

`v'
     `v' キーはユーザー用に予約されています。そのまま何かのコマンドに割
     り当てても構いませんが、接頭キーとして使う方が良いでしょう。例です:

          (define-key gnus-group-mode-map (kbd "v j d")
            (lambda ()
              (interactive)
              (gnus-group-jump-to-group "nndraft:drafts")))

     Emacs でユーザー用に予約されているキーとキーバインドについては、
     *Note Keymaps: (emacs)Keymaps.

`^'
     サーバーバッファーモードに入ります (`gnus-group-enter-server-mode')。
     *Note Server Buffer::.

`a'
     メッセージ (ディフォルトはニュース) の作成を開始しま
     す (`gnus-group-post-news')。接頭引数が与えられると、現在位置のグルー
     プに投稿します。もし接頭引数が 1 だったら、どのグループに投稿するかを尋
     ねます。この関数の名前から連想されることとは裏腹に、接頭引数でメールグルー
     プが指定された場合は、ニュースの代わりにメールの様式が用意されます。
     *Note Composing Messages::.

`m'
     メールをどこかに送ります (`gnus-group-mail')。接頭引数が与えられる
     と、現在位置のグループの投稿様式 (posting style) を使います。もし接頭引
     数が 1 だったら、どのグループの投稿様式を使うかを尋ねます。
     *Note Composing Messages::.

`i'
     ニュースの作成を開始します (`gnus-group-news')。接頭引数が与えられ
     ると、現在位置のグループに投稿します。もし接頭引数が 1 だったら、
     どのグループに投稿するかを尋ねます。*Note Composing Messages::.

     この関数は、たとえメールグループで使われたとしても、実際にはニュー
     スの様式を用意します。これは、メッセージを実際にはネットワーク経由
     で送らずに、メールグループに「投稿」するのに便利です; それらは当の
     グループに単に直接保存されます。対応するバックエンドが投稿のための
     メソッド (request-post method) を持っていなければなりませんが。

`G z'

     現在位置のグループを圧縮します (`gnus-group-compact-group')。今の
     ところ `nnml' (*Note Mail Spool::) だけに実装されています。これは
     記事番号のすきまを取り除くので、正しい全記事数を得ることができるよ
     うになります。

以下はグループバッファーのための変数です:

`gnus-group-mode-hook'
     グループバッファーが作成された時に呼び出されます。

`gnus-group-prepare-hook'
     グループバッファーが生成されたあとに呼び出されます。これはバッファー
     を何か変な、自然ではない方法で修正したいときに使われるかもしれませ
     ん。

`gnus-group-prepared-hook'
     グループバッファーが生成された後の一番最後に呼び出されます。例えば
     ポイントをどこかに移動させたいときなどに使えます。

`gnus-permanently-visible-groups'
     この正規表現に合致するグループは、それが空であるかどうかに関わらず、
     常にグループバッファーに表示されます。



File: gnus-ja.info, Node: Scanning New Messages, Next: Group Information, Prev: Misc Group Stuff, Up: Misc Group Stuff

新着メッセージを探す
--------------------

`g'
     サーバーの新着記事をチェックします。数値の接頭引数を使用すると、こ
     の命令は引数 ARG かそれより小さいレベルのグループのみをチェックし
     ます (`gnus-group-get-new-news')。数値以外の接頭引数を与えると、こ
     の命令はそのバックエンドからアクティブファイルを強制的に全部読み直
     します。

`M-g'
     現在のグループに新着記事があるかどうかをチェックします
     (`gnus-group-get-new-news-this-group')。
     `gnus-goto-next-group-when-activating' はこの命令が次のグループ位
     置へ移動するかどうかを決めます。ディフォルトは `t' です。

`C-c M-g'
     無条件にすべてのグループを起動します (`gnus-activate-all-groups')。

`R'
     Gnus を再起動します (`gnus-group-restart')。これは `.newsrc' ファ
     イルをセーブし、すべてのサーバーの接続を閉じ、すべての Gnus ランタ
     イム変数をクリアした後、Gnus をもう一度最初から開始します。

`gnus-get-new-news-hook' は新着ニュースをチェックする直前に実行されます。

`gnus-after-getting-new-news-hook' 新着ニュースをチェックした後に実行さ
れます。



File: gnus-ja.info, Node: Group Information, Next: Group Timestamp, Prev: Scanning New Messages, Up: Misc Group Stuff

グループ情報
------------

`H f'
     現在のグループの FAQ を取得しようとします
     (`gnus-group-fetch-faq')。Gnus は FAQ を
     `gnus-group-faq-directory' から取得しようとします。これは通常リモー
     トマシン上のディレクトリーです。この変数はディレクトリーのリストで
     あっても構いません。この場合、このコマンドに接頭引数を与えることで
     いくつかのサイトの中から選ぶことができます。ファイルの取得には
     `ange-ftp' (または `efs') が使用されます。

     もし最初のサイトからの取得が失敗した場合、Gnus は
     `gnus-group-faq-directory' の値をすべて、一つ一つオープンしてみよ
     うとします。

`H c'
     現在のグループの憲章を web ブラウザーで開こうとします
     (`gnus-group-fetch-charter')。接頭引数が与えられるとグループ名を尋
     ねます。

     Gnus は `gnus-group-charter-alist' を使って憲章の所在を探します。
     所在がわからなかったら、Gnus はそのグループのコントロールメッセー
     ジを取得します。それには憲章を含んでいることがありますから。

`H C'
     そのグループのコントロールメッセージを `ftp.isc.org' の記録庫から
     取得します (`gnus-group-fetch-control')。接頭引数が与えられるとグ
     ループ名を尋ねます。

     `gnus-group-fetch-control-use-browse-url' が非-`nil' だったら、
     Gnus は `browse-url' を使ってコントロールメッセージを開きます。そ
     うでない場合は `ange-ftp' を使って取得され、一時グループに表示され
     ます。

     コントロールメッセージは圧縮されていることに注意してください。この
     コマンドを使うには `auto-compression-mode' を on にしておく必要が
     あります (*Note Compressed Files: (emacs)Compressed Files.)。

`H d'
`C-c C-d'
     現在のグループの説明を表示します (`gnus-group-describe-group')。接
     頭引数を与えると、説明文をサーバーから強制的に再読み込みします。

`M-d'
     すべてのグループの説明を表示します
     (`gnus-group-describe-all-groups')。接頭引数を与えると、説明文ファ
     イルをサーバーから強制的に再読み込みします。

`H v'
`V'
     現在の Gnus のバージョン番号を表示します (`gnus-version')。

`?'
     とても短いヘルプメッセージを与えます
     (`gnus-group-describe-briefly')。

`C-c C-i'
     Gnus の info ノードに移動します (`gnus-info-find-node')。



File: gnus-ja.info, Node: Group Timestamp, Next: File Commands, Prev: Group Information, Up: Misc Group Stuff

グループの日付
--------------

Gnus に、あなたが最後にいつグループを読んだかを記録させると便利かもしれ
ません。この活動を始めさせるには、`gnus-group-set-timestamp' を
`gnus-select-group-hook' に追加してください。

     (add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)

これを行なった後、あなたがグループに入るたびにそれが記録されます。

この情報はさまざまな方法で表示できます--もっとも簡単なのは、グループ行
フォーマットで `%d' 指定を使う方法です:

     (setq gnus-group-line-format
           "%M\%S\%p\%P\%5y: %(%-40,40g%) %d\n")

この結果として、各行は以下のように表示されます:

     *        0: mail.ding                                19961002T012943
              0: custom                                   19961002T012713

見て分かるとおり、日付はコンパクトな ISO 8601 形式で表示されます。これ
ではちょっとあんまりなので、以下のような感じにすると日付だけを表示でき
ます。

     (setq gnus-group-line-format
           "%M\%S\%p\%P\%5y: %(%-40,40g%) %6,6~(cut 2)d\n")

もっと凝った日付の形式をお望みなら、利用者定義によるフォーマットの仕様
を使うことができます。以下のようなものはうまくいくでしょう:

     (setq gnus-group-line-format
           "%M\%S\%p\%P\%5y: %(%-40,40g%) %ud\n")
     (defun gnus-user-format-function-d (headers)
       (let ((time (gnus-group-timestamp gnus-tmp-group)))
         (if time
             (format-time-string "%b %d  %H:%M" time)
           "")))



File: gnus-ja.info, Node: File Commands, Next: Sieve Commands, Prev: Group Timestamp, Up: Misc Group Stuff

ファイル命令
------------

`r'
     初期化ファイルの再読み込みを行ないます (`gnus-init-file'、ディフォ
     ルトは `~/.gnus.el') (`gnus-group-read-init-file')。

`s'
     `.newsrc.eld' ファイル (と、もしそうしたければ `.newsrc' ファイル)
     をセーブします (`gnus-group-save-newsrc')。




File: gnus-ja.info, Node: Sieve Commands, Prev: File Commands, Up: Misc Group Stuff

Sieve コマンド
--------------

Sieve はサーバー側で使われるメールフィルター言語です。Gnus では、各グルー
プに適用される sieve の規則を指定する、`sieve' グループパラメーター
(*Note Group Parameters::) を使うことができます。guns はそれらすべての
グループパラメーターを、サーバーで使うことも可能な正しい Sieve スクリプ
トに翻訳する、二つのコマンドを提供します。

作成された Sieve スクリプトは `gnus-sieve-file' (ディフォルトは
`~/.sieve') に置かれます。Gnus が作るコードは二つの区切り記号
`gnus-sieve-region-start' と `gnus-sieve-region-end' の間に置かれるので、
これらの区切り記号の外に追加の Sieve コードを書いても、次回 Sieve スク
リプトを再作成するときに消されてしまうことはありません。

変数 `gnus-sieve-crosspost' は Sieve スクリプトがどのように作られるかを
制御します。もし非-`nil' (ディフォルト) だったら記事は規則に合致するす
べてのグループに置かれます。そうでない場合、記事は最初の規則に合致する
グループだけに置かれます。例えばグループパラメーター `(sieve address
sender" "owner-ding@hpc.uh.edu")' は、`gnus-sieve-crosspost' が `nil'
だったら以下の Sieve コードの断片を作ります。(`gnus-sieve-crosspost' が
非-`nil' だった場合は、行が含む `stop' の呼び出しが削除されること以外は
同じです。)

     if address "sender" "owner-ding@hpc.uh.edu" {
             fileinto "INBOX.ding";
             stop;
     }

*Note Emacs Sieve: (sieve)Top.

`D g'
     `sieve' グループパラメーターから Sieve スクリプトを再作成して、
     `gnus-sieve-file' に書き込みます。以前の内容は保存されません。

`D u'
     `sieve' グループパラメーターを元に `gnus-sieve-file' の Gnus が管
     理している部分を再作成してファイルにセーブし、`sieveshell' プログ
     ラムを使ってサーバーにアップロードします。



File: gnus-ja.info, Node: Summary Buffer, Next: Article Buffer, Prev: Group Buffer, Up: Top

概略バッファー
**************

概略バッファー (summary buffer) ではそれぞれの記事が一行で表示されます。
その中を動き回り、記事を読み、投稿し、返答をすることができます。

概略バッファーに移る一番普通の方法は、グループバッファーでグループを選
択することです (*Note Selecting a Group::)。

好きなだけたくさんの概略バッファーを開いておくことができます。

概略モードのツールバーをカスタマイズすることができます。`M-x
customize-apropos RET gnus-summary-tool-bar' を試してみてください。この
機能を利用できるのは Emacs だけですが。

`v' キーはユーザー用に予約されています。そのまま何かのコマンドに割り当
てても構いませんが、接頭キーとして使う方が良いでしょう。例です:

     ;; 副スレッドのスコアを下げる。
     (define-key gnus-summary-mode-map (kbd "v -") "LrS")

* Menu:

* Summary Buffer Format::       概略バッファーの外観を決定する
* Summary Maneuvering::         概略バッファーを動き回る
* Choosing Articles::           記事を読む
* Paging the Article::          読んでいる記事をスクロールする
* Reply Followup and Post::     記事を投稿する
* Delayed Articles::            記事を後で送る
* Marking Articles::            記事に既読や期限切れ消去可能等の印を付ける
* Limiting::                    概略バッファーに制限を加えることができる
* Threading::                   スレッドがどのように作られるか
* Sorting the Summary Buffer::  スレッドと記事がどのように並びかえられるか
* Asynchronous Fetching::       Gnus は記事を先に取得することができる
* Article Caching::             キャッシュに記事を貯めておける
* Persistent Articles::         記事を期限切れ消去しなくさせる
* Sticky Articles::             再利用しない記事バッファー
* Article Backlog::             すでに読んだ記事を残しておく
* Saving Articles::             記事の保存をカスタマイズする方法
* Decoding Articles::           Gnus は一連の (uu)encode された記事を扱える
* Article Treatment::           記事バッファーはお望みどおりに目茶苦茶にできる
* MIME Commands::               記事の MIME のあれこれを操作する
* Charsets::                    文字セットのこと
* Article Commands::            記事バッファーでいろいろなことをする
* Summary Sorting::             いろいろな方法で概略バッファーを並べ替える
* Finding the Parent::          子記事が探せないって? 親記事を取得しなさい
* Alternative Approaches::      ディフォルトではない概略を使って読む
* Tree Display::                もっと視覚的なスレッドの表示
* Mail Group Commands::         いくつかの命令はメールグループだけで使うことができる
* Various Summary Stuff::       他のどの章にも納まらなかったもの
* Exiting the Summary Buffer::  グループバッファーに戻る、または現在のグループを再び選択する
* Crosspost Handling::          クロスポストされた記事がどのように扱われるか
* Duplicate Suppression::       クロスポストの扱いに失敗したときの代替手段
* Security::                    暗号のデコードと検証
* Mailing List::                メーリングリストマイナーモード



File: gnus-ja.info, Node: Summary Buffer Format, Next: Summary Maneuvering, Prev: Summary Buffer, Up: Summary Buffer

概略バッファーの様式
====================

* Menu:

* Summary Buffer Lines::        概略バッファーがどのように見えるべきかを指定できる
* To From Newsgroups::          自分自身の名前を表示しない方法
* Summary Buffer Mode Line::    モード行の見え方を決められる
* Summary Highlighting::        概略バッファーをきれいで素敵にする

Gnus は変数 `gnus-extract-address-components' の値を `From' ヘッダーの
名前とアドレスの部分を抽出するための関数として使います。すでに定義され
ている関数が二つ存在します: ディフォルトは
`gnus-extract-address-components' で、とても簡単に割り切った解決法です
が非常に速く動作します。`mail-extract-address-components' は良く動作し
ますが遅いです。ディフォルトの関数は 5% の割合で間違った答を返します。
もしこれに我慢ならないのであれば、代わりに他の関数を使ってください:

     (setq gnus-extract-address-components
           'mail-extract-address-components)

`gnus-summary-same-subject' は今読んでいる記事が、その前の記事と同じ表
題 (subject) であることを示す文字列です。この文字列は、それを要求する書
法仕様で使われます。ディフォルトでは `""' です。



File: gnus-ja.info, Node: Summary Buffer Lines, Next: To From Newsgroups, Prev: Summary Buffer Format, Up: Summary Buffer Format

概略バッファーの行
------------------

変数 `gnus-summary-line-format' の値を変えることによって、概略バッファー
の行の様式 (format) を変更することができます。いくつかの拡張 (*Note
Formatting Variables::) とともに、普通の `format' 文字列と同じように動
作します。

行には常にコロンかポイント位置のマーカーが存在していなければなりません。
操作した後に、カーソルはいつもコロンかポイント位置のマーカーの場所に移
動します。(もちろん、この動作を変えることができないとしたら Gnus にはあ
るまじきことです。関数 `gnus-goto-colon' を、あなたが好きなカーソルの動
きになるように、新たに書けば良いのです。) *Note Positioning Point::.

ディフォルトの文字列は `%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n' です。

以下の様式指示文字と拡張様式指示を使うことができます:

`N'
     記事数。
`S'
     表題の文字列。`gnus-list-identifiers' の設定によってメーリングリス
     トの標識が削除されます。*Note Article Hiding::.
`s'
     スレッド (thread) の元記事であるときか直前の記事が違う表題のときは
     その表題で、それ以外は `gnus-summary-same-subject'。
     (`gnus-summary-same-subject' はディフォルトで `""'。)
`F'
     完全な `From' 欄。
`n'
     名前 (`From' 欄より)。
`f'
     名前、`To' 欄の内容、または `Newsgroups' 欄の内容のどれかです
     (*Note To From Newsgroups::)。
`a'
     名前 (`From' 欄より)。これと `n' との違いは、これは変数
     `gnus-extract-address-components' で指定されている関数を使って名前
     を取得することです。この方が遅いですが、おそらくより完全に近いでしょ
     う。
`A'
     名前 (`From' 欄より)。これは `a' と同じように動作します。
`L'
     記事の行数。
`c'
     記事の文字数。この名前指定子は (nnfolder のような) いくつかの選択
     方法をサポートしません。
`k'
     整形された記事の文字数; 例えば `1.2k' や `0.4M'。
`I'
     スレッドのレベルによる字下げ (*Note Customizing Threading::)。
`B'
     複雑な trn 様式のスレッド木 (tree)。どのような応答が行なわれたかの
     記録を表示します。スレッドはこのように描かれるでしょう:

          >
          +->
          | +->
          | | \->
          | |   \->
          | \->
          +->
          \->

     以下のオプションで見栄えをカスタマイズすることができます。ディフォ
     ルトの ASCII 文字を線描画用の図案で置き換えることによって、スレッ
     ド表示を実に巧妙に見せることができることに気付いてください。

     `gnus-sum-thread-tree-root'
          スレッドの根 (root) に使われます。`nil' だったら、代わりに表
          題を使います。ディフォルトは `> ' です。

     `gnus-sum-thread-tree-false-root'
          スレッドのにせの根に使われます (*Note Loose Threads::)。
          `nil' だったら、代わりに表題を使います。ディフォルトは `> '
          です。

     `gnus-sum-thread-tree-single-indent'
          単一のメッセージのスレッドに使われます。`nil' だったら、代わ
          りに表題を使います。ディフォルトは `' です。

     `gnus-sum-thread-tree-vertical'
          縦線の描画に使われます。ディフォルトは `| ' です。

     `gnus-sum-thread-tree-indent'
          行下げ (indenting) に使われます。ディフォルトは ` ' です。

     `gnus-sum-thread-tree-leaf-with-other'
          兄弟がいる葉っぱに使われます。ディフォルトは `+-> ' です。

     `gnus-sum-thread-tree-single-leaf'
          兄弟がいない葉っぱに使われます。ディフォルトは `\-> ' です。

`T'
     記事が元記事であれば何も表示せず、そうでない場合はたくさんの空白で
     す (それより後のものをすべて画面の外に追い出してしまいます)。
`['
     開き括弧。普通は `[' ですが、養子記事には `<' にすることができます
     (*Note Customizing Threading::)。
`]'
     閉じ括弧。普通は `]' ですが、養子記事には `>' にすることができます。
`>'
     それぞれのスレッドのレベルに対して一つの空白。
`<'
     (20 - スレッドレベル) 個の空白。
`U'
     未読。*Note Read Articles::.

`R'
     この紛らわしい名前指定子は「第二の印」(the secondary mark) です。
     この印は記事がすでに返答済みのものか、キャッシュされたものか、ある
     いは保存されたものかを表します。*Note Other Marks::.

`i'
     数値としてのスコア (*Note Scoring::)。
`z'
     これは、zcore でディフォルトのレベルよりも上であれば `+' で、ディ
     フォルトのレベルよりも下であれば `-' です。
     `gnus-summary-default-score' との差が `gnus-summary-zcore-fuzz' よ
     りも小さいと、この仕様は使われません。
`V'
     スレッド全体のスコア。
`x'
     `Xref'.
`D'
     `Date'.
`d'
     `DD-MM' 様式による `Date'。
`o'
     YYYYMMDD`T'HHMMSS 様式による `Date'。
`M'
     `Message-ID'.
`r'
     `References'.
`t'
     現在の副スレッドの記事の数。この仕様を使うと概略バッファーの生成が
     幾分遅くなります。
`e'
     記事に子記事があると、`=' (`gnus-not-empty-thread-mark') が表示さ
     れます。
`P'
     行数。
`O'
     ダウンロードの印。
`*'
     カーソルを (最初のコロンの後ろの代わりに) 置く場所。
`&user-date;'
     経過時間の様式。いろいろな様式が `gnus-user-date-format-alist' で
     定義されています。
`u'
     利用者定義指定子。フォーマット文字列の中の次の文字は英字でなければ
     なりません。これにより Gnus は関数 `gnus-user-format-function-'X
     を呼び出しますが、ここで X は `%u' の次の文字です。関数には現在の
     記事のヘッダーが引数として渡されます。関数は文字列を返さなければな
     りません。それは他の概略指定と同様に概略に挿入されます。

`%(' と `%)' の間にあるテキストは、そこにマウスがあるときに
`gnus-mouse-face' でハイライトされます。そういう領域は一つだけです。

`%U' (状態), `%R' (返答済み), `%z' (zcore) の扱いには気を付ける必要があ
ります。効率のために、Gnus はこれらの文字がどの桁に現れるかを計算し、
『ハード・コード』します。これは、可変長の仕様の後では、これらは意味を
持たないということです。まぁ、さすがに逮捕はされないでしょうが、概略バッ
ファーは変になります。それでも十分悲しいでしょうけど。

賢い選択はこれらの指定をできるだけ左に持ってくることです。(でも、そうい
うことはすべてに当てはまるのではないでしょうか。閑話休題。)

この制限は将来の版では無くなるかもしれません。



File: gnus-ja.info, Node: To From Newsgroups, Next: Summary Buffer Mode Line, Prev: Summary Buffer Lines, Up: Summary Buffer Format

To From Newsgroups
------------------

いくつかのグループ (特にアーカイブグループ) では `From' ヘッダーはあま
り興味を引きません。そこのすべての記事はあなたによって書かれたものです
から。代わりに、`To' や `Newsgroups' ヘッダーの情報を表示するためには、
三つのことを決める必要があります: どの情報を集めるか, どこに表示するか,
いつ表示するか。

  1. 追加のヘッダーの情報は `gnus-extra-headers' により制御されます。こ
     れはヘッダーのシンボルのリストです。例えば:

          (setq gnus-extra-headers
                '(To Newsgroups X-Newsreader))

     これによって Gnus はこれらの三つのヘッダーを取得しようとし、後の容
     易な取得のためにヘッダー構造に保存します。

  2. これらの追加のヘッダーの値は `gnus-extra-function' 関数を通じて取
     得することができます。これは `X-Newsreader' ヘッダーを使う書式行の
     仕様です:

          "%~(form (gnus-extra-header 'X-Newsreader))@"

  3. `gnus-ignored-from-addresses' 変数はいつ `%f' 概略行仕様
     が `To', `Newsreader' や `From' ヘッダーを返せば良いかを
     決めます。この正規表現が `From' ヘッダーの内容と合致すると、
     `To' や `Newsreader' ヘッダーの値が代わりに使用されます。

     それらの `From' フィールドが入れ替わっている記事と、普通の記事を区
     別するために、概略行の `To' または `Newsgroups' ヘッダーに、ある文
     字列が前置されます。その文字列はディフォルトで、`To' には `-> ' が、
     `Newsgroups' には `=> ' が使われますが、`gnus-summary-to-prefix'
     と `gnus-summary-newsgroup-prefix' によって、それらの文字列をカス
     タマイズすることができます。

関連する変数は `nnmail-extra-headers' で、overview (NOV) ファイルを作る
際にいつ追加のヘッダーを含めるかを制御します。古い overview ファイルが
ある場合は、この変数を変更した後にサーバーバッファーに `^' で入って適切
なメールサーバー (例えば nnml) で `g' を押し、再生成する必要があります。

さらに `gnus-summary-line-format' 変数の `%n' 仕様を `%f' 仕様に変更す
ることによってデータを表示するように、Gnus に指示する必要があります。

要約すると、普通は以下のようなものを `~/.gnus.el' に置くことになります:

     (setq gnus-extra-headers
           '(To Newsgroups))
     (setq nnmail-extra-headers gnus-extra-headers)
     (setq gnus-summary-line-format
           "%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n")
     (setq gnus-ignored-from-addresses
           "Your Name Here")

(上記の値は Gnus のディフォルト値です。あなたの役に立つように変えてくだ
さい。)

ニュース管理人、またはニュース管理人を説得してサポートの追加をしてもら
おうと思っている利用者のみなさんへのご注意:

NOV ファイルの生成を制御できるメールグループでは、上記のことはたいてい
の場合役立ちます。しかし、管理人を説得して (特に INN の普通の実装におい
て) 以下のものを `overview.fmt' ファイルの最後に追加してもうらうことが
できれば、メールグループでの追加ヘッダーのようにそれを使うことができま
す。

     Newsgroups:full



File: gnus-ja.info, Node: Summary Buffer Mode Line, Next: Summary Highlighting, Prev: To From Newsgroups, Up: Summary Buffer Format

概略バッファーのモード行
------------------------

概略のモード行の様式も変更することができます (*Note Mode Line
Formatting::)。`gnus-summary-mode-line-format' を何でも好きなものに設定
してください。ディフォルトは `Gnus: %%b [%A] %Z' です。

以下はあなたが遊ぶことのできる要素たちです:

`G'
     グループ名。
`p'
     接頭語を取り除いた名前。
`A'
     現在の記事番号。
`z'
     現在の記事スコア。
`V'
     Gnus バージョン。
`U'
     そのグループでの未読記事の数。
`e'
     概略バッファーに表示されていない未読記事の数。
`Z'
     未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記
     事がある場合の `<%U(+%e) more>'、および未読記事のみの場合の `<%U
     more>' のどちらかです。
`g'
     短縮グループ名。例えば、`rec.arts.anime' は `r.a.anime' に短縮され
     ます。
`S'
     現在の記事の表題。
`u'
     利用者定義の仕様 (*Note User-Defined Specs::)。
`s'
     現在のスコアファイルの名前 (*Note Scoring::)。
`d'
     保留記事の数 (*Note Unread Articles::)。
`t'
     可視印付き記事の数 (*Note Unread Articles::)。
`r'
     その概略バッファーで記事を読んだ結果、既読の印が付いた記事の数。
`E'
     スコアファイルによって抹消された記事の数。



File: gnus-ja.info, Node: Summary Highlighting, Prev: Summary Buffer Mode Line, Up: Summary Buffer Format

概略のハイライト
----------------

`gnus-visual-mark-article-hook'
     このフックは記事を選択した後に実行されます。これは何らかの方法で記
     事をハイライトするように意図されています。`gnus-visual' が `nil'
     だったら実行されません。

`gnus-summary-update-hook'
     このフックは概略行が変化したときに呼ばれます。
     `gnus-visual' が `nil' だったら実行されません。

`gnus-summary-selected-face'
     これは概略バッファーでの現在の記事をハイライトするために使われる
     フェース (もしくは、ある人たちが「フォント」と呼ぶようなもの) です。

`gnus-summary-highlight'
     概略行はこの変数にしたがってハイライトされます。この変数は要素が
     `(FORM . FACE)' の形式のリストです。例えば、印付きの記事を斜体、高
     いスコアの記事を太字にしたければ、この変数を次のように設定すること
     ができます。

          (((eq mark gnus-ticked-mark) . italic)
           ((> score default) . bold))

     ご想像のとおり、FORM が `nil' でない値を返すと、FACE がその行に適
     用されます。



File: gnus-ja.info, Node: Summary Maneuvering, Next: Choosing Articles, Prev: Summary Buffer Format, Up: Summary Buffer

概略間の移動
============

すべての直接移動命令は数値接頭引数を受け付け、かなり期待どおりに動作す
るでしょう。

これらの命令はどれも記事を選択しません。

`G M-n'
`M-n'
     概略行の次の未読記事に移ります
     (`gnus-summary-next-unread-subject')。

`G M-p'
`M-p'
     概略行の前の未読記事に移ります
     (`gnus-summary-prev-unread-subject')。

`G g'
     記事番号を尋ね、その記事を表示せずに、その概略行に行きます
     (`gnus-summary-goto-subject')。

Gnus が次のグループ移動することを確認するためにキー入力を求めた場合、
`C-n' キーと `C-p' キーを使うことによって、実際にグループバッファーに戻
らなくても、次に読むグループを探すことができます。

概略の移動に関連した変数:

`gnus-auto-select-next'
     移動命令の一つ (`n' のような) を発したときに現在の記事の後に未読記
     事が無いと、Gnus は次のグループに移動することをうながします。この
     変数が `t' で次のグループが空っぽだったら、Gnus は概略モードを抜け
     てグループバッファーに戻ります。この変数が `t' でも `nil' でもなけ
     れば、Gnus はさらに次の未読記事があるグループを選択します。特別な
     場合として、この変数が `quietly' だったら、Gnus は確認をせずに次の
     グループを選択します。この変数が `almost-quietly' だった場合は、グ
     ループの一番最後の記事を読んでいたときに限って同じことが起こります。
     最後に、もしこの変数が `slightly-quietly' だったら、`Z n' 命令は確
     認をせずに次のグループに移ります。*Note Group Levels:: も参照して
     ください。

`gnus-auto-select-same'
     `nil' でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
     しようとします。(「同じ」はここでは「大体同じ」という意味かもしれ
     ません。詳細は `gnus-summary-gather-subject-limit' を見てください
     (*Note Customizing Threading::)。) 同じ表題の記事が無いときは、最
     初の未読記事に移動します。

     この変数は、スレッド表示を行なっているときはあまり役に立たないでしょ
     う。

`gnus-summary-check-current'
     これが `nil' ではない場合、すべての『未読』移動命令は、現在の記事
     が未読だったら次 (もしくは前) の記事に移動しません。代わりに、それ
     らは現在の記事を選びます。

`gnus-auto-center-summary'
     `nil' でないと、Gnus は概略バッファーでのポイントを常に真中に保ち
     ます。これをすると、とてもこぎれいになりますが、遅いネットワークに
     接続していたり、この Emacs らしくない流儀が好きになれないのであれ
     ば、この変数を `nil' にすることによって、普通の Emacs のスクロール
     にすることができます。これは概略バッファーの水平方向でポイントが真
     ん中になるようにする操作 (horizontal re-centering) も禁止してしま
     うので、非常に長いスレッドを読むときは不便かもしれません。

     この変数は数値でも構いません。その場合は、ウィンドウの先頭からその
     数の行だけ下がった位置に常にポイントがあるように制御されます。



File: gnus-ja.info, Node: Choosing Articles, Next: Paging the Article, Prev: Summary Maneuvering, Up: Summary Buffer

記事の選択
==========

* Menu:

* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数



File: gnus-ja.info, Node: Choosing Commands, Next: Choosing Variables, Prev: Choosing Articles, Up: Choosing Articles

選択命令
--------

以下の移動コマンドはどれも数値接頭引数を受け付けません。それらはすべて、
記事を選択して表示します。

新しい記事を取り込んだり、グループを再表示したいときは *Note Exiting
the Summary Buffer:: を参照してください。

`SPACE'
     現在の記事、またはそれが既読だった場合は次の未読記事を選択します
     (`gnus-summary-next-page')。

     すでに記事ウィンドウを開いているときに再び `SPACE' を押すと、その記
     事はスクロールされます。これによって、ニュースグループ全体
     を `SPACE' だけで便利に通読することができます。
     *Note Paging the Article::.

`G n'
`n'
     次の未読記事に移動します (`gnus-summary-next-unread-article')。

`G p'
`p'
     前の未読記事に移動します (`gnus-summary-prev-unread-article')。

`G N'
`N'
     次の記事に移動します (`gnus-summary-next-article')。

`G P'
`P'
     前の記事に移動します (`gnus-summary-prev-article')。

`G C-n'
     同じ表題の次の記事に移動します (`gnus-summary-next-same-subject')。

`G C-p'
     同じ表題の前の記事に移動します (`gnus-summary-prev-same-subject')。

`G f'
`.'
     最初の未読記事に移動します (`gnus-summary-first-unread-article')。

`G b'
`,'
     最高スコアの未読記事に移動します
     (`gnus-summary-best-unread-article')。接頭引数が与えられると、ディ
     フォルトのスコアより大きいスコアを持つ最初の未読記事に移動します。

`G l'
`l'
     直前に読んだ記事に移動します (`gnus-summary-goto-last-article')。

`G o'
     概略の履歴 (history) から最後の記事を一つ取り出して選択します
     (`gnus-summary-pop-article')。この命令が上の命令と違うのは、`l' が
     最後の二つの記事の間を移動するだけなのに対して、これは好きなだけ前
     の記事を履歴から選び出すことができる点です。これに多少関係すること
     について、*Note Article Backlog:: を参照してください (これらの命令
     をたくさん使うのであれば)。

`G j'
`j'
     記事番号か `Message-ID' を尋ね、それからその記事に行きます
     (`gnus-summary-goto-article')。



File: gnus-ja.info, Node: Choosing Variables, Prev: Choosing Commands, Up: Choosing Articles

選ぶための変数
--------------

記事の移動と選択に関連するいくつかの変数:

`gnus-auto-extend-newsgroup'
     この変数が `nil' でないと、すべての移動命令は、記事が概略バッファー
     に表示されていない場合でも、前 (もしくは次) の記事に移動しようとし
     ます。その際 Gnus はサーバーから記事を取得して、記事バッファーに表
     示します。

`gnus-select-article-hook'
     このフックは記事が選択されたときに常に呼ばれます。ディフォルトは
     `nil' です。講読するそれぞれの記事をエージェントに保存させたい場合
     は、このフックに `gnus-agent-fetch-selected-article' を追加すれば
     良いでしょう。

`gnus-mark-article-hook'
     このフックは記事が選択されたときに常に呼ばれます。これは記事に既読
     の印を付けるために使われることを意図しています。ディフォルト値は
     `gnus-summary-mark-read-and-unread-as-read' で、ほとんどすべての読
     んだ記事の印を `gnus-read-mark' に変更します。この関数に影響されな
     い記事は、可視、保留、期限切れ消去可能記事だけです。未読記事に既読
     の印を付けたいだけであれば、代わりに
     `gnus-summary-mark-unread-as-read' を使うことができます。
     `gnus-low-score-mark' や `gnus-del-mark' (など) の印はそのまま残し
     ます。



File: gnus-ja.info, Node: Paging the Article, Next: Reply Followup and Post, Prev: Choosing Articles, Up: Summary Buffer

記事のスクロール
================

`SPACE'
     `SPACE' を押すと、現在の記事を一ページ先にスクロールします。記事の
     最後に行き着いた場合は次の記事を選択します
     (`gnus-summary-next-page')。

     `gnus-article-skip-boring' が非-`nil' で、かつ記事の残りに引用と署
     名しか無い場合、それはスキップされ、代わりに次の記事が表示されます。
     `gnus-article-boring-faces' で、つまらないと思うものをカスタマイズ
     することができます。どんなにうんざりするものでも、`C-M-v' を使うこ
     とによって、手動で記事のページを見ることはできます。

`DEL'
     現在の記事を一ページ前にスクロールします
     (`gnus-summary-prev-page')。

`RET'
     現在の記事を一行先にスクロールします (`gnus-summary-scroll-up')。

`M-RET'
     現在の記事を一行後ろへスクロールします
     (`gnus-summary-scroll-down')。

`A g'
`g'
     現在の記事を (再) 取得します。もし接頭引数が与えられると、現在の記
     事を取得しますが、記事をトリートメントする関数は実行しません。これ
     は、サーバーから来たままの『生の』記事をもたらします。

     接頭引数を与えると、手動で文字セットの操作を行なうことができます。
     `C-u 0 g cn-gb-2312 RET' により、メッセージはあたかも
     `cn-gb-2312' 文字セットでエンコードされたかのようにデコードされま
     す。以下のような設定を用意しておくと、`C-u 1 g' で同じ効果を得るこ
     とができます。

          (setq gnus-summary-show-article-charset-alist
                '((1 . cn-gb-2312)
                  (2 . big5)))

`A <'
`<'
     記事の最初までスクロールします。
     (`gnus-summary-beginning-of-article')。

`A >'
`>'
     記事の最後までスクロールします (`gnus-summary-end-of-article')。

`A s'
`s'
     記事バッファーでインクリメンタルサーチ (isearch) を行ないます
     (`gnus-summary-isearch-article')。

`h'
     記事バッファーを選択します (`gnus-summary-select-article-buffer')。



File: gnus-ja.info, Node: Reply Followup and Post, Next: Delayed Articles, Prev: Paging the Article, Up: Summary Buffer

返答、フォローアップ、投稿
==========================

* Menu:

* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::



File: gnus-ja.info, Node: Summary Mail Commands, Next: Summary Post Commands, Prev: Reply Followup and Post, Up: Reply Followup and Post

概略でのメールの命令
--------------------

メールメッセージを作成するための命令:

`S r'
`r'
     現在の記事を書いた人に返答のメールを送ります
     (`gnus-summary-reply')。

`S R'
`R'
     現在の記事を書いた人に、元記事を含んだ返答のメールを出します
     (`gnus-summary-reply-with-original')。この命令はプロセス/接頭引数
     の習慣を使います。

`S w'
     現在の記事を書いた人に対して、広い返答 (wide reply) をします
     (`gnus-summary-wide-reply')。「広い返答」とはヘッダーの `To',
     `From', (もしくは `Reply-to') と `Cc') のすべての人に返答をするこ
     とです。`Mail-Followup-To' があれば、代わりにそれが使われます。

`S W'
     現在の記事に元記事を含んだ広い返答のメールを送ります
     (`gnus-summary-wide-reply-with-original')。この命令はプロセス/接頭
     引数の習慣を使います。

`S v'
     現在の記事を書いた人に対して、非常に広い返答 (very wide reply) を
     します (`gnus-summary-very-wide-reply')。「非常に広い返答」とは、
     プロセス/接頭引数で指定されたすべての記事のヘッダーの `To',
     `From', (もしくは `Reply-to') と `Cc') のすべての人に返答をするこ
     とです。この命令はプロセス/接頭引数の習慣を使います。

`S V'
     現在の記事に元記事を含んだ非常に広い返答のメールを送ります
     (`gnus-summary-very-wide-reply-with-original')。この命令はプロセス
     /接頭引数の習慣を使います。

`S B r'
     現在の記事を書いた人に対して返答をしますが `Reply-To' フィールドは
     無視します (`gnus-summary-reply-broken-reply-to')。メーリングリス
     トがそのリストを指す `Reply-To' を過って設定するためにこれが必要な
     のであれば、おそらくあなたは代わりに `broken-reply-to' グループパ
     ラメーターを設定する必要があります。そうすれば、ものごとは正しく働
     くようになるでしょう。*Note Group Parameters::.

`S B R'
     現在の記事を書いた人に対して元記事を含んだ返答をしますが
     `Reply-To' フィールドは無視します
     (`gnus-summary-reply-broken-reply-to-with-original')。

`S o m'
`C-c C-f'
     誰か他の人に現在の記事を転送します (`gnus-summary-mail-forward')。
     接頭引数が与えられない場合、メッセージは
     `message-forward-as-mime' および `message-forward-show-mml' の値に
     従ったやり方で転送されます。接頭引数が 1 だったら、デコードされた
     メッセージが直接埋め込まれた転送用のバッファーが作られます。2 だっ
     たら rfc822 形式の MIME パートが挿入されます。この場合、元のメッセー
     ジはデコードされません。3 ではデコードされた rfc822 形式の MIME パー
     トが挿入されます (実際に送信する際に再びエンコードされます)。接頭
     引数 4 では、1 の場合と同じ動作になります。接頭引数がこれら以外の
     場合には、`message-forward-as-mime' の値を一時的に反転して、接頭引
     数が与えられなかった場合と同じ動作を行ないます。ディフォルトでは、
     デコードされたメッセージが rfc822 形式の MIME パートとして生成され
     ます。

`S m'
`m'
     メールを作成します (`gnus-summary-mail-other-window')。ディフォル
     トでは現在のグループの投稿様式 (posting style) を使います。接頭引
     数が与えられると、それは使いません。もし接頭引数が 1 だったら、ど
     のグループの投稿様式を使うかを尋ねます。

`S i'
`i'
     ニュースを作成します (`gnus-summary-news-other-window')。ディフォ
     ルトでは現在のグループに投稿します。接頭引数が与えられると、現在の
     グループ名は使われません。もし接頭引数が 1 だったら、どのグループ
     に投稿するかを尋ねます。

     この関数は、たとえメールグループで使われたとしても、実際にはニュー
     スの様式を用意します。これは、メッセージを実際にはネットワーク経由
     で送らずに、メールグループに「投稿」するのに便利です; それらは当の
     グループに単に直接セーブされます。対応するバックエンドが投稿のため
     のメソッド (request-post method) を持っていなければなりませんが。

`S D b'
     メールを送ったのに、何らかの理由 (アドレスの間違い、転送の不調) で
     戻ってきたときに、この命令を使って戻ってきたメールをもう一回送るこ
     とができます (`gnus-summary-resend-bonced-mail')。メールバッファー
     にそのメールが現れて、そこでもう一度メールを送る前にヘッダーを編集
     することができます。この命令に接頭引数を与えると、戻ってきたメール
     が何か他のメールへの返答であった場合に、Gnus はそのメールを取得し
     て、それのヘッダーの精密調査ができるように画面に表示しようとします。
     ま、これはとてもよく失敗しますけど。

`S D r'
     上の命令と混同しないでください。`gnus-summary-resend-message' は現
     在のメッセージを送る宛先のアドレスの入力を促して、その場所にメール
     を送ります。メッセージのヘッダーは変更されません--しかし
     `Resent-To', `Resent-From' などの、たくさんのヘッダーが付け加えま
     す。これは、(おそらく) あなた自身を `To' 欄に書いた本人にもメール
     を送ってしまうということです。これは混乱を招くでしょう。ですから当
     然、あなたが本当に邪悪な人でなければ、これは使わないでしょう。

     この命令は主に、あなたがいくつかのメールアカウントを持っていて、自
     分自身の違ったアカウントにメールを転送したいときに用いられます。
     (もしあなたが `root' であり、`postmaster' でもあり、`root' 宛てに
     `postmaster' へのメールを受け取った場合は、それを `postmaster' に
     も再送する必要があるかもしれません。秩序がなければなりません!
     (Ordnung muss sein!))

     この命令はプロセス/接頭引数の習慣に従います (*Note
     Process/Prefix::)。

`S D e'
     一つ前のコマンドに似ていますが、再送する前にあたかも新しいメッセー
     ジのように編集することができます。

`S O m'
     現在の一連の記事 (*Note Decoding Articles::) の要約を作り、メール
     でその結果を送ります (`gnus-uu-digest-mail-forward')。この命令はプ
     ロセス/接頭引数の習慣に従います (*Note Process/Prefix::)。

`S M-c'
     現在の記事の書き手に、過剰なクロスポストへの苦情のメールを送ります
     (`gnus-summary-mail-crosspost-complaint')。

     この命令は、現在 Usenet に横行しているクロスポストの世界的流行に対
     して反撃を行なう手段として提供されています。これは変数
     `gnus-crosspost-complaint' を序文にして返答を作成します。この命令
     はプロセス/接頭引数の習慣 (*Note Process/Prefix::) に従い、それぞ
     れのメールを送る前に送信するかどうかの確認をします。

また *Note ヘッダー命令: (message-ja)Header Commands, にさらなる情報が
あります。



File: gnus-ja.info, Node: Summary Post Commands, Next: Summary Message Commands, Prev: Summary Mail Commands, Up: Reply Followup and Post

概略の投稿命令
--------------

ニュースの記事を投稿するための命令:

`S p'
`a'
     投稿するための記事を作成します (`gnus-summary-post-news')。ディフォ
     ルトでは現在のグループに投稿します。接頭引数が与えられると、現在の
     グループ名は使われません。もし接頭引数が 1 だったら、代わりに別の
     どのグループに投稿するかを尋ねます。

`S f'
`f'
     現在の記事のフォローアップを投稿します (`gnus-summary-followup')。

`S F'
`F'
     元記事を取り込んで、現在の記事にフォローアップをします
     (`gnus-summary-followup-with-original')。この命令はプロセス/接頭引
     数の習慣を用います。

`S n'
     メールのメッセージを受け取っていたとしても、現在の記事のフォローアッ
     プをニュースに投稿します (`gnus-summary-followup-to-mail')。この命
     令はプロセス/接頭引数の習慣を用います。

`S N'
     メールのメッセージを受け取っていたとしても、元記事を引用して、現在
     の記事のフォローアップをニュースに投稿します
     (`gnus-summary-followup-to-mail-with-original'). この命令はプロセ
     ス/接頭引数の習慣を用います。

`S o p'
     現在の記事をニュースグループに転送します
     (`gnus-summary-post-forward')。接頭引数が与えられない場合、メッセー
     ジは `message-forward-as-mime' および `message-forward-show-mml'
     の値に従ったやり方で転送されます。接頭引数が 1 だったら、デコード
     されたメッセージが直接埋め込まれた転送用のバッファーが作られます。
     2 だったら rfc822 形式の MIME パートが挿入されます。この場合、元の
     メッセージはデコードされません。3 ではデコードされた rfc822 形式の
     MIME パートが挿入されます (実際に送信する際に再びエンコードされま
     す)。接頭引数 4 では、1 の場合と同じ動作になります。接頭引数がこれ
     ら以外の場合には、`message-forward-as-mime' の値を一時的に反転して、
     接頭引数が与えられなかった場合と同じ動作を行ないます。ディフォルト
     では、デコードされたメッセージが rfc822 形式の MIME パートとして生
     成されます。

`S O p'
     現在の一連の記事を要約して、その結果をニュースグループに送ります
     (`gnus-uu-digest-post-forward')。この命令はプロセス/接頭引数の習慣
     を用います。

`S u'
     ファイルを uuencode して分割し、それらを連続して投稿します
     (`gnus-uu-post-news')。(*Note Uuencoding and Posting::)。

また *Note ヘッダー命令: (message-ja)Header Commands, にさらなる情報が
あります。



File: gnus-ja.info, Node: Summary Message Commands, Next: Canceling and Superseding, Prev: Summary Post Commands, Up: Reply Followup and Post

概略メッセージ命令
------------------

`S y'
     現在の記事を、すでに存在するメッセージ作成バッファーに貼り付けます
     (`gnus-summaryyank-message')。この命令は貼り付けたいメッセージバッ
     ファーの入力を促し、プロセス/接頭引数の習慣を理解します (*Note
     Process/Prefix::)。



File: gnus-ja.info, Node: Canceling and Superseding, Prev: Summary Message Commands, Up: Reply Followup and Post

記事を取り消す
--------------

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなけれ
ばなぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニュースの投稿は取り消
すことができます。

取り消したい記事を見つけてください (取り消すことができるのは自分の記事
だけです。変なことは試さないでください)。そして `C' か `S c' を押してく
ださい (`gnus-summary-cancel-article')。あなたの記事が取り消されます--
世界中の機械があなたの記事を取り消します。この命令はプロセス/接頭引数の
習慣を用います (*Note Process/Prefix::)。

しかし注意して欲しいのは、すべてのサイトが取り消しを扱っているわけでは
ないことです。ですから、たいていのサイトが問題の記事を取り消しても、あ
ちこちであなたの記事は生き残るかもしれません。

Gnus は取り消すときに『現在』の選択方法を使います。標準の投稿方法を使い
たいのであれば、文字接頭引数 `a' を使ってください (*Note Symbolic
Prefixes::)。

Gnus は `Cancel-Lock' ヘッダー (*Note ニュースを取り消す:
(message-ja)Canceling News.) を使って、あなただけがあなたのメッセージを
キャンセルできるようにします。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、「代替」
("superseding") 記事を投稿して元記事を置き換えることができます。

元記事のところへ移動して、`S s' を押してください
(`gnus-summary-supersede-article')。それを普通に送信する前に、記事を好
きなように編集することができます。

代替に関しても、取り消しと同じことが当てはまります。こちらの方がもっと
よく当てはまるかもしれません: いくつかのサイトは代替を受け付けません。
これらのサイトでは、ほとんど同じ記事を二回投稿したようになってしまいま
す。

もしさっき記事を投稿したばかりですぐに変更したくなった場合、記事が最初
にあなたのサイトに現れる前に取り消し/代替をするための巧妙な手段がありま
す。まず、投稿バッファー (`*sent ... *' のようになっています) に戻って
ください。そこにはあなたがちょうど投稿した記事があり、すべてのヘッダー
がそのままあります。`Message-ID' ヘッダーを `Cancel' もしくは
`Supersedes' に変更してください。そして、いつもやっているように単に
`C-c C-c' を押して記事を送信してください。前の記事は取り消されるか置き
換えられるでしょう。

ちょっと覚えておいてください: 'supersede' (代替) という語の中に 'c' は
無いということを。



File: gnus-ja.info, Node: Delayed Articles, Next: Marking Articles, Prev: Reply Followup and Post, Up: Summary Buffer

遅延記事
========

ときとして、あなたはメッセージの送信を先延ばしにしたいと思うことはありま
せんか。例えば、あなたが大切なだれかの誕生日を思い出すために、ちょうどそ
の日に届くメッセージを用意したいと思ったとしましょう。
`gnus-delay' パッケージはこれにうってつけです。設定は簡単です:

     (gnus-delay-initialize)

普段はメッセージを送信するのに Message モードで `C-c C-c' コマンドを使
いますよね。先延ばしにするには、代わりに `C-c C-j'
(`gnus-delay-article') を使ってください。そうすると、どのくらい遅らせる
かを尋ねてきます。可能な返事は次の通りです:

   * 期間。整数と一つの文字で指定します。例えば `42d' は 42 日遅らせるこ
     とを意味します。使うことができる文字は `m' (分)、`h' (時)、
     `d' (日), `w' (週), `M' (月) および `Y' (年) です。

   * 日付。`YYYY-MM-DD' のような形式で指定します。メッセージの送信はその
     日の特定の時刻 (ディフォルトは 8 時) まで遅らせられます。
     `gnus-delay-default-hour' も参照してください。

   * 時刻。am/pm を含まない 24 時間制の、`hh:mm' の形式で与えます。送信
     されるのは今日のその時刻ですが、すでにその時刻を過ぎてしまっていた
     場合は翌日のその時刻になります。ですから、朝の 10 時に `11:15' を
     指定した場合は 1時間15分後に送信されることになります。しかし
     `9:20' を指定した場合は翌日の時刻を意味します。

`gnus-delay-article' の動作は、以下の数個の変数に影響されます:

`gnus-delay-default-hour'
     特定の日付を指定した場合に、メッセージがその日の何時に送信されるか
     を与えます。可能な値は 0 から 23 までの整数です。

`gnus-delay-default-delay'
     ディフォルトの遅延を与える文字列です。前述のどんな形式でも可能です。

`gnus-delay-group'
     遅延記事は、ドラフトサーバーのこのグループに期限が来るまで保管され
     ます。たぶんあなたはこれを変更する必要は無いでしょう。ディフォルト
     の値は `"delayed"' です。

`gnus-delay-header'
     それぞれの記事が送信される日時はヘッダーに記録されます。この変数は
     ヘッダー名の文字列です。たぶんあなたはこれを変更する必要は無いでしょ
     う。ディフォルトの値は `"X-Gnus-Delayed"' です。

送信の先延ばしはこんなふうに行なわれます: `gnus-delay-article' コマンド
で、あなたはどのくらい遅らせるかを指定します。Gnus はメッセージを送信す
る日時を計算して `X-Gnus-Delayed' ヘッダーに記録し、そのメッセージを
`nndraft:delayed' グループに納めます。

そして、あなたが新着ニュースを取得しようとするときはいつも、Gnus は送信
する期限に達した記事をそのグループで探して、それらを送信します。これに
は関数 `gnus-delay-send-queue' が使われます。ディフォルトではこの関数は
`gnus-get-new-news-hook' に追加されますが、もちろんあなたはこれを変更す
ることができます。おそらくあなたは、ドラフトの送信にデーモンを使いたい
と思うのではないでしょうか? それには、デーモンに関数
`gnus-delay-send-queue' を実行せよ、と言うだけで良いのです。

`gnus-delay-initialize'
     ディフォルトではこの関数は `gnus-delay-send-queue' の
     `gnus-get-new-news-hook' への追加を行ないます。ですが、これは第二
     オプション引数 `no-check' を受け付けます。もしそれが非-`nil' だっ
     たら `gnus-get-new-news-hook' は変更されません。第一オプション引数
     は無視されます。

     例えば `(gnus-delay-initialize nil t)' は何もしないことを意味しま
     す。あなたは遅延記事の送信にデーモンを使いたいのでしょうね。でも、
     それを設定することを忘れないでくださいね。:-)



File: gnus-ja.info, Node: Marking Articles, Next: Limiting, Prev: Delayed Articles, Up: Summary Buffer

記事に印を付ける
================

記事に付けられる印はいくつかあります。

記事の「購読度」(うひょーっ、何てすらばやしい造語だ!) を決定する印があ
ります。英字でない文字が一般に「未読」を意味するのに対して、英字の印は
一般に「既読」を意味します。

加えて、購読度に影響しない印もあります。

これらの印を操作する過剰なくらいの命令があります:

* Menu:

* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方



File: gnus-ja.info, Node: Unread Articles, Next: Read Articles, Prev: Marking Articles, Up: Marking Articles

未読記事
--------

以下の印は何らかの方法で記事に未読の (ような) 印を付けます。

`!'
     可視記事 (ticked) として印を付けます (`gnus-ticked-mark')。

     「可視記事」とは常に可視状態である記事のことです。おもしろいと思う
     記事があった場合や、読むのを先に延ばしたいときや、後で返答をしたい
     ときに、普通は可視印を付けます。しかし、記事は期限切れ消去されるこ
     ともあります (ニュースサーバー上の記事を消去するのはニュースサーバー
     のソフトウェアで、Gnus 自体は可視記事を期限切れ消去しません) ので、
     永遠に記事を保存しておきたい場合は、その記事を永続にする必要があり
     ます (*Note Persistent Articles::)。

`?'
     保留として印を付けます (`gnus-dormant-mark')。

     「保留記事」はフォローアップがあったときにだけ概略バッファーに現れ
     ます。フォローアップが無いときも表示させたいときは、`/ D' 命令を使っ
     てください (*Note Limiting::)。それ以外は (見えるかどうかは別にし
     て)、可視記事 (ticked) と似たようなものです。

`SPACE'
     未読として印を付けます (`gnus-unread-mark')。

     「未読記事」は今までまったく読まれていない記事のことです。



File: gnus-ja.info, Node: Read Articles, Next: Other Marks, Prev: Unread Articles, Up: Marking Articles

既読記事
--------

以下のすべての印は記事に既読の印を付けます。

`r'
     利用者が手動で `d' 命令もしくはそれに類する手段を使って、既読の印
     を付けた記事です (`gnus-del-mark')。

`R'
     実際に読まれた記事 (`gnus-read-mark')。

`O'
     前回のセッションで既読の印を付けて、今は「古く」なってしまった記事。

`K'
     削除された印 (`gnus-killed-mark')。

`X'
     削除ファイルによって削除の印が付いた記事 (`gnus-kill-file-mark')。

`Y'
     低すぎるスコアのために既読の印が付いた記事
     (`gnus-low-score-mark')。

`C'
     キャッチアップによって既読の印が付いた記事 (`gnus-catchup-mark')。

`G'
     取り消された記事 (`gnus-canceled-mark')。

`F'
     SOUP されている記事 (`gnus-souped-mark')。*Note SOUP::.

`Q'
     まばらに参照された記事 (`gnus-sparse-mark')。
     *Note Customizing Threading::.

`M'
     重複抑制により既読の印の付いた記事 (`gnus-duplicate-mark')。
     *Note Duplicate Suppression::.

これらのすべての印は、本当にただ記事が既読として印が付いていることを意
味するだけです。適応スコアリングをしたときには違ったように解釈されます
けれど。

もう一つ、特別な印があります:

`E'
     期限切れ消去可能として印の付いた記事 (`gnus-expirable-mark')。

     記事を「期限切れ消去可能」として印を付ける (もしくは、自動的にその
     ように印を付ける) ことは、普通のグループではあまり意味がありませ
     ん--利用者はニュース記事の期限による削除を制御していません。しかし、
     例えばメールグループでは、「期限切れ消去可能」として印の付いた記事
     は、いつでも Gnus によって削除されることがあります。



File: gnus-ja.info, Node: Other Marks, Next: Setting Marks, Prev: Read Articles, Up: Marking Articles

他の印
------

記事が読まれたかどうかには関係しない印がいくつかあります。

   * 現在の記事にしおりを挟むことができます。あなたは猫のおしっこの習慣に関す
     る長い論文を読んでいて、それを読み終わる前に晩ご飯を食べに家に帰らなけれ
     ばならなかったとしましょう。そんなとき、記事にしおりを挟むことができます。
     次にその記事に出くわすと、Gnus はそのしおりのところへ移動するでしょう。
     *Note Setting Marks::.

   * 返信したかフォローアップした (つまり、答えた) すべての記事には、二
     桁目に `A' の印が付きます (`gnus-replied-mark')。

   * 転送したすべての記事には、二桁目に `F' の印が付きます
     (`gnus-forwarded-mark')。

   * 記事キャッシュに貯められている記事は、二桁目に `*' の印が付きます
     (`gnus-replied-mark')。*Note Article Caching::.

   * (何らかの方法によって; 必ずしも宗教的というわけではなく) 『救済さ
     れた』(原文は saved==保存された) 記事は、二桁目に `S' の印が付きま
     す (`gnus-saved-mark')。

     まだサーバーが利用者に見せていない記事は、二桁目に `N' の印が付き
     ます (`gnus-recent-mark')。たいていのサーバーはこの印をサポートせ
     ず、その場合は単に表示されません。`gnus-unseen-mark' と見比べてく
     ださい。

   * まだ Gnus で読まれたことがない記事は、二桁目に `.' の印が付きます
     (`gnus-unseen-mark')。`gnus-recent-mark' と見比べてください。

   * Gnus エージェント (*Note Agent Basics::) を使っているとき、記事は
     unplugged (ネットワークから切り離されている状態) で見るためにダウ
     ンロードされるかもしれません。`%O' の仕様を使っていると、それらの
     記事にはその仕様に `+' の印が付きます。(変数
     `gnus-downloaded-mark' でどの文字を使うかを制御します。)

   * Gnus エージェント (*Note Agent Basics::) を使っているとき、いくつ
     かの記事はダウンロードされていないかもしれません。Unplugged (ネッ
     トワークから切り離されている状態) ではそのような記事を見ることがで
     きません。`%O' の仕様を使っていると、それらの記事にはその仕様に
     `-' の印が付きます。(変数 `gnus-undownloaded-mark' でどの文字を使
     うかを制御します。)

   * Gnus エージェント (*Note Agent Basics::) はいくつかの記事を自動的
     にダウンロードしますが、自動的にダウンロードされない記事にもダウン
     ロードのための明示的な印を付けることは可能です。そのような明示的に
     印が付けられた記事には、最初の桁に `%' の印が付きます。(変数
     `gnus-downloadable-mark' でどの文字を使うかを制御します。)

   * `%e' の仕様が使われると、スレッドがあるかどうかの印が
     `gnus-not-empty-thread-mark' または `gnus-empty-thread-mark' によっ
     て、三桁目に付きます。

   * 最後に「プロセス印」があります (`gnus-process-mark')。いろいろな種
     類の命令が、プロセス印があるとそれに対して実行されます。例えば `X
     u' (`gnus-uu-decode-uu') は、プロセス印の付いたすべての記事を
     uudecode して表示します。プロセス印の付いた記事は二桁目に `#' があ
     ります。

たいていのこれら『購読度と関係無い』印は、ディフォルトでは二桁目に現れ
ることに気付いたでしょう。では、キャッシュされていて、保存されていて、
返答した記事にプロセス印を付けた場合は、どうなるのでしょう?

たいしたことはありません。優先順位は次のようになっています: プロセス →
キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入って
いて返答されていた場合、キャッシュ印が見えるだけで、返答済み印は見えま
せん。



File: gnus-ja.info, Node: Setting Marks, Next: Generic Marking Commands, Prev: Other Marks, Up: Marking Articles

印を付ける
----------

すべての印を付けるための命令は、数値接頭引数を受け付けます。

`M c'
`M-u'
     現在の記事から、すべての購読度に関する印を消去します
     (`gnus-summary-clear-mark-forward')。要するに、記事に未読の印を付
     けます。

`M t'
`!'
     現在の記事に可視記事の印を付けます
     (`gnus-summary-tick-article-forward')。*Note Article Caching::.

`M ?'
`?'
     現在の記事に保留記事の印を付けます
     (`gnus-summary-mark-as-read-forward')。*Note Article Caching::.

`M d'
`d'
     現在の記事に既読の印を付けます
     (`gnus-summary-mark-as-read-forward')。

`D'
     現在の記事に既読の印を付け、前の行にポイントを移動します
     (`gnus-summary-mark-as-read-backward')。

`M k'
`k'
     現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未
     読記事を選択します (`gnus-summary-kill-same-subject-and-select')。

`M K'
`C-k'
     現在の記事と同じ表題を持つすべての記事を既読として印を付けます
     (`gnus-summary-kill-same-subject')。

`M C'
     すべての未読記事に既読の印を付けます (`gnus-summary-catchup')。

`M C-c'
     グループのすべての記事に--可視記事や保留記事でさえも、既読の印を付
     けます (`gnus-summary-catchup-all')。

`M H'
     現在のグループの、現在位置とそれ以前の記事を既読として印を付けます
     (`gnus-summary-catchup-to-here')。

`M h'
     現在のグループの、現在位置とそれ以降の記事を既読として印を付けます
     (`gnus-summary-catchup-from-here')。

`C-w'
     ポイントとマークの間の記事に既読の印を付けます
     (`gnus-summary-mark-region-as-read')。

`M V k'
     ディフォルトのスコア (もしくは数値接頭引数) よりも低いスコアの記事
     を削除します。

`M e'
`E'
     現在の記事を期限切れ消去可能として印を付けます
     (`gnus-summary-mark-as-expirable')。

`M b'
     現在の記事にしおりを設定します (`gnus-summary-set-bookmark')。

`M B'
     現在の記事のしおりを削除します (`gnus-summary-remobe-bookmark')。

`M V c'
     ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持
     つ記事のすべての印を消去します (`gnus-summary-clar-above')。

`M V u'
     ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持
     つすべての記事に可視印を付けます (`gnus-summary-tick-above')。

`M V m'
     印の入力を促し、ディフォルトのスコア (もしくは数値接頭引数) よりも
     大きなスコアを持つすべての記事にその印を付けます
     (`gnus-summary-mark-above')。

変数 `gnus-summary-goto-unread' は印が付けられた後にどのような動作がな
されるかを決定します。もし `nil' でないと、ポイントは次/前の未読記事に
移動します。もし `nil' であると、ポイントは一行上か下に行くだけです。特
別な場合として、この変数が `never' であると、すべての印を付ける命令と
(`SPACE' のような) 他の命令は次の記事が未読であろうが無かろうが次の記事
に移動します。ディフォルトは `t' です。



File: gnus-ja.info, Node: Generic Marking Commands, Next: Setting Process Marks, Prev: Setting Marks, Up: Marking Articles

Generic Marking Commands
------------------------

記事に可視の印を付ける命令 (`!') に、次の記事に移動してもらいたい人がい
ます。次の未読記事に移動してもらいたい人もいます。さらに、現在の記事に
留まっていてもらいたい人もいるでしょう。そして、前の (未読の) 記事に行っ
て欲しい人がいるとはまだ聞いたことはありませんが、そうしたいと思う人も
間違いなくいると思います。

この五つの動作を五つの違った印付け命令と掛け算すると、どの命令が何をす
べきかの非常に複雑な変数の組を持つことになります。

この窮地を脱するために、Gnus はこれらすべての違ったことをする命令を提供
します。これらは概略バッファーの `M M' マップにあります。すべてを見るた
めには `M M C-h' を入力してください--このマニュアルで一覧を出すには多過
ぎます。

これらの命令を直接使うことはできますが、ほとんどの利用者は概略モードの
キーマップを交換する方を好むでしょう。例えば、`!' 命令に次の未読記事の
代わりに次の記事に移動して欲しいとすると、このようなことができます:

     (add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)
     (defun my-alter-summary-map ()
       (local-set-key "!" 'gnus-summary-put-mark-as-ticked-next))

もしくは、

     (defun my-alter-summary-map ()
       (local-set-key "!" "MM!n"))



File: gnus-ja.info, Node: Setting Process Marks, Prev: Generic Marking Commands, Up: Marking Articles

プロセス印を付ける
------------------

プロセス印は概略バッファーに `#' として表示され、他のコマンドで処理させ
る記事に印を付けるために使われます。例えば、四つの記事に印を付けてから
`*' コマンドを使うと、Gnus はそれら四つの記事をキャッシュに入れます。詳
しくは *Note Process/Prefix:: をどうぞ。

`M P p'
`#'
     現在の記事にプロセス印を付けます
     (`gnus-summary-mark-as-processable')。

`M P u'
`M-#'
     もし現在の記事にプロセス印があれば取り除きます
     (`gnus-summary-unmark-as-processable')。

`M P U'
     すべての記事からプロセス印を取り除きます
     (`gnus-summary-unmark-all-processable')。

`M P i'
     プロセス印の付いている記事とそうでない記事を逆にします
     (`gnus-uu-mark-by-regexp')。

`M P R'
     正規表現に合致する `Subject' ヘッダーを持つ記事に印を付けます
     (`gnus-uu-mark-by-regexp')。

`M P G'
     正規表現に合致する `Subject' ヘッダーを持つ記事から印を削除します
     (`gnus-uu-unmark-by-regexp')。

`M P r'
     領域にある記事に印を付けます (`gnus-uu-mark-region')。

`M P g'
     領域にある記事から印を削除します (`gnus-uu-unmark-region')。

`M P t'
     現在のスレッド (または副スレッド) のすべての記事に印を付けます
     (`gnus-uu-mark-thread')。

`M P T'
     現在のスレッド (または副スレッド) のすべての記事から印を取り除きま
     す (`gnus-uu-unamrk-thread')。

`M P v'
     接頭引数よりも大きなスコアを持つすべての記事に印を付けます
     (`gnus-uu-mark-over')。

`M P s'
     現在の一連の記事に印を付けます (`gnus-uu-mark-series')。

`M P S'
     すでにいくつか印の付いた記事を持つ一連の記事群すべてに印を付けます
     (`gnus-uu-mark-sparse')。

`M P a'
     一連の記事が出てくる順番にそれに属するすべての記事に印を付けます
     (`gnus-uu-mark-all')。

`M P b'
     バッファーのすべての記事を現れている順番に印を付けます
     (`gnus-uu-mark-buffer')。

`M P k'
     現在のプロセス印をスタックに積んで、すべての記事を無印にします
     (`gnus-summary-kill-process-mark')。

`M P y'
     スタックから前回のプロセス印を取り出して、それを復元します
     (`gnus-summary-yank-process-mark')。

`M P w'
     現在のプロセス印をスタックに積みます
     (`gnus-summary-save-process-mark')。

そして、記事の本文の内容に基づいてプロセス印を付けるやり方については、
*Note Searching for Articles:: の `&' 命令を参照してください。



File: gnus-ja.info, Node: Limiting, Next: Threading, Prev: Marking Articles, Up: Summary Buffer

制限をする
==========

現在グループにある記事の一部だけを表示するように概略バッファーを制限で
きれば便利なことがあります。多くの制限命令が持つ効果は、概略バッファー
から少し (もしくは多く) の記事を削除することです。

制限命令はサーバーからすでに取得された記事の一部分に作用します。これら
の命令はサーバーに追加の記事を要求しません。

`/ /'
`/ s'
     概略バッファーをいくつかの表題と合致するものだけに制限します
     (`gnus-summary-limit-to-subject')。接頭引数が与えられると、合致す
     る記事を除外します。

`/ a'
     概略バッファーを何人かの著者に合致するものだけに制限します
     (`gnus-summary-limit-to-author')。接頭引数が与えられると、合致する
     記事を除外します。

`/ R'
     概略バッファーをいくつかの受信者に合致する記事だけに制限します
     (`gnus-summary-limit-to-recipient')。接頭引数が与えられると、合致
     する記事を除外します。

`/ A'
     概略バッファーを、その From、To または Cc ヘッダーの内容が与えられ
     たアドレスと合致する記事に制限します
     (`gnus-summary-limit-to-address')。接頭引数が与えられると、合致す
     る記事を除外します。

`/ S'
     概略バッファーを表示されているスレッドに属さない記事だけに制限しま
     す (`gnus-summary-limit-to-singletons')。接頭引数が与えられると、
     表示されているスレッドに属する記事だけに制限します。

`/ x'
     「追加」のヘッダーの一つに合致する記事に概略バッファーを制限します
     (*Note To From Newsgroups::) (`gnus-summary-limit-to-extra')。接頭
     引数が与えられると、合致する記事を除外します。

`/ u'
`x'
     概略バッファーを既読の印が付いていない記事に制限します
     (`gnus-summary-limit-to-unread')。接頭引数が与えられると、バッファー
     を完全に未読記事のみに制限します。これは、可視と保留の記事は含まれ
     ないということです。

`/ m'
     印を尋ねて、その印が付いている記事に制限します
     (`gnus-summary-limit-to-marks')。

`/ t'
     数値を尋ねて、概略バッファーをその日数より古い (もしくは同じ) 記事
     に制限します (`gnus-summary-limit-to-age')。接頭引数が与えられると、
     その数値の日よりも新しい記事に制限します。

`/ n'
     概略バッファーを、接頭引数 `n' で指定された次の `n' 個の記事に制限
     します。接頭引数が与えられないと、代わりにプロセス印が付いている記
     事に制限します。(`gnus-summary-limit-to-articles')。

`/ w'
     前の制限をスタックから取り出して、復元します
     (`gnus-summary-pop-limit')。接頭引数を与えられると、すべての制限を
     スタックから取り出します。

`/ .'
     概略バッファーをまだ読まれたことが無い記事に制限します
     (`gnus-summary-limit-to-unseen')。

`/ v'
     概略バッファーをあるスコアと同じか、それより大きなスコアを持つ記事
     に制限します (`gnus-summary-limit-to-score')。

`/ p'
     概略バッファーを `display' グループパラメーターの述語を満足させる
     ように制限します (`gnus-summary-limit-to-display-predicate')。この
     述語に関する詳細は *Note Group Parameters:: を参照してください。

`/ r'
     概略バッファーを返信した記事だけに制限します
     (`gnus-summary-limit-to-replied')。接頭引数が与えられると、返信し
     た記事以外の記事に制限します。

`/ E'
`M S'
     すべての消去された記事を制限に含めます
     (`gnus-summary-limit-include-expunged')。

`/ D'
     すべての保留記事を制限に含めます
     (`gnus-summary-limit-include-dormant')。

`/ *'
     すべてのキャッシュに入っている記事を制限に含めます
     (`gnus-summary-limit-include-cached')。

`/ d'
     すべての保留記事を制限から除外します
     (`gnus-summary-limit-exclude-dormant')。

`/ M'
     すべての印付き記事を除外します
     (`gnus-summary-limit-exclude-marks')。

`/ T'
     現在のスレッドのすべての記事を制限に含めます
     (`gnus-summary-limit-include-thread')。

`/ c'
     子記事の無いすべての保留記事を制限から除外します
     (`gnus-summary-limit-exclude-childless-dormant')。

`/ C'
     すべての除外された未読の記事に既読の印を付けます
     (`gnus-summary-limit-mark-excluded-as-read')。接頭引数が与えられる
     と、可視と保留のみの印の記事も既読として印を付けます。

`/ b'
     概略バッファーを、ある正規表現に本文が合致する記事だけに制限します
     (`gnus-summary-limit-to-bodies')。接頭引数が与えられると、制限を逆
     にします (訳注: 合致しない記事だけに制限します)。合致するものを探
     すためにそれぞれの記事を取り込まなければならないので、このコマンド
     はとても遅いです。

`/ h'
     この前のコマンドに似ていますが、代わりにこれは、ある正規表現にヘッ
     ダーが合致する記事だけに制限します
     (`gnus-summary-limit-to-headers')。

以下は制限命令ではありませんが、同様に接頭キー `/' を使います。

`/ N'
     すべての新しい記事を概略バッファーに挿入します。
     BACK-END`-get-new-mail' が非-`nil' だったら、新しいメールの到来を
     調べるということです。

`/ o'
     すべての古い記事を概略バッファーに挿入します。数値の接頭引数が与え
     られると、その個数の記事を取り込みます。



File: gnus-ja.info, Node: Threading, Next: Sorting the Summary Buffer, Prev: Limiting, Up: Summary Buffer

スレッド
========

Gnus はディフォルトで記事をスレッド表示します。「スレッドにする」とは、
ある記事への応答を応答した記事の直後に置く--階層的流儀で、ということで
す。

スレッドは記事の `References' 欄を調べることによって行なわれます。理想
的な世界では、これだけで木を完成させるのに十分なのですが、不運なことに
`References' 欄はしばしば壊れているか、時には単に無いことがあります。怪
しげなニュースの伝搬は問題を悪化させるので、満足な結果を得るためには他
の検出法を採用しなければなりません。過剰な対策法は存在していて、その恐
るべき詳細は *Note Customizing Threading:: に詳しく書いてあります。

まず、概念の概観です:

"根本 (root)"
     スレッドで一番頂点にある記事です；スレッドの最初の記事です。

"スレッド (thread)"
     木のような記事の構成です。

"副スレッド (sub-thread)"
     木のような構造の (より) 小さな部分です。

"無束縛スレッド (loose threads)"
     記事の期限切れ消去や、根本がすでに前回のセッションで読まれたことに
     より概略バッファーに表示されない、等の理由により、スレッドはしばし
     ば根本を失います。そのようなときには、普通は多くの副スレッドがあっ
     て、本当は一つのスレッドに属しているのですが、根本にはつながってい
     ない、ということになります。こういうスレッドが無束縛スレッドと呼ば
     れています。

"スレッド集め (thread gathering)"
     副スレッドを大きなスレッドに集めようとする試みです。

"まばらスレッド (sparse threads)"
     そこではたぶんいくつかの記事が失われてしまったのだろうと『推測され
     た』スレッドのことで、概略バッファーでは空行で表示されます。

* Menu:

* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令



File: gnus-ja.info, Node: Customizing Threading, Next: Thread Commands, Prev: Threading, Up: Threading

スレッドをカスタマイズする
--------------------------

* Menu:

* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう... でもあなたは間違っていた!



File: gnus-ja.info, Node: Loose Threads, Next: Filling In Threads, Prev: Customizing Threading, Up: Customizing Threading

無束縛スレッド
..............

`gnus-summary-make-false-root'
     もし `nil' でないと、Gnus はすべてのつながっていない部分木を一つの
     大きな木にして、頂上にみせかけの根本を作ります。(ちょっと待ってく
     ださい。頂上に根元 (root) ですって? ええ、そうなのです。) つながっ
     ていない部分木は本当の根本が期限切れ消去されたか、前回のセッション
     で根本を読んだり削除したときにできます。

     本当のスレッドが無いときは、Gnus は何かでっち上げをする必要があり
     ます。この変数は Gnus が使うべきごまかしの方法を示しています。値と
     してとることができる四つの候補があります。

     `養子 (adopt)'
          Gnus は孤児になった記事群の最初のものを親にします。この親はす
          べての他の記事を養子にします。それらの養子記事は、標準の角括
          弧 (`[]') の代わりに、先の尖った括弧 (`<>') で印が付けられま
          す。これがディフォルトの手段です。

     `みせかけ (dummy)'
          Gnus は親のふりをするみせかけの概略行を作ります。このみせかけ
          の行はどの本当の記事にも対応しないので、それを選択することは、
          みせかけの記事の後の最初の本当の記事を選択をするだけになりま
          す。みせかけの根本の様式を指定するために、
          `gnus-summary-dummy-line-format' が使われます。これはたった一
          つだけのフォーマットの仕様を受け付けます: それは `S' で、記事
          の表題です (*Note Formatting Variables::)。たとえ集めるものが
          無くても、すべてのスレッドにみせかけの根本を持たせたい場合は、
          `gnus-summary-make-false-root-always' を `t' に設定してくださ
          い。

     `空 (empty)'
          Gnus は実際にはどの記事も親にはせず、最初の孤児を除いてすべて
          の孤児の表題欄を単に空のままにします。(実際は
          `gnus-summary-same-subject' を表題として使います (*Note
          Summary Buffer Format::)。)

     `none'
          まったくどの記事も親にしません。スレッドを集めて、単に順繰り
          に表示するだけです。

     `nil'
          無束縛スレッドを集めません。

`gnus-summary-gather-subject-limit'
     無束縛スレッドは記事の表題を比較することによって集められます。もし
     この変数が `nil' であると、Gnus は無束縛スレッドを一つの大きな超ス
     レッドに集める前に、無束縛スレッドの表題が完全に一致することを要求
     します。これは、長い表題の行を切り落としてしまう間抜けなニュースリー
     ダーが存在する現状では、あまりに厳しい要求かもしれません。そう思う
     のなら、この変数を例えば 20 に設定して、表題の最初の 20 文字だけが
     一致することを要求するようにしてください。この変数を本当に低い数値
     に設定すると、目についたもののすべてを Gnus が一つのスレッドに集め
     るのを見ることになるでしょう。それはあまり有用ではありません。

     この変数を特別な値 `fuzzy' に設定すると、Gnus は表題の文字列を大雑
     把に比較するアルゴリズムを使います (*Note Fuzzy Matching::)。

`gnus-simplify-subject-fuzzy-regexp'
     正規表現または正規表現のリストのどちらかです。表題の大雑把な比較を
     行なうときに、それらに合致する文字列を表題から取り除きます。

`gnus-simplify-ignored-prefixes'
     もし `gnus-summary-gather-subject-limit' を 10 くらいに低く設定し
     たならば、この変数を何か意味のあるものに設定することを考えるでしょ
     う:

          (setq gnus-simplify-ignored-prefixes
                (concat
                 "\\`\\[?\\("
                 (mapconcat
                  'identity
                  '("looking"
                    "wanted" "followup" "summary\\( of\\)?"
                    "help" "query" "problem" "question"
                    "answer" "reference" "announce"
                    "How can I" "How to" "Comparison of"
                    ;; ...
                    )
                  "\\|")
                 "\\)\\s *\\("
                 (mapconcat 'identity
                            '("for" "for reference" "with" "about")
                            "\\|")
                 "\\)?\\]?:?[ \t]*"))

     この正規表現に合致するすべての語は、二つの表題を比較する前に取り除
     かれます。

`gnus-simplify-subject-functions'
     `nil' でないと、この変数は `gnus-summary-gather-subject-limit' よ
     りも優先されます。この変数は `Subject' の文字列に反復して作用させ
     て簡単にするための、関数のリストである必要があります。

     このリストに入れて役に立つような関数は次のようなものです:

     `gnus-simplify-subject-re'
          前の方にある `Re:' を取り除きます。

     `gnus-simplify-subject-fuzzy'
          大雑把な比較ができるように簡単にします。

     `gnus-simplify-whitespace'
          余分な空白 (whitespace) を取り除きます。

     `gnus-simplify-all-whitespace'
          すべての空白 (whitespace) を取り除きます。

     もちろん、あなた自身の関数を書くこともできます。

`gnus-summary-gather-exclude-subject'
     無束縛スレッド集めは表題だけで行なわれるので、特に `' や `(none)'
     のような良くある表題のときは、多くの間違いを起こす可能性があります。
     この状況を少し良くするために、正規表現
     `gnus-summary-gather-exclude-subject' を使うことによって、集める過
     程においてどんな表題を除外するかを指示することができます。ディフォ
     ルトは `^ *$\\|^(none)$' です。

`gnus-summary-thread-gathering-function'
     Gnus は `Subject' 欄を調べることによってスレッドを集めます。これは、
     結果的にまったく関係の無い記事が同じ『スレッド』に含まれるかもしれ
     ないことを意味し、混乱の元です。代替手段は、合致するものを見つける
     ために `References' 欄にある `Message-ID' をすべて調べることです。
     これは集められたスレッドが関係の無い記事をまったく含まないことを保
     証しますが、いかれたニュースリーダーで投稿した記事は適切に集められ
     ないということでもあります。ペストかコレラかの選択権はあなたにあり
     ます。

     `gnus-gather-threads-by-subject'
          この関数はディフォルトの収集関数で、排他的に `Subject' を調べ
          ます。

     `gnus-gather-threads-by-references'
          この関数は排他的に `References' 欄を調べます。

     `References' によって集めることを試してみたいのであれば、次のよう
     にすることができます:

          (setq gnus-summary-thread-gathering-function
                'gnus-gather-threads-by-references)



File: gnus-ja.info, Node: Filling In Threads, Next: More Threading, Prev: Loose Threads, Up: Customizing Threading

スレッドを埋める
................

`gnus-fetch-old-headers'
     もし `nil' でないと、Gnus は古いスレッドをもっと古いヘッダー、すな
     わち既読の印が付いている記事のヘッダー、を取得することで構築しよう
     とします。できるだけ少ない概略行を表示したいけれど、できるだけたく
     さんの無束縛スレッドをつなげておきたいときは、この変数を `some' か
     数値に設定してください。もし数値に設定したときは、それより多い追加
     のヘッダーは取得されません。どちらの場合でも、古いヘッダーの取得は、
     使っているバックエンドが overview ファイルを使っている場合だけ動作
     します。それらのバックエンドは、普通は `nntp', `nnspool', `nnml'
     および `nnmaildir' です。スレッドの根本がサーバーによって期限切れ
     消去されてしまったら、Gnus はどうしようもないことも覚えておいてく
     ださい。

     この変数は `invisible' に設定することもできます。これは視覚的な効
     果は何もありませんが、`A T' 命令をよく使うのであれば役に立つでしょ
     う (*Note Finding the Parent::)。

     サーバーは、このいずれをも機能させるために NOV をサポートしなけれ
     ばなりません。

     この機能は性能に深刻な影響を与え得ます。すべてのローカルにキャッシュ
     されたヘッダーを無視するからです。記事を期限切れ消去しないサーバー
     (例えば news.gmane.org) の、あるグループのためにそれを `t' に設定
     すると、概略の生成がとても遅くなってしまいます。

`gnus-fetch-old-ephemeral-headers'
     `gnus-fetch-old-headers' と同じですが、一時ニュースグループのため
     にだけ使われます。

`gnus-build-sparse-threads'
     古いヘッダーを取得すると遅くなることがあります。この変数を `some'
     に設定することによって、同じような低賃金の効果を得ることができます。
     そうすると、Gnus はすべての記事の完全な `References' 欄を見て、同
     じスレッドに属する記事をつなごうとします。これは、記事がそのスレッ
     ドから失われていると Gnus が推測したスレッド表示に「ずれ」を残すで
     しょう。(これらのずれは普通の概略行のように見えます。もしずれを選
     択すると、Gnus はその当の記事を取得しようとします。) この変数が
     `t' であると、Gnus はスレッドを補完するのに役立つかどうかを考慮せ
     ずに、すべての「ずれ」を表示します。最後に、この変数が `more' であ
     ると、Gnus はどこにもつながっていない枝葉のまばらな節を切り落とし
     ません。この変数はディフォルトでは `nil' です。

`gnus-read-all-available-headers'
     これはあまり役に立たない、いささかはっきりしない変数です。ニュース
     ではないグループにおいて、概略バッファーを作るためにバックエンドが
     極めて多くのものを取り込まなければならず、しかも親記事を辿ることが
     できない場合に使うことを想定しています。それは主に `nnultimate' グ
     ループのような、ウェブに基づいたグループでの場合です。

     そんなグループを使わない場合はディフォルトの `nil' のままにしてお
     くのが無難です。使いたい場合はグループ名に合致する正規表現か、すべ
     てのグループが対象になる `t' にしてください。



File: gnus-ja.info, Node: More Threading, Next: Low-Level Threading, Prev: Filling In Threads, Up: Customizing Threading

もっとスレッドを
................

`gnus-show-threads'
     この変数が `nil' であると、スレッドは作られず、ここにある残りのす
     べての変数はまったく効果が無くなります。スレッド作りを止めるとグルー
     プの選択が少し速くなりますが、記事を読むのがもっと遅く、不便になる
     ことは確実です。

`gnus-thread-hide-subtree'
     これが `nil' でないと、すべてのスレッドは概略バッファーが生成され
     たときに隠れます。

     これは述語指示子であることもできます (*Note Predicate
     Specifiers::)。利用できる述語は `gnus-article-unread-p' と
     `gnus-article-unseen-p' です。

     これは例です:

          (setq gnus-thread-hide-subtree
                '(or gnus-article-unread-p
                     gnus-article-unseen-p))

     (これはかなりばかげた例です。なぜならすべてのまだ読まれたことが無
     い記事は未読でもあるからなのですが、趣旨は汲み取ってください。)

`gnus-thread-expunge-below'
     この数値より少ない総スコア (`gnus-thread-score-function' で定義さ
     れた関数を使って算出されます) を持つすべてのスレッドは消去されます。
     この変数はディフォルトでは `nil' で、これはどのスレッドも消去され
     ないということです。

`gnus-thread-hide-killed'
     スレッドを削除すると、この変数が `nil' でない場合、部分木は隠され
     ます。

`gnus-thread-ignore-subject'
     ときどき誰かがスレッドの途中で表題を変更することがあります。この変
     数が `nil' でないと (これがディフォルトですが)、表題の変更は無視さ
     れます。もし `nil' だと、表題の変更をすると別のスレッドになります。

`gnus-thread-indent-level'
     これは、それぞれの副スレッドがどれくらい字下げ (indent) されるべき
     かを決める数値です。ディフォルトは 4 です。

`gnus-sort-gathered-threads-function'
     とりわけメーリングリストでは、ときとして手元にメールが到着する順番
     は必ずしもメーリングリストに到着した順番と同じでは無いことがありま
     す。その結果、副スレッドをディフォルトの
     `gnus-thread-sort-by-number' で並べ換えると、応答の方がそれの元記
     事より先に現れてしまうことがあります。グループパラメーターや適切な
     フック (例えば `gnus-summary-generate-hook') でこの変数を代わりの
     値 (例えば `gnus-thread-sort-by-date') に設定することによって、そ
     のような場合に、より論理的な副スレッドの順番を生成することができま
     す。



File: gnus-ja.info, Node: Low-Level Threading, Prev: More Threading, Up: Customizing Threading

低レベルにおけるスレッド作成
............................

`gnus-parse-headers-hook'
     すべてのヘッダーを解析する前に実行されるフックです。

`gnus-alter-header-function'
     この変数の値が `nil' ではなくて関数であると、ヘッダー構造 (訳注:
     記事の主要なヘッダーの内容を効率良く保持するための Lisp オブジェク
     ト) を変更するために呼ばれます。関数は記事ヘッダーのベクトル (訳注:
     すなわちヘッダー構造) とともに呼ばれ、それが何らかの方法で変更され
     ます。例えば `Message-ID' を体系的な方法で (接頭語などを付け加える
     ことによって) 変更してしまうメールからニュースへのゲートウェイがあ
     る場合、この変数を設定することによって、その `Message-ID' を元の意
     味のあるものに戻すことができます。これは一つの例です:

          (setq gnus-alter-header-function 'my-alter-message-id)

          (defun my-alter-message-id (header)
            (let ((id (mail-header-id header)))
              (when (string-match
                     "\\(<[^<>@]*\\)\\.?cygnus\\..*@\\([^<>@]*>\\)" id)
                (mail-header-set-id
                 (concat (match-string 1 id) "@" (match-string 2 id))
                 header))))

          訳注: 取得した記事の `Message-ID' 欄から、`@' の前に付加され
          た `cygnus.' で始まる文字列を取り除きます。



File: gnus-ja.info, Node: Thread Commands, Prev: Customizing Threading, Up: Threading

スレッドの命令
--------------

`T k'
`C-M-k'
     現在のスレッド (または副スレッド) のすべての記事に既読の印を付けま
     す (`gnus-summary-kill-thread')。もし接頭引数が正であると、代わり
     にすべての印を取り除きます。接頭引数が負であると、代わりに記事を可
     視にします。

`T l'
`C-M-l'
     現在のスレッド (または副スレッド) のスコアを下げます
     (`gnus-summary-lower-thread')。

`T i'
     現在のスレッド (または副スレッド) のスコアを上げます
     (`gnus-summary-raise-thread')。

`T #'
     プロセス印を現在のスレッド (または副スレッド) に付けます
     (`gnus-uu-mark-thread')。

`T M-#'
     現在のスレッド (または副スレッド) からプロセス印を取り除きます
     (`gnus-uu-unmark-thread')。

`T T'
     スレッド表示を切り替えます (`gnus-summary-toggle-threads')。

`T s'
     もしあれば、現在の記事の下に隠れているスレッドを表示します
     (`gnus-summary-show-thread')。

`T h'
     現在のスレッド (または副スレッド) を隠します
     (`gnus-summary-hide-thread')。

`T S'
     すべての隠されているスレッドを表示します
     (`gnus-summary-show-all-threads')。

`T H'
     すべてのスレッドを隠します (`gnus-summary-hide-all-threads')。

`T t'
     現在の記事のスレッドをもう一度作り直します
     (`gnus-summary-rethread-current')。これは概略バッファーがスレッド
     表示されていないときでも動作します。

`T ^'
     現在の記事を印付きの (もしくは前の) 記事の子記事にします
     (`gnus-summary-reparent-thread')。

`T M-^'
     現在の記事を印付きの記事の親記事にします
     (`gnus-summary-reparent-children')。

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付け
ます。

`T n'
`C-M-f'
`M-down'
     次のスレッドに移動します (`gnus-summary-next-thread')。

`T p'
`C-M-b'
`M-up'
     前のスレッドに移動します (`gnus-summary-prev-thread')。

`T d'
     スレッドを下ります (`gnus-summary-down-thread')。

`T u'
     スレッドを登ります (`gnus-summary-up-thread')。

`T o'
     スレッドの頂上に移動します (`gnus-summary-top-thread')。

スレッドを作成するときに表題を無視すると、当然ながらいくつかの違った表
題があるスレッドが出来上がります。そして `T k'
(`gnus-summary-kill-thread') のような命令を発するときに、全体のスレッド
を削除するのではなく、現在の記事と同じ表題を持つ部分だけを削除したいと
きがあるかもしれません。もしこの発想が良いと思うのであれば、
`gnus-thread-operation-ignore-subject' をいじってみてください。これが
`nil' でないと (それがディフォルトですが)、スレッドの命令を実行している
ときに表題は無視されます。これが `nil' だったら、同じスレッドにある異な
る表題を持つ記事は、そのとき行なう操作の対象に含まれません。この変数が
`fuzzy' であると、大雑把な比較によって等しいと判定される表題を持つ記事
だけが対象に含まれます (*Note Fuzzy Matching::)。



File: gnus-ja.info, Node: Sorting the Summary Buffer, Next: Asynchronous Fetching, Prev: Threading, Up: Summary Buffer

並べ替え
========

概略でスレッドの表示を使っているのであれば、
`gnus-thread-sort-functions' を設定することによってスレッドを並べ替える
ことができます。この変数の値は単独の関数、関数のリスト、または関数と
`(関数でないもの)' の要素を含むリストであることができます。

ディフォルトでは並べ替えは記事番号に基づいて行なわれます。すでに用意さ
れている並べ替え述語関数は `gnus-thread-sort-by-number',
`gnus-thread-sort-by-author', `gnus-thread-sort-by-recipient',
`gnus-thread-sort-by-subject', `gnus-thread-sort-by-date',
`gnus-thread-sort-by-score', `gnus-thread-sort-by-most-recent-number',
`gnus-thread-sort-by-most-recent-date', `gnus-thread-sort-by-random' お
よび `gnus-thread-sort-by-total-score' です。

それぞれの関数は二つのスレッドをとり、最初のスレッドがもう一方より先に
並べ替えられるべきであれば `nil' でない値を返します。実際の並べ替えは、
普通それぞれのスレッドの根本だけを調べることによって行なわれることに気
を付けてください。

二つ以上の関数を使う場合、並べ替えの第一の鍵はリストの最後の関数でなけ
ればなりません。並べ替え関数のリストのなるべく先頭に、おそらく常に
`gnus-thread-sort-by-number' を含めておくべきでしょう。これは、他の並べ
替えの基準が等しいスレッドが、記事番号の登り順に表示されることを保証し
ます。

スコアの逆順、表題、そして最後に番号、の順に並べ替えたいのであれば、次
のようにできます:

     (setq gnus-thread-sort-functions
           '(gnus-thread-sort-by-number
             gnus-thread-sort-by-subject
             (not gnus-thread-sort-by-total-score)))

最大のスコアを持つスレッドが、最初に概略バッファーに表示されます。スレッ
ドが同じスコアの場合は、英字順に並び替えられます。同じスコアと表題を持
つスレッドは番号で並べ替えられ、(普通は) 記事が到着した順番になります。

スコア、到着の逆順に並べ替えたいのであれば、次のようにできます:

     (setq gnus-thread-sort-functions
           '((not gnus-thread-sort-by-number)
             gnus-thread-sort-by-score))

変数 `gnus-thread-score-function' (ディフォルトは `+') に設定されている
関数は、スレッドの総スコアを計算するために用いられます。役立つ関数は
`max', `min', もしくは二乗、もしくはあなたの好奇心をくすぐるような何か
でしょう。

何か変な理由でスレッド表示を使っていないのなら、変数
`gnus-article-sort-functions' をいじくる必要があります。これは
`gnus-thread-sort-functions' と非常に似ていますが、記事の比較には少々違っ
た関数を使います。使用可能な並べ替え述語関数は
`gnus-article-sort-by-number', `gnus-article-sort-by-author',
`gnus-article-sort-by-subject', `gnus-article-sort-by-date',
`gnus-article-sort-by-random' および `gnus-article-sort-by-score' です。

スレッドを使っていない概略の表示を表題で並べ替えたいのであれば、次のよ
うなことをすることができます:

     (setq gnus-article-sort-functions
           '(gnus-article-sort-by-number
             gnus-article-sort-by-subject))

`gnus-parameters' を介することによって、グループによって異なる並べ替え
を定義することができます。*Note Group Parameters::.



File: gnus-ja.info, Node: Asynchronous Fetching, Next: Article Caching, Prev: Sorting the Summary Buffer, Up: Summary Buffer

非同期記事取得
==============

遠くにある NNTP サーバーからニュースを取得していると、ネットワークの遅
延が記事を読むことを嫌な仕事にしてしまうかもしれません。`n' を押してか
ら次の記事が現れるまで、しばらく待たなければなりませんものね。どうして
前の記事を読んでいる間に Gnus が先行して記事を取得してくれないのでしょ
うか? なぜできないんでしょう、本当に。

まず警告しておきましょう。非同期で記事を取得、特に Gnus がそれを行なう
場合には、いくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くて、あなた
はそれを読むことには興味が無いとしましょう。Gnus はこのことはわからない
ので、先行して記事 2 を取得します。あなたは記事 3 を読むことにしますが、
Gnus は記事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、Gnus はサーバーに二つ (二まで数えてください) の
接続を張ります。これはあまり良いことではないと考える人もいるでしょうが、
私には実際の代替手段が見つからないのです。余分な接続を立ち上げるために
はいくばくかの時間がかかるので、Gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先行取得を使わないときよりも、あなたのマシンと NNTP サーバー間の
接続にもっと負荷をかけることになるでしょう。サーバー自身にももっと負荷
がかかるようになります--余分な記事の要求と、余分な接続によって。

はい、本当はこのようなことをすべきで無いことがこれで分かったでしょ
う... 本当にそうしたいと思わない限りは。

やり方です: `gnus-asynchronous' を `t' に設定してください。それ以外の諸々
のことは自動的に行なわれます。

`gnus-use-article-prefetch' を設定することによって、どれくらいの記事を
先に取得するべきかを操作することができます。これはディフォルトでは 30
で、グループの記事を読んでいるときに、バックエンドが次の 30 通の記事を
先行取得するということです。この変数が `t' であると、バックエンドは取得
できるすべての記事を際限なく先行取得しようとします。これが `nil' である
と、先行取得は行なわれません。

おそらく先行取得をしたくない記事がいくつかあるでしょう--例えば既読記事
です。変数 `gnus-async-prefetch-article-p' は記事が先に取得されるかどう
かを制御します。この変数に設定される関数は、問題の記事を先行取得するの
であれば `nil' でない値を返さなければなりません。ディフォルトの関数は
`gnus-async-unread-p' で、これは既読記事には `nil' を返します。この関数
は記事のデータ構造を唯一の引数として呼ばれます。

例えば、100 行よりも短い未読記事だけを先に取得したいのであれば、次のよ
うにできます:

     (defun my-async-short-unread-p (data)
       "Return non-nil for short, unread articles."
       (and (gnus-data-unread-p data)
            (< (mail-header-lines (gnus-data-header data))
               100)))

     (setq gnus-async-prefetch-article-p 'my-async-short-unread-p)

これらの関数は何度も何度も呼ばれるので、Gnus を遅くしすぎないように、短
く簡潔であるのが好ましいです。このようなものをバイトコンパイルするのは、
おそらく良い着想でしょう。

記事は非同期バッファーから遅かれ早かれ削除されなければなりません。
`gnus-prefetched-article-deletion-strategy' はいつ記事を削除するかを指
定します。これは以下の要素を含むリストです:

`read'
     記事が読まれたときに削除します。

`exit'
     グループを抜けたときに記事を削除します。

ディフォルトの値は `(read exit)' です。



File: gnus-ja.info, Node: Article Caching, Next: Persistent Articles, Prev: Asynchronous Fetching, Up: Summary Buffer

記事のキャッシュ
================

*非常に* 遅い NNTP 接続を使っているのならば、記事をキャッシュすることを
考えても良いでしょう。それをすると、それぞれの記事はあなたのホームディ
レクトリーの下にローカルに溜められます。もう感付いたかもしれませんが、
これは i ノードを非常に速く食いつぶすだけでなく、*巨大な* ディスクスペー
スを食う可能性があります。それはあなたにウォッカの中で泳ぐようなめまい
を起こさせるでしょう。

でも注意深く使われれば、それは記事を保存する、より楽な方法になり得ます。

キャッシュを実行させるには `gnus-use-cache' を `t' に設定してください。
ディフォルトでは、すべての可視または保留として印の付いている記事はロー
カルのキャッシュ (`gnus-cache-directory') に複写されます。このキャッシュ
が平らな構造か階層的であるかは、通常通り、変数
`gnus-use-long-file-name' で制御されます。

可視記事か保留記事を再選択した場合は、サーバーの代わりにキャッシュから
取得されます。キャッシュにある記事は期限切れ消去されないので、記事をそ
れらが属するところに居続けさせている間、それらを保存する方法としてこれ
は役立つかもしれません。保存したいすべての記事に保留の印を付けるだけで、
後は心配無用です。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょう
か。

記事をキャッシュに入れたりキャッシュから削除することは、変数
`gnus-cache-enter-articles' および `gnus-cache-remove-articles' によっ
て制御されます。これらは両方ともシンボルのリストです。前者はディフォル
トでは `(ticked dormant)' で、可視記事と保留記事はキャッシュに入れられ
ます。後者はディフォルトでは `(read)' で、既読の印が付いた記事はキャッ
シュから削除されます。おそらくこれら二つのリストに含まれるシンボルは
`ticked', `dormant', `unread' および `read' でしょう。

それでは、大規模な記事の取得と格納は、どこで関係してくるのでしょうか。
`gnus-jog-cache' 命令は、すべての購読グループに対して、すべての未読記事
を要求し、スコアを付け、キャッシュに保存します。この命令をいつもいつも
いつもいつも使うのは、1) NNTP サーバーとの接続が本当に本当に本当に遅く
て、2) 本当に本当に本当に巨大なディスクを持っているときだけにするべきで
す。これは真面目に言っています。ダウンロードされる記事の数を控える一つ
の方法は、欲しくない記事のスコアを低くして、それらに既読の印を付けるこ
とです。そうすれば、それらはこの命令ではダウンロードされません。

すべてのグループではキャッシュをしたくないというのは良くあることです。
例えば `nnml' のメールがホームディレクトリーにあるのなら、それをホーム
ディレクトリーの別の場所にキャッシュするのは意味がありません。二倍の容
量を使う方が良いと思うのでなければ。

キャッシュを制限するには、`gnus-cacheable-groups' を例えば `^nntp' のよ
うなキャッシュするグループの正規表現に設定するか、または正規表現
`gnus-uncacheable-groups' を例えば `^nnml' に設定してください。両方の変
数ともにディフォルトは `nil' です。もしグループが両方の変数に合致すると、
そのグループはキャッシュされません。

キャッシュは、それがどの記事を含んでいるかの情報を、そのアクティブファ
イル (`gnus-cache-active-file') に格納します。このファイル (もしくは
キャッシュの他の部分) が何らかの理由でぐちゃぐちゃになってしまった場合、
Gnus はものごとを正しくするための二つのコマンドを提供します。`M-x
gnus-cache-generate-nov-databases' はすべての NOV ファイルを (再) 作成
し、`M-x gnus-cache-generate-active' はアクティブファイルを (再) 作成し
ます。

`gnus-cache-move-cache' コマンドは、すべての `gnus-cache-directory' を
どこか別の場所に移動します。あなたはどこに移動させるかを尋ねられます。
それってかっこいいでしょ?



File: gnus-ja.info, Node: Persistent Articles, Next: Sticky Articles, Prev: Article Caching, Up: Summary Buffer

永続記事
========

記事のキャッシュと近い関係にあるものに「永続記事」があります。実際それ
はキャッシュを見るための別の方法で、私に言わせればはるかに役に立ちます。

例えば、ニュースグループを読んでいて、永久に秘蔵しておく価値のある宝石
に出会ったとしましょう。普通はそれをファイルに保存します (多くの保存命
令の一つを使って)。問題は、単にあの、嫌なだけです。理想的には、記事はグ
ループで見つけた場所に永遠に残っていることが好ましいでしょう。ニュース
サーバーにおける期限切れ消去には影響されないで。

これが「永続記事」です--記事は削除されません。それは普通のキャッシュ命
令を使って実装されていますが、永続記事の管理をするために二つの明示的な
命令を使います:

`*'
     現在の記事を永続にします (`gnus-cache-enter-article')。

`M-*'
     現在の記事を永続記事から取り除きます
     (`gnus-cache-remove-articles')。これは普通は記事を削除します。

これらの命令は両方ともプロセス/接頭引数の習慣を理解します。

永続記事にだけ興味があるのなら、可視記事 (やその他のもの) がキャッシュ
に入るのを避けるために、`gnus-use-cache' を `passive' に設定するのが良
いでしょう:

     (setq gnus-use-cache 'passive)



File: gnus-ja.info, Node: Sticky Articles, Next: Article Backlog, Prev: Persistent Articles, Up: Summary Buffer

粘着記事
========

記事を選択するとき、変数 `gnus-single-article-buffer' の値によっては現
在の記事バッファーが再利用されます。それが `nil' 以外の値だと、すべての
記事が同じ記事バッファーを再利用しますが、`nil' だった場合はグループ毎
に独自の記事バッファーを持ちます。

このことは、あるグループで同時に一つより多い記事バッファーを持つことは
できないことを意味します。でも、時には今度のクリスマス・パーティーの段
取りのために、お母さん、お父さん、叔母さん、叔父さん、さらに 17 人のい
とこから最近届いたすべての電子メールを表示したいこともあるでしょう。

こんなときに粘着記事が役に立ちます。粘着記事バッファーは原理的には普通
の記事バッファーなのですが、他の記事を選択しても再利用されません。記事
を粘着質にするには、このコマンドを使ってください:

`A S'
     現在の記事を粘着質にします。接頭引数付きで呼ぶと、この粘着記事バッ
     ファーの名前を尋ねます。

粘着記事バッファーを閉じるには、次のコマンドを使ってください:

`q'
     この粘着記事バッファーを、すべてのバッファーのリストの最後尾に置き
     ます。

`k'
     この粘着記事バッファーを削除します。

すべての粘着記事バッファーを削除するには、このコマンドを使えば良いでしょ
う:

 -- Function: gnus-kill-sticky-article-buffers ARG
     すべての粘着記事バッファーを削除します。接頭引数を与えると、確認を
     求めます。



File: gnus-ja.info, Node: Article Backlog, Next: Saving Articles, Prev: Sticky Articles, Up: Summary Buffer

記事のバックログ
================

回線が遅いために、キャッシュを使うという発想があまり魅力的ではないとき
(実際そうなのですが)、「バックログ」に切り替えることによって状況を何と
かすることができます。これはすでに読んだ記事を再取得しなくても良いよう
に、すでに読んだ記事を Gnus が一時保存しておくところです。これはもちろ
ん、あなたに最近読んだ記事を再び選択する癖があるときだけ役立ちます。絶
対にそれをしない人にとっては、バックログを on にすることは Gnus を少し
遅くし、メモリーの使用量をいくらか増やすだけのことです。

`gnus-keep-backlog' を数値 N に設定すると、Gnus は最大で N 個の古い記事
を後の再取得のためにバッファーに溜めておきます。この変数が `nil' ではな
く、数値でもない場合、Gnus は *すべて* の既読記事を蓄えます。それは
Emacs が爆発するまで際限なく膨れ上がって、マシンがあなたもろとも落ちて
しまうということです。私はみなさんがいつも注意を怠らないようにするため
に、ここに書き加えました。

ディフォルト値は 20 です。



File: gnus-ja.info, Node: Saving Articles, Next: Decoding Articles, Prev: Article Backlog, Up: Summary Buffer

記事の保存
==========

Gnus はたくさんの方法で記事を保存することができます。以下のものは非常に
率直な方法 (すなわち記事が保存する前にほとんど何もなされない) で記事を
保存するための説明です。異なる手続き (uudecode, unshar) のためには
`gnus-uu' を使うのが良いでしょう (*Note Decoding Articles::)。

ここに列挙されているコマンドは対象がファイルです。グループに保存したい
場合は `B c' (`gnus-summary-copy-article') コマンドを参照してください
(*Note Mail Group Commands::)。

`gnus-save-all-headers' が `nil' でないと、Gnus は記事を保存する前に不
要なヘッダーを消去しません。

もし上記の変数が `nil' であると、正規表現 `gnus-saved-headers' に合致す
るすべてのヘッダーが残される一方、残りのものは保存する前に削除されます。

`O o'
`o'
     ディフォルトの記事を保存する手段を用いて現在の記事を保存します
     (`gnus-summary-save-article')。

`O m'
     現在の記事を Unix メール (mbox) ファイルに保存します
     (`gnus-summary-save-article-mail')。

`O r'
     現在の記事を Rmail の様式で保存します
     (`gnus-summary-save-article-rmail')。これは Emacs 23 から mbox に
     なります。旧バージョンでは Babyl でした。

`O f'
     現在の記事を普通のファイル (plain file) 様式で保存します
     (`gnus-summary-save-article-file')。

`O F'
     現在の記事を普通のファイル様式で保存し、以前のファイルの内容を上書
     きします (`gnus-summary-write-article-file')。

`O b'
     現在の記事の本文を普通のファイル様式で保存します
     (`gnus-summary-save-article-body-file')。

`O h'
     現在の記事を mh のフォルダーの様式で保存します
     (`gnus-summary-save-article-folder')。

`O v'
     現在の記事を VM フォルダーに保存します
     (`gnus-summary-save-article-vm')。

`O p'
`|'
     現在の記事をパイプに保存します。うーんと、あのぉ、私が言おうとして
     いることは--現在の記事をプロセスにパイプするということです
     (`gnus-summary-pipe-output')。シンボル接頭引数 (*Note Symbolic
     Prefixes::) が与えられると、パイプへの出力に完全なヘッダーを含めま
     す。シンボル接頭引数 `r' は特別で、それはすべてのヘッダーを含む生
     の (デコードされていない) 記事をパイプに送ります。
     `gnus-summary-pipe-output-default-command' 変数をディフォルトのコ
     マンドと引数を含む文字列に設定することができます (ディフォルトは
     `nil')。

`O P'
     現在の記事を muttprint に保存します。つまり、外部プログラム
     Muttprint (http://muttprint.sourceforge.net/) を使って記事を印刷す
     るということです。プログラム名と使用するオプションは、変数
     `gnus-summary-muttprint-program' で指定されます。
     (`gnus-summary-muttprint')。

すべてのこれらの命令はプロセス/接頭引数の習慣を使います (*Note
Process/Prefix::)。もしこれらの関数を使ってたくさんの記事を保存した場合、
それぞれのすべての記事に対してファイル名の入力を要求されることに飽き飽
きするでしょう。入力を求める動作は変数 `gnus-prompt-before-saving' によっ
て制御されます。これはディフォルトでは `always' で、あなたが嫌な思いを
味わっている、過剰な入力要求をします。代わりにこの変数を `t' に設定する
と、保存するそれぞれの一連の記事に対して一回だけ入力を要求します。本当
に Gnus にすべての判断を任せてしまいたいのであれば、この変数を `nil' に
することさえできます。そうすれば、記事を保存するためのファイルを促され
ることはありません。Gnus は単純にすべての記事をディフォルトのファイルに
保存します。

Gnus を思い通りに動作させるために、変数 `gnus-default-article-saver' を
カスタマイズすることができます。下の八つの既製の関数を使うことができ、
また自分自身の関数を作ることもできます。

`gnus-summary-save-in-rmail'
     これがディフォルトで、Rmail パッケージで使われているものです。
     Emacs 23 から Rmail は標準の mbox 様式を使うようになりました。それ
     以前には "Babyl" 様式というものが使われていました。そのため、既存
     の Babyl ファイルに追加するのでなければ、Emacs 23 からこのコマンド
     は mbox 様式で書きます。古いバージョンの Emacs では、常に Babyl 様
     式を使います。変数 `gnus-ramil-save-name' に設定されている関数を、
     記事を保存するファイルの名前を取得するために使います。ディフォルト
     は `gnus-plain-save-name' です。

`gnus-summary-save-in-mail'
     Unix メール (mbox) ファイルに保存します。変数
     `gnus-mail-save-name' に設定されている関数を、記事を保存するファイ
     ルの名前を取得するために使います。ディフォルトは
     `gnus-plain-save-name' です。

`gnus-summary-save-in-file'
     記事を通常のファイルの後に追加します。変数 `gnus-file-save-name'
     に設定されている関数を、記事を保存するファイルの名前を取得するため
     に使います。ディフォルトは `gnus-numeric-save-name' です。

`gnus-summary-write-to-file'
     記事をストレートに通常のファイルに保存します。そのファイルが存在し
     ていたら上書きされます。変数 `gnus-file-save-name' に設定されてい
     る関数を、記事を保存するファイルの名前を取得するために使います。ディ
     フォルトは `gnus-numeric-save-name' です。

`gnus-summary-save-body-in-file'
     記事の本文を通常のファイルの後に追加します。変数
     `gnus-file-save-name' に設定されている関数を、記事を保存するファイ
     ルの名前を取得するために使います。ディフォルトは
     `gnus-numeric-save-name' です。

`gnus-summary-write-body-to-file'
     記事の本文をストレートに通常のファイルに保存します。そのファイルが
     存在していたら上書きされます。変数 `gnus-file-save-name' に設定さ
     れている関数を、記事を保存するファイルの名前を取得するために使いま
     す。ディフォルトは `gnus-numeric-save-name' です。

`gnus-summary-save-in-folder'
     MH ライブラリーの `rcvstore' を使って、記事を MH フォルダーに保存
     します。変数 `gnus-folder-save-name' に設定されている関数を、記事
     を保存するファイルの名前を取得するために使います。ディフォルトは
     `gnus-folder-save-name' ですが、`gnus-Folder-save-name' も使うこと
     ができて、こちらは先頭が大文字、残りが小文字になった名前を作ります。

`gnus-summary-save-in-vm'
     記事を VM フォルダーに保存します。この設定を使うためには VM メール
     リーダーが必要です。

`gnus-summary-save-in-pipe'
     記事をシェルコマンドにパイプします。この関数は二つの引数 COMMAND
     および RAW を受け付けます (無くても構いません)。有効な COMMAND の
     値は次の通りです:

        * 文字列
          実行可能なコマンド名と、もしあれば引数です。
        * `nil'
          ミニバッファーでコマンドを入力します。
        * シンボル `default'
          `gnus-summary-pipe-output-default-command' 変数が持っている値、
          または最後に保存のために使われたコマンドで置き換えられます。

     RAW に `nil' 以外の値を与えると `:decode' および `:headers' 属性
     (後述) が無視され、すべてのヘッダーを含む生の (デコードされていな
     い) 記事がパイプに渡されます。

それぞれの関数シンボルは以下の属性 (property) を持つことができます:

`:decode'
     `nil' ではない値が設定されているとデコードした記事を保存します。
     `gnus-summary-save-in-file'、`gnus-summary-save-body-in-file'、
     `gnus-summary-write-to-file'、`gnus-summary-write-body-to-file' お
     よび `gnus-summary-save-in-pipe' でだけ、これを設定する意義があり
     ます。

`:function'
     記事をファイルに上書するのではなく、追加するための代わりの関数を指
     定します。これを設定すると、複数の記事を一度に保存するときに
     `gnus-prompt-before-saving' が `t' に束縛され、すべての記事が単一
     のファイルに保存されます。`gnus-summary-write-to-file' および
     `gnus-summary-write-body-to-file' でだけ、これを設定する意義があり
     ます。

`:headers'
     保存されるヘッダーを指定する変数のシンボルをこれで設定します。省略
     された場合は `gnus-save-all-headers' と `gnus-saved-headers' が、
     どのヘッダーを保存するかを制御します。

これらのすべての関数は最後の一つを除いて、環境変数 `SAVEDIR' によって初
期化される `gnus-article-save-directory' に記事を保存します。これはディ
フォルトでは `~/News/' です。

上で述べたように、記事を保存するためのファイルの適切な名前を見つけるた
めに、それらは違った関数を用います。以下は名前を生成するために使うこと
ができる関数のリストです:

`gnus-Numeric-save-name'
     `~/News/Alt.andera-dworkin/45' のようなファイル名。

`gnus-numeric-save-name'
     `~/News/alt.andera-dworkin/45' のようなファイル名。

`gnus-Plain-save-name'
     `~/News/Alt.andera-dworkin' のようなファイル名。

`gnus-plain-save-name'
     `~/News/alt.andera-dworkin' のようなファイル名。

`gnus-sender-save-name'
     `~/News/larsi' のようなファイル名。

連想リスト `gnus-split-methods' に正規表現を放り込むことによって、Gnus
に記事を保存する場所をほのめかすことができます。例えば Gnus に関連する
記事を `gnus-stuff' ファイルに、VM に関連する記事を `vm-stuff' ファイル
に保存したければ、この変数を以下のようにすれば良いでしょう:

     (("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
      ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
      (my-choosing-function "../other-dir/my-stuff")
      ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))

これはそれぞれの要素が、二つの要素---「合致」と「ファイル」を持つリスト
であるリストであるということがわかります。合致は文字列 (この場合は記事
のヘッダーに合致する正規表現として使われます)、シンボル (グループ名を引
数として、関数として呼ばれます) およびリスト (これは評価 (`eval') され
ます) のどれかであることができます。これらの動作の一つでも `nil' でない
結果を返すと、入力を求めるときのディフォルトとして「ファイル」が使われ
ます。加えて、呼ばれた関数か式が文字列か文字列のリストを返したときは、
演算の結果自体が使われます。

基本的には、現在の記事を保存するのに使われる可能性のあるファイル名のリ
ストを手に入れることになります。(すべての『合致』が使われます。) そして、
実際に名前として使いたいものの入力を促されますが、その際、この変数を適
用して得られた結果が、ファイル名を補完するときの候補になります。

この変数はディフォルトでは `((gnus-article-archive-name))' で、これは
Gnus が保存する記事の `Archive-name' 行を調べて、それをファイル名の候補
として使います。

これはファイル名を多少きれいにする関数の例です。`nnml:mail.whatever' の
ようなメールグループがたくさんあるとすると、保存するためのファイル名を
作る前にそれらのグループ名の最初の方を切り落とす必要があるかもしれませ
ん。次の物はまさにそれをします:

     (defun my-save-name (group)
       (when (string-match "^nnml:mail." group)
         (substring group (match-end 0))))

     (setq gnus-split-methods
           '((gnus-article-archive-name)
             (my-save-name)))

最後に、`gnus-use-long-file-name' という変数があります。これが `nil' で
あると、すべての上記の関数はグループ名のすべてのピリオド (`.') をスラッ
シュ (`/') で置き換えます--つまり、すべてのファイルを一番上のディレクト
リーに置くのではなく、それらの関数が階層的なディレクトリーを生成すると
いうことです (`~/News/alt.andrea-dworkin' ではなく
`~/News/alt/andrea-dworkin' のように)。たいていのシステムにおいて、この
変数のディフォルトは `t' です。しかし、歴史的な理由によって Xenix と
usg-unix-v マシンでは `nil' がディフォルトになります。

この関数は削除とスコアのファイル名にも影響します。この変数がリストで、
そのリストが `not-score' という要素を含んでいると、長いファイル名はスコ
アファイルには使われません。そのリストが `not-save' という要素を含んで
いると、保存するときに長いファイル名は使われません。また、そのリストが
`not-kill' という要素を含んでいると、長いファイル名は削除ファイルには使
われません。

記事をスプールのような階層に保存したい場合は、次のようにしてください。

     (setq gnus-use-long-file-name '(not-save)) ; 階層にする
     (setq gnus-default-article-saver
           'gnus-summary-save-in-file) ; エンコードしない

そうしたならば、`o' で記事を保存するだけです。すると、階層を
`nneething' 一時グループによって読むことができます--グループバッファー
で `G D' をタイプして、一番上のディレクトリー (`~/News/') を引数として
渡してください。



File: gnus-ja.info, Node: Decoding Articles, Next: Article Treatment, Prev: Saving Articles, Up: Summary Buffer

記事のデコード
==============

ときどき利用者は何らかの方法でエンコードされた記事 (もしくは一連の記事
群) を投稿します。Gnus はそれらをデコードすることができます。

     訳注: この章では、複数に分割して送信された一つの巨大な記事を、再び
     一つにまとめ上げてデコードする処理について説明しています。現在では、
     そのような分割送信をメールサーバーが受け付けない等の理由によって、
     ほとんど目にすることはありません。分割して送信しないことを確実にす
     るには、以下の設定を行なってください (*Note メール変数:
     (message-ja)Mail Variables.):

          (setq message-send-mail-partially-limit nil)

* Menu:

* Uuencoded Articles::          記事を uudecode する
* Shell Archives::              shar 記事を解凍する
* PostScript Files::            ポストスクリプトを分割する
* Other Files::                 普通の保存と binhex.
* Decoding Variables::          幸せなデコードのための変数
* Viewing Files::               デコードされた結果を見たい?

これらすべての関数はプロセス/接頭引数の習慣 (*Note Process/Prefix::) を、
『一つの記事』を『一つの群』と解釈する拡張をして、どの記事に操作をする
かを見つけるために使います。Gnus は自分自身でどの記事がその群に属してい
るかを判断し、すべての記事をデコードして、その結果のファイルを展開/表示
/保存することができます。

Gnus は以下の簡単な規則に則ってどの記事が群に属するのかを推測します: 表
題は行の最後の二つの数字を除いて (ほとんど) 同じである必要があります。
(空白は大体無視されますが。)

例えば: `cat.gif (2/3)' というような表題を選ぶと、Gnus は正規表現
`^cat.gif ([0-9]+/[0-9]+).*$' に合致するすべての記事を見つけようとしま
す。

`cat.gif (2/3) Part 6 of a series' のような標準でない表題はどの自動表示
命令によっても適切に認識されないため、手で記事に `#' の印を付けなければ
なりません。



File: gnus-ja.info, Node: Uuencoded Articles, Next: Shell Archives, Prev: Decoding Articles, Up: Decoding Articles

uuencode された記事
-------------------

`X u'
     現在の群を uudecode します (`gnus-uu-decode-uu')。

`X U'
     現在の群を uudecode して保存します (`gnus-uu-decode-uu-and-save')。

`X v u'
     現在の群を uudecode して、表示します (`gnus-uu-decode-uu-view')。

`X v U'
     現在の記事を uudecode して、表示して保存します
     (`gnus-uu-decode-uu-and-save-view')。

これらはすべて、プロセス印が付けられた記事に対して反応するということを
覚えておいてください。例えばニュースグループ全体をデコードして保存した
いのであれば、例によって `M P a' (`gnus-uu-mark-all') に続いて `X U'
(`gnus-uu-decode-uu-and-save') を実行してください。

このすべては、白日の下にいちいちキーを打っていた GNUS 4.1 のときの
`gnus-uu' の動作とはまったく違っています。一般にこの版の `gnus-uu' は、
何かの方法 (*Note Setting Process Marks::) で記事に印を付け、それから
`X u' を押すことを前提としています。

注意: 定数 `gnus-uu-notify-files' (値が
`[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)' にハードコードされています)
に合致する名前を持つ記事をデコードしようとすると、あなたが問題の記事を
今まさに見たことをバラすために、`gnus-uu' は自動的に
`comp.unix.wizards' に記事を投稿します。この機能を使わないようにするこ
とはできません (訳注: そんな Cindy Crawford 嬢の写真がニュースで大量に
流れていた、まだ WWW がロクに普及していなかった時代の産物です)。



File: gnus-ja.info, Node: Shell Archives, Next: PostScript Files, Prev: Uuencoded Articles, Up: Decoding Articles

シェルアーカイブ
----------------

シェルアーカイブ (『shar ファイル』) はソースを配布するための人気のある
方法でしたが、今日ではそんなに使われていません。とにかくこれらを扱うた
めの命令があります:

`X s'
     現在の群を解凍します (`gnus-uu-decode-unshar')。

`X S'
     現在の群を解凍して保存します (`gnus-uu-decode-unshar-and-save')。

`X v s'
     現在の群を解凍して表示します (`gnus-uu-decode-unshar-view')。

`X v S'
     現在の群を解凍し、表示して保存します
     (`gnus-uu-decode-unshar-and-save-view')。



File: gnus-ja.info, Node: PostScript Files, Next: Other Files, Prev: Shell Archives, Up: Decoding Articles

ポストスクリプトファイル
------------------------

`X p'
     現在のポストスクリプト群を展開します
     (`gnus-uu-decode-postscript')。

`X P'
     現在のポストスクリプト群を展開して保存します
     (`gnus-uu-decode-postscript-and-save')。

`X v p'
     現在のポストスクリプト群を表示します
     (`gnus-uu-decode-postscript-view')。

`X v P'
     現在のポストスクリプト群を表示して保存します
     (`gnus-uu-decode-postscript-and-save-view')。



File: gnus-ja.info, Node: Other Files, Next: Decoding Variables, Prev: PostScript Files, Up: Decoding Articles

他のファイル
------------

`X o'
     現在の記事群を保存します (`gnus-uu-decode-save')。

`X b'
     現在の記事群を binhex で解凍します (`gnus-uu-decode-binhex')。これ
     はまだ実際には動作しません。

`X Y'
     現在の記事群を yEnc でデコードして保存します
     (`gnus-uu-decode-yenc')。



File: gnus-ja.info, Node: Decoding Variables, Next: Viewing Files, Prev: Other Files, Up: Decoding Articles

デコードのための変数
--------------------

形容詞です。動詞ではありません。

* Menu:

* Rule Variables::              ファイルがどのように表示されるかを決める変数
* Other Decode Variables::      他のデコードのための変数
* Uuencoding and Posting::      uuencode するのをカスタマイズする変数



File: gnus-ja.info, Node: Rule Variables, Next: Other Decode Variables, Prev: Decoding Variables, Up: Decoding Variables

規則変数
........

Gnus はファイルをどうやって表示するかを決めるために「規則変数」を使いま
す。これらの変数はすべて以下のような様式です。

           (list '(regexp1 command2)
                 '(regexp2 command2)
                 ...)

`gnus-uu-user-view-rules'
     この変数はファイルを表示するときに最初に調べられます。例えば、もし
     `.au' 音響ファイルを変換するために `sox' を使いたいときは、次のよ
     うに設定することができます:

          (setq gnus-uu-user-view-rules
                (list '("\\\\.au$\" "sox %s -t .aiff > /dev/audio")))

`gnus-uu-user-view-rules-end'
     この変数は Gnus が利用者とディフォルトの表示規則から合致するものを
     見つけることができなかったときに調べられます。

`gnus-uu-user-archive-rules'
     この変数はアーカイブを展開するときにどの命令が使われるべきかを決め
     るために使うことができます。



File: gnus-ja.info, Node: Other Decode Variables, Next: Uuencoding and Posting, Prev: Rule Variables, Up: Decoding Variables

他のデコードのための変数
........................


`gnus-uu-grabbed-file-functions'
     これは関数のリストです。すぐにファイルを移動したり表示することを可
     能にし、何かができるようになる前にすべてのファイルがデコードされる
     のを待つ必要が無いように、それぞれのファイルのデコードに成功した直
     後にそれらの関数が呼ばれます。このリストに入れることができる既製の
     関数は以下の通りです:

     `gnus-uu-grab-view'
          ファイルを表示します。

     `gnus-uu-grab-move'
          ファイルを移動します (もし保存関数を使っているのであれば)。

`gnus-uu-be-dangerous'
     デコードの最中に異常な状況が起こったときに何をするかを指定します。
     もし `nil' であると、できるだけ保守的になります。もし `t' であると、
     動作しないものは無視して、現存するファイルを上書きします。その他の
     場合は、それぞれのときに尋ねます。

`gnus-uu-ignore-files-by-name'
     この正規表現に合致する名前のファイルは表示されません。

`gnus-uu-ignore-files-by-type'
     この変数に合致する MIME の型を持つファイルは表示されません。Gnus
     はファイル名に基づいて型を推測していることに注意してください。
     `gnus-uu' は (まだ) MIME パッケージではないので、これは少々お行儀
     が悪いものです。

`gnus-uu-tmp-dir'
     `gnus-uu' がその仕事をする場所です。

`gnus-uu-do-not-unpack-archives'
     `nil' でないと、`gnus-uu' は表示するためのファイルを探すためにアー
     カイブの中身までは見ません。

`gnus-uu-view-and-save'
     `nil' でないと、利用者はファイルを表示した後で常に保存するかどうか
     を尋ねられます。

`gnus-uu-ignore-default-view-rules'
     `nil' でないと、`gnus-uu' はディフォルトの表示規則を無視します。

`gnus-uu-ignore-default-archive-rules'
     `nil' でないと、`gnus-uu' はディフォルトのアーカイブ展開命令を無視
     します。

`gnus-uu-kill-carriage-return'
     `nil' でないと、`gnus-uu' は記事からすべてのキャリッジリターンを取
     り去ります。

`gnus-uu-unmark-articles-not-decoded'
     `nil' でないと、`gnus-uu' はデコードに失敗した記事に未読の印を付け
     ます。

`gnus-uu-correct-stripped-uucode'
     `nil' でないと、`gnus-uu' は後続の空白が削除されてしまっている
     uuencode されたファイルを修復しようと *試み* ます。

`gnus-uu-pre-uudecode-hook'
     メッセージを `uudecode' に送る前に実行されるフックです。

`gnus-uu-view-with-metamail'
     `nil' でないと、`gnus-uu' は規則変数で定義された表示命令を無視して、
     ファイル名に基づいた MIME Content-Type をでっちあげます。その結果
     は表示のために `metamail' にかけられます。

`gnus-uu-save-in-digest'
     `nil' でないと、デコードせずに保存することを指示されたときに、
     `gnus-uu' は要約 (digest) を保存します。この変数が `nil' であると、
     `gnus-uu' は何も加工を施さずにすべてを一つのファイルに保存します。
     要約の作成は概ね RFC1153 に準拠していますが、意味のある目次を付け
     る簡単な方法が見つからなかったので、私はそれらを単に落としました。



File: gnus-ja.info, Node: Uuencoding and Posting, Prev: Other Decode Variables, Up: Decoding Variables

uuencode と投稿
...............

`gnus-uu-post-include-before-composing'
     `nil' でないと、`gnus-uu' は記事を作成する前にエンコードするファイ
     ルを尋ねます。この変数が `t' であると、`C-c C-i' によってエンコー
     ドされたファイルを取り込むか、記事を投稿するときに取り込むかのどち
     らかをすることができます。

`gnus-uu-post-length'
     記事の最大の長さです。エンコードされたファイルは全体のファイルを投
     稿するのに必要な量のファイルに分割されます。

`gnus-uu-post-threaded'
     `nil' でないと、`gnus-uu' はエンコードされたファイルをスレッドで投
     稿します。これはあまり賢い方法ではないかもしれません。というのは、
     今まで私が見た中で uuencode された記事を集めるのに、スレッドを追っ
     ていくことのできる他のデコーダーが存在しないからです。(えーと、私
     はそれをする一つのパッケージを見たことがあります---`gnus-uu' です。
     しかしどうも、それが数のうちに入るとは思えないのです...) ディフォ
     ルトは `nil' です。

`gnus-uu-post-separate-description'
     `nil' でないと、説明文は別の記事で投稿されます。最初の記事は普通
     (0/x) のように番号が付けられます。もしこの変数が `nil' であると、
     利用者の書いた説明分は最初のファイルの始めに取り込まれ、(1/x) の番
     号が付けられます。ディフォルトは `t' です。



File: gnus-ja.info, Node: Viewing Files, Prev: Decoding Variables, Up: Decoding Articles

ファイルの表示
--------------

デコードした後でファイルが何らかのアーカイブである場合、Gnus はアーカイ
ブを展開しようと試み、アーカイブの中に表示できるファイルがあるかどうか
を調べます。例えば、gzip された tar ファイル `pics.tar.gz' があって、ファ
イル `pic1.jpg' と `pic2.gif' を含んでいる場合、Gnus は主ファイルを解凍
して tar を展開し、それから二つの絵を表示します。この展開の過程は再帰的
なので、アーカイブにアーカイブのアーカイブがあると、それはすべて展開さ
れます。

最後に、Gnus は普通はそれぞれの抽出された記事ごとに「疑似記事」を概略バッ
ファーに挿入します。これらの『記事』に移動した場合は、実行する命令 (普
通は Gnus が提案をします) を入力するように促され、それからその命令が実
行されます。

`gnus-view-pseudo-asynchronously' が `nil' であると、Emacs は先へ進む前
に表示の終了を待ちます。

`gnus-view-pseudos' が `automatic' であると、Gnus は概略バッファーに疑
似記事を挿入せず、それらをすぐに表示します。この変数が `not-confirm' で
あると、利用者は表示が済む前に確認さえも求められません。

`gnus-view-pseudos-separately' が `nil' でないと、表示されるそれぞれの
ファイルにつき一つの疑似記事が作成されます。`nil' であると、同じ表示命
令を使うすべての命令がその命令の引数のリストとして渡されます。

`gnus-insert-pseudo-articles' が `nil' でないと、デコードのときに疑似記
事を挿入します。ディフォルトでは `t' です。

さて、あなたはそんなふうに *仮想サーバー* の *仮想グループ* にある *疑
似記事* を読むことになるわけです。どうしてすべてが現実ではなくなってし
まったんでしょうか?  どうしてこんなところに来てしまったんでしょうか?



File: gnus-ja.info, Node: Article Treatment, Next: MIME Commands, Prev: Decoding Articles, Up: Summary Buffer

記事のトリートメント
====================

この巨大な説明文書を読んできて、人々の著作を読むことがニュースリーダー
の本当の目的だったことを、すっかり忘れてしまったかもしれません。記事を
読むことです。残念ながら人々は書くことがとても苦手ですが、記事を読みや
すくするための関数と変数は山のようにあります。

* Menu:

* Article Highlighting::        記事をフルーツサラダのようにしたい
* Article Fontisizing::         強調された文を素敵にする
* Article Hiding::              特定の情報は消し去りたいとも思う
* Article Washing::             人生をもっとよくするたくさんの気の利いた関数
* Article Header::              ヘッダーをいろいろ変形させる
* Article Buttons::             URL や Message-ID やアドレスなどをクリックする
* Article Button Levels::       ボタンの見え方を制御する
* Article Date::                ぐずぐず言うな、世界時だ!
* Article Display::             X-Face, Picons, Smileys を表示する
* Article Signature::           署名って何?
* Article Miscellanea::         他のいろいろなもの



File: gnus-ja.info, Node: Article Highlighting, Next: Article Fontisizing, Prev: Article Treatment, Up: Article Treatment

記事のハイライト
----------------

記事バッファーをフルーツサラダのように、いや総天然色のフルーツサラダの
ようにしたくありませんか。

`W H a'
     現在の記事をもっとハイライトします。この関数は、ヘッダー、引用文、
     署名をハイライトし、本文とヘッダーにボタンを加えます。

`W H h'
     ヘッダーをハイライトします (`gnus-article-highlight-headers')。ハ
     イライトは変数 `gnus-header-face-alist' に従って行なわれ、それはそ
     れぞれの要素が `(正規表現 名前 内容)' という様式のリストです。正規
     表現 はヘッダーに合致する正規表現、名前 はヘッダーの名前をハイライ
     トするのに使われるフェース (*Note Faces and Fonts::)、内容 はヘッ
     ダーの値をハイライトするフェースです。最初に合致したものが使われま
     す。正規表現 の先頭に `^' を付けてはいけないことに注意してくださ
     い--Gnus がそれを付け加えます。

`W H c'
     引用された文をハイライトします
     (`gnus-article-highlight-citation')。

     引用文のハイライトをカスタマイズする変数は次の通りです:

     `gnus-cite-parse-max-size'
          記事の大きさがこの変数 (ディフォルトでは 25000) のバイト数よ
          り大きい記事は、引用文のハイライトが行なわれません。

     `gnus-cite-max-prefix'
          引用符の最大の長さです (ディフォルトでは 20 です)。

     `gnus-cite-face-list'
          引用文をハイライトするために使われるフェースのリストです
          (*Note Faces and Fonts::)。同じメッセージの中に複数の記事から
          の引用があると、Gnus はそれぞれの記事からの引用をそれ用のフェー
          スで表示しようとします。これにより、誰が何を書いたかが分かり
          やすくなるでしょう。

     `gnus-supercite-regexp'
          普通の Supercite 著者行に合致する正規表現です。

     `gnus-supercite-secondary-regexp'
          引き裂かれた Supercite 著者行に合致する正規表現です。

     `gnus-cite-minimum-match-count'
          それが引用文であると判定する前に調べなければならない引用符の
          最小の数です。

     `gnus-cite-attribution-prefix'
          著者行の始まりに合致する正規表現です。

     `gnus-cite-attribution-suffix'
          著者行の終りに合致する正規表現です。

     `gnus-cite-attribution-face'
          著者行に使われるフェースです。その著者が書いた文の引用のため
          のフェースと融合されます。

     `gnus-cite-ignore-quoted-from'
          非-`nil' だったら、`>From ' で始まる行で引用文のハイライトは
          行なわれません。それらの行は、エンベロープ From 行と混同しな
          いように、MTA がクオートした可能性があります。ディフォルト値
          は `t' です。

`W H s'
     署名 (signature) をハイライトします
     (`gnus-article-highlight-signature')。`gnus-signature-separator'
     (*Note Article Signature::) の後のすべてのものは署名であると解釈さ
     れ、`gnus-signature-face' でハイライトされます。それはディフォルト
     では `italic' です。

記事を自動的にハイライトする方法については *Note Customizing
Articles:: を参照してください。



File: gnus-ja.info, Node: Article Fontisizing, Next: Article Hiding, Prev: Article Highlighting, Up: Article Treatment

記事中の文の強調表示
--------------------

(訳注: Fontisize == Fontify + Emphasize)

人々はよくニュースの記事で `_これ_' や `*これ*' または `/これ/' のよう
なものを使って単語を強調します。Gnus は記事を `W e' 命令
(`gnus-article-emphasize') にかけることによって素敵に見えるようにできま
す。

強調がどのように処理されるかは変数 `gnus-emphasis-alist' によって制御さ
れます。これは連想リストで、最初の要素は合致するべき正規表現です。二番
目の要素は、正規表現の中のどのグループが強調語全体を見つけるために使わ
れるかを示す数値です。三番目は正規表現のどのグループが表示されハイライ
トされるかを決める数値です。(この二つのグループの間にあるテキストは隠さ
れます。) 四番目はハイライトさせるためののフェースです。

     (setq gnus-emphasis-alist
           '(("_\\(\\w+\\)_" 0 1 gnus-emphasis-underline)
             ("\\*\\(\\w+\\)\\*" 0 1 gnus-emphasis-bold)))

(訳注: 上記の変数の値は、ディフォルトのままにしておくのが無難です。)


ディフォルトでは七つの規則があり、それらは以下のフェースを用います:
`gnus-emphasis-bold', `gnus-emphasis-italic',
`gnus-emphasis-underline', `gnus-emphasis-bold-italic',
`gnus-emphasis-underline-italic',
`gnus-emphasis-underline-bold',
`gnus-emphasis-underline-bold-italic'。

これらのフェースを変更したいのであれば、`M-x customize' か `copy-face'
を使うことができます。例えば `gnus-emphasis-italic' が代わりに赤のフェー
スを使うようにしたいのならば、次のようにすれば良いでしょう:

     (copy-face 'red 'gnus-emphasis-italic)

任意の語を強調表示させたいときは、`gnus-group-highlight-words-alist' 変
数を使うことができます。これは `gnus-emphasis-alist' と同じ構文を使いま
す。`highlight-words' グループパラメーター (*Note Group Parameters::)
を使うこともできます。

記事を自動的に強調表示させるやり方については *Note Customizing
Articles:: を参照してください。



File: gnus-ja.info, Node: Article Hiding, Next: Article Washing, Prev: Article Fontisizing, Up: Article Treatment

記事を隠す
----------

と言うよりはむしろ、記事の中にある特定のものを隠すことです。たいていの
記事には、普通はありすぎるくらいのごみがあります。

`W W a'
     記事バッファーでたくさんのものを隠します (`gnus-article-hide')。特
     にこの関数はヘッダー、PGP、引用文、それに署名を隠します。

`W W h'
     ヘッダーを隠します (`gnus-article-hide-headers')。
     *Note Hiding Headers::.

`W W b'
     あまり興味の持てないヘッダーを隠します
     (`gnus-article-hide-boring-headers')。*Note Hiding Headers::.

`W W s'
     署名を隠します (`gnus-article-hide-signature')。
     *Note Article Signature::.

`W W l'
     `gnus-list-identifiers' で指定されているメーリングリストの標識を削
     除します。これらはいくつかのメーリングリストのサーバーがすべて
     の `Subject' ヘッダーの最初に付ける文字列、例え
     ば `[zebra 4711]' のようなものです。文字列の初めにあ
     る `Re: ' は、削除を行なう前に跳び越されます。
     `gnus-list-identifiers' に `\\(..\\)' を含めてはいけません。

     `gnus-list-identifiers'
          表題から削除されるべきメーリングリストの標識に合致する正規表
          現です。これは正規表現のリストであることもできます。

`W W P'
     不要な PEM (privacy enhanced messages (プライバシー拡張メッセージ))
     の部分を隠します (`gnus-article-hide-pem')。

`W W B'
     `banner' グループパラメーターで指定されたバナーを取り除きます
     (`gnus-article-strip-banner')。これは主に、いくつかのメーリングリ
     ストや司会者付きのグループがすべての記事に追加する、欝陶しいバナー
     と/ もしくは署名を隠すために使用されます。この関数を使う方法は
     `banner' グループパラメーター (*Note Group Parameters::) をバナー
     を取り除きたいグループに追加することです。パラメーターは、消去され
     るテキストに合致する正規表現として解釈される文字列か、(最後の) 署
     名を消去するためのシンボル `signature'、または
     `gnus-article-banner-alist' の正規表現に対応した他のシンボルのいず
     れかであることができます。

     グループにかかわらず、記事の送信者が
     `gnus-article-address-banner-alist' で設定されている特定のメールア
     ドレスを持っているときだけ、広告のようなものを隠すことができます。

     `gnus-article-address-banner-alist'
          メールアドレスとバナーの連想リストです。それぞれの要素は
          `(ADDRESS . BANNER)' の形式を持ち、ここで ADDRESS は From ヘッ
          ダーにあるメールアドレスに合致する正規表現です。また、BANNER
          はシンボル `signature'、`gnus-article-banner-alist' の要素、
          正規表現または `nil' のうちの一つです。ADDRESS が著者のメール
          アドレスに合致すると、広告のようなものを消します。例えば、送
          信者が `hail@yoo-hoo.co.jp' というメールアドレスを持っていて、
          彼が送信するすべての記事に `Do You Yoo-hoo!?' のようなものが
          ある場合、以下の要素でそれらを消すことができます。

               ("@yoo-hoo\\.co\\.jp\\'" . "\n_+\nDo You Yoo-hoo!\\?\n.*\n.*\n")

`W W c'
     引用文を隠します (`gnus-article-hide-citation')。隠蔽をカスタマイ
     ズするいくつかの変数は:

     `gnus-cited-opened-text-button-line-format'
     `gnus-cited-closed-text-button-line-format'
          Gnus はどこの引用文が隠されているかを示すためにボタンを付け加
          え、文章の隠蔽を切り替えられるようにします。この変数の様式は、
          以下のフォーマットのような変数によって指定されます (*Note
          Formatting Variables::)。次の指定が有効です:

          `b'
               隠された文の最初のポイントです。
          `e'
               隠された文の最後のポイントです。
          `l'
               隠されたリージョンの文字の数です。
          `n'
               隠された文の行の数です。

     `gnus-cited-lines-visible'
          隠さずに表示しておく、引用文の先頭からの行数です。これは、隠
          さずに表示する先頭からの行と、隠さずに表示する末尾からの行の、
          それぞれの数の cons セルであることもできます。

`W W C-c'
     以下の二つの変数に依存して、引用文を隠します
     (`gnus-article-hide-citation-maybe'):

     `gnus-cite-hide-percentage'
          引用文の割合のパーセンテージが、この変数 (ディフォルトは 50)
          より大きかったら、引用文を隠します。

     `gnus-cite-hide-absolute'
          隠される前に、引用文は少なくともこの長さ (ディフォルトは 10)
          でなければなりません。

`W W C'
     根本でない記事の引用文を隠します
     (`gnus-article-hide-citation-in-followups')。これは対話的命令とし
     てはあまり役に立たないかもしれませんが、自動的に実行させるには手軽
     な関数でしょう (*Note Customizing Articles::)。

これらのすべての『隠蔽』命令は切り替え命令ですが、これらの命令に負の接
頭引数を与えると、それらは前に隠されていたものを表示します。正の接頭引
数を与えれば、それらは常に隠します。

引用文をカスタマイズするためのさらなる変数について、
*Note Article Highlighting:: も参照してください。

自動的に記事の要素を隠すための方法は *Note Customizing Articles:: を参
照してください。



File: gnus-ja.info, Node: Article Washing, Next: Article Header, Prev: Article Hiding, Up: Article Treatment

記事の洗濯
----------

私たちはこれをもっともな理由の下で『記事の洗濯』(article washing) と呼
んでいます。`A' キーは使われていたので、代わりに `W' キーを使う必要があ
りました。

「洗濯」は『何かの何かを何か別のものに変換する』と定義されますが、普通
はもっと良く見える何かに落ち着きます。もっときれいになります、たぶん。

Gnus が記事を表示するディフォルトのやり方を変えたいときは *Note
Customizing Articles:: を参照してください。

`C-u g'
     これは洗濯ではなくて、その逆です。これをタイプすると、ディスクやサー
     バーにあるがままの記事が見えます。

`g'
     現在の記事の再表示を強制します (`gnus-summary-show-article')。これ
     もまた本当の洗濯ではありません。これをタイプすると、以前に適用され
     た対話的な洗濯機能はご破算にされ、すべてのディフォルトのトリートメ
     ントを施された記事が表示されます (*Note Customizing Articles::)。

`W l'
     ページの区切りを現在の記事から取り除きます
     (`gnus-summary-stop-page-breaking')。ページの区切りに付いては
     *Note Misc Article:: を参照してください。

`W r'
     記事バッファーでカエサル変換 (Caesar rotate, rot13) を行ないます
     (`gnus-summary-caesar-message')。カエサル変換か rot13 を用いて読む
     ことを指定する、判読不可能な記事です (典型的には攻撃的な冗談などで
     す。)

     普通は“rot13”と呼ばれています。それはアルファベットの位置が 13
     個回転するからです。例えば、`B' (2 番目の文字) → `O' (15 番目の文
     字)。これは時々『カエサル変換』と呼ばれることもあります。というの
     は、カエサルがこの形式の、えーと、いささか貧弱な暗号化を採用したと
     いう噂があるからです。

`W m'
     記事バッファーをモールスでデコードします
     (`gnus-summary-morse-message')。

`W i'
     現在の記事にある IDNA エンコードされたドメイン名をデコードします。
     IDNA エンコードされたドメイン名は `xn--bar' のように見えます。これ
     を実行した後で文字列がデコードされないままだったら、おそらくそれは
     不正な IDNA 文字列でしょう (`xn--bar' は不正です)。このコマンドを
     動かすためには、GNU Libidn
     (`http://www.gnu.org/software/libidn/') をインストールしていなけれ
     ばなりません。

`W t'
`t'
     記事バッファーにすべてのヘッダーを表示するかどうかを切り替えます
     (`gnus-summary-toggle-header')。

`W v'
     記事バッファーにすべてのヘッダーを永続的に表示するかどうかを切り替
     えます (`gnus-summary-verbose-headers')。

`W o'
     オーバーストライクを処理します (`gnus-article-treat-overstrike')。

     訳注: 以下のような重ね打ちを指示する文字列を bold や underline で
     表示します。

     `B^HBo^Hol^Hld^Hd', `U^H_n^H_d^H_e^H_r^H_l^H_i^H_n^H_e^H_'

`W d'
     `gnus-article-dumbquotes-map' に応じて、マ■■■ソ■■
     sm*rtq**t*s を処理します。この関数は文字が sm*rtq**t* かどうかを推
     測するので、対話的にのみ使用されるべきであることに注意してください。

     Sm*rtq**t*s はもっと多くの引用文字を提供するために、マ■■■ソ■■
     が勝手に文字マップを拡張したものです。もし、アポストロフィ (') や
     引用記号 (") などがあるべきところに `\222' や `\264' のようなもの
     が見えてしまったら、洗濯してみてください。

`W Y f'
     いかれた Outlook (Express) の記事を完全に醜くなくすること (訳注:
     de-ugly-fy) (sm*rtq**t*s を処理、行の折り返しを解除、著者行の修復
     と引用文の整頓) をします。
     (`gnus-article-outlook-deuglify-article')。

`W Y u'
     折り返された引用行のように見える行の折り返しを解きます。折り返しが
     解かれた行の最小および最大の長さを表す
     `gnus-outlook-deuglify-unwrap-min' および
     `gnus-outlook-deuglify-unwrap-max' を調整することによって、どんな
     行の折り返しが解かれるかを制御することができます。
     (`gnus-article-outlook-unwrap-lines')。

`W Y a'
     壊れた著者行を修復します。
     (`gnus-article-outlook-repair-attribution')。

`W Y c'
     壊れた引用文を、テキストを整理し直すことによって修復します。
     (`gnus-article-outlook-rearrange-citation')。

`W w'
     行を折り返します (`gnus-article-fill-cited-articles')。

     折り返す幅を指定するために、命令に数値接頭引数を与えることができま
     す。

`W Q'
     長い行を折り返します (`gnus-article-fill-mode-lines')。

`W C'
     それぞれの文の最初の語を大文字にします
     (`gnus-article-capitalize-sentences')。

`W c'
     CRLF の組 (すなわち、行の最後の `^M') を LF に変換します (これは
     DOS の行末の世話をします)。そうしてから残りの CR を LF に変換しま
     す (これは MAC の行末の世話をします) (`gnus-article-remove-cr')。

     Quoted-printable を処理します
     (`gnus-article-de-quoted-unreadable')。Quoted-Printable は
     非-ASCII (すなわち 8-bit) の記事を送るときに使われる一般的な MIME
     エンコーディングです。それは概して `d,Aij,A` vu' のようなものを
     `d=E9j=E0 vu' に見せるので、とても読み辛くなります。問題の記事が、
     そのエンコーディングが行なわれたことを示す
     `Content-Transfer-Encoding' ヘッダーを持っていれば、通常それは
     Gnus によって自動的に行なわれることに注意してください。接頭引数が
     与えられると、文字セットが尋ねられます。

`W 6'
     Base64 をデコードします (`gnus-article-de-base64-unreadable')。
     Base64 は非-ASCII (すなわち 8-bit) の記事を送るときに使われる、一
     般的な MIME エンコーディングです。問題の記事が、そのエンコーディン
     グが行なわれたことを示す `Content-Transfer-Encoding' ヘッダーを持っ
     ていれば、通常それは Gnus によって自動的に行なわれることに注意して
     ください。接頭引数が与えられると、文字セットが尋ねられます。

`W Z'
     HZ または HZP を処理します。HZ (または HZP) は中国語の記事を伝送す
     るときに使われる一般的な符号です。これは
     `~{<:Ky2;S{#,NpJ)l6HK!#~}' のような典型的な文字列を作ります。

`W A'
     ANSI SGR シーケンスを overlay または extent に変換します
     (`gnus-article-treat-ansi-sequences')。ANSI シーケンスは中国語の
     ニュースグループで強調表示に使われています。

`W u'
     URL に含まれる改行を削除します。いくつかのメイラーは、行を短くする
     ために出ていくメールに改行を挿入しますが、これは長い URL を複数の
     行に分割してしまいます。改行を削除することによって、それらの URL
     を復旧させます (`gnus-article-unsplit-urls')。

`W h'
     HTML を処理します。当該メッセージが HTML であることを示す
     `Content-Type' ヘッダーを持っていたならば、それは Gnus によって自
     動的に行なわれることに注意してください。

     接頭引数が与えられると、文字セットを尋ねられます。それがもし数値だっ
     たら、`gnus-summary-show-article-charset-alist' (*Note Paging the
     Article::) で定義されている文字セットが使われます。(訳注: 実質的に
     は「文字セット」ではなくて `coding-system' です。)

     ディフォルトでは HTML の変換に `mm-text-html-renderer' (*Note 表示
     のカスタマイズ: (emacs-mime-ja)Display Customization.) で設定され
     た関数を使いますが、変数 `gnus-article-wash-function' が設定されて
     いると、記事の洗濯ではそれが優先されます。使うことができる、あらか
     じめ用意された関数は以下の通りです:

     `w3'
          Emacs/W3 を使います。

     `w3m'
          emacs-w3m (http://emacs-w3m.namazu.org/) を使います。

     `w3m-standalone'
          w3m (http://w3m.sourceforge.net/) を使います。

     `links'
          Links (http://links.sf.net/) を使います。

     `lynx'
          Lynx (http://lynx.isc.org/) を使います。

     `html2text'
          html2text (シンプルな HTML コンバーターで、Gnus に含まれてい
          ます) を使います。

     訳注: 例えば `mm-text-html-renderer' を `w3m' などに設定してあって
     正しく動作するのならば、`gnus-article-wash-function' はディフォル
     トの `nil' のままにしておいて構いません。

`W b'
     クリックできるボタンを記事に加えます (`gnus-article-add-buttons')。
     *Note Article Buttons::.

`W B'
     クリックできるボタンを記事のヘッダーに加えます
     (`gnus-article-add-buttons-to-head')。

`W p'
     署名付きコントロールメッセージの認証を行ないます
     (`gnus-article-verify-x-pgp-sig')。`newgroup' や `checkgroups' と
     いったコントロールメッセージは、通常そのニュースグループ階層のメイ
     ンテイナーによって署名されています。認証を行なうためには、メインテ
     イナーの PGP 公開鍵をあなたのキーリングに追加しなければなりません。
     (1) (*Note Article Washing-Footnotes::)

`W s'
     署名されたメッセージ (PGP, PGP/MIME または S/MIME によって) を検証
     します (`gnus-summary-force-verify-and-decrypt')。*Note
     Security::.

`W a'
     記事の本文の先頭から `X-No-Archive' ヘッダーのようなヘッダーを取り
     除きます (`gnus-article-strip-headers-in-body')。

`W E l'
     記事の先頭にあるすべての空白行を取り除きます
     (`gnus-article-strip-leading-blank-lines')。

`W E m'
     すべての空白行を空行で置き換えてから、すべての複数の空行を一つの空
     行で置き換えます (`gnus-article-strip-multiple-blank-lines')。

`W E t'
     記事の最後にあるすべての空白行を取り除きます
     (`gnus-article-remove-trailing-blank-lines')。

`W E a'
     上の三つの命令をすべて実行します
     (`gnus-article-strip-blank-lines')。

`W E A'
     すべての空白行を取り除きます
     (`gnus-article-strip-all-blank-lines')。

`W E s'
     記事の本文のすべての行頭にあるすべての空白を取り除きます
     (`gnus-article-strip-leading-space')。

`W E e'
     記事の本文のすべての行末にあるすべての空白を取り除きます
     (`gnus-article-strip-trailing-space')。

自動的に記事の洗濯を行なわせる方法は *Note Customizing Articles:: を参
照してください (訳注: 実は多くの洗濯がディフォルトで自動的に行なわれま
す)。


File: gnus-ja.info  Node: Article Washing-Footnotes, Up: Article Washing

(1) 多くのニュースグループ階層のメインテイナーの PGP の
鍵は `ftp://ftp.isc.org/pub/pgpcontrol/README.html' から入手
することができます。



File: gnus-ja.info, Node: Article Header, Next: Article Buttons, Prev: Article Washing, Up: Article Treatment

記事ヘッダー
------------

これらのコマンドは記事ヘッダーをいろいろに変形させます。

`W G u'
     折り返されたヘッダー行を一行にします
     (`gnus-article-treat-unfold-headers')。

`W G n'
     `Newsgroups' と `Followup-To' ヘッダーを折り返します
     (`gnus-article-treat-fold-newsgroups')。

`W G f'
     すべてのメッセージヘッダーを折り返します
     (`gnus-article-treat-fold-headers')。

`W E w'
     すべてのヘッダーから余分な空白を取り除きます
     (`gnus-article-remove-leading-whitespace')。



File: gnus-ja.info, Node: Article Buttons, Next: Article Button Levels, Prev: Article Header, Up: Article Treatment

記事のボタン
------------

人々はよく記事の中に他の資料を参照するための案内を入れることがあります
が、それらの参照への案内の上で `RET' を打つか、マウスの真中のボタンを使っ
たときに、彼らが話題にしているのが何であれ、最小限の曖昧さで Gnus が取
得することができれば素敵でしょう。

特定の標準的な参照に、Gnus はディフォルトで「ボタン」を付けます: ちゃん
とした URL、メールアドレス、Message-ID、Info へのリンク、man ページ、そ
れに関連する Emacs または Gnus の参考文献です。これは二つの変数によって
制御されていて、その一つは記事の本文を扱い、もう一つは記事のヘッダーを
扱います。

`gnus-button-alist'
     それぞれの要素が次のような様式を持つ連想リストです:

          (REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)

     REGEXP
          この正規表現 (大文字と小文字は区別されません) に合致するすべ
          てのテキストは、外部への参照であるとみなされます。これは埋め
          込まれた URL に合致する典型的な正規表現です:
          `<URL:\\([^\n\r>]*\\)>'。これはまた正規表現の値を持つ変数であっ
          てもよく、有用な変数として `gnus-button-url-regexp' および
          `gnus-button-mid-or-mail-regexp' があります。

     BUTTON-PAR
          Gnus は合致したもののどの部分がハイライトされるのかを知らなけ
          ればなりません。これは正規表現のどの副表現がハイライトされる
          かを指定する番号です。すべてをハイライトしたいのなら、ここで
          0 を使ってください。

     USE-P
          この式は `評価' され、結果が `nil' でなかったら、これは合致で
          あるとみなされます。これは間違った合致を避けるために特別な選
          別をしたいときに役に立ちます。ここではしばしば
          `gnus-button-*-level' のような名前の変数が使われますが、
          *Note Article Button Levels::, 他のどんな形式でも使うことがで
          きます。

     FUNCTION
          この関数が、このボタンをクリックしたときに呼ばれます。

     DATA-PAR
          BUTTON-PAR のように、これは部分表現の番号ですが、これは合致の
          どの部分が FUNCTION にデータとして送られるかを指定します。

     したがって URL をボタンにする完全な要素は、こうなります。

          ("<URL:\\([^\n\r>]*\\)>" 0 t gnus-button-url 1)

`gnus-header-button-alist'
     これは他の連想リストと同じようなものですが、記事のヘッダーだけに適
     用されることと、それぞれの項目がどのヘッダーにボタンを付けるかを指
     示するための追加の要素を持っていることが異なります:

          (HEADER REGEXP BUTTON-PAR USE-P FUNCTION DATA-PAR)

     HEADER は正規表現です。


関連する変数と関数
..................

`gnus-button-*-level'
     *Note Article Button Levels:: を参照してください。

`gnus-button-url-regexp'
     埋め込まれた URL に合致する正規表現です。上述の変数のディフォルト
     の値で使われます。

`gnus-button-man-handler'
     Man ページの表示に使う関数です。少なくとも一つの引数として Man ペー
     ジの名前の文字列を受け付けなければなりません。

`gnus-button-mid-or-mail-regexp'
     Message-ID かメールアドレスに合致する正規表現です。

`gnus-button-prefer-mid-or-mail'
     この変数は `foo123@bar.invalid' のような文字列のボタンが押されたと
     きに、何を行なうかを決める変数です。このような文字列は Message-ID
     かメールアドレスのいずれかです。もし `mid' か `mail' というシンボ
     ルのうちの一つだったら、Gnus は常にそれぞれ文字列が Message-ID ま
     たはメールアドレスであると仮定します。この変数が `ask' というシン
     ボルに設定されると、Gnus はいつも利用者が何をしたいかを尋ねます。
     それが関数だった場合、たった一つの文字列を引数として呼ばれます。そ
     の関数は `mid'、`mail'、`invalid' または `ask' を返さなければなり
     ません。ディフォルト値は関数 `gnus-button-mid-or-mail-heuristic'
     です。

`gnus-button-mid-or-mail-heuristic'
     その引数が Message-ID かメールアドレスであるかを推定する関数です。
     Message-ID だったら `mid' を、メールアドレスだったら `mail' を、不
     確かだったら `ask' を、そして無効な文字列だったら `invalid' を返し
     ます。

`gnus-button-mid-or-mail-heuristic-alist'
     関数 `gnus-button-mid-or-mail-heuristic' で使われる `(RATE
     . REGEXP)' 対の連想リストです。

`gnus-button-ctan-handler'
     CTAN リンクの表示に使う関数です。URL 名の文字列を、引数として一つ
     受け付けなければなりません。

`gnus-ctan-url'
     `gnus-button-ctan-handler' で使われる CTAN (Comprehensive TeX
     Archive Network) アーカイブのディレクトリーです。

`gnus-article-button-face'
     ボタンに使われるフェースです。

`gnus-article-mouse-face'
     マウスのカーソルがボタンの上にあるときに使われるフェースです。

記事に自動的にボタンを付ける方法は、*Note Customizing Articles:: を参照
してください。



File: gnus-ja.info, Node: Article Button Levels, Next: Article Date, Prev: Article Buttons, Up: Article Treatment

Article button levels
---------------------

変数 `gnus-button-*-level' の値が高いほど、より多くのボタンが現れます。
レベルがゼロだったらボタンは表示されません。ディフォルト値 (それは 5)
では、とてもたくさんのボタンをすでに見ているはずです。高いレベルではよ
り多くのボタンを見ることになりますが、多くの要らないものも現れるかもし
れません。それらを避けるために、特定のグループに対して変数
`gnus-button-*-level' を設定しても良いでしょう (*Note Group
Parameters::)。`gnus-parameters' 変数の例です:

     ;; いくつかのグループで `gnus-button-*-level' を増やす:
     (setq gnus-parameters
           '(("\\<\\(emacs\\|gnus\\)\\>" (gnus-button-emacs-level 10))
             ("\\<unix\\>"               (gnus-button-man-level 10))
             ("\\<tex\\>"                (gnus-button-tex-level 10))))

`gnus-button-browse-level'
     Message-ID、メールアドレスおよびニュースの URL を参照する案内の表示を制
     御します。関連する変数と関数には `gnus-button-url-regexp'、
     `browse-url' および `browse-url-browser-function' があります。

`gnus-button-emacs-level'
     Emacs または Gnus への参照の表示を制御します。関連する関数は、
     `gnus-button-handle-custom',
     `gnus-button-handle-describe-function',
     `gnus-button-handle-describe-variable',
     `gnus-button-handle-symbol', `gnus-button-handle-describe-key',
     `gnus-button-handle-apropos',
     `gnus-button-handle-apropos-command',
     `gnus-button-handle-apropos-variable',
     `gnus-button-handle-apropos-documentation' および
     `gnus-button-handle-library' です。

`gnus-button-man-level'
     (Unix の) man ページへの参照の表示を制御します。
     `gnus-button-man-handler' を見てください。

`gnus-button-message-level'
     Message-ID、メールアドレスおよびニュースの URL の表示を制御します。
     関連する変数と関数には `gnus-button-mid-or-mail-regexp',
     `gnus-button-prefer-mid-or-mail',
     `gnus-button-mid-or-mail-heuristic' および
     `gnus-button-mid-or-mail-heuristic-alist' があります。

`gnus-button-tex-level'
     TeX または LaTex への参照、例えば CTAN の URL の表示を制御します。
     変数 `gnus-ctan-url', `gnus-button-ctan-handler',
     `gnus-button-ctan-directory-regexp' および
     `gnus-button-handle-ctan-bogus-regexp' を見てください。



File: gnus-ja.info, Node: Article Date, Next: Article Display, Prev: Article Button Levels, Up: Article Treatment

記事の日付
----------

日付は聞いたことの無い何か辺鄙なタイムゾーンで作成されていることが良く
あるので、記事が送られたときに何時だったかを知ることができるのはとても
良いことです。

`W T u'
     UT (別名 GMT, ZULU) で日付を表示します (`gnus-article-date-ut')。

`W T i'
     日付を国際的な形式、ISO 8601 で表示します
     (`gnus-article-date-iso8601')。

`W T l'
     日付をローカル・タイムゾーンで表示します
     (`gnus-article-date-local')。

`W T p'
     日付を英語で楽に発音できる形式で表示します
     (`gnus-article-date-english')。

`W T s'
     日付を利用者定義の様式を使って表示します
     (`gnus-article-date-user')。その様式は変数
     `gnus-article-time-format' で指定される、`format-time-string' に渡
     される文字列です。指定することができる様式の一覧は、変数の説明文を
     見てください。

`W T e'
     記事が投稿されてから今までどれくらいの時間が経過したかを表示します
     (`gnus-article-date-lapsed')。こんなふうに。

          X-Sent: 6 weeks, 4 days, 1 hour, 3 minutes, 8 seconds ago

     `gnus-article-date-lapsed-new-header' の値で、このヘッダーを既存の
     Date の下に追加するか、置き替えるかを指定します。

     Gnus でメールを読むことの利点は、それが単純なバグを素晴らしい不条
     理に置き換えることです。

     この行が連続して更新されるようにしたいのであれば、

          (gnus-start-date-timer)

     を `~/.gnus.el' ファイルに入れるか、それを何かのフックで実行するよ
     うにすることができます。タイマーを止めたい場合は、
     `gnus-stop-date-timer' 命令を使ってください。

`W T o'
     本来の日付を表示します (`gnus-article-date-original')。これはあな
     たが普段は他の変換関数を使っていて、それが完全に間違ったことをして
     いるのではないかと心配になったときに役に立ちます。例えば、記事が
     1854年に投稿されたと主張したとしましょう。しかし、そのようなことは
     *完全に * 不可能です。私が信用できませんか? *くすくす*

好みの書式で自動的に日付を表示する方法は *Note Customizing Articles::
を参照してください。



File: gnus-ja.info, Node: Article Display, Next: Article Signature, Prev: Article Date, Up: Article Treatment

Article Display
---------------

これらのコマンドは、いろんな取るに足らないギミック (gimmicks) の表示を、
それらをサポートしている Emacs の記事バッファーに追加します。

`X-Face' ヘッダーは小さな白黒画像で、メッセージヘッダーから持ってきます
(*Note X-Face::)。

`Face' ヘッダーは小さなカラー画像で、メッセージヘッダーから持ってきます
(*Note Face::)。

スマイリーは、人々がメッセージに散らかしたがる小さな `:-)' シンボルです。

一方 Picon はあなた自身のシステムに依存し、Gnus はヘッダーに合致するあ
なたの持ち物を探してみます (*Note Picons::)。

これらすべての機能はトグルです。もしすでにそれらが存在していたならば、
それらは削除されます。

`W D x'
     `X-Face' を `From' ヘッダーに表示します
     (`gnus-article-display-x-face')。

`W D d'
     `Face' を `From' ヘッダーに表示します
     (`gnus-article-display-face')。

`W D s'
     スマイリーを表示します (`gnus-treat-smiley')。

`W D f'
     `From' ヘッダーを Picon 化します (`gnus-treat-from-picon')。

`W D m'
     すべてのメールヘッダー (すなわち `Cc'、`To') を Picon 化します
     (`gnus-treat-mail-picon')。

`W D n'
     すべてのニュースヘッダー (すなわち `Newsgroups' と `Followup-To')
     を Picon 化します (`gnus-treat-newsgroups-picon')。

`W D D'
     記事バッファーからすべての画像を削除します
     (`gnus-article-remove-images')。



File: gnus-ja.info, Node: Article Signature, Next: Article Miscellanea, Prev: Article Display, Up: Article Treatment

記事の署名
----------

それぞれの記事は二つの部分に分けられます--ヘッダーと本文です。本文は署
名部分と文章部分に分けることができます。どれが署名とみなされるかを決め
る変数は `gnus-signature-separator' です。これは普通は son-of-RFC 1036
で規定されている標準の `^-- $' です。しかし、多くの人が標準ではない署名
セパレーターを使うので、この変数は一つ一つ試される、正規表現のリストで
あることもできます。(探索は本文の最後から始めへとなされます。) よくあり
そうな値は:

     (setq gnus-signature-separator
           '("^-- $"         ; 標準
             "^-- *$"        ; 普通の崩し方
             "^-------*$"    ; 多くの人は長ーーい横棒の
                             ; 行を使います。みっともない!
             "^ *--------*$" ; 二倍みっともない!
             "^________*$"   ; 下線も人気があります
             "^========*$")) ; 邪道!

あなたが寛容であればあるほど、間違った結果を得ることになるでしょう。

`gnus-signature-limit' は記事を表示するときにどれが署名とみなされるかへ
の制限を提供します。

  1. これが整数であれば、署名はこの整数より (文字数で) 長くなっていては
     いけません。
  2. これが浮動小数点数であれば、署名はその数値より (行数で) 長くなって
     いてはいけません。
  3. これが関数であれば、その関数は引数なしで呼ばれ、それが `nil' を返
     せば、そのバッファーには署名がありません。
  4. これが文字列であれば、それは正規表現として使われます。もしそれが合
     致すれば、当のその文字列は署名ではありません。

この変数は、要素が上に列挙された型のリストであることもできます。例です:

     (setq gnus-signature-limit
           '(200.0 "^---*Forwarded article"))

これは署名セパレーターの後に 200 を超える行があるか、セパレーターの後の
テキストが正規表現 `^---*Forwarded article' に合致すれば、結局それは署
名ではないということです。



File: gnus-ja.info, Node: Article Miscellanea, Prev: Article Signature, Up: Article Treatment

記事いろいろ
------------

`A t'
     記事をある言語から別のものへ変換します (`gnus-article-babel')。



File: gnus-ja.info, Node: MIME Commands, Next: Charsets, Prev: Article Treatment, Up: Summary Buffer

MIME コマンド
=============

以下のコマンドはすべて数値接頭引数を理解します。例えば `3 K v' は「三番
目の MIME パートを表示する」という意味です。

`b'
`K v'
     MIME パートを表示します。

`K o'
     MIME パートを保存します。

`K O'
     ファイル名の入力を求めてから MIME パートを保存し、それを記事から取
     り除きます。取り除かれた MIME オブジェクトは
     message/external-body 型の MIME 形式として参照されるようになります。

`K r'
     MIME パートを外部にある本体で置き換えます。

`K d'
     MIME パートを削除して、削除したことの案内を追加します。

`K c'
     MIME パートをコピーします。

`K e'
     MIME パートを外部コマンドで表示します。

`K i'
     MIME パートをバッファー内に表示します。

`K |'
     MIME パートを外部コマンドにパイプします。

以降の MIME コマンドの残りは、数値接頭引数を同じやり方では使いません:

`K H'
     現在の記事の `text/html' パートを WWW ブラウザーで見ます。接頭引数
     が与えられなければ、すべての html パートの先頭に記事のヘッダーが加
     えられます。

     警告: Spammers は HTML 記事中の画像へのリンクを、あなたがその記事
     を読んだかどうかを確かめるために使います。このコマンドは HTML 記事
     からその手の "web bugs" を取り除かないでブラウザーに渡すので、この
     コマンドは信頼できる送信者からのメールでだけ使うべきです。

     HTML を常にブラウザーで表示したいのであれば、
     `mm-text-html-renderer' を `nil' に設定してください。

`K b'
     すべての MIME パートの先頭にボタンを付加します。埋め込まれたパート
     をセーブ (または他の動作を実行) しようとするときに、たいてい便利で
     す。

`K m'
     ときたま、ヘッダーが無かったり間違ったヘッダーを持つマルチパートの
     メッセージが送信されてきます。このコマンドは、それらのメッセージが
     より快適に表示されるように「修復」を試みます
     (`gnus-summary-repair-multipart')。

`X m'
     MIME タイプに合致するすべてのパートを、ディレクトリーにセーブしま
     す (`gnus-summary-save-parts')。プロセス/接頭引数の習慣を理解しま
     す (*Note Process/Prefix::)。

`M-t'
     記事バッファーにボタンを表示するかしないかを切り替えまます
     (`gnus-summary-toggle-display-buttonized')。

`W M w'
     記事ヘッダーにある RFC 2047 でエンコードされた語をデコードします
     (`gnus-article-decode-mime-words')。

`W M c'
     エンコードされた記事の本文を、文字セットでデコードします
     (`gnus-article-decode-charset')。

     このコマンドは、文字セットを決めるために `Content-Type' ヘッダーを
     調べます。記事にそんなヘッダーが無い場合でも、接頭引数を与えること
     によって、デコードするための文字セットを入力することは可能です。あ
     る共通のエンコーディングを使って (でも MIME ヘッダーは含めずに) 人々
     が記事を投稿する地域的なグループでは、`charset' グループ/トピック・
     パラメーターに必要な文字セットを設定すれば良いでしょう (*Note
     Group Parameters::)。

`W M v'
     現在の記事にある、すべての MIME パートを表示します
     (`gnus-mime-view-all-parts')。

関連する変数:

`gnus-ignored-mime-types'
     これは正規表現のリストで、これに含まれている正規表現に合致する
     MIME タイプは、Gnus によって完全に無視されます。ディフォルト値は
     `nil' です。

     すべての Vcard を無視させるには、こんなふうにしてください:

          (setq gnus-ignored-mime-types
                '("text/x-vcard"))

`gnus-article-loose-mime'
     非-`nil' だったら、Gnus は記事を MIME メッセージとして解読する前に、
     `MIME-Version' があることを必要としません。これは、ある壊れたメー
     ル・ユーザー・エージェントからのメッセージを読むときに役立ちます。
     ディフォルトは `t' です。

`gnus-article-emulate-mime'
     MIME ではない別のエンコーディングの手法があります。最も一般的なの
     は `uuencode' ですが、yEncode も普及してきています。この変数が
     非-`nil' になっていると、Gnus はメッセージの本文にそれらのエンコー
     ディングが見つかるかどうかを調べ、もしあったならば、それらを Gnus
     の MIME 機構で処理します。ディフォルトは `t' です。デコードできる
     のは単一の yEnc でエンコードされたパートだけです。Gnus はエンコー
     ドについてはサポートしません。

`gnus-unbuttonized-mime-types'
     これは正規表現のリストで、これに含まれている正規表現に合致する
     MIME タイプには、ボタンが付加されません。ただし、それらが表示され
     ないか、`gnus-buttonized-mime-types' 変数の方が優先される場合を除
     いて、ですが。ディフォルト値は `(".*/.*")' です。この変数は
     `gnus-inhibit-mime-unbuttonizing' が `nil' のときだけ使われます。

`gnus-buttonized-mime-types'
     これは正規表現のリストで、これに含まれている正規表現に合致する
     MIME タイプには、それらが表示されない場合を除いて、ボタンが付加さ
     れます。この変数は `gnus-unbuttonized-mime-types' よりも優先されま
     す。ディフォルト値は `nil' です。この変数は
     `gnus-inhibit-mime-unbuttonizing' が `nil' のときだけ使われます。

     例えば、セキュリティーのボタンだけを表示して、他のボタンを表示しな
     いようにするには、この変数を `("multipart/signed")' に設定して、
     `gnus-unbuttonized-mime-types' はディフォルト値のままにしておいて
     ください。

     また、このリストに `"multipart/alternative"' を加えることによって、
     そういうメールに含まれている二つのメディア・タイプのうちの一つを選
     ぶことができる、ラジオボタンを表示させることができます。
     `mm-discouraged-alternatives' も参照してください (*Note 表示のカス
     タマイズ: (emacs-mime-ja)Display Customization.)。

`gnus-inhibit-mime-unbuttonizing'
     これが非-`nil' だと、すべての MIME パートにボタンを付加します。ディ
     フォルト値は `nil' です。

`gnus-article-mime-part-function'
     それぞれの MIME パートに対して、この関数が MIME ハンドル (訳注: パー
     トのタイプや内容物を表現するために、Gnus の内部で使われるデータの
     構造体) を引数にして呼ばれます。この関数は、利用者が記事から情報を
     集め (例えば Vcard の情報を bbdb のデータベースに加え) たり、パー
     トに基づいて何かを起動 (例えば、すべての jpeg をあるディレクトリー
     にセーブ) するために使われることが意図されています。

     後者を行なう関数の例です:

          (defun my-save-all-jpeg-parts (handle)
            (when (equal (car (mm-handle-type handle)) "image/jpeg")
              (with-temp-buffer
                (insert (mm-get-part handle))
                (write-region (point-min) (point-max)
                              (read-file-name "Save jpeg to: ")))))
          (setq gnus-article-mime-part-function
                'my-save-all-jpeg-parts)

`gnus-mime-multipart-functions'
     MIME マルチパートの型と、それらを扱う関数の連想リストです。

`gnus-mime-display-multipart-alternative-as-mixed'
     "multipart/alternative" のパートを "multipart/mixed" であるものと
     して表示します。

`gnus-mime-display-multipart-related-as-mixed'
     "multipart/related" のパートを "multipart/mixed" であるものとして
     表示します。

     もし `text/html' を表示するのが気に入らないのなら、
     `mm-discouraged-alternatives' を参照してください。ただし (それで
     text/html" を表示しないように設定して、かつ) この変数が `nil' だと、
     multipart/related" パートの中にある画像や他の資料を見逃してしまう
     かもしれません。*Note 表示のカスタマイズ: (emacs-mime-ja)Display
     Customization.

`gnus-mime-display-multipart-as-mixed'
     "multipart" のパートを "multipart/mixed" であるものとして表示しま
     す。もし `t' だと、
     `gnus-mime-display-multipart-alternative-as-mixed' および
     `gnus-mime-display-multipart-related-as-mixed' が `nil' であっても、
     この設定の方が優先されます。

`mm-file-name-rewrite-functions'
     MIME パートのファイル名を書き換えるために使われる関数のリストです。
     それぞれの関数はファイル名を受け取って、ファイル名を返します。

     出来合いの関数は
     `mm-file-name-delete-whitespace',
     `mm-file-name-trim-whitespace',
     `mm-file-name-collapse-whitespace' およ
     び `mm-file-name-replace-whitespace' です。最後のものはファイル名に
     含まれるそれぞれの空白文字を、変
     数 `mm-file-name-replace-whitespace' の値で置き換えます。ディフォル
     ト値は `"_"' (単一の下線) です。

     標準の関数である `capitalize', `downcase', `upcase' および
     `upcase-initials' も、役に立つでしょう。

     ファイル名に含まれる空白文字が害をもたらすことは、みんなが知ってい
     ます。ただし、気にかけない人たちを除いて、ですが。そんな蒙昧の人た
     ちから、たくさんの添付ファイルを受け取るのであれば、こんなものを
     `~/.gnus.el' ファイルに追加することによって、安寧な生活を送ること
     ができるでしょう。

          (setq mm-file-name-rewrite-functions
                '(mm-file-name-trim-whitespace
                  mm-file-name-collapse-whitespace
                  mm-file-name-replace-whitespace))



File: gnus-ja.info, Node: Charsets, Next: Article Commands, Prev: MIME Commands, Up: Summary Buffer

文字セット
==========

人々はいろいろな文字セットを使いますが、私たちは彼らが何の文字セットを
使っているかを教えてくれる MIME を持っています。あるいはもっと正確に言
えば、持っていたらいいなあと思います。多くの人たちが MIME を利用しない
か理解しないニュースリーダーとメイラーを使って、何の文字セットを使うか
を言わずに、単にメッセージを送出するのですが、これを少しばかり救済する
ために、いくつかの地域的なニュース階層には、何の文字セットがディフォル
トであるかを宣言する取り決めがあります。例えば `fj' 階層では
`iso-2022-jp' を使っています。

この知識は `gnus-group-charset-alist' 変数にエンコードされています。こ
れは正規表現 (グループのフルネームに合致した最初の項目を使います) と、
それらのグループを講読するときに使われるディフォルトの文字セットの、連
想リストです。

加えて、人々のいくらかは MIME を意識していると自称 (soi-disant) してい
るくせに、実はそうではないエージェントを使っています。それらは、実際に
はメッセージが `koi-8' なのに `iso-8859-1' だと、陽気にメッセージに刻印
するのです。ここでは救済のために `gnus-newsgroup-ignored-charsets' 変数
を使うことができます。そのリストに連ねられた文字セットは無視されます。
この変数は、グループパラメーター (*Note Group Parameters::) を使って、
グループ毎に設定することができます。ディフォルト値は `(unknown-8bit
x-unknown)' で、それはいくつかのエージェントが内蔵し、主張する値を含ん
でいます。

投稿する場合に、MIME でエンコードしてはいけない文字セットを判定するため
に、`gnus-group-posting-charset-alist' が使われます。例えばいくつかの階
層では、quoted-printable でヘッダーをエンコードすることは嫌われます。

この変数は正規表現と、投稿に際してエンコードしなくても良いことを許され
た (またはエンコードすることが嫌われる) 文字セットの連想リストです。そ
れぞれの要素は `('TEST HEADER BODY-LIST`)' の形式であり、それらは次の意
味を持ちます。

TEST
     Newsgroups ヘッダーに合致する正規表現、または変数シンボルのどちら
     かです。後者の場合は、その値を調べた結果が非-`nil' だったら、その
     要素が採用されることになります。
HEADER
     ヘッダーをエンコードしなくても良い文字セットです (`nil' は、すべて
     の文字セットをエンコードすることを意味します)。
BODY-LIST
     “Content-Transfer-Encoding: 8bit”でもって本文をエンコードしても
     良い (または quoted-printable や base64 でエンコードすることが嫌わ
     れる) 文字セットのリスト、または特別な値の一つである `nil' (常に
     quoted-printable でエンコードする)、または `t' (常に
     “Content-Transfer-Encoding: 8bit”を使う) です。

メッセージを送信するときに何の文字セットが使われるかを制御する付加的な
変数については、*Note エンコーディングのカスタマイズ:
(emacs-mime-ja)Encoding Customization, を参照してください (訳注: 特に日
本語のメッセージの文字セットについては、例えば変数
`mm-coding-system-priorities' を参照してください)。

Gnus 固有ではないけれど、役に立つかもしれない文字セットに関する他の秘訣:

もし、同一の Emacs の文字セットをエンコードする MIME の文字セットが複数
あるのならば、以下の宣言を使うことによって、使う文字セットを選択するこ
とができます:

     (put-charset-property 'cyrillic-iso8859-5
                           'preferred-coding-system 'koi8-r)

これは、ロシア語がディフォルトの `iso-8859-5' MIME 文字セットの代わりに、
`koi8-r' でエンコードされることを意味します。

メッセージを `koi8-u' で読みたいのであれば、以下のように騙すことができ
ます。

     (define-coding-system-alias 'koi8-u 'koi8-r)

これは、ほとんど正しいことをするでしょう。

そして最後に、`windows-1251' のような文字セットを読むには、次のよう
に宣言すれば良いでしょう (訳注: Emacs の版によっては、
`windows-1251' が最初から実装されています)。

     (codepage-setup 1251)
     (define-coding-system-alias 'windows-1251 'cp1251)



File: gnus-ja.info, Node: Article Commands, Next: Summary Sorting, Prev: Charsets, Up: Summary Buffer

記事命令
========

`A P'
     記事バッファーのポストスクリプト (PostScript) イメージを作成して印
     刷します (`gnus-summary-print-article')。`gnus-ps-print-hook' がバッ
     ファーを印刷する直前に実行されます。他に Muttprint を使って印刷す
     ることもできます (*Note Saving Articles::)。



File: gnus-ja.info, Node: Summary Sorting, Next: Finding the Parent, Prev: Article Commands, Up: Summary Buffer

概略の並べ替え
==============

私はどうしてあなたがそうしたいのかはわからないのですが、それでもあなた
はたくさんの方法で概略バッファーを並べ替えることができます。

`C-c C-s C-n'
     記事番号によって並べ替えます (`gnus-summary-sort-by-number')。

`C-c C-s C-m C-n'
     最新の記事番号によって並べ替えます
     (`gnus-summary-sort-by-most-recent-number')。

`C-c C-s C-a'
     著者によって並べ替えます (`gnus-summary-sort-by-author')。

`C-c C-s C-t'
     受信者によって並べ替えます (`gnus-summary-sort-by-recipient')。

`C-c C-s C-s'
     表題によって並べ替えます (`gnus-summary-sort-by-subject')。

`C-c C-s C-d'
     日付によって並べ替えます (`gnus-summary-sort-by-date')。

`C-c C-s C-m C-d'
     最新の日付によって並べ替えます
     (`gnus-summary-sort-by-most-recent-date')。

`C-c C-s C-l'
     行数によって並べ替えます (`gnus-summary-sort-by-lines')。

`C-c C-s C-c'
     記事の長さ (文字数) で並べ替えます (`gnus-summary-sort-by-chars')。

`C-c C-s C-i'
     スコアによって並べ替えます (`gnus-summary-sort-by-score')。

`C-c C-s C-r'
     ランダムに並べ替えます (`gnus-summary-sort-by-random')。

`C-c C-s C-o'
     ディフォルトの方法で並べ替えます
     (`gnus-summary-sort-by-original')。

これらの関数はスレッドを使っているときと使っていないときの両方で動作し
ます。後者では、すべての概略行が一行一行並べ替えられます。前者では根本
だけに基づいて並べ替えられ、それはあなたが求めていることとは異なってい
るかもしれません。スレッドを使うかどうかを切り替えるには `T T' を打って
ください (*Note Thread Commands::)。

接頭引数を与えると並べ替えの順序が逆になります。



File: gnus-ja.info, Node: Finding the Parent, Next: Alternative Approaches, Prev: Summary Sorting, Up: Summary Buffer

親記事を探す
============

`^'
     現在の記事の親記事を読みたいのに、それが概略バッファーに表示されて
     いなくても、おそらくそれは可能でしょう。というのは、現在のグループ
     が NNTP で取得されていて、親がまだ期限切れ消去されていない上、現在
     の記事の `References' がぶち壊されていなければ、ただ `^' か `A r'
     を押せば良いだけですから (`gnus-summary-refer-parent-article')。す
     べてがうまくいけば、親記事を取得できるでしょう。もし親記事がすでに
     概略バッファーに表示されているのであれば、ポイントがその記事に移動
     するでしょう。

     正の数値接頭引数を与えられると、その数の祖先たちを遡って取得します。
     負の数値接頭引数が与えられた場合は、その数の世代だけ前の祖先の記事
     のみを取得します。ですから `3 ^' とすれば、Gnus は現在の記事の親と
     祖父母と曾祖父母を取得します。`-3 ^' とすれば、Gnus は現在の記事の
     曾祖父母だけを取得します。

`A R (概略)'
     記事の `References' 欄にあるすべての記事を取得します
     (`gnus-summary-refer-references')。

`A T (概略)'
     現在の記事があるスレッドの、全部の記事を表示します
     (`gnus-summary-refer-thread')。この命令は動作するために現在のグルー
     プのすべてのヘッダーを取得しなければならないので、普通は少し時間が
     かかります。これをしばしば行なうのであれば、
     `gnus-fetch-old-headers' を `invisible' に設定することを考えたほう
     が良いでしょう (*Note Filling In Threads::)。これは普通は視覚的な
     効果はありませんが、この命令の動作をかなり速くします。もちろんグルー
     プに入るのはいくらか遅くなりますが。

     変数 `gnus-refer-thread-limit' はこの命令を実行するときにどのくら
     い古い (すなわち、現在のグループで最初に表示されたものよりも前の記
     事の) ヘッダーを取得するかを指定します。ディフォルトは 200 です。
     もし `t' であれば、取得可能なすべてのヘッダーを取得します。`A T'
     命令に数値接頭引数を与えると、代わりにそれが使われます。

`M-^ (概略)'
     どのグループに属しているかに関わらず、任意の記事を Gnus に要求する
     ことができます。`M-^' (`gnus-summary-refer-article') は
     `Message-ID'、つまりあの長くてなかなか読むことのできない
     `<38o6up$6f2@hymir.ifi.uio.no>' のようなものをあなたに尋ねます。あ
     なたはすべてを正確に打ち込まなければなりません。残念ながら、あいま
     いな検索はできないのです。

     Gnus はすでに取得してあるヘッダーたちの中で `Message-ID' を探しま
     すが、見つからなかったら `gnus-refer-article-method' に設定されて
     いるすべての選択方法を試してもみます。

もしあなたの読んでいるグループが `Message-ID' での取得があまり良くでき
ないようなバックエンド (`nnspool' など) であるのなら、
`gnus-refer-article-method' を NNTP の選択方法に設定すれば良いでしょう。
おそらく、あなたが問い合わせる NNTP サーバーがあなたの読んでいるスプー
ルを更新していると最も良いでしょう。しかし、それはどうしても必要なわけ
ではありません。

それは選択方法のリストのみならず、現在の選択方法を意味する特別なシンボ
ル `current' であることもできます。Gnus は合うものを発見するまでそれら
すべての方法を試します。

これは現在の選択方法を試して、それが失敗した場合には Google に訊く設定
の例です:

     (setq gnus-refer-article-method
           '(current
             (nnweb "google" (nnweb-type google))))

ほとんどのメールバックエンドは `Message-ID' での取得が可能ですが、あま
り優雅な方法でやっているわけではありません。`nnmbox', `nnbabyl',
`nnmaildir' および `nnml' がどのグループからでも記事を捜索できるのに対
して、`nnfolder' と `nnimap' は現在のグループに投稿された記事しか探すこ
とができません。(その他のものは時間がかかりすぎます。) `nnmh' ではまっ
たく不可能です。



File: gnus-ja.info, Node: Alternative Approaches, Next: Tree Display, Prev: Finding the Parent, Up: Summary Buffer

代替手段
========

ニュースを読む方法の好みは人それぞれです。これは Gnus なのですから、概
略バッファーのためのマイナーモードに少しばかり選択肢を設けます。

* Menu:

* Pick and Read::               まず、記事に印を付けて、それから読む
* Binary Groups::               すべての記事を自動デコードする



File: gnus-ja.info, Node: Pick and Read, Next: Binary Groups, Prev: Alternative Approaches, Up: Alternative Approaches

選んで読む
----------

いくつかのニュースリーダー (`nn' や、ええと VM/CMS の `Netnews' など)
は二段階の講読インターフェースを使います。利用者はまず概略バッファーで
読みたい記事に印を付けます。それから、記事バッファーだけを表示して記事
を読みます。

Gnus はこれをするための概略バッファーマイナーモードを提供しま
す---`gnus-pick-mode' です。これは、基本的には簡単に印を付けられるよう
に少数のプロセス印命令を一個のキーだけで済む命令にして、概略バッファー
へ切り替えるための追加の命令を一つ提供します。

     訳注: Pick マイナーモードを有効にするには、以下のフックを使ってく
     ださい:

          (add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)

     そうせずに、概略バッファーに入ってから `M-x gnus-pick-mode' を実行
     しても、うまくいかないようです。

これらが pick mode で使うことができるキーです:

`.'
     現在の行の記事かスレッドを選択します
     (`gnus-pickd-article-or-thread')。変数 `gnus-thread-hide-subtree'
     が非-`nil' だったら、このキーがスレッドの最初の記事で使われるとス
     レッド全体を選択します。そうでなければ、その記事だけを選択します。
     もし数値接頭引数を与えられると、その番号のスレッドか記事に移動して、
     それを選択します。(普通は行番号が概略行の最初に表示されます。)

`SPACE'
     概略バッファーを一ページ次にスクロールします
     (`gnus-pick-next-page')。もしバッファーの最後であれば、選択した記
     事を読み始めます。

`u'
     スレッドか記事を未選択にします
     (`gnus-pick-unmark-article-or-thread')。変数
     `gnus-thread-hide-subtree' が非-`nil' だったら、このキーがスレッド
     の最初で使われるとそのスレッドを未選択にします。そうでなければ、そ
     の記事だけを未選択にします。その行にあるスレッドか記事を未選択にす
     るために、このキーに数値接頭引数を与えることができます。

`RET'
     選択された記事を読み始めます (`gnus-pick-start-reading')。接頭引数
     が与えられると、最初にすべての未選択記事に既読の印を付けます。
     `gnus-pick-display-summary' が `nil' でないと、概略バッファーは読
     んでいる間も表示されます。

すべての普通の概略モード命令は pick-mode でも使用可能ですが、`u' は例外
です。それでも、同じ関数 `gnus-summary-tick-article-forward' に割り当て
られている `!' を使うことができます。

これが良さそうだと思ったら、次のようにしてください:

     (add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)

`gnus-pick-minor-mode-hook' は pick マイナーモードのバッファーで実行さ
れます。

`gnus-mark-unpicked-articles-as-read' が非-`nil' だったら、選択されなかっ
たすべての記事に既読の印を付けます。ディフォルトは `nil' です。

pick モードでの概略行の様式は標準の様式とは少し違います。それぞれの行の
最初に行数が表示されます。Pick モードの行の様式は変数
`gnus-summary-pick-line-format' で制御されます (*Note Formatting
Variables::)。これは `gnus-summary-line-format' と同じ様式指定を受け付
けます (*Note Summary Buffer Lines::)。



File: gnus-ja.info, Node: Binary Groups, Prev: Pick and Read, Up: Alternative Approaches

バイナリーグループ
------------------

多くの時間をバイナリーグループで過ごしているのなら、いつも `X u', `n',
`RET' を叩くのが嫌になっているでしょう。`M-x gnus-binary-mode' は、単に
記事を普通の方法で表示する代わりに、記事を選択するための普通の Gnus の
関数を、一連の記事を uudecode してその結果を表示するように変更する、概
略バッファーのためのマイナーモードです。

現実には、このモードにしたときに、実際に記事を見るための唯一の命令が
`g' です (`gnus-binary-show-article')。

`gnus-binary-mode-hook' がバイナリーマイナーモードのバッファーで呼ばれ
ます。



File: gnus-ja.info, Node: Tree Display, Next: Mail Group Commands, Prev: Alternative Approaches, Up: Summary Buffer

木表示
======

もし普通の Gnus の概略表示を好きでないならば、`gnus-use-trees' を `t'
に設定してみると良いかもしれません。これは (ディフォルトで) 追加の「木
バッファー」(tree buffer) を作成します。木バッファーではすべての概略モー
ド命令を実行することができます。

もちろん、木表示をカスタマイズする変数が少しあります:

`gnus-tree-mode-hook'
     すべての木モードのバッファーで実行されるフックです。

`gnus-tree-mode-line-format'
     木モードのバッファーにおけるモード行のためのフォーマット文字列です
     (*Note Mode Line Formatting::)。ディフォルトは `Gnus: %%b %S %Z'
     です。使用可能な指定は *Note Summary Buffer Mode Line:: を参照して
     ください。

`gnus-selected-tree-face'
     木バッファーで選択された記事をハイライトするために使われるフェース
     です。ディフォルトでは `modeline' です。

`gnus-tree-line-format'
     木の節のためのフォーマット文字列です。でもこれは少し誤った名称で
     す--それは行ではなく、ただ節を定義するだけです。ディフォルトの値は
     `%(%[%3,3n%]%)' で、それは投稿者の名前の最初の三文字を表示します。
     すべての節が同じ長さであることが重要なので、`%4,4n' のような指定を
     *使わなければなりません*。

     有効な指定は:

     `n'
          投稿者の名前。
     `f'
          `From' 欄。
     `N'
          記事の番号。
     `['
          開き括弧。
     `]'
          閉じ括弧。
     `s'
          表題。

     *Note Formatting Variables::.

     表示に関連した変数は:

     `gnus-tree-brackets'
          これは『本当の』記事と『まばら』な記事に違いを付けるために使
          われます。様式は

               ((本当の開 . 本当の閉)
                (まばら開 . まばら閉)
                (偽の開 . 偽の閉))

          となっていて、ディフォルトは `((?[ . ?]) (?( . ?)) (?{ . ?})
          (?< . ?>))' です。

     `gnus-tree-parent-child-edges'
          これは親の節を子に接続するために使われる文字を含むリストです。
          ディフォルトは `(?- ?\\ ?|)' です。

`gnus-tree-minimize-window'
     もしこの変数が `nil' でないと、他の Gnus ウィンドウがもっと場所を
     取れるように Gnus は木バッファーをできるだけ小さくします。もしこの
     変数が数値であると、木バッファーの高さはその数値より大きくなること
     はありません。ディフォルトは `t' です。フレームでいくつかのウィン
     ドウが横に並んで表示されていて、木バッファーがそのうちの一つである
     場合、木ウィンドウを最小化することはその隣に表示されているすべての
     ウィンドウの大きさをも変更することに注意してください。

     以下のフックを追加して、いつでも木ウィンドウを最小化するようにして
     も良いでしょう。

          (add-hook 'gnus-configure-windows-hook
                    'gnus-tree-perhaps-minimize)

`gnus-generate-tree-function'
     実際にスレッドの木を作成する関数です。二つの定義済みの関数
     `gnus-generate-horizontal-tree' および
     `gnus-generate-vertical-tree' (これがディフォルトです) が利用可能
     です。

水平木バッファー (horizontal tree buffer) の例です:

     {***}-(***)-[odd]-[Gun]
          |      \[Jan]
          |      \[odd]-[Eri]
          |      \(***)-[Eri]
          |            \[odd]-[Paa]
          \[Bjo]
          \[Gun]
          \[Gun]-[Jor]

同じスレッドが垂直木バッファー (vertical tree buffer) で表示されたもの
です:

     {***}
       |--------------------------\-----\-----\
     (***)                         [Bjo] [Gun] [Gun]
       |--\-----\-----\                          |
     [odd] [Jan] [odd] (***)                   [Jor]
       |           |     |--\
     [Gun]       [Eri] [Eri] [odd]
                               |
                             [Paa]

もし水平木を使っているのなら、概略バッファーで木を隣り合わせで表示でき
れば嬉しいでしょう。次のようなものを `~/.gnus.el' ファイルに加えること
ができます:

     (setq gnus-use-trees t
           gnus-generate-tree-function 'gnus-generate-horizontal-tree
           gnus-tree-minimize-window nil)
     (gnus-add-configuration
      '(article
        (vertical 1.0
                  (horizontal 0.25
                              (summary 0.75 point)
                              (tree 1.0))
                  (article 1.0))))

*Note Window Layout::.



File: gnus-ja.info, Node: Mail Group Commands, Next: Various Summary Stuff, Prev: Tree Display, Up: Summary Buffer

メールグループ命令
==================

いくつかの命令はメールグループでのみ意味を持ちます。これらの命令が現在
のグループで有効でないなら、それらは大騒ぎをしてあなたに知らせるでしょ
う。

これらすべての命令は (期限切れ消去と編集命令は除く) プロセス/接頭引数の
習慣を使います (*Note Process/Prefix::)。

`B e'
     現在のグループのすべての期限切れ消去可能な記事について、期限切れ消
     去の処理 (`gnus-summary-expire-articles') を行ないます。これは、そ
     のグループにしばらく存在していた期限切れ消去可能なすべての記事を消
     去するということです。(*Note Expiring Mail::)。

`B C-M-e'
     グループのすべての期限切れ消去可能な記事を削除します
     (`gnus-summay-expire-articles-now')。これは、現在のグループにある
     *すべて* の期限切れ消去可能な記事が、永遠に空の大きな `/dev/null'
     へ消え去るということです。

`B DEL'
     メール記事を削除します。これは『あなたのディスクから永久に削除して
     二度と戻らない』の意味の『削除』です。注意して使ってください
     (`gnus-summary-delete-article')。

`B m'
     あるメールグループから別のメールグループへ記事を移動します
     (`gnus-summary-move-article')。`gnus-preserve-marks' の値が `nil'
     でなければ (それがディフォルト)、印は保存されます。

`B c'
     あるグループ (メールグループや他のもの) からメールグループに記事を
     コピーします (`gnus-summary-copy-article')。`gnus-preserve-marks'
     の値が `nil' でなければ (それがディフォルト)、印は保存されます。

`B B'
     現在の記事を他のグループにクロスポストします
     (`gnus-summary-crosspost-article')。これは他のグループの記事の新し
     い複製を作成し、記事の Xref 欄も適切に更新されます。

`B i'
     任意のファイルを現在のメールグループに取り込みま
     す (`gnus-summary-import-article')。あなたはファイル名と、
     `From' 欄と `Subject' 欄の入力を促されます。

`B I'
     空の記事を現在のメールグループに作ります
     (`gnus-summary-create-article')。`From' ヘッダーと `Subject' ヘッ
     ダーの内容を尋ねられます。

`B r'
     メール記事をスプールし直します (`gnus-summary-move-article')。
     `gnus-summary-respool-default-method' が再スプールするときのディフォ
     ルトの選択方法として使用されます。この変数はディフォルトでは
     `nil' で、その場合は現在のグループの選択方法が代わりに使われます。
     `gnus-preserve-marks' の値が `nil' でなければ (それがディフォルト)、
     印は保存されます。

     訳注: 「スプールし直す」というのはメールの分割 (*Note Splitting
     Mail:: または *Note Fancy Mail Splitting::) の規則に基づいて、メー
     ルを適切なグループに入れ直すことです。そのグループに間違って入って
     しまったメールを、分割の規則を修正した後で、正しいグループに移動さ
     せる場合などに使います。この章の `B q' と `B t' も見てください。

`B w'
`e'
     現在の記事を編集します (`gnus-summary-edit-article')。編集を終了し
     て変更を固定するには `C-c C-c' (`gnus-summary-edit-article-done')
     を打ちます。もし `C-c C-c' 命令に接頭引数を与えると、Gnus は記事を
     再ハイライトしません。

     訳注: 変更しないで編集を終るには、`C-c C-k' をタイプしてください。

`B q'
     記事を再スプールするときは、再スプールをする前にどのグループに記事
     が移るかを知りたいでしょう。この命令でそれがわかります
     (`gnus-summary-respool-query')。

`B t'
     同様に、この命令は再スプールするときに使われるすべての特級分割方式
     を、もしあれば表示します (`gnus-summary-respool-trace')。

`B p'
     一部の人たちには、あなたが投稿した記事にフォローアップするときに
     「親切な」複製を送る傾向があります。これらは普通はそこに
     `Newsgroups' ヘッダーが付いているのですが、いつもそうであるとは限
     りません。この命令 (`gnus-summary-article-posted-p') は現在の記事
     をあなたのニュースサーバーから (というよりは、むしろ
     `gnus-refer-article-method' や `gnus-select-method' から) 取得しよ
     うとして、記事を発見できたかどうかを報告します。それが記事を発見し
     なかったとしても、それはとにかく投稿されているかもしれません--メー
     ルの伝達はニュースの伝達よりもずっと速いので、ニュースの複製がまだ
     到着していないだけかもしれないのです。

     訳注: その「親切な」複製が、概略バッファーで独立した記事として見え
     ていないと検査することができないので、そうするために `A D' または
     `C-d' 命令 (*Note Really Various Summary Commands::) を使う必要が
     あるかもしれません。この命令はとにかくすべての選択方法を試すので、
     特にそれらに遅いものが含まれているときは、注意して使ってください。

`K E'
     記事の本文を暗号化します (`gnus-article-encrypt-body')。本文は、変
     数 `gnus-article-encrypt-protocol' で指定されたプロトコルで暗号化
     されます。

いつも記事をどこかに移動 (もしくは複製) することを習慣にしているのなら
ば、記事をどこに入れれば良いかを Gnus に提案してもらいたいと思うでしょ
う。`gnus-move-split-methods' は `gnus-split-methods' と同じ構文を使う
変数です (*Note Saving Articles::)。あなたが妥当だと思うような提案をす
るようにその変数をカスタマイズすることができます。
(`gnus-split-methods' がファイル名を使うのに対して
`gnus-move-split-methods' はグループ名を使うことに注意してください。)

     (setq gnus-move-split-methods
           '(("^From:.*Lars Magne" "nnml:junk")
             ("^Subject:.*gnus" "nnfolder:important")
             (".*" "nnml:misc")))



File: gnus-ja.info, Node: Various Summary Stuff, Next: Exiting the Summary Buffer, Prev: Mail Group Commands, Up: Summary Buffer

概略のいろいろなもの
====================

* Menu:

* Summary Group Information::   情報指向の命令
* Searching for Articles::      複数記事命令
* Summary Generation Commands::
* Really Various Summary Commands::  あのやっかいな思い通りにならない命令

`gnus-summary-display-while-building'
     非-`nil' だったら、構築中の概略バッファーを更新しながら表示します。
     `t' だった場合は、行が挿入される度に毎回バッファーを更新します。値
     が整数 N であった場合は、N 行毎に表示を更新します。ディフォルトは
     `nil' です。

`gnus-summary-display-arrow'
     非-`nil' だったら、現在の記事を指し示すためにフリンジに矢印を表示
     します。(訳注: フリンジとは Emacs 21 以上でウィンドウの左右に現れ
     る余白のことです。)

`gnus-summary-mode-hook'
     概略モードのバッファーを作成するときにこのフックが呼ばれます。

`gnus-summary-generate-hook'
     これはスレッド作成と概略バッファー作成の前に実行する最後のものとし
     て呼ばれます。これはニュースグループの持っているデータに基づいてス
     レッドの変数をカスタマイズするのに非常に便利です。このフックはほと
     んどの概略バッファー変数が設定された後に概略バッファーから呼ばれま
     す。

`gnus-summary-prepare-hook'
     これは概略バッファーが作成された後に呼ばれます。例えば、これを何か
     しら神をも畏れぬ方法で行をハイライトしたり、バッファーの見え方を修
     正したりするのに使ったりするかもしれません。

`gnus-summary-prepared-hook'
     概略バッファーが作成された後で一番最後に呼ばれるフックです。

`gnus-summary-ignore-duplicates'
     Gnus が同じ `Message-ID' を持つ二つの記事を発見したときは、何か思
     い切ったことをしなければなりません。別の記事が同じ `Message-ID' を
     持つことは許されていませんが、それは何らかのソースからメールを読ん
     でいるときに起こるかもしれません。この変数によって Gnus が何をする
     かをカスタマイズできるようになっています。`nil' だったら (それがディ
     フォルトです)、Gnus は `Message-ID' を付け替えて (表示のためだけに)
     その記事を他の記事と同じように表示します。`t' にすると、それは記事
     を表示しません--最初から存在しなかったかのように。

`gnus-alter-articles-to-read-function'
     この変数に設定した関数で、選択する記事のリストを変更することができ
     ます。関数は二つの引数 (グループ名と選択する記事のリスト) を受け付
     けます。

     例えば以下の関数は、キャッシュされた記事のリストを、あるグループの
     リストだけに追加します。

          (defun my-add-cached-articles (group articles)
            (if (string= group "some.group")
                (append gnus-newsgroup-cached articles)
              articles))

`gnus-newsgroup-variables'
     ニュースグループ (その概略バッファーの) のローカル変数、または変数
     とそれらの評価されるディフォルトの表現 (ディフォルト値が `nil' で
     ない場合) の cons セルのリストで、その概略バッファーが活きている間
     はグローバル変数になります。(訳注: いわゆるバッファーローカル変数
     ではありません。)

     注: ディフォルトの表現は単にローカル変数に設定されるのではなく、そ
     の前に (`eval' 関数を使って) 評価されます。ディフォルトの表現が
     `global' というシンボルだった場合は評価されず、代わりにそのローカ
     ル変数のグローバル値が使われます。

     これらグループパラメーターの値が他のバッファーで行なわれる処理に影
     響するようになっていても、(訳注: その概略バッファーの) グループパ
     ラメーターを設定するために使うことができます。例です:

          (setq gnus-newsgroup-variables
               '(message-use-followup-to
                 (gnus-visible-headers .
                   "^From:\\|^Newsgroups:\\|^Subject:\\|^Date:\\|^To:")))

     *Note Group Parameters:: も参照してください。

     訳注: もっと良い例が必要です。`gnus-newsgroup-variables' および
     `gnus-parameters' (*Note Group Parameters::) の値を次のように設定
     したとしましょう:

          (setq gnus-newsgroup-variables '((VAR . FOO)))
          (setq gnus-parameters
                '(("^fj\\." (VAR . BAR))
                  ("^japan\\." (VAR . BAZ))))

     こうしておくと変数 VAR の値が、`fj' 階層のニュースグループ (の概略
     バッファー) に入ると BAR になり、`japan' 階層のグループに入ると
     BAZ になります。グループを抜けても変数 VAR の値は変化しませんが、
     `fj' または `japan' 階層以外のグループに入ると変数 VAR の値は FOO
     になります (正確には、FOO, BAR または BAZ の値は、本編で説明されて
     いるように `eval' した結果が使われます)。

     通常のグループパラメーターは、そのグループの概略バッファーでだけ値
     を知ることができるのに対して、`gnus-newsgroup-variables' で設定し
     た変数は、同じ Emacs のどのバッファーでも、現在選択されているグルー
     プ固有の値を持つ点が違います。異なる複数のグループの概略バッファー
     を使う場合には、注意する必要があります。

     特別な場合として FOO が `nil' で良い場合は、次のように記述すること
     ができます:

          (setq gnus-newsgroup-variables '(VAR))
          (setq gnus-parameters
                '(("^fj\\." (VAR . BAR))
                  ("^japan\\." (VAR . BAZ))))

     `gnus-newsgroup-variables' および `gnus-parameters' はどちらもリス
     トなので、`setq' よりはむしろ `add-to-list' や `push' などを使って、
     値を「追加」した方が便利かもしれません。

`gnus-propagate-marks'
     `nil' 以外の値だったら、印をバックエンドに伝えます。それらを記録す
     るためです。もっときめ細かくふるいにかけるには *Note NNTP marks::
     およびその仲間を参照してください。



File: gnus-ja.info, Node: Summary Group Information, Next: Searching for Articles, Prev: Various Summary Stuff, Up: Various Summary Stuff

概略グループ情報
----------------

`H f'
     現在のグループの FAQ (frequently asked questions (頻繁にされる質問)
     のリスト) を取得しようとします (`gnus-summary-fetch-faq')。Gnus は
     `gnus-group-faq-directory' (通常これは遠隔マシンのディレクトリー)
     から FAQ を取得しようとします。この変数はディレクトリーのリストで
     あることもできます。その場合、この命令に接頭引数を与えることによっ
     ていろいろなサイトから選ぶことができます。おそらく `ange-ftp' もし
     くは `efs' がファイルの取得に使われるでしょう。

`H d'
     現在のグループの簡潔な説明を表示します
     (`gnus-summary-describe-group')。接頭引数が与えられると、サーバー
     から強制的に説明の再読み込みをします。

`H h'
     最も重要な概略コマンドの、非常に簡潔な説明を表示します
     (`gnus-summary-describe-briefly')。

`H i'
     Gnus の info の節 (node) に移動します (`gnus-info-find-node')。



File: gnus-ja.info, Node: Searching for Articles, Next: Summary Generation Commands, Prev: Summary Group Information, Up: Various Summary Stuff

記事を探す
----------

`M-s'
     それ以降のすべての (生の) 記事を正規表現で検索します
     (`gnus-summary-search-article-forward')。

`M-r'
     それ以前のすべての (生の) 記事を正規表現で検索します
     (`gnus-summary-search-article-backward')。

`M-S'
     前回の前方検索を繰り返します
     (`gnus-summary-repeat-search-article-forward')。

`M-R'
     前回の後方検索を繰り返します
     (`gnus-summary-repeat-search-article-backward')。

`&'
     この命令は、ヘッダー、そのヘッダーの内容に合致する正規表現、および
     合致したときに実行されるコマンドの入力を要求します
     (`gnus-summary-execute-command')。ヘッダーが空文字列だったら、記事
     全体で合致するものを探します。接頭引数を与えられると、代わりに後ろ
     向きに探します。

     例えば `& RET 何かの.*文字列 RET #' は、ヘッダーか本文に `何か
     の.*文字列' を持つすべての記事にプロセス印を付けます。

`M-&'
     この命令に続けて入力する命令を、プロセス印が付けられているすべての
     記事で実行します (`gnus-summary-universal-argument')。



File: gnus-ja.info, Node: Summary Generation Commands, Next: Really Various Summary Commands, Prev: Searching for Articles, Up: Various Summary Stuff

概略生成命令
------------

`Y g'
     現在の概略バッファーを再作成します (`gnus-summary-prepare')。

`Y c'
     (現在のグループのために) キャッシュされたすべての記事を概略バッ
     ファーに挿入します (`gnus-summary-insert-cached-articles')。

`Y d'
     (現在のグループのための) すべての保留記事を概略バッファーに挿入し
     ます (`gnus-summary-insert-dormant-articles')。

`Y t'
     (現在のグループのための) すべての可視記事を概略バッファーに挿入し
     ます (`gnus-summary-insert-ticked-articles')。



File: gnus-ja.info, Node: Really Various Summary Commands, Prev: Summary Generation Commands, Up: Various Summary Stuff

本当にいろいろな概略命令
------------------------

`A D'
`C-d'
     現在の記事が別の記事を寄せ集めたもの (例えばダイジェスト) であるな
     らば、それらの記事でできているグループに入るためにこの命令を使うこ
     とができます (`gnus-summary-enter-digest-group')。この命令に接頭引
     数を与えないと Gnus はどのような型の記事が現在表示されているかを推
     測しようとし、実際にはそれが『ダイジェスト』であるものとして強引に
     解釈します。基本的に、ある様式で寄せ集められた別のメッセージを見る
     ときはいつでも、`C-d' を使うことによって、もっと便利なやり方でそれ
     らのメッセージを読むことができます。

     変数 `gnus-auto-select-on-ephemeral-exit' はダイジェスト・グループ
     を出た後に、どの記事を選択すべきかを制御します。有効な値は次の通り
     です:

     `next'
          次の記事を選択します。

     `next-unread'
          次の未読記事を選択します。

     `next-noselect'
          カーソルを次の記事に移動します。これがディフォルトです。

     `next-unread-noselect'
          カーソルを次の未読記事に移動します。

     これら以外の値だったり、次の (未読の) 記事が無かったら、ダイジェス
     ト・グループに入る前に選択されていた記事が現れます。

`C-M-d'
     この命令は上のものによく似ていますが、いくつかの文書を一つのおおー
     きなグループに集めます (`gnus-summary-read-read-document')。それを
     実現するために、この命令はそれぞれの文書のための `nndoc' グループ
     を開いてから、それら複数の `nndoc' グループのてっぺんで
     `nnvirtual' グループを開きます。この命令はプロセス/接頭引数の習慣
     を理解します (*Note Process/Prefix::)。

`C-t'
     長い概略行を切り詰めるかどうかを切り替えます
     (`gnus-summary-toggle-truncation')。これはおそらく概略バッファーで
     行を中央に表示する機能を混乱させるので、記事を読んでいるときに行の
     切り詰めを off にするのは良い考えではないでしょう。

`='
     概略バッファーのウィンドウを拡大します
     (`gnus-summary-expand-window')。接頭引数を与えられると、記事バッ
     ファーのためのウィンドウの配置の設定を強制します (訳注: ディフォル
     トでは記事バッファーのためのウィンドウの配置の設定には概略バッファー
     を表示することも含まれているので、普通に記事を読んでいるときと同じ
     になるでしょう)。

`C-M-e'
     現在のグループのグループパラメーター (*Note Group Parameters::) を
     編集します (`gnus-summary-edit-parameters')。

`C-M-a'
     現在のグループのグループパラメーター (*Note Group Parameters::) を
     カスタマイズします (`gnus-summary-customize-parameters')。



File: gnus-ja.info, Node: Exiting the Summary Buffer, Next: Crosspost Handling, Prev: Various Summary Stuff, Up: Summary Buffer

概略バッファーを抜ける
======================

概略バッファーから抜けると、普通はグループのすべての情報を更新してグルー
プバッファーに戻ります。

`Z Z'
`Z Q'
`q'
     現在のグループを出て、グループのすべての情報を更新します
     (`gnus-summary-exit')。抜け出るための多くの処理を行なう前に
     `gnus-summary-prepare-exit-hook' が呼ばれ、それはディフォルトで
     `gnus-summary-expire-articles' を呼びます。抜け出るための処理を終
     えた後で `gnus-summary-exit-hook' が呼ばれます。グループモードに戻
     るときに (未読の) グループが残っていなかったら
     `gnus-group-no-more-groups-hook' が実行されます。

`Z E'
`Q'
     グループのどんな情報も更新せずに現在のグループを抜け出ます
     (`gnus-summary-exit-no-update')。

`Z c'
`c'
     グループのすべての可視ではない (unticked) 記事に既読の印を付けてか
     ら抜けます (`gnus-summary-catchup-and-exit')。

`Z C'
     可視記事さえも含むすべての記事に既読の印を付けてから抜けます
     (`gnus-summary-catchup-all-and-exit')。

`Z n'
     すべての記事に既読の印を付けて次のグループへ移動します
     (`gnus-summary-catchup-and-goto-next-group')。

`Z p'
     すべての記事に既読の印を付けて前のグループへ移動します
     (`gnus-summary-catchup-and-goto-prev-group')。

`Z R'
`C-x C-s'
     現在のグループを出て、それから入り直します
     (`gnus-summary-reselect-current-group')。接頭引数が与えられると、
     既読と未読の両方のすべての記事を選択します。

`Z G'
`M-g'
     グループを抜け、そのグループの新しい記事を調べてから、再びそのグルー
     プを選択します (`gnus-summary-rescan-group')。接頭引数が与えられる
     と、既読と未読の両方のすべての記事を選択します。

`Z N'
     グループを抜けて、次のグループへ移動します
     (`gnus-summary-next-group')。

`Z P'
     グループを抜けて、前のグループへ移動します
     (`gnus-summary-prev-group')。

`Z s'
     現在の既読と印付き記事の数をドリブルバッファー (dribble buffer) に
     保存し、それからドリブルバッファーを保存します
     (`gnus-summary-save-newsrc')。接頭引数が与えられると `.newsrc' ファ
     イル (と `.newsrc.eld' ファイル) も保存します。この命令を使うと、
     更新なしで抜け出ること (`Q' 命令) は意味が無くなります。

グループのすべての情報を「更新」して現在のグループを抜けるときに
`gnus-exit-group-hook' が呼ばれます。例えば `Q' 命令
(`gnus-summary-exit-no-update') はこのフックを呼びません。

グループを抜けた後でそれを後悔する癖があるのなら、
`gnus-kill-summary-on-exit' を `nil' に設定と良いかもしれません。そうす
ると Gnus は抜け出るときに概略バッファーを削除しません。(何という驚き!)
代わりに、それはバッファーの名前を `*Dead Summary ... *' のようなものに
変更して、`gnus-dead-summary-mode' というマイナーモードを導入します。今
やそのバッファーに切り替えると、すべてのキーが関数
`gnus-summary-wake-up-the-dead' に割り当てられていることに気付くでしょ
う。死んだ概略バッファー (dead summary buffer) でどんなキーでも叩くと、
それは生きた普通の概略バッファーになります。

死んだ概略バッファーは同時に一つしか存在することはできません。

概略バッファーを抜け出ると、現在のグループのデータは更新されます (どの
記事を読んで、どの記事に返答したか、などなど。) もし変数
`gnus-use-cross-reference' が `t' であると (それがディフォルトです)、そ
のグループに相互参照された (cross referenced) 記事には、それがクロスポ
ストされた他の購読しているグループにあっても、既読の印が付きます。この
変数が `nil' でも `t' でもなければ、記事には購読しているグループと購読
していないグループの両方で既読の印が付きます (*Note Crosspost
Handling::)。



File: gnus-ja.info, Node: Crosspost Handling, Next: Duplicate Suppression, Prev: Exiting the Summary Buffer, Up: Summary Buffer

クロスポストの扱い
==================

クロスポストされた記事に既読の印を付けることによって、同じ記事を二回以
上読まないで済むことを保証します。もちろん、だれかがそれを複数のグルー
プに別々に投稿しない限りは。同じ記事を複数のグループに (クロスポストで
はではなく) 投稿することは "spamming" と呼ばれ、あなたはそのような憎む
べき犯罪を行なうものに対して、法律によって不快な記事を送ることが義務づ
けられています。spam を振い落すために、NoCeM で処理することを試してみる
必要があるかもしれません (*Note NoCeM::)。

覚えておいてください: クロスポストはまあ構いませんが、同じ記事を別々に
複数のグループに投稿するのは許されません。大量のクロスポスト
("velveeta" として知られているもの) は何としても避けられるべきで、過剰
なクロスポストに対して不満を言うために
`gnus-summary-mail-crosspost-complaint' 命令を使うことさえできます。

Gnus にクロスポストを正しく扱えなくさせる原因の一つは、XOVER (これは非
常に良いです、というのはそれは速度をとても速くするからです) をサポート
しているけれども NOV 行に `Xref' 欄を含めない NNTP サーバーを使っている
ことです。これは害悪です。でも、あぁ、悲しいかな、非常に良くあることな
のです。Gnus はあなたが読んだすべての記事に `Xref' 行を記録することによっ
て The Right Thing (正しいこと) をしようとしますが、記事を削除したり単
に読まないで既読の印を付けると、Gnus がこれらの記事の `Xref' 行をのぞき
まわる機会が無くなってしまうので、相互参照 (cross reference) の機構を使
えなくなってしまいます。

あなたの NNTP サーバーがその概観ファイル (overview file) に `Xref' 欄を
含めるかどうかを調べるには、`telnet your.nntp.server nntp' をタイプして、
`inn' サーバーでは `MODE READER' コマンドを与えてから、`LIST
overview.fmt' を試してください。これは動作しないかもしれません。しかし、
もし動作して、取得した最後の行が `Xref:full' でないならば (訳注: 最後の
行ではないかもしれません)、ニュースの管理者が概観ファイルに `Xref' 欄を
含めるようにしてくれるまで、彼女に向かって叫び、泣き付くべきでしょう。

Gnus にいつでも正しい `Xref' を取得するようにさせたいのであれば、
`nntp-nov-is-evil' を `t' にする必要があり、それは非常に速度を遅くしま
す。*Note Slow/Expensive Connection:: も参照してください。

ま、人生はそのようなものです。

代替手段に付いては *Note Duplicate Suppression:: を参照してください。



File: gnus-ja.info, Node: Duplicate Suppression, Next: Security, Prev: Crosspost Handling, Up: Summary Buffer

重複の抑制
==========

ディフォルトでは Gnus はクロスポスト機構を利用することによって、同じ記
事を二回以上読まないようにしようとします (*Note Crosspost Handling::)。
しかし、その単純で効果的な方法は、いろいろな理由により、満足する結果を
もたらさないかもしれません。

  1. NNTP サーバーは `Xref' 欄の生成に失敗するかもしれません。これは悪
     いことで、あまり起こりません。

  2. NNTP サーバーは `.overview' データベースに `Xref' 欄を含めるのに失
     敗するかもしれません。これは悪いことで、非常に良くあることです、あぁ
     悲しい。

  3. 同じグループ (もしくはいくつかの関連したグループ) を違った NNTP サー
     バーから読んでいるかもしれません。

  4. グループに投稿された記事と重複するメールを受け取ったかもしれません。

`Xref' の扱いに失敗する状況は確かに他にもありますが、これら四つが最も良
くある状況です。

もし、本当にもしも `Xref' の扱いに失敗したら、「重複抑制」に切り替える
ことを考慮する必要があるかもしれません。そうすれば、Gnus はあなたが読ん
だすべての記事、あるいは既読の印を付けたすべての記事の `Message-ID' を
記憶し、そしてまるで魔法のように、以後それらを読むときはいつでも既読の
印が付いているようにします---*すべて* のグループで。この機構を使うのは
何だかとても非効率になりそうですが、過度に非効率なわけではありません。
同じ記事を二回以上読むよりは、間違い無く望ましいです。

重複抑制はあまり精密な道具ではありません。どちらかというと大槌のような
ものです。それは非常に単純なやり方で動作しています--あなたが記事に既読
の印を付けると、その Message-ID をキャッシュに加えます。次にその
Message-ID に出会うと、`M' 印によって記事に既読の印を付けます。その記事
をどのグループで見たかは気にしません。

`gnus-suppress-duplicates'
     `nil' でなければ、重複抑制をします。

`gnus-save-duplicate-list'
     `nil' でなければ、重複のリストをファイルに保存します。これは起動と
     終了の時間を長くするので、ディフォルトは `nil' です。しかし、これ
     は Gnus を一回実行したときに読まれた重複記事だけが抑制されるという
     ことです。

`gnus-duplicate-list-length'
     この変数はどのくらい多くの `Message-ID' を重複抑制リストに保ってお
     くかを決定します。ディフォルトは 10000 です。

`gnus-duplicate-file'
     重複抑制のリストを格納しておくファイルの名前です。ディフォルトは
     `~/News/suppression' です。

何度も Gnus を終了して起動する傾向があるのであれば、おそらく
`gnus-save-duplicate-list' を `t' にするのは良い考えでしょう。もし
Gnus を続けて何週間も走らせておくのであれば、それを `nil' にした方が良
いかもしれません。一方、リストを保存することは起動と終了をずっと遅くす
るので、頻繁に Gnus を終了して起動するのであれば、
`gnus-save-duplicate-list' を `nil' に設定するべきです。うーむ。私はあ
なたがどうするかに任せようと思います。



File: gnus-ja.info, Node: Security, Next: Mailing List, Prev: Duplicate Suppression, Up: Summary Buffer

セキュリティー
==============

Gnus は署名されたメッセージを検証したり、暗号化されたメッセージをデコー
ドすることができます。PGP, PGP/MIME および S/MIME の形式をサポートしま
すが、それらを動作させるためには、いくつかの外部プログラムを必要としま
す:

  1. PGP と PGP/MIME のメッセージを扱うには、OpenPGP の実装である
     GnuPG のようなものをインストールしなければなりません。Emacs に含ま
     れている GnuPG へのインターフェースは EasyPG というもの (*Note
     EasyPG: (epa)Top.) ですが、PGG (*Note PGG: (pgg-ja)Top.)、
     Mailcrypt および gpg.el もサポートします。

  2. S/MIME のメッセージを扱うには、OpenSSL をインストールする必要があ
     ります。OpenSSL 0.9.6 か、それより新しいものがお勧めです。

以下は、メッセージを読む、または作成する場合に、セキュリティーの機能を
制御するための変数です:

`mm-verify-option'
     署名されたパートを検証するためのオプション。`never' は検証しない、
     `always' はいつも検証する、`known' は知られたプロトコルの場合だけ
     検証する、の意味です。それら以外の場合は、どうするかを利用者に尋ね
     ます。

`mm-decrypt-option'
     暗号化されたパートをデコードするためのオプション。`never' はデコー
     ドしない、`always' はいつもデコードする、`known' は知られたプロト
     コルの場合だけデコードする、の意味です。それら以外の場合は、どうす
     るかを利用者に尋ねます。

`mm-sign-option'
     署名されたパートを作成するためのオプション。`nil' ではディフォルト
     の署名のための鍵を使い、`guided' では署名のための鍵をメニューから
     選びます。

`mm-encrypt-option'
     暗号化されたパートを作成するためのオプション。`nil' で
     は `From:' ヘッダーを受取人として最初に合致する公開鍵を使い、
     `guided' では受取人のキーをメニューから選びます。

`mml1991-use'
     PGP のメッセージのための、OpenPGP の実装への elisp インターフェー
     スを示すシンボルです。ディフォルトは `epg' ですが、後方互換のため
     に `pgg'、`mailcrypt' および `gpg' もサポートします。ディフォルト
     では、Gnus はこの順番で最初に見つかるインターフェースを使います。

`mml2015-use'
     PGP/MIME のメッセージのための、OpenPGP の実装への elisp インター
     フェースを示すシンボルです。ディフォルトは `epg' ですが、後方互換
     のために `pgg'、`mailcrypt' および `gpg' もサポートします。ディフォ
     ルトでは、Gnus はこの順番で最初に見つかるインターフェースを使いま
     す。

ディフォルトではセキュリティーの情報を表示するボタンが現れません。それ
らは実際にメールを読む際に邪魔になるからです。 `K b' をタイプすれば、そ
の情報を表示することができますが。これを恒久的に行なわせるには、
`gnus-buttonized-mime-types' および `gnus-unbuttonized-mime-types' 変数
を使ってください。これらの変数の詳細と、常にセキュリティーの情報を表示
させるためにカスタマイズする方法は、*Note MIME Commands:: を参照してく
ださい。

メニュー項目やコマンドから OpenPGP の鍵を取得 (snarf) する (すなわち、
記事から鍵を鍵束に輸入 (import) する) 機能は、明示的にはサポートされま
せん。というよりはむしろ、あなたが適切だと思うどんな動作をも通常の
MIME の機構を介して指定できるように、Gnus は `application/pgp-keys' と
して鍵を検出し、ラベルを付けます。MIME ボタンをクリック (*Note Using
MIME::) したときに、GNU Privacy Guard を使って鍵を輸入してくれるように
するには、以下のような行を `~/.mailcap' ファイル (*Note mailcap:
(emacs-mime-ja)mailcap.) に記入してください。

     application/pgp-keys; gpg --import --interactive --verbose; needsterminal

これは、たまたま `mailcap-mime-data' ですでに定義されている、ディフォル
トの動作でもあります。

送信するメッセージに署名したり暗号化するために、どうやって設定するかに
ついてのもっと詳しい情報が、message マニュアル (*Note セキュリティー:
(message-ja)Security.) で見つかるでしょう。



