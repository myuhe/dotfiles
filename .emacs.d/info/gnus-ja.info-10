Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契
     約書第 1.2 版またはそれ以降の版が定める条件の下で複製、配布、ある
     いは変更することを許可します。変更不可部分は指定しません。“A GNU
     Manual”は表表紙テキスト、以下の (a) は裏表紙テキストです。この利
     用許諾契約書の複写は“Emacs manual”の「GNU フリー文書利用許諾契約
     書」という章に含まれています。

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     (a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフト
     ウェアのように複製したり変更する自由があります。複製はフリーソフト
     ウェア財団によって出版されました。(フリーソフトウェア財団は) GNU
     の開発のために必要な資金を集めています。」

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.

     この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集
     著作物の一部です。もしあなたがこの文書を収集著作物から分離して配布
     したいときは、契約書の第 6 章に記述されているように、文書に契約書
     の複写を付加することによって、行なうことができます。



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY





File: gnus-ja.info, Node: Score File Format, Next: Score File Editing, Prev: Score Variables, Up: Scoring

スコアファイル様式
==================

スコアファイルは普通は単一の様式だけを含む `emacs-lisp' ファイルです。
無頓着な利用者はこれを編集しないで下さい。すべては概略バッファーから変
更することができます。

にもかかわらず、それを自分でいじってみたくなったのなら、例があります:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

この例はたいていのスコアファイルの要素を説明しています。別のやり方につ
いては、*Note Advanced Scoring:: を見て下さい。

これがとても Lisp コードのように見えるとしても、実際はここにあるものは
何も `eval' (評価) されません。しかしこの様式を読み込むために Lisp リー
ダーが使われるので、意味的に有効でないとしても、文法的には正当なもので
す。

この連想リストでは六つのキーがサポートされています:

`文字列 (STRING)'
     キーが文字列だったら、それは合致が実行されるヘッダーの名前です。ス
     コア付けはこれら八つのヘッダーだけで行なうことができます: `From',
     `Subject', `References', `Message-ID', `Xref', `Lines', `Chars' お
     よび `Date' です。これらのヘッダーに加えて、Gnus に、記事全体を取
     得して記事のより大きな部分で合致を行なわせる三つの文字列があります:
     `Body' は記事の本文で合致を行ない、`Head' は記事のヘッダーで合致を
     行ない、`All' は記事全体で合致を行ないます。これら最後の三つのキー
     を使うと、グループに入る速度を *かなり* 遅くしてしまうことに気を付
     けて下さい。スコアを付けることができる最後の「ヘッダー」は
     `Followup' です。これらのスコア・エントリーは、これらのスコア・エ
     ントリーに合致する記事へのすべてのフォローアップのための追加が行な
     われている、新しいスコア・エントリーに帰着するでしょう。

     このキーに続くのは任意の数のスコア・エントリーで、それぞれのスコア・
     エントリーは一つから四つまでの要素を持ちます。

       1. 最初の要素は「合致要素」です。これはたいていのヘッダーでは文
          字列ですが、Lines と Chars ヘッダーでは整数でなければなりませ
          ん。

       2. もし二番目の要素があるなら、それは数値の「スコア要素」でなけ
          ればなりません。この数値は負の無限大から正の無限大までの間の
          整数でなければなりません。合致が成功すると、この数値が記事の
          スコアに加えられます。この要素が存在していない場合は、代わり
          に `gnus-score-interactive-default-score' の数値が使われます。
          ディフォルトは 1000 です。

       3. もし三番目の要素があるなら、それは数値の「日付要素」でなけれ
          ばなりません。この日付は最後にこのスコア・エントリーが合致し
          た時刻を示し、それはスコア・エントリーを期限切れ消去するため
          の機構を提供します。この要素が存在していないと、スコア・エン
          トリーは永続になります。日付は紀元前 1年12月31日からの経過し
          た日数で表されます。

       4. もし四番目の要素があるなら、それはシンボルの「型要素」でなけ
          ればなりません。この要素は、このスコア・エントリーが記事に合
          致するかどうかを調べるために、どの関数が使われるべきかを指定
          します。

          "From, Subject, References, Xref, Message-ID"
               たいていのヘッダー型のために、`r' と `R' (正規表現
               (regexp))、`s' と `S' (文字列の一部(substring)) 型、`e'
               と `E' (正確な合致(exact match))、および `w' (語の合致
               ((word match)) 型があります。もしこの要素が無いと、Gnus
               は文字列の一部の合致が用いられるべきであると仮定します。
               `R', `S', `E' は、合致が大文字と小文字を区別する方法で行
               なわれる点で他のものと異なります。これらすべての一文字型
               は、本当は `regexp', `exact', `word' 型の短縮形で、この
               方が好みならば代わりに使うことができます。

          "Extra"
               overview ヘッダーの標準の文字列に的を絞って
               `gnus-extra-headers' を使っていれば、それらのヘッダーの
               値でスコアを付けることができます。この場合スコア・エント
               リーの五番目の要素が、スコアを付けるヘッダーの名前になり
               ます。NNTP サーバーが overview で `NNTP-Posting-Host' を
               捕捉しているならば、`all.SCORE' ファイルの以下のエントリー
               は、単一のホストを起源とする spam の攻撃に対して有効です:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

          "Lines, Chars"
               これらの二つのヘッダーは別の合致の型を使います: `<', `>',
               `=', `>=', `<=' です。

               これらの述語は

                    (PREDICATE HEADER MATCH)

               の評価が `nil' ではない場合に真です。例えば、上級合致
               `("lines" 4 <)' (*Note Advanced Scoring::) は結果として
               以下の式になります:

                    (< header-value 4)

               言い換えると、4 を合致として `<' を `Lines' で使っている
               ときは、記事が 4 行よりも少ないときにスコアが加算される
               ということです。(混乱して、それが反対ではないかと考えが
               ちです。でも、そうではないのです。私が思うに。)

               合致を `Lines' で行なっていると、いくつかのバックエンド
               (`nndir' のようなもの) は `Lines' ヘッダーを作成しないの
               で、すべての記事が 0 行であるとして扱われてしまうことに
               気を付けて下さい。これは、少しの行しかない記事のスコアを
               下げている場合に、変な結果を導くことがあり得ます。

          "Date"
               Date (日付) ヘッダーには三つのなんとなくばかげている合致
               の型があります: `before', `at', `after' です。私は本当に
               これが役立つような機会を想像できないのですが、この関数を
               提供しないのもなんとなくばかげています。そうした場合のた
               めにあるのです。いつ必要になるかは誰にもわかりません。転
               ばぬ先の杖。羹(あつもの)に懲りて膾(なます)を吹く。本をカ
               バーで判断してはいけません。初めてのデートでエッチしては
               いけません。(しかし、私は少なくとも一人、引用しますが、
               「この関数は欠かせないものであることがわかった」と言った
               人がいると聞いています。)

               もっと役に立つ合致の型は「正規表現」です。それによって、
               日付の文字列に正規表現を使って合致させることができます。
               日付はまず ISO8601 の短縮様式 (compact format) に標準化
               されます---YYYYMMDD`T'HHMMSS です。例えば、すべての年の
               4月1日に投稿されたすべての記事に合致させたいのであれば、
               合致文字列として `....0401.........' を使うことができま
               す。(日付は元々の標準時で保存されているので、その記事が
               投稿された場所での 4月1日に投稿された記事に合致すること
               に注意して下さい。“Time zones”は家族全員の健全な楽しみ
               ですね? (訳注: いくつかある“Time zones”というタイトル
               の曲のことを言っているのかもしれません。))

          "Head, Body, All"
               これらの三つの合致のキーは `From' ヘッダー (など) と同じ
               合致の型を使います。

          "Followup"
               この合致のキーはやや特別で、それは `From' ヘッダーに合致
               し、合致した記事だけでなくその記事へのすべてのフォローアッ
               プのスコアにも影響します。これは例えば、あなた自身の記事
               へのフォローアップのスコアを増やしたり、良く知られた問題
               児へのフォローアップ記事のスコアを下げたりするのに使われ
               ます。`From' ヘッダーが使うのと同じ型の合致を使います。
               (この合致キーを使うと、`ADAPT' ファイルを作ることになり
               ます。)

          "Thread"
               この合致キーは `Followup' 合致キーと同じ方針に沿って動作
               します。`Message-ID' X で始まっているスレッド (または副
               スレッド) にスコアを付けたいのであれば、`thread' 合致を
               付け加えて下さい。これは `Reference' ヘッダーに X を持つ
               それぞれの記事に、新しい `thread' 合致を追加します。(こ
               れらの新しい `thread' 合致はこれらの合致する記事の
               `Message-ID' を使います。) これはスレッドのいくつかの記
               事が完全な `References' ヘッダーを持っていなかったとして
               も、スレッド全体のスコアを上げ/下げできることを保証しま
               す。これを使うと、スレッドの記事に決定的でないスコアが付
               くかもしれないということに注意して下さい。(この合致キー
               を使うと、`ADAPT' ファイルを作ることになります。)

`mark'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事にも既読の印が付きます。

`expunge'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事も概略バッファーから削除されます。

`mark-and-expunge'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事にも既読の印が付き、概略バッファーから削除されます。

`thread-mark-and-expunge'
     このエントリーの値は数値でなければなりません。スコアの総計がこの数
     値より低いスレッドのすべての記事には既読の印が付き、概略バッファー
     から削除されます。`gnus-thread-score-function' はスレッドのスコア
     の総計をどのように計算するかを指定します。

`files'
     このエントリーの値は任意の数のファイル名でなければなりません。それ
     らのファイルもスコアファイルであるとみなされ、これがされたのと同じ
     方法で読み込まれます。

`exclude-files'
     このエントリーの手がかりは任意の数のファイル名でなければなりません。
     これらのファイルが何らかの理由で普通は読み込まれるようになっていた
     としても、読み込まれません。

`eval'
     このエントリーの値は `eval' (評価) されます。この要素はグローバル
     スコアファイルを扱っているときは無視されます。

`read-only'
     読み込み専用スコアファイルは更新されたり保存されたりしません。グロー
     バルスコアファイルはこのアトムを使用するべきです (*Note Global
     Score Files::)。(注意: 「グローバル」はここでは本当に「全体的」と
     いう意味です。個人的なすべてのグループに適用するスコアファイルのこ
     とではありません。)

`orphan'
     このエントリーの値は数値でなければなりません。親記事を持たない記事
     のスコアにこの数値が加えられます。`comp.lang.c' のような流通量の多
     いニュースグループを追いかけていると想像して下さい。おそらくほんの
     少しのスレッドだけを追いたいでしょう。さらに新しいスレッドは見たい
     でしょう。

     以下の二つのスコアファイルエントリーによって、それをすることができ
     ます:

                  (orphan -500)
                  (mark-and-expunge -100)

     最初にこのグループに入ったときは、新しいスレッドだけを見るでしょう。
     そうしたら、興味を持ったスレッドのスコアを上げ (`I T' または `I
     S' で)、残りを無視 (`C y') して下さい。次にグループに入ったときは、
     興味を持ったスレッドの新しい記事と、まったく新しいスレッドを見るこ
     とになります。

     すなわち orphan (孤児) スコアアトムは、普通のスコア規則では自動的
     に発見できない、興味深いスレッドが少し存在しする、流通量が多いグルー
     プのためにあります。

`adapt'
     このエントリーは適応スコア付けを制御します。これが `t' だったら、
     ディフォルトの適応スコア規則が使われます。`ignore' だったら、この
     グループでは適応スコア付けは行なわれません。もしリストだったら、そ
     のリストが適応スコア規則として用いられます。もしそれが存在しないか
     `t' や `ignore' 以外の何かだったら、ディフォルトの適応スコア規則が
     使われます。たいていのグループで適応スコア付けを使いたいのであれば、
     `gnus-use-adaptive-scorint' を `t' に設定し、適応スコア付けをした
     くないグループに `(adapt ignore)' を挿入すればよいでしょう。少しの
     グループでだけ適応スコアを行ないたいのであれば、
     `gnus-use-adaptive-scoring' を `nil' に設定し、それを行ないたいグ
     ループのスコアファイルに `(adaptive t)' を挿入しましょう。

`adapt-file'
     すべての適応スコア・エントリーは、このエントリーによって名づけられ
     たファイルに入ります。さらにそれはグループに入るときにも適用されま
     す。このアトムは、多くのグループで同じ適応スコアファイルを用いるこ
     とによって、複数のグループに一度に適応スコアを付けたいときに便利で
     しょう。

`local'
     このエントリーの値は `(VAR VALUE)' の形式の対のリストでなければな
     りません。それぞれの VAR は現在の概略バッファーでバッファーローカ
     ルになり、指定された値 (VALUE) に設定されます。これは少し風変わり
     ですが、フックがあまり好きでないならば、いくつかのグループで変数を
     設定するのに便利な方法です。VALUE は評価されないことに注意して下さ
     い。



File: gnus-ja.info, Node: Score File Editing, Next: Adaptive Scoring, Prev: Score File Format, Up: Scoring

スコアファイルの編集
====================

普通はすべてのスコア命令を概略バッファーから発行しますが、手でそれらを
編集したくなることもあるかもしれないので、それのためのモードを用意して
います。

それは以下に列挙する命令を使えるように、少しカスタマイズしただけの
`emacs-lisp' モードです:

`C-c C-c'
     あなたが行なった変更を保存して概略バッファーに戻ります
     (`gnus-score-edit-done')。

`C-c C-d'
     現在の日付を数値の様式で挿入します
     (`gnus-score-edit-insert-date')。これはどのようなものだろうと考え
     ているのなら、これは本当に日の数値です。

`C-c C-p'
     適応スコアファイルは整形されずに保存されます。もしこれらのファイル
     の一つを読むつもりなら、まず "pretty print" (整形して印字) したい
     でしょう。この命令 (`gnus-score-pretty-print') がそれを行ないます。

このモードを使うには `M-x gnus-score-mode' とタイプして下さい。

`gnus-score-menu-hook' がスコアモードのバッファーで実行されます。

概略バッファーでは、`V f'、`V e' および `V t' のような命令でスコアファ
イルの編集を始めることができます。



File: gnus-ja.info, Node: Adaptive Scoring, Next: Home Score File, Prev: Score File Editing, Up: Scoring

適応スコア付け
==============

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、Gnus に
はこれらをすべて自動的に--まるで魔法でも使ったように作成する方法があり
ます。いやむしろ、人工無能によって、という方が正確かな。

記事を読んだとき、記事に既読の印を付けたとき、あるいは記事を削除したと
きに、その印を残しておいて下さい。グループから出るときに、Gnus はそれら
の印の辺りを嗅ぎ回り、何の印を見つけたかに応じてスコア要素を追加します。
この機能は `gnus-use-adaptive-scoring' を `t' か `(line)' に設定すると
有効になります。もしスコアを、表題に現れる個別の単語をもとに適応させた
ければ、この変数を `(word)' に設定して下さい。両方の適応方法を使いたけ
れば、この変数を `(word line)' に設定して下さい。

スコア付けの処理を完全に制御するために
`gnus-default-adaptive-score-alist' 変数をカスタマイズして下さい。例え
ば、こんな感じになるでしょう:

     (setq gnus-default-adaptive-score-alist
           '((gnus-unread-mark)
             (gnus-ticked-mark (from 4))
             (gnus-dormant-mark (from 5))
             (gnus-del-mark (from -4) (subject -1))
             (gnus-read-mark (from 4) (subject 2))
             (gnus-expirable-mark (from -1) (subject -1))
             (gnus-killed-mark (from -1) (subject -3))
             (gnus-kill-file-mark)
             (gnus-ancient-mark)
             (gnus-low-score-mark)
             (gnus-catchup-mark (from -1) (subject -1))))

ご覧のように、この連想リストの各要素は、キーとして印 (変数名か「実際の」
印すなわち文字のいずれか) を持ちます。このキーの後には任意の数のヘッダー
/スコアの組が続きます。もしそのキーの後にヘッダー/スコアの組が一つもな
ければ、そのキーが記事の印として付いている記事に対しては適応型スコア付
けは行なわれません。例えば上記の例では、`gnus-unread-mark' が付いている
記事は、適応型スコア付けのエントリーを持ちません。

各記事は一つしか印を持ち得ないので、それぞれの記事にはこれらの規則のう
ちの一つだけが適用されます。

`gnus-del-mark' を例に取りましょう--この連想リストでの意味は、この印
(すなわち `e' の印) が付いている記事はすべて、`From' ヘッダーをもと
に -4 下げられ `Subject' で -1 下げられるスコア・エントリーが追加されま
す。これをあなたの偏見に合わせて変更して下さい。

もし 10 個の記事に同じ subject で `gnus-del-mark' の印が付いていたとす
ると、この印に対する規則は十回適用されます。それはつまり、その subject
は -1 の十倍のスコアを得ます。その値は、私が大きく誤解していないかぎ
り -10 のはずです。

もし自動期限切れ消去 (メール) グループ (*Note Expiring Mail::) があれば、
既読記事にはすべて `E' 印が付けられます。これはおそらく適応型スコア付け
をちょっとばかりやりにくくするので、自動期限切れ消去と適応型スコア付け
は、一緒には現実にあまりうまくやっていけません。

スコアを付けられるヘッダーには `from', `subject', `message-id',
`references', `xref', `lines', `chars' および `date' があります。さらに
`followup' にもスコア付けができて、これは現在の記事の `Message-ID' を使っ
て `References' ヘッダーに合致、すなわちこれに続くスレッドに合致する適
応型スコア・エントリーを作成します。

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を避ける
ために、スコアファイルの `mark' アトムを何か小さい値--ひょっとする
と -300 くらいに設定しておくべきです。

適応型スコア付けを一週間かそこら使ってくると、Gnus はそれ相応に調教され、
あなたが何も言わなくても、あなたの好きな投稿者を強調し、あまり好きでは
ない投稿者を消去するようになるはずです。

どのグループにおいて適応型スコア付けを作動させるかは、スコアファイル
(*Note Score File Format::) を使うことによって制御できます。またこれを
使って、違ったグループに対して違った規則を使うようにもできます。

適応型スコア・エントリーは、グループ名に `gnus-adaptive-file-suffix' を
付加した名前のファイルに入れられます。ディフォルトは `ADAPT' です。

適応型スコアファイルは巨大になり得るので、人の手で編集されることは想定
されていません。`gnus-adaptive-pretty-print' が `nil' (ディフォルト) で
あると、それらのファイルは人に読めるような形式では書かれません。

適応型スコア付けを行なうときは、部分文字列一致やファジーな一致を行なっ
た方が、おそらくほとんどの場合において良い結果が得られるでしょう。しか
し、ヘッダーの一致する部分が短い場合、意図に反する動作をする可能性が大
きいので、`gnus-score-exact-adapt-limit' より短い長さしか一致しない場合
は完全一致が行なわれます。この変数が `nil' であれば、この問題が起こらな
いように常に完全一致が行なわれます。

上で述べたように、個別の単語ででもヘッダー全体ででも適応を行なうことが
できます。単語で適応を行なう場合には、それぞれの単語の事例が、ある印に
どんなスコアを加えるかを、`gnus-default-adaptive-word-score-alist' 変数
によって指定します。

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

これがディフォルト値です。単語での適応を有効にすると、`gnus-read-mark'
の印が付いている記事の表題に現れるすべての単語が、スコアに 30 点追加す
るというスコア規則を生み出します。

`gnus-default-ignored-adaptive-words' のリストに現れる単語は無視されま
す。無視したい単語を追加したいときは、この変数ではなく
`gnus-ignored-adaptive-words' リストの方を使って下さい。

短い単語では適応型スコア付けを作動させるべきではないと思う人もいるでしょ
う。もしそうなら `gnus-adaptive-word-length-limit' に整数を設定すること
ができ、この数値より短い単語は無視されます。この変数のディフォルトは
`nil' です。

スコア付けが行なわれるとき、`gnus-adaptive-word-syntax-table' が実際に
使われるシンタックステーブルです。これは標準シンタックステーブルと似て
いますが、数字を単語の構成要素ではない文字だと認識します。

もし `gnus-adaptive-word-minimum' に数値が設定されていると、単語適応型
スコア付け処理において、記事のスコアがこの数値よりも小さくなることはあ
りません。ディフォルトは `nil' です。

`gnus-acaptive-word-no-group-words' が `t' に設定されていると、Gnus は
グループ名のすべての語について、単語適応型スコア付けをしません。ほとん
どの表題が `emacs' という語を含んでいる `comp.editors.emacs' のようなグ
ループで便利です。

この機構をしばらく使ってみた後で、規則を解析することによってあなたがど
んな単語が好きでどんな単語が嫌いかを診断する `gnus-psychoanalyze-user'
(利用者精神分析命令) を書いてみると良いかもしれません。いや、良くないか
な。

単語適応型スコア付けは高度に実験的なものなので、将来変更されるであろう
ことは心に留めておいて下さい。第一印象では、これは現状ではまったく使い
物にならないように思えます。これをもっと使えるようにするためには、(より
厳密な統計的手法を巻き込んで) さらなる作業が行なわれる必要があるでしょ
う。



File: gnus-ja.info, Node: Home Score File, Next: Followups To Yourself, Prev: Adaptive Scoring, Up: Scoring

ホームスコアファイル
====================

新しいスコアファイルエントリーが入れられるスコアファイルは、ホームスコ
アファイル "home score file" と呼ばれます。これは通常 (ディフォルトで)
そのグループ自身のためのスコアファイルになります。例えば
`gnu.emacs.gnus' 用のホームスコアファイルは `gnu.emacs.gnus.SCORE' です。

しかしながら、これはあなたのお望みではないかもしれません。たくさんのグ
ループの間で共通のホームスコアファイルを共有することはしばしば便利で
す--例えばすべての `emacs' グループが、ことによると同じホームスコアファ
イルを使うことができます。

これを制御する変数が `gnus-home-score-file' です。これは以下の値を取り
得ます:

  1. 文字列。この場合、このファイルがすべてのグループでホームスコアファ
     イルとして使用されます。

  2. 関数。この関数の結果がホームスコアファイルとして使用されます。この
     関数はグループの名前を引数として呼び出されます。

  3. リスト。このリストの要素は以下の値を取り得ます:

       1. `(REGEXP FILE-NAME)'。REGEXP がグループ名に合致すると、
          FILE-NAME がホームスコアファイルとして使用されます。

       2. 関数。この関数が `nil' 以外を返せば、その戻り値がホームスコア
          ファイルとして使用されます。グループ名が引数として関数に渡さ
          れます。

       3. 文字列。この文字列をホームスコアファイルとして使用します。

     このリストは、合致するものを探すために先頭から終りに向かってなぞら
     れます。

というわけで、単一のスコアファイルだけを使いたい場合は、以下のようにす
れば良いでしょう:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

すべての `gnu' グループに対して `gnu.SCORE' を、すべての `rec' グループ
に対して `rec.SCORE' (等々) を使いたい場合は、このように設定することが
できます:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

これは利用者の便宜のために、あらかじめ提供されている関数です。他に以下
の関数があります:

`gnus-current-home-score-file'
     「現在の」標準スコアファイルを返します。これはスコア命令群に「最深」
     の合致するスコアファイルにエントリーを加えさせます。

`emacs' グループ用に一つのスコアファイルを、それとは別のものを `comp'
グループ用に用意する一方、他のすべてのグループではそれぞれ独自のスコア
ファイルを使うようにしたいなら、こんな設定で良いでしょう:

     (setq gnus-home-score-file
           ;; 正規表現 `"\\.emacs"' に合致するすべてのグループ
           '(("\\.emacs" "emacs.SCORE")
             ;; すべての comp グループを単一のスコアファイルで
             ("^comp" "comp.SCORE")))

`gnus-home-adapt-file' は `gnus-home-score-file' とまったく同じやり方で
動作しますが、代わりにこれで、何をホーム適応スコアファイルにするかを指
定します。すべての新しい適応ファイルエントリーは、この変数で指定される
ファイルに入れられ、同じ文法を使うことができます。

`gnus-home-score-file' と `gnus-home-adapt-file' を使うことに加えて、グ
ループパラメーター (*Note Group Parameters::) とトピックパラメーター
(*Note Topic Parameters::) を使っても、ほぼ同様のことを成し遂げることが
できます。グループ、トピックパラメーターはこの変数よりも優先されます。



File: gnus-ja.info, Node: Followups To Yourself, Next: Scoring On Other Headers, Prev: Home Score File, Up: Scoring

自分自身へのフォローアップ
==========================

Gnus は現在のバッファーから `Message-ID' ヘッダーを見つけ出すための二つ
の命令を提供します。そして Gnus は、他の記事の `References' ヘッダーに
あるこの `Message-ID' を使ってスコアを付けるためのスコア規則を追加しま
す。これは事実上、現在のバッファーにある記事に返答したすべての記事のス
コアを増加させます。これは、あなたが言ったことに人々が答えたら、それに
容易に気付かせてもらいたいときに、とても便利です。

`gnus-score-followup-article'
     これは、あなた自身の記事に直接フォローアップした記事にスコアを加え
     ます。

`gnus-score-followup-thread'
     これは、あなたの記事より「下」のスレッドに現れるすべての記事にスコ
     アを加えます。

これら二つの関数は、本来どちらも `message-sent-hook' のようなフックの中
で、例えばこのように使うためのものです:

     (add-hook 'message-sent-hook 'gnus-score-followup-thread)

自分の `Message-ID' をじっくりと眺めてみると、はじめの二〜三文字は常に
同じであることに気が付くでしょう。以下の二つは私のものです:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

したがって、このマシンでは `x6' で「私」かどうかを見分けることができま
す。これは使えます--以下の規則は、私自身へのすべてのフォローアップのス
コアを上げるでしょう:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

「あなたの」が最初の二文字になるか最初の三文字になるかは、システムに依
存します。



File: gnus-ja.info, Node: Scoring On Other Headers, Next: Scoring Tips, Prev: Followups To Yourself, Up: Scoring

他のヘッダーにスコアを付ける
============================

Gnus が「伝統的」なヘッダー ---`From', `Subject' など--にスコアを付ける
のはとても速いです。ですが、他のヘッダーにスコアを付けるには `head' の
スコアのための規則を書く必要があり、それは合致を探すために Gnus が毎回
バックエンドから単独の記事を取り寄せなければならないことを意味します。
これは大きなグループでは長い時間がかかります。

さて、これに関してニュースグループのためにできることは多くはありません
が、メールグループのためにはより優れた手段があります。*Note To From
Newsgroups:: の章でこの機構がどう働くかが詳しく説明されていますが、ここ
ではどうしたら `nnml' で `To' と `Cc' ヘッダーにスコアを付けることがで
きるかの調理の例を挙げましょう。

以下を `~/.gnus.el' ファイルに置いて下さい。

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

Gnus を再起動して、`M-x nnml-generate-nov-databases' コマンドで `nnml'
の overview ファイルを作り直して下さい。たくさんのメールを持っていると、
これには長い時間がかかるでしょう。

そして `I e s p To RET <your name> RET' のようにすると、`To' と `Cc' ヘッ
ダーに“extra headers”としてスコアを付けることができます。

わかったかな? 簡単だよね。

ヘッダーまたは本文の遅いスコア付けは、変数 `gnus-inhibit-slow-scoring'
を設定することによって禁止することができます。もし
`gnus-inhibit-slow-scoring' が正規表現だったら、グループがその正規表現
に合致する場合に遅いスコア付けが禁止されます。それが `t' だったら、すべ
てのグループで遅いスコア付けが禁止されます。



File: gnus-ja.info, Node: Scoring Tips, Next: Reverse Scoring, Prev: Scoring On Other Headers, Up: Scoring

スコア付けの奥義
================

"クロスポスト"
     クロスポストのスコアを低くしたければ、合致させるべき行は `Xref' ヘッ
     ダーです。

          ("xref" (" talk.politics.misc:" -1000))

"複数のクロスポスト"
     ある数、例えば三つ以上のグループにクロスポストされている記事のスコ
     アを低くしたければ、

          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"本文への合致"
     これは一般的にはあまり良い考えではありません--とても長い時間がかか
     るからです。実際 Gnus は、それぞれの記事を個別にサーバーから取得し
     てこなければならないのです。でも、とにかくあなたはやりたいのでしょ
     うね。合致させるキーは三つ (`Head', `Body', `All') あるのですが、
     それぞれのスコアファイルで一つを選んで、それに固執すべきです。もし
     二つを使うと、それぞれの記事は *二回* 取得されてしまいます。もし
     `Head' でちょっとだけ、`Body' でもちょっとだけ合致させたい、という
     のであれば、素直に `All' を使って全部合致させて下さい。

"既読として印を付ける"
     ある一定の値より低いスコアを持つ記事には、おそらく既読の印を付けて
     しまいたくなるでしょう。これは `all.SCORE' ファイルに以下のものを
     入れておくことによって、最も簡単に実現できます。

          ((mark -100))

     同様のことを `expunge' で行なうことを考えても良いでしょう。

"否定文字クラス"
     もし `[^abcd]*' みたいなものを指定すると、期待外れの結果で終わるか
     もしれません。これは改行文字にも合致してしまうので、えーと、未知の
     ものまで引きずり出してしまうもしれません。代わりに `[^abcd\n]*' を
     使いましょう。



File: gnus-ja.info, Node: Reverse Scoring, Next: Global Score Files, Prev: Scoring Tips, Up: Scoring

逆スコア
========

もし、表題ヘッダーに `Sex with Emacs' という文字がある記事だけを残して、
その他の記事すべてを消去してしまいたければ、スコアファイルに以下のよう
なものを入れることができます:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

これで `Sex with Emacs' に合致するすべての記事のスコアが上がって、残り
の記事には既読の印が付き、おまけにそれらは消去されるでしょう。



File: gnus-ja.info, Node: Global Score Files, Next: Kill Files, Prev: Reverse Scoring, Up: Scoring

グローバルスコアファイル
========================

間違いなく、他のニュースリーダーは「グローバル削除ファイル (global
kill file)」を持っています。それらは普通、すべてのグループに適用される、
利用者のホームディレクトリーに格納されている一つの削除ファイル以上の何
物でもありません。ふふん!  つまらない、低能なニュースリーダーだね。

私がここで話しているのはグローバルスコアファイルです。全世界の、あらゆ
る地域の利用者のスコアファイル。それはすべての国家を巨大な一つの幸せな
スコアファイル同盟に団結させる!  スコア天使!  新しい、でもテストされて
いない!

他人のスコアファイルを使うためにしなければならないのは、
`gnus-global-score-files' 変数を設定することがすべてです。それぞれのス
コアファイルにつき一つ、またはそれぞれのスコアファイルディレクトリーに
つき一つのエントリーになります。Gnus はどのスコアファイルをどのグループ
に使うのが適切であるかを自分で決定します。

例えはスコアファイル
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' および
`/ftp@ftp.some-where:/pub/score' ディレクトリーにあるすべてのスコアファ
イルを使いたければ、このように設定して下さい:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

単純でしょう?  ディレクトリー名は `/' で終わらなくてはなりません。これ
らのディレクトリーは、一般に Gnus を使う一回の期間中に一回だけしか読み
込まれません。もし遠隔ディレクトリーを手動で再読み込みすることが必要だ
と思ったら、`gnus-score-search-global-directories' 命令を使って下さい。

ただし、現時点ではこのオプションを使うと、グループに入るのがいくらか遅
くなります。(つまり--かなり、ですけど。)

他の人たちに使ってもらうためにスコアファイルを維持管理したくなったら、
単にあなたのスコアファイルを匿名 ftp に置いて、世界に公表して下さい。逆
行司会者になりましょう!  その後に続いて間違いなく起こる逆行司会者戦争、
すなわち人々の共感を勝ち取るための戦いに参加して、彼らのスコアファイル
に偽りの前提を使わせるように誘導するのです!  やったね!  これでネットは
救われる!

     `retro-' を「逆行」と訳しました。日本では「レトロ」を「古き善き時
     代の」のような肯定的な意味で使うことが少なくないのですが、ここでは
     本来の「時代に逆行した」「使えねー」のような意味で使っています。

以下に、逆行司会者なりたがりのための秘技をいくつか、即席で述べます:

   * 非常に多くの場所にクロスポストされている記事は間違いなく屑である。
   * 一個の不適切な記事を減点するには、`Message-ID' で減点する。
   * 特に素晴らしい投稿者たちは永続的な基準で加算して良い。
   * そのグループの憲章を無視した投稿を頻繁に繰り返す投稿者は、絶滅させ
     てしまって差し支えない。
   * `mark' と `expunge' アトムを設定し、汚らわしい記事を完全に葬り去る。

   * 期限切れ消去のスコア・エントリーを使って、ファイルの大きさを小さく
     抑える。もっとも、サイトによって古い記事を長期間保存するように、お
     そらく長い期限切れ消去の期間を取るでしょうけれども。

... 果たして他のニュースリーダーは、将来グローバルスコアファイルをサ
ポートするでしょうか?  *うふふ*。そう、どう考えてみたって、Blue Wave や
xrn や 1stReader とかいったニュースリーダーは、スコアをサポートするべき
ですね。今は固唾を飲んで見守ることにしましょうか?



File: gnus-ja.info, Node: Kill Files, Next: Converting Kill Files, Prev: Global Score Files, Up: Scoring

消去ファイル
============

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。実際消
去ファイルの項目はもう消してもよいのですが、それは Daniel Quinlan がス
コアファイルを考え出す前に私が書いたものなので、そのコードはまだ残して
あるのです。

要するに、消去処理はスコア処理よりもかなり (私に言わせれば *ものすごく
*) 遅いので、あなたの消去ファイルはスコアファイルに書き換えた方が良いか
もしれません。

いずれにせよ、消去ファイルは普通の `emacs-lisp' ファイルです。このファ
イルの中にはどんな形式でも入れることができます。つまり消去ファイルをグ
ループに入ったときに実行する一種の原始的なフック関数のように使うことが
できます。まあそれがあまりいい方法ではないとしてもね。

通常の消去ファイルは以下のようになります:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

これは私が書いたすべての記事に既読の印を付け、概略バッファーから印の付
いた記事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムではまったく違う消去ファイルの構文を使っています。Gnus は
`rn' の消去ファイルらしきものに出会うと、何とかそれを解釈しようとします。

GNUS 消去ファイルを編集するための二つの概略バッファー関数があります:

`M-k'
     このグループの消去ファイルを編集します
     (`gnus-summary-edit-local-kill')。

`M-K'
     一般消去ファイルを編集します (`gnus-summary-edit-global-kill')。

消去ファイルを編集する二つのグループモード関数があります:

`M-k'
     このグループの消去ファイルを編集します
     (`gnus-group-edit-local-kill')。

`M-K'
     一般消去ファイルを編集します (`gnus-group-edit-global-kill')。

消去ファイル変数:

`gnus-kill-file-name'
     `soc.motss' グループ用の消去ファイルは通常 `soc.motss.KILL' という
     名前です。このファイル名を得るためにグループ名に付加される接尾語は、
     `gnus-kill-file-name' 変数で与えられます。「グローバル」消去ファイ
     ルは (スコアファイルの意味での「グローバル」じゃないよ、もちろん)
     単に `KILL' という名前です。

`gnus-kill-save-kill-file'
     この変数が `nil' 以外であれば、Gnus は処理の後に消去ファイルを保存
     します。これは期限切れ消去を行なう消去を使っているときに必要です。

`gnus-apply-kill-hook'
     グループに消去ファイルを適用するために呼び出されるフック。これはディ
     フォルトでは `(gnus-apply-kill-file)' です。同じグループのためのス
     コアファイルがある場合に消去ファイルを無視したければ、このフックを
     `(gnus-apply-kill-file-unless-scored)' に設定して下さい。消去ファ
     イルを処理させたくなければ、この変数を `nil' に設定して下さい。

`gnus-kill-file-mode-hook'
     消去ファイルモードのバッファー内で呼び出されるフック。



File: gnus-ja.info, Node: Converting Kill Files, Next: Advanced Scoring, Prev: Kill Files, Up: Scoring

消去ファイルの変換
==================

あなたが古い消去ファイルをどっさり持っているのであれば、それらをスコア
ファイルに変換したくなるでしょう。もしそれらが「普通の」ものであれば、
`gnus-kill-to-score.el' パッケージを使うことができます。そうでなければ、
手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準では Gnus には
含まれていません。
`http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'
から入手することができます。

あなたの消去ファイルが非常に複雑なのであれば--それに `gnus-kill' 形式以
外のものがたくさん含まれているのなら、それらを手で変換しなければならな
いでしょう。あるいは、単そのままにしておいて下さい。Gnus は以前と同様に
それらを使ってくれるでしょう。



File: gnus-ja.info, Node: Advanced Scoring, Next: Score Decays, Prev: Converting Kill Files, Up: Scoring

上級スコア付け
==============

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、本当に興味があ
るのが、特定の表題に関してある人が言っていることだけだった場合はどうす
れば良いでしょう?  もしくは、A さんが B さんにフォローアップしていると
きは彼女が言っていることを読みたくないけれど、C さんにフォローアップし
ているときは何を言っているかを知りたいという場合は?

上級スコア規則を使えば、どんな複雑なスコアのパターンでも作成することが
できます。

* Menu:

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限に利用する



File: gnus-ja.info, Node: Advanced Scoring Syntax, Next: Advanced Scoring Examples, Prev: Advanced Scoring, Up: Advanced Scoring

上級スコア付け構文
------------------

普通のスコア規則では、規則の最初の要素が文字列です。上級スコア付け規則
では、最初の要素はリストです。二番目の要素は、最初の要素が `nil' でない
値として評価されたときに適用されるスコアです。

これらのリストは三つの論理演算子、一つのリダイレクト演算子 (訳注: 本文
では間接演算子と表記されています)、および様々な合致演算子で構成すること
ができます。

論理演算子:

`&'
`and'
     この論理演算子は、それぞれの引数を順に評価して、ある評価の結果が
     `false' になったら停止します。すべての引数が `true' の値に評価され
     た場合、この演算子は `true' を返します。

`|'
`or'
     この論理演算子は、それぞれの引数を順に評価して、ある評価の結果が
     `true' になったら停止します。どの引数も `true' でなかったら、この
     演算子は `false' を返します。

`!'
`not'
`,A,'
     この論理演算子はたった一つの引数を取ります。その引数の値の論理否定
     を返します。

スコア付けされている現在の記事の先祖たちに対して、その引数群を適用する
「間接演算子」があります。例えば `1-' は、現在の記事の親にもスコア規則
を適用します。`2-' は現在の記事の祖父母にスコア規則を適用します。代わり
に `^^' を書くこともでき、`^' (caret==キャレット) の数でどのくらい祖先
の記事までさかのぼるかを示します。

最後に合致演算子があります。これらが本当の仕事をするものです。合致演算
子はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合
致演算子は `("form" "Lars Ingebrigtsen" s)' のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。



File: gnus-ja.info, Node: Advanced Scoring Examples, Next: Advanced Scoring Tips, Prev: Advanced Scoring Syntax, Up: Advanced Scoring

上級スコア付けの例
------------------

以下の例はスコアファイルの規則であることに注意して下さい。それらを使っ
て完璧なスコアファイルを作るには、別の括弧の組でそれらを囲んで下さい。

Lars が Gnus に関して話をしているときに、彼によって書かれた記事のスコア
を増やしたいとしましょう:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

ふん、簡単すぎるかな?

彼が長い記事を書くとき、時々何か素敵なことを言います:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigil Logge")))
      -100000)

Redmondo が消えた靴下について書いたときにフォローアップしたすべての人の
スコアが上げられますが、それは彼らが白い靴下について語っているときのみ
です。しかし Lars が靴下について話をしているときは、たいていあまりおも
しろくありません:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

大量の記事が流れているグループを読んでいて、返答にしか興味が無いとしま
しょう。そういう場合にやることは、"Re:"、"Fw:" または "Fwd:" で始まる表
題を持っていないすべての記事のスコアを下げて、返答の印で始まる表題を持っ
ている記事のすべての親のスコアを上げることです。

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

可能性は無限大です。



File: gnus-ja.info, Node: Advanced Scoring Tips, Prev: Advanced Scoring Examples, Up: Advanced Scoring

上級スコアのちょっとした秘訣
----------------------------

`&' と `|' 論理演算子は、無意味な処理を迂回する論理 (原典:
short-circuit logic) に基づいて動作します。すなわち、その処理の結果が明
らかになった時点で、引数を処理することを止めます。例えば `&' の引数の一
つが `false' に評価されると、残りの引数を評価する意味がありませんから。
これは遅い合致 (`body' や `header') を最後に持ってきて、速い合致
(`from' や `subject') を最初に持ってくるべきであることを示唆します。

間接演算子 (`1-' など) は、それらの引数をスレッドの一世代前に作用させま
す。次のようなことをすると:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

これは「現在の記事の祖父母の from ヘッダーでスコアを付ける」ということ
を意味します。間接演算子の処理はとても速いのですが、以下のやり方の方が:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

次のものより良いです:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))



File: gnus-ja.info, Node: Score Decays, Prev: Advanced Scoring, Up: Scoring

スコアを減衰させる
==================

スコアは (特に適応スコアを使っていると) 際限無く膨れ上がる傾向があるこ
とに気が付くでしょう。スコアが大きくなりすぎると、それらはすべての意味
を失います--それらは単に最大値に達してしまうので、意味のある方法で使う
ことは難しくなります。

Gnus はこの問題の解決を助けるためにスコアを減衰させる機構を提供します。
スコアファイルが読み込まれて、`gnus-decay-scores' が `nil' ではないと、
Gnus はスコアファイルを減衰機構に通して、すべての永続でないスコア規則の
スコアを下げます。もし `gnus-decay-scores' が正規表現だったら、それに合
致するスコアファイルだけが扱われます。例えば *adaptive* スコアファイル
だけを減衰させるには、それを `\\.ADAPT\\'' に設定すれば良いでしょう。減
衰そのものは `gnus-decay-score-function' 関数によって実行され、ディフォ
ルトは `gnus-decay-score' です。以下はその関数の定義です:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

`gnus-score-decay-constant' はディフォルトで 3、
`gnus-score-decay-scale' は 0.05 です。これは以下のようなことを引き起こ
します:

  1. この関数が呼ばれたときに -3 から 3 の間のスコアは 0 に設定されます。

  2. 3 から 60 までの間の大きさのスコアは 3 減らされます。

  3. 60 より大きいスコアはスコアの 5% が減らされます。

もしこの減衰関数がお気に召さないなら、自分用の関数を書いて下さい。それ
は減衰させるべきスコアを唯一の引数として呼ばれ、新しいスコアを整数で返
さなければなりません。

Gnus は一日に一回スコアを減衰させようとします。例えば Gnus を四日間走ら
せていないと、Gnus はスコアを四回減衰させます。




File: gnus-ja.info, Node: Various, Next: The End, Prev: Scoring, Up: Top

いろいろ
********

* Menu:

* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーの見栄えを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Compilation::                 Gnus を速くするには
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Buttons::                     たった十回たたいただけで腱鞘炎になる!
* Daemons::                     Gnus はあなたの裏で仕事をすることができる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* Image Enhancements::          最新の Emacs/XEmacs は画像を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        頼んでもいない広告メールを避ける簡単な方法
* Spam Package::                Spam を濾過して処理するためのパッケージ
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの



File: gnus-ja.info, Node: Process/Prefix, Next: Interactive, Prev: Various, Up: Various

プロセス/接頭引数
=================

多くの関数、その中でも記事の移動、デコード、保存をするための関数は、
「プロセス/接頭引数の習慣」として知られているものを使います。

これは、利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

数値接頭引数が N だったら、現在の記事を含めた次の N 個の記事に対して作
業を実行します。もし数値接頭引数が負だったら、現在の記事を含めた前の N
個の記事に対して作業を実行します。

`transient-mark-mode' が `nil' ではなく、リージョンが設定されていたら、
リージョンにあるすべての記事で作業が行なわれます。

数値接頭引数が無くても、いくつかの記事はプロセス印が付いている場合には、
プロセス印が付いている記事で作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事でだけ
作業を実行します。

これは実際とても単純なのですが、びっくりされないためにも、はっきりさせ
ておく必要があります。

プロセス印に反応するコマンドは、現在プロセス印が付いている記事のリスト
をスタックに積んで、記事のすべてのプロセス印を消去します。前回の設定を
`M P y' で復旧させることができます (*Note Setting Process Marks::)。

多くの人々をぎょっとさせ、恐がらせると思われることの一つは、例えば `3
d' が、本当に `d' `d' `d' と同じことをすることです。それぞれの `d' (こ
れは現在の記事に既読の印を付けます) は、ディフォルトでは印を付けた後で
次の未読記事に移動するので、`3 d' は概略バッファーがどうなっていても、
次の三つの未読記事を既読にします。動作をもっと分かりやすくするには、
`gnus-summary-goto-unread' を `nil' に設定して下さい。

多くのコマンドはプロセス/接頭引数の習慣を使いません。それをしないすべて
のコマンドは、このマニュアルで明記されています。そういうコマンドにプロ
セス/接頭引数の習慣を適用するには、`M-&' コマンドを使って下さい。例えば、
そのグループのすべての記事を期限切れ消去可能として印を付けるには `M P
b M-& E' とします。



File: gnus-ja.info, Node: Interactive, Next: Symbolic Prefixes, Prev: Process/Prefix, Up: Various

利用者との相互作用
==================

`gnus-novice-user'
     この変数が `nil' でないのは、あなたは Usenet の世界の新参者か非常
     に慎重な人のどちらかだというです。これは本当に良いことです。何か危
     険なことをする前に、「本当にこれをしたいのですか?」というような質
     問を受けます。これはディフォルトでは `t' です。

`gnus-expert-user'
     この変数が `nil' でないと、あなたが Gnus から質問を受けることは滅
     多に無いでしょう。これは単純に、あなたがどんな変なことをしても、何
     をしているかをわかっていると見なします。

`gnus-interactive-catchup'
     `nil' でないと、グループに追いつく (catchup, 未読の記事を読んだこ
     とにしてしまう) 前に、確認を求めます。ディフォルトで `t' です。

`gnus-interactive-exit'
     Gnus を終了する前に確認を求めます。ディフォルトで `t' です。



File: gnus-ja.info, Node: Symbolic Prefixes, Next: Formatting Variables, Prev: Interactive, Up: Various

シンボルの接頭引数
==================

非常に多くの Emacs の命令が (数値) 接頭引数に反応します。例えば `C-u 4
C-f' はポイントを 4 文字先に移動し、`C-u 9 0 0 I s s p' は 900 のスコア
(永続、`Suject'、文字列の一部、という規則) を現在の記事に加えます。

これはすべて素敵で良いのですが、命令にもう少し追加の情報を与えたいとき
はどうすれば良いのでしょう?  えーと、たいていの命令がしていることは「生
の」接頭引数を何らかの特別な方法で解釈することです。例えば `C-u 0 C-x
C-s' は、現在の記事を保存するときにバックアップファイルを作らないで欲し
いことを意味します。でも、バックアップファイルを作らないで保存するのと
同時に、Emacs に閃光を放って、素敵な音楽を演奏して欲しいときはどうすれ
ば良いでしょう?  それができなくても、あなたは申し分なく幸せですね(?)。

私はそうではありません。そこで、私は二つめの接頭引数「シンボル接頭引数」
を加えました。接頭キーは `M-i' (`gnus-symbolic-argument') で、次に押さ
れる文字が値です。いくらでも `M-i' 接頭語を積み重ねることができます。
`M-i a C-M-u' は「`C-M-u' 命令にシンボル接頭引数 `a' を与える」というこ
とです。`M-i a M-i b C-M-u' は「`C-M-u' 命令にシンボル接頭引数 `a' `b'
を与える」ということです。趣旨はわかりましたね。

シンボル接頭引数を受け付けない命令にそれを打ち込んでも何も悪いことをし
ませんが、良いことも何もしません。現在のところ、あまり多くの関数がシン
ボル接頭引数を利用しているわけではありません。

Gnus がこれを実装しているやり方に興味があるなら、
*Note Extended Interactive:: を見て下さい。



File: gnus-ja.info, Node: Formatting Variables, Next: Window Layout, Prev: Symbolic Prefixes, Up: Various

書法仕様変数
============

このマニュアルを通して、おそらく `gnus-group-line-format' または
`gnus-summary-mode-line-format' のように呼ばれるたくさんの変数があるこ
とに気付いたでしょう。これらは Gnus が色々なバッファーでどのように行を
出力するかを制御します。非常にたくさんのものがあります。幸運なことに、
それらはすべて同じ構文を使うので、あまり嫌な目には会わないでしょう。

書法仕様 (format) 指定の例です (グループバッファーより):
`%M%S%5y: %(%g%)\n'。それは極めて醜く、たくさんのパーセント記号がい
たるところにあります。

* Menu:

* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を変化させる
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う

現在のところ Gnus は以下の書法仕様変数を使います:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format', `gnus-summary-mode-line-format',
`gnus-article-mode-line-format', `gnus-server-mode-line-format', および
`gnus-summary-pick-line-format'。

これらすべての書法仕様変数は任意の elisp 式であることもできます。その場
合、それらは要求される行に挿入するために `eval' (評価) されます。

Gnus は、あなたが自分用の書法仕様指定を作っているときに、手助けをする命
令を備えています。`M-x gnus-update-format' は現在の式を `eval' し、当の
仕様を更新し、行を生成するための Lisp 式を検査することができるバッファー
に移動します。



File: gnus-ja.info, Node: Formatting Basics, Next: Mode Line Formatting, Prev: Formatting Variables, Up: Formatting Variables

書法仕様の基本
--------------

それぞれの `%' の要素は、当のバッファーが作成されるときに何らかの文字列
や他のもので置き換えられます。`%5y' は「`y' 指定を挿入して、5 文字の場
所を得るために空白を詰め込みなさい」ということです。

普通の C や Emacs Lisp の書法仕様 (format) 文字列と同じように、`%' と書
法仕様の型の文字の間の数値修飾子は、常に少なくともその長さになるように、
出力に (空白文字などを)「詰め込み」ます。`%5y' はその場所が常に (少なく
とも) 5 文字の長さになるように、左に空白を詰め込みます。もし `%-5y' と
すれば、代わりに右側に詰め込みます。

特に広い幅の値に対して保護するために、その場所の長さを制限したいことも
あるでしょう。そのために `%4,6y' などと指定することができます。これは、
その場所は決して 6 文字を超える幅にはならず、かつ 4 文字より少ない幅に
もならないということです。

Gnus は `%&user-date;' のような、いくつかの拡張様式指示もサポートします。



File: gnus-ja.info, Node: Mode Line Formatting, Next: Advanced Formatting, Prev: Formatting Basics, Up: Formatting Variables

モード行書法仕様
----------------

モード行書法仕様変数 (例えば `gnus-summary-mode-line-format') は、以下
の二つの違い以外は、バッファー行に適応した書法仕様変数 (*Note
Formatting Basics::) と同じ規則に従います:

  1. 最後に改行 (`\n') があってはなりません。

  2. 特別な `%%b' 仕様をバッファー名を表示するために使うことができます。
     えーと、実はそれは仕様ではないのです---`%%' というものは、Emacs が
     `%b' を受け取って、そのモード行表示機能に「バッファー名を表示しな
     さい」と解釈させるために、単に書法仕様の処理系を無傷で通り抜けるこ
     とができるように `%' を囲う方法なのです。Emacs が理解するモード行
     指定の完全な一覧については、変数 `mode-line-format' の説明文を見て
     下さい。



File: gnus-ja.info, Node: Advanced Formatting, Next: User-Defined Specs, Prev: Mode Line Formatting, Up: Formatting Variables

上級書法仕様
------------

表示された領域を後で何らかの方法で処理するのは、しばしば役に立ちます。詰
め込み、制限、切り取り、および特定の値の抑制は、「チルダ修飾子」を使うこ
とによって実現することができます。よくあるチルダ仕様は、
`%~(cut 3)~(ignore "0")y' のように見えるでしょう。

これらは有効な修飾子です:

`pad'
`pad-left'
     領域の左側に、要求された長さになるまで空白を詰め込みます。

`pad-right'
     領域の右側に、要求された長さになるまで空白を詰め込みます。

`max'
`max-left'
     指定された長さになるように、文字列の左側を切り取ります。

`max-right'
     指定された長さになるように、文字列の右側を切り取ります。

`cut'
`cut-left'
     指定された数の文字を左側から切り落とします。

`cut-right'
     指定された数の文字を右側から切り落とします。

`ignore'
     領域が指定された値と等しい (equal) ならば、空文字列を返します。

`form'
     `@' 仕様が使われたときに、指定された式を領域の値として使います。

     これは例です:

          "~(form (current-time-string))@"

例を出してみましょう。概略モード行での `%o' 仕様は ISO0861 様式の凝縮さ
れた日付 (`19960809T230410' のようなもの) を返します。これはとても発音
しにくいので、世紀を表す数と時刻を削ぎ落として、6 文字の日付を残したい
と思います。それは `%~(cut-left 2)~(max-right 6)~(pad 6)o' となるでしょ
う。(切り落とし (cutting) は 最大幅の制限 (maxing) より先に行なわれるの
で、表示欄での見栄えを良くするために、日付が 6 文字より少なくならないこ
とを保証する詰め込み (padding) が必要になります。)

無視 (ignore) が最初に行なわれます。それから切り落とし (cutting)、次に
最大幅の制限 (maxing)、そして最後の操作である詰め込み (padding) が行な
われます。

もしあなたが、これらの上級参照をたくさん使っているなら、Gnus がとても遅
くなるのがわかるでしょう。これはあなたが行の外見に満足したときに `M-x
gnus-compile' を実行することによって、格段に速度低下を減らすことができ
ます。*Note Compilation::.



File: gnus-ja.info, Node: User-Defined Specs, Next: Formatting Fonts, Prev: Advanced Formatting, Up: Formatting Variables

利用者定義の指定
----------------

すべての仕様に、利用者が定義した `u' で始まる述語を挿入することができま
す。書法仕様文字列の次の文字は、アルファベットでなければなりません。
`%u' に続くアルファベットが `X' だったら、Gnus は関数
`gnus-user-format-function-'`X' を呼びます。関数には単一の引数が与えら
れますが、その引数の意味は関数がどのバッファーから呼ばれているかによっ
て変わります。関数は文字列を返さなければなりません。それは他の述語によっ
て生成される情報とまったく同じように、バッファーに挿入されます。関数は
意味の無い値と共に呼ばれる場合もあるので、それの対策をしておくべきです。

Gnus は利用者定義仕様を拡張した `%u&foo;' のような形式もサポートします。
この場合は `gnus-user-format-function-'`foo' という関数を呼び出します。

新しい関数を定義しなくても、ほとんど同じことをチルダ修飾子 (*Note
Advanced Formatting::) を使って達成できるでしょう。例です:

`%~(form (count-lines (point-min) (point)))@'

ここで与えられた式は評価されて現在の行番号をもたらし、それから挿入され
ます。



File: gnus-ja.info, Node: Formatting Fonts, Next: Positioning Point, Prev: User-Defined Specs, Up: Formatting Variables

書法仕様フォント
----------------

すべての書法仕様変数によって共有される、ハイライト (強調表示) のための
仕様があります。述語 `%(' と 述語 `%)' で囲まれたテキストには特別な
`mouse-face' 属性が与えられ、そこにマウスのポインターを置いたときに
(`gnus-mouse-face' によって) ハイライトされます。

述語 `%{' と 述語 `%}' で囲まれたテキストには、普通のフェー
スである `gnus-face-0' (ディフォルトで `bold') が与えられます。
`%{1' を使うと、代わりに `gnus-face-1' が与えられ、以下同様で
す。欲しいだけたくさんのフェースを作って下さい。同じこと
が `mouse-face' 仕様にも言えます。`hello' がマウスを置いたとき
に `gnus-mouse-face-3' でハイライトされるためには、
`%3(hello%)' とすれば良いでしょう。

述語 `%《' と 述語 `%》' で囲まれたテキストでは、特別な `balloon-help'
属性が `gnus-balloon-face-0' に設定されます。`%1《' とすると、
`gnus-balloon-face-1' が使われ、以下同様です。`gnus-balloon-face-*' 変
数は、文字列か文字列を返す関数を指すシンボルのどちらかでなければなりま
せん。この属性が設定されているテキストの上をマウスが通過すると、吹き出
しが現れて文字列を表示します。これの詳しい情報は *Note Tooltips:
(emacs)Tooltips, (GNU Emacs) または `balloon-help-mode' (XEmacs) の説明
を参照して下さい。(技術的な理由のために、ギィメ (guillemets) はこの節で
は `《' と `》' で近似されました。)

     訳注: guillemets (仏語) はギュメとも表記されます。実際に Gnus で有
     効なのは次の二つです:

          (string (make-char 'latin-iso8859-1 43)) ;; 《
          (string (make-char 'latin-iso8859-1 59)) ;; 》

     日本語の「」に当たるもので、口頭表現を表記したり、強調したい単語を
     囲む、何かからの引用部分を囲む、書物等のタイトルを記す等様々に使わ
     れます。

これはグループバッファーで使うことができる、もう一つの調理法です:

     ;; 三つのフェースを作ります。
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; 記事の数をボールドで緑のフェースにしたいので、
     ;; `my-green-bold' という新しいフェースを作ります。
     (copy-face 'bold 'my-green-bold)
     ;; 色を設定します。
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; 新しい特製の書法仕様を設定します。
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

あなたがこの案を使って、完全に読めなくて非常に下品な表示を作ることがで
きることを確信しています。楽しんで下さい!

`%(' 指定 (やその類のもの) は、モード行変数ではまったく意味をなさないこ
とに注意して下さい。



File: gnus-ja.info, Node: Positioning Point, Next: Tabulation, Prev: Formatting Fonts, Up: Formatting Variables

ポイントの移動
--------------

Gnus は通常ほとんどのバッファーで、ポイントを各行のあらかじめ決められた
場所に移動します。ディフォルトでは、ポイントは行の最初のコロンに移動し
ます。この振るまいは、三つの違う方法でカスタマイズすることができます。

また、コロンを行のどの場所にでも移動することができます。

コロンの位置にポイントを移動させるための関数を定義し直すことができます。
その関数は `gnus-goto-colon' と呼ばれています。

でも、行にコロンを含めたくないならば、これを扱うためのおそらく最も手ご
ろな方法は `%*' という述語を使うことです。あなたの行の書法仕様の定義に
`%*' を入れておけば、Gnus はそこにポイントを置きます。



File: gnus-ja.info, Node: Tabulation, Next: Wide Characters, Prev: Positioning Point, Up: Formatting Variables

整列
----

通常は、空白文字を詰め込んだり端を切り落とすことによって、文字列をディ
スプレイに並べることができます。でも大きさが違う異なる文字列を連結させ
る場合は、単に文字列を出力してしまうのがより手ごろであることが多いはず
で、しかしそうするとその後に続くテキストを並べるのに悩むことになります。

それを行なうために、Gnus は整列子 (tabulator) の仕様 `%=' を備えていま
す。これには二つの形式 "hard tabulators" および "soft tabulators" があ
ります。

`%50=' は文字列が 50桁までの場所を占めるように空白文字を詰め込みます。
もし挿入するテキストの末端が 50桁より後ろになる場合は何も挿入しません。
これは穏やか (soft) な整列子です。

`%-50=' もまた、文字列が 50桁までの場所を占めるように空白文字を詰め込み
ます。ですが、もし挿入するテキストの末端が 50桁より後ろになる場合は、
50桁より後ろになる過剰なテキストは削除されます。これは厳密 (hard) な整
列子です。



File: gnus-ja.info, Node: Wide Characters, Prev: Tabulation, Up: Formatting Variables

Wide Characters
---------------

多くの地域において、固定幅フォントは同じ幅の文字を持っています。しかし
いくつかの地域、よく知られている東アジアの国々では、ラテン文字と幅の広
い文字が混在して使われています。

整形において、Gnus は文字列が 10個の文字の幅だとしたら、スクリーンでも
10個分のラテン文字の幅になると仮定しますが、それは問題です。かの国々で
は、それは正しくありません。

それを救済するために、あなたは `gnus-use-correct-string-widths' を `t'
に設定することができます。これはバッファーの生成を遅くしますが、より美
しい結果を得ることができるでしょう。ディフォルト値は XEmacs では `t' で
すが Emacs では `nil' です。(訳注: 日本語などを Emacs で表示する場合に、
書法仕様によっては `t' にしないと概略バッファーの表示が不揃いになること
があります。)



File: gnus-ja.info, Node: Window Layout, Next: Faces and Fonts, Prev: Formatting Variables, Up: Various

ウィンドウの配置
================

いえ、X に関することはありませんから、おとなしくして下さい。

もし `gnus-use-full-window' が `nil' でないと、Gnus はすべての他のウィ
ンドウを消して、Emacs の画面全体を占有します。これはディフォルトで `t'
です。

この変数を `nil' に設定してもそれなりに動作しますが、問題もあります。危
険を覚悟の上で使って下さい。

`gnus-buffer-configuration' はそれぞれの Gnus のバッファーがどのくらい
の空間を与えられるべきかを現します。これはこの変数の抜粋です:

     ((group (vertical 1.0 (group 1.0 point)
                           (if gnus-carpal (group-carpal 4))))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

これは連想リストです。「キー」は何らかの動作を名付けるためのシンボルで
す。例えば、グループバッファーを表示するときは、ウィンドウを設定するた
めの関数は `group' をキーとして使います。使用可能な名前の完全な一覧は下
に挙げられています。

「値」(すなわち「分割」) は、それぞれのバッファーがどれくらいの空間を占
めるべきかを指定します。`article' の分割を例に取ると

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

この「分割」は概略バッファーが画面の上の 25% を占めるべきで、それは記事
バッファーの上に配置されると言っています。お気づきのように、100% + 25%
は実際は 125% です (えぇ、皆さんの計算はこの様になったと思います。) し
かし、特別な数値 `1.0' は、残りのバッファーが必要なものを取り去った後に、
使用可能な残りの空間すべてを吸い取る、ということを合図するために使われ
ます。`1.0' の大きさを指定するバッファーは、一つの分割につき一つだけで
なくてはなりません。

ポイント (カーソル) は省略可能な三つ目の要素、`point' を持つバッファー
に置かれます。`frame' 分割では、`frame-focus' タグが含まれている枝葉の
分割を持っている副分割の、最後のもののフレームがフォーカスを得ることに
なります (`frame-focus' タグは、それを含んでいる枝葉リストにおいて、
`point' タグが無ければ三番目の、あれば四番目の要素になります。

次はもっと複雑な例です:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (if gnus-carpal (summary-carpal 4))
                            (article 1.0)))

もし大きさの指定が浮動小数点数の代わりに整数だったなら、それは割合では
なく、どのくらい多くの行をバッファーが占めるべきかを指定するために使わ
れます。

もし「分割」が `eval' (評価) されるもののように見えるときは (正確に言う
と--分割の `car' が関数か原始関数 (subr) であるときは)、この分割は
`eval' されます。結果が `nil' でないなら、それは分割として用いられます。
これは、`gnus-carpal' が `nil' であれば三つのバッファーが、
`gnus-carpal' が `nil' でないなら、四つのバッファーが存在することになる
ということです。

まだ複雑ではないですって? それでは、大きさとしてこれを試してみて下さい:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0)
                      (gnus-carpal 4))
                  (vertical 1.0
                      (summary 0.25 point)
                      (summary-carpal 4)
                      (article 1.0))))

おぉっと。二つのバッファーに謎の 100% タグが付いています。そして
`horizontal' って何でしょう?

もし分割の一つの最初の要素が `horizontal' であったなら、Gnus はウィンド
ウを水平に分割し、二つのウィンドウを横に並べます。これらのそれぞれの小
片の中では、あなたのやりたいことをすべて普通の流儀で行なうことができま
す。`horizontal' の後の数値は、この小片に画面のどれくらいの割合が与えら
れるかを指定します。

それぞれの分割では、100% のタグを持つ要素が *必ず* 一つある必要がありま
す。分割は決して正確ではないので、分割によって余ったすべての行を、この
バッファーが分捕ります。

もう少し形式的に、有効な分割がどのようになるかの定義を挙げておきましょ
う:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

制限として、`frame' は最も上位階層の分割としてしか現れることができない
というものがあります。`form' は有効な分割を返す Emacs Lisp の式 (form)
でなければなりません。それぞれの分割は完全に再帰的で、任意の数の
`vertical' と `horizontal' 分割を含むことができます。

正しい大きさを見つけることは、少し複雑になります。どのウィンドウも
`gnus-window-min-height' (ディフォルトは 1) の文字の高さよりも小さくて
はならないし、少なくとも `gnus-window-min-width' (ディフォルトは 1) の
文字幅でなくてはなりません。Gnus は分割を適用する前にこれを強制しようと
試みます。もし標準の Emacs のウィンドウの幅/高さ制限を使いたいなら、こ
の二つの変数を `nil' にするだけで良いです。

Emacs の用語になじんでいないのなら、`horizontal' と `vertical' の分割は、
期待したものと反対の動作をするでしょう。`horizontal' 分割の中のウィンド
ウは横に並んで表示され、`vertical' 分割の中のウィンドウは上下に表示され
ます。

ウィンドウの配置に関して実験をしてみたいのであれば、良い方法は分割を引
数にして直接 `gnus-configure-frame' を呼ぶことです。これはバッファーを
分割するときにすべての実際の仕事をする関数です。下のものは五つのウィン
ドウを作るかなりばかげた設定です。二つをグループバッファーに、三つを記
事バッファーのために充てます。(だから、ばかげていると言ったでしょ。) も
し下の文を `評価' すると、普通の Gnus の経路を使わないで、すぐにそれが
どのように見えるかの直観を得ることができます。満足するまでそれで遊んで、
それから `gnus-add-configuration' を使って新しい作品をバッファー配置リ
ストに加えて下さい。

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

複数のフレームも欲しいかもしれません。問題ありません---`frame' 分割を使
うだけです:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))

この分割の結果は、最初の (もしくは「主たる」) フレームに見慣れた概略/記
事ウィンドウを配置し、小さな追加のフレームが picon を表示するために作ら
れます。ご覧の通り、普通の最上位階層の `1.0' の定の代わりに、それぞれの
追加の分割が大きさの指定として、フレームパラメーターの連想リストを持た
なければなりません (*Note Frame Parameters: (elisp)Frame Parameters.)。
XEmacs では、フレームプロパティーリストも使えます--例えば `(height 5
width 15 left -1 top 1)' がそのような plist です。
`gnus-buffer-configuration' で使うことができるすべてのキーの一覧は、そ
のディフォルト値で見つけることができます。

キー `message' は `gnus-group-mail' および
`gnus-summary-mail-other-window' の両方で使われることに注意して下さい。
もし二つを区別するほうが望ましいなら、このような物を使うことができます:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

良くある複数のフレーム分割の要望は、メールとニュースの作成には別のフレー
ムを使い、元のフレームはそのままに残すというものです。これの達成には、
以下のようなものでできます。

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

訳注: これを高度に発展させたものが
`http://www.jpl.org/elips/message-multiple-frames.el.gz' として入手でき
ます。使い方はファイルの冒頭に書かれています。

変数 `gnus-buffer-configuration' はとても長く複雑なので、単一の設定の変
更を簡単にするための関数があります: `gnus-add-configuration' です。例え
ば `article' の設定を変えたいのなら、次のようにできます:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

普通はこれらの `gnus-add-configuration' の呼び出しを `~/.gnus.el' ファ
イルに入れるか、何らかの起動時のフックに入れるでしょう--それらは Gnus
が読み込まれた後で実行されなければなりません。

もし分割の設定で指定されたすべてのウィンドウがすでに見えているのであれ
ば、Gnus はウィンドウの配置を変更しません。常に「正しい」ウィンドウ設定
を強制したいのであれば、`gnus-always-force-window-configuration' を
`nil' でない値に設定して下さい。

木表示 (*Note Tree Display::) を使っていて、木ウィンドウが垂直方向に次
の別のウィンドウで表示されるなら、ウィンドウの大きさが変更されることを
避けるために `gnus-tree-minimize-window' をいじるのが良いでしょう。


ウィンドウ配置の例
------------------

   * 左側を狭めてグループバッファーに。右側を分割して概略バッファー (上
     1/6) と記事バッファー (下) に。

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))



File: gnus-ja.info, Node: Faces and Fonts, Next: Compilation, Prev: Window Layout, Up: Various

フェースとフォント
==================

かつてフォントとフェースをいじくるのは非常に難しかったのですが、今日で
は非常に簡単です。単に `M-x customize-face' とやって、変えたいフェース
を選び出して、標準のカスタマイズインターフェースを使って変更することが
できます。



File: gnus-ja.info, Node: Compilation, Next: Mode Lines, Prev: Faces and Fonts, Up: Various

コンパイル
==========

あの行書法仕様指定変数を覚えていますか? `gnus-summary-line-format',
`gnus-group-line-format' などなどです。さて、Gnus はこれらの変数が何で
あっても注意を払いますが、残念ながらそれらを変更すると大変重大な速度低
下を引き起こすことになります。(これらの変数のディフォルト値は、それらに
関連付けられたバイトコンパイルされた関数を持っていますが、利用者作成の
ものはもちろんそうではありません。)

これを改善するために、変数をいじくりまわして、(なんとなく) 満足したと感
じた後で、`M-x gnus-compile' を実行することができます。これは新しい指定
がバイトコンパイルされ、もう一度最高速度に復帰できるということです。
Gnus はこれらのバイトコンパイルされた指定を `.newsrc.eld' ファイルに保
存します。(もっとも利用者が定義した関数は、この関数によってコンパイルさ
れません--それらを `~/.gnus.el' ファイルに突っ込んでから、自分でそのファ
イルをバイトコンパイルしなければなりません。)



File: gnus-ja.info, Node: Mode Lines, Next: Highlighting and Menus, Prev: Compilation, Up: Various

モード行
========

`gnus-updated-mode-lines' はどのバッファーがそれらのモード行を常に最新
のものにしておくかを指定します。それはシンボルのリストです。使うことの
できるシンボルは `group', `article', `summary', `server', `browse',
`tree' などです。もし対応するシンボルが存在すると、Gnus は該当する情報
でモード行を更新します。この変数が `nil' ならば、画面の再描画はもっと速
いでしょう。

ディフォルトでは、Gnus は概略バッファーと記事バッファーのモード行に現在
の記事の情報を表示します。Gnus が表示したい情報 (例えば記事の表題) はし
ばしばモード行よりも長いことがあるので、どこかで切り落とされなければな
りません。変数 `gnus-mode-non-string-length' はその行の他の要素 (すなわ
ち情報でない部分) がどのくらいの長さであるかを指定します。もしモード行
に追加の要素を入れたなら、この変数を修正する必要があります:

     (add-hook 'display-time-hook
               (lambda () (setq gnus-mode-non-string-length
                                (+ 21
                                   (if line-number-mode 5 0)
                                   (if column-number-mode 4 0)
                                   (length display-time-string)))))

もしこの変数が `nil' であるなら (これがディフォルトですが)、モード行は
切り落とされず、詰め込みもされません。ディフォルトでは、バッファーの完
全なパーセント表示さえもモード行から追いやられる可能性もあるので、おそ
らく望ましい設定ではないことに注意して下さい。利用者が自分の設定に合う
ようにこの変数を適切に設定しなければなりません。



