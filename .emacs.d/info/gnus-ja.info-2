Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY






File: gnus-ja.info, Node: Mailing List, Prev: Security, Up: Summary Buffer

メーリングリスト
================

Gnus は RFC 2369 で規定された各種のメーリングリストで使われるフィールド
を理解します。これを有効にするには概略バッファーで `A M'
(`gnus-mailing-list-insinuate') を使うなどして、`to-list' グループパラ
メーター (*Note Group Parameters::) を追加してください。

これによって概略バッファーでの以下の命令が使えるようになります。

`C-c C-n h'
     List-Help フィールドがあったら、メーリングリストのヘルプを取り寄せ
     るためのメッセージを送信します。

`C-c C-n s'
     List-Subscribe フィールドがあったら、メーリングリストの講読を始め
     るためのメッセージを送信します。

`C-c C-n u'
     List-Unsubscribe フィールドがあったら、メーリングリストの講読をや
     めるためのメッセージを送信します。

`C-c C-n p'
     List-Post フィールドがあったら、メーリングリストに投稿します。

`C-c C-n o'
     List-Owner フィールドがあったら、メーリングリストの管理者宛てにメッ
     セージを送信します。

`C-c C-n a'
     List-Archive フィールドがあったら、メーリングリストのアーカイブを
     閲覧します。



File: gnus-ja.info, Node: Article Buffer, Next: Composing Messages, Prev: Summary Buffer, Up: Top

記事バッファー
**************

記事は一つしかない記事バッファーに表示されます。すべての概略バッファー
は (Gnus に指示しない限り) 同じ記事バッファーを共有します。

* Menu:

* Hiding Headers::              どのヘッダーを表示するかを決める
* Using MIME::                  読む前に記事を MIME に通す
* Customizing Articles::        記事の見栄えを仕立てる
* Article Keymap::              記事バッファーで使えるキー操作
* Misc Article::                その他



File: gnus-ja.info, Node: Hiding Headers, Next: Using MIME, Prev: Article Buffer, Up: Article Buffer

余分なヘッダーを隠す
====================

各記事の頭の部分はヘッダー ("head") と呼ばれます。(残りの部分はボディー
("body") です。すでにお気づきでしょうが。)

ヘッダーにはたくさんの有益な情報が含まれています。記事を書いた人の名前、
それが書かれた日付、および記事の表題です。これはとても良いのですが、ヘッ
ダーには大部分の人にとっては見たくもない情報--記事があなたのところに着
くまでにどんなシステムを経由してきたか、`Message-ID'、
`References' などなど…もううんざりするくらい--たくさん含まれてい
ます。たぶんあなたはこれらの行のいくつかは取り除いてしまいたいと思うでしょ
う。もしこれらの行をすべて記事バッファー内に残しておきたければ、
`gnus-show-all-headers' を `t' に設定してください。

Gnus はヘッダーを選り分けるために二つの変数を用意しています:

`gnus-visible-headers'
     この変数が `nil' 以外であれば、どのヘッダーを記事バッファーに残し
     たいかを指定する正規表現であるとみなされます。この変数に合致しない
     ヘッダーはすべて隠されます。

     例えば、記事を書いた人の名前と表題のみを見たければ、こう指定します:

          (setq gnus-visible-headers "^From:\\|^Subject:")

     この変数は、表示させたいヘッダーに合致する正規表現をリストで指定す
     ることもできます。

`gnus-ignored-headers'
     この変数は `gnus-visible-headers' の反対です。この変数が設定されて
     いれば (かつ `gnus-visible-headers' が `nil' であれば)、これは隠し
     たいヘッダー行すべてに合致する正規表現であるとみなされます。この変
     数に合致しないすべてのヘッダー行が表示されます。

     例えば、単に `References' 欄と `Xref' 欄のみを消し去りたければ、以
     下のようにします:

          (setq gnus-ignored-headers "^References:\\|^Xref:")

     この変数は消したいヘッダーに合致する正規表現のリストでも構いません。

     なお、`gnus-visible-headers' が `nil' 以外の場合は、この変数には効
     果が無いことに注意してください。

Gnus はヘッダーの並べ替え (sort) も行ないます (これはディフォルトで行な
われます)。この並べ替えは `gnus-sorted-header-list' 変数を設定すること
で制御することができます。これはヘッダーをどういう順序で表示するかを指
定する正規表現のリストです。

例えば、記事の著者名を最初に、次に表題を表示したければ、こんな風になる
でしょう。

     (setq gnus-sorted-header-list '("^From:" "^Subject:"))

表示するようになっているヘッダーでこの変数に指定されていないものは、こ
の変数に指定されているすべてのヘッダーの後に、適当な順序で表示されるで
しょう。

`gnus-treat-hide-boring-headers' を `head' に設定することによって、もっ
とつまらないヘッダーを隠すことができます。この関数が何をするかは
`gnus-boring-article-headers' 変数に依存します。この変数はリストですが、
このリストには実際のヘッダーの名前が入るのではありません。代わりに
Gnus がチェックして視界から消し去るためのさまざまな「つまらない条件」
("boring conditions") のリストを指定します。

この条件には以下のようなものがあります。

`empty'
     空のヘッダーをすべて消去します。
`followup-to'
     `Followup-To' 欄が `Newsgroups' 欄と同一である場合には消去します。
`reply-to'
     `Reply-To' 欄が `From' 欄と同じアドレスを示しているか、
     `broken-reply-to' グループパラメーターが設定されている場合には消去
     します。
`newsgroups'
     `Newsgroups' 欄が現在のグループ名しか含んでいない場合には消去します。
`to-address'
     `To' 欄が現在のグループの `to-address' パラメーターと同じものしか
     含んでいない場合には消去します。
`to-list'
     `To' 欄が現在のグループの `to-list' パラメーターと同じものしか含ん
     でいない場合には消去します。
`cc-list'
     `Cc' 欄が現在のグループの `to-list' パラメーターと同じものしか含ん
     でいない場合には消去します。
`date'
     その記事が過去三日以内のものであれば、`Date' 欄を消去します。
`long-to'
     `To' 欄および/または `Cc' 欄があまりにも長い場合には消去します。
`many-to'
     `To' 欄および/または `Cc' 欄が一つよりも多ければ、それらをすべて消
     去します。

これらのうちの三つの要素を入れたければ、こんな風になります:

     (setq gnus-boring-article-headers
           '(empty followup-to reply-to))

これはこの変数のディフォルト値でもあります。



File: gnus-ja.info, Node: Using MIME, Next: Customizing Articles, Prev: Hiding Headers, Up: Article Buffer

MIME を使う
===========

パントマイム (mime) は、観客があくびをしながらぼんやりしているのにもか
かわらず、意味も無く空中で手を振るものの標準として広く知られています。

一方 MIME は、そのためにすべてのニュースリーダーが恐怖で死んでしまうの
にもかかわらず、意味も無く記事をエンコードする標準です。

MIME は記事がどんな文字セットを使うか、文字をどうエンコードするかを指定
することができ、さらには絵やその他のみだらなものを無邪気な格好の記事に
埋め込むことさえ可能にします。

Gnus は MIME パートを表示するために、`gnus-display-mime-function' によっ
て MIME 記事を処理します。これはディフォルトでは `gnus-display-mime' で、
MIME オブジェクトを表示し、セーブし、かつ操作するために使うことができる、
ひとかたまりのクリック可能なボタンを作成します。

MIME ボタンの上にポイントを置いたならば、以下のコマンドが利用できます:

`RET (記事)'
`BUTTON-2 (記事)'
     MIME オブジェクトの表示をトグルで切り替えます
     (`gnus-article-press-button')。そのオブジェクトを内蔵のビューワー
     で表示できないときは、Gnus は `mailcap' ファイルにある外部のビュー
     ワーに助けを求めます。ビューワーが `copiousoutput' 仕様になってい
     る場合は、オブジェクトはインラインで (訳注: Emacs の表示に埋め込ま
     れて) 表示されます。

`M-RET (記事)'
`v (記事)'
     手段を尋ね、その手段を使って MIME オブジェクトを表示します
     (`gnus-mime-view-part')。

`t (記事)'
     MIME オブジェクトを、異なる MIME メディア・タイプであるかのように
     表示します (`gnus-mime-view-part-as-type')。

`C (記事)'
     文字セットを尋ね、その文字セットを使って MIME オブジェクトを表示し
     ます (`gnus-mime-view-part-as-charset')。

`o (記事)'
     ファイル名を尋ねて MIME オブジェクトをセーブします
     (`gnus-mime-save-part')。

`C-o (記事)'
     ファイル名を尋ね、MIME オブジェクトをセーブして、それを記事から取
     り外します (記事を編集することによって行なわれます)。取り外された
     MIME オブジェクトは message/external-body MIME タイプとして参照さ
     れるようになります (`gnus-mime-save-part-and-strip')。

`r (記事)'
     ファイル名の入力を求めて、MIME オブジェクトを
     message/external-body 型の MIME 形式のファイルとして参照される外部
     にある本体で置き換えます。(`gnus-mime-replace-part')。

`d (記事)'
     記事から MIME オブジェクトを取り外し、取り外したことを表す告知で置
     き換えます (`gnus-mime-delete-part')。

`c (記事)'
     MIME オブジェクトを新たに作ったバッファーにコピーして、それを
     表示します (`gnus-mime-copy-part')。接頭引数が与えられると、デコー
     ドせずに生の内容物をコピーします。数値の接頭引数を与えると、文字セットに
     よるデコードを半手動で切り替えることができま
     す (*Note Paging the Article:: で述べられてい
     る `gnus-summary-show-article-charset-alist' を参照してください)。
     `auto-compression-mode' (*Note Accessing Compressed Files: (emacs)Compressed Files.) が設定されていると、
     `.gz' や `.bz2' のような圧縮されたファイルを自動的に解凍します。

`p (記事)'
     MIME オブジェクトを印刷します (`gnus-mime-print-part')。このコマン
     ドは `.mailcap' ファイルで定義された `print=' 仕様に従います。

`i (記事)'
     MIME オブジェクトの内容物を、その記事バッファーに `text/plain' と
     して挿入します (`gnus-mime-inline-part')。接頭引数が与えられると、
     デコードせずに生の内容物を挿入します。数値の接頭引数を与えると、文
     字セットによるデコードを半手動で切り替えることができます (*Note
     Paging the Article:: で述べられている
     `gnus-summary-show-article-charset-alist' を参照してください)。
     `auto-compression-mode' (*Note Accessing Compressed Files:
     (emacs)Compressed Files.) の設定とは無関係に、`.gz' や `.bz2' のよ
     うな圧縮されたファイルを `jka-compr' を使って自動的に解凍します。

`E (記事)'
     内部ビューワーで MIME オブジェクトを表示します。内部ビューワーが使
     えないときは、外部ビューワーを使います
     (`gnus-mime-view-part-internally')。

`e (記事)'
     外部ビューワーで MIME オブジェクトを表示します
     (`gnus-mime-view-part-externally')。

`| (記事)'
     MIME オブジェクトをプロセスに出力します (`gnus-mime-pipe-part')。

`. (記事)'
     MIME オブジェクトをどう処理するかを、対話的に決めて実行します
     (`gnus-mime-action-on-part')。

Gnus はいくつかの種類の MIME オブジェクトを自動的に表示します。どのパー
トに対してそうするかを Gnus が決めるやり方については、Emacs MIME マニュ
アルで述べられています。

不愉快なものでびっくりさせられるのを避けるには、トグルで切り替える関数
を使うのが最も良いでしょう。 (例えば、`alt.sing-a-long' グループに入る
と、あなたの気づかないうちに MIME は記事中のサウンドファイルをデコード
して、何やら怪しげな長い長い歌があなたのスピーカーから大音響で流れ出し、
あなたはボリュームボタンを見つけられず、というのはそんなものはもともと
付いていないからで、みんなはあなたの方を睨みはじめ、あなたはプログラム
を止めようとするけれどもできなくて、ボリュームを制御するプログラムも見
つけられなくて、そして部屋中の全員は突然あなたのことを軽蔑の眼差しで見
るようになってしまい、あなたはちょっと面白くない思いをする、とか)。

現実の出来事と実在の人物に類似しているかもしれませんが、これはすべてホ
ントのことです。げほげほ。

*Note MIME Commands:: も見てください。



File: gnus-ja.info, Node: Customizing Articles, Next: Article Keymap, Prev: Using MIME, Up: Article Buffer

記事のカスタマイズ
==================

記事をどのように見せるかをカスタマイズするためのたくさんの関数が存在し
ています。これらの関数を対話的に呼ぶこともできるし (*Note Article
Washing::)、記事を選択したときに自動的に選択することもできます。

自動的に呼ばれるようにするためには、対応するトリートメント変数を設定し
なければなりません。例えばヘッダーを隠すためには、
`gnus-treat-hide-headers' を設定します。以下は設定できる変数の一覧です
が、まずこれらの変数の取り得る値について話しましょう。

注意: いくつかの値は、有効な値であってもほとんど意味を無しません。実用
的な値は下の一覧を調べてください。

  1. `nil': このトリートメントをしません。

  2. `t': このトリートメントをすべての本文のパートで行ないます。

  3. `head': ヘッダーでそのトリートメントをします。

  4. `first': このトリートメントを最初の本文のパートで行ないます。

  5. `last': このトリートメントを最後の本文のパートで行ないます。

  6. 整数: このトリートメントをこの数値より短いすべての本文のパートで行
     ないます。

  7. 文字列のリスト: このリストに含まれている正規表現に合致する名前のグ
     ループで読まれた記事の、すべての本文のパートでこのトリートメントを
     行ないます。

  8. 最初の要素が文字列でないリストです:

     リストは再帰的に評価されます。リストの最初の要素は述語です。以下の
     述語が認識されます: `or', `and', `not', `typep'。例です:

          (or last
              (typep "text/x-vcard"))

ここで「パート」という語が使われていることに気付いたと思います。これは
メッセージには MIME マルチパート記事があり、いくつかのパートに分割され
ているかもしれないという事実に関連しています。マルチパートでない記事は
一つのパートのみであるとみなされます。

このトリートメントはすべてのマルチパートのパートたちに適用されるのでしょ
うか?  はい、そうしたければそうなります。ですが、ディフォルトでは
`text/plain' パートだけにトリートメントが施されます。これは
`gnus-article-treat-types' 変数で制御され、これはパートの型に合致する正
規表現のリストです。制御変数の値が、上で説明されているように述語のリス
トであるときは、この変数は無視されます。


以下のトリートメントのオプションが使用可能です。これをカスタマイズする
ための最も簡単な方法は `gnus-article-treat' カスタマイズグループを調査
することです。丸括弧の中の値は提案されている意味のある値です。他のもの
も可能ですが、ほとんどの人にとってはおそらくここに一覧表示されているも
ので十分でしょう。

`gnus-treat-buttonize (t, integer)'
`gnus-treat-buttonize-head (head)'

     *Note Article Buttons::.

`gnus-treat-capitalize-sentences (t, integer)'
`gnus-treat-overstrike (t, integer)'
`gnus-treat-strip-cr (t, integer)'
`gnus-treat-strip-headers-in-body (t, integer)'
`gnus-treat-strip-leading-blank-lines (t, first, integer)'
`gnus-treat-strip-multiple-blank-lines (t, integer)'
`gnus-treat-strip-pem (t, last, integer)'
`gnus-treat-strip-trailing-blank-lines (t, last, integer)'
`gnus-treat-unsplit-urls (t, integer)'
`gnus-treat-wash-html (t, integer)'

     *Note Article Washing::.

`gnus-treat-date-english (head)'
`gnus-treat-date-iso8601 (head)'
`gnus-treat-date-lapsed (head)'
`gnus-treat-date-local (head)'
`gnus-treat-date-original (head)'
`gnus-treat-date-user-defined (head)'
`gnus-treat-date-ut (head)'

     *Note Article Date::.

`gnus-treat-from-picon (head)'
`gnus-treat-mail-picon (head)'
`gnus-treat-newsgroups-picon (head)'

     *Note Picons::.

`gnus-treat-display-smileys (t, integer)'

`gnus-treat-body-boundary (head)'

     ヘッダーと本文の間に境界線を追加します。境界線には
     `gnus-body-boundary-delimiter' に設定された文字列が使われます。

     *Note Smileys::.

`gnus-treat-display-x-face (head)'

     *Note X-Face::.

`gnus-treat-display-face (head)'

     *Note Face::.

`gnus-treat-emphasize (t, head, integer)'
`gnus-treat-fill-article (t, integer)'
`gnus-treat-fill-long-lines (t, integer)'
`gnus-treat-hide-boring-headers (head)'
`gnus-treat-hide-citation (t, integer)'
`gnus-treat-hide-citation-maybe (t, integer)'
`gnus-treat-hide-headers (head)'
`gnus-treat-hide-signature (t, last)'
`gnus-treat-strip-banner (t, last)'
`gnus-treat-strip-list-identifiers (head)'

     *Note Article Hiding::.

`gnus-treat-highlight-citation (t, integer)'
`gnus-treat-highlight-headers (head)'
`gnus-treat-highlight-signature (t, last, integer)'

     *Note Article Highlighting::.

`gnus-treat-play-sounds'
`gnus-treat-translate'
`gnus-treat-ansi-sequences (t)'
`gnus-treat-x-pgp-sig (head)'

`gnus-treat-unfold-headers (head)'
`gnus-treat-fold-headers (head)'
`gnus-treat-fold-newsgroups (head)'
`gnus-treat-leading-whitespace (head)'

     *Note Article Header::.

もちろん、`gnus-part-display-hook' から呼ばれる自分用の関数を書くことも
できます。関数はそのパートに範囲が狭められた状態で呼ばれ、ほとんどなん
でも好きなことができます。バッファーに保存しておかなければならない情報
はありません--何でも変えることができます。



File: gnus-ja.info, Node: Article Keymap, Next: Misc Article, Prev: Customizing Articles, Up: Article Buffer

記事のキーマップ
================

概略バッファーにおけるキー操作のほとんどは記事バッファーでも使用できま
す。これらは概略バッファーでそれらを押したかのように動作するはずです。
つまり記事を読んでいる間、実際に概略バッファーを表示させておく必要があ
りません。すべての操作は記事バッファーから行なうことができるのです。

`v' キーはユーザー用に予約されています。そのまま何かのコマンドに割り当
てても構いませんが、接頭キーとして使う方が良いでしょう。

他にもいくつかのキーが利用できます:

`SPACE'
     記事を一ページ先にスクロールします。(`gnus-article-next-page')。
     `h SPACE h' とまったく同じです。

`DEL'
     記事を一ページ前にスクロールします (`gnus-article-prev-page')。
     `h DEL h' とまったく同じです。

`C-c ^'
     カーソルが `Message-ID' の近辺にあるときに `C-c ^' を押すと、Gnus
     はサーバーからその記事を取ってこようとします
     (`gnus-article-refer-article')。

`C-c C-m'
     カーソルの近くにあるアドレスに返信を送ります
     (`gnus-article-mail')。接頭引数を与えると、そのメールを引用します。

`s'
     バッファーを再配置して、概略バッファーが見えるようにします
     (`gnus-article-show-summary')。

`?'
     利用できるキー操作のごく簡単な説明を出します
     (`gnus-article-describe-briefly')。

`TAB'
     次のボタンがあればそこに移動します (`gnus-article-next-button')。
     これは記事にボタンを付ける機能をオンにしているときのみ意味を持ちま
     す。

`M-TAB'
     一つ前のボタンがあればそこに移動します
     (`gnus-article-prev-button')。

`R'
     現在の記事に元記事を含んだ返答のメールを送ります
     (`gnus-article-reply-with-original')。もし領域が活性化されていたな
     らば、その領域にあるテキストだけを yank します。

`S W'
     現在の記事に元記事を含んだ広い返答のメールを送ります
     (`gnus-article-wide-reply-with-original')。もし領域が活性化されて
     いたならば、その領域にあるテキストだけを yank します。

     訳注:「広い返答」とはヘッダーの `To', `From', (もしく
     は `Reply-to') と `Cc') のすべての人に返答をすることです。
     `Mail-Followup-To' があれば、代わりにそれが使われます。

`F'
     現在の記事に元記事を含んでフォローアップをします
     (`gnus-article-followup-with-original')。もし領域が活性化されてい
     たならば、その領域にあるテキストだけを yank します。



File: gnus-ja.info, Node: Misc Article, Prev: Article Keymap, Up: Article Buffer

記事のその他
============

`gnus-single-article-buffer'
     `nil' 以外であれば、すべてのグループに対して同じ記事バッファーを使
     用します (これはディフォルトです)。`nil' であれば、各グループ毎の
     固有の記事バッファーを持つようになります。

`gnus-article-decode-hook'
     MIME 記事をデコードするときに使用されるフックです。ディフォルト値
     は `(article-decode-charset article-decode-encoded-words)' です。

`gnus-article-prepare-hook'
     このフックは記事が記事バッファーに挿入された直後に呼び出されます。
     これは主に、何か記事の内容に依存する処理をする関数のために用意され
     ています。記事バッファーの内容を変更するような目的で使うべきではな
     いでしょう。

`gnus-article-mode-hook'
     記事モードのバッファーで呼び出されるフックです。

`gnus-article-mode-syntax-table'
     記事バッファーで用いられる構文テーブル (syntax table) です。これは
     `text-mode-syntax-table' をもとに初期化されます。

`gnus-article-over-scroll'
     非-`nil' にすることによって、それ以上スクロールする新しいテキスト
     が無くても記事バッファーをスクロールできるようにします。ディフォル
     トは `nil' です。(訳注: 記事の最下行が見えているときに、`nil' だと
     `RET' キーでそれ以上スクロールしませんが、非-`nil' にすると記事が
     見えなくなるまでスクロールします。)

`gnus-article-mode-line-format'
     この変数は `gnus-summary-mode-line-format' と同じ仕様に沿った様式
     文字列です (*Note Summary Buffer Mode Line::)。これは、その変数と
     同じ様式指定および二つの拡張を受付けます。

     `w'
          記事の「洗濯状態」("wash status")。これは記事に対して行なわれ
          たであろう洗濯操作を、それぞれ一文字で示す短い文字列になりま
          す。文字とそれらの意味は次の通りです:

          `c'
               記事バッファーにおいて、引用された文が隠されているかもし
               れない場合に表示されます。

          `h'
               記事バッファーにおいて、ヘッダーが隠されている場合に表示
               されます。

          `p'
               記事が電子署名または暗号化されていて、Gnus がセキュリ
               ティーのためのヘッダーを隠していると表示されます。(注:
               署名が正しいか間違っているかを表すものではありません。)

          `s'
               記事バッファーにおいて、署名が隠されている場合に表示され
               ます。

          `o'
               記事バッファーにおいて、Gnus が重ね打ち文字のトリートメ
               ントを行なった場合に表示されます。

          `e'
               記事バッファーにおいて、Gnus が強調された文字のトリート
               メントを行なった場合に表示されます。

     `m'
          記事の MIME パートの数です。

`gnus-break-pages'
     改ページ ("page breaking") を行なうかどうかを制御します。この変数
     が `nil' 以外であれば、記事中にページ区切り文字が現れるごとにペー
     ジ分割をします。この変数が `nil' であればページ分けは行なわれませ
     ん。

`gnus-page-delimiter'
     これが上で触れた区切り文字です。ディフォルトでは `^L' (フォーム
     フィード) です。

`gnus-use-idna'
     この変数は `From:'、`To:' および `Cc:' ヘッダーにある国際化ドメイ
     ン名を、Gnus が IDNA デコードするかどうかを制御します。そのような
     メッセージの作り方については *Note 国際化ドメイン名:
     (message-ja)IDNA, を参照してください。これには GNU Libidn
     (http://www.gnu.org/software/libidn/) が必要で、この変数はそれをイ
     ンストールしてある場合だけ有効になります。



File: gnus-ja.info, Node: Composing Messages, Next: Select Methods, Prev: Article Buffer, Up: Top

メッセージの作成
****************

すべての投稿とメールを送るためのコマンドは、あなたをメッセージバッファー
に導きます。そこでは `C-c C-c' を押すことによって記事を送信する前に、記
事を好きなように編集することができます。*Note 概要: (message-ja)Top.
メッセージはあなたの設定に基づいて投稿またはメールとして送信されます
(*Note Posting Server::)。

* Menu:

* Mail::                        メールの送信と返答
* Posting Server::              どのサーバーで投稿またはメールを送信するべきか?
* POP before SMTP::             メールを読まないとメールを送信できない
* Mail and Post::               ニュースとメールを同時に送信する
* Archived Messages::           送ったメッセージを Gnus が貯めておくところ
* Posting Styles::              あなたが誰であるかを明らかにするより簡単な方法
* Drafts::                      メッセージの延期と拒否されたメッセージ
* Rejected Articles::           サーバーがあなたの記事を嫌いだと何が起こる?
* Signing and encrypting::      安全なメッセージを作るには?

投稿するべきでなかった記事を削除するための情報について *Note Canceling
and Superseding:: も参照してください。



File: gnus-ja.info, Node: Mail, Next: Posting Server, Prev: Composing Messages, Up: Composing Messages

メール
======

出て行くメールをカスタマイズする変数です:

`gnus-uu-digest-headers'
     要約メッセージ (digested message) に含まれるヘッダーに合致する正規
     表現のリストです。ヘッダーは合致した順に取り込まれます。`nil' だっ
     たら、すべてのヘッダーを含みます。

`gnus-add-to-list'
     `nil' でなければ、`a' を押したときに、`to-list' グループパラメーター
     をそれの無いメールグループに付け加えます。

`gnus-confirm-mail-reply-to-news'
     非-`nil' だったら、あなたがニュース記事への返答をメールでしようと
     すると Gnus は確認を求めます。`nil' ならば、あなたがやりたいことに
     何も口出ししません。これは関数か正規表現であることもできます。関数
     は唯一のパラメーターとしてグループ名を受け取り、確認する必要がある
     場合に非-`nil' を返します。これを正規表現にすると、それに合致する
     名前のグループで確認を求めます。

     メールで返信する気は無いのに時たまぞんざいに R を押してしまう癖が
     あるならば、この変数はそんなあなたのためにあります。

`gnus-confirm-treat-mail-like-news'
     非-`nil' だったら、Gnus はメールに返信する時にも
     `gnus-confirm-mail-reply-to-news' に基づいた確認を求めます。これは
     メーリングリストをニュースグループのように扱うのに便利です。



File: gnus-ja.info, Node: Posting Server, Next: POP before SMTP, Prev: Mail, Up: Composing Messages

投稿するサーバー
================

最新の (もちろん、非常に知的な) 記事を送り出すために、あの魔法のような
`C-c C-c' キーを押した時、それはどこにいくのでしょう?

尋ねてくれてありがとう。あなたを恨みます。

それは非常に複雑になり得ます。

ニュースを投稿するとき、通常 Message は `message-send-news' を呼び出し
ます (*Note ニュース変数: (message-ja)News Variables.)。普通は、Gnus は
講読用と同じ選択方法を使って投稿します (このことは、あなたがたくさんの
グループを異なったサーバーで講読している場合に、たぶん都合が良いのです)。
しかし、あなたが講読しているそのサーバーが投稿を許可せず、読むことのみ
を許可しているのならば、おそらくあなたの (非常に知的でとんでもなく興味
深い) 記事を投稿するために、他のサーバーを使いたいと思うでしょう。そう
ならば `gnus-post-method' を他の方法に設定することができます:

     (setq gnus-post-method '(nnspool ""))

さて、この設定をした後でサーバーがあなたの記事を拒否したり、サーバーが
落ちていたりしたら、どうしたらよいのでしょう? この変数よりも優先させる
ために `C-c C-c' 命令にゼロでない数の接頭引数を与えることによって、投稿
に“current”(現在の) サーバーを使わせること、すなわちディフォルトの動
作 (訳注: `gnus-post-method' のディフォルト値は `current') に戻すことが
できます。

もし、ゼロを接頭引数としてその命令に与えたなら (すなわち、`C-u 0 C-c
C-c')、Gnus は投稿にどの方法を使うかをあなたに尋ねます。

`gnus-post-method' を選択方法のリストにすることもできます。その場合は、
Gnus は常に投稿にどの方法を使うかをあなたに尋ねます。

最後に、あなたがいつでも基本の選択方法を使って投稿したいのならば、この
変数を `native' にしてください。

メールを送信するときに、Message は `message-send-mail-function' 変数に
よって指定される関数を呼び出します。Gnus はそれを、あなたのシステムに適
合する値に設定しようとします。詳しくは: *Note メール変数:
(message-ja)Mail Variables.



File: gnus-ja.info, Node: POP before SMTP, Next: Mail and Post, Prev: Posting Server, Up: Composing Messages

POP before SMTP
===============

あなたの ISP は POP-before-SMTP 認証を要求しますか? それは、メールを送
信する前の一定時間以内に POP メールサーバーに接続しなければならないかど
うかです。もしそうならば、便利な手があります。それには `~/.gnus.el' ファ
イルに以下の行を入れてください:

     (setq message-send-mail-function 'message-smtpmail-send-it)
     (add-hook 'message-send-mail-hook 'mail-source-touch-pop)

これは、メールを送信するときはいつでも Gnus に前もって POP メールサーバー
に接続させることを意味します。関数 `mail-source-touch-pop' は、メールを
送信する直前に、メールを取得せずに `mail-sources' の値に従って POP 認証
だけを行ないます。`smtpmail-send-it' ではなくて、
`message-send-mail-hook' を実行する `message-smtpmail-send-it' を使わな
ければならないことと、POP 接続のために `mail-sources' の値を正しく設定
しなければならないことに注意してください。*Note Mail Sources::.

もし `mail-sources' に二つ以上の POP メールサーバーを設定しているならば、
それらの一つを POP-before-SMTP 認証に使われる POP メールサーバーとして
`mail-source-primary-source' に設定する必要があるでしょう。それが第一
POP メールサーバーならば (すなわち、主にそのサーバーからメールを取得し
ているならば)、それを以下のように恒久的に設定することができます:

     (setq mail-source-primary-source
           '(pop :server "pop3.mail.server"
                 :password "secret"))

さもなければ、POP-before-SMTP 認証を行なうときだけ、それを以下のように
動的に束縛してください:

     (add-hook 'message-send-mail-hook
               (lambda ()
                 (let ((mail-source-primary-source
                        '(pop :server "pop3.mail.server"
                              :password "secret")))
                   (mail-source-touch-pop))))



File: gnus-ja.info, Node: Mail and Post, Next: Archived Messages, Prev: POP before SMTP, Up: Composing Messages

メールと投稿
============

これはメールの送信とニュースの投稿の両方に関連する変数のリストです:

`gnus-mailing-list-groups'
     あなたのニュースサーバーが、本当にメーリングリストの記事を NNTP サー
     バーに流し込むゲートウェイによって、それらがニュースグループの記事
     として見えるようにしているのであれば、それらのグループは問題なく読
     めるでしょう。しかしいくらか面倒なことを克服すること無しに、それら
     に投稿またはフォローアップすることはできません。一つの解決法は、グ
     ループパラメーター (*Note Group Parameters::) に `to-address' を加
     えることです。簡単にできるのは、`gnus-mailing-list-groups' を、本
     当はメーリングリストであるグループに合致する正規表現に設定すること
     です。そうすれば、少なくともメーリングリストへのフォローアップはた
     いていのときに行なうことができるでしょう。これらのグループに投稿す
     ること (`a') は、それでも苦痛を引き起こすでしょうけれど。

`gnus-user-agent'
     この変数は、どの情報が User-Agent ヘッダーに陳列されるかを制御しま
     す。シンボルのリスト、または文字列です。有効なシンボルは `gnus'
     (Gnus のバージョン) および `emacs' (Emacs のバージョン) です。
     Emacs のバージョンには `codename' ((S)XEmacs のコードネーム)、また
     は `config' (`system-configuration' の値) か `type'
     (`system-type' の値) のどちらか一方を加えることができます。これを
     文字列にするときは、正しいフォーマットを使ってください (RFC2616 参
     照)。

あなたは自分が送るメッセージで、綴りをチェックしたいかもしれません。も
しくは手で綴りのチェックをしたくないのであれば、自動綴りチェックを
`ispell' パッケージを使うことによって付け加えることができます:

     (add-hook 'message-send-hook 'ispell-message)

`ispell' の辞書をグループに応じて切り替えたいならば、以下のようにすれば
良いでしょう。

     (add-hook 'gnus-select-group-hook
               (lambda ()
                 (cond
                  ((string-match
                    "^de\\." (gnus-group-real-name gnus-newsgroup-name))
                   (ispell-change-dictionary "deutsch"))
                  (t
                   (ispell-change-dictionary "english")))))

あなたの必要に応じて変更してください。

`gnus-message-highlight-citation' を `t' に設定すれば、message モードの
バッファーでも記事バッファーと同様に、引用された文のレベルの違いに応じ
たハイライトが行なわれます。



File: gnus-ja.info, Node: Archived Messages, Next: Posting Styles, Prev: Mail and Post, Up: Composing Messages

メッセージの保管
================

Gnus はあなたが送ったメールとニュースを貯めておくためのいくつかの違った
方法を提供します。ディフォルトの方法はメッセージを保存するために「アー
カイブ仮想サーバー」を使うことです。これを完全に禁止したいのであれば、
変数 `gnus-message-archive-group' を `nil' にしなければなりません。それ
がディフォルトです。

グループで読んだ興味のあるメッセージの保存については、`B c'
(`gnus-summary-copy-article') コマンドを参照してください (*Note Mail
Group Commands::)。

`gnus-message-archive-method' は、送ったメッセージを保存するためにどの
仮想サーバーを Gnus が使うかを指定します。ディフォルトは `"arhive"' で、
実際に使われるときに以下の方法に展開されます:

     (nnfolder "archive"
               (nnfolder-directory   "~/Mail/archive")
               (nnfolder-active-file "~/Mail/archive/active")
               (nnfolder-get-new-mail nil)
               (nnfolder-inhibit-expiry t))

     注: このようなサーバーは、`"archive"' という名前のサーバーの実際の
     選択方法としてその後ずっと使えるようにするために (つまり
     `gnus-message-archive-method' が `"archive"' に設定された場合のた
     めに)、最初に `~/.newsrc.eld' ファイルに保存されます。もしそれが一
     度保存されると、`gnus-message-archive-method' の値を後で変更しても、
     ディフォルトではそれは更新されません。したがって `"archive"' とい
     うサーバーが、いつでもこのような `nnfolder' サーバーを意味するとは
     限りません。保存される選択方法が常に
     `gnus-message-archive-method' の値を反映するようにしたい場合は、
     `gnus-update-message-archive-method' 変数を `nil' 以外の値に設定し
     てください。この変数のディフォルト値は `nil' です。

`nnfolder' はこのようなことをするのには極めて適した選択方法なのですが、
これに限らず `nnml' や `nnmbox' などの、どのメール選択方法でも使うこと
ができます。ディフォルトで選択されるディレクトリーが気にいらなければ、
次のようにすることができます:

     (setq gnus-message-archive-method
           '(nnfolder "archive"
                      (nnfolder-inhibit-expiry t)
                      (nnfolder-active-file "~/News/sent-mail/active")
                      (nnfolder-directory "~/News/sent-mail/")))

訳注: 上記のような例は「意図した通りに動作しない」FAQ のネタになりつつ
あり、不具合の原因が特定できない事例が少なくありません。例えば、同じ
`"archive"' という名前の仮想サーバーを過去に使ったことがあると、それが
`~/.newsrc.eld' ファイルの中で `gnus-server-alist' 変数に登録されている
かもしれません。あるいは単に、同名の仮想サーバーを現在も使っているかも
しれません。そのような場合は、別の名前を使う必要があります。

Gnus は外へ出て行くすべてのメッセージに、`gnus-message-archive-method'
で指定されたアーカイブ仮想サーバーにある (あるいはそれ以外のサーバーに
ある) 一つかそれ以上のグループに保存することを意図した `Gcc' 欄を挿入し
ます。どのグループを使うかは変数 `gnus-message-archive-group' によって
決まります。

この変数 (`gnus-message-archive-group') は次のようなことをするために使
うことができます:

文字列
     メッセージはそのグループに保存されます。

     グループ名に選択方法を含めることができますが、そうするとそのメッセー
     ジは `gnus-message-archive-method' で指定した選択方法ではなくて、
     代わりにグループ名の選択方法で保存されることに注意しましょう。
     `gnus-message-archive-method' は、上に示したようなディフォルト値を
     持つためものであると考えてください。ですから
     `gnus-message-archive-group' を `"foo"' にしておけば、外へ出て行く
     メッセージは `nnfolder+archive:foo' に保存されますが、
     `"nnml:foo"' という値を使うと、外へ出て行くメッセージは
     `nnml:foo' に保存されるでしょう。

文字列のリスト
     メッセージはそれらのすべてのグループに保存されます。

正規表現、関数、Lisp フォームの連想リスト
     キーが『合致』すると、その結果が使われます。

     訳注: 正確には以下の三種類です。
        * 正規表現とグループ名 (または複数のグループ名リスト) の連想リ
          スト。最初に正規表現が合致した要素のグループ名 (またはグルー
          プ名のリスト) が使われます。
        * 関数のリスト。それぞれの関数には現在のグループ名が引数として
          与えられ、最初に返ってきた `nil' 以外の値が使われます。
        * Lisp フォームのリスト。それぞれのフォームが評価され、最初に返っ
          てきた `nil' 以外の値が使われます。

`nil'
     メッセージの保存は行なわれません。これがディフォルトです。

例をあげてみましょう:

`MisK' という単一のグループに保存するだけならば:
     (setq gnus-message-archive-group "MisK")

二つのグループ、`MisK' と `safe' に保存するならば:
     (setq gnus-message-archive-group '("MisK" "safe"))

どのグループにいるかによって違ったグループに保存するなら:
     (setq gnus-message-archive-group
           '(("^alt" "sent-to-alt")
             ("mail" "sent-to-mail")
             (".*" "sent-to-misc")))

もっと複雑なもの:
     (setq gnus-message-archive-group
           '((if (message-news-p)
                 "misc-news"
               "misc-mail")))

すべてのニュースメッセージを一つのファイルに保存して、メールメッセージ
を一月につき一つのファイルに保存するというのはどうでしょう:

     (setq gnus-message-archive-group
           '((if (message-news-p)
                 "misc-news"
               (concat "mail." (format-time-string
                                "%Y-%m" (current-time))))))

さあ、メッセージを送ると適切なグループに保存されるようになりました。(も
し特定のメッセージを保存をしたくないのであれば、挿入された `Gcc' 欄を取
り除いてください。) 保管グループは次に Gnus を起動したときか、次にグルー
プバッファーで `F' を押したときにグループバッファーに現れます。他のグルー
プと同じように、そのグループに入って記事を読むことができます。そのグルー
プが本当に大きくて悩ましくなったら、なにか良いものにその名前を変更する
ことができます (グループバッファーで `G r' を使うことによっ
て)---`misc-mail-september-1995' その他何でも。新しいメッセージは古い
(今は空になった) グループに溜められます。

以上が送ったメッセージを保管するディフォルトの方法です。Gnus はディフォ
ルトの方法を好きではない人には違ったやり方を勧めています。そのような場
合は、`gnus-message-archive-group' を `nil' に設定するべきです。これは
保管をしないようにします。

`gnus-outgoing-message-group'
     すべての外にいくメッセージはこのグループに入れられます。もしすべて
     の外に行くメールと記事を `nnml:archive' グループに保管したいのであ
     れば、この変数をその値に設定してください。この変数はグループ名のリ
     ストであることもできます。

     もしそれぞれのメッセージをどのグループに入れるかをもっと制御したい
     のであれば、この変数を現在のニュースグループ名を調べて、適切なグルー
     プ名 (もしくは名前のリスト) を返す関数に設定することができます。

     この変数は `gnus-message-archive-group' の代わりに使うことができま
     すが、後者の方が好ましい方法です。

     (訳注:「後者」とは `gnus-message-archive-group' のこと。前者より四ヶ
     月遅れて、1996年1月に新設されました。)

`gnus-gcc-mark-as-read'
     もし非-`nil' なら、`Gcc' の記事に既読の印を付けます。

`gnus-gcc-externalize-attachments'
     `nil' だったら、ファイルを通常のパートとして Gcc で保存する記事の
     コピーに添付します。それが正規表現で Gcc のグループ名に合致する場
     合は、外部パートとしてファイルを添付します。`all' だったらローカル
     ファイルを参照する外部パートとして添付します。それが別の非-`nil'
     だった場合の動作は `all' のときと同じですが、将来は変わるかもしれ
     ません。

     (訳注: 送信したメッセージと同じものを Gcc で保存する代わりに、添付
     ファイルをメッセージから切り離して、別にセーブするかどうかを制御す
     る変数です。)



File: gnus-ja.info, Node: Posting Styles, Next: Drafts, Prev: Archived Messages, Up: Composing Messages

投稿様式
========

それらはすべて変数で、私の頭をくらくらさせます。

投稿するグループによって違った `Organization' と署名を付けたいんですか?
そして、家のマシンと職場のマシンの両方から投稿するけれども、違った
`From' 行などを使いたいんですか?  そんなこと、どうでもいいじゃありませ
んか。

そのようなことをする方法の一つは、変更する必要のある変数を変更する賢い
フックを書くことです。それは少し退屈なので、利用者にこれらのことを手軽
な連想リストで指定するというすばらしい着想にたどり着いた人がいました。
これが変数 `gnus-posting-styles' の例です:

     ((".*"
        (signature "Peace and happiness")
        (organization "What me?"))
      ("^comp"
       (signature "Death to everybody"))
      ("comp.emacs.i-love-it"
       (organization "Emacs is it")))

この例から推測されるように、この連想リストはいくつかの「様式」(style)
からなっています。それぞれの様式は最初の要素が何らかの形で「合致」した
ときに適用されます。連想リスト全体は最初から最後まで反復して実行され、
それぞれの合致が適用されます。これは、後の様式の属性が前に合致した様式
の属性よりも優先されるということです。ですから
`comp.programming.literate' は、`Death to everybody' という署名と
`What me?' という `Organization' ヘッダーを持ちます。

それぞれの様式の最初の要素は `マッチ' (match) と言います。もしそれが文
字列であれば、Gnus はそれを正規表現であるものとして、グループ名に合致す
るかどうかを調べます。`(header 合致 正規表現)' という形式であれば、
Gnus は元記事の中からその名前が 合致 であるヘッダーを探し、それを 正規
表現 と比較します。合致 と 正規表現 は文字列です。(元記事とは、あなたが
それに対して返信またはフォローアップしようとしている対象の記事です。返
信あるいはフォローアップを作成していなければ、合致するものは何もありま
せん。) もし `マッチ' が関数のシンボルであれば、その関数が引数無しで呼
ばれます。それが変数のシンボルであれば、その変数が参照されます。それが
リストであれば、そのリストが `評価' されます。どの場合でも、これが
`nil' でない値を返せば、様式は `合致した' と言います。

それぞれの様式は任意の量の「属性」を持つことができます。それぞれの属性
は `(NAME VALUE)' の対により成り立っています。加えて `(NAME :file
VALUE)' の形式か `(NAME :value VALUE)' の形式を使うこともできます。ここ
で `:file' は VALUE がファイル名を表して、その内容が属性値として使用さ
れるべきであることを示し、`:value' は VALUE がファイル名を表わさないこ
とを明示的に示します。属性名 (NAME) は、以下のどれかであることができま
す。

   * `signature'
   * `signature-file'
   * `x-face-file'
   * `address' (`user-mail-address' よりも優先されます)
   * `name' (`(user-full-name)' よりも優先されます)
   * `body'

`signature-file' 属性は `message-signature-directory' 変数を見ることに
注意してください。

属性名は文字列またはシンボルであることもできます。その場合それはヘッダー
名として使われ、その値が記事のヘッダーに挿入されます。もし属性名が
`nil' だったら、そのヘッダー名は削除されます。もし属性名が `eval' だっ
たらその様式が評価され、結果は捨てられます。

属性値は文字列 (そのまま使われます)、引数の無い関数 (返り値が使われま
す)、変数 (その値が使われます) またはリスト (それは `評価' されて、返り
値が使われます) であることができます。関数と S式 (sexp) はセットアップ
されつつあるメッセージバッファーで呼ばれるか評価されます。現在の記事の
ヘッダー群は変数 `message-reply-headers' から得られます。これは number
subject from date id references chars lines xref extra の各ヘッダーから
成るベクトルです。

作成しようとしているメッセージがニュース記事かメールメッセージであるか
を調べたいときは、関数 `message-news-p' と `message-mail-p' の戻り値を
調べてください。

そして、これは例です:

     (setq gnus-posting-styles
           '((".*"
              (signature-file "~/.signature")
              (name "User Name")
              (x-face-file "~/.xface")
              (x-url (getenv "WWW_HOME"))
              (organization "People's Front Against MWM"))
             ("^rec.humor"
              (signature my-funny-signature-randomizer))
             ((equal (system-name) "gnarly")  ;; 様式
              (signature my-quote-randomizer))
             (message-news-p        ;; 関数シンボル
              (signature my-news-signature))
             (window-system         ;; 変数シンボル
              ("X-Window-System" (format "%s" window-system)))
             ;; Lars さんに返事をするときは
             ;; Organization ヘッダーを付けよう。
             ((header "to" "larsi.*org")
              (Organization "Somewhere, Inc."))
             ((posting-from-work-p) ;; 利用者が定義した関数
              (signature-file "~/.work-signature")
              (address "user@bar.foo")
              (body "You are fired.\n\nSincerely, your boss.")
              (organization "Important Work, Inc"))
             ("nnml:.*"
              (From (with-current-buffer gnus-article-buffer
                      (message-fetch-field "to"))))
             ("^nn.+:"
              (signature-file "~/.mail-signature"))))

`nnml:.*' の規則は、あなたが出すすべての返事の `To' アドレスを `From'
アドレスとして使うことを意味します。これは、あなたがたくさんのメーリン
グリストに参加している場合に便利でしょう。代わりに
`message-alternative-emails' を使うこともできます。*Note メッセージヘッ
ダー: (message-ja)Message Headers.



File: gnus-ja.info, Node: Drafts, Next: Rejected Articles, Prev: Posting Styles, Up: Composing Messages

下書き
======

メッセージ (メールもしくはニュース) を書いているときに、オーブンにステー
キが入っている (もしくはあなたがとーってもすごい菜食主義者で、何かのペー
ストがフードプロセッサーに入っている) ことを突然思い出したなら、書いて
いるメッセージを保存する方法があれば良いと思うでしょう。いつか別の日に
編集を続けることができ、それが完成したと思ったときに送ることができるよ
うに。

えぇ、心配しないでください。メールかニュースを送信するための Gnus の命
令を使って何らかのメッセージを書き始めたときにあなたが手にするバッファー
は、自動的に特別な "draft" グループに関連付けられます。普通の方法 (例え
ば `C-x C-s') でバッファーを保存すれば、その記事はそこに保存されます。
(自動保存 (auto-save) ファイルも下書きグループ (draft group) に行きま
す。)

下書きグループは `nndraft:drafts' と呼ばれる特別なグループです (あなた
が絶対に知っていなければならないのであれば、それは `nndraft' グループと
して実装されています)。変数 `nndraft-directory' は `nndraft' がそのファ
イルをどこに保管するかを指定します。このグループを特別なものにしている
のは、その中の記事に可視や既読の印を付けることができないことです--その
グループのすべての記事は永久に未読です。

もしグループが存在しないと、それは作成され、購読させられます。グループ
バッファーからそれを消し去る唯一の方法は、それを購読しないようにするこ
とです。下書きグループの特別の特性はグループの特性 (*Note Group
Parameters::) によって生じ、それが失われてしまうと他のグループのように
振る舞うようになります。これは (グループの特性を消してしまうことは) 以
下のコマンドが使えないことを意味します。そのグループの特別の特性を復活
させる最も簡単な方法は、`C-k' でそのグループを削除してから Gnus を再起
動することです。そのグループの内容物は失われません。

記事の編集を続けたいときは、下書きグループに入って `D e'
(`gnus-draft-edit-message') を押すだけです。編集を中断したときの状態の
バッファーに移動します。

送信を拒否された記事も、この下書きグループに入れられます (*Note
Rejected Articles::)。

送信を拒否されたメッセージがたくさんあって、それ以上編集せずにそれらを
送信したい場合は、`D s' 命令 (`gnus-draft-send-message') を使うことがで
きます。この命令はプロセス/接頭引数の習慣を理解します (*Note
Process/Prefix::)。`D S' 命令 (`gnus-draft-send-all-messages') はバッ
ファーのすべてのメッセージを送り出します。

送りたくないメッセージがいくつかあるのであれば、`D t' 命令
(`gnus-draft-toggle-sending') を使ってメッセージに送信不可の印を付ける
ことができます。これは切り替え命令です。



File: gnus-ja.info, Node: Rejected Articles, Next: Signing and encrypting, Prev: Drafts, Up: Composing Messages

拒否された記事
==============

時々ニュースサーバーは記事を送信することを拒否します。おそらくサーバー
はあなたの顔を好きではないのでしょう。おそらく落ち込んでいるのでしょう。
おそらく *悪魔 (demon) がいるのでしょう*。おそらく引用文を入れすぎたの
でしょう。おそらくディスクが一杯だったのでしょう。おそらくサーバーが落
ちていたのでしょう。

もちろんこれらの状況は完全に Gnus の扱える範囲外です。(もちろん Gnus は
あなたの風貌を愛しているし、いつも機嫌が良いし、中を飛び回る天使がいて、
どれくらい引用文が含まれていようと気にせず、一杯になったり、落っこちた
りしません。) ですから Gnus はこれらの記事を後でサーバーの機嫌が良くな
るまで保存します。

拒否された記事は自動的に特別な下書きグループ (*Note Drafts::) に入れら
れます。サーバーが復旧した暁には、普通あなたはそのグループに入って、す
べての記事を送ることになるでしょう。



File: gnus-ja.info, Node: Signing and encrypting, Prev: Rejected Articles, Up: Composing Messages

署名と暗号化
============

素の PGP 形式、PGP/MIME または S/MIME を使って、Gnus はメッセージに電子
署名したり暗号化することができます。そのようなメッセージのデコードに関
しては、`mm-verify-option' オプションおよび `mm-decrypt-option' オプショ
ン (*Note Security::) を参照してください。

署名したメッセージを送ってきた人たちに、署名した返信を返したいことはし
ばしばあります。さらに暗号化されたメッセージへの返信を暗号化したいこと
は、もっとたびたびあるかもしれません。Gnus は前者のために
`gnus-message-replysign' の機能を、後者のために
`gnus-message-replyencrypt' の機能を提供します。さらに
`gnus-message-replysignencrypted' を設定することによって (ディフォルト
で on になっています)、暗号化したメッセージに自動的に署名もします。

MIME パートに対してセキュリティーの操作を行なうための MML への指示は、
以下のように署名の場合は `C-c C-m s' キーマップを使って、暗号化の場合は
`C-c C-m c' キーマップを使って行ないます。

`C-c C-m s s'

     S/MIME を使って現在のメッセージに電子署名します。

`C-c C-m s o'

     PGP を使って現在のメッセージに電子署名します。

`C-c C-m s p'

     PGP/MIME を使って現在のメッセージに電子署名します。

`C-c C-m c s'

     S/MIME を使って現在のメッセージを電子暗号化します。

`C-c C-m c o'

     PGP を使って現在のメッセージを電子暗号化します。

`C-c C-m c p'

     PGP/MIME を使って現在のメッセージを電子暗号化します。

`C-c C-m C-n'
     メッセージから、セキュリティー関連の MML タグを外します。

もっと詳しいことは *Note セキュリティー: (message-ja)Security, を参照し
てください。



File: gnus-ja.info, Node: Select Methods, Next: Scoring, Prev: Composing Messages, Up: Top

選択方法
********

「外部グループ」(foreign group) とは、普通 (もしくはディフォルト) の方
法で読まれないグループのことです。例えばそれは別の NNTP サーバーのグルー
プであったり、仮想グループであったり、個人的なメールグループであったり
するでしょう。

外部グループ (あるいは実際にどんなグループでも) は「名前」と「選択方法」
で指定されます。先に後者を例に出すと、選択方法はリストで、最初の要素が
どのバックエンドを使うか (例えば `nntp', `nnspool', `nnml') を、二つめ
の要素が「サーバー名」を表します。選択方法には、その当のバックエンドに
とって特別の意味を持つ値である追加の要素があるかもしれません。

選択方法とは「仮想サーバー」を定義することだ、と言うことができます--で
すから私たちはまさにそれをしました (*Note Server Buffer::)。

グループの「名前」は、バックエンドがそのグループを認識する名前です。

例えば `some.where.edu' という NNTP サーバーにある `soc.motss' グループ
は、名前 `soc.motss' と選択方法 `(nntp "some.where.edu")' を持ちます。
`nntp' バックエンドはこのグループを `soc.motss' として知っているだけで
すが、Gnus はこのグループを `nntp+some.where.edu:soc.motss' と呼びます。

もちろん、違った方法はすべてそれ特有の要素を持っています。

* Menu:

* Server Buffer::               仮想サーバーを作って編集する
* Getting News::                USENET ニュースを Gnus で読む
* Getting Mail::                個人的なメールを Gnus で読む
* Browsing the Web::            大量のウェブの資源からメッセージを取得する
* IMAP::                        Gnus を IMAP のクライアントとして使う
* Other Sources::               ディレクトリー、ファイル、SOUP パケットを読む
* Combined Groups::             複数のグループを一つのグループに合併させる
* Email Based Diary::           日程をメールで管理する
* Gnus Unplugged::              ニュースとメールをオフラインで読む



File: gnus-ja.info, Node: Server Buffer, Next: Getting News, Prev: Select Methods, Up: Select Methods

サーバーバッファー
==================

伝統的に、「サーバー」は誰かがそれに接続して、それからの情報を要求する
マシンかソフトウェアの断片です。Gnus は実際のどんなサーバーにも直接には
接続せず、何かのバックエンドを通してすべての処理を行ないます。しかしそ
れはまさしく実際の媒体と Gnus の間に一つ以上の階層を置くことであって、
ちょうどそれぞれのバックエンドが疑似的なサーバーに相当すると言っても良
いでしょう。

例えば `nntp' バックエンドは、複数の別々に実在する NNTP サーバー、ある
いは実在する同じ NNTP サーバーの異なるポートに接続するために用いられま
す。あなたはどのバックエンドを使うか、そしてどんなパラメーターを設定す
るかを選択方法 ("select method") に設定して Gnus に指示します。

選択方法の指定は、ときに極めて面倒なものになります--えーと、例えば
`news.funet.fi' という NNTP サーバーのポート 13 を読みたいのだけれど、
NOV ヘッダーを取り寄せようとすると固まってしまうし、間違った記事を選択
してしまうような場合です。うおっほん。とにかくこのサーバーを使うそれぞ
れのグループについてそういうことを設定しなければならないとしたら、大変
な作業になってしまうでしょう。そこで Gnus は、そういう作業をサーバーバッ
ファーで行なうために、選択方法に名前を付ける手段を設けているのです。

サーバーバッファーに入るためには、グループバッファーで `^'
(`gnus-group-enter-server-mode') コマンドを使ってください。

* Menu:

* Server Buffer Format::        このバッファーの外見をカスタマイズできる
* Server Commands::             サーバーを操る命令
* Example Methods::             サーバー指定の例
* Creating a Virtual Server::   セッションの例
* Server Variables::            どの変数を設定するか
* Servers and Methods::         サーバー名を選択方法として使うことができる
* Unavailable Servers::         接続しようとしたサーバーのいくつかは落ちているかもしれない

サーバーバッファーを作成するときに `gnus-server-mode-hook' が実行されま
す。



File: gnus-ja.info, Node: Server Buffer Format, Next: Server Commands, Prev: Server Buffer, Up: Server Buffer

サーバーバッファーの表示様式
----------------------------

サーバーバッファーの行の外見を、変数 `gnus-server-line-format' 変数を変
更することによって変えることができます。これは `format' のような変数で、
少しばかり単純な拡張がなされています:

`h'
     どのようにニュースが取得されるか--バックエンドの名前。

`n'
     サーバーの名前。

`w'
     どこからニュースが取得されるか--アドレス。

`s'
     サーバーの接続の 開いた/閉じた/拒否された 状態。

`a'
     そのサーバーがエージェント化されているかどうか。

モード行も変数 `gnus-server-mode-line-format' を使うことによってカスタ
マイズすることができます (*Note Mode Line Formatting::)。

[訳注: 現在この変数は使われていません。]

以下の仕様が理解されます:

`S'
     サーバー名。

`M'
     サーバーの選択方法。

*Note Formatting Variables:: も参照してください。



File: gnus-ja.info, Node: Server Commands, Next: Example Methods, Prev: Server Buffer Format, Up: Server Buffer

サーバー命令
------------

`v'
     `v' キーはユーザー用に予約されています。そのまま何かのコマンドに割
     り当てても構いませんが、接頭キーとして使う方が良いでしょう。

`a'
     新しいサーバーを追加します (`gnus-server-add-server')。

`e'
     サーバーを編集します (`gnus-server-edit-server')。

`SPACE'
     現在のサーバーを眺めます (`gnus-server-read-server')。

     訳注: 実際には `gnus-server-read-server-in-server-buffer' 命令を呼
     びますが、`gnus-server-browse-in-group-buffer' の値がディフォルト
     の `nil' であれば `gnus-server-read-server' と同じです。
     `gnus-server-browse-in-group-buffer' を `nil' 以外の値にすることは
     まったくお勧めできませんが、あなたが何をするのも自由です。詳細はソー
     スコードを読むか、実際に試して痛い目に会ってください。;-p

`q'
     グループバッファーに戻ります (`gnus-server-exit')。

`k'
     現在のサーバーを切り取ります (kill します)
     (`gnus-server-kill-server')。

`y'
     先ほど切られた (killed) サーバーを貼り付けます (yank します)
     (`gnus-server-yank-server')。

`c'
     現在のサーバーを複写します (`gnus-server-copy-server')。

`l'
     すべてのサーバーの一覧を表示します (`gnus-server-list-servers')。

`s'
     サーバーにそのソースから新しい記事を調べるように要求します
     (`gnus-server-scan-server')。主にメールサーバーが意味のある動作を
     します。

`g'
     サーバーにすべてのデータ構造を再作成させます
     (`gnus-server-regenerate-server')。これは同期が外れてしまったメー
     ルバックエンドがあるときに役に立ちます。

`z'

     現在位置のサーバーのすべてのグループを圧縮します。今のところ
     `nnml' (*Note Mail Spool::) だけに実装されています。これは記事番号
     のすきまを取り除くので、正しい全記事数を得ることができるようになり
     ます。



File: gnus-ja.info, Node: Example Methods, Next: Creating a Virtual Server, Prev: Server Commands, Up: Server Buffer

方法の例
--------

ほとんどの選択方法は、説明する必要が無いくらいにかなり単純です:

     (nntp "news.funet.fi")

直接スプールから読むのはもっと単純です:

     (nnspool "")

見ての通り、選択方法の最初の要素はバックエンドの名前で、二番目は「アド
レス」(address)、もしくはそう呼びたいのであれば「名前」です。

これらの二つの要素の後には、任意の数の `(変数 様式)' の対を置くことがで
きます。

最初の例に戻りましょう--そのマシンのポート 15 から読みたいのだと思って
ください。これがその時に、そうなるはずの選択方法です:

     (nntp "news.funet.fi" (nntp-port-number 15))

どの変数が関連するかを見つけ出すために、それぞれのバックエンドの説明文
書を読むべきでしょうが、これは `nnmh' の例です。

`nnmh' はスプールのような構造を読むためのメールバックエンドです。例えば
アクセスしたい二つの構造があるとしましょう: 一つはあなたの私的なメール
スプールで、他方は公的なものです。これは私的なメールのために使うことが
できる指定です:

     (nnmh "private" (nnmh-directory "~/private/mail/"))

(それでこのサーバーは `private' と呼ばれますが、あなたはすでに推測して
いたかもしれませんね。)

これは公的なスプールのための方法です:

     (nnmh "public"
           (nnmh-directory "/usr/information/spool/")
           (nnmh-get-new-mail nil))

あなたが防壁 (firewall) の中にいて、防壁マシンを通して NNTP サーバーに
接続するしかないのであれば、防壁マシンに `rlogin' して、そこから
netcat (http://netcat.sourceforge.net/) で NNTP サーバーに接続するよう
に Gnus に指示することができます。こんなことをするのはいささかばかげて
いるのですが、でも仮想サーバーの定義はおそらくこのようなものになるはず
です:

     (nntp "firewall"
           (nntp-open-connection-function nntp-open-via-rlogin-and-netcat)
           (nntp-via-address "the.firewall.machine")
           (nntp-address "the.real.nntp.host"))

あの素敵な `ssh' プログラムを、モデムを経由する通信を圧縮するために使い
たいのならば、上記の例に以下の設定を加えることができます。

           (nntp-via-rlogin-command "ssh")

`nntp-via-rlogin-command-switches' も参照してください。間接的に接続する
場合の例です:

     (setq gnus-select-method
           '(nntp "indirect"
                  (nntp-address "news.server.example")
                  (nntp-via-user-name "intermediate_user_name")
                  (nntp-via-address "intermediate.host.example")
                  (nntp-via-rlogin-command "ssh")
                  (nntp-via-rlogin-command-switches ("-C"))
                  (nntp-open-connection-function nntp-open-via-rlogin-and-netcat)))

もちろん、自動認証を行なわせるためには `ssh-agent' を適切に設定しなけれ
ばなりません。

防壁の中にいたとしても "runsocks" のようなラッパーコマンドを通して外の
世界に直接アクセスできるのならば、以下のように socks 化された netcat で
ニュースサーバーに接続することができるでしょう:

     (nntp "outside"
           (nntp-pre-command "runsocks")
           (nntp-open-connection-function nntp-open-netcat-stream)
           (nntp-address "the.news.server"))



File: gnus-ja.info, Node: Creating a Virtual Server, Next: Server Variables, Prev: Example Methods, Up: Server Buffer

仮想サーバーを作成する
----------------------

永続記事を使ってたくさんの記事をキャッシュに保存しているのであれば、
キャッシュを読むための仮想サーバーを作る必要があるでしょう。

最初に新しいサーバーを追加する必要があります。それをするのは `a' 命令で
す。おそらくキャッシュを読むためには `nnml' を使うのが一番良いでしょう。
`nnspool' や `nnmh' も使えるでしょうれけど。

`a nnml RET cache RET' とタイプしてください。

今やあなたは真新しい `cache' という `nnml' の仮想サーバーを手に入れたは
ずです。次はそれを編集して、正しい定義を与えましょう。サーバーを編集す
るには `e' をタイプしてください。あなたは以下のものを含むバッファーに入
ります:

     (nnml "cache")

それを次のように変更してください:

     (nnml "cache"
           (nnml-directory "~/News/cache/")
           (nnml-active-file "~/News/cache/active"))

サーバーバッファーに戻るには `C-c C-c' をタイプしてください。今ではこの
仮想サーバーで `RET' を押すと、閲覧バッファーに入って、表示されているど
のグループにでも入ることができるはずです。



File: gnus-ja.info, Node: Server Variables, Next: Servers and Methods, Prev: Creating a Virtual Server, Up: Server Buffer

サーバー変数
------------

変数を (バックエンドと Emacs 一般の両方で) 定義する際の一つのやっかいな
点は、いくつかの変数は、概してその変数の定義がロードされるときに他の変
数で初期化されることです。「基」になる変数がロードされた後でそれを変更
しても、「派生」した変数は変更されません。

これは一般にディレクトリーやファイルの変数に影響します。例えば
`nnml-directory' はディフォルトでは `~/Mail/' で、また、すべての
`nnml' ディレクトリー変数はその変数によって初期化されるので、
`nnml-active-file' は `~/Mail/active' になります。新しい `nnml' 仮想サー
バーを定義する場合、`nnml-directory' を設定するだけでは十分では *ありま
せん*---あなたはすべてのファイル変数を、そうしたいと望んだ値に明示的に
設定しなければなりません。それぞれのバックエンドのための完全な変数のリ
ストを見るには、このマニュアルの後に続くそれぞれのバックエンドの部分を
読んでください。でも `nnml' の定義の例はここにあります:

     (nnml "public"
           (nnml-directory "~/my-mail/")
           (nnml-active-file "~/my-mail/active")
           (nnml-newsgroups-file "~/my-mail/newsgroups"))

サーバー変数はしばしば「サーバーパラメーター」と呼ばれます。



File: gnus-ja.info, Node: Servers and Methods, Next: Unavailable Servers, Prev: Server Variables, Up: Server Buffer

サーバーと選択方法
------------------

普通に選択方法を使う (例えば外部サーバーから記事を読むときにグループを
選択する手段として `gnus-secondary-select-method' 使う) 場面ではどこで
も、代わりに仮想サーバーの名前を使うことができます。これによって、たく
さんキーボードを叩かなくて済むかもしれません。そして、どんなときでもそ
の方が良いです。



File: gnus-ja.info, Node: Unavailable Servers, Prev: Servers and Methods, Up: Server Buffer

使用不可能なサーバー
--------------------

あるサーバーに接続することができないように見えるとき、Gnus はそのサーバー
に拒否された (`denied') ことを記録します。その後でそのサーバーと接続し
ようとするどんな試みも、単に無視されます。実際にそうかどうかを少しも確
かめずに、Gnus は「接続を開くことができません」と (英語で) 告げます。

それはずいぶんお行儀が悪いと思うかもしれませんが、たいていの場合は有意
義なのです。例えば `nephelococcdyia.com' というサーバーで十個のグループ
を購読しているとしましょう。サーバーはどこかとても遠いところにあって、
そのマシンはとても遅いので、今日それが接続を拒否するかどうかを調べるだ
けでも一分かかります。もし Gnus がそれを十回試すようになっていたとする
と、とても煩わしいでしょう。ですから Gnus はそれを試そうとはしません。
一度でも「接続が拒否された」(connection refused) という結果を受け取った
なら、それはサーバーが「落ちている」(down) のだ、とみなします。

では、一時的にそのマシンの機嫌が悪いだけだったら何が起こるのでしょう?
マシンが復活したかどうかをどうすれば調べることができるのでしょう?

それには、サーバーバッファーに移動して (*Note Server Buffer::)、以下の
命令で突いてみてください:

`O'
     現在の行のサーバーとの接続を確立しようとします
     (`gnus-server-open-server')。

`C'
     サーバーとの接続 (もしあれば) を閉じます
     (`gnus-server-close-server')。

`D'
     現在のサーバーに接続不可の印を付けます
     (`gnus-server-open-all-server')。

`M-o'
     バッファーにあるすべてのサーバーとの接続を開きます
     (`gnus-server-open-all-servers')。

`M-c'
     バッファーにあるすべてのサーバーとの接続を閉じます
     (`gnus-server-close-all-servers')。

`R'
     Gnus が接続を拒否されたすべてのサーバーの、すべての印を消去します
     (`gnus-server-remove-denials')。

`L'
     サーバーの状態をオフラインにします (`gnus-server-offline-server')。



File: gnus-ja.info, Node: Getting News, Next: Getting Mail, Prev: Server Buffer, Up: Select Methods

ニュースの取得
==============

ニュースリーダーは普通はニュースを読むために使われます。Gnus は現在は
ニュースを取得するための二つの方法だけを提供しています---NNTP サーバー
から、またはローカルスプールから読むことができます。

* Menu:

* NNTP::                        NNTP サーバーからニュースを読む
* News Spool::                  ローカルスプールからニュースを読む



File: gnus-ja.info, Node: NNTP, Next: News Spool, Prev: Getting News, Up: Getting News

NNTP
----

NNTP サーバーから外部グループを購読するのは比較的簡単です。単に選択方法
として `nntp' を指定し、NNTP サーバーのアドレスを、うーん、アドレスとし
て指定するだけです。

NNTP サーバーが標準ではないポート (port) に設置されているときは、選択方
法の三番目の要素をこのポートの番号に設定すれば、正しいポートに接続する
ことができるでしょう。そのためにはグループ情報を編集しなければなりませ
ん (*Note Foreign Groups::)。

外部グループの名前は基本グループと同じでも構いません。実際、あなたの思
うままに同じグループを可能な限りの違ったサーバーから購読することができ
ます。名前の衝突は起こりません。

以下の変数は仮想 `nntp' サーバーを作るために使われます:

`nntp-server-opened-hook'
     は接続ができた後に実行されます。それは NNTP サーバーに接続した後に、
     それに命令を送るために使うことができます。ディフォルトでは `MODE
     READER' 命令が、`nntp-send-mode-reader' 関数によってサーバーに送ら
     れるようになっています。この関数は常にこのフックにあるべきです。

`nntp-authinfo-function'
     この関数は NNTP サーバーに `AUTHINFO' を送るために使われます。ディ
     フォルトの関数は `nntp-send-authinfo' で、適切な記載事項を探すため
     に `~/.authinfo' (もしくは `nntp-authinfo-file' 変数に設定した何で
     も) を調べます。もし一つも見つからなかったら、ログイン名とパスワー
     ドの入力を要求します。`~/.authinfo' ファイルの様式は `ftp' のため
     の `~/.netrc' ファイルと (ほとんど) 同じです。それは `ftp' のマニュ
     アルページで定義されていますが、ここに顕著な実例があります:

       1. ファイルは一つ以上の行を含み、それぞれは一つのサーバーを定義
          します。

       2. それぞれの行は任意の数の標章 (token) と値の対を含むことができ
          ます。

          有効な標章は `machine', `login', `password', `default' です。
          加えて、Gnus は `.netrc'/`ftp' の構文の原型には現れない二つの
          新しい標章、名付けて `port' と `force' を導入します。(これが
          `.authinfo' ファイルの様式が `.netrc' ファイルの様式から逸脱
          する唯一の方法です。) `port' はサーバーのどのポートを認証に用
          いるかを示し、`force' は以下で説明します。

     これがそのファイルの例です:

          machine news.uio.no login larsi password geheimnis
          machine nntp.ifi.uio.no login larsi force yes

     標章と値の対はどんな順番ででも現れることができます。例えば
     `machine' が最初でなければならない必要はありません。

     この例では、前者のサーバーにログイン名とパスワードの両方が与えられ
     ているのに対して、後者にはログイン名だけがあり、利用者はパスワード
     の入力を求められるでしょう。後者は `force' タグも持っていて、これ
     によって接続時に NNTP サーバーに認証情報 (authinfo) が送られます。
     ディフォルト (すなわち、`force' タグが無いとき) では、NNTP サーバー
     が認証情報を尋ねない限りそれを NNTP サーバーに送りません。

     `machine' 行に合致しないすべてのサーバーに適用される `default' 行
     を追加することもできます。

          default force yes

     これは、それ以前に書かれていないすべてのサーバーに `AUTHINFO' 命令
     を強制的に送ります。

     `~/.authinfo' ファイルを世界中が読めるような設定のままで放置しない
     ように注意してください。

`nntp-server-action-alist'
     これはサーバーの型に合致する正規表現と、合致が起こったときに取られ
     る動作の連想リストです。例えば、Gnus に innd に接続したときに毎回
     ビープ音を鳴らしたいのであれば、次のようにすることができます:

          (setq nntp-server-action-list
                '(("innd" (ding))))

     まぁ、そんなことをしたいとは思わないでしょうけれどね。

     ディフォルトの値は

          '(("nntpd 1\\.5\\.11t"
             (remove-hook 'nntp-server-opened-hook
                          'nntp-send-mode-reader)))

     で、これは nntpd 1.5.11t には `MODE READER' 命令を確実に送らないよ
     うにします。なぜなら、その命令はサーバーの息の根を止めると聞いてい
     るからです。

`nntp-maximum-request'
     もし NNTP サーバーが NOV ヘッダーをサポートしていないのであれば、
     このバックエンドは `head' 命令をいくつも送って、ヘッダーを集めます。
     この動作を速くするために、バックエンドは返答を待たずにこの命令をた
     くさん送り、それからすべての返答を読みます。これは変数
     `nntp-maximum-request' によって制御され、ディフォルトで 400 です。
     もしネットワークの具合が良くないようなら、この変数を 1 に設定する
     べきでしょう。

`nntp-connection-timeout'
     定期的に接続している外部 `nntp' グループがたくさんあると、ちゃんと
     応答しなかったり常識的な時間内に返答できないくらいの負荷がかかって
     いる NNTP サーバーの問題があるはずです。これはやっかいな問題をもた
     らしますが、`nntp-connection-timeout' を設定することによってある程
     度解消することができます。これは接続を諦める前に、`nntp' バックエ
     ンドが何秒待つかを示す整数です。もしこれが `nil' であると、それが
     ディフォルトですが、時間切れによる切断は行ないません。

`nntp-nov-is-evil'
     NNTP サーバーが NOV をサポートしていない場合は、この変数を `t' に
     設定すれば良いでしょう。でも `nntp' は普通は NOV が使えるかどうか
     を自動的に調べます。(訳注: ですから、わざわざ設定しなくても構いま
     せん。)

`nntp-xover-commands'
     サーバーから NOV 行を取得するための命令として使われる文字列のリス
     トです。この変数のディフォルトの値は `("XOVER" "XOVERVIEW")' です。
     (訳注: それらを順に試します。)

`nntp-nov-gap'
     `nntp' は、普通はサーバーに NOV 行のための一つの大きな要
     求を送ります。サーバーは一つの巨大な行のリストで応答します。しかし、グルー
     プの 2-5000 の記事を読んだ後で 1 と 5001 を読みたいだけだとしても、
     `nntp' は必要の無い 4999 個の NOV 行を取得することになり
     ます。この変数は、どれくらい大きな二つの連続した記事群の間の隔た
     り (gap) まで `XOVER' の要求を分割せずに送るかを決定します。ネット
     ワークが速い場合に、この変数を本当に小さな数値に設定してしまうと、おそら
     く取得が遅くなることに注意してください。この変数が `nil' ならば、
     `nntp' は要求を分割しません。ディフォルトは 5 です。

`nntp-xref-number-is-evil'
     ユーザーが指定した `Message-ID' を持っている記事、または現在のもの
     の親記事の `Message-ID' を持っている記事を参照するとき (*Note
     Finding the Parent::)、Gnus はそれがどこにあるかを知るために NNTP
     サーバーに `HEAD' コマンドを送ります。そしてサーバーは、`Xref' ヘッ
     ダーにグループと記事番号の対を含んでいるデータを返します。そのデー
     タが、その記事が現在のグループにあることを示すなら、通常 Gnus はそ
     の記事を参照するのに記事番号を使用します、そうでなければ
     `Message-ID' を使いますが。ところが、あるニュースサーバー (例えば
     Diablo を実行するもの) は、同じ記事群を有する複数のエンジンを運転
     していて、それらの間では記事番号が同期されていません。その場合
     `Xref' ヘッダーに現われる記事番号は、どのエンジンが選ばれるかによっ
     て変化するので、例えば現在のグループにある親記事を参照することがで
     きません。そのようなサーバーに接続するのであれば、この変数を
     `nil' ではない値に設定してください。そうすれば Gnus は記事番号を使
     いません。例えば:

          (setq gnus-select-method
                '(nntp "newszilla"
                       (nntp-address "newszilla.example.com")
                       (nntp-xref-number-is-evil t)
                       ...))

     このサーバー変数のディフォルト値は `nil' です。

`nntp-prepare-server-hook'
     NNTP サーバーに接続を試みる前に実行するフックです。

`nntp-record-commands'
     これを `nil' でない値にすると、`nntp' は NNTP サーバーに送ったすべ
     ての命令を (時刻と共に) `*nntp-log*' バッファーに記録します。これ
     は動作していないように見える Gnus の NNTP 接続をデバッグしていると
     きに役に立ちます。

`nntp-open-connection-function'
     どのように NNTP サーバーと接続するかをカスタマイズすることができま
     す。`nntp-open-connection-function' パラメーターを設定しておくと、
     Gnus は接続を確立するためにその関数を使います。そのために七つの関
     数があらかじめ用意されています。それらは二種類に分類することができ、
     直接接続するための関数群 (四つ) と間接的に接続するためのもの (三つ)
     があります。

`nntp-never-echoes-commands'
     非-`nil' で NNTP サーバーがコマンドをエコーバックしないことを意味
     します。報告によると、ある種の NNTPS サーバーはコマンドをエコーバッ
     クしないそうです。したがって、例えば
     `nntp-open-connection-function' を `nntp-open-ssl-stream' に設定し
     てあるそのようなサーバーのための選択方法の中で、この変数を
     非-`nil' に設定する必要があるでしょう。ディフォルト値は `nil' です。
     この変数の値 `nil' は、
     `nntp-open-connection-functions-never-echo-commands' 変数でくつが
     えされることに注意してください。

`nntp-open-connection-functions-never-echo-commands'
     コマンドをエコーバックしない関数のリストです。
     `nntp-open-connection-function' に設定した関数がコマンドをエコーバッ
     クしないならば、それをこのリストに加えてください。
     `nntp-never-echoes-commands' 変数の `nil' でない値が、この変数をく
     つがえすことに注意してください。ディフォルト値は
     `(nntp-open-network-stream)' です。

`nntp-prepare-post-hook'
     記事を投稿する直前に実行されるフックです。もし記事に `Message-ID'
     ヘッダーが無くてニュースサーバーが推奨 ID を提供してくれるならば、
     このフックが実行される前にそれが記事に加えられます。これは、もしあ
     なたが Gnus が `Message-ID' ヘッダーを付けないようにしていても、
     `Cancel-Lock' ヘッダーを作るために利用することができます。それには
     こうすれば良いでしょう:

          (add-hook 'nntp-prepare-post-hook 'canlock-insert-header)

     すべてのサーバーが推奨 ID をサポートしているわけではないことに注意
     してください。これは例えば INN 2.3.0 以上で動作します。

* Menu:

* Direct Functions::            サーバーに直接接続する
* Indirect Functions::          サーバーに間接的に接続する
* Common Variables::            いくつかの接続用の関数が参照する変数
* NNTP marks::                  NNTP サーバー用の印の保存



File: gnus-ja.info, Node: Direct Functions, Next: Indirect Functions, Prev: NNTP, Up: NNTP

直接接続するための関数
......................

これらの関数は、あなたのマシンと NNTP サーバーを接続するために直接呼ば
れます。また、それらの動作はそれらが共通に参照する変数に影響されます
(*Note Common Variables::)。

`nntp-open-network-stream'
     これはディフォルトで、単純に遠隔システムの何らかのポートに接続しま
     す。

`nntp-open-tls-stream'
     「安全な」チャンネルを使ってサーバーに接続します。これを使うために
     は GNUTLS (http://www.gnu.org/software/gnutls/) をインストールして
     おかなければなりません。それからサーバーを次のように定義します:

          ;; ポート 563 が "nntps" として `/etc/services' で定義済み
          ;; であっても、`gnutls-cli -p' でその名前は使えません。
          ;;
          (nntp "snews.bar.com"
                (nntp-open-connection-function nntp-open-tls-stream)
                (nntp-port-number 563)
                (nntp-address "snews.bar.com"))

`nntp-open-ssl-stream'
     「安全な」チャンネルを使ってサーバーに接続します。これを使うために
     は OpenSSL (http://www.openssl.org) または SSLeay
     (ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL) をインストールしておかなけ
     ればなりません。それからサーバーを次のように定義します:

          ;; ポート 563 が "snews" として `/etc/services' で定義済みで
          ;; あっても、`openssl s_client -port' でその名前は使えません。
          ;;
          (nntp "snews.bar.com"
                (nntp-open-connection-function nntp-open-ssl-stream)
                (nntp-port-number 563)
                (nntp-address "snews.bar.com"))

`nntp-open-netcat-stream'
     `netcat' コマンドを使って NNTP サーバーに接続します。ディフォルト
     の `nntp-open-network-stream' がそれをするのにもかかわらず、なぜこ
     の関数があるのか不思議に思うかもしれません。その理由 (の一つ) は、
     もしあなたが防壁の中にいたとしても `runsocks' のようなコマンドラッ
     パーのおかげで外の世界を直接アクセスできるならば、それをこのように
     使うことができるのです:

          (nntp "socksified"
                (nntp-pre-command "runsocks")
                (nntp-open-connection-function nntp-open-netcat-stream)
                (nntp-address "the.news.server"))

     ディフォルトのメソッドのままでそれを行なうには Emacs のセッション
     全体をラップする必要があるでしょうが、それは良い考えではありません。

`nntp-open-telnet-stream'
     `nntp-open-netcat-stream' に似ていますが、`netcat' ではなくて
     `telnet' を使います。行末コードを変更したりするので `telnet' はい
     ささか堅実さに欠けるのですが、`netcat' が無い場合もあります。前の
     例はこのように書き換えられるでしょう:

          (nntp "socksified"
                (nntp-pre-command "runsocks")
                (nntp-open-connection-function nntp-open-telnet-stream)
                (nntp-address "the.news.server")
                (nntp-end-of-line "\n"))



File: gnus-ja.info, Node: Indirect Functions, Next: Common Variables, Prev: Direct Functions, Up: NNTP

間接的に接続するための関数
..........................

これらの関数は、実際に NNTP サーバーに接続する前に中間のホストに接続す
るために間接的に呼ばれます。すべてのこれらの関数と関連する変数は“via”
接続の仲間に属しているとも言えるので、それを明確にするためにすべて
“via”という接頭語が付けられます。また、それらの動作はそれらが共通に参
照する変数に影響されます (*Note Common Variables::)。

`nntp-open-via-rlogin-and-netcat'
     遠隔システムに `rlogin' して、そこから本当の NNTP サーバーに接続す
     るために `netcat' を使います。これは、例えばあなたが始めに防壁マシ
     ンに接続しなければならない場合に便利です。

     `nntp-open-via-rlogin-and-netcat'-用の変数:

     `nntp-via-rlogin-command'
          中間のホストにログインするために使われるコマンドです。ディフォ
          ルトは `rsh' ですが、`ssh' が人気のある代替手段です。

     `nntp-via-rlogin-command-switches'
          `nntp-via-rlogin-command' のコマンドのスイッチとして使われる
          文字列のリストです。ディフォルトは `nil' です。もし `ssh' を
          `nntp-via-rlogin-command' の値として使うならば、すべてのデー
          タ接続を圧縮するために `("-C")' を使うことができます。

`nntp-open-via-rlogin-and-telnet'
     本質的には同じことなのですが、中間のホストから本当の NNTP サーバー
     に接続するために、`netcat' の代わりに `telnet' を使います。行末コー
     ドを変更したりするので `telnet' はいささか堅実さに欠けるのですが、
     `netcat' が無い場合もあるでしょう。

     `nntp-open-via-rlogin-and-telnet'-用の変数:

     `nntp-telnet-command'
          中間のホストから本当の NNTP サーバーに接続するために使われる
          コマンドです。ディフォルトは `telnet' です。

     `nntp-telnet-switches'
          `nntp-telnet-command' のコマンドのスイッチとして使われる文字
          列のリストです。ディフォルトは `("-8")' です。

     `nntp-via-rlogin-command'
          中間のホストにログインするために使われるコマンドです。ディフォ
          ルトは `rsh' ですが、`ssh' が人気のある代替手段です。

     `nntp-via-rlogin-command-switches'
          `nntp-via-rlogin-command' のコマンドのスイッチとして使われる
          文字列のリストです。`ssh' を使う場合に、もし中間のホストで
          telnet コマンドが疑似端末を必要とするならば、これを `("-t"
          -e" "none")' または `{("-C" "-t" "-e" "none")} にする必要があ
          るでしょう。ディフォル'トは `nil' です。

     `nntp-end-of-line' の値を `\n' に変更する必要があるであろうことに
     注意してください (*Note Common Variables::)。

`nntp-open-via-telnet-and-telnet'
     これもまた本質的には同じことなのですが、中間のホストに接続するため
     に `rlogin' の代わりに `telnet' を使います。

     `nntp-open-via-telnet-and-telnet'-用の変数:

     `nntp-via-telnet-command'
          中間のホストに `telnet' するために使われるコマンドです。ディ
          フォルトは `telnet' です。

     `nntp-via-telnet-switches'
          `nntp-via-telnet-command' のコマンドのスイッチとして使われる
          文字列のリストです。ディフォルトは `("-8")' です。

     `nntp-via-user-password'
          中間のホストにログインするときに使われるパスワードです。

     `nntp-via-envuser'
          もし非-`nil' なら、中間の `telnet' のセッション (クライアント
          とサーバーの両方) で `ENVIRON' オプションをサポートし、ログイ
          ン名の入力を要求しません。これは例えば Solaris の `telnet' で
          動作します。

     `nntp-via-shell-prompt'
          中間のホストでのシェルのプロンプトに合致する正規表現です。ディ
          フォルトは `bash\\|\$ *\r?$\\|> *\r?' です。

     `nntp-end-of-line' の値を `\n' に変更する必要があるであろうことに
     注意してください (*Note Common Variables::)。

これらは上記のすべての関数が参照する付加的な変数です:

`nntp-via-user-name'
     中間のホストに接続するときに使う利用者名です。

`nntp-via-address'
     接続する中間のホストのアドレスです。



File: gnus-ja.info, Node: Common Variables, Next: NNTP marks, Prev: Indirect Functions, Up: NNTP

共通の変数
..........

以下の変数は、すべての、またはいくつかのあらかじめ用意されている関数の
動作に影響を及ぼします。設定されていなければ、すべての関数が影響されま
す (それぞれの仮想サーバーにおいて、サーバー変数として個々に値が設定さ
れていない場合に、以下の値がディフォルトで使われます)。

`nntp-pre-command'
     素の接続用の関数ではないもの (`nntp-open-network-stream'、
     `nntp-open-tls-stream' または `nntp-open-ssl-stream' 以外のすべて)
     を通して接続するときに使うコマンドラッパーです。例えばあなたは
     `SOCKS' ラッパーを割り当てるでしょう。(訳注: `telnet' などの外部コ
     マンドに被せて使われます。)

`nntp-address'
     NNTP サーバーのアドレスです。

`nntp-port-number'
     接続する NNTP サーバーのポート番号です。ディフォルトは `nntp' です。
     TLS/SSL を介した NNTP を使うには、ポートの名前ではなくて整数 (つま
     り `snews' や `nntps' ではなくて `563') を指定する必要があります。
     外部の TLS/SSL ツールはポートの名前では動作しないからです。

`nntp-end-of-line'
     NNTP サーバーとお話をしているときに行の終わりの印として使われる文
     字列です。これはディフォルトで `\r\n' ですが、素ではない接続用の
     telnet 同等の関数を使っているときは `\n' であるべきです。

`nntp-netcat-command'
     `netcat' を通して NNTP サーバーと接続するときに使うコマンドです。
     これは中間のホストと接続するためのものでは *ありません*。これはま
     さに本当の NNTP サーバーと接続するためのものです。ディフォルトは
     `nc' です。

`nntp-netcat-switches'
     `nntp-netcat-command' に渡すスイッチのリストです。ディフォルトは
     `()' です。



File: gnus-ja.info, Node: NNTP marks, Prev: Common Variables, Up: NNTP

NNTP marks
..........

Gnus は NNTP サーバーのための記事の印 (marks) (*Note Marking
Articles::) を印ファイルに保存します。印ファイルはあるグループで設定し
た印を記録し、それぞれのファイルは、対応するサーバーに対して専用です。
印ファイルは、ニュースサーバーに似ている古典的な階層で `~/News/marks'
(`nntp-marks-directory') に保存されます。例えば news.gmane.org サーバー
における `gmane.discuss' グループのための印ファイルは
`~/News/marks/news.gmane.org/gmane/discuss/.marks' に保存されます。

印ファイルは役に立ちます。`~/News/marks' ディレクトリーは (rsync、scp
または他の何かを使って) Gnus を走らせる別のホストにコピーすることができ、
どの記事を読んで印を付けたかをそちらで再現します。`~/News/marks' のデー
タは、`~/.newsrc.eld' にある同じものよりも優先されます。

印ファイルは、それぞれのサーバーでそれ専用に非常に特化されることに注意
してください。Gnus は記事番号を記憶するので、両方のホストで同じサーバー
を使っていないと、ものごとは壊れてしまうでしょう (大抵の NNTP サーバー
は他のどんなサーバーとも同じ記事番号を使いません)。しかし、あるホストで
サーバー A、B、C を使い、別のホストでサーバー A、D、E を使う場合には、
A のための印ファイルを同じにすることができるので、二つのホスト間でその
サーバーは同期するでしょう。

NNTP 印の使用は性能の劣化を招き、Gnus をのろく感じさせる可能性がありま
す。そういう場合は `nntp-marks-is-evil' 変数を `t' に設定してみてくださ
い。すると、印は `~/.newsrc.eld' (だけ) に格納されるようになるでしょう。

関連する変数:

`nntp-marks-is-evil'
     非-`nil' だったら、このバックエンドは印ファイルを無視します。ディ
     フォルトは `nil' です。

`nntp-marks-directory'
     NNTP グループの印が格納されるディレクトリーです。



File: gnus-ja.info, Node: News Spool, Prev: NNTP, Up: Getting News

ニューススプール
----------------

ローカルスプールから外部グループを購読することは極めて簡単だし便利かも
しれません。非常に大きな記事があるグループ--例えば
`alt.binaries.pictures.furniture' を読む速度が速くなります。

とにかく、`nnspool' を選択方法として、かつ `""' (もしくは何でも) をアド
レスとして指定するだけです。

もしローカルスプールにつなぐことが可能なら、おそらくそれを基本選択方法
として使うべきでしょう (*Note Finding the News::)。それは普通は `nntp'
選択方法を使うより速いですが、そうでないかもしれません。それは場合によ
ります。何があなたのサイトで一番良いかを見つけるために、いろいろと試し
てみなければなりません。

`nnspool-inews-program'
     記事を投稿するために使われるプログラムです。

`nnspool-inews-switches'
     記事を投稿するときに inews プログラムに与えられるパラメーターです。

`nnspool-spool-directory'
     `nnspool' が記事を探すところです。これは普通は `/usr/spool/news/'
     です。

`nnspool-nov-directory'
     `nnspool' が NOV ファイルを探すところです。これは普通は
     `/usr/spool/news/over.view/' です。

`nnspool-lib-dir'
     ニュースのライブラリーが置かれているディレクトリーの場所です (ディ
     フォルトで `/usr/lib/news/' です)。

`nnspool-active-file'
     アクティブファイルの絶対パス名です。

`nnspool-newsgroups-file'
     `newsgroups' ファイルの絶対パス名です。

`nnspool-history-file'
     `history' ファイルの絶対パス名です。

`nnspool-active-times-file'
     `active.times' ファイルの絶対パス名です。

`nnspool-nov-is-evil'
     `nil' でないと、`nnspool' はそれが見つけたどんな NOV ファイルも使
     おうとはしません。

`nnspool-sift-nov-with-sed'
     `nil' でないと、これがディフォルトですが、概観ファイル (overview)
     から関連する部分を得るために `sed' を使います。もし `nil' だと、
     `nnspool' はファイル全体をバッファーに読み込んで、そこで実行します。



File: gnus-ja.info, Node: Getting Mail, Next: Browsing the Web, Prev: Getting News, Up: Select Methods

メール取得
==========

ニュースリーダーでメールを読むなんて実に奇妙ですよね?  いや、もちろんで
きるのですが。

* Menu:

* Mail in a Newsreader::        ニュースリーダーでメール (大事な前置き)
* Getting Started Reading Mail::  簡単な料理本のような例
* Splitting Mail::              メールグループの作り方
* Mail Sources::                どこからメールを取ってくるかを Gnus に知らせる方法
* Mail Back End Variables::     メールの扱いをカスタマイズするための変数
* Fancy Mail Splitting::        Gnus は入って来たメールを、身の毛のよだつような分割をすることができる
* Group Mail Splitting::        グループをカスタマイズしてメールを分割する
* Incorporating Old Mail::      あなたが持っている古いメールをどうするか?
* Expiring Mail::               要らないメールを取り除く
* Washing Mail::                取得したメールからごみを取り除く
* Duplicates::                  重複したメールを処理する
* Not Reading Mail::            メールバックエンドで別のファイルを読む
* Choosing a Mail Back End::    Gnus は色々なメール様式を読むことができる



File: gnus-ja.info, Node: Mail in a Newsreader, Next: Getting Started Reading Mail, Prev: Getting Mail, Up: Getting Mail

ニュースリーダーでメール
------------------------

使い慣れた伝統的なメールリーダーから Gnus に乗り換えることを決断したな
らば、かなりのカルチャーショックを経験することになるでしょう。

Gnus は伝統的なメールリーダーのようなふるまいをしません。あなたが望むな
らそのようにもできますが、それは骨折り損のくたびれ儲けです。

Gnus はふつう同じ手法ですべてのグループを扱います。あるグループを選んで
新しい、または未読のメッセージを読むと、それらには既読の印が付けられ、
(意図的に要求しなければ) 以後はそれらを目にすることはありません。これっ
てとてもニュースリーダー的でしょ。

メッセージを消すために、取り立てて何かを行なうことはありません。

このことは既読のメッセージはすべて消されてしまうことを意味するのかって?
そりゃあんまりですよね!

しかし、そうではありません。古いメッセージは何らかの仕組みによって期限切
れ消去 ("expire") されるのです。ニュースのメッセージはニュースの管理
人 (が管理しているサーバー) によって期限切れ消去の処理が制御され、メール
の期限切れ消去の処理はあなたが制御します。メールの期限切れ消去については、
*Note Expiring Mail:: で徹底的に網羅されています。

多くの Gnus の利用者が、それをニュースとメールの両方でしばらく使ってみ
た後で気が付くのは、その配送の機構がメッセージの扱い方に関して行なうこ
とが、ほんの少ししか無いことです。

多くの人たちが複数のメーリングリストを講読しています。それらは SMTP で
配送されるもの、すなわちメールです。それらのメッセージに返答をしないま
ま、あるいはさらに、それらを非常に注意深くは読まないままに、私たちは何
週間も過ごすかもしれません。でも、そういうメッセージを保存しておく必要
はありません。なぜならば、もう一度読む必要が生じたとしても、それらはど
こかに保存されているからです。

ある人たちは小人数に利用されているローカルニュースグループを講読してい
ます。それらは NNTP で配送されるもの、すなわちニュースです。私たちは自
分の仕事に役立てるために、それらの膨大なメッセージの断片を読んだり返事
をしなければなりません。しかもそれらがどこかに保存されているとは限らな
いので、興味のあるメッセージを個人メールと同じように保存しなければなり
ません。

配送の仕組みの違いはどうでもよいことで、大事なのはいかに主題に興味を持っ
ているかと、もう一度読みたいときにいかに簡単に呼び出せるかなのです。

Gnus はメールをニュースグループのように「グループ」に並べ変えて、各々の
グループ (メールかニュース) を別個に扱うための豊富な機能を提供します。

ある人たちは Gnus (えっへん) のやりかたに満足できなくて、Gnus が男
(male) になること、もとい、メールリーダーになることを欲します。Gnus を
もっとメールリーダー的なものにするために鞭打つことは可能ではあるのです
が、前にも言ったように簡単ではありません。いわゆるメールリーダーが好み
ならば VM を使いましょう。これは優秀な、厳密な意味でのメールリーダーで
す。

脅かすわけではないのですが、はっきりさせておきたいのは、あなたにメッセー
ジについての新しいやり方を修得して欲しいということです。あなたが Gnus
のやり方を受け入れてくれた暁には、きっとあなたは Gnus が好きになるでしょ
う。請け合いますよ。(少くとも、私が Gnus に入れた Emacs のサブリミナル
脳味噌洗濯関数を売ってくれた人はそれを保証しています。あなたも同化しま
す。あなたは Gnus を愛します。あなたは Gnus でのメールの方法を愛します。
絶対に。)



File: gnus-ja.info, Node: Getting Started Reading Mail, Next: Splitting Mail, Prev: Mail in a Newsreader, Up: Getting Mail

メールを読むことを始める
------------------------

Gnus を使って新しいメールを読むことはまったく簡単です。あなたが選んだメー
ルバックエンドを `gnus-secondary-select-methods' に放り込むだけで、自動
的に読むことができるようになります。

例えば `nnml' (これは「一メールにつき一ファイル」のバックエンドです) を
使いたいなら、次のものを `~/.gnus.el' ファイルに入れれば良いでしょう:

     (setq gnus-secondary-select-methods '((nnml "")))

そうすると、次に Gnus を起動したときにこのバックエンドは新しい記事を求
め、すべてのメッセージをスプールファイルからそのディレクトリー (ディフォ
ルトでは `~/Mail/') に移します。新しいグループ (`mail.misc') が作られて、
他のグループと同じように読むことができるようになります。

たぶんメールをいくつかのグループに分割したいでしょうけれど:

     (setq nnmail-split-methods
           '(("junk" "^From:.*Lars Ingebrigtsen")
             ("crazy" "^Subject:.*die\\^Organization:.*flabby")
             ("other" "")))

これは三つの新しい `nnml' メールグループ `nnml:junk', `nnml:crazy' およ
び `nnml:other' を作ることになります。初めの二つのグループにふさわしく
ないすべてのメールは、最後のグループに置かれます。

Gnus でメールを読むにはこれで十分なはずです。マニュアルのこの部分の他の
章を熟読する必要があるかもしれませんが。特に *Note Choosing a Mail
Back End:: と *Note Expiring Mail:: を。



File: gnus-ja.info, Node: Splitting Mail, Next: Mail Sources, Prev: Getting Started Reading Mail, Up: Getting Mail

メールの分割
------------

     訳注: このマニュアルの多方面で使われている「分割」という語のうち、
     受信したメールをいろいろなグループに「区分け」することを意味するも
     のは“split”という語に対応します。ある一つのメールを「分解」する
     のではなくて、外からやって来た複数のメールをそれぞれの格納先に一通
     ずつ「振り分ける」意味で使っています。

変数 `nnmail-split-methods' は入ってくるメールをどのようにグループ分け
するかを指定します。

     (setq nnmail-split-methods
       '(("mail.junk" "^From:.*Lars Ingebrigtsen")
         ("mail.crazy" "^Subject:.*die\\|^Organization:.*flabby")
         ("mail.other" "")))

この変数はリストのリストで、それぞれのリストの最初の要素はメールグルー
プの名前、二つめの要素はそれぞれのメールがそのグループに属するかどうか
をヘッダーで判定するために使う正規表現です (ところで、メールグループの
名前が `mail' で始まる必要はありません)。最初の文字列は、
`replace-match' が合致した文章から取り出した副表現を挿入するために使わ
れるような、`\\1' の様式を含むかもしれません。例えば:

     ("list.\\1" "From:.* \\(.*\\)-list@majordomo.com")

この場合、挿入されるテキストを小文字にすべきかどうかを
`nnmail-split-lowercase-expanded' が制御します。*Note Fancy Mail
Splitting::.

二番目の要素は関数でも構いません。その場合、それは規則の最初の要素 (メー
ルグループの名前) を引数として、ヘッダーだけに範囲を狭められたバッファー
で呼ばれます。メールがそのグループに属すると判断したら、その関数は
`nil' でない値を返す必要があります。

これらのグループの最後は常に総合的なものであるべきで、その正規表現は他
の正規表現に合致しなかったメールに合致するために、*いつも* `""' でなけ
ればなりません。(これらの規則は連想リストの初めから終わりまで順番に処理
されます。クロスポストを有効にしていない限り、最初に合致した規則が「勝
ち」ます。クロスポストを有効にしている場合は、すべての合致した規則が
「勝ち」ます。) 合致する規則がなかったら、メールは最後に `bogus' グルー
プで終わります。メール分割によって新しいグループが作られた場合は、それ
らを見るために `gnus-group-find-new-groups' を実行する必要があるでしょ
う。これは `bogus' グループにも当てはまります。

あなた自身でこれをいじくりまわしたいときは、あなたの選んだ関数をこの変
数に設定することができます。この関数は入って来たメールメッセージのヘッ
ダーに範囲を狭められたバッファーで、引数無しで呼ばれます。この関数は、
そのメールメッセージをが行くべきだと判断するグループ名のリストを返さな
ければなりません。

すべてのメールバックエンドは、入って来た気の毒な無実のヘッダーを乱暴に
扱っても良いことに注意してください。それらはすべて `Lines' ヘッダーを追
加します。いくつかは `X-Gnus-Group' ヘッダーを加えます。たいていのもの
は Unix の mbox の `From<SPACE>' 行を何か別のものに変えます。

すべてのメールバックエンドはクロスポストをサポートします。複数の正規表
現が合致すると、メールはそれらすべてのグループに「クロスポスト」されま
す。`nnmail-crosspost' はこの機能を使うかどうかを指定します。どの記事も
総合の (`""') グループにクロスポストされないことに注意してください。

`nnmh' と `nnml' はクロスポストされた記事にハードリンク (hardlink) を作
ることによってクロスポストを行ないます。しかし、すべてのファイルシステ
ムがハードリンクの機能を提供しているわけではありません。もしあなたがそ
の場合に当てはまるのであれば、`nnmail-crosspost-link-function' を
`copy-file' に設定してください。(この変数はディフォルトで
`add-name-to-file' です。)

以前に行なわれたメール分割がメッセージをどこに入れたかを見たい場合は、
`M-x nnmail-split-history' 命令を使ってください。これからスプールし直そ
うとするメッセージがどこに入るかを見たい場合は、
`gnus-summary-respool-trace' および関連する命令 (*Note Mail Group
Commands::) を使ってください。

`nnmail-split-header-length-limit' の制限より長いヘッダー行は、分割関数
の処理対象から除外されます。

ディフォルトでは分割の処理においてヘッダーを MIME デコードしないので、
非-ASCII 文字列に合致させることができません。しかし、生のヘッダーのデー
タを元に記事の合致を判定したい場合には役立つでしょう。それを可能にする
には `nnmail-mail-splitting-decodes' 変数を `nil' ではない値に設定して
ください。加えて `nnmail-mail-splitting-decodes' が `nil' ではない場合
に、`nnmail-mail-splitting-charset' 変数の値が MIME ではないエンコード
された文字列 (訳注: `iso-2022-jp' でエンコードされた生のデータなど) を
デコードするために使われます。ディフォルトは `nil' で、MIME ではないエ
ンコードされた文字列をデコードしません。あなたにとって好都合な値はおそ
らく `undecided' か、またはあなたが興味があるメールで通常使われている文
字セット (訳注: 実際は coding system) になるでしょう。

ディフォルトでは入ってくるすべてのメッセージに対して分割の処理が行なわ
れます。しかし、もし `mail-sources' 変数 (*Note Mail Source
Specifiers::) に `directory' の項目を設定すると、ディフォルトでは分割は
*行なわれません*。変数 `nnmail-resplit-incoming' を `nil' ではない値に
設定すれば、この場合でも分割を起こさせることができます。(この変数は他の
種類の項目に対しては効果がありません。)

Gnus はあなた自身に災いが及ぶ可能性あっても、あなたが望むすべての機会を
提供します。例えば、あなたの上司からくるすべてのメールを入れるグループ
を作ったとしましょう。その後、偶発的にそのグループの購読をやめてしまう
とどうなるでしょう。それでも Gnus は上司からのすべてのメールを未購読の
グループに入れるので、上司が「月曜日までにその報告書を準備しないと首だ!」
というメールをあなたに送っても、あなたはそれを見ることはなく、火曜日に
なって本当は翌月の家賃を払うために空のボトルを集めるべきであっても、ま
だ有給で雇われていると信じているかもしれません。



File: gnus-ja.info, Node: Mail Sources, Next: Mail Back End Variables, Prev: Splitting Mail, Up: Getting Mail

メールソース
------------

メールはたくさんの別のソース (source) から取得することができます--例え
ばメールスプールから、POP メールサーバーから、procmail ディレクトリーか
ら、maildir から。

* Menu:

* Mail Source Specifiers::      メールのソースがどこかを指定する
* Mail Source Customization::   ものごとに影響するいくつかの変数
* Fetching Mail::               メールソース指示子を使う



File: gnus-ja.info, Node: Mail Source Specifiers, Next: Mail Source Customization, Prev: Mail Sources, Up: Mail Sources

メールソース指示子
..................

「メールソース指示子」に `メールソース' (*Note Fetching Mail::) を設定
して、Gnus にメールを取得する方法を指示しましょう。

例です:

     (pop :server "pop3.mailserver.com" :user "myname")

ご覧のように、メールソース指示子はリストで、最初の要素は「メールソース
の型」、それに任意の数の「キーワード」が続きます。明示的に指定されてい
ないキーワードはディフォルト値になります。

`mail-sources' はすべてのグループに対して共通です。しかし特定のグループ
のために、`mail-sources' に `group' メールソース指示子を持たせて、かつ
単一のメールソースを指定する `mail-source' グループパラメーター (*Note
Group Parameters::) を設定することによって、メールソースを追加すること
ができます。これを使う場合の `mail-sources' は、一般には単なる
`(group)' です。そしてグループのための `mail-source' パラメーターはこの
ようなものになるでしょう:

     (mail-source . (file :path "home/user/spools/foo.spool"))

これは、そのグループは (このグループだけは) メッセージをスプールファイ
ル `/user/spools/foo.spool' から取得することを意味します。

以下のメールソースの型が使用可能です:

`file'
     単一のファイルからメールを取得します。普通はメールスプールです。

     キーワード:

     `:path'
          ファイルの名前です。ディフォルトは `MAIL' 環境変数の値か
          `rmail-spool-directory' の値 (普通は
          `usr-mail/spool/user-name' のようなもの) です。

     `:prescript'
     `:postscript'
          それぞれのメールを取得する前と後で実行するスクリプトです。

     ファイルメールソースの例:

          (file :path "/usr/spool/mail/user-name")

     もしくは、ディフォルトのファイル名を使うと:

          (file)

     メールスプールファイルがローカルマシンに無い場合は、POP や IMAP な
     どでメールを取得するのが最善です。ここでは ange-ftp のファイル名は
     使用できません--メールを移動しているときにメールスプールをロックす
     る方法がありません。

     適当なサーバーを設置することが不可能なら、変わりに ssh を使うこと
     ができます。

          (setq mail-sources
                '((file :prescript "ssh host bin/getmail >%t")))

     `getmail' スクリプトは以下のようなものになるでしょう:

          #!/bin/sh
          #  getmail - move mail from spool to stdout
          #  flu@iki.fi

          MOVEMAIL=/usr/lib/emacs/20.3/i386-redhat-linux/movemail
          TMP=$HOME/Mail/tmp
          rm -f $TMP; $MOVEMAIL $MAIL $TMP >/dev/null && cat $TMP

     あなたが使いたい `movemail' と一時ファイルに合わせて、スクリプトを
     書き換えてください。

`directory'
     特定のディレクトリーにある複数のファイルからメールを取得します。こ
     れは普通は procmail に新しいメールをいくつかのファイルに分割させて
     いるときに使われます。すなわち、そのディレクトリーにあるファイルと
     グループは一対一で対応しているので、`foo.bar.spool' ファイルにある
     メールは `foo.bar' グループに置かれます (接尾語の `.spool' は変更
     可能です)。`nnmail-scan-directory-mail-source-once' を `nil' 以外
     の値にすると、Gnus に新しいメールソースを一回だけ調べさせることが
     できます。これは特に、指定したレベルのメールグループだけを調べたい
     ときに便利です。

     `nnmail-resplit-incoming' という変数もあり、これを非-`nil' にする
     と通常の分割処理がそのディレクトリーにあるすべてのファイルに対して
     行なわれます (*Note Splitting Mail::)。

     キーワード:

     `:path'
          ファイルがあるディレクトリーの名前です。これにはディフォルト
          値はありません。

     `:suffix'
          この接尾語で終わる名前ファイルだけが使われます。ディフォルト
          は `.spool' です。

     `:predicate'
          この述語が `nil' でない値を返すファイルだけが使われます。ディ
          フォルトは `identity' です。これは追加の選別器として使用され
          ます--正しい接尾語で、*かつ* この述語を満足するファイルだけが
          対象になります。

          訳注: この場合の述語は関数で、正しい接尾語を持つファイルの名
          前が引数として渡されます。

     `:prescript'
     `:postscript'
          それぞれのメールを取得する前と後で実行するスクリプトです。

     ディレクトリーメールソースの例です:

          (directory :path "/home/user-name/procmail-dir/"
                     :suffix ".prcml")

`pop'
     POP サーバーからメールを取得します。

     キーワード:

     `:server'
          POP サーバーの名前です。ディフォルトは `MAILHOST' 環境変数か
          ら取得されます。

     `:port'
          POP サーバーのポート番号です。これは数値 (例えば `:port
          1234') か文字列 (例えば `:port "pop3"') です。もし文字列なら
          Unix システムにおける `/etc/services' に載っているサービス名
          でなければなりません。ディフォルトは `"pop3"' です。システム
          によっては `"pop-3"' としなければならないかもしれません。

     `:user'
          POP サーバーに与える利用者名です。ディフォルトはログイン名です。

     `:password'
          POP サーバーに与えるパスワードです。設定しないと利用者は入力
          を求められます。

     `:program'
          POP サーバーからメールを取得するために使用されるプログラムで
          す。これは `format' で使うような文字列でなければなりません。
          例です:

               fetchmail %u@%s -P %p %t

          有効な書法仕様指示子は:

          `t'
               メールがそこに移動させられるファイルの名前です。これは常
               にこの文字列に含まれていなければなりません。

          `s'
               サーバーの名前です。

          `P'
               サーバーのポート番号です。

          `u'
               使用する利用者名です。

          `p'
               使用するパスワードです。

          これらの仕様で使われる値は、対応するキーワードに与えた値から
          取られます。

     `:prescript'
          メールを取得する前に実行されるスクリプトです。構文は
          `:program' キーワードと同じです。これは実行される関数であるこ
          ともできます。

     `:postscript'
          メールを取得した後で実行されるスクリプトです。構文は
          `:program' キーワードと同じです。これは実行される関数であるこ
          ともできます。

     `:function'
          POP サーバーからメールを取得するために使う関数です。その関数
          は一つのパラメーター (メールがそこへ移動されるべきファイルの
          名前) とともに呼ばれます

     `:authentication'
          これは `password' かシンボル `apop' のどちらかで、何の認証方
          式を使うかを指示します。ディフォルトは `password' です。

     `:program' と `:function' キーワードが指定されていない場合は
     `pop3-movemail' が使われます。`pop3-movemail' を使う場合に
     `pop3-leave-mail-on-server' が非-`nil' だったら、メールは取得した
     後でも POP サーバーに残されます。POP サーバーはセッションとセッショ
     ンの間の状態の情報を維持しないので、そこにあるクライアントが信頼で
     きる情報と、実際にそこにあるものは一致しないかもしれないことに注意
     してください。それらが一致しないと、メールをダブって受け取るか、ま
     たはすべてが崩壊して、あなたは壊れたメールボックスとともに置き去り
     にされる可能性があります。

          訳注: Gnus に含まれている `pop3.el' を使う場合に
          `pop3-leave-mail-on-server' を非-`nil' に設定するのは、あまり
          意味がありません。サーバーに残されたメールは、次回に (何度で
          も) 再び取り込まれてしまいます。一度取り込んだメールを二度と
          取得しないようにする機能を持つ `pop3.el' は T-gnus に含まれて
          います。これは XEmacs 用に開発されたものが元になっています。
          しかし、残念ながら誰が開発したかがわかりません。したがって
          FSF への正式な権利譲渡が行なわれていないので、Gnus に含めるこ
          とができないのです。

          参考: 以下は T-gnus の `pop3.el' を使う場合に自動的に追加され
          るメールソース用のキーワードです:

          `:connection'
               サーバーに接続するときに使うストリームで、`ssl'、`tls'
               または `nil' を指定することができます。ディフォルトは
               `nil' で、安全ではない接続を用います。`ssl' と `tls' で
               は外部プログラムとライブラリーが必要であることに注意して
               ください:

               `ssl'
                    SSL を使います。OpenSSL (`openssl' プログラム) か
                    SSLeay (`s_client') と外部ライブラリー `ssl.el' が
                    必要です。

               `tls'
                    STARTTLS (SSL に類似) を使います。外部ライブラリー
                    `starttls.el' と `starttls' プログラムが必要です。

          `:leave'
               非-`nil' でメールをサーバーに残し、メッセージの取得に
               UIDL を使います。ディフォルトは `nil' です。

     メールを POP サーバーから取得するための、いくつかの例を挙げます。
     ディフォルトの利用者名を使って、ディフォルトの POP サーバーから取
     得し、ディフォルトの取得方法を使用します:

          (pop)

     指名したサーバーから、指名した利用者とパスワードで取得します:

          (pop :server "my.pop.server"
               :user "user-name" :password "secret")

     メールの移動に `movemail' を使います:

          (pop :program "movemail po:%u %t %p")

`maildir'
     Maildir からメールを取得します。これは少なくとも qmail と postfix
     によってサポートされているメールボックスの形式で、特別のディレクト
     リーにあるそれぞれのファイルは、厳密に一通のメールを含んでいます。

     キーワード:

     `:path'
          メールが保存されるディレクトリーの名前です。ディフォルトは環
          境変数 `MAILDIR' から取得した値か、または `~/Maildir/' です。
     `:subdirs'
          Maildir のサブディレクトリーです。ディフォルトは `("new"
          cur")' です。

          リモートマシンからメールを取り寄せることも出来ます。(というの
          も、maildir はロックの問題を気にせずに済むからです。)

     Maildir メールソースの例をふたつ:

          (maildir :path "/home/user-name/Maildir/"
                   :subdirs ("cur" "new"))

          (maildir :path "/user@remotehost.org:~/Maildir/"
                   :subdirs ("new"))

`imap'
     IMAP サーバーからメールを取得します。何らかの理由で、IMAP をそれが
     意図されたようなネットワーク上でメールを読むプロトコルとしては (す
     なわち `nnimap' で) 使いたくないときは、Gnus では POP サーバーと同
     様に扱って、指定された IMAP メールボックスから記事を取得することが
     できます。詳しくは *Note IMAP:: を参照してください。

     Kerberos, GSSAPI, TLS/SSL および STARTTLS のための外
     部プログラムとライブラリーが必要であることに留意してください。
     *Note IMAP::.

     キーワード:

     `:server'
          IMAP サーバーの名前。ディフォルトは環境変数 `MAILHOST' から得
          ます。

     `:port'
          IMAP サーバーのポート番号。普通はディフォルトは `143' で、
          TLS/SSL 接続には `993' です。

     `:user'
          IMAP サーバーに渡す利用者名です。ディフォルトはログイン名です。

     `:password'
          IMAP サーバーに渡すパスワードです。指定されていないときは、利
          用者は入力することを促されます。

     `:stream'
          サーバーに接続するときに使うストリーム。`imap-stream-alist' にある
          シンボルの中のひとつを設定します。現状では `gssapi',
          `kerberos4', `starttls', `tls', `ssl',
          `shell' またはディフォルトの `network' になります。

     `:authentication'
          サーバーでの認証にどの認証法を使うか。これには
          `imap-authenticator-alist' で定義されているシンボルの一つを設
          定します。現状では `gssapi', `kerberos4', `digest-md5',
          `cram-md5', `anonymous' またはディフォルトの `login' になりま
          す。

     `:program'
          :stream に `shell' が設定されているときは、この値が変数
          `imap-shell-program' に割り当てられます。これは `format' ふう
          の文字列 (または文字列のリスト) でなければなりません。例を示
          しましょう:

               ssh %s imapd

          何物もそのプログラムの出力を邪魔しないようにしてください。例
          えばエラー出力は void に振り分けましょう。有効な書法仕様指示
          子は以下の通りです。

          `s'
               サーバーの名前。

          `l'
               `imap-default-user' で設定された利用者名。

          `p'
               サーバーのポート番号。

          これらの指定に使われる値は、対応するキーワードに与えた値から
          取ってきます。

     `:mailbox'
          メールを取得するメールボックスの名前。ディフォルトは `INBOX'
          で、これは普通は入ってくるメールを受け取るメールボックスです。

     `:predicate'
          取得する記事を見つけるために使われる述語。ディフォルトの、
          `UNSEEN UNDELETED' はおそらくたいていの人には最良の選択でしょ
          うが、ときどき IMAP クライアントでメールボックスを覗いて、い
          くつかの記事に既読 (または SEEN) の印を付けるなら、これを
          `1:*' に設定する必要があるかもしれません。そうすれば、メール
          ボックスのすべての記事は印の如何に関わらず取得されます。述語
          の完全な一覧は、RFC2060 の 6.4.4 節を読んでください。

     `:fetchflag'
          サーバーで、取得した記事にフラグを付ける方法。ディフォルトの
          `\Deleted' はそれらに消去のフラグを付けますが、単に既読のフラ
          グを付けるための `\Seen' が代案になるでしょう。これらは最もあ
          りそうな二つの選択ですが、他のフラグも RFC2060 の 2.3.2 節で
          定義されています。

     `:dontexpunge'
          `nil' でなかったら、記事を取得した後で、それらに消去の印が付
          いていても削除しません。

     IMAP メールソースの例:

          (imap :server "mail.mycorp.com"
                :stream kerberos4
                :fetchflag "\\Seen")

`webmail'
     `http://www.hotmail.com/', `http://webmail.netscape.com/',
     `http://www.netaddress.com/', `http://www.yahoo.com/' などのウェブ
     メールサーバーからメールを取得します。

     注: ウェブメールはクッキーに大きく依存します。url "4.0pre.46" を使
     う場合は "one-line-cookie" パッチを当てる必要があります。

     警告: メールが失われるかもしれません。無保証です。

     キーワード:

     `:subtype'
          ウェブメールサーバーの型です。ディフォルトは `hotmail' です。
          他の候補には `netscape', `netaddress', `my-deja' があります。

     `:user'
          ウェブメールサーバーに渡す利用者名です。ディフォルトはログイ
          ン名です。

     `:password'
          ウェブメールサーバーに渡すパスワードです。指定しない場合は、
          利用者は入力することを促されます。

     `:dontexpunge'
          `nil' でなかったら、未読の記事だけを取得し、かつ取得後にそれ
          らをごみ箱のフォルダーに移動しません。

     ウェブメールのソースの例です:

          (webmail :subtype 'hotmail
                   :user "user-name"
                   :password "secret")

`group'
     実際のメールソースとして `mail-source' グループパラメーターで設定
     されているものを使います。*Note Group Parameters::.


"Common Keywords"
     共通キーワードはどんな型のメールソースにも使うことができます。

     キーワード:

     `:plugged'
          `nil' でなかったら、Gnus が unplugged (ネットワークから切り離
          されている状態) であってもメールを取得します。ディレクトリー
          をメールソースに使っているのならば、この例のように指定するこ
          とができます:

               (setq mail-sources
                     '((directory :path "/home/pavel/.Spool/"
                                  :suffix ""
                                  :plugged t)))

          こうしておくことによって unplugged であっても Gnus はメールを
          取得します。これはローカルのメールとニュースを使う場合に便利
          です。


関数インターフェース
....................

上記のいくつかのキーワードは、実行するための Lisp 関数を指定します。関
数が実行されている間だけ、それぞれのキーワード `:foo' に対して Lisp 変
数 `foo' が、そのキーワードの値に束縛されます。例えば、以下のメールソー
スの設定例について考えてみてください。

     (setq mail-sources '((pop :user "jrl"
                               :server "pophost" :function fetchfunc)))

関数 `fetchfunc' が実行されているとき、`user' というシンボルの値は
`"jrl"' に束縛され、`server' というシンボルの値は `"pophost"' に束縛さ
れます。`port', `password', `program', `prescript', `postscript',
`function' および `authentication' の値もまた (それらのディフォルト値に)
束縛されます。

それぞれの型のメールソースのためのキーワードのリストについては、前述の
説明を参照してください。



File: gnus-ja.info, Node: Mail Source Customization, Next: Fetching Mail, Prev: Mail Source Specifiers, Up: Mail Sources

メールソースのカスタマイズ
..........................

以下はメールの取得方法に影響する変数の一覧です。普通はこれらのどれも設
定または変更する必要は無いでしょう。

`mail-source-crash-box'
     メールが、それを処理している期間中に格納されている場所です。ディフォ
     ルトは `~/.emacs-mail-crash-box' です。

`mail-source-delete-incoming'
     `nil' でなければ、入って来たメールを一時的に格納したファイルを、そ
     れを処理した後で消去します。`t' ではファイルをただちに消去し、
     `nil' ではいかなるファイルも消しません。正の数だった場合は、その日
     数以上に古いファイルを消去します (消去は新着メールを受け取るときだ
     け行なわれます)。`mail-source-delete-incoming' を `nil' にしておい
     て、`mail-source-delete-old-incoming' をフックで呼ぶか、または対話
     的に呼ぶこともできます。`mail-source-delete-incoming' のディフォル
     ト値は、アルファ版の Gnus では `10'、リリースされた版の Gnus では
     `2' です。*Note Gnus Development::.

`mail-source-delete-old-incoming-confirm'
     非-`nil' だったら、古い incoming (メールの到着時に使われた) ファイ
     ルを消去するときに確認を求めます。この変数は
     `mail-source-delete-incoming' が正の数である場合だけ使われます。

`mail-source-ignore-errors'
     非-`nil' だったら、メールソースからメールを読むときのエラーを無視
     します。

`mail-source-directory'
     入ってきたメールソースのファイルが (もしあれば) 格納されるディレク
     トリーです。ディフォルトは `~/Mail/' です。現時点でこれが使われる
     唯一のものは、変数 `mail-source-delete-incoming' が `nil' または数
     値であった場合に、入ってきたメールを格納するファイルの置き場所の指
     定です。

`mail-source-incoming-file-prefix'
     入ってきたメールを一時的に格納するファイルの名前の接頭語です。ディ
     フォルトは `Incoming' で、この場合ファイルは `Incoming30630D_' や
     `Incoming298602ZD' のようになります。これが本当に関係するのは
     `mail-source-delete-incoming' が `nil' または数値の場合だけですが。

`mail-source-default-file-modes'
     すべての新しいメールファイルはこのファイルモードになります。ディフォ
     ルトは 384 です。

`mail-source-movemail-program'
     `nil' でなかったら、新着メールを取り込むためのプログラムの名前であ
     ると解釈されます。`nil' だったら `exec-directory' にある
     `movemail' が使われます。



File: gnus-ja.info, Node: Fetching Mail, Prev: Mail Source Customization, Up: Mail Sources

メールの取得
............

新しいメールをどこから取得するかを実際に Gnus に指示する手段は、
`mail-sources' をメールソース指示子のリストに設定することです (*Note
Mail Source Specifiers::)。

この変数が `nil' であれば、メールバックエンドは決して自分自身ではメール
を取得しようとしません。

ローカルのスプールと POP メールサーバーの両方からメールを取得したいなら、
このようにすることができます:

     (setq mail-sources
           '((file)
             (pop :server "pop3.mail.server"
                  :password "secret")))

あるいは、これらのキーワードのどんなディフォルトも使いたくなければ、こ
のようにしてください:

     (setq mail-sources
           '((file :path "/var/spool/mail/user-name")
             (pop :server "pop3.mail.server"
                  :user "user-name"
                  :port "pop3"
                  :password "secret")))

あなたがメールバックエンドを使うとき、Gnus はすべてのメールを inbox か
ら吸い上げてホームディレクトリーに放り込みます。あなたがメールバックエ
ンドを使っていないときは、Gnus は一通もメールを移動しません--そういう場
合には、最初にたくさんの魔法を唱えなければなりません。まず五芳星を描き、
蝋燭を灯し、山羊を生け贄として捧げ終えた後には、Gnus があなたのメールを
移動したとしても、あなたは実際にはあまり驚かないはずです。



File: gnus-ja.info, Node: Mail Back End Variables, Next: Fancy Mail Splitting, Prev: Mail Sources, Up: Getting Mail

メールバックエンド変数
----------------------

これらの変数 (のほとんど) は、すべてのさまざまなメールバックエンドに関
連します。

`nnmail-read-incoming-hook'
     すべてのメールバックエンドは、新しいメールを読み込んだ後にこのフッ
     クを呼びます。そうしたければ、何かのメール監視プログラムに知らせる
     ためにこのフックを使うことができます。

`nnmail-split-hook'
     それぞれのメッセージがそのヘッダーに基づいて分割がなされる直前に、
     それが格納されているバッファーで実行されるフックです。このフックは、
     それがふさわしいと考えられるようにするために、どんなやり方ででも自
     由にバッファーの内容を編集することができます--バッファーは分割が終
     わった後で捨てられ、バッファーで行なわれた変更はどのファイルにも現
     れません。`gnus-article-decode-rfc1522' は、このフックに加えられる
     ことがありそうな関数の一つです。

`nnmail-pre-get-new-mail-hook'
`nnmail-post-get-new-mail-hook'
     これらは、入ってくるメールを処理するときに実行される、有用な二つの
     フックです---`nnmail-pre-get-new-mail-hook' は新しいメールを処理す
     る直前に呼ばれ、`nnmail-post-get-new-mail-hook' はメールの扱う処理
     が終わったときに呼ばれます。以下はこれらの二つのフックを使って、新
     しいメールのファイルのファイルモードを変更する例です:

          (add-hook 'nnmail-pre-get-new-mail-hook
                    (lambda () (set-default-file-modes 511)))

          (add-hook 'nnmail-post-get-new-mail-hook
                    (lambda () (set-default-file-modes 551)))

`nnmail-use-long-file-names'
     `nil' でないなら、メールバックエンドは長いファイル名とディレクトリー
     名を使います。`mail.misc' のようなグループは `mail.misc' という長
     い名前のディレクトリーかファイルに収められます (`nnml' バックエン
     ドの場合はディレクトリー、`nnfolder' バックエンドの場合はファイル
     です)。`nil' だったら、同じグループは `mail/misc' に収められます。

`nnmail-delete-file-function'
     ファイルを消去するために呼ばれる関数です。ディフォルトは
     `delete-file' です。

`nnmail-cache-accepted-message-ids'
     `nil' でないと、バックエンドに (例えば `Gcc' によって) 入って来た
     記事の `Message-ID' を、メールの重複を発見するためのキャッシュに入
     れます。ディフォルトは `nil' です。

`nnmail-cache-ignore-groups'
     正規表現か正規表現のリストです。名前がどれかの正規表現に合致するグ
     ループの記事は、`Message-ID' キャッシュに記録されません。

     例えば特級分割 (*Note Fancy Mail Splitting::) を関数
     `nnmail-split-fancy-with-parent' とともに使っている場合に役立つで
     しょう。



File: gnus-ja.info, Node: Fancy Mail Splitting, Next: Group Mail Splitting, Prev: Mail Back End Variables, Up: Getting Mail

特級メール分割
--------------

     訳注: "Fancy" という単語は、創造的、空想的、気まぐれな、好きな、派
     手な、上等な、極上の、変わり種の、等々のさまざまな意味で使われます
     が、ここでは助動詞無しで使える利便を考えて「特級」という訳語を割り
     当てました。

比較的単純な、標準のメール分割指定の方法では思い通りにならないならば、
`nnmail-split-methods' を `nnmail-split-fancy' に設定すると良いでしょう。
そうすると、変数 `nnmail-split-fancy' で遊ぶことができるようになります。

まずこの変数の値の例を見てみましょう:

     ;; メイラーデーモンから送られたメッセージが、普通のグループにクロス
     ;; ポストされないようにします。警告は本当のエラーとは違ったグループ
     ;; に入れます。
     (| ("from" mail (| ("subject" "warn.*" "mail.warning")
                        "mail.misc"))
        ;; エラーでないメッセージはすべての関連するグループにクロスポスト
        ;; しますが、(ding) メーリングリストと他の (ding) 関連のメールの
        ;; ためのグループにはクロスポストしません。
        (& (| (any "ding@ifi\\.uio\\.no" "ding.list")
              ("subject" "ding" "ding.misc"))
           ;; 他のメーリングリスト...
           (any "procmail@informatik\\.rwth-aachen\\.de" "procmail.list")
           (any "SmartList@informatik\\.rwth-aachen\\.de" "SmartList.list")
           ;; 以下のどちらのメーリングリストも同じ接尾語なので、bugs- だ
           ;; けに投稿されたものが mypkg.list にクロスポストされないよう
           ;; にしています。しかし本当にクロスポストされた記事をクロスポ
           ;; ストすることはできるようになっています。
           (any "bugs-mypackage@somewhere" "mypkg.bugs")
           (any "mypackage@somewhere" - "bugs-mypackage" "mypkg.list")
           ;; 人々...
           (any "larsi@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
        ;; 合致しなかったメールはすべてを捕まえるグループへ行きます。
        "misc.misc")

この変数は「分割」の様式になっています。分割は (ことによると) それぞれ
の分割が他の分割を含む再帰的構造です。以下は使うことができる分割の構文
です:

`group'
     分割が文字列だったら、それはグループ名であるとみなされます。通常の正規表
     現の展開が行なわれます。後述の例 (訳注: `\\&',
     `\\1'〜`\\9') を見てください。

`(FIELD VALUE [- RESTRICT [...] ] SPLIT [INVERT-PARTIAL])'
     この分割は少なくとも三つの要素を含んでいる必要があります。最初の要
     素 FIELD (正規表現) に合致するヘッダーが VALUE (これも正規表現) に
     合致する文字列を含んでいたならば、SPLIT で指定されたグループにメッ
     セージを格納します。

     FIELD の後にあって、しかも合致した VALUE の最後尾より前にある何か
     の文字列に RESTRICT (これもまた正規表現) が合致したら、SPLIT は無
     視されます。いくつかの RESTRICT のどれもが合致しなければ SPLIT が
     実行されます。

     最後の要素 INVERT-PARTIAL は任意です。これが省略されていなくて、し
     かも値が `nil' でなければ、語 (word) の境界をまたいで正規表現の合
     致を行なうかどうかの振る舞い
     (`nnmail-split-fancy-match-partial-words' 変数によって制御されます;
     下記参照) が反転します。(Gnus 5.10.7 の新機能)

`(| SPLIT ...)'
     分割がリストで、最初の要素が `|' (垂直棒) だったら、それぞれの
     SPLIT をそのうちの一つが合致するまで実行します。ここで言う「合致」
     とは、ある SPLIT がメッセージを一つ以上のグループに格納しようとす
     ることです。

`(& SPLIT ...)'
     分割がリストで、最初の要素が `&' だったら、そのリストにあるすべて
     の SPLIT を実行します。

`junk'
     もし分割がシンボル `junk' だったら、そのメッセージを保存しません
     (すなわち、消去してしまいます)。非常に注意して使ってください。

`(: FUNCTION ARG1 ARG2 ...)'
     もし分割がリストで、最初の要素が `:' だったら、二番目の要素が
     ARGS を引数として関数として呼ばれます。関数は SPLIT を返さなければ
     なりません。

     例えば以下の関数は、記事のボディーに基づいた分割に使えるでしょう:

          (defun split-on-body ()
            (save-excursion
              (save-restriction
                (widen)
                (goto-char (point-min))
                (when (re-search-forward "Some.*string" nil t)
                  "string.group"))))

     FUNCTION が実行されるとき、バッファーは対象となるメッセージのヘッ
     ダー部分に狭められています。それが上記の例で `save-excursion' と
     `save-restriction' の後で `(widen)' を呼ぶ必要がある理由です。さら
     に `nnimap' バックエンドの場合、ディフォルトでは記事のボディーがダ
     ウンロードされないことに注意してください。それをするためには
     `nnimap-split-download-body' を `t' に設定する必要があります
     (*Note Splitting in IMAP::)。

`(! FUNC SPLIT)'
     分割がリストで最初の要素が `!' だったら、SPLIT が実行され、FUNC は
     SPLIT の結果を引数として呼ばれます。FUNC は分割を返さなければなり
     ません。

`nil'
     分割が `nil' だったら、それは無視されます。

これらの分割で FILELD は完全なフィールド名 (と言うかヘッダー名) に合致
しなければなりません。

通常これらの分割における VALUE は、基礎モード (fundamental mode) 構文テー
ブル (syntax table) に従って、完全に *語* (word) に合致しなければなりま
せん。言い換えれば、すべての VALUE は暗に `\<...\>' 印 (語の区切り記号)
で囲まれます。したがって、例えば以下の分割を使うと、

     (any "joe" "joemail")

`joedavis@foo.org' からやって来たメッセージは、通常 `joemail' には格納
されないでしょう。この振る舞いを変更したければ、以下の三つのやり方のど
れでもを使うことができます:

  1. `nnmail-split-fancy-match-partial-words' 変数を `nil' ではない値に
     設定することによって、語の境界を無視させることができます。すると、
     合致はより grep ふうになります。この変数は、特級分割で語の境界をま
     たいだ合致を行なうかどうかを制御します。ディフォルト値は `nil' で
     す。

     分割の規則のすべての VALUE に影響することに注意してください。

  2. `.*' で始まる VALUE は、語の前にある語の境界を無視させます。
     同様に `.*' で終わる VALUE は、語の後ろにある語の境界を無視さ
     せます。例えば `"@example\\.com"' とい
     う VALUE は `foo@example.com' に合致しませんが、
     `".*@example\\.com"' ならば合致します。

  3. この章の最初の方で述べた INVERT-PARTIAL フラグを、`(FIELD
     VALUE ...)' 型の分割規則で使うことができます。このフラグが設定され
     ていると、`nnmail-split-fancy-match-partial-words' が `nil' であっ
     ても、語の両側にある語の境界は無視されます。逆に、このフラグが設定
     されていると、`nnmail-split-fancy-match-partial-words' が `nil' で
     はない値であっても、語の境界は無視されません。(Gnus 5.10.7 の新機
     能)

FIELD と VALUE は Lisp シンボルであることもできます。その場合それらは
`nnmail-split-abbrev-alist' で指定された内容に従って展開されます。これ
はセルの CAR がキーを含んでいて、CDR が関連付けられた値を持っているコン
スセル (cons cell) の連想リストです。以下の項目が、あらかじめ
`nnmail-split-abbrev-alist' に定義されています:

`from'
     `From'、`Sender' および `Resent-From' の各フィールドに合致します。
`to'
     `To'、`Cc'、`Apparently-To'、`Resent-To' および `Resent-Cc' の各
     フィールドに合致します。
`any'
     `from' と `to' を統合したものです。

`nnmail-split-fancy-syntax-table' は、これらのすべての分割が実行されて
いるときに有効な構文テーブルです。

ヘッダーのいくつかの情報に基づいて、Gnus に動的にグループを作らせたい
(例えば、グループ名の一部を `replace-match' のようなやり方で置き換えさ
せたい) ならば、次のようなことができます。

     (any "debian-\\b\\(\\w+\\)@lists.debian.org" "mail.debian.\\1")

この例では、`debian-foo@lists.debian.org' に送られたメールは
`mail.debian.foo' というグループに入れられます。

文字列が要素 `\\&' を含んでいる場合は、直前に合致した文字列で置き換えら
れます。同様に、要素 `\\1' から `\\9' までは、合致した文字列の一部で置
き換えられます (訳注: 正規表現の中に `\\(' と `\\)' を使ってグループに
まとめられたものが一つ以上ある場合に、`\\N' はその正規表現の N 個目のグ
ループに合致する文字列の一部で置き換えられます)。

その際、合致した文字列を小文字にしたもので置き換えるべきかどうかを
`nnmail-split-lowercase-expanded' が決定します。これを非-`nil' にするこ
とによって、アドレスで大文字と小文字が区別せずに使われている (例えば
mailing-list@domain と Mailing-List@Domain) 場合でも、複数のグループが
生成されてしまうことを避けることができます。ディフォルトは `t' です。

関数 `nnmail-split-fancy-with-parent' は、フォローアップ記事を親記事と
同じグループに振り分けるために使います。メールの振り分けを一生懸命設定
してみても完璧にはできないことがありますね。例えば、上司から個人宛ての
メールが届いたとします。自分が携っているプロジェクトとは別の話です。け
れど「他のメールと区別できるようにこれこれこういう言葉を表題に書いてく
ださい」と上司に向かって指図するわけにはいきませんから、結局自分の手を
煩わしてひとつひとつメールを正しいグループに振り分けるはめになります。
そんなときにこの関数を使うと、この面倒な作業を一スレッドにつき一回きり
で済ますことができます。

この機能を利用するためには、まず変数 `nnmail-treat-duplicates' および
`nnmail-cache-accepted-message-ids' の値を `nil' ではない値に設定する必
要があります。それができたら `nnmail-split-fancy-with-parent' を使って
みてください。コロンを使ってこんな風に書きます:

     (setq nnmail-treat-duplicates 'warn     ; または `delete'
           nnmail-cache-accepted-message-ids t
           nnmail-split-fancy
           '(| (: nnmail-split-fancy-with-parent)
               ;; 残りの振り分け方はここに書く
             ))

この機能は実際、次の様に働いています: 変数 `nnmail-treat-duplicates' の
値が非-`nil' の場合、Gnus は見つけた全記事のメッセージ ID を変数
`nnmail-message-id-cache-file' で指定されたファイルに記録します。このと
き、それぞれの記事が格納されたグループの名前を併記します (ただしメール
ではないメッセージの場合は、グループ名は省略されます)。さて、いよいよメー
ルの振り分けが始まると、関数 `nnmail-split-fancy-with-parent' は、分割
される各記事の References (と In-Reply-To) ヘッダーを調べ、
`nnmail-message-id-cache-file' で指定されたファイルにそれらのメッセージ
ID があるかどうか調べます。親記事が見つかると、そのグループ名が正規表現
`nnmail-split-fancy-with-parent-ignore-groups' に合致しなければ、この関
数は対応するグループ名を返すわけです。ここで、変数
`nnmail-message-id-cache-length' の値をディフォルトよりも幾らか大きな値
に設定することを勧めます。そうすると、今調べられたメッセージ ID たちは
今しばらくキャッシュの中に存続できます (5000 に設定するとキャッシュファ
イルの大きさはだいたい 300 キロバイトぐらいになるみたいです)。さらに、
変数 `nnmail-cache-accepted-message-ids' の値を非-`nil' に設定すれば、
Gnus は移動された記事のメッセージ ID をも記録するので、フォローアップ記
事は親記事の移動先と同じグループに入るようになります。

特定のグループをキャッシュに記録したくない場合は、変数
`nnmail-cache-ignore-groups' も参照してください。例えば、外に出すすべて
のメッセージを“outgoing”グループに保存しているのならば、
`nnmail-cache-ignore-groups' をそのグループ名に合致するように設定すれば
良いでしょう。さもないとあなたのすべてのメッセージに対する返事が
“outgoing”グループに入ってしまいます。



File: gnus-ja.info, Node: Group Mail Splitting, Next: Incorporating Old Mail, Prev: Fancy Mail Splitting, Up: Getting Mail

グループメール分割
------------------

何ダースものメーリングリストを購読しているけれど、手でメール分割規則を
維持したくないというときのために、グループメール分割というものがありま
す。あなたがしなければならないことは、グループパラメーターかグループカ
スタマイズで `to-list', `to-address' の両方もしくはどちらかを設定して
`nnmail-split-methods' を `gnus-group-split' に設定するだけです。分割関
数はすべてのグループでこれらのパラメーターを走査し、それに従って分割し
ます。すなわち、メールグループのパラメーター `to-list' か `to-address'
で指定されたアドレスから投稿されたものか、そのアドレスへ投稿されたメッ
セージがそのグループに保存されます。

ときには、メーリングリストには複数のアドレスがあり、メール分割にそれら
すべてを認識させる必要があるかもしれません: `extra-aliases' グループパ
ラメーターを追加のアドレスのリストに設定するだけで終りです。あえて正規
表現を使いたければ、`split-regexp' を設定してください。

これらのすべてのグループのパラメーターは、`nnmail-split-fancy' の分割を
作成するために使用されます。その分割の仕様の中身は、FIELD の値が `any'
であり、VALUE の値が `to-list' と `to-address' と `extra-aliases' のす
べてと `split-regexp' に合致するもののすべてに合致する単一の正規表現、
そして SPLIT がグループの名前になります。RESTRICT も使うことができます:
それには `split-exclude' パラメーターを正規表現のリストに設定してくださ
い。

これらのすべてのパラメーターを使って正しい分割が生成されないときや、何
かもっと凝ったものが必要なときは、`split-spec' パラメーターを
`nnmail-split-fancy' の分割に設定することができます。この場合は、前もっ
て書かれたすべてのパラメーターは `gnus-group-split' に無視されます。特
に、`split-spec' は `nil' (訳注: これも `nnmail-split-fancy' の分割の一
種です) に設定することができ、その場合そのグループは
`gnus-group-split' に無視されます。

それぞれのグループのために、一つの分割を含む単一の `&' 特級分割を定義す
ることによって、`gnus-group-split' は合致するすべてのグループにクロスポ
ストをします。どの分割にも合致しないメッセージは、どれかのグループで
SPLIT-SPEC が `catch-all' に設定されていない場合は
`gnus-group-split-default-catch-all-group' で指定された名前のグループに
格納されます。その場合、そのグループはすべてを受け取る (catch-all) グルー
プとして使われます。この変数はしばしばグループを指定するためだけに使わ
れますが、任意の複雑な特級分割に設定することもできるので (結局のところ
グループ名は特級分割なのです)、個人のメールフォルダーにそれらのメールが
格納されるどのメーリングリストにも当てはまらないメールを、分割するのに
便利でしょう。なおこの特級分割は、`|' 分割リスト (それは、グループパラ
メーターから抽出された規則を持った `&' 分割をも含んでいます) の最後の要
素として追加されることに注意してください。

そろそろ例を出すべきでしょう。以下のグループパラメーターが定義されてい
ることを仮定します:

     nnml:mail.bar:
     ((to-address . "bar@femail.com")
      (split-regexp . ".*@femail\\.com"))
     nnml:mail.foo:
     ((to-list . "foo@nowhere.gov")
      (extra-aliases "foo@localhost" "foo-redist@home")
      (split-exclude "bugs-foo" "rambling-foo")
      (admin-address . "foo-request@nowhere.gov"))
     nnml:mail.others:
     ((split-spec . catch-all))

`nnmail-split-methods' を `gnus-group-split' に設定すると、
`nnmail-split-fancy' が選択されていて、かつ変数 `nnmail-split-fancy' が
以下のように設定されているかのように振舞います:

     (| (& (any "\\(bar@femail\\.com\\|.*@femail\\.com\\)" "mail.bar")
           (any "\\(foo@nowhere\\.gov\\|foo@localhost\\|foo-redist@home\\)"
                - "bugs-foo" - "rambling-foo" "mail.foo"))
        "mail.others")

グループ分割をすべてのメールグループで積極的には使いたくなければ、
`nnmail-split-fancy' の分割を次のように使用することで、いくつかのグルー
プだけで使うことができます。

     (: gnus-group-split-fancy GROUPS NO-CROSSPOST CATCH-ALL)

GROUPS は、出力の分割を生成するためにパラメーターが走査されるグループ名
のリストか、それらのグループ名に合致する正規表現です。NO-CROSSPOST はク
ロスポストを禁止するために使うことができ、その場合は、単一の `|' 分割が
出力されます。CATCH-ALL は `gnus-group-split-default-catch-all-group'
のように、最後の手段として使われる特級分割です。CATCH-ALL が `nil' に設
定されているか、`split-regexp' がどれかの選択されたグループで空の文字列
に合致すると、すべてを受け取る (catch-all) 分割は発行されません。そうで
ない場合、あるグループに `catch-all' に設定されている `split-spec' があ
ると、そのグループは CATCH-ALL 引数の値よりも優先されます。

不運なことに、すべてのグループとそれらのパラメーターを走査することは、
特にすべてのメッセージに対して行なわなければならないことを考慮に入れる
と、非常に遅くなるでしょう。でも、絶望してはいけません。
`gnus-group-split-setup' 関数を、はるかに効率的な方法で
`gnus-group-split' を動作させるために使うことができます。それは
`nnmail-split-methods' を `nnmail-split-fancy' に設定し、
`nnmail-split-fancy' を `gnus-group-split-fancy' で生成される分割に設定
します。そうすることによって、どんなに分割するメッセージがたくさんあっ
ても、グループパラメーターは一度だけ走査されるようになります。

しかしながら、グループパラメーターを変更すると、`nnmail-split-fancy' を
手で更新しなければならなくなるでしょう。`gnus-group-split-update' を実
行することによって、それを行なうことができます。どちらかと言えば、それ
を自動的に更新したい場合には、`gnus-group-split-setup' にそれを実行する
ように指示してください。例えば、`~/.gnus.el' に以下のものを追加すれば良
いでしょう:

     (gnus-group-split-setup AUTO-UPDATE CATCH-ALL)

AUTO-UPDATE が `nil' でなければ `gnus-group-split-update' が
`nnmail-pre-get-new-mail-hook' に追加されるので、二度と
`nnmail-split-fancy' の更新について心配する必要はありません。CATCH-ALL
を省略しない場合は (それはオプションで `nil' と等価です)、
`gnus-group-split-default-catch-all-group' がその値に設定されます。

`gnus-group-split-update' によって設定された `nnmail-split-fancy' を後
で変更する必要があるときのために、この関数 (`gnus-group-split-update')
は終了する直前に `gnus-group-split-update-hook' を実行します。



File: gnus-ja.info, Node: Incorporating Old Mail, Next: Expiring Mail, Prev: Group Mail Splitting, Up: Getting Mail

古いメールを取り込む
--------------------

たいていの人は色々なファイルフォーマットで保存されたたくさんの古いメー
ルを持っているでしょう。Gnus の粋なメールバックエンドの一つを使うように
設定したのであれば、おそらく古いメールをメールグループに取り込みたいと
思いますよね。

それをすることはとても簡単です。

例を挙げましょう: `nnml' (*Note Mail Spool::) を使ってメールを読んでい
て、`nnmail-split-methods' を申し分の無い値に設定しているものとしましょ
う。重要な、しかし古いメールで、古い Unix mbox ファイルが満たされていま
す。あなたはそれを `nnml' グループに移動したいと思っています。

方法です:

  1. グループバッファーに行ってください。

  2. `G f' をタイプしてください。`nndoc' グループを作成するための元にな
     る mbox ファイルの名前を求められるので、それを入力してください
     (*Note Foreign Groups::)。

  3. `SPACE' をタイプして、新しく作られたグループに入ってください。

  4. `M P b' をタイプして、グループバッファーのすべての記事に実行印を付
     けてください (*Note Setting Process Marks::)。

  5. `B r' をタイプしてプロセス印の付いたすべての記事を再スプールしてく
     ださい。その際に入力を求められるので、`nnml' と答えてください
     (*Note Mail Group Commands::)。

今や mbox ファイルのすべてのメールメッセージは、あなたの `nnml' グルー
プ群にもばらまかれています。それらに入って、ものごとが変な故障も無く、
うまくいったかどうかを調べてください。大丈夫なようであれば、mbox ファイ
ルを消そうと思うかもしれませんが、私はすべてのメールがあるべきところに
納まったことを完全に確認するまでは、そうはしません。

再スプールすることは、あるメールバックエンドを別のものに変更するときに
も便利なものです。古いメールグループにあるメールは、新しいメールバック
エンドを使ってただ再スプールすれば良いのです。



File: gnus-ja.info, Node: Expiring Mail, Next: Washing Mail, Prev: Incorporating Old Mail, Up: Getting Mail

メールの期限切れ消去
--------------------

伝統的なメールリーダーは、既読の印を付けるとメールの記事を何らかの方法
で削除する傾向があります。Gnus はメールを読むことに対して、基本的に違う
方法を取ります。

基本的に Gnus は、メールを少々変わった方法で受け取られたニュースである
とみなします。実際にメールを変更したり、メールメッセージを消す権限があ
るとは考えません。あなたがメールグループに入って記事に「既読」の印を付
けたり、何らかの他のやり方で切ったりしても、メールの記事はまだシステム
に存在しています。繰り返します: Gnus はあなたの古い既読のメールを消去し
ません。もちろん、あなたがそうしろと要求しない限りの話ですが。

要らないメールを Gnus に削除させるには、記事に「期限切れ消去可能」
(expirable) の印を付けなければなりません。(ディフォルトのキー割り当てで
は、`E' をタイプしなければならないということです。) しかしながら、これ
は記事が即座に消え去るということではありません。一般的にメール記事は、
1) 期限切れ消去可能の印が付いていて、かつ 2) 一週間以上経っている、とい
う場合に、システムによって削除されます。記事を期限切れ消去可能にしなけ
れば、それは地獄が凍りつくまでシステムに残り続けます。このことは、もう
一度強調付きで繰り返されるに足るものです: 「もし」あなたが記事を「期限
切れ消去可能」に「しない」なら、Gnus は「決して」それらの「記事」を消去
しません。

手作業で記事に期限切れ消去可能の印を付けなければならないわけではありま
せん。Gnus は“auto-expire”および“total-expire”と呼ばれる二つの機能
を提供して、あなたの手助けをします。かいつまんで言えば“auto-expire”は
あなたが記事を選択したときに Gnus が `E' を叩いてくれることを意味します。
そして“total-expire”は、すべての既読の記事は期限切れ消去可能であると
Gnus が解釈することを意味します。したがって `E' の印が付けられた記事に
加えて、`r', `R', `O', `K', `Y' などの印が付けられた記事も期限切れ消去
可能であると解釈されます。

では auto-expire または total-expire は、いつ使用されるべきなのでしょう
か?  メーリングリストを購読しているほとんどの人々は、それぞれのリストが
それ用のグループに分割されるようにして、それらのグループに対して
auto-expire または total-expire を有効にしています。(それぞれのリストを
それ用のグループへの分割する件についてのさらなる情報は *Note Splitting
Mail:: を参照してください。)

auto-expire と total-expire のどちらが良いのでしょうか?  それに答えるの
は簡単ではありません。概して言えば、たぶん auto-expire が速いでしょう。
auto-expire の別の利点は、より多くの印を後で読み返すつもりの記事に使う
ことができる、つまり今までどおりに可視 (tick)、保留 (dormant) または既
読 (read) の中から選ぶことができるということです。しかし total-expire
では、dormant と ticked からしか選べません。total-expire の利点は、適応
スコア付け (*Note Adaptive Scoring::) で良好に働くことです。
auto-expire は通常のスコア付けでは動作しますが、適応スコア付けではだめ
です。

正規表現 `gnus-auto-expirable-newsgroups' に合致するグループでは、読ん
だすべての記事に自動的に期限切れ消去可能の印が付けられます。期限切れ消
去可能の印の付いたすべての記事は、概略バッファーの最初の桁に `E' が表示
されます。

自動期限切れ消去を有効にすると、ディフォルトではあなたが読んだすべての
記事に、以前に読まれたかどうかに関わらず、 Gnus は期限切れ消去可能の印
を付けます。既読の印が付いている記事に、自動的に期限切れ消去可能の印が
付けられるのを避けるには、以下のようなものを `~/.gnus.el' ファイルに置
いておけば良いでしょう:

     (remove-hook 'gnus-mark-article-hook
                  'gnus-summary-mark-read-and-unread-as-read)
     (add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read)

グループを自動期限切れ消去可能にしても、すべての既読の記事が期限切れ消
去されるわけではなく、期限切れ消去可能の印が付いている記事だけが期限切
れ消去されることに気を付けてください。また、`d' 命令が自動的に記事を期
限切れ消去可能にするのでは無いことにも気を付けてください--自動期限切れ
消去可能にしたグループでは、記事に既読の印が半自動で付けられることによっ
てのみ、記事が期限切れ消去可能になるということです。

2〜3 のメーリングリストを講読していて、読み終わってしばらく経ったら記事
が消えてしまうようにしたいなら、例えばこんな風に設定しましょう:

     (setq gnus-auto-expirable-newsgroups
           "mail.nosense-list\\|mail.nice-list")

自動期限切れ消去を行なわせるもう一つの方法は、そのグループのグループパ
ラメーターに `auto-expire' という要素を持たせることです。

もし適応スコア付け (*Note Adaptive Scoring::) と自動期限切れ消去を使用
していると、問題が起こるでしょう。自動期限切れ消去と適応スコア付けはあ
まり良く調和しません。

変数 `nnmail-expiry-wait' で、期限切れ消去可能な記事をどれくらいの期間
残しておくかのディフォルトの時間を設定します。Gnus はメッセージが送り出
されたときではなく、それが *到着* してからの日数を計算します。ディフォ
ルトは 7 日間です。

Gnus は記事がどのグループに属しているかに基づいて、それをどのくらい残し
ておくかをこまめに設定する関数も提供しています。以下の例では
`mail.private' グループは一ヶ月、`mail.junk' グループは一日、その他全部
は六日間に、それぞれ期限を設定します:

     (setq nnmail-expiry-wait-function
           (lambda (group)
            (cond ((string= group "mail.private")
                    31)
                  ((string= group "mail.junk")
                    1)
                  ((string= group "important")
                   'never)
                  (t
                    6))))

この関数に与えられるグループ名には「装飾」すなわち `nnml:' のようなもの
は付きません。

変数 `nnmail-expiry-wait' と関数 `nnmail-expiry-wait-function' は、数値
(整数である必要はありません) かシンボルの `immediate' か `never' のどち
らかにすることができます。

期限切れ期間を選択的に変更するために、グループパラメーターの
`expiry-wait' を使うこともできます (*Note Group Parameters::)。

記事を期限切れ消去するときに取られる通常の動作は、それらを消去すること
です。しかし、場合によってはそれらを消去するよりも別のグループに移動し
た方が有意義かもしれません。変数 `nnmail-expiry-target' (とグループパラ
メーター `expiry-target') はこれを制御します。この変数の値はすべてのグ
ループに対するディフォルトになりますが、特定のグループごとにグループパ
ラメーターを使って指定すれば、そちらを優先させることができます。ディフォ
ルトの値は `delete' ですが、文字列 (記事を移動する先のグループ名) また
は移動先のグループ名か `delete' を返す関数にすることができます (関数の
場合は、記事に範囲を狭めたバッファーで、その記事が存在しているグループ
名が引数として与えられます)。

グループ名を指定する場合の例:
     (setq nnmail-expiry-target "nnml:expired")

Gnus には期限切れのメールをグループに移動させるための関数があります。そ
れは変数 `nnmail-fancy-expiry-targets' に従って動作します。例です:

      (setq nnmail-expiry-target 'nnmail-fancy-expiry-target
            nnmail-fancy-expiry-targets
            '((to-from "boss" "nnfolder:Work")
              ("subject" "IMPORTANT" "nnfolder:IMPORTANT.%Y.%b")
              ("from" ".*" "nnfolder:Archive-%Y")))

この設定を行なうことにより、表題ヘッダーに `IMPORTANT' を持っていて、
`YYYY' 年 `MMM' 月に発信されたいかなるメールも、期限になると
`nnfolder:IMPORTANT.YYYY.MMM' グループに移動させられます。また、From ま
たは To ヘッダーが文字列 `boss' を含んでいるメールは `nnfolder:Work' に、
それ以外のすべてのメールは `nnfolder:Archive-YYYY' に、それぞれ期限にな
ると移動させられます。

`nnmail-keep-last-article' が `nil' でないと、Gnus はメールグループの最
後の記事を決して期限切れ消去しません。これは procmail の利用者の人生を
より楽にするためのものです。

補足: 上記の、Gnus が決して期限切れ消去可能でない記事を期限切れ消去する
ことはない、というのは嘘です。`total-expire' をグループパラメーターに入
れても、記事に期限切れ消去の印が付くことはありませんが、読んだすべての
記事は期限切れ消去の処理に通されます。非常に注意して使ってください。さ
らに危険なのは変数 `gnus-total-expirable-newsgroups' です。この正規表現
に合致するすべてのグループでは、読んだすべての記事が期限切れ消去の処理
に通されます。これは、当のグループの *すべて* の古いメールの記事は、し
ばらく後で削除されるということです。非常に注意して使ってください。そし
て、あなたが使った正規表現が間違ったグループに合致してしまい、すべての
重要なメールが消えてしまったと言って、私に泣き付いて来ないでください。
しっかしりなさい! (直訳: 男になりなさい、あるいは女になりなさい、さもな
ければもっと気持ちいい何にでもなりなさい!) ほうら、言わんこっちゃない!

たいていの人はほとんどのメールグループを total-expirable (全体期限切れ
消去可能) にしますが。

`gnus-inhibit-user-auto-expire' が `nil' でなければ、グループで自動期限
切れ消去が有効になっていても、利用者が印を付ける命令が記事に期限切れ消
去可能の印を付けることはありません。

記事の期限切れ消去可能の印は、自動期限切れ消去が有効になっていないグルー
プにコピーするか移動するとき削除されます。これは記事が不意に期限切れ消
去されてしまうことを防ぐためです。一方、自動期限切れ消去が有効になって
いるグループにコピーまたは移動される記事の期限切れ消去可能の印は、ディ
フォルトでは変化しません。つまり、そのようなグループにコピーまたは移動
されるとき、期限切れ消去可能だった記事は期限切れ消去可能のままにされ、
期限切れ消去可能ではなかった記事に期限切れ消去可能の印が付くことはあり
ません。したがって、たとえ自動期限切れ消去のグループであっても、いくつ
かの記事は期限切れ消去されないでしょう (それらを再び読まない限りは)。自
動期限切れ消去のグループに期限切れ消去しない記事が紛れ込んでしまうかも
しれないその動作が気に入らないなら、
`gnus-mark-copied-or-moved-articles-as-expirable' を `nil' ではない値に
設定することができます。その場合、読み終わった記事は自動期限切れ消去が
有効になっているグループにコピーまたは移動するとき、期限切れ消去可能の
印が自動的に付けられます。ディフォルト値は `nil' です。



File: gnus-ja.info, Node: Washing Mail, Next: Duplicates, Prev: Expiring Mail, Up: Getting Mail

メール洗濯
----------

メイラーやメーリングリストのサーバーは、メールに対して本当に本当に馬鹿
げたことをすることで悪名高いです。「わぁ、RFC822 はサーバーを通っていく
メッセージのすべての行の最後に `wE aRe ElItE!!!!!1!!' を加えることを明
示的に禁止はしていないぞ。さぁ、やってみよう!!!!1!」えぇ、そのとおりで
すが、RFC822 はおろか者が読むようには書かれていません。当たり前なこと
(訳注: 良識から逸脱すること) はそこでは議論されていません。ですから、こ
の章が必要なのです。

適例: ドイツ語版の Microsoft Exchange は返答の表題に `Re: ' の代わりに
`AW: ' を付け加えます。私はこれに動揺して狼狽しているふりをすることもで
きましたが、そうする気力がありませんでした。それは笑うべきことです。

Gnus は表示する記事を洗濯するために多すぎるほどの関数を提供していますが、
メールをディスクに保存する前にふるいにかけることができた方が良いかもし
れません。その目的のために、三つのフックとそれらのフックに入れることが
できる色々な関数を用意しています。

`nnmail-prepare-incoming-hook'
     このフックはメールに何かをする前に呼ばれ、総括的に掃除してきれいに
     する所作のためにあります。それは新しいすべての入ってきたメールを含
     んでいるバッファーで呼ばれます。使うことのできる関数は:

     `nnheader-ms-strip-cr'
          それぞれの行から、最後にあるキャリッジリターン (carriage
          return) を取り除きます。これは MS のマシン上で動作している
          Emacs のディフォルトです。

`nnmail-prepare-incoming-header-hook'
     このフックはそれぞれのメールのヘッダーに範囲を狭められて呼ばれます。
     ヘッダーをきれいにするときに使うことができます。使うことのできる関
     数は:

     `nnmail-remove-leading-whitespace'
          「役に立つ」メーリングリストのサーバーが、見栄えを良くするた
          めだと称して、ヘッダーの前の方に付け加えた空白を無くします
          (訳注: 例えば `Subject:' などの直後に二つ以上の空白文字があっ
          たら、一つを残して消します)。まったくもう。

          (この関数はすべてのメッセージのボディーの中にあるヘッダー (ボ
          ディーの中にある別のメッセージが持っているヘッダー行のような
          もの) に対しても動作するので、使用に際しては潜在的な危険を孕
          んでいます。したがってバグを修正するよりは、そういう特徴があ
          ることを文書で説明するのが、もちろん正しい解決の道です。)

     `nnmail-remove-list-identifiers'
          いくつかのメーリングリストのサーバーは、そのリストが配信した
          メールであることを同定するための識別子--例えば `(idm)'---をす
          べての `Subject' ヘッダーの先頭に付け加えます。石器時代のメー
          ルリーダーを使っている人たちには、それは確かに良いことです。
          この関数は正規表現 `nnmail-list-identifiers' に合致する文字列
          を取り除きます。それは正規表現のリストでも構いません。ただし
          正規表現に `\\(..\\)' を含めてはいけません。

          例えば `(idm)' と `nagnagnag' という識別子を取り除きたいのな
          ら:

               (setq nnmail-list-identifiers
                     '("(idm)" "nagnagnag"))

          これは `gnus-list-identifiers' で非破壊的に行なうこともできます。
          *Note Article Hiding::.

     `nnmail-remove-tabs'
          すべての `TAB' 文字を `SPACE' 文字に変換します。

     `nnmail-ignore-broken-references'
          いくつかの MUA (例えば Eudora と Pegasus) は壊れた `References' ヘッ
          ダーを作成しますが、`In-Reply-To' ヘッダーにはちゃんとしたものを入
          れます。この関数は、ヘッダー部に正規表
          現 `nnmail-broken-references-mailers' に合致する行があったら、
          `References' ヘッダーを取り除きます。

`nnmail-prepare-incoming-message-hook'
     このフックはそれぞれのメッセージに範囲を狭められて呼ばれます (訳注:
     一度に複数のメールを受信した場合でも、一通ずつ呼ばれるということで
     す)。使うことのできる関数は:

     `article-de-quoted-unreadable'
          Quoted Readable エンコードをデコードします (訳注: 実際に行な
          うのは quoted printable のデコードです)。



File: gnus-ja.info, Node: Duplicates, Next: Not Reading Mail, Prev: Washing Mail, Up: Getting Mail

重複
----

いくつかのメーリングリストのメンバーなら、時々同じメールを二つ受け取る
ことがあるでしょう。これはとても煩わしいので、`nnmail' はそれが見つけた
どんな重複をも、調べて処理します。これをするために、`nnmail' は古い
`Message-ID' を `nnmail-messagge-id-cache-file' (ディフォルトでは
`~/.nnmail-cache') に保存します。それに保存される `Message-ID' のおおよ
その最大数は変数 `nnmail-message-id-cache-length' で制御され、ディフォ
ルトは 1000 です。(ですから千個の `Message-ID' が溜められます。) これで
怖気をふるったなら、`nnmail-treat-duplicates' を `warn' (ディフォルトで
はそのようになっていますが) に設定しても良いでしょう。そうすると、
`nnmail' は重複したメールを消去しない代わりに、それが別のメッセージの重
複であるという警告をメールのヘッダーに挿入します。

この変数は関数であることもできます。その場合、関数は当のメッセージに範
囲を狭められたバッファーから `Message-ID' を引数として呼ばれます。この
関数は `nil', `warn', `delete' のどれかを返さなければなりません。

変数を `nil' に設定することによって、この機能を完全に使わないようにする
ことができます。

もしすべての重複したメールを特別な "duplicates" グループに入れたいので
あれば、普通のメール分割方法を使ってそれをすることができます:

     (setq nnmail-split-fancy
           '(| ;; 重複したメッセージは分かれたグループへ。
             ("gnus-warning" "duplicat\\(e\\|ion\\) of message" "duplicate")
             ;; デーモンやポストマスターなどからのメッセージは他へ。
             (any mail "mail.misc")
             ;; 他の規則。
             [ ... ] ))

もしくは次のようなもの:

     (setq nnmail-split-methods
           '(("duplicates" "^Gnus-Warning:.*duplicate")
             ;; 他の規則。
             [...]))

すてきな使い方があるよ: 受け手である彼女がメールを Gnus で読んでいるこ
とと、彼女が `nnmail-treat-duplicates' を `delete' に設定してあることを
知っていれば、彼女がすでに受け取ったことがわかっているメールの
`Message-ID' そのものを使って、考えられる限りたくさんの侮辱を送ることが
できるんだぜ。その面白さを考えてみてよ! 彼女はそれらを決して見ることは
ないんだ! わぉ!



File: gnus-ja.info, Node: Not Reading Mail, Next: Choosing a Mail Back End, Prev: Duplicates, Up: Getting Mail

メールを読むのではない
----------------------

あなたが使い始めたどんなメールバックエンドでも、あなたがそれらでメール
を読みたいと思っていると仮定するという、悩ましい癖を持っていることに気
が付くでしょう。これは決して不合理ではないかもしれませんが、あなたの望
むことではないかもしれません。

`mail-sources' と `nnmail-spool-file' を `nil' に設定すれば、どのバック
エンドも入ってくるメールを読もうとしなくなって、それは助けになるはずで
す。

でも、それは行き過ぎでしょう。あなたが、例えば `nnml' でメールを読
むことと、しまいこんである古い (Emacs 23 より前の) Rmail ファイル
を `nnbabyl' を使ってざっと覗くことだけで、まったく満足していている
のならば。すべてのバックエンドには  バックエンド-`get-new-mail' と
いう変数があります。もし `nnbabyl' がメールを読み込みをやめさせたい
のであれば、そのグループの仮想サーバー編集して、
`nnbabyl-get-new-mail' を `nil' に設定しましょう。

すべてのメールバックエンドは、入ってくるメールを読み込むときに、保存さ
れるべき記事に範囲を狭めて `nn'*`-prepare-save-mail-hook' を呼びます。



File: gnus-ja.info, Node: Choosing a Mail Back End, Prev: Not Reading Mail, Up: Getting Mail

メールバックエンドを選ぶ
------------------------

メールグループを動作するようにすると Gnus はメールスプールを読み込みま
す。メールのファイルはまずあなたのホームディレクトリーに複写されます。
その後で何が起こるかは、メールをどの様式で格納したいかによります。

標準の Gnus では六つの違ったメールバックエンドがあり、さらに多くのバッ
クエンドを個別に手に入れることができます。ほとんどの人が使うメールバッ
クエンドは (それがたぶん最速なので) `nnml' です (*Note Mail Spool::)。

* Menu:

* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Babyl::                       Rmail の旧バージョンは Babyl を使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察



File: gnus-ja.info, Node: Unix Mail Box, Next: Babyl, Prev: Choosing a Mail Back End, Up: Choosing a Mail Back End

Unix メールボックス
...................

"nnmbox" バックエンドはメールを格納するために標準の Un*x mbox ファイル
を用います。`nnmbox' はそれぞれのメール記事にそれがどのグループに属して
いるかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

`nnmbox-mbox-file'
     利用者のホームディレクトリーのメールボックスの名前。ディフォルトは
     `~/mbox' です。

`nnmbox-activate-file'
     メールボックスのアクティブファイルの名前。ディフォルトは
     `~/.mbox-active' です。

`nnmbox-get-new-mail'
     `nil' でなければ、`nnmbox' は入って来たメールを読み込んでグループ
     に分割します。ディフォルトは `t' です。



File: gnus-ja.info, Node: Babyl, Next: Mail Spool, Prev: Unix Mail Box, Up: Choosing a Mail Back End

Babyl
.....

"nnbabyl" バックエンドはメールを格納するために Babyl メールボックスを使
います。`nnbabyl' はそれぞれの記事にそれがどのグループに属しているかを
示す追加のヘッダーを加えます。

仮想サーバーの設定:

`nnbabyl-mbox-file'
     Babyl ファイルの名前。ディフォルトは `~/RMAIL' です。

`nnbabyl-active-file'
     Babyl ファイルのためのアクティブファイルの名前。ディフォルトは
     `~/.rmail-active' です。

`nnbabyl-get-new-mail'
     `nil' でなければ、`nnbabyl' は入ってくるメールを読み込みます。ディ
     フォルトは `t' です。



File: gnus-ja.info, Node: Mail Spool, Next: MH Spool, Prev: Babyl, Up: Choosing a Mail Back End

メールスプール
..............

"nnml" スプールメール様式は他の知られている様式とは互換性がありません。
それは少し注意して使われるべきです。

このバックエンドを使うと、Gnus は入ってくるメールを、それぞれのメールを
1 ファイルとしてファイルに分割し、記事を変数 `nnml-directory' で指定さ
れたディレクトリーの下の対応するディレクトリーに入れます。ディフォルト
の値は `~/Mail/' です。

前もってディレクトリーを作っておく必要はありません。その面倒は Gnus が
すべて見てくれます。

あなたのアカウントに保存できるファイルの数に厳密な制限があるなら、この
バックエンドを使うべきではありません。それぞれのメールはそれ自身のファ
イルを伴うので、数週間で数千の iノードを占有する可能性は十分にあります。
あなたにとってこれが問題でなく、親切なシステム管理者が気が狂ったように
「誰が僕の i ノードを食いつぶしているんだ? 誰だ? 誰!?!」と叫びながら歩
き回ることも問題でないなら、これがおそらく使うことのできる一番速い様式
であるということは知っておくべきでしょう。新しいメールを読むためだけに
大きな mbox ファイルを重い足取りで探す必要はありません。

`nnml' は記事分割に関してはおそらく一番遅いバックエンドでしょう。多くの
ファイルを作らなければならず、入ってくるメールのための NOV データベース
も作成しなければなりません。これのために、メールを読むことに関してはた
ぶん最速のバックエンドになるのです。

印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
`nnml' サーバーは `tar' などを使ってバックアップしたり、後であなたが付
けた印がすべて保たれた状態で Gnus に戻す (本来の `nnml' サーバーによっ
て追加する) ことができる特質を持つようになります。グループの印はそれぞ
れの `nnml' グループのディレクトリー内の、通常 `.marks' ファイル
(`nnml-marks-file-name' を参照) に格納されます。また、個々の `nnml' グ
ループについてもバックアップすることが可能で、そうするには (バックアッ
プを nnml ディレクトリーに戻した後で) `G m' キーを使ってそのグループを
元に戻してください。

何らかの理由によって `.marks' ファイルがおかしくなっていると思ったとき
は、単にそれら全部を消してしまえば良いでしょう。Gnus は次回起動するとき
に、それらを正しく再作成してくれます。

仮想サーバーの設定:

`nnml-directory'
     すべての `nnml' ディレクトリーはこのディレクトリーの下に置かれます。
     ディフォルトは `message-directory' の値 (そのディフォルト値は
     `~/Mail') です。

`nnml-active-file'
     `nnml' サーバーのためのアクティブファイル。ディフォルトは
     `~/Mail/active' です。

`nnml-newsgroups-file'
     `nnml' グループ記述ファイル。*Note Newsgroups File Format::. ディ
     フォルトは `~/Mail/newsgroups' です。

`nnml-get-new-mail'
     `nil' でなければ、`nnml' は入って来たメール読み込みます。ディフォ
     ルトは `t' です。

`nnml-nov-is-evil'
     `nil' でなければ、このバックエンドはどの NOV ファイルも無視します。
     ディフォルトは `nil' です。

`nnml-nov-file-name'
     NOV ファイルの名前。ディフォルトは `.overview' です。

`nnml-prepare-save-mail-hook'
     保存する前に一つの記事に範囲を狭めて実行するフックです。

`nnml-marks-is-evil'
     非-`nil' であると、このバックエンドはいかなる 印 ファイルも無視し
     ます。ディフォルトは `nil' です。

`nnml-marks-file-name'
     「印」ファイルの名前です。ディフォルトは `.marks' です。

`nnml-use-compressed-files'
     非-`nil' だったら、`nnml' は圧縮されたメッセージファイルを扱うこと
     ができるようになります。ただし `auto-compression-mode' が有効になっ
     ていなければなりません (*Note Compressed Files: (emacs)Compressed
     Files.)。`nnml-use-compressed-files' の値が文字列だった場合、それ
     は圧縮プログラムを指定するファイル拡張子として使われます。Emacs が
     それをサポートしていれば、それを `.bz2' に設定することができます。
     値 `t' は `.gz' と等価です。

`nnml-compressed-files-size-threshold'
     メッセージファイルを圧縮するかどうかを判断するための、サイズの閾値
     です。`nnml-use-compressed-files' が非-`nil' に設定されていて、本
     文の文字数がこの変数の値より大きかったら、メッセージファイルは圧縮
     されます。

`nnml' グループと NOV ファイルの調子が完全に狂ってしまったら、`M-x
nnml-generate-nov-databases' とタイプすることによって、完全に更新するこ
とができます。この命令は、それぞれすべてのファイルを見ることによって
`nnml' 階層全体をトロール魚網でさらうので、それが終わるまでには時間がか
かるかもしれません。この機能へのより良いインターフェースはサーバーバッ
ファーで見つかるでしょう (*Note Server Commands::)。

訳注: 単一の `nnml' グループの NOV データベースを再生成させるための
`nnml-generate-nov-databases-1' という命令もあります。



File: gnus-ja.info, Node: MH Spool, Next: Maildir, Prev: Mail Spool, Up: Choosing a Mail Back End

MH スプール
...........

`nnmh' は、NOV データベースを作らないこととアクティブファイルや印ファイ
ルを保持しないことを除いて、`nnml' と似ています。このことは `nnmh' を
`nnml' より *かなり* 遅いバックエンドにしていますが、procmail のスクリ
プトを書くことはずっとやりやすくなってもいます。

仮想サーバーの設定:

`nnmh-directory'
     すべての `nnmh' ディレクトリーはこのディレクトリーの下に置かれます。
     ディフォルトは `message-directory' の値 (そのディフォルトは
     `~/Mail') です。

`nnmh-get-new-mail'
     `nil' でなければ、`nnmh' は入ってくるメールを読み込みます。ディフォ
     ルトは `t' です。

`nnmh-be-safe'
     `nil' でなければ、`nnmh' はフォルダーにある記事が実際に Gnus が考
     えているものと同じであるかを調べるという馬鹿げたことをやります。そ
     れは日付と目に入るすべての情報を調べるので、これを `t' に設定する
     と深刻な速度低下が起こります。`nnmh' の記事を読むのに Gnus 以外の
     ものを使っていないのであれば、この変数を `t' に設定する必要はあり
     ません。ディフォルトは `nil' です。



File: gnus-ja.info, Node: Maildir, Next: Mail Folders, Prev: MH Spool, Up: Choosing a Mail Back End

Maildir
.......

`nnmaildir' は各々の Gnus のグループに対応する maildir に、maildir フォー
マットでメールを格納します。このフォーマットは
`http://cr.yp.to/proto/maildir.html' および
`http://www.qmail.org/man/man5/maildir.html' で文書化されています。また
`nnmaildir' は maildir の中の `.nnmaildir/' ディレクトリーに追加の情報
を格納します。

Maildir フォーマットは、配送と講読を、ロックを必要とせずに同時に行なう
ことができるようにするために設計されました。他のバックエンドでは、メー
ルを何らかのスプールに渡した後で、そのスプールからグループに分割するた
めに、Gnus を設定しなければならないでしょう。それは今まで通り
`nnmaildir' で行なうことができますが、もっと普通のやり方は、Gnus のグルー
プとして現われる maildir に配送されたメールを、直接手にすることです。

`nnmaildir' は完全に信頼できることを目指しています: `C-g' はメモリー中
のデータを壊さないし、`SIGKILL' がファイルの中のデータを壊すことはあり
ません。

`nnmaildir' は記事の印と NOV データを、それぞれの maildir に格納します。
それによって、ある Gnus の環境から別の場所に maildir 全体をコピーするこ
とができ、印は保持されます。

仮想サーバーの設定:

`directory'
     それぞれの `nnmaildir' サーバー (一つを越えるサーバーが必要だとは
     とても思えませんが) に対してディレクトリーを作り、それを maildir
     または maildir へのシンボリックリンクとして実装する必要があります
     (maildir のためだけにです。他の目的のためにすでに使われているディ
     レクトリーを選んではいけません)。それぞれの maildir は、そのサーバー
     のニュースグループとして Gnus に現れ、シンボリックリンクのファイル
     名がそのグループの名前になります。ディレクトリーにある `.' で始ま
     るどんなファイル名も無視されます。ディレクトリーは最初に Gnus を起
     動したときとグループバッファーで `g' をタイプしたときはいつでも走
     査され、どれかの maildir が削除または追加されていると、
     `nnmaildir' はそのときにそれを知ります。

     `directory' パラメーターの値は Lisp 式でなければなりません。それは
     このサーバーのためのディレクトリーのパスを得るために `eval' と
     `expand-file-name' で処理されます。その式はサーバーが開かれたとき
     だけ `eval' され、その結果得られた文字列が、サーバーが閉じられるま
     で使われます (もし、式や `eval' を知らなくでも心配ご無用; 単なる文
     字列で動作します)。このパラメーターは任意ではなく、必ず設定しなけ
     ればなりません。`"~/Mail"' やそれのサブディレクトリーを使うことは
     推奨しません。なぜかと言うと、Gnus の他の複数の部分がそれをディフォ
     ルトでいろんなものに使うので、`nnmaildir' でもそれを使うと混乱する
     かもしれないからです。`"~/.nnmaildir"' が一般的な値です。

`target-prefix'
     これは Lisp 式でなければなりません。それは `eval' と
     `expand-file-name' で処理されます。その式が `eval' されるのはサー
     バーが開かれたときだけで、その結果得られた文字列がサーバーが閉じら
     れるまで使われます。

     `nnmaildir' サーバーにグループを作ると、その名前の頭に
     `target-prefix' が付加された maildir と、その maildir を指し示すシ
     ンボリックリンクが素のグループ名の名前で作成されます。したがって、
     `directory' が `"~/.nnmaildir"' で、`target-prefix' が
     `"../maildirs/"' だった場合に `foo' というグループを作ると、
     `nnmaildir' は maildir として `~/.nnmaildir/../maildirs/foo' を、
     `../maildirs/foo' へのシンボリックリンクとして `~/.nnmaildir/foo'
     を作成します。

     同じ `directory' に maildirs とシンボリックリンクの両方を作成する
     ために、スラッシュを含まない文字列を `target-prefix' に設定するこ
     とができます。この場合は、`directory' で見つかる名前が
     `target-prefix' で始まるどの maildir も、グループとは見なされませ
     ん (が、それらを指し示すシンボリックリンクがグループになります)。

     特別な場合として `target-prefix' が `""' (それがディフォルトです)
     だったら、グループを作るときに、対応するシンボリックリンクを持たな
     い maildir が `directory' において作成されます。そのようなグループ
     に対しては、`force' 引数を与えないと `gnus-group-delete-group' が
     使えないことに気をつけてください。

`directory-files'
     これは `directory-files' と同じインターフェースを持っている関数
     (または `directory-files' そのもの) でなければなりません。これは
     maildir 用のサーバーの `directory' を走査するために使われます。こ
     のパラメーターは任意です。ディフォルトは、
     `nnheader-directory-files-is-safe' が `nil' だったら
     `nnheader-directory-files-safe' で、それ以外の場合は
     `directory-files' です (`nnheader-directory-files-is-safe' はサー
     バーが開いたときに一回だけ検査されますが、ディレクトリーが走査され
     るときに毎回チェックさせたいのならば、それを行なう関数をあなたが自
     前で用意する必要があります)。

`get-new-mail'
     非-`nil' にしておくと、いつもの通りにグループの maildir 自体におい
     て新着メールを走査した後で、このサーバーはさらに `mail-sources' か
     ら、`nnmail-split-methods' か `nnmail-split-fancy' の設定に従って、
     従来の Gnus の方法でメールを取り込みます。ディフォルト値は `nil'
     です。

     `mail-sources' と `nnmaildir' グループの両方で同じ maildir を使っ
     ては *いけません*。その結果は運良く有益になるかもしれませんが、そ
     んな意図では設計されていませんし、将来は違う結果をもたらす可能性が
     あります。あなたの分割規則が新しいグループを作るようになっている場
     合は、`create-directory' サーバーパラメーターを設定することを忘れ
     ないでください。


グループパラメーター
....................

`nnmaildir' は複数のグループパラメーターを使います。これらのすべてを無
視しても安全です。ディフォルトの `nnmaildir' の動作は、他のメールバック
エンドのディフォルト (記事が一週間後に消去される、など) と同じです。期
限切れ消去のパラメーターを除いて、この機能はすべて `nnmaildir' だけにあ
るものです。したがって、別のバックエンドですでに行なっている動作を単に
踏襲させようというのであれば、これを無視することができます。

これらのパラメーターのうちのどれでも、その値がベクトルである場合は、オ
リジナルの値に代わって、第一の要素が Lisp 式として評価された結果が使わ
れます。値がベクトルでない場合は、その値そのものが Lisp 式として評価さ
れます。(それが、これらのパラメーターが他とは違う名前、すなわち他のバッ
クエンドでサポートされているものとは違うけれども似た意味を持っている同
様のパラメーターを使っている理由です。) (数値、文字列、`nil'、および
`t' についても `eval' の関与を無視することができます。他の値について、
そうすることがふさわしい場合には、追加のクオートを使い、かつベクトルで
値を包むことを忘れないでください。)

`expire-age'
     記事が消去されるまでの寿命の秒数を指定する整数、あるいは記事が期限
     切れ消去されてはならないことを指定する `never' というシンボルです。
     このパラメーターが設定されていないと、いつもの
     `nnmail-expiry-wait' 変数または `nnmail-expiry-wait-function' 変数
     を最後のよりどころにします (`expiry-wait' グループパラメーターが設
     定されていると、その値が `nnmail-expiry-wait' より優先して使われ、
     `nnmail-expiry-wait-function' は無効にされます)。3日の値が必要なら
     ば、`[(* 3 24 60 60)]' のようなものを使ってください。`nnmaildir'
     は式を評価して、その結果を使います。記事の寿命は記事ファイルの変更
     時刻を基点に計測されます。通常これは記事が配送された時刻と同じです
     が、記事の編集はそれを若くします。(期限切れ消去以外の) 記事の移動
     もまた、記事を若くしてしまうでしょう。

`expire-group'
     これが以下のような完全な Gnus のグループ名の文字列で、

          "backend+server.address.string:group.name"

     かつこのパラメーターが設定されているグループの名前と同じではなかっ
     たら、期限切れ消去が行なわれる際に、記事は消去される代わりに、これ
     で指定されたグループに移動させられます。*これが `nnmaildir' グルー
     プに設定されていると、移動先のグループにおいて、記事は元のグループ
     にあったときとちょうど同じ古さになります。* したがって、移動先のグ
     ループにおける `expire-age' には注意してください。これがパラメーター
     が設定されているのと同じグループの名前に設定されると、記事はまった
     く期限切れ消去されません。ベクトルの式を使うと、最初の要素が一回、
     それぞれの記事について評価されます。したがって記事をどこに置くかを
     決めるために、その式は `nnmaildir-article-file-name' などに照会す
     ることができます。*たとえこのパラメーターが設定されていなくても、
     `nnmaildir' は `expiry-target' グループパラメーターや
     `nnmail-expiry-target' 変数を顧みません。*

`read-only'
     これが `t' に設定されていると、`nnmaildir' はその記事をこの
     maildir では読み出し専用として扱います。この意味は、記事は `new/'
     から `cur/' に改名されない、記事は `cur/' ではなく `new/' でのみ見
     つかる、記事は消去されない、記事は編集できない、ということです。
     `new/' は他の maildir の `new/' ディレクトリーへのシンボリックリン
     クであると想定されます (そのディレクトリーには、例えばみんなが興味
     があるメーリングリストを含んでいる、システムで共通のメールボックス
     があります)。`new/' 以外の maildir にあるすべてのものは、読み出し
     専用として扱われ *ません*。したがって、みんなで共有するメールボッ
     クスに対しては、あなた自身の maildir を設置する (または 共有のメー
     ルボックスに書き込み権限を持つ) 必要が依然としてあります。そうすれ
     ば、あなたの maildir は記事の余分なコピーをまったく含まなくて済む
     でしょう。

`directory-files'
     `directory-files' と同じインターフェースの関数です。記事を見つける
     ために、このグループに対応する maildir のディレクトリーを走査する
     ために使われます。ディフォルトはそのサーバーの `directory-files'
     パラメーターで設定されている関数です。

`distrust-Lines:'
     非-`nil' にしておくと、`nnmaildir' は `Lines:' ヘッダーフィールド
     を使う代わりにいつも記事の行数を数えます。`nil' だった場合は、あれ
     ばそのヘッダーフィールドが使われます。

`always-marks'
     `['(read expire)]' のような印シンボルのリストです。Gnus が記事の印
     を `nnmaildir' に尋ねるときはいつでも、ファイルシステムに格納され
     ている印が何であるかとは無関係に、`nnmaildir' はすべての記事がこれ
     らの印を持っていると答えます。これは機能を検証するためのもので、お
     そらく結局は削除されるでしょう。それは Gnus 本体で行なわれるか、あ
     るいは有益でなければ放棄されるべきです。

`never-marks'
     `['(tick expire)]' のような印シンボルのリストです。Gnus が記事の印
     を `nnmaildir' に尋ねるときはいつでも、ファイルシステムに格納され
     ている印が何であるかとは無関係に、`nnmaildir' はこれらの印を持って
     いる記事は無いと答えます。`never-marks' は `always-marks' よりも優
     先されます。これは機能を検証するためのもので、おそらく結局は削除さ
     れるでしょう。それは Gnus 本体で行なわれるか、あるいは有益でなけれ
     ば放棄されるべきです。

`nov-cache-size'
     NOV メモリーキャッシュのサイズを指定する整数です。スピードアップの
     ために、`nnmaildir' はそれぞれのグループの限定された数の記事に対し
     て、メモリー上に NOV データを保持します。(これはたぶん有用ではなく、
     将来はおそらく削除されるでしょう)。このパラメーターの値は、サーバー
     が開かれた後で最初にグループが見られたとき、すなわち一般には最初に
     Gnus を起動したときだけ注目されます。サーバーが閉じられて再び開か
     れるまでは、NOV キャッシュのサイズは変更されません。ディフォルトは
     概略バッファーに表示される記事の数の見積り (`tick' 印がある記事の
     数か `read' が無い記事の数に、少々の余分を加えたもの) です。


記事の識別
..........
記事はそれぞれの maildir の `cur/' ディレクトリーに格納されます。各々の
記事には `uniq:info' のような名前が付けられます。ここで `uniq' はコロン
を含みません。`nnmaildir' は `:info' の部分を保持しますが無視します。
(他の maildir リーダーは一般に印を格納するためにこの部分を使います。)
`uniq' の部分は記事をユニークに識別し、maildir の `.nnmaildir/' サブディ
レクトリーの色々な場所に、対応する記事の情報を格納するために使われます。
記事の完全なパス名は、概略バッファーで記事を要求した後で
`nnmaildir-article-file-name' 変数から得られます。


NOV データ
..........
`uniq' によって識別される記事は、その NOV データ (概略バッファーの行を
生成するために使われる) を `.nnmaildir/nov/uniq' に格納します。
`nnmaildir-generate-nov-databases' 関数はありません。(その必要はあまり
ありません。記事の NOV データは記事か `nnmail-extra-headers' が変化した
ときに自動的に更新されます。) 対応する NOV ファイルを消すことによって、
単一の記事だけの NOV データの生成を `nnmaildir' に強制することはできま
す。しかし *ご用心*。これは `nnmaildir' にこの記事に新しい記事番号を割
り振らせるので、`seen' 印、エージェント、およびキャッシュにとって面倒な
ことになります。


記事の印
........
`.nnmaildir/marks/flag/uniq' ファイルがある場合に、`uniq' によって識別
される記事は、`flag' 印を持つものと考えられます。Gnus が `nnmaildir' に
グループの印を尋ねると、`nnmaildir' はそのようなファイルを探して、見つ
けた印のセットを報告します。Gnus が `nnmaildir' に印のセットを格納する
ことを要求すると、`nnmaildir' は必要に応じて対応するファイルを生成し、
または消去します。(実際は、それぞれの印のために新しいファイルを作るので
はなく、iノードを節約するために単に `.nnmaildir/markfile' へのハードリ
ンクを張ります。)

`.nnmaildir/marks/' に新しいディレクトリーを作ることによって、新しい印
を創造することができます。印を保持しつつ maildir を tar でまとめてサー
バーからそれを削除し、後で tar をほどくと、印は保持されています。印ファ
イルを作成または消去することによって、あなた自身が印を追加または削除す
ることができます。Gnus が動作していて `nnmaildir' サーバーが開いている
ときにこれを行なう場合は、最初にすべての `nnmaildir' グループの概略バッ
ファーから退出してグループバッファーで `s' をタイプし、その後グループバッ
ファーで `g' か `M-g' をタイプするのが最良です。そうしないと Gnus は変
更を捉えてくれずに、それらを元に戻してしまうかもしれません。



File: gnus-ja.info, Node: Mail Folders, Next: Comparing Mail Back Ends, Prev: Maildir, Up: Choosing a Mail Back End

メールフォルダー
................

`nnfolder' はそれぞれのメールグループを別々ファイルに格納するバックエン
ドです。それぞれのファイルは標準の Un*x mbox 様式です。`nnfolder' は記
事番号と到着時刻を見失わないようにするための追加のヘッダーを加えます。

印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
`nnfolder' サーバーは `tar' などを使ってバックアップしたり、後であなた
が付けた印がすべて保たれた状態で Gnus に戻す (本来の `nnfolder' サーバー
によって追加する) ことができる特質を持つようになります。グループの印は
`nnfolder' ディレクトリー内の、mbox ファイルに通常 `.mrk'
(`nnfolder-marks-file-name' を参照) が付加された名前のファイルに格納さ
れます。また、個々の `nnfolder' グループについてもバックアップすること
が可能で、(バックアップを nnfolder ディレクトリーに戻した後で) `G m' キー
を使えば、そのグループは元に戻ります。

仮想サーバーの設定:

`nnfolder-directory'
     すべての `nnfolder' メールボックスはこのディレクトリーの下に置かれ
     ます。ディフォルトは `message-directory' の値 (そのディフォルトは
     `~/Mail') です。

`nnfolder-active-file'
     アクティブファイルの名前。ディフォルトは `~/Mail/active' です。

`nnfolder-newgroups-file'
     グループ記述ファイルの名前。*Note Newsgroups File Format::. ディフォ
     ルトは `~/Mail/newsgroups"' です。

`nnfolder-get-new-mail'
     `nil' でなければ、`nnfolder' は入ってくるメールを読み込みます。ディ
     フォルトは `t' です。

`nnfolder-save-buffer-hook'
     フォルダーを保存する前に実行されるフックです。`nnfolder' バッファー
     に対してさえも、Emacs は通常とおりファイル名を変更してバックアップを行な
     うことに注意してください。この機能を無効にしたいのであれば、
     `~/.gnus.el' ファイルで次のようなことをすれば良いでしょう:

          (defun turn-off-backup ()
            (set (make-local-variable 'backup-inhibited) t))

          (add-hook 'nnfolder-save-buffer-hook 'turn-off-backup)

`nnfolder-delete-mail-hook'
     これから消去されるメッセージに範囲を狭められて実行されるフックです。
     この関数は別の場所にメッセージをコピーしたり、消去する前に何らかの
     情報を取り出すために使うことができます。

`nnfolder-nov-is-evil'
     もし非-`nil' なら、このバックエンドはどんな NOV ファイルをも無視し
     ます。ディフォルトは `nil' です。

`nnfolder-nov-file-suffix'
     NOV ファイルの拡張子です。ディフォルトは `.nov' です。

`nnfolder-nov-directory'
     NOV ファイルが格納されるディレクトリーです。`nil' だったら
     `nnfolder-directory' が使われます。

`nnfolder-marks-is-evil'
     非-`nil' であると、このバックエンドはいかなる 印 ファイルをも無視
     します。ディフォルトは `nil' です。

`nnfolder-marks-file-suffix'
     印 ファイルの拡張子です。ディフォルトは `.mrk' です。

`nnfolder-marks-directory'
     印 ファイルが格納されるディレクトリーです。`nil' だったら
     `nnfolder-directory' が使われます。

`nnfolder' で読みたいたくさんの `nnfolder' に似たファイルを持っているの
なら、そのようなすべてのファイルが `nnfolder-directory' にあることを
`nnfolder' に気付かせるために、`M-x nnfolder-generate-active-file' 命令
を使ってください。もっとも、これは長いファイル名を使っているときだけ動
作しますが。



File: gnus-ja.info, Node: Comparing Mail Back Ends, Prev: Mail Folders, Up: Choosing a Mail Back End

メールバックエンドの比較
........................

まず用語としての「バックエンド」(back end) は、それによってなにものかが
取得される、低次のアクセス手段、あるいはそう言いたければ輸送手段です。
それが意図するのはどこからかメールを取ってくることなので、Gnus がすぐに
手が届く距離の範囲内でメールを受け取るための、適当なバックエンドを選択
する必要があります。

同じ概念が Usenet 自身にも存在します。近ごろでは記事へのアクセスは一般
的に NNTP で行なわれますが、凄涼たる暗黒の昔には、世界中の誰もが、記事
を置いてあるマシン (今日では NNTP サーバーと呼ぶもの) でリーダーを動作
させることによって Usenet に接続したものでした。また、アクセスは記事の
ディレクトリーのスプールの領域に直接に踏み込むリーダーによって行なわれ
ました。たまたまそういうサーバーにいるのなら (あるいは NFS を介して、と
にかくそれのスプールのディレクトリーを見ることができるのなら)、今でも
`nntp' か `nnspool' バックエンドのどちらかを選ぶことができます。

     (訳注:「凄涼たる暗黒の昔には」はポーの詩「大鴉」の冒頭部分“Once
     upon a midnight dreary”。)

メールバックエンドを選択することの行き着く先は、元の形式を処理し、かつ
将来便利に使える形式でメールを残すことを、同時に実現するのに適した方法
を選び出すことです。それぞれいくつかの良い点と悪い点があります:

`nnmbox'
     歴史的に UNIX システムは、とても一般的で行き届いた定義のたった一つ
     の形式を持っています。すべてのメッセージは単一の「スプールファイル」
     に到着し、それらは正規表現 `^From_' に合致する行で区切られています。
     (`_' という記号はスペースを意味し、この例ではこれが RFC で規定され
     ている `From:' ヘッダーではないことをはっきりさせるために使ってい
     ます。) Emacs それに Gnus も歴史的に Unix 環境から始まっているので、
     元の mailbox 形式をあまりいじくり回さずに済めば、それが最も単純で
     す。したがってこのバックエンドを選んだ場合に、本当のスプールからメー
     ルを取得して Gnus にとって都合が好いディレクトリーにメールを移動す
     るために Gnus が主に行なうのは、処理の過程で何も (目立つような) 変
     更をせずに、単にそれを複製することです。それは Gnus が処理を行なう
     ことができる環境にメールを移動するための「最も気が利かない」方法で
     す。これは移動させることを速くしますが、Gnus がどこに何があるかを
     調べるときは、解析が遅くなります。

`nnbabyl'
     むかしむかしあるところに DEC-10 と DEC-20 がありました。それらは
     TOPS というオペレーティングシステムや似たようなものを実行していて、
     メールを読むための普通の (もしかしたら唯一の?) 環境は Babyl という
     ものでした。そのシステムに届いたメールでどんな形式が使われていたか
     はわかりませんが、Babyl にはメールを変換するための、それ用の内部形
     式がありました。その変換とは、Babyl 特有のヘッダーと状態ビットを、
     ファイルにあるそれぞれのメッセージの先頭に挿入するための仕組みによっ
     て、スプールファイル風の実体を作ることでした。Rmail は Emacs の最
     初のメールリーダーで、Richard Stallman によって書かれました。
     Stallman はその TOPS/Babyl の環境の出身だったので、すでに存在して
     いたメールファイルの一族を理解するように Rmail を書きました。Gnus
     は (この件に関しては VM も) この形式をサポートし続けています。それ
     は、そのメーラー特有のヘッダー/ステータス・ビットというものが、か
     なり良質だと認められているからです。Rmail 自身ももちろんまだ存在し
     ていて、今でも Emacs の中で維持されています。Emacs 23 から、Babyl
     に代わって標準の mbox 様式が使われるようになりました。

     上記の両方の形式は、メールをファイルシステムにおける単一のファイル
     に置いたままにするので、メールを見るたびにファイル全体を解析しなけ
     ればなりません。

`nnml'
     `nnml' は、あたかも `nnspool' でアクセスされる Usenet システムで実
     際に操作しているかのような感じのするバックエンドです。(実際のとこ
     ろ、`nnml' はすごく以前に `nnspool' から枝分かれしたものだと思いま
     す。) メールは元のスプールファイルから取り出された後で、個々のファ
     イルに 1:1 で切り分けられます。Usenet 様式のアクティブファイル
     (INN や CNews に基づいたニュースシステムの `/var/lib/news/active'
     ファイル (例えば) や、`NNTP LIST' 命令で返されるものに類似したもの)
     を維持し、今ではかなりの年数にわたって NNTP サーバーのために定義さ
     れている "overview" ファイルも、グループへ入るときの効率を良くする
     ために作成します。たくさんのファイルを作成し、`nnml' アクティブファ
     イルを更新し、さらにメッセージ毎に overview への追加を行なうので、
     メール分割では遅くなりますが、アクセスするときには、アクティブファ
     イルと overview によって提供される索引機能に支援されて、とてつもな
     く速くなります。

     `nnml' は "inode" を非常にたくさん消費します。すなわち、新しいファ
     イルを置くことができる場所をファイルシステム上に定めるための資源を、
     たくさん占有します。ぎっしりつまった共有ファイルシステムで大量の
     inode を占有することを、システム管理者は快く思いません。もっとも、
     そのファイルシステムが自分自身のもので、容量が希少ではない個人のマ
     シンにいるのならば、`nnml' には非常に大きな利点があるのですが。

     FAT16 の Windows の世界にいる場合にも、たくさんの小さなファイルで
     多くの場所を取られてしまう点で問題があります。

`nnmh'
     Rand MH メール閲覧システムは UNIX システムにかなり長い間存在してい
     ます。それはメッセージのスプールファイルを個々のファイルに分割する
     ことによって動作しますが、索引機能は少ししか、あるいはまったくあり
     ません---`nnmh' は、意味的には「アクティブファイルまたは overview
     の無い `nnml'」と等価です。これはおそらく最悪の選択でしょう。なぜ
     ならば、個々のファイルを作ることの遅さが、何がグループで新しいかを
     知るときに解析するために行なうアクセスの遅さに結び付くからです。

`nnfolder'
     基本的に `nnfolder' が実現することは、グループ毎の `nnmbox' (上で
     説明されている最初の方法) です。すなわち `nnmbox' 自体は *すべて*
     のメールを一つのファイルに入れます。でも `nnfolder' はメールグルー
     プのそれぞれが Unix mail box ファイルを持つように、ほんの少し最適
     化をします。それぞれのグループは別々に解析されるので `nnmobx' より
     も速く、しかもなお、メールを移動させるのに最小限の労力しか要求しな
     い、単純な Unix mail box 形式を提供します。加えて「アクティブ」ファ
     イルを維持し、Gnus がそれぞれの別のグループにどのくらいのメッセー
     ジがあるかを調べることをとても速くします。

     もしたくさんの量のメッセージを受け取ることが予想されるグループがあ
     るなら、`nnfolder' は最善の選択ではありませんが、ほどほどの量のメー
     ルしか受け取らないなら、おそらく `nnfolder' はすべての中で最も都合
     の良いバックエンドでしょう。

`nnmaildir'
     期限切れ消去その他もろもろを設定するのに、`nnmaildir' は他のメール
     バックエンドとは少々異なった、互換性の無いグループパラメーターを使
     います。

     `nnmaildir' は大方 `nnml' と似たものですが、いくらか顕著な違いがあ
     ります。それぞれのメッセージは別々のファイルに格納されますが、ファ
     イル名は Gnus の記事番号と関係がありません。また `nnmaildir' は
     `nnml' の overview に相当するファイルを記事ごとに一つ格納するので、
     `nnml' の約二倍の量の iノードを使います。(`df -i' を使って iノード
     の割り当てがどれほどたくさんあるかを調べてください。) そのために遅
     くなったり多くの場所を取ってしまうようならば、ReiserFS
     (http://www.namesys.com/) や他の非ブロック構造のファイルシステムへ
     の転換を検討してください。

     maildir は受信配送のためのロックを必要としないので、あなたがグルー
     プとして使っている maildir は、配送されてきたメールを直接受け取る
     ための maildir にすることもできます。これは、メールが配送されてく
     る過程で異なるメールボックスに仕分されるようになっているのならば、
     Gnus のメール分割を省略できることを意味します。`mail-sources' にお
     ける `directory' の項には (訳注: maildir を使わなくても) 似た効果
     がありますが、配送されてくるメールをスプールするためのメールボック
     スの一揃い (mbox 形式ではそのためにメッセージの本文が壊れる) と、
     他の (何であれあなたの好みの形式の) グループとして使われる組が必要
     です。一方 maildir は、`new/' サブディレクトリーに置かれる組み込み
     スプールを持ちます。メール分割による代わりに `new/' から `cur/' に
     移動されたメールは、ダブっているかどうかをチェックするような処理を
     今のところは受けないことに注意してください。

     `nnmaildir' はグループの記事の印を、それに対応する maildir に格納し
     ます。Gnus の外からそれらを簡単に操作できるようにするために、そのように
     作られているのです。maildir を tar でまとめてから別のどこかで展開しても、
     印はそのままです。`nnml' も印を格納しますが、
     `nnmaildir' で Gnus の外からそれらを使うように簡単ではありません。

     `nnmaildir' は速度を上げるためにかなりの量のメモリを使います。
     (`nnml' の場合はファイルに格納し、`nnmh' では何度もメッセージファ
     イルを解析して得るものごとを、それはメモリ上に保持します。) これが
     あなたにとって問題ならば、`nov-cache-size' グループパラメーターを
     何か小さな値 (0 はおそらくだめですが 1 だったらたぶん働きます) に
     設定することによって、少ないメモリで済むようにすることができます。
     このキャッシュ機構は、おそらく将来は削除されるでしょう。

     起動は他のバックエンドよりも `nnmaildir' の方が遅いでしょう。ファ
     イルシステムに依存していないすべての部分では速いでしょう。

     `nnmaildir' は `nnoo' を使わないので、`nnmaildir' から派生したバッ
     クエンドを書くのに `nnoo' は使えません。



File: gnus-ja.info, Node: Browsing the Web, Next: IMAP, Prev: Getting Mail, Up: Select Methods

Browsing the Web
================

ウェブに基づいた議論の場はどんどん広まっています。多くの分野で、ウェブ
の掲示板は最も重要な場になり、メーリングリストやニュースグループの重要
性を翳らせています。理由は簡単です--新しい利用者が使い易いからです。た
だ場所をクリックするだけで、議論の場があります。メーリングリストでは、
面倒な購読手続きをしなければならず、ほとんどの人はニュースグループとい
うものがが何であるかすら知りません。

この筋書きから浮かび上がる問題は、ウェブブラウザーはニュースリーダーと
してはあまり良くないということです。どんな記事を読んだかを記録しません。
興味のある表題にスコアを付けることができません。オフラインで読むことが
できません。何度もクリックすることを要求し、最後にはあなたを怒らせます。

ならば--ウェブブラウザーが掲示板を読むのに適していないのなら、代わりに
Gnus を使いませんか?

Gnus はこれらのソースへのインターフェースを提供するバックエンド群を少し
備えつつあります。

* Menu:

* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* RSS::                         RDF Site Summary を読む
* Customizing W3::              Gnus から Emacs/W3 を操作する

すべてのウェブソースは、動作させるために Emacs/W3 と url ライブラリー、
またはそれらの代替が必要です。

これらのウェブソースの一番の問題は、長期間は動作しない可能性が高いこと
です。HTML のデータから情報を拾い集めるのはせいぜい推測で、その構造が変
化したときには、Gnus バックエンドは動作しません。でも、ある程度新しいバー
ジョンのバックエンドを使っていれば大丈夫のはずです。

これらのウェブの手段に共通することは、ウェブソースはしばしば落ちていた
り、使用可能でなかったり、はっきり言って楽しむには遅すぎる、ということ
です。そういう場合に、Gnus Agent (*Note Gnus Unplugged::) に記事のダウ
ンロードを任せて、ローカルディスクから好きなときに読むようにすることは、
大いに意義があります。これで World Wide Wait とはおさらばです。



File: gnus-ja.info, Node: Archiving Mail, Next: Web Searches, Prev: Browsing the Web, Up: Browsing the Web

メールの保存
------------

いくつかのバックエンド、特に `nnml', `nnfolder' および `nnmaildir' は、
今ではそれぞれのグループの記事の印を本当に保持するようになりました (訳
注: そうなったのはだいぶ前ですが)。これらのサーバーで、グループの印を保
ちつつ保存したり元に戻すのはかなり簡単です。

(でも、グループレベルとグループパラメーターをも保持するには、今までとお
り `.newsrc.eld' の神に、舞いと生贄を捧げなければなりませんが。)

`nnml', `nnfolder' または `nnmaildir' サーバーにまるごと保存するには、
サーバーのディレクトリーを再帰的にコピーしてください。Gnus を終了する必
要は無いので、保存は `cron' やそれに類するものが行なうことができます。
データを復帰させるにはディレクトリー木 (tree) を元に戻すことによって行
ない、そのディレクトリーを指し示すように Gnus のサーバーの定義に追加し
ましょう。*Note Article Backlog::, *Note Asynchronous Fetching:: および
その他のものはデータを上書きして邪魔をするかもしれないので、データを復
帰させる前に Gnus を終了する必要があるかもしれません。

さらに、個々の `nnml', `nnfolder' または `nnmaildir' のグループを、印を
保持しつつ保存することもできます。`nnml' または `nnmaildir' では、その
グループのディレクトリーにあるすべてのファイルをコピーしてください。
`nnfolder' では、基本のフォルダーファイルそのもの (例えば `FOO') と印ファ
イル (`FOO.mrk') の両方をコピーする必要があります。グループを元に戻すに
は、グループバッファーで `G m' キーを使いましょう。その最後の手順が、
Gnus に新しいディレクトリーができたことを知らせます。`nnmaildir' は自動
的に新しいディレクトリーを知るので、その場合 `G m' は不要です。



File: gnus-ja.info, Node: Web Searches, Next: Slashdot, Prev: Archiving Mail, Up: Browsing the Web

ウェブ検索
----------

ううむ、まあ、調べたい文字が書いてある記事を、その、Usenet で探すという
ことは、ですね、もちろん素晴らしいことこの上ないのではありますが、しか
し、何と申しましょうか、ウェブブブラウザーといいますか、そういうものを
使ってことを行なうのは、何ともその、はばかりながら、ぶざまと言いますか、
そうすると、コマーシャルを見ないわけにはいかないのでありまして、しかる
に、Gnus を使えばブラウザー無しで検索することができます。

`nnweb' バックエンドは、強力な検索エンジンへの簡単なインターフェースを
提供します。`nnweb' グループを作成し、検索パターンを入力してから、その
グループに入って他の普通のグループのように記事を読んでください。グルー
プバッファー (*Note Foreign Groups::) の `G w' 命令によって、手軽にこれ
ができます。

`nnweb' グループは、固定グループになろうとはしません--このグループでは
記事番号はごく一時的なものとして扱われます。実際、`nnweb' グループに入
るたびに (たとえ検索パターンを変更していなくても)、記事の順序が違ってい
るかもしれません。また、重複抑制 (*Note Duplicate Suppression::) を使っ
ても役に立たないでしょう。というのは、検索エンジン (例えば Google) を使っ
て記事を読み込む前の段階では、`nnweb' はそれらの `Message-ID' を知らな
いからです。あなたが読んだ記事を憶えておくための唯一の方法は、`Date' ヘッ
ダーを元にスコアを付けることだけです--つまり、そのグループを最後に読ん
だ日付より前に投稿された記事を、すべて既読にするということです。

もし検索エンジンの出力形式が実質的に変更されると、`nnweb' はそれをうま
く解釈できなくて、処理に失敗するでしょう。ウェブの提供者たちがそんなこ
とをしても、彼らを責めることはできないでしょう--それは広告で金を稼ぐの
が彼らの *レーゾン・デートル* (存在理由) であり、社会にサービスを提供す
ることではないからです。`nnweb' はすべての記事から広告を洗い流してしま
うので、提供者たちがムカついていると思われるかもしれません。まあ見てて
ください。

`nnweb' を使うには、`url' と `W3' パッケージ、またはそれらの代替
(`mm-url' 変数グループに対して `customize-group' を試してみてください)
をインストールしておかなくてはなりません。

以下は仮想サーバー変数です。

`nnweb-type'
     どの検索エンジンを使うかを指定します。現在サポートされている種類は、
     `google', `dejanews' そして `gmane' です。`dejanews' は `google'
     の別名になっていることに注意してください。

`nnweb-search'
     検索エンジンに与える検索文字列です。

`nnweb-max-hits'
     一つの検索で表示する最大のヒット数の希望値で、ディフォルトは 999
     です。

`nnweb-type-definition'
     種類と定義の連想リストです。この連想リストは、さまざまな検索エンジ
     ンの種類に対して、`nnweb' がどうすべきかを指定します。以下に示す要
     素を与えなくてはなりません。

     `article'
          記事をデコードし、Gnus が理解できる何かを提供する関数です。

     `map'
          メッセージヘッダーと URL を、記事番号を元にして得るための連想
          リストを作成する関数です。

     `search'
          検索エンジンに検索文字列を送るための関数です。

     `address'
          前述の関数が検索文字列を送るべきアドレスです。

     `id'
          `Message-ID' を元にして記事を取得するための、URL フォーマット
          の文字列です。



File: gnus-ja.info, Node: Slashdot, Next: Ultimate, Prev: Web Searches, Up: Browsing the Web

Slashdot
--------

Slashdot (http://slashdot.org/) は人気のあるニュースサイトで、ニュース
記事に関して活発な議論がなされています。`nnslashdot' では便利な方法でこ
の会議室を読むことができます。

ここから読むための一番簡単な方法は、以下のようなものを `~/.gnus.el' ファ
イルに入れることです。

     (setq gnus-secondary-select-methods
           '((nnslashdot "")))

これは Gnus に `nnslashdot' バックエンドに対して新しいコメントとグルー
プを尋ねさせます。`F' 命令はそれぞれの新しいニュース記事を新しい Gnus
のグループとして作るので、これらのグループに入ることによってコメントを
読むことができます。(ディフォルトの講読方法では、新しいグループをゾンビ
として作ることに注意してください。他の方法を使うこともできます (*Note
Subscription Methods::)。

古い `nnslashdot' グループを削除したい場合には、`G DEL' が最も手軽な道
具です (*Note Foreign Groups::)。

`nnslashdot' のコメントにフォローアップ (または新しいコメントの投稿) を
するときは、いくつかの軽い HTML 変換が行なわれます。特に `> ' で引用さ
れたテキストは代わりに `blockquote' で引用され、署名にはそれぞれの行の
最後に `br' が追加されます。それ以外は、メッセージバッファーに直接
HTML を書くことができます。Slashdot はいくつかの HTML 様式をふるい落と
すことに気を付けてください。

以下の変数で振る舞いを変えることができます:

`nnslashdot-threaded'
     `nnslashdot' がグループをスレッドで表示するかどうかを指定します。
     ディフォルトは `t' です。スレッドを表示できるようにするためには、
     `nnslashdot' はグループのすべてのコメントを完全に取得する必要があ
     ります。スレッド表示が要求されていないと、`nnslashdot' は実際に利
     用者が欲しいコメントだけを取得します。スレッドの方が快適ですが、ス
     レッド無しの場合より、ずっとずっと遅くなります。

`nnslashdot-login-name'
     投稿時に使うログイン名です。

`nnslashdot-password'
     投稿時に使うパスワードです。

`nnslashdot-directory'
     `nnslashdot' がファイルを保存する場所です。ディフォルトは
     `~/News/slashdot/' です。

`nnslashdot-active-url'
     ニュース記事の情報とコメントを取得するために使われる URL のフォー
     マット文字列です。ディフォルトは
     `http://slashdot.org/search.pl?section=&min=%d' です。

`nnslashdot-comments-url'
     コメントを取得するために使われる URL のフォーマット文字列です。

`nnslashdot-article-url'
     ニュース記事を取得するために使われる URL のフォーマット文字列です。
     ディフォルトは
     `http://slashdot.org/article.pl?sid=%s&mode=nocomment' です。

`nnslashdot-threshold'
     スコアのしきい値です。ディフォルトは -1 です。

`nnslashdot-group-number'
     最新の 10 個に加えて更新を続ける古いグループの数です。ディフォルト
     は 0 です。



File: gnus-ja.info, Node: Ultimate, Next: Web Archive, Prev: Slashdot, Up: Browsing the Web

Ultimate
--------

The Ultimate Bulletin Board (http://www.ultimatebb.com/) はおそらく一番
良く使われているウェブ掲示板システムでしょう。とても規則的で良質なイン
ターフェースを持っていて、Gnus がグループを最新の状態に保っておくために
必要な情報を得ることが可能です。

`nnultimate' を始めるための一番簡単な方法は、グループバッファーで以下の
ようなものをすることです: `B nnultimate RET
http://www.tcj.com/messboard.ubbcgi/ RET'。(興味のある会議室の URL
(`Ultimate.cgi' 等を最後に含んでいないもの) に変えてください。Ultimate
ウェブサイトにはたくさん挙げられています。) それからサーバーバッファー
で興味のあるグループを購読し、グループバッファーからそれらを読んでくだ
さい。

以下の `nnutimate' 変数が変更可能です:

`nnultimate-directory'
     `nnultimate' がファイルを保存するディレクトリーです。ディフォルト
     は `~/News/ultimate/' です。



File: gnus-ja.info, Node: Web Archive, Next: RSS, Prev: Ultimate, Up: Browsing the Web

Web Archive
-----------

いくつかのメーリングリストは、`http://www.egroups.com/' や
`http://www.mail-archive.com/' のようなウェブサーバーでだけ、そのアーカ
イブを持っています。それはとても規則的で良質なインターフェースを持って
いるので、Gnus がグループを最新の状態に保っておくために必要な情報を得る
ことが可能です。

`nnwarchive' を始めるための一番簡単な方法は、グループバッファーで以下の
ようなものをすることです: `M-x gnus-group-make-warchive-group RET
AN_EGROUP RET egroups RET www.egroups.com RET YOUR@EMAIL.ADDRESS RET'。
(AN_EGROUP を購読しているメーリングリストに、YOUR@EMAILADDRESS を電子メー
ルアドレスに置き換えてください。) または `B nnwarchive RET
mail-archive RET' でバックエンドをブラウズしてください。

以下の `nnwarchive' 変数が変更可能です:

`nnwarchive-directory'
     `nnwarchive' がファイルを保存するディレクトリーです。ディフォルト
     は `~/News/warchive' です。

`nnwarchive-login'
     ウェブサーバーでのアカウント名です。

`nnwarchive-passwd'
     ウェブサーバーでのアカウントのパスワードです。



File: gnus-ja.info, Node: RSS, Next: Customizing W3, Prev: Web Archive, Up: Browsing the Web

RSS
---

いくつかのウェブサイトは RDF site summary (RSS) を持っています。RSS は、
ニュース関連のサイト (BBC や CNN のような) の見出しを要約するためのフォー
マットです。しかし、基本的にリストのようなものなら何でも、RSS feed とし
て提供することができます: weblogs, changelogs あるいは wiki (例えば
`http://cliki.net/recent-changes.rdf') の最新の変更などが対象になります。

RSS はとても規則的で良質なインターフェースを持っているので、Gnus がグルー
プを最新の状態に保っておくために必要な情報を得ることが可能です。

注: `utf-8' coding system をサポートする Emacs を使うのが良いでしょう。
RSS は非-ASCII テキストをエンコードするために、ディフォルトで UTF-8 を
使うからです。それはまた、非-ASCII グループ名にもディフォルトで使われま
す。

Feed を講読するには、グループバッファーから `G R' を使ってくださ
い--feed の所在、タイトルおよび説明の入力を求められるでしょう。タイトル
はどんな文字でもよく、それはグループ名とグループのデータ・ファイルの名
前に使われます。説明は省略できます。

簡単に `nnrss' を始める方法は、グループバッファーで `B nnrss RET RET
y' のようなことを唱え、そしてグループを講読することです。

`nnrss' バックエンドは、それぞれの `nnrss' グループのためのデータ・ファ
イルを `nnrss-directory' (下記参照) に保存します。非-ASCII 文字を含んで
いるファイル名は、`nnmail-pathname-coding-system' 変数または他のもので
指定された coding system でエンコードされます。詳細はここ (*Note
Non-ASCII Group Names::) を見てください。

`nnrss' バックエンドは、それぞれが `text/plain' パートと `text/html' パー
トを含んでいる `multipart/alternative' 型の MIME 記事を作ります。

あなたの講読目録を OPML フォーマット (Outline Processor Markup
Language) でロード/セーブするために、以下のコマンドを使うこともできます。

 -- Function: nnrss-opml-import FILE
     OPML ファイルの入力を促し、そのファイルにあるそれぞれの feed を講
     読します。

 -- Function: nnrss-opml-export
     現在の RSS 講読目録を OPML フォーマットでバッファーに書き出します。

以下の `nnrss' 変数が変更可能です:

`nnrss-directory'
     `nnrss' がファイルを書き込むディレクトリーで、ディフォルトは
     `~/News/rss/' です。

`nnrss-file-coding-system'
     `nnrss' グループのデータ・ファイルを読み書きするときに使われる
     coding system です。ディフォルトは `mm-universal-coding-system' の
     値 (そのディフォルトは Emacs では `emacs-mule'、XEmacs では
     `escape-quoted') です。

`nnrss-ignore-article-fields'
     いくつかのフィードは、記事フィールドの例えばコメント数を、その存続
     期間を通じて絶えず更新します。しかしそれはローカルに保存したものと
     の差異を生むので、サーバーに新しい記事があるように解釈されてしまい
     ます。いくつかのフィールドを無視してこれを防ぐためには、この変数に
     無視するべきフィールドのリストを設定してください。ディフォルトは
     `'(slash:comments)' です。

`nnrss-use-local'
     `nnrss-use-local' を `t' に設定すると、`nnrss' は
     `nnrss-directory' にあるローカルファイルから feed を読みます。
     `nnrss-generate-download-script' コマンドを使うことによって、
     `wget' を使ったダウンロード・スクリプトを作ることができます。

`nnrss-wash-html-in-text-plain-parts'
     `nil' ではない値にすると `nnrss' は `text/plain' パートにあるテキ
     ストを HTML として描画します。テキストの描画には
     `mm-text-html-renderer' 変数 (*Note 表示のカスタマイズ:
     (emacs-mime-ja)Display Customization.) で定義された関数が使われま
     す。`nil' だったら (それがディフォルトです)、テキストは単に折り返
     されるだけです。もし `text/html' パートを見るのが好みならば、
     `nil' のままにしておいてください。

概略バッファーに説明を表示させたいならば、以下のコードが役に立つでしょ
う。

     (add-to-list 'nnmail-extra-headers nnrss-description-field)
     (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-15,15f%]%) %s%uX\n")

     (defun gnus-user-format-function-X (header)
       (let ((descr
              (assq nnrss-description-field (mail-header-extra header))))
         (if descr (concat "\n\t" (cdr descr)) "")))

以下のコードは、概略バッファーから直接 nnrss の url をオープンするのに
便利でしょう。

     (require 'browse-url)

     (defun browse-nnrss-url (arg)
       (interactive "p")
       (let ((url (assq nnrss-url-field
                        (mail-header-extra
                         (gnus-data-header
                          (assq (gnus-summary-article-number)
                                gnus-newsgroup-data))))))
         (if url
             (progn
               (browse-url (cdr url))
               (gnus-summary-mark-as-read-forward 1))
           (gnus-summary-scroll-up arg))))

     (eval-after-load "gnus"
       #'(define-key gnus-summary-mode-map
           (kbd "<RET>") 'browse-nnrss-url))
     (add-to-list 'nnmail-extra-headers nnrss-url-field)

あなたが HTML パートを見たくないために `text/html' を
`mm-discouraged-alternatives' 変数 (*Note 表示のカスタマイズ:
(emacs-mime-ja)Display Customization.) に加えていたとしても、特に
`nnrss' グループでは `text/html' を表示する方が便利かもしれません。以下
は `nnrss' グループでだけは `text/html' パートを表示するために、グルー
プパラメーターとして `mm-discouraged-alternatives' を設定する例です:

     ;; `mm-discouraged-alternatives' のディフォルト値を設定。
     (eval-after-load "gnus-sum"
       '(add-to-list
         'gnus-newsgroup-variables
         '(mm-discouraged-alternatives
           . '("text/html" "image/.*"))))

     ;; `nnrss' グループでは `text/html' パートを表示。
     (add-to-list
      'gnus-parameters
      '("\\`nnrss:" (mm-discouraged-alternatives nil)))



File: gnus-ja.info, Node: Customizing W3, Prev: RSS, Up: Browsing the Web

W3 のカスタマイズ
-----------------

Gnus はウェブページを取得するために url ライブラリーを、ウェブページを
表示するために Emacs/W3 を (またはそれらの代替を) 使います。Emacs/W3 の
ことはそのマニュアルに記載されていますが、ここでは Gnus の利用者にとっ
てより適切な、いくつかの事柄を述べることにします。

例えばよくある質問は、Emacs/W3 に `browse-url' の関数 (Netscape のよう
な外部プラウザーを呼びます) を使ってリンクを参照させるにはどうしたらよ
いか、というものです。以下は一つの方法です:

     (eval-after-load "w3"
       '(progn
         (fset 'w3-fetch-orig (symbol-function 'w3-fetch))
         (defun w3-fetch (&optional url target)
           (interactive (list (w3-read-url-with-default)))
           (if (eq major-mode 'gnus-article-mode)
               (browse-url url)
             (w3-fetch-orig url target)))))

これをあなたの .emacs ファイルに書き込んでください。そうすれば、Gnus の
記事バッファーで W3 が描画した HTML リンクを叩くと、
`browse-url' を使ってそのリンクを参照してくれるでしょう。



File: gnus-ja.info, Node: IMAP, Next: Other Sources, Prev: Browsing the Web, Up: Select Methods

IMAP
====

IMAP はメール (もしくは、ニュース、もしくは ...) を読むためのネットワー
クプロトコルです。現代風の NNTP と考えてください。IMAP サーバーへの接続
はニュースサーバーへの接続と非常に似ていて、そのサーバーのネットワーク
アドレスを指定するだけになっています。

IMAP には二つの特質があります。一つは、IMAP は POP でできることは全部で
きる、それゆえ POP++ のようにも見えるということ。二つ目は、IMAP は
NNTP がニュースを貯蔵するプロトコルであるように、メールを貯蔵するプロト
コルであるということです。しかしながら IMAP は NNTP より多くの機能を提
供します。メールは読み書きができるのに対して、ニュースはだいたいにおい
て読むだけですから。

IMAP を POP++ のように使いたいときは、
`mail-sources' に imap の項目を登録してください。これによっ
て Gnus は IMAP サーバーからメールを取り込んで、ローカルディス
クに格納します。ここではその使い方の説明はしませんから、
*Note Mail Sources:: を参照してください。

IMAP をメールを貯蔵するプロトコルとして使いたいときは、
`gnus-secondary-select-methods' に nnimap の項目を登録してください。こ
れによって Gnus は IMAP サーバーに格納されているメールを操作するように
なります。これがここで説明する種類の使い方です。

いくつかの IMAP サーバーを `~/.gnus.el' で設定すると、たぶん以下のよう
なものになるでしょう。(注: TLS/SSL では外部プログラムとライブラリーが必
要です。以下を参照してください。)

     (setq gnus-secondary-select-methods
           '((nnimap "simpleserver") ; 特殊ではない設定
             ; もしかしたら SSH ポートをフォワードしたサーバー:
             (nnimap "dolk"
                     (nnimap-address "localhost")
                     (nnimap-server-port 1430))
             ; ローカルホストで稼動している UW サーバー:
             (nnimap "barbar"
                     (nnimap-server-port 143)
                     (nnimap-address "localhost")
                     (nnimap-list-pattern ("INBOX" "mail/*")))
             ; 匿名で使える cyrus の公衆サーバー:
             (nnimap "cyrus.andrew.cmu.edu"
                     (nnimap-authenticator anonymous)
                     (nnimap-list-pattern "archive.*")
                     (nnimap-stream network))
             ; 標準ではないポートの SSL サーバー:
             (nnimap "vic20"
                     (nnimap-address "vic20.somewhere.com")
                     (nnimap-server-port 9930)
                     (nnimap-stream ssl))))

新しいサーバーを定義した後で、`U' のような Gnus の通常のコマンドをグルー
プバッファーで使う (*Note Subscription Commands::) か、またはサーバーバッ
ファー (*Note Server Buffer::) を介して、そのサーバーのグループを講読す
ることができます。

以下の変数は仮想 `nnimap' サーバーを作成するために使うことができます。

`nnimap-address'
     遠隔 IMAP サーバーのアドレスです。指定されていない場合は仮想サーバー
     の名前になります。

`nnimap-server-port'
     接続するサーバーのポートです。ディフォルトはポート 143、または
     TLS/SSL では 993 です。

     これは整数でなければならないことに注意してください。以下はサーバー
     指定の例です:

          (nnimap "mail.server.com"
                  (nnimap-server-port 4711))

`nnimap-list-pattern'
     使うことができるグループを制限するための、メールボックスの文字列ま
     たは文字列のリストです。これは、サーバーに非常に多くのメールボック
     スがあるけれど、興味のあるものは少しだけであるときに使用します。い
     くつかのサーバーはホームディレクトリーを IMAP 経由でアクセスできる
     ようにするので、その場合はおそらくメールボックスを `~/Mail/*' に制
     限したいでしょう。

     文字列は REFERENCE と上記の文字列との cons であることもできます。
     どの REFERENCE が使用されるかはサーバーによりますが、ワシントン大
     学のサーバーでは、メールボックスと連結されるディレクトリーです。

     以下はサーバー指定の例です:

          (nnimap "mail.server.com"
                  (nnimap-list-pattern ("INBOX" "Mail/*" "alt.sex.*"
                                         ("~friend/Mail/" . "list/*"))))

`nnimap-stream'
     サーバーに接続するときに使われるストリームの型です。ディフォルトで
     は nnimap は TLS/SSL を除く以下のすべてを自動的に検知してそれを使
     います。(TLS/SSL を使う IMAP は STARTTLS で置き換えられています。
     これは自動検出できますが、まだ広範囲に配備されていません。)

     以下はサーバー指定の例です:

          (nnimap "mail.server.com"
                  (nnimap-stream ssl))

     `nnimap-stream' の値はシンボルであることに注意してください!

        * "gssapi:" GSSAPI (普通は Kerberos 5) で接続します。`gsasl' ま
          たは `imtest' プログラムが必要です。
        * "kerberos4:" Kerberos 4 で接続します。`imtest' プログラムが必
          要です。
        * "starttls:" STARTTLS 拡張 (TLS/SSL に類似) を介して接続します。
          `starttls.el' 外部ライブラリーと `starttls' プログラムが必要
          です。
        * "tls:" TLS を通して接続します。GNUTLS (`gnutls-cli' プログラ
          ム) が必要です。
        * "ssl:" SSL を通して接続します。OpenSSL (`openssl' プログラム)
          か SSLeay (`s_client') が必要です。
        * "shell:" シェル命令を使って IMAP 接続を開始します。
        * "network:" 生の TCP/IP のネットワーク接続です。

     `imtest' プログラムは Cyrus IMAPD に含まれています。もし 2.0.14 未
     満の Cyrus IMAPD に含まれている `imtest' (バージョン 1.5.x および
     1.6.x) を使っているなら、`imap-process-connection-type' をいじって、
     `imap.el' が `imtest' と通信するときに、パイプではなくて pty を使
     うようにさせる必要があります。そうするとあなたは IMAP コマンドの行
     の長さの制限に悩まされ、メールボックスにたくさんの記事がある場合に
     は、Gnus が無期限にハングするように見えるかもしれません。変数
     `imap-kerberos4-program' は imtest プログラムに渡すパタメータを含
     みます。

     TLS 接続では GNUTLS 由来の `gnutls-cli' プログラムが必要です。
     `http://www.gnu.org/software/gnutls/' から手に入れることができます。

     このパラメーターは、副シェルで GSSAPI 認証による IMAP 接続を起動す
     るためのコマンド行のリストを指定します。これらは接続が確立するまで、
     またはリストが使い尽くされるまで、順ぐりに試されます。ディフォルト
     では、`http://www.gnu.org/software/gsasl/' にある GNU SASL による
     `gsasl' と、Cyrus IMAPD による `imtest' プログラム
     (`imap-kerberos4-program' 参照) が試されます。

     SSL 接続のための OpenSSL プログラムは `http://www.openssl.org/' か
     ら入手できます。OpenSSL は以前は SSLeay として知られていたもので、
     nnimap はそれもサポートします。しかし SSLeay の最新版である 0.9.x
     には、それを役に立たなくしてしまう重大なバグがあることが知られてい
     ます。以前の版、特に SSLeay 0.8.x は使えることがわかっています。変
     数 `imap-ssl-program' は OpenSSL/SSLeay に渡すパタメータを含みます。

     `shell' ストリームを使う IMAP 接続では、何のプログラムを呼ぶかを変
     数 `imap-shell-program' で指定します。何物もそのプログラムの出力を
     邪魔しないようにしてください。例えばエラー出力は void に振り分けま
     しょう。

`nnimap-authenticator'
     サーバーに接続するために使われる認証手段です。ディフォルトでは
     nnimap はサーバーにできる最も安全な認証手段を使います。

     以下はサーバー指定の例です:

          (nnimap "mail.server.com"
                  (nnimap-authenticator anonymous))

     `nnimap-authenticator' の値はシンボルであることに注意してください!

        * "gssapi:" GSSAPI (普通は Kerberos 5) 認証です。外部プログラム
          `gsasl' または `imtest' が必要です。
        * "kerberos4:" Kerberos 4 による認証です。外部プログラム
          `imtest' が必要です。
        * "digest-md5:" DIGEST-MD5 で暗号化された 利用者名/パスワード
          です。外部ライブラリー `digest-md5.el' が必要です。
        * "cram-md5:" CRAM-MD5 で暗号化された 利用者名/パスワード です。
        * "login:" LOGIN 経由での生の 利用者名/パスワード です。
        * "anonymous:" 電子メールアドレスをパスワードとして与え、
          “anonymous”としてログインします。

`nnimap-expunge-on-close'
     パルメニデスと違って、IMAP の設計者達は、存在していないものが実際
     には存在していると決めました。もっと詳しく説明すると、IMAP には実
     際には記事を消去せずに `Deleted' という印を記事に付けるという概念
     があります。これ (すなわち `Deleted' の印を付けること) が Gnus で
     記事を消去するときに nnimap が行なうことです (`B DEL' などで)。(訳
     注: パルメニデスは紀元前 5 世紀のギリシアの Elea 派の哲学者。)

     記事を `Deleted' フラグで印を付けたときには本当は消去されていない
     ので、実際に消去するための方法が必要となります。まだどうどうめぐり
     をしているように感じますか?

     伝統的に nnimap はメールボックスを閉じるときに `Deleted' という印
     の付いたすべての記事を消去してきましたが、今ではこのサーバー変数に
     よって設定することが可能になりました。

     可能な選択肢は:

     `always'
          これがディフォルトの振舞いで、メールボックスを閉じるときに
          “Deleted”として印が付けられている記事を消去します。
     `never'
          決して記事を消去しません。現在は消去の印が付いた記事を
          nnimap で表示する方法はありませんが、他の IMAP クライアントで
          はできるかもしれません。いつも手で EXPUNGE コマンドを発行した
          いならば、*Note Expunging mailboxes:: を参照してください。
     `ask'
          メールボックスを閉じるときに、nnimap が消去された記事を削除す
          るかどうかを尋ねます。

`nnimap-importantize-dormant'
     非-`nil' (ディフォルト) だったら、他の IMAP クライアントのために保
     留記事に可視記事として (も) 印を付けます (訳注: 保留==dormant、可
     視==ticked)。Gnus の内部では、当然ながら保留記事には保留記事として
     のみ印が付けられます。一方これは、保留記事を、他の IMAP クライアン
     トにおいて、あたかも可視記事のようにきわ立たせます。(別の言い方を
     すると、Gnus には二つの「可視」印があり、IMAP にははたった一つだと
     いうことです。)

     おそらくこれをいじる唯一の理由は、あなたが利用者ごとに永続的な保留
     フラグを付けようとしているかどうかということでしょう。こんな感じで:

          (setcdr (assq 'dormant nnimap-mark-to-flag-alist)
                  (format "gnus-dormant-%s" (user-login-name)))
          (setcdr (assq 'dormant nnimap-mark-to-predicate-alist)
                  (format "KEYWORD gnus-dormant-%s" (user-login-name)))

     この場合、あなたは利用者ごとの保留フラグが付いている記事が、他の利
     用者には可視記事として見えるようにしたくないのでしょうね。

`nnimap-expunge-search-string'
     この変数には、期限切れ消去するのが望ましい記事を探すときにサーバー
     に送った IMAP の検索コマンドが入っています。ディフォルトは `"UID
     %s NOT SINCE %s"' で、ここで最初の `%s' は UID の一揃いで置き換え
     られ、二番目の `%s' は日付で置き換えられます。

     この代わりに使いものになる値はたぶん `"UID %s NOT SENTSINCE %s"'
     だけで、それは nnimap に記事の内部的な日付の代わりに Date: を使う
     ようにさせます。 使うことができる文字列に関するさらなる情報は、
     RFC 2060 の第 6.4.4 章を見てください。

     しかしながら `nnimap-search-uids-not-since-is-evil' が真になってい
     ると、後述のように検索論理が反転されるので、この変数は無効になりま
     す。

`nnimap-authinfo-file'
     サーバーにログインするために使う認証情報 (credentials) を含むファ
     イルです。その形式は `ftp' の `~/.netrc' ファイルと (ほとんど) 同
     じです。厳密な様式については、変数 `nntp-authinfo-file' を見てくだ
     さい。そして *Note NNTP:: も見てください。IMAP サーバー用
     の .authinfo 行の例です:

          machine students.uio.no login larsi password geheimnis port imap

     安全な IMAP で使われる実際のポート番号は port 993 ですが、
     `nnimap-stream' として `tls' または `ssl' を使う場合、それは
     `port imap' または `port 143' でなければならないことに注意してくだ
     さい。便宜上 Gnus は `port imap' の同義語として `port imaps' を受
     け入れます。

`nnimap-need-unselect-to-notice-new-mail'
     メールボックス群で新着メールを探す前に、それらを未選択にします。い
     くつかのサーバーが、何らかの状況の元でこれを必要とするようです。
     Courier 1.7.1 はそうだという報告がありました。

`nnimap-nov-is-evil'

     NOV データベースを作らないか、またはローカルのものを使います。ディ
     フォルトは `gnus-agent' の値です。

     普通 NOV データベースを使うとヘッダーの取得がとても速くなりますが、
     ある種のサーバー (特にいくつかの Courier の版) では非常に遅い
     `UID SEARCH UID' コマンドを使います。Gnus エージェントは、その遅い
     コマンドを使わずに NOV データベースに情報をキャッシュするので、こ
     の変数のディフォルト値は、エージェントが使われる場合は真に、そうで
     ない場合は偽になります。

`nnimap-search-uids-not-since-is-evil'

     `UID SEARCH UID MESSAGE NUMBERS NOT SINCE DATE' コマンドを使わない
     ようにします。それは、ある種の IMAP サーバー (特にいくつかの
     Courier の版) では非常に遅くなります。代わりに `UID SEARCH SINCE
     DATE' を使って、Gnus で期限切れ消去する記事のリストから余分なもの
     を取り除きます。

     Gnus がメールの期限切れ消去 (*Note Expiring Mail::) を行うときは、
     期限切れ消去してもよい記事のリストが始めにあり、IMAP サーバーに
     「これらの記事のうち、一週間より古いものはどれ?」のような問いを発
     します。これは完全に合理的な質問に見えますが、見たところいくつかの
     IMAP サーバーは、すべての古い記事について期限切れ消去の対象かどう
     かを調べるので、それに答えるために長い時間がかかります。不思議なこ
     とに「*すべて* の記事のうち、一週間より古いものはどれ?」という質問
     の方がめっぽう速く答えが返ってくるので、この変数を設定して Gnus に
     この質問を出させることによって、本来の質問そのものへの答を得ること
     ができるのです。

     この問題は実際にあなたに忍び寄ってくるでしょう。最初のころは、
     Gnus を設定して、すべてがうまくいったとしても、いったん二〜三千通
     のメッセージが溜まったならば、あなたは Gnus の遅いことをののしりは
     じめるでしょう。一方、あなたが大量の電子メールをたった一週間で受け
     取るのであれば、この変数を設定すると Gnus と IMAP サーバー間の通信
     量の増大を招くでしょう。

`nnimap-logout-timeout'

     ある種のネットワーク (例えば VPN) を経由して IMAP サーバーに接続す
     る場合に、サーバーへの接続を閉じることができないことがあります。そ
     の場合、サーバーがある理由 (典型的にはタイムアウト) で接続を閉じて
     しまったとしても、Emacs とローカル・ネットワークの間の接続が生きて
     いるように観測されるでしょう。その結果 Emacs は Emacs が送った
     `LOGOUT' 命令に対するサーバーからの返答を待ち続けます、と言うかハ
     ングします。そのようなネットワークにいるのであれば、この変数に秒数
     を設定することは役に立ちます。それが設定されると Emacs が
     `LOGOUT' 命令を送ってからこの秒数後に、ハングした接続は強制的に終
     了させられます。それは小さ過ぎる値ではいけませんが、大き過ぎる値も
     不便でしょう。おそらく値 1.0 は良い目安です。でも他の値をいくつか
     試してみる価値があるかもしれません。

     以下はサーバー指定の例です:

          (nnimap "mail.server.com"
                  (nnimap-logout-timeout 1.0))

* Menu:

* Splitting in IMAP::           nnimap でメールを分割する
* Expiring in IMAP::            nnimap によるメールの期限切れ消去
* Editing IMAP ACLs::           他の利用者のメールボックスへのアクセスを制限/許可する
* Expunging mailboxes::         「メールボックス圧縮」ボタンと等価なもの
* A note on namespaces::        Gnus で IMAP 名前空間を使う (使わない) 方法
* Debugging IMAP::              ものごとが働かないときにするべきこと



File: gnus-ja.info, Node: Splitting in IMAP, Next: Expiring in IMAP, Prev: IMAP, Up: IMAP

IMAP での分割
-------------

分割は Gnus の利用者が何年も愛用してきたもので、今や残りの世界も追い着
こうとしています。ええ、彼らには勝手に夢を見ていてもらいましょう。サー
バー側で分割できる IMAP サーバーはあまり多くなく、しかもそれらは標準で
はないプロトコルを使っているようです。つまり Gnus の IMAP サポートは、
自分自身で分割をしなければならないということです。

そして実際にします。

(ついでに言えば、みんなが夢見ていたのでしょうね。その結果 Sieve は市場
占有率を増して、いくつもの IMAP サーバーによってサポートされるようにな
りました。幸いに Gnus もそれをサポートします。*Note Sieve Commands::.)

関連する変数は三つです:

`nnimap-split-crosspost'
     `nil' でなければ、複数の分割規則がそのメールと合致したときにクロス
     ポストをします。`nil' ならば、`nnimap-split-rule' で最初に見つかっ
     たものが使われます。

     Nnmail で対応するもの: `nnmail-crosspost'.

`nnimap-split-inbox'
     分割の元となる IMAP のメールボックスの名前を指定する文字列か文字列
     のリストです。ディフォルトは `nil' で、分割は使用しないようになっ
     ています!

          (setq nnimap-split-inbox
                '("INBOX" ("~/friend/Mail" . "lists/*") "lists.imap"))

     Nnmail に対応するものはありません。

`nnimap-split-rule'
     `nnimap-split-inbox' で見つかった新しいメールは、この変数に従って
     分割されます。

     この変数はリストのリストから成ります。副リストの最初の要素は IMAP
     のメールボックスで、二つめの要素の正規表現に合致した記事の移動先を
     指定します。わかりましたか? いいえ、私もわかりません。例が必要です。

          (setq nnimap-split-rule
                '(("INBOX.nnimap"
                   "^Sender: owner-nnimap@vic20.globalcom.se")
                  ("INBOX.junk"    "^Subject:.*MAKE MONEY")
                  ("INBOX.private" "")))

     これは nnimap メーリングリストからのすべての記事をメールボックス
     INBOX.nnimap に入れ、Subject: 行に MAKE MONEY のあるすべての記事を
     INBOX.junk に入れ、その他すべてのものを INBOX.private に入れます。

     最初の文字列は、replace-match で合致したテキストから副表現を挿入す
     るときに使用されるのと同じような、`\\1' 形式を含むことができます。
     例えば:

          ("INBOX.lists.\\1"     "^Sender: owner-\\([a-z-]+\\)@")

     最初の要素をシンボル `junk' にして、合致するメッセージを単に消すべ
     きであることを表すこともできます。気を付けて使ってください。

     二つ目の要素は関数であることもできます。その場合は、その規則の最初
     の要素を引数として、記事のヘッダーがあるバッファーで呼ばれます。メー
     ルがそのグループに属すると考える場合は、`nil' でない値を返す必要が
     あります。

     Nnmail の利用者は、最後の正規表現はすべての記事に合致するように、
     空でなくてはならないことを覚えているかもしれません (上の例のよう
     に)。これは nnimap では必要ではありません。正規表現のどれにも合致
     しない記事は inbox から移動されません。(inbox に未読記事を大量に置
     いておくと、分割のコードは新しいメールを取得するときにそれらすべて
     を調べるので、実行速度に影響するかもしれません。)

     これらの規則は連想リストの最初から終りに向かって実行されます。クロ
     スポストを有効にしていない限り、最初に合致した規則が「勝ち」ます。
     有効にしている場合は、すべての合致した規則が「勝ち」ます。

     この変数はその値として関数を持つこともできます。その関数は記事のヘッ
     ダーの部分に範囲が狭められた状態で呼ばれ、記事の移動先だと思うグルー
     プを返すものでなければなりません。`nnimap-split-fancy' を参照して
     ください。

     分割コードは必要ならメールボックスを作成しようとします。

     異なる仮想サーバー毎に違う分割の規則を使ったり、それどころか同じサー
     バーの異なる inbox 毎に違う分割の規則を使うことができるようにする
     ために、この変数の構文は以下のやり方で拡張されています。

          (setq nnimap-split-rule
                '(("my1server"    (".*"    (("ding"    "ding@gnus.org")
                                            ("junk"    "From:.*Simon")))
                  ("my2server"    ("INBOX" nnimap-split-fancy))
                  ("my[34]server" (".*"    (("private" "To:.*Simon")
                                            ("junk"    my-junk-func)))))

     仮想サーバー名は、同じ規則を複数のサーバーに適用できるように、実際
     には正規表現になっています。この例ではサーバー `my3server' と
     `my4server' の両方が同じ規則を使います。同様に inbox 文字列も正規
     表現です。実際の分割の規則は、前に説明したように、関数か、グループ
     /正規表現またはグループ/関数を要素群とするリスト、の両方です。

     Nnmail で対応するもの: `nnmail-split-methods'.

`nnimap-split-predicate'
     この述語に合致する `nnimap-split-inbox' にあるメールは分割されます。
     これは文字列で、ディフォルトは `UNSEEN UNDELETED' です。

     inbox にあるメールを読むために別の IMAP クライアントを使っているが、
     購読度に関わらずにすべての記事を Gnus に分割させたいならば、これは
     役に立つかもしれません。その場合は `UNDELETED' に変えれば良いでしょ
     う。

`nnimap-split-fancy'
     特級分割を使いたいならば、`nnimap-split-rule' の値
     を `nnmail-split-fancy' に設定することができます。
     *Note Fancy Mail Splitting::.

     しかし nnmail と nnimap とで異なる特級分割方式を持つようにするには、
     `nnimap-split-rule' の値を `nnimap-split-fancy' に設定して、
     nnimap 特有の特級分割方式を `nnimap-split-fancy' に定義してくださ
     い。

     例:

          (setq nnimap-split-rule 'nnimap-split-fancy
                nnimap-split-fancy ...)

     Nnmail で対応するもの: `nnmail-split-fancy'.

`nnimap-split-download-body'
     分割している最中にすべての記事をダウンロードするには、非-`nil' に
     設定してください。これは普通は必要としないし、ものごとを相当に遅く
     してしまうでしょう。記事を分割するためにその本文を分析する高度な関
     数を使いたい場合には、必要かもしれません。



File: gnus-ja.info, Node: Expiring in IMAP, Next: Editing IMAP ACLs, Prev: Splitting in IMAP, Up: IMAP

IMAP での期限切れ消去
---------------------

`nnimap' は完全な `nnmail' 由来のバックエンドではありませんが、標準的な
たいていの期限切れ消去 (*Note Expiring Mail::) の機能をサポートします。
IMAP の分割 (*Note Splitting in IMAP::) では `nnmail' の変数を複製しな
い (例えば NNIMAP-EXPIRY-WAIT を生成しない) 点が違うのですが、`nnmail'
の変数を流用します。以下は `nnimap' の期限切れ消去の処理で使われる変数
です。

また、期限切れ消去の印がどのように IMAP サーバーに記録されるかについて
も、ここで言及しておくのが適切でしょう。期限切れ消去の印は `imap' クラ
イアント特有の印である `gnus-expire' に変換され、メッセージに記録されま
す。そうするのは、おそらく Gnus だけが適切に `gnus-expire' の印を理解し
て扱うからです。もっとも他のクライアントは、メッセージのクライアント特
有のフラグを見させてくれるでしょうが。このことは、クライアント特有のフ
ラグを恒久的にメッセージに保存することを、サーバーがサポートしなければ
ならないことも意味します。たいていはサポートします。幸いにも。

もし IMAP メールの期限切れ消去がとても遅く感じられるのならば、サーバー
変数 `nnimap-search-uids-not-since-is-evil' を設定することを試してみて
ください。

`nnmail-expiry-wait'
`nnmail-expiry-wait-function'
     これらの変数は完全にサポートされています。期限切れ消去の値は、数、
     シンボルの `immediate' または `never' です。

`nnmail-expiry-target'
     この変数はサポートされていて、内部的にはこれを扱う `nnmail' 関数を
     呼ぶことによって実装されています。それには、行き先が同じサーバーの
     IMAP グループだったら、記事を追加する代わりにコピーする (アップロー
     ドし直す) という最適化も含みます。



File: gnus-ja.info, Node: Editing IMAP ACLs, Next: Expunging mailboxes, Prev: Expiring in IMAP, Up: IMAP

IMAP の ACL を編集する
----------------------

ACL は Access Control List (使用制限一覧) の略です。IMAP では、ACL は他
の利用者によるあなたのメールボックスの使用を制限 (もしくは許可) するた
めに使われています。すべての IMAP サーバーにこの機能があるわけではない
ので、無いサーバーでこれを使うとエラーが発生します。

あるメールボックスのための ACL を編集するには、`G l'
(`gnus-group-edit-nnimap-acl') をタイプしてください。そうすると、詳しい
説明をともなった ACL 編集ウィンドウが現れます。

使うことがありそうな例:

   * あなたのメーリングリストのメールボックスで“anyone”に“lrs”権
     (lookup, read, seen/unseen フラグの保持) を与えることによって、そ
     のリストに講読登録しなくても、同じサーバーの他の利用者が読むことが
     できます。
   * 少なくとも Cyrus のサーバーでは、誰もが“plussing”を使うことがで
     きるようにするためには、利用者“anyone”に投稿 ("p") の許可を与え
     る必要があります (“plussing”とはすなわち、user+mailbox@domain 宛
     てに送られたメールが INBOX.mailbox という IMAP のメールボックスに
     届くようにすることです)。



File: gnus-ja.info, Node: Expunging mailboxes, Next: A note on namespaces, Prev: Editing IMAP ACLs, Up: IMAP

メールボックスの削除
--------------------

`nnimap-expunge-on-close' に `never' を設定している場合には、メールボッ
クスのすべての消去 (deleted) された記事を手動で削除 (expunge) する必要
があるでしょう。まさにこれが `G x' が行なうことです。

今のところ消去された記事を表示する方法はありません。ただ消去できるだけ
です。



File: gnus-ja.info, Node: A note on namespaces, Next: Debugging IMAP, Prev: Expunging mailboxes, Up: IMAP

名前空間に関する注意
--------------------

IMAP プロトコルには名前空間 (namespaces) と呼ばれる概念があり、以下の
RFC2060 の文書で記述されています:

     5.1.2.  メールボックス名前空間命名規則

        習慣により "#" で始まっているすべてのメールボックス名の最初の階層要素
        は、残りの名前の "名前空間" を示している。これは、それぞれ独自の名前
        空間を持つ異なるメールボックス保管の間での、曖昧さを取り除くことを可
        能にする。

           例えば USENET ニュースグループへのアクセスを提供する実装は、USENET
           ニュースグループ名前空間を他のメールボックスから分離するために、
           "#news" 名前空間を用いてもよい。こうして comp.mail.misc ニュースグ
           ループは "#news.comp.mail.misc" というメールボックス名を持ち、名前
           "comp.mail.misc" は別のオブジェクト (例えば、利用者の個人メールボッ
           クス) を指すことはありうる。

     (訳註: http://kame.zit.to/~obata/imap/rfc/rfc2060ja.txt より転載)

Gnus における IMAP の実装を保証する記述がこの文書には無い一方で、いくつ
かのサーバーは Gnus のメールボックスの名前の使い方では動作しないやり方
で名前空間接頭語 (namespace prefix) を使っています。

具体的には、ワシントン大学の IMAP サーバーは `#driver.mbx/read-mail' の
ようなメールボックス名を使っていて、それは CREATE と APPEND コマンドで
だけ有効です。メールボックスが作られた後 (またはメッセージがメールボッ
クスに追加された後) では、それは名前空間接頭語を付けずにアクセス、すな
わち `read-mail' されなければなりません。Gnus は利用者が CREATE と
APPEND コマンドだけで入力したメールボックス名を保証できないので、絶対に
名前空間接頭語が付いたメールボックス名を Gnus で使ってはいけません。

`#driver.*/' について、どのように接頭語を使えば良いかについてのさらなる
情報は、UoW IMAPD の文書を見てください。それらは強力な工具なので、どん
な効果があるかが確かな場合だけ使ってください。



File: gnus-ja.info, Node: Debugging IMAP, Prev: A note on namespaces, Up: IMAP

IMAP のデバッグ
---------------

IMAP は NNTP や POP3 よりもっと複雑なプロトコルです。実装上のバグが無い
とは言い切れないので、私たちは、すぐにそれらを直すために最善を尽くしま
す。あなたが奇妙な振る舞いに出会ったとしたら、サーバーか Gnus のどちら
かにバグがある可能性があります。

あなたが一般的なネットワーク・プロトコルに精通しているならば、Gnus とサー
バーの間でやりとりされるプロトコル・ダンプを読むことによって、おそらく
いくつかの手掛かりを抽出することができるでしょう。精通していなくても、
プロトコル・ダンプを IMAP に関するバグ報告に含めれば、その問題の解決に
とって重要なデータで私たちを助けることになります。したがって Gnus の
IMAP バグを報告するときに、プロトコル・ダンプを含めることを強く奨励しま
す。

プロトコル・ダンプは、それを有効にしているとたくさんのデータを生成する
ので、ディフォルトでは無効になっています。有効にするには、以下のように
`imap-log' を設定してください:

     (setq imap-log t)

これはサーバーとのやりとりを何でも `imap.el' パッケージに記録させます。
その記録は `*imap-log*' というバッファーに格納されます。ときとして、
`BAD' という札が付けられるエラーメッセージを探してください。でも、バグ
を提出するときは、すべてのデータを含めるようにしてください。



File: gnus-ja.info, Node: Other Sources, Next: Combined Groups, Prev: IMAP, Up: Select Methods

その他のグループ源
==================

Gnus はただ単にニュースやメールを読む以上のことができます。以下に示す方
法によって、Gnus でディレクトリーやファイルを、あたかもニュースグループ
であるかのように閲覧することができるようになります。

* Menu:

* Directory Groups::            ディレクトリーをニュースグループのように読む
* Anything Groups::             Dired?  誰が dired なんて使うの?
* Document Groups::             個別のファイル群はグループの素
* SOUP::                        SOUP パケットを「オフライン」で読む
* Mail-To-News Gateways::       メールからニュースへのゲートウェイを通して記事を投稿する



File: gnus-ja.info, Node: Directory Groups, Next: Anything Groups, Prev: Other Sources, Up: Other Sources

ディレクトリーグループ
----------------------

たくさんの記事が個別のファイルとして入っているディレクトリーがあれば、
それをニュースグループとして扱うことができます。もちろん、ファイルは数
字のファイル名をもっていなければなりません。

素晴らしい Emacs のパッケージの中でも最も素晴らしい `ange-ftp' (とその
後継の `efs') について触れるのに、ここは良い機会でしょう。私が `nndir'
を書いたときは、これ (ディレクトリーを読むバックエンド) についてはあま
り考えていませんでした。とんでもないことだね。

`ange-ftp' はこの情況を劇的に変化させました。例えばディレクトリー名とし
て `ange-ftp' の様式で `/ftp.hpc.uh.edu:/pub/emacs/ding-list/' というファ
イル名をディレクトリー名として入力したとすると、`ange-ftp' あるいは
`efs' は実に「シナ」の向こうのディレクトリーをニュースグループとして読
めるようになるのです。おーい、分散ニュースだぞーっ!

     (訳注:「シナ」(原典 `sina') は China のことか?)

`nndir' は NOV ファイル群が存在すればそれらを利用します。

`nndir' は「読み出し専用」のバックエンドです--この選択方法では、記事の
削除や期限切れ消去を行なうことはできません。`nndir' が使えるものなら何
でも、`nnmh' あるいは `nnml' でも使うことができるので、もし読み出し専用
ではない `nndir' が必要だと思ったら、これらのどちらかの方法に切り替える
こともできます。



File: gnus-ja.info, Node: Anything Groups, Next: Document Groups, Prev: Directory Groups, Up: Other Sources

なんでもグループ
----------------

`nneething' は `nndir' バックエンド (単一のスプール風ディレクトリーを読
むバックエンド) のほんの少し先にあるもので、それはどんなディレクトリー
でもニュースグループに見せかけてしまいます。不思議ですが真実です。

`nneething' にディレクトリーを与えると、そのディレクトリーを走査して各
ファイルに記事番号を割り当てます。そのようなグループに入ったら、
`nneething' は Gnus が使える「ヘッダー」を作らなくてはなりません。つま
るところ Gnus はニュースリーダーなんです。忘れているかもしれないので念
のため。`nneething' はこれを二段階で処理します。最初に、対象となるそれ
ぞれのファイルを覗いてまわります。もしそのファイルが記事のように見えた
なら (すなわち最初の数行がヘッダーのように見えたら) それをヘッダーとし
て使います。もしそれがヘッダーの無いただの適当なファイル (例えば C のソー
スファイル) だったら、`nneething' はヘッダーを虚空からでっち上げます。
これはファイルの所有者、名前および日付を使い、それらの要素を元にできる
ことを何でもやります。

これはあなたにとってはすべて自動的に起こることで、あなたはニュースグルー
プにとても良く似た何かを見せられることになるでしょう。本当に寸分違わな
い、ニュースグループのようなものを。記事を選択すると、それはいつものよ
うに記事バッファーに表示されるでしょう。

ディレクトリーを表わしている行を選択すると、Gnus はいきなりあなたをこの
`nneething' グループのための新しい概略バッファーに連れて行くでしょう。
以下同様に、あなたがそうしたければ、この方法で全ディスクを駆け巡ること
ができます。ですが、Gnus は本当は dired ではないし、そのように意図され
たものでもないことは覚えておいてください。

ここでの動作には二つの全体的なモードがあります-- 一時モードと固定モード
です。一時的な操作を行なっているときは (すなわちグループバッファーで
`G D')、Gnus はどのファイルを読んだか、どのファイルが新しいか、などの情
報を憶えておきません。普通に `G m' で固定 `nneething' グループを作れば、
Gnus は記事番号とファイル名の対応表を憶えておくので、このグループを他の
グループと同様に扱うことができるようになります。固定 `nneething' グルー
プを活かすと、それが未読記事をいくつ含んでいるかを知らせてもらえる、等々
の利便があります。

いくつかの変数があります:

`nneething-map-file-directory'
     すべての固定 `nneething' グループの対応表が、このディレクトリーに
     格納されます。このディフォルトは `~/.nneething/' です。

`nneething-exclude-files'
     この正規表現に合致するファイルはすべて無視されます。自動保存ファイ
     ルなどを除外するのに便利に使えます。そしてそれがまさにディフォルト
     で行なわれる動作です。

`nneething-include-files'
     どのファイルをグループに含めるかを示す正規表現です。この変数が
     `nil' でなければ、この正規表現に合致するファイルだけが含まれます。

`nneething-map-file'
     対応表ファイルの名前です。



File: gnus-ja.info, Node: Document Groups, Next: SOUP, Prev: Anything Groups, Up: Other Sources

文書グループ
------------

`nndoc' は単一のファイルをニュースグループとして読むことをできるように
する、ちょっと気の利いたやつです。複数のファイルの種別がサポートされて
います:

`babyl'
     Babyl 様式。

`mbox'
     標準 Unix mbox ファイル。

`mmdf'
     MMDF 形式のメールボックス。

`news'
     一つのファイルにまとめられた複数のニュース記事。

`rnews'
     rnews のバッチ転送形式。

`nsmail'
     Netscape のメールボックス。

`mime-parts'
     MIME のマルチパートのメッセージ。

`standard-digest'
     標準 (RFC1153) のまとめ送り形式。

`mime-digest'
     MIME のまとめ送りメッセージ。

`lanl-gov-announce'
     ロスアラモス国立研究所 (LANL) Gov Announce からの発表メッセージ。

`rfc822-forward'
     RFC822 で転送されたメッセージ。

`outlook'
     Outlook のメールボックス。

`oe-dbx'
     Outlook Express の dbx メールボックス。

`exim-bounce'
     Exim MTA から跳ね返されたメッセージ。

`forward'
     非公式の規則で転送されたメッセージ。

`rfc934'
     RFC934 形式で転送されたメッセージ。

`mailman'
     mailman のまとめ送り。

`clari-briefs'
     Clarinet のニュース項目を要約したまとめ送り。

`slack-digest'
     非標準まとめ送り形式--だいたいのものを扱えるが、下手。

`mail-in-mail'
     最後の手段。

特別な「ファイル種別」である `guess' を使うこともできます。これを使うと、
見ているファイルの種別が何かを `nndoc' が推測しようとします。また、
`digest' というファイル種別は、そのファイルがどのまとめ送り形式かを
`nndoc' に推測させます。

`nndoc' はファイルを書き換えようとしたり、余分なヘッダーを挿入しようと
したりはしません--単に、ファイルをそのグループを作る元として使えるよう
にする、というようなことです。それだけのことです。

保存された古い記事を持っていて、それを新しくてかっこいい Gnus のメール
バックエンドに追加したいなら、おそらく `nndoc' が助けになるはずです。例
えば新しい `nnml' グループに振り分けたいメールが、今は古い `RMAIL' ファ
イルにメールがあるとしましょう。そういう場合は、そのファイルを `nndoc'
を使って開き (グループバッファーで `G f' 命令 (*Note Foreign Groups::)
を使いましょう)、バッファー内の全記事にプロセス印を (例えば `M P b' で)
付けてから、それらが `nnml' グループ群に振り分けられるように (`B r' 命
令を使って) 再スプールしてください。すべてがうまくいけば、`RMAIL' ファ
イル内のすべてのメールは、たくさんの `nnml' ディレクトリーの中にも格納
されます。そうしたら、あの厄介な `RMAIL' を削除してしまっても良いでしょ
う。あなたにガッツがあれば!

仮想サーバー変数:

`nndoc-article-type'
     これは `mbox', `babyl', `digest', `news', `rnews', `mmdf',
     `forward', `rfc934', `rfc822-forward', `mime-parts',
     `standard-digest', `slack-digest', `clari-briefs', `nsmail',
     `outlook', `oe-dbx', `mailman' および `mail-in-mail' または
     `guess' のいずれかでなくてはなりません。

`nndoc-post-type'
     この変数は、そのグループをニュースグループとみなすかメールグループ
     とみなすかを Gnus に伝えます。二つの有効な値は `mail' (ディフォル
     ト) および `news' です。

* Menu:

* Document Server Internals::   あなた独自の文書種別を追加する方法



File: gnus-ja.info, Node: Document Server Internals, Prev: Document Groups, Up: Document Groups

文書サーバーの内部
..................

`nndoc' で認識される新しい文書の種別を追加することは難しくありません。
その文書がどのように見えるかの定義を仕上げ、その文書種別を認識するため
の述語関数を書いて、`nndoc' を手なずけるだけで良いのです。

まず、これが文書の種別の定義の例です:

     (mmdf
      (article-begin .  "^\^A\^A\^A\^A\n")
      (body-end .  "^\^A\^A\^A\^A\n"))

この定義は種別を示すためのユニークな名前 ("name") と、それに続く仮想的
な変数名およびその設定値の単純な連なりからなります。以下が使うことがで
きる変数です--変数の数に圧倒されないでください。ほとんどの文書の種別は、
ごくわずかな設定で定義することができます:

`first-article'
     これが設定されていると、`nndoc' はこの正規表現に合致する何かが見つ
     かるまで、すべてのテキストを読み飛ばします。それより前のすべてのテ
     キストは完全に無視されます。

`article-begin'
     この設定は、すべての文書の種別の定義に必ず存在しなければなりません。
     それぞれの記事の始まりがどのように見えるかを指定する正規表現です。
     単純な正規表現では対処できないもっと複雑なことをしたい場合は、これ
     の代わりに `article-begin-function' を使うことができます。

`article-begin-function'
     これを設定する場合は、それぞれの記事の開始位置にポイントを移動させ
     る関数を指定してください。これは `article-begin' より優先されます。

`head-begin'
     これを設定する場合は、記事のヘッダーの始まりに合致する正規表現を指
     定してください。単純な正規表現では対処できないもっと複雑なことをし
     たい場合は、これの代わりに `head-begin-function' を使うことができ
     ます。

`head-begin-function'
     これを設定する場合は、記事のヘッダーの開始位置にポイントを移動させ
     る関数を指定してください。これは `head-begin' より優先されます。

`head-end'
     これを設定する場合は、記事のヘッダーの最後に合致する正規表現を指定
     してください。ディフォルトは `^$'、つまり空行です。

`body-begin'
     これを設定する場合は、記事のボディーの始まりに合致する正規表現を指
     定してください。ディフォルトは `^\n' です。単純な正規表現では対処
     できないもっと複雑なことをしたい場合は、これの代わりに
     `body-begin-function' を使うことができます。

`body-begin-function'
     これを設定する場合は、記事のボディーの開始位置にポイントを移動させ
     る関数を指定してください。これは `body-begin' より優先されます。

`body-end'
     これを設定する場合は、記事のボディーの最後に合致する正規表現を指定
     してください。単純な正規表現では対処できないもっと複雑なことをした
     い場合は、これの代わりに `body-end-function' を使うことができます。

`body-end-function'
     これを設定する場合は、記事のボディーの最後の位置にポイントを移動さ
     せる関数を指定してください。これは `body-end' より優先されます。

`file-begin'
     これを設定する場合は、ファイルの始まりに合致する正規表現を指定して
     ください。それより前のすべてのテキストは完全に無視されます。

`file-end'
     これを設定する場合は、ファイルの最後に合致する正規表現を指定してく
     ださい。それより後ろのすべてのテキストは完全に無視されます。

このように `nndoc' はこれらの変数を使って、文書ファイルをそれぞれヘッダー
とボディーを持った記事の連なりとして切り分けることができます。しかし、
すべての文書の種別がこのようなニュース風になっているわけではないので、
さらにヘッダーやボディーを Gnus の趣味に合うように変形させる変数が、い
くらか必要になります。

`prepare-body-function'
     これに関数を設定しておくと、記事が要求されたときに呼び出されます。
     これはボディーの開始位置のポイントを引数として呼び出され、文書にい
     くつかのエンコードされた内容物のパートがある場合に有用です。

`article-transform-function'
     これに関数を設定しておくと、記事が要求されたときに呼び出されます。
     これは記事のヘッダーとボディーの両方に、より広範囲な変形を行なうた
     めに使われるものです。

`generate-head-function'
     これに関数を設定しておくと、Gnus が理解できるヘッダーを生成するた
     めに呼び出されます。これは記事番号をパラメーターとして呼び出され、
     その記事のための良質なヘッダーを生成することを求められます。すべて
     の記事のヘッダーが要求されるときに呼び出されます。

`generate-article-function'
     これに関数を設定しておくと、Gnus が理解できる完全な記事を生成する
     ために呼び出されます。これはすべての記事のヘッダーが要求されるとき
     に、記事番号をパラメーターとして呼び出されます。

`dissection-function'
     これに関数を設定しておくと、それだけを使って文書ファイルを記事に切り分け
     るために呼び出されます。これは `first-article',
     `article-begin', `article-begin-function', `head-begin',
     `head-begin-function', `head-end', `body-begin',
     `body-begin-function', `body-end', `body-end-function',
     `file-begin' および `file-end' より優先されます。

私が出会った中で最も複雑な例を見てください。標準まとめ送り形式のための
ものです:

     (standard-digest
      (first-article . ,(concat "^" (make-string 70 ?-) "\n\n+"))
      (article-begin . ,(concat "\n\n" (make-string 30 ?-) "\n\n+"))
      (prepare-body-function . nndoc-unquote-dashes)
      (body-end-function . nndoc-digest-body-end)
      (head-end . "^ ?$")
      (body-begin . "^ ?\n")
      (file-end . "^End of .*digest.*[0-9].*\n\\*\\*\\|^End of.*Digest *$")
      (subtype digest guess))

70 文字のダッシュ (`-') の行より前はすべて無視されるというのが分かりま
すね。また `^End of' で始まる行より後ろもすべて無視されます。各記事は
30 文字のダッシュの行で始まり、ヘッダーとボディーの区切りの行は一個のス
ペースを含むことがあり、そしてボディーはそれが渡される前に
`nndoc-unquote-dashes' を通されます。

あなた独自の文書のための定義を `nndoc' で使えるようにするには、
`nndoc-add-type' 関数を使ってください。これは二つのパラメーターをとりま
す-- 一つ目は定義そのもので、二つ目の (省略可能な) パラメーターは、この
定義を文書の種別を定義する連想リストのどこに置くかを指定します。この連
想リストは順番に走査され、与えられた種別 TYPE に対して
`nndoc-TYPE-type-p' が呼び出されます。したがって、例えば `mmdf' という
種別であるかどうかを調べるためには `nndoc-mmdf-type-p' が呼び出され、他
の種別の場合も同様です。これらの種別述語関数は、文書がその種別でない場
合は `nil' を返し、その種別である場合は `t' を返し、その種別かもしれな
いときは数値を返さなくてはなりません。高い数値は高い可能性を意味し、低
い数値は低い可能性を意味します。`0' は正しい値の中でもっとも低い数値で
す。



File: gnus-ja.info, Node: SOUP, Next: Mail-To-News Gateways, Prev: Document Groups, Up: Other Sources

SOUP
----

PC の世界の人々はよく、「オフライン」ニュースリーダーについて話をしてい
ます。それらはリーダーとニュース配送を合体させた、奇っ怪なものどもです。
内蔵モデムプログラム付きでね。うげーっ!

もちろん、我らが Unix キチガイの人間ども (原典: Unix Weenie types of
human beans) は `uucp' だとか `nntpd' のようなものを使い、神の領域たる
メール、ニュースの配送を正しく設定するのです。そして…、僕たちはただ普
通のニュースリーダーを使います。

しかし、あなたがとても遅いモデムを持っていてこれらを正しく設定すること
に興味が無ければ、ほんの少し脳みそに楽をさせる方をするのも時には便利で
しょう。

SOUP というファイル形式は、ニュースとメールをサーバーから家のマシンへと
転送し、それをまた戻すために開発されました。ちょっと面倒くさいかもしれ
ませんがね。

はじめにいくつか用語を:

"server"
     これは外の世界に繋がっていて、あなたがニュースやメールを送受信する
     マシンです。

"home machine"
     これはあなたが実際に読んだり返事を書いたりしたいマシンです。これは
     普通、他の世界といかなる形でも接続されていません。

"packet"
     メッセージや命令を含んでいる何か。パケットには二種類あります。

     "message packets"
          これはサーバーで作られるパケットで、普通はあなたが読むための
          たくさんのメッセージを含んでいます。これらはディフォルトでは
          `SoupoutX.tgz' という名前です。ここで X は数字です。

     "response packets"
          このパケットは自宅マシンで作られるパケットで、普通はあなたが
          書いた返事を含んでいます。これらはディフォルトでは
          `SoupinX.tgz' という名前です。ここで X は数字です。

  1. まずサーバーにログインして SOUP パケットを作りましょう。SOUP 専用
     に供されたもの (`awk' プログラムのようなもの) を使っても良いし、
     Gnus の SOUP 命令を使ってパケットを作っても良いです (`O s' や `G
     s b' に続いて `G s p') (*Note SOUP Commands::)。

  2. パケットを自宅に転送しましょう。電車に、船に、自動車に、あるいはモ
     デムに、でも結構です。

  3. パケットをあなたのホームディレクトリーに置きましょう。

  4. 基本サーバーか二次サーバーとして `nnsoup' バックエンドを使うように
     して、あなたの自宅のマシンで Gnus に火を入れましょう。

  5. ニュース記事やメールを読んで、必要なものに返事やフォロー記事を書き
     ましょう (*Note SOUP Replies::)。

  6. これらの返事を SOUP パケットにまとめるために、`G s r' 命令を実行し
     ましょう。

  7. このパケットをサーバーに転送しましょう。

  8. このパケットを Gnus の `G s s' 命令で送信しましょう。

  9. あとはこれを死ぬまで繰り返しましょう。

というわけで、読むために `nnsoup' を使い、それらの SOUP パケットをまと
めて送り出すためには Gnus を使うという分業システムが手に入りました。

* Menu:

* SOUP Commands::               SOUP パケットを作って送り出す命令
* SOUP Groups::                 SOUP パケットを読むためのバックエンド
* SOUP Replies::                メールとニュースを `nnsoup' に引き継がせる方法



File: gnus-ja.info, Node: SOUP Commands, Next: SOUP Groups, Prev: SOUP, Up: SOUP

SOUP 命令
.........

これらは SOUP パケットを作成して操作するための命令です。

`G s b'
     現在のグループのすべての未読記事をパケットにまとめます
     (`gnus-group-brew-soup')。このコマンドはプロセス/接頭引数の習慣に
     従います。

`G s w'
     すべての SOUP データファイルを保存します (`gnus-soup-save-areas')。

`G s s'
     返信パケットからすべての返信を送出します
     (`gnus-soup-send-replies')。

`G s p'
     すべてのファイルを SOUP パケットにまとめます
     (`gnus-soup-pack-packet')。

`G s r'
     すべての返信を返信パケットにまとめます (`nnsoup-pack-replies')。

`O s'
     この概略モード命令は、現在の記事を SOUP パケットに追加します
     (`gnus-soup-add-article')。これはプロセス/接頭引数の習慣に従います
     (*Note Process/Prefix::)。

Gnus がこれらすべてのものをどこに置くかをカスタマイズするための、いくつ
かの変数があります。

`gnus-soup-directory'
     SOUP パケットの作成中に Gnus が中間ファイルを保存するディレクトリー
     です。ディフォルトは `~/SoupBrew/' です。

`gnus-soup-replies-directory'
     返信パケットの送信中に Gnus が使用する一時ディレクトリーです。
     `~/SoupBrew/SoupReplies/' がディフォルトです。

`gnus-soup-prefix-file'
     Gnus が最後に使った接頭語を保存するファイル名です。ディフォルトは
     `gnus-prefix' です。

`gnus-soup-packer'
     SOUP パケットをまとめる命令を作るためのフォーマット文字列です。ディ
     フォルトは `tar cf - %s | gzip > $HOME/Soupout%d.tgz' です。

`gnus-soup-unpacker'
     SOUP パケットを取り出す命令を作るためのフォーマット文字列です。ディ
     フォルトは `gunzip -c %s | tar xvf -' です。

`gnus-soup-packet-directory'
     Gnus が返信パケットを探す場所です。ディフォルトは `~/' です。

`gnus-soup-packet-regexp'
     `gnus-soup-packet-directory' にある SOUP パケットに合致する正規表
     現です。



File: gnus-ja.info, Node: SOUP Groups, Next: SOUP Replies, Prev: SOUP Commands, Up: SOUP

SOUP グループ
.............

`nnsoup' は SOUP パケットを読むためのバックエンドです。これは入ってきた
パケットを読み込み、それを取り出し、あなたの都合が良いときにそこで読む
ディレクトリーに展開します。

これらはこの振る舞いをカスタマイズできる変数です:

`nnsoup-tmp-directory'
     `nnsoup' が SOUP パケットを展開するとき、このディレクトリー内で行
     ないます (ディフォルトは `/tmp/')。

`nnsoup-directory'
     次に `nnsoup' は、それぞれのメッセージと索引ファイルをこのディレク
     トリーに移動させます。ディフォルトは `~/SOUP/' です。

`nnsoup-replies-directory'
     すべての返信は、返信パケットにまとめられる前にこのディレクトリーに
     格納されます。ディフォルトは `~/SOUP/replies/' です。

`nnsoup-replies-format-type'
     返信パケットの SOUP 形式です。ディフォルトは `?n' (rnews) で、この
     変数には触るべきではないと私は思います。たぶん文書に明記すべきでさ
     えなかったね。しまった! もう手遅れか。

`nnsoup-replies-index-type'
     返信パケットの索引の種類です。ディフォルトは `?n' で、意味は「なし」
     です。これもいじるんじゃないよ!

`nnsoup-active-file'
     `nnsoup' がたくさんの情報を格納する場所です。これは `nntp' で言う
     ところの「アクティブファイル」ではなく、Emacs Lisp のファイルです。
     このファイルを無くしてしまったり、何か壊してしまったら、あなたは死
     にます。ディフォルトは `~/SOUP/active' です。

`nnsoup-packer'
     返信 SOUP パケットをまとめる命令を作るためのフォーマット文字列です。
     ディフォルトは `tar cf - %s | gzip > $HOME/Soupin%d.tgz' です。

`nnsoup-unpacker'
     入ってくる SOUP パケットを展開するための命令文字列の形式です。ディ
     フォルトは `gunzip -c %s | tar xvf -' です。

`nnsoup-packet-directory'
     入ってきたパケットを `nnsoup' が探す場所です。ディフォルトは `~/'
     です。

`nnsoup-packet-regexp'
     入ってきた SOUP パケットに合致する正規表現です。ディフォルトは
     `Soupout' です。

`nnsoup-always-save'
     `nil' 以外であれば、メッセージを一通投稿する度にその返信バッファー
     を保存します。



File: gnus-ja.info, Node: SOUP Replies, Prev: SOUP Groups, Up: SOUP

SOUP 返信
.........

単に `nnsoup' を使うだけで、自動的に送信したニュース記事やメールが
SOUP 返信パケットに納まるわけではありません。そうするためには、もうちょっ
と働かなくてはなりません。

`nnsoup-set-variables' 命令は、あなたのすべてのフォローアップ記事と返信
が SOUP システムの処理に渡るように、適切な変数を設定します。

具体的には、これが実際に行なわれることです。

     (setq message-send-news-function 'nnsoup-request-post)
     (setq message-send-mail-function 'nnsoup-request-mail)

本当にそれだけです。ニュース記事だけを SOUP システムに処理させたければ、
最初の行だけを使ってください。メールだけを SOUP させたいなら、二番目を
使ってください。



File: gnus-ja.info, Node: Mail-To-News Gateways, Prev: SOUP, Up: Other Sources

メールからニュースへのゲートウェイ
----------------------------------

あなたのローカルの `nntp' サーバーが何らかの理由で投稿を許可してい
なくても、数ある mail-to-news ゲートウェイを使って投稿することができます。
`nngateway' バックエンドはこのインターフェースを提供します。

このバックエンドからは何も読み出せないことに注意してください--これは投
稿するためだけに使われます。

以下はサーバー変数です。

`nngateway-address'
     これが mail-to-news ゲートウェイのアドレスです。

`nngateway-header-transformation'
     ニュースヘッダーは、mail-to-news ゲートウェイが受け付けられるよう
     に、何か奇妙なやり方で変形しておかなければならないことがしばしばで
     す。この変数はどんな変形処理が呼び出されるべきかを指示するもので、
     ディフォルトでは `nngateway-simple-header-transformation' になりま
     す。その関数は変形しようとするヘッダーの領域だけに狭められたバッ
     ファーで、ゲートウェイのアドレスを一つの引数として呼び出されます。

     ディフォルトの関数は、単に `Newsgroups' ヘッダーとゲートウェイのア
     ドレスに基づいた新しい `To' ヘッダーを挿入します。例えば、以下のよ
     うな `Newsgroups' ヘッダーを持つ記事には、

          Newsgroups: alt.religion.emacs

     次のような `To' ヘッダーが挿入されます。

          To: alt-religion-emacs@GATEWAY

     以下の関数が用意されています:

     `nngateway-simple-header-transformation'
          NEWSGROUP@`nngateway-address' のような `To' ヘッダーを作りま
          す。

     `nngateway-mail2news-header-transformation'
          `nngateway-address' のような `To' ヘッダーを作ります。

例です:

     (setq gnus-post-method
           '(nngateway
             "mail2news@replay.com"
             (nngateway-header-transformation
              nngateway-mail2news-header-transformation)))

したがってこれを使うには、単にこんな風にすれば良いでしょう:

     (setq gnus-post-method '(nngateway "GATEWAY.ADDRESS"))



File: gnus-ja.info, Node: Combined Groups, Next: Email Based Diary, Prev: Other Sources, Up: Select Methods

合併グループ
============

Gnus は、すべてのグループの種類を混合して、大きなグループに合併させるこ
とができます。

* Menu:

* Virtual Groups::              たくさんのグループの記事を合併する
* Kibozed Groups::              ニューススプールの中からの記事を検索する



File: gnus-ja.info, Node: Virtual Groups, Next: Kibozed Groups, Prev: Combined Groups, Up: Combined Groups

仮想グループ
------------

"nnvirtual" グループは、実は複数のグループを寄せ集めたものに過ぎません。

例えば、小さなグループをたくさん読むのが嫌になってきたら、それらを一つ
の大きなグループに入れて、嫌になるくらい巨大で手に負えないグループを読
むことができます。これはコンピューティングの醍醐味だね!

選択方法として `nnvirtual' を指定してください。アドレスは、それを構成す
るグループに合致する正規表現です。

仮想グループで付けられたすべての印は、その構成要素のグループの記事にくっ
つけられます。つまり、仮想グループで記事に可視記事の印を付けると、その
記事はもともとの構成要素のグループでも可視記事になります。(そして逆も成
り立ちます--構成要素のグループで付けた印は、仮想グループでも表示されま
す。)  空の仮想グループを作るには、グループバッファーで `G V'
(`gnus-group-make-empty-virtual') を実行し、`M-e'
(`gnus-group-edit-group-method') で選択方法の正規表現を編集してください。

これが、Andrea Dworkin に関するすべてのニュースグループを、一つの巨大で
シアワセなニュースグループにまとめる `nnvirtual' 選択方法の例です:

     (nnvirtual "^alt\\.fan\\.andrea-dworkin$\\|^rec\\.dworkin.*")

構成要素のグループは基本グループでも外部グループでも構いません。すべて
問題無く動くはずですが、もしあなたのコンピューターが爆発でもしてしまっ
たら、それはたぶん私が悪いんでしょうね。

利用者が (訳注: 記事を投稿する人たちが) Distribution ヘッダーを使って配
布範囲を制限している場合に、同じグループを複数のサーバーから寄せ集める
ことは、本当にうまい考えかもしれません。`soc.motss' を日本のサーバーと
ノルウェーのサーバーの両方から読みたければ、グループの正規表現として以
下のものを使うことができるでしょう:

     "^nntp\\+server\\.jp:soc\\.motss$\\|^nntp\\+server\\.no:soc\\.motss$"

(でもちょっと注意。`G m' でグループを作成するときは、バックスラッシュを
二重に付けてはいけません。そして文字列の最初と最後の引用記号 (`"..."')
も取り払ってください。)

これはまあ、すらすらと動作するはずです--両方のグループのすべての記事は
一つのグループに入り、重複も無いはずです。スレッド表示 (とその他) も通
常通り動作するでしょうけれど、記事の並ぶ順序には問題があるかもしれませ
ん。日付による並べ替えが、ここでは一つの選択肢になるかもしれません
(*Note Selecting a Group::)。

なお、ここで一つだけ制限があります--仮想グループに含まれるグループはす
べて生きている (すなわち購読または非購読の) 状態でなくてはなりません。
削除された (killed) グループあるいはゾンビのグループは `nnvirtual' グルー
プを構成するグループになることはできません。

`nnvirtual-always-rescan' 変数が `nil' でなければ (それ、つまり
非-`nil' がディフォルト)、`nnvirtual' は仮想グループに入ったときに常に
未読記事を走査します。この変数が `nil' になっていて、仮想グループを作っ
た後に構成要素のグループで記事を読んだ場合は、その構成要素のグループで
読まれた記事は、仮想グループに現れてしまうでしょう。共通な構成要素のグ
ループを持つ二つの仮想グループがある場合にも、この影響があります。そう
いう場合には、この変数を `t' にするべきです。さもなければ、仮想グループ
に入る度に、毎回その仮想グループの上で `M-g' を叩いても良いでしょう--こ
れにはほぼ同様の効果があります。

`nnvirtual' はメールとニュースの両方のグループを構成要素のグループにす
ることができます。`nnvirtual' グループの記事に返答するときは、
`nnvirtual' は記事の出所の構成要素のグループのバックエンドに、それが
ニュースのバックエンドであるかメールのバックエンドであるかを尋ねなけれ
ばなりません。しかし `^' をしたときには、普通は構成要素のバックエンドが
これを知るための確実な方法が無いので、その場合 `nnvirtual' は、Gnus に
記事はニュースではないバックエンドからやって来たと告げます。(単にそれが
安全な側なので。)

これらの場合にメッセージバッファーで `C-c C-n' を行なうと、応答しようと
している記事から `Newsgroups' 行を抜き出して挿入します。

`nnvirtual' グループは、記事と印以外は構成要素のグループから継承しませ
ん--例えばグループパラメーターもそうなのですが、それらは継承されません。



File: gnus-ja.info, Node: Kibozed Groups, Prev: Virtual Groups, Up: Combined Groups

Kiboze グループ
---------------

OED (オックスフォード英語大辞典) によれば、"Kiboze" する、とは、「ニュー
ススプール全体 (あるいはその一部) を grep すること」と定義されています。
`nnkiboze' はこれをあなたのために行なってくれるバックエンドです。嬉しい
なあ! これでどんな NNTP サーバーでも、要りもしない検索で止まってしまう
まで酷使することができるぞ。ああ、なんて幸せなんだ!

kiboze グループを作るには、グループバッファーで `G k' 命令を使ってくだ
さい。

`nnkiboze' 方法におけるアドレス欄は、`nnvirtual' と同様に、`nnkiboze'
に「含めたい」グループに合致する正規表現です。ここが `nnkiboze' と
`nnvirtual' バックエンドの最も類似している点です。

構成要素のグループを列挙するこの正規表現に加えて、`nnkiboze' グループに
は、グループ内のどの記事を含めるかを決めるスコアファイルがなくてはなり
ません (*Note Scoring::)。

あなたが欲しい `nnkiboze' グループを作成した後で、`M-x
nnkiboze-generate-groups' を実行しなければなりません。この命令は時間が
かかります。とってもかかります。すごく、すごーくかかります。Gnus はその
`nnkiboze' グループの一部となるべき記事があるかどうかを調べるために、全
部の構成要素のグループの全部の記事からヘッダーを取得し、それらすべてに
対してスコア処理を実行しなくてはならないのです。

限定した正規表現を使って、構成要素のグループの数を抑えてください。さも
ないと、システム管理者はあなたに閉口してしまい、NNTP サーバーからあなた
を追い出して二度と入れないようにしてしまうかもしれません。もっと変なこ
とだって起こりました。

`nnkiboze' を構成するグループは生きている必要はありません--死んでいても
良いし、外部グループでも構いません。無制限です。

`nnkiboze' グループを生成すると、二つのファイルが `nnkiboze-directory'
に書き込まれます。そのディフォルトは `~/News/kiboze/' です。一方はその
グループのすべての記事の NOV ヘッダー行を含み、もう一方は構成要素の記事
を見つけるためにどのグループが検索されたかの情報を格納する、`.newsrc'
の補助ファイルです。

既読になった `nnkiboze' グループの記事は、それらの記事の NOV 行が NOV
ファイルから削除されます。



File: gnus-ja.info, Node: Email Based Diary, Next: Gnus Unplugged, Prev: Combined Groups, Up: Select Methods

電子メールによる日程管理
========================

この章では `nndiary' という特別なメールバックエンドと、その仲間の
`gnus-diary' ライブラリーについて説明します。それが「特別」なのは、
Gnus でメールを読むための標準の選択肢の一つであるつもりは無いからです。
それ (標準の選択肢) については *Note Choosing a Mail Back End:: を参照
してください。代わりに、特別な方法であなたのメールの * いくつか* を扱う、
すなわちこれはリマインダー (予定を思い出させるもの) として使われます。

典型的な筋書きは、こうです。

   * あなたはアンディ・マクドウェルかブルース・ウィリス (あなたの好みに
     合わせて、どちらかを選んでください) と、一ヶ月後にデートの約束をし
     ました。それを忘れるわけにはいきません。
   * そこで、自分宛てにリマインダーのメッセージを (本当に毎日一通) 送る
     ことにしました。
   * あなたはそのことをすっかり忘れて、いつもどおりに新しいメールを取り
     込んで読み続けます。
   * デートの日が近付いてくると、グループバッファーで `g' をタイプした
     ときに、ときどきあなたの予定を思い出させるために、あたかも新着で未
     読のように、メッセージが再びポップアップするでしょう。
   * これが含まれている「新しい」メッセージたちを読んでください、そして、
     再びあなたが過ごす夜を夢見てください。
   * いったんデートが終わると (実際にはディナーのすぐ後で寝入ってしまっ
     たとしても)、期限切れ消去の印が付いていれば、メッセージは自動的に
     消去されます。

Gnus Diary バックエンドは、(常に取り消されることが無い) 定期的な予定を、
几帳面な人たちと同じように扱う能力を持っていて、本当のメールバックエン
ドのように動作し、いろんなやり方で設定することができます。このすべてが、
以下の各章で説明されています。

* Menu:

* The NNDiary Back End::        基本的な設定と使い方
* The Gnus Diary Library::      nndiary の上位階層にある実用的なツールキット
* Sending or Not Sending::      日程メッセージを送るときに注意すること



File: gnus-ja.info, Node: The NNDiary Back End, Next: The Gnus Diary Library, Prev: Email Based Diary, Up: Email Based Diary

NNDiary バックエンド
--------------------

`nndiary' は `nnml' (*Note Mail Spool::) にとてもよく似ているバックエン
ドです。現にそれは `nnml' と `nndraft' を合わせたものに見えるでしょう。
`nnml' をご存知ならば、あなたはすでに `nndiary' がメッセージを格納する
仕組み (一通あたり一つのファイル、一グループあたり一つのディレクトリー)
に精通しています。

何はさておき、`nndiary' をちゃんと動作させるには、一つの要件があります:
Gnus のグループの日付の機能を *使わなければなりません*。それがどういう
ふうに行なわれるかは *Note Group Timestamp:: を見てください。

* Menu:

* Diary Messages::              メッセージを nndiary で使えるようにするには
* Running NNDiary::             NNDiary には二つの動作モードがある
* Customizing NNDiary::         ベルとホイッスル



File: gnus-ja.info, Node: Diary Messages, Next: Running NNDiary, Prev: The NNDiary Back End, Up: The NNDiary Back End

日程メッセージ
..............

七つの特別なヘッダーが必須であること以外、`nndiary' のメッセージはまっ
たく普通のものです。それらのヘッダーは `X-Diary-<something>' の様式で表
され、`<something>' の部分は `Minute', `Hour', `Dom', `Month', `Year',
`Time-Zone' および `Dow' のうちの一つです。`Dom' は「日 (Day of Month)」
を、`Dow' は「曜日 (Day ofWeek)」を意味します。これらのヘッダーは
crontab の設定のように働いて、予定日を定義します。

   * `Time-Zone' のもの以外のすべてのヘッダーについて、ヘッダーの値は星
     印 (可能なすべての値を意味します) かコンマで区切られたフィールドの
     リストです。
   * フィールドは整数か範囲のどちらかです。
   * 範囲とは、ダッシュ (-) で区切られた二つの整数です。
   * 可能な値は、それぞれ `Minute' には 0--59、`Hour' には 0--23、
     `Dom' には 1--31、`Month' には 1--12、`Year' には 1971 より大きい
     値、そして `Dow' には 0--6 (0 が日曜日) です。
   * 特別な場合として、`Dom' または `Dow' のどちらか一方における星印は
     「可能なすべての値」ではなく、「もう一方のフィールドだけを使う」意
     味になります。両方とも星印にした場合は、どちらを使っても同じ結果に
     なることに注意してください。
   * `Time-Zone' ヘッダーは、値を一つしか持てない (例えば `GMT') 点で特
     別です。星印は「可能なすべての値」ではなく (それは意味をなさないの
     で)、「現在のローカルなタイムゾーン」を意味します。ここではたいて
     い星印を使うでしょう。しかし、利用できるタイムゾーンの値については、
     変数 `nndiary-headers' を見てください。

1999年から 2010年までの毎週月曜日と毎月の一日の 12:00, 20:00, 21:00,
22:00, 23:00 および 24:00 を設定するために、メッセージに加える日程ヘッ
ダーの具体例です (その時何をしたら良いかは、自分で考えてください):

     X-Diary-Minute: 0
     X-Diary-Hour: 12, 20-24
     X-Diary-Dom: 1
     X-Diary-Month: *
     X-Diary-Year: 1999-2010
     X-Diary-Dow: 1
     X-Diary-Time-Zone: *



File: gnus-ja.info, Node: Running NNDiary, Next: Customizing NNDiary, Prev: Diary Messages, Up: The NNDiary Back End

NNDiary を動かす
................

`nndiary' には二つの動作モードがあります。一つはディフォルトの「伝統型
(traditional)」、もう一つは「自律型 (autonomous)」です。伝統型のモード
では、`nndiary' はそれ自身が新着メールを取得することはありません。日程
メッセージとして扱うために、あなたはメールを基本のメールバックエンドか
ら nndiary グループに、移動 (`B m') またはコピー (`B c') しなければなり
ません。自律型のモードでは、`nndiary' はそれ自身のメールを取ってきて、
基本のメールバックエンドとは独立してそれを扱います。

本質的に Gnus は、同時に複数の「マスター」メールバックエンドを許容する
ようには設計されていなことに注意すべきです。しかし `nndiary' では、これ
は意味をなします。あなたは本当に、日程メッセージを日程グループに直接送っ
て、それらを受け取りたいのです。そこで `nndiary' は、まさに「二番目の第
一メールバックエンド」をサポートします (私が知っている限り、それはこの
機能を提供する唯一のバックエンドです)。しかしながら制約があって (いつの
日にか解消することを願いますが)、自律型のモードでは再スプールができませ
ん。

自律型のモードで `nndiary' を使うためには、いくつかのことをやってもらわ
なければなりません:

   * 新着メールを `nndiary' が自分で取り込めるようにします。以下の行を
     `~/.gnus.el' ファイルに記入してください:

          (setq nndiary-get-new-mail t)

   * 日程メッセージ (`X-Diary-*' ヘッダーを含んでいる) が、Gnus がそれ
     らを処理する *前* に専用のフォルダーに分配されるように、準備を行な
     わなければなりません。繰り返しますが、Gnus が複数の第一メールバッ
     クエンドを適切に扱うことが (まだ ?) できないので、これが必要です。
     別々のソースからそれらのメッセージを取り込むことによって、この欠点
     はある程度補われます。

     日程ファイルを `~/.nndiary' (これがディフォルトの `nndiary' のメー
     ルソース・ファイルです) に格納するための procmailrc の項目の例です:

          :0 HD :
          * ^X-Diary
          .nndiary

いったんこれを実施したら、日程メールの取り込みと分割の処理に影響する、
以下の二つのオプションをカスタマイズする必要があるでしょう:

 -- Variable: nndiary-mail-sources
     標準の `mail-sources' 変数の、日程用に特化した代替品です。同じ構文
     (syntax) を使い、ディフォルトは `(file :path "~/.nndiary")' です。

 -- Variable: nndiary-split-methods
     標準の `nnmail-split-methods' 変数の、日程用に特化した代替品です。
     同じ構文 (syntax) を使います。

最終的には `gnus-secondary-select-methods' に、恒久的な `nndiary' 仮想
サーバー (`(nndiary "diary")' が行なうべきであるようなもの) を追加して
も良いでしょう。

うまくいけば、Gnus を再起動すると、ほとんどすべて (`nndiary.el' の
TODO の項を参照) が期待通りに動作するでしょう。自律型のモードでは、`g'
や `M-g' をグループバッファーでタイプすれば新しい日程メールをも取り込ん
で、日程用に特化した規則に従ってそれらを分割するし、`F' は新しい日程グ
ループを見つけてくれる、など。



File: gnus-ja.info, Node: Customizing NNDiary, Prev: Running NNDiary, Up: The NNDiary Back End

NNDiary のカスタマイズ
......................

さあ `nndiary' が立ち上がって動作しています。それをカスタマイズするとき
が来ました。カスタマイズするためのグループは `nndiary' です (へえー)。
どのオプションをカスタマイズし倒したいかを見つけるために、それに目を通
してください。あなたが変更したいのは、おそらく以下のたった二つの変数で
しょう:

 -- Variable: nndiary-reminders
     予定を思い出させてもらいたい時刻のリスト (例えば三週間前、それから
     二日前、それから一時間前、そしてそのとき) です。「思い出させてもら
     う」の意味は、新着メールを取り込んだときに、日程メッセージが真新し
     く未読になって、ポップアップすることであることを思い出してください。

 -- Variable: nndiary-week-starts-on-monday
     読んで字の如し。さもなくば日曜日が仮定されます (それがディフォルト
     です)。



File: gnus-ja.info, Node: The Gnus Diary Library, Next: Sending or Not Sending, Prev: The NNDiary Back End, Up: Email Based Diary

Gnus Diary ライブラリー
-----------------------

`nndiary' を手作業で使うこと (ヘッダーを手で書くことなど) は、いささか
うんざりします。幸い `nndiary' の上位階層に書かれた `gnus-diary' という
ライブラリーがあって、たくさんの便利なことをやってくれます。

それを使うためには、以下の行を `~/.gnus.el' ファイルに加えてください:

     (require 'gnus-diary)

さらに、どんな `gnus-user-format-function-[d|D]' (*Note Summary Buffer
Lines::) も、使ってはいけません。`gnus-diary' はそれらの両方を提供しま
す (あなたがそれらを使っていたら、すみません)。

* Menu:

* Diary Summary Line Format::   より良い概略行仕様
* Diary Articles Sorting::      メッセージを並べ替える気の利いた方法
* Diary Headers Generation::    手作業でそれをしないで
* Diary Group Parameters::      手作業でそれらを扱わないで



File: gnus-ja.info, Node: Diary Summary Line Format, Next: Diary Articles Sorting, Prev: The Gnus Diary Library, Up: The Gnus Diary Library

日程の概略行仕様
................

標準の概略行仕様 (通常 `From Joe: Subject' のようなもの) で日程メッセー
ジを表示するのは、まったく役に立ちません。たいていはあなたがメッセージ
を書いた人で、おおかた予定の日付を見たいと思っているでしょう。

`gnus-diary' は、概略行仕様で使う二つの追加の利用者定義の書法仕様を提供
します。`D' は次の予定が生じるときのための整形された時刻表示 (例えば
“Sat, Sep 22 01, 12:00”) を表すのに対して、`d' は次の予定が生じるまで
のおおよその残り時間 (例えば“in 6 months, 1 week”) を表します。

ジョーの誕生日が、概略行にどう表示されるかの例です (定期的な予定を指定
すると消されないことを除いて、メッセージが期限切れ消去可能であることに
気を付けてください):

        E  Sat, Sep 22 01, 12:00: Joe's birthday (in 6 months, 1 week)

上記のようなものを得るために、普段だったら、あなたは以下の行を日程グルー
プのパラメーターに加えようとするでしょう:

     (gnus-summary-line-format "%U%R%z %uD: %(%s%) (%ud)\n")

しかし `gnus-diary' はそれを自動で行ないます (*Note Diary Group
Parameters::)。それでもあなたは、以下のユーザー・オプション群で提供され
る概略行仕様を、カスタマイズすることができます:

 -- Variable: gnus-diary-summary-line-format
     日程グループのために使われる概略行仕様を定義します (*Note Summary
     Buffer Lines::)。`gnus-diary' はそれを、日程グループのパラメーター
     を自動で更新するために使います。

 -- Variable: gnus-diary-time-format
     日程の概略バッファーに日付を表示するための書法仕様を定義します。こ
     れは利用者定義の書法仕様 `D' で使われます。詳細は変数の説明文を見
     てください。

 -- Variable: gnus-diary-delay-format-function
     日程の概略バッファーに遅延 (残り時間) を表示するための整形関数を定
     義します。これは利用者定義の書法仕様 `d' で使われます。現在は英語
     とフランス語のための組み込み関数があり、自分で定義することもできま
     す。詳細は変数の説明文を見てください。



File: gnus-ja.info, Node: Diary Articles Sorting, Next: Diary Headers Generation, Prev: Diary Summary Line Format, Up: The Gnus Diary Library

日程記事の並べ替え
..................

`gnus-diary' は並べ替え (*Note Sorting the Summary Buffer::) のために
`gnus-summary-sort-by-schedule'、`gnus-thread-sort-by-schedule' および
`gnus-article-sort-by-schedule' という新しい関数を提供します。これらの
関数によって、最も近い予定から最も遠い方まで、日程の概略バッファーを整
理することができます。

`gnus-diary' は自動的に概略バッファーの「並べ替え (sort)」メニューに
`gnus-summary-sort-by-schedule' を組み込み、他の二つを第一次の (ゆえに
ディフォルトの) 並べ替え関数として、グループパラメーター (*Note Diary
Group Parameters::) に登録します。



File: gnus-ja.info, Node: Diary Headers Generation, Next: Diary Group Parameters, Prev: Diary Articles Sorting, Up: The Gnus Diary Library

日程ヘッダーの生成
..................

`gnus-diary' は、`X-Diary-*' ヘッダーの取り扱いを補佐するために、
`gnus-diary-check-message' という関数を提供します。この関数は、現在のメッ
セージがすべての必要な日程ヘッダーを確実に含むようにして、必要ならば値
を入力するか修正することを要求します。

記事を日程グループに移動またはコピーすることによって自動的にそれが発動
されるようにするために、この関数は `nndiary' バックエンドのフックとして
組み入れられています。それはさらに、通常のメールを日程用のものに変換す
る操作を簡単にするために、`message-mode' と `article-edit-mode' におい
て `C-c C-f d' キーとして設定もされています。

接頭引数を伴ってこの関数を呼ぶと、それらがあるか、正しいかどうかとは無
関係に、日程ヘッダーの入力を強制します。そうやって、例えばすでに正しく
設定されたメッセージの日程を、とても簡単に変更することができます。



File: gnus-ja.info, Node: Diary Group Parameters, Prev: Diary Headers Generation, Up: The Gnus Diary Library

日程グループのパラメーター
..........................

新しい日程グループを作るか、またはそれを開くと、`gnus-diary' は自動的に
グループパラメーターを検査し、必要なら概略行仕様を日程用に特化した値に
設定し、日程用の並べ替え関数を組み込み、さらにそのグループの投稿様式
(posting-style) に種々の `X-Diary-*' ヘッダーを加えます。そして、日程メッ
セージを送るのは、もっと簡単です。メッセージを用意するために、日程グルー
プで `C-u a' か `C-u m' を使うことによって、これらのヘッダーが自動的に
挿入されるので (まだ適切な値で満たされていませんが)。



File: gnus-ja.info, Node: Sending or Not Sending, Prev: The Gnus Diary Library, Up: Email Based Diary

送信するべきか、しないべきか
----------------------------

さて、以上の説明をすべて読んでくれたものとして、以下は `nndiary' でメー
ルを送信することに関する、二つの最後の注意事項です:

   * `nndiary' は *本当の* メールバックエンドです。本当にあなたは本当の
     日程メッセージを本当に送ります。これは、日程メッセージを送ることに
     よって、誰にでも (彼らが Gnus と `nndiary' を使っているのならば)
     予定を伝えることができることをも意味します。
   * しかしながら `nndiary' は `request-post' メソッドを持ってもいるの
     で、日程グループで `C-u m' の代わりに `C-u a' を使うことによって、
     メッセージを実際に送信するのではなく、そのグループにローカルに格納
     することもできます。これは個人的な予定のためには、とても役に立ちま
     す。



File: gnus-ja.info, Node: Gnus Unplugged, Prev: Email Based Diary, Up: Select Methods

Gnus の切り離し
===============

いにしえの時代 (およそ 1988年2月頃)、人々はニュースリーダーをネットワー
クに常時接続した大きなマシンで走らせていました。ニュースの配送はニュー
スサーバーによって取り扱われ、すべてのニュースリーダーがすべきことは
ニュースを読むことであったのです。信じられないかもしれませんが。

今日では多くの人々は自宅でニュースやメールを読み、ネットワークに接続す
るためにモデムの類を使います。電話代の請求書が莫大なものに上らないよう
に、すべてのニュースとメールをすすり込んで電話を切り、数時間かけて読ん
でから送りたい返信をすべて送信する、という手段を持つことは良いことでしょ
う。あとはこの手順を繰り返すのです。(訳注: この章の前身は 1997年頃に書
かれました。)

もちろん、これを行なうためにニュースサーバーを使うこともできます。私は
`inn' を `slurp', `pop', `sendmail' と一緒にここ数年使ってきましたが、
しかしこれは退屈な仕事です。もしあるマシン上でニュースを読む人があなた
しかいなければ、ニュースサーバーの機能をニュースリーダーに任せるように
することは理にかなっています。

Gnus を「オフライン」のニュースリーダーとして仕立てるのは極めて簡単です。
実際、エージェントは今やディフォルトで有効になっている (*Note
gnus-agent: Agent Variables.) ので、あなたは何も設定する必要が無いので
す。

もちろん、これをそんなふうに使うには、いくつか新しい命令を覚えなくては
なりません。

* Menu:

* Agent Basics::                これらはどう動くのか
* Agent Categories::            何をダウンロードするかを Gnus エージェントに教える方法
* Agent Commands::              各バッファーでの新しい命令
* Agent Visuals::               概略バッファーが変化するかもしれないエージェントの所業
* Agent as Cache::              エージェントは大きなキャッシュでもある
* Agent Expiry::                古い記事を追い払う方法
* Agent Regeneration::          通信切断や他の事故から回復する方法
* Agent and flags::             エージェントはどうフラグを維持するのか
* Agent and IMAP::              エージェントを IMAP で使う方法
* Outgoing Messages::           ニュースやメールを出すときになにが起こるのか?
* Agent Variables::             カスタマイズは楽し
* Example Setup::               オフライン人間のための `~/.gnus.el' の例
* Batching Agents::             `cron' ジョブでニュースを取得する方法
* Agent Caveats::               あなたが予想することと、それが実際にすること



File: gnus-ja.info, Node: Agent Basics, Next: Agent Categories, Prev: Gnus Unplugged, Up: Gnus Unplugged

エージェントの基礎
------------------

まず、いくつかの用語を片付けておきましょう。

ネットワークとの接続を切っているとき (かつエージェントにそのことを知ら
せてあるとき)、Gnus エージェントは "unplugged" です、と言います。ネット
ワークとの接続が復活したら (かつ Gnus がそのことを知っていれば)、エージェ
ントは "plugged" です。

「ローカル」マシンとは、あなたがそこで作業しているもので、継続的にネッ
トワークに接続されているわけではありません。

「ダウンロード」とは、あなたのローカルマシンに、何かをネットワークから
取ってくることを意味します。「アップロード」はその逆をすることです。

ご存知のように Gnus はあなたがドジを踏むすべての機会を提供します。それ
を柔軟性と言う人もいます。さらに Gnus は大いにカスタマイズ可能で、それ
は利用者が、Gnus がどのように動作するかについて発言権を持っていることを
意味します。他のニュースリーダーは有無を言わずあなたにドジを踏ませるか
もしれませんが、Gnus ではあなたに選択権があります!

Gnus は実際には plugged または unplugged のどちらの状態にもありません。
もっと正確に言えば、サーバーごとにそれぞれの状態を持ちます。これは、い
くつかのサーバーが unplugged でも、他のサーバーは plugged になることが
できるということです。さらに、エージェントがいくつかのサーバーをまとめ
て無視する (それらを常に plugged になっているように見せかける) ようにも
できます。

さて、エージェントを unplugged にしたのに Gnus がネットに接続しているの
を疑問に思ったら、行なうべき次のステップはサーバーがすべてエージェント
化されているかどうかを確かめることです。エージェント化されていないサー
バーがあったら、あなたは犯人を見つけたのです。

もう一つは「オフライン」という状態です。サーバーはときどき接続できなく
なります。Gnus がこのことに気付くと、そのサーバーをオフラインの状態に切
り換えても良いかどうかを尋ねます。Yes と答えたならば (オンラインに戻し
て良いかと Gnus が尋ねた場合以外は)、サーバーはいくらか unplugged だっ
たときのように振る舞います。

エージェントを使った典型的な Gnus の対話操作を見てみましょう:

   * Gnus を `gnus-unplugged' で起動します。これは unplugged で Gnus エー
     ジェントを立ち上げます。このモードでは、すでに取得しているニュース
     記事はすべて読むことができます。

   * 次に、新しいニュースが到着しているかどうかを調べることにします。マ
     シンをネットワークに (PPP か何かを使って) 接続してから Gnus を
     plugged" にするために `J j' を叩き、いつものように新着メールを検査
     するために `g' を使います。Gnus エージェントが unplugged になって
     いるときに新着メールを検査するには、*Note Mail Source
     Specifiers:: を参照してください。

   * そうすれば、直ちに新しいニュースを読むこともできるし、ニュースをロー
     カルマシンにダウンロードすることもできます。後者を実行したいときは、
     `g' を押して新しいニュースがあるかどうかを検査し、次に `J s' です
     べてのグループのすべての適格な (訳注: あなたが指定した条件に合致す
     る) 記事を取得します。(どの記事をダウンロードしたいかを Gnus に指
     示するには *Note Agent Categories:: を参照してください。)

   * 記事を取得した後で `J j' を押し、Gnus を再び unplugged にして、
     PPP の接続 (か何か) を閉じます。その後でニュースをオフラインで読み
     ます。

   * そして第二ステップに戻ります。

エージェントを初めて使うときは (またはそのくらいの時期に)、以下のいくつ
かの作業をしなければなりません。

   * どのサーバーをエージェントで面倒を見るかを決めます。メールのバック
     エンドをエージェントに面倒を見させるのはおそらく無意味でしょう。サー
     バーバッファーに移動し (グループバッファーで `^')、エージェントに
     扱って欲しいサーバー (複数可) で `J a' を押す (*Note Server Agent
     Commands::) か、またはエージェントに扱って欲しくないのに自動的に追
     加されたサーバーで `J r' を押します。ディフォルトでは
     `gnus-select-method' と `gnus-secondary-select-methods' にあるすべ
     ての `nntp' と `nnimap' サーバーがエージェント化されます。

   * ダウンロード方針を決定します。あなたの方針を実装するために、エージェ
     ント分類、トピックパラメーター、グループパラメーターのどれを使うか
     をいったん決めてしまえば、これはかなり簡単です。あなたが Gnus の初
     心者ならば、たぶん分類で始めるのが最良でしょう、*Note Agent
     Categories::.

     トピックパラメーター (*Note Topic Parameters::) とエージェント分類
     (*Note Agent Categories::) の両方とも、多数のグループに適用する方
     針の設定を用意しています。どれを使うかは完全にあなたの責任です。両
     方を混ぜて使う場合は、トピックパラメーターは分類を無効にすることを
     考慮に入れなければならないでしょう。あなたの方針にそぐわない少数の
     グループがあるのならば、それらの設定を変更するためにグループパラメー
     ター (*Note Group Parameters::) を使うことができます。

   * ええと...、以上です。



File: gnus-ja.info, Node: Agent Categories, Next: Agent Commands, Prev: Agent Basics, Up: Gnus Unplugged

エージェント分類
----------------

ニュースを配送する機構をニュースリーダーに統合する主要な理由の一つは、
どの記事をダウンロードするかについて、もっと強力に制御できるようにする
ことです。莫大な量の記事をダウンロードすることにあまり意味はなく、それ
らを読んでもあまり面白くないことが分かるだけです。何をダウンロードする
かの選択ではもう少し保守的になって、その記事がやっぱり面白そうだとわかっ
たら、主動でダウンロードするための印を付ける方がすぐれています。

何をダウンロードするかを制御するためのより有効な方法の一つは、分類
("category") を作成して、その分類にいくつか (または全部) のグループを割
り当てることです。どんな分類にも属さないグループは「ディフォルト」の分
類に属します。Gnus は分類の作成と管理のための独自のバッファーを持ってい
ます。

もしそうしたければ、グループパラメーター (*Note Group Parameters::) と
トピックパラメーター (*Note Topic Parameters::) を、エージェントを制御
する代替手段に使うことができます。実際に違うのは、グループとトピックパ
ラメーターが何でもかんでも (kitchen sink) 含むのに対して、分類はエージェ
ントに特化している (したがってあまり学ばなくても良い) ということだけで
す。

エージェントパラメーターは複数の違う場所で設定することができるので、ど
のソースが信用できるかを決めるための規則を設けました。この規則は、パラ
メーターのソースが次の順序で調べられることを定めます: グループパラメー
ター、トピックパラメーター、エージェント分類、そして最後はカスタマイズ
できる変数群です。したがって、広い範囲で動作を起こさせるためにこれらの
ソースをすべて混合することができます。どこに設定を置いたのかを忘れてし
まったからといって、私を責めないでくださいよ。

* Menu:

* Category Syntax::             分類とはどんなものか
* Category Buffer::             分類を管理するバッファー
* Category Variables::          カスタマイザ"ら"ス



File: gnus-ja.info, Node: Category Syntax, Next: Category Buffer, Prev: Agent Categories, Up: Agent Categories

分類の文法
..........

分類は、名前、その分類に属するグループのリスト、およびカスタマイズ可能
な変数よりも優先される多くの任意なパラメーターから成ります。エージェン
トパラメーターの完全なリストを以下に示します。

`agent-groups'
     この分類にあるグループのリスト。

`agent-predicate'
     (通常) どの記事をダウンロードするのが適当かという大まかな輪郭を与
     える述語。そして

`agent-score'
     (通常) どの記事をダウンロードするかを決めるときのよりきめの細かい
     スコア規則。(このダウンロードスコア ("download score") は通常のス
     コアとは必ずしも関係が無いことに注意してください。)

`agent-enable-expiration'
     このグループの古い記事をエージェントが期限切れ消去すべきかどうかを
     示すブール変数。大抵のグループはディスク空間を浪費しないために期限
     切れ消去されるべきです。いや、実際には gnus.* 階層は期限切れ消去さ
     れるべきではないグループだけを含んでいると言っても、たぶん差し支え
     ありません。

`agent-days-until-old'
     既読の記事を期限切れ消去しても差し支えないことを判断する前に、エー
     ジェントが待っているべき日数を示す整数。

`agent-low-score'
     `gnus-agent-low-score' よりも優先される整数。

`agent-high-score'
     `gnus-agent-high-score' よりも優先される整数。

`agent-short-article'
     `gnus-agent-short-article' よりも優先される整数。

`agent-long-article'
     `gnus-agent-long-article' よりも優先される整数。

`agent-enable-undownloaded-faces'
     ダウンロードされていない記事を `gnus-summary-*-undownloaded-face'
     のフェース群を使って概略バッファーに表示すべきかどうかを示すシンボ
     ル。`nil' 以外ならどんなシンボルでも、ダウンロードされていない記事
     用のフェースを使うようになります。

いったん分類が作られたら、分類の名前を変えることはできません。

それぞれの分類は、その分類の排他的な (他の分類には無い) メンバーである
グループのリストを維持します。排他規則は自動的に執行され、新しい分類に
グループを追加すると、それは古い分類から自動的に取り除かれます。

述語の一番単純な形式は `true' や `false' のような単独の述語からなります。
これらの二つはそれぞれ、すべての可能な記事をダウンロードするか、まった
く何もしないか、です。これらの二つの特別な述語の場合は、追加のスコア規
則は不要です。

`high' や `low' という述語は下で説明されているように、
`gnus-agent-high-score' と `gnus-agent-low-score' との記事のスコアとの
関係により記事をダウンロードします。

何をもってダウンロードすることが適格だと見なされるかについて、さらに細
かい制御を得るために、述語は論理演算子が間に散りばめられた述語の組み合
わせからなることができます。

おそらくいくつかの例が必要でしょう。

以下は簡単な述語です。(これはディフォルトの述語です。実際に他のどの分類
にも含まれないすべてのグループに対して使用されます。)

     short

とっても簡単でしょ? この述語は、記事が短い (「短い」ことを意味する何ら
かの価値がある) 場合に限り真になります。

これはもっと複雑な述語です:

     (or high
         (and
          (not low)
          (not long)))

この意味は、高いスコアを持っているか、あるいはスコアが低くなくてかつ長
くない、という記事をダウンロードする、ということです。様子はわかりまし
たね。

使ってもよい論理演算子は `or', `and' および `not' です。(もし使いたけれ
ば、より“C”風の演算子 `|', `&', `!' を代りに使うことができます。)

以下の述語があらかじめ定義されていますが、これらのどれもあなたのやりた
いことに適さなければ、自分で独自のものを書くこともできます。

それぞれのこれらの述語を評価するとき、名前が付けられた定数は、適切なパ
ラメーターを与えて `gnus-agent-find-parameter' を呼ぶことによって決定さ
れる値に束縛されます。例えば gnus-agent-short-article は
`(gnus-agent-find-parameter group 'agent-short-article)' に束縛されます。
これは、あなたの分類で述語を指定してから、その述語を個々のグループにつ
いて調整できることを意味します。

`short'
     記事が `gnus-agent-short-article' の行数より短かければ真です。ディ
     フォルトは 100 です。

`long'
     記事が `gnus-agent-long-article' の行数より長ければ真です。ディフォ
     ルトは 200 です。

`low'
     記事のダウンロードスコアが `gnus-agent-low-score' の値より小さけれ
     ば真です。ディフォルトは 0 です。

`high'
     記事のダウンロードスコアが `gnus-agent-high-score' の値より大きけ
     れば真です。ディフォルトは 0 です。

`spam'
     Gnus エージェントがその記事を spam だと推測した場合に真です。この
     検出法は今後変更されるかもしれませんが。現時点では、これはチェック
     サムを計算し、記事が一致するかどうかを調べているだけです。

`true'
     常に真です。

`false'
     常に偽です。

独自の述語関数を作成したければ、このことを知っておかなければなりません:
関数は引数無しで呼び出されますが、`gnus-headers' と `gnus-score' という
動的な変数が有意な値に束縛されるということを。

例えば、一定の日数以上前に投稿された記事 (例えば
`gnus-agent-expire-days' の日数以上前に投稿されたもの) をダウンロードし
ないと決断することもできます。その場合、以下のような関数を書いて、

     (defun my-article-old-p ()
       "Say whether an article is old."
       (< (time-to-days (date-to-time (mail-header-date gnus-headers)))
          (- (time-to-days (current-time)) gnus-agent-expire-days)))

そして述語はこのように定義すれば良いでしょう:

     (not my-article-old-p)

もしくは `~/.gnus.el' か何かで、あらかじめ定義されている
`gnus-category-predicate-list' の値に、自分の述語を追加することもできま
す。

     (require 'gnus-agent)
     (setq gnus-category-predicate-alist
           (append gnus-category-predicate-alist
                   '((old . my-article-old-p))))

この場合は、次のように述語を指定するだけです:

     (not old)

上のようなものを使うときは、世の中には正しく設定されていないシステム/メー
ラーがあり、記事の日付はいつ投稿されたかを常に確実に示すわけではないこ
とを知っていてください。困ったことに、それを少しも気にかけない人もいる
んです。

上記の述語はその分類に属する *すべて* のグループに適用されます。しかし、
分類中の個々のグループのための特定の述語を設定したかったり、単に不精を
決め込んで新しい分類を設定したくないのならば、グループの個々の述語を次
のようにグループパラメーターに入れることができます:

     (agent-predicate . short)

これは agent 分類のディフォルトと等価なグループ/トピックパラメーターで
す。このように単一の語で述語を指定するときは、`agent-predicate' の設定
値はドット対で表記しなければならないことに注意してください。

上のものと等価な長い方の例はこうなるでしょう:

     (agent-predicate or high (and (not low) (not long)))

述語の値がドット対で表記されていなくて、その値はリストだと仮定されるの
で、分類の設定で要求される外側の括弧が、ここでは入れられません。

さて、ダウンロードスコアの文法は通常のスコアファイルの文法と同じですが、
例外があります。記事そのものを実際に調べる必要がある要素は厳禁です。つま
り、以下のヘッダーだけがスコア付けできるということです: `Subject',
`From', `Date', `Message-ID', `References',
`Chars', `Lines' および `Xref'。

述語の場合のように、`ダウンロードスコア規則' の設定は、それをグループに
関して使う限りは、そこのすべてのグループに適用できるものならば分類の定
義、グループに特有ならばグループパラメーター、のどちらかにできます。

これら両方の場所で、`ダウンロードスコア規則' は以下の三つの形式の一つを
取ることができます:

  1. スコア規則

     上で書かれているように、スコア付けキーワードの一部分しか使えないこ
     とを除けば、これは普通の Gnus スコアファイルの構文と同じです。

     例:

        * 分類指定

               (("from"
                      ("Lars Ingebrigtsen" 1000000 nil s))
               ("lines"
                      (500 -100 nil <)))

        * グループ/トピックパラメーター指定

               (agent-score ("from"
                                  ("Lars Ingebrigtsen" 1000000 nil s))
                            ("lines"
                                  (500 -100 nil <)))

          ここでも一番外側の括弧が省略されていることに注意してください。

  2. エージェントスコアファイル

     これらのスコアファイルは、上で述べられている使用可能なスコア付けキー
     ワード *だけ* を含んでいなければなりません。

     例:

        * 分類指定

               ("~/News/agent.SCORE")

          または、もしかすると

               ("~/News/agent.SCORE" "~/News/agent.group.SCORE")

        * グループパラメーター指定

               (agent-score "~/News/agent.SCORE")

          ここでも前述のように、追加のスコアファイルを指定することがで
          きます。括弧について言わなければいけませんか?

  3. `普通' のスコアファイルの使用

     あるグループのためにあなたが望んだ「ダウンロード」の基準が、「読む」
     基準と同じならば、一つのグループのために二つのスコア規則を維持管理
     したいとは思わないでしょう。そういう場合は、何をダウンロードするか
     を決める際に、エージェントに `普通' のスコアファイルを参照させるこ
     とができます。

     分類の定義やグループパラメーターでこれらの指示を行なうと、エージェ
     ントはあるグループに適用することができるすべてのスコアファイルを読
     み込んで、使うことが許されているスコア付けキーワードの副セットでは
     ない項目を *選別して取り除きます*。

        * 分類指定

               file

        * グループパラメーター指定

               (agent-score . file)



File: gnus-ja.info, Node: Category Buffer, Next: Category Variables, Prev: Category Syntax, Up: Agent Categories

分類バッファー
..............

通常すべての分類は分類バッファーから管理します。これに (グループバッ
ファーで `J c' 命令を使って) 初めて入ると、ディフォルトの分類だけが表示
されます。

このバッファーでは以下の命令を使うことができます:

`q'
     グループバッファーに戻ります (`gnus-category-exit')。

`e'
     選択された分類のパラメーターを一括して設定するために、カスタマイズ
     バッファーを使います (`gnus-category-customize-category')。

`k'
     現在の分類を消去します (`gnus-category-kill')。

`c'
     現在の分類を複製します (`gnus-category-copy')。

`a'
     新しい分類を追加します (`gnus-category-add')。

`p'
     現在の分類の述語を編集します (`gnus-category-edit-predicate')。

`g'
     現在の分類に属するグループのリストを編集します
     (`gnus-category-edit-groups')。

`s'
     現在の分類のダウンロードスコア規則を編集します
     (`gnus-category-edit-score')。

`l'
     すべての分類を表示します (`gnus-category-list')。



File: gnus-ja.info, Node: Category Variables, Prev: Category Buffer, Up: Agent Categories

分類変数
........

`gnus-category-mode-hook'
     分類バッファーで実行するフックです。

`gnus-category-line-format'
     分類バッファーの行様式です (*Note Formatting Variables::)。有効な
     要素は:

     `c'
          分類の名前です。

     `g'
          その分類に属するグループの数です。

`gnus-category-mode-line-format'
     分類モード行の様式です (*Note Mode Line Formatting::)。

`gnus-agent-short-article'
     この値より少ない行数の記事は短いと見なします。ディフォルトは 100
     です。

`gnus-agent-long-article'
     この値より多い行数の記事は長いと見なします。ディフォルトは 200 で
     す。

`gnus-agent-low-score'
     この値より小さいスコアを持つ記事は低スコアだと見なします。ディフォ
     ルトは 0 です。

`gnus-agent-high-score'
     この値より大きいスコアを持つ記事は高スコアだと見なします。ディフォ
     ルトは 0 です。

`gnus-agent-expire-days'
     期限切れ消去する前に、既読記事をエージェントのローカルディスクに留
     めておかなければならない日数 (「期限切れ消去」という名前は同じです
     が、サーバーで期限切れ消去することではありません。単に記事のローカ
     ルな複製を消すことを意味します)。さらに理解すべき大事なことは、記
     事が読まれた時ではなくローカルディスクに記事が書かれた時から計数が
     始まるということです。ディフォルトは 7日です。

`gnus-agent-enable-expiration'
     グループの記事が、ディフォルトで期限切れ消去されるか、無期限に保持
     されるかを決定します。ディフォルトは `ENABLE' で、あなたが望むなら
     ば期限切れ消去をさせないようにしなければならないことを意味します。
     一方、これを `DISABLE' に設定することができます。その場合、選択さ
     れたグループでの期限切れ消去を有効にしなければなりません。



File: gnus-ja.info, Node: Agent Commands, Next: Agent Visuals, Prev: Agent Categories, Up: Gnus Unplugged

エージェント命令
----------------

すべての Gnus エージェント命令は `J' サブマップにあります。`J j'
(`gnus-agent-toggle-plugged') 命令はすべてのモードで動作し、Gnus エージェ
ントの plugged/unplugged 状態を切り替えます。

* Menu:

* Group Agent Commands::        グループを設定してそれらの記事を取得する
* Summary Agent Commands::      手動で記事を選択し、指定した取得する
* Server Agent Commands::       エージェントでサポートされるサーバーの選択



File: gnus-ja.info, Node: Group Agent Commands, Next: Summary Agent Commands, Prev: Agent Commands, Up: Agent Commands

グループエージェント命令
........................

`J u'
     現在のグループの適格な (訳注: あなたが指定した条件に合致する) 記事
     をすべて取得します (`gnus-agent-fetch-groups')。

`J c'
     エージェント分類バッファーに入ります
     (`gnus-enter-category-buffer')。

`J s'
     全グループの適格な (訳注: あなたが指定した条件に合致する) 記事をす
     べて取得します (`gnus-agent-fetch-session')。

`J S'
     順番待ち (queue) グループにある送信可能なメッセージをすべて送信し
     ます (`gnus-group-send-queue')。*Note Drafts::.

`J a'
     現在のグループをエージェント分類に追加します
     (`gnus-agent-add-group')。この命令はプロセス/接頭引数の習慣を理解
     します (*Note Process/Prefix::)。

`J r'
     現在のグループを、もし存在していれば、その分類から消去します
     (`gnus-agent-remove-group')。この命令はプロセス/接頭引数の習慣を理
     解します。(*Note Process/Prefix::)。

`J Y'
     リモートサーバーが unplugged のときに変更されたフラグがあれば同期
     させます。



File: gnus-ja.info, Node: Summary Agent Commands, Next: Server Agent Commands, Prev: Group Agent Commands, Up: Agent Commands

概略エージェント命令
....................

`J #'
     記事にダウンロード印を付けます (`gnus-agent-mark-article')。

`J M-#'
     記事からダウンロード印を消去します (`gnus-agent-unmark-article')。

`@'
     記事をダウンロードするかどうかを切り替えます
     (`gnus-agent-toggle-mark')。ディフォルトではダウンロードの印は
     `%' です。

`J c'
     キャッシュされていない、ダウンロードされていない、またはダウンロー
     ドできないすべての記事を既読にします (`gnus-agent-catchup')。

`J S'
     このグループのすべての望ましい (訳注: あなたが指定した条件に合致す
     る) 記事 (*Note Agent Categories::) をダウンロードします。
     (`gnus-agent-fetch-group')。

`J s'
     このグループのすべてのプロセス印が付いた記事をダウンロードします。
     (`gnus-agent-summary-fetch-series')。

`J u'
     現在のグループのダウンロード可能な記事を、すべてダウンロードします
     (`gnus-agent-summary-fetch-group')。



File: gnus-ja.info, Node: Server Agent Commands, Prev: Summary Agent Commands, Up: Agent Commands

サーバーエージェント命令
........................

`J a'
     現在のサーバーを Gnus エージェントで扱われるサーバーのリストに追加
     します (`gnus-agent-add-server')。

`J r'
     現在のサーバーを Gnus エージェントで扱われるサーバーのリストから削
     除します (`gnus-agent-remove-server')。



File: gnus-ja.info, Node: Agent Visuals, Next: Agent as Cache, Prev: Agent Commands, Up: Gnus Unplugged

エージェントの視覚効果
----------------------

Unplugged のときに概略を開くと、現在エージェントに格納されているヘッダー
よりも多くの記事があることを Gnus がそのグループの active (訳注: 何番か
ら何番までの記事があるかを示す管理情報) の範囲から知っている場合には、
表題が `[Undownloaded article #####]' のようになっているいくつかの記事
を見るかもしれません。それらは見当たらないヘッダーのための穴埋め
(placeholders) です。印を設定することは別として、それらの穴埋めの一つで
できることは多くはありません。最終的に Gnus がグループのヘッダーを取っ
て来る機会を得たときに、それらの穴埋めは実際のヘッダーで自動的に置き換
えられるでしょう。気になるならば、それらの穴埋めを読み飛ばすために、概
略バッファーの動作を操作することができます (`gnus-auto-goto-ignores' 参
照)。

すべての人にとって明白かもしれませんが、オフラインのときに利用できるの
は、plugged だった期間にエージェントに取り込まれたヘッダーと記事だけで
す。言い換えると「plugged だった期間に取り込むことを忘れると、オフライ
ンのセッションを満足できるものにするには足りない」ということです。この
理由のために、エージェントは概略バッファーに二つの視覚効果を加えます。
これらの効果は、オフラインのときにどの記事が利用できるかをいつも知らせ
るために、それぞれの記事のダウンロードの状態を表示します。

第一の視覚効果は `%O' 仕様です。`gnus-summary-line-format' をカスタマイ
ズしてこの指示子を含めると、記事のダウンロードの状態を示すために単一の
文字を表示する場所が加わります。エージェントかキャッシュのどちらかに取
り込まれた記事は、`gnus-downloaded-mark' (ディフォルトは `+') を表示し
ます。それら以外のすべての記事は `gnus-undownloaded-mark' (ディフォルト
は `-') を表示します。エージェント化されていないグループを開くと、空白
(` ') が表示されます。

第二の視覚効果はダウンロードされていないことを示すフェースです。多くの
Gnus の利用者に好感と嫌悪をもたらすであろう、記事のスコアを三段階
(low, normal, high) で表示するフェースがあります。問題は、フェースの選
択が条件検査とフェース名のリスト (`gnus-summary-highlight' 参照) によっ
て制御されることです。それぞれの条件は、それがリストの中に現れる順に検
査されるので、後の条件よりも前の条件が優先されます。これが意味するすべ
ては、ダウンロードされていない記事に可視記事 (ticked) の印を付けても、
その記事は可視記事のフェースではなくて、ダウンロードされていない記事の
フェースで表示し続けられるということです。

(記事を読むたびに同じ記事をダウンロードしないようにするため、または接続
時間を最小にするために) エージェントをキャッシュとして使う場合は、ダウ
ンロードされていない記事のフェースはおそらく良い考えのように思えるでしょ
う。ダウンロードされた記事に対してすべての仕事 (印を付ける、読む、削除
する) を行なえば、いつも通常のフェースが現れるからです。しかし、NOV を
キャッシュすることによってオンライン性能を改善するためにエージェントを
使っている利用者にとっては (Gnus 5.10.2 以降のほとんどの利用者にとって
は)、ダウンロードされていない記事のフェースが見えるかもしれないことは、
まったくひどいものでしょう。これは、それらのどの記事もエージェントに取
り込まれていないので、ダウンロードされていない記事のフェースのために、
すべての普通のフェースが目立たなくなってしまうだろうという問題です。

ダウンロードされていない記事のフェースを使いたい場合は、
`agent-enable-undownloaded-faces' グループパラメーターを `t' に設定して、
ダウンロードされていない記事のフェースを有効にしなければなりません。こ
のパラメーターは他のすべてのエージェントパラメーターと同様に、エージェ
ント分類 (*Note Agent Categories::)、グループトピック (*Note Topic
Parameters::)、あるいは個々のグループ (*Note Group Parameters::) に対し
て設定することができます。

エージェントを使うすべての利用者に共通した一つの問題は、それがディスク
の容量をいかに速く使い尽くすことができるかということです。あなたが多く
のグループでエージェントを使っている場合、事実上ディスク容量を回復する
ことはさらにもっと困難です。一つの解決手段は `gnus-group-line-format'
で用意されている `%F' 形式です。この形式は、エージェントとキャッシュの
両方で取得した記事によって占められる実際のディスク容量を表示します。ど
のグループが最も多い容量を使うかを知ることによって、利用者は記事を「エー
ジェント期限切れ消去」する場合に、どこに努力を集中するべきかがわかりま
す。



File: gnus-ja.info, Node: Agent as Cache, Next: Agent Expiry, Prev: Agent Visuals, Up: Gnus Unplugged

キャッシュとしてのエージェント
------------------------------

Gnus が plugged であるときに、すでにヘッダーや記事がエージェントに格納
されているのならば、それらを再びダウンロードするのは効率的ではありませ
ん。そのため Gnus は通常ヘッダーを一回だけダウンロードしてエージェント
に格納します。それらのヘッダーは後に概略バッファーを生成するときに、
plugged か unplugged にかかわらずに使われます。ディフォルトでは記事は
(それはたくさんのディスク容量を浪費するかもしれないので) エージェントに
キャッシュされませんが、すでにエージェントにダウンロードした記事がある
ならば、Gnus はサーバーから再び記事をダウンロードせずに、手元に格納され
たコピーを使います。

あなたがそう望むのであれば、plugged な期間は常にヘッダーと記事をダウン
ロードするように、エージェント (`gnus-agent-cache' 参照 *Note Agent
Variables::) を設定することができます。Gnus はほとんど確かにもっと遅く
なりますが、サーバーとの同期は保たれます。nntp か nnimap バックエンドを
使っている場合は、たぶんこの最後の点は意味をなさないでしょう。



File: gnus-ja.info, Node: Agent Expiry, Next: Agent Regeneration, Prev: Agent as Cache, Up: Gnus Unplugged

エージェント期限切れ消去
------------------------


エージェントバックエンド `nnagent' は期限切れ消去を扱いません。えーと、
少なくとも他のバックエンドのようにそれを扱いません。その代わりに、
`gnus-agent-expire-days' の日数よりも古い既読記事をすべて消去する、特別
な `gnus-agent-expire' と `gnus-agent-expire-group' 命令があります。こ
れらはあなたがディスク容量を使い切りそうだと思ったときに、いつでも実行
することができます。どちらも特に速くも効率的でもなく、それらの一つをいっ
たん始めてしまったら (`C-g' やその他で) 中断することもあまり良いことで
はありません。

例えば `gnus-request-expire-articles' のような他の関数は、エージェント
をグループに同期させるために `gnus-agent-expire' を実行するかもしれない
ことに注意してください。

`agent-enable-expiration' というエージェントのパラメーターを、選択した
グループでの期限切れ消去を抑制するために使うことができます。

`gnus-agent-expire-all' が `nil' でなければ、エージェントの期限切れ消去
コマンド群はすべての記事--未読、既読、可視、保留記事を消去します。もし
`nil' (これがディフォルト) であれば、既読記事のみが消去の対象となり、未
読、可視、さらに保留記事は無期限に保持されます。

期限切れ消去されるはずなのに残っている記事を見つけたならば、もしかする
といくつかの Gnus エージェントファイルが壊れています。起こりうる問題を
修復するために、`gnus-agent-regenerate' と
`gnus-agent-regenerate-group' という特別なコマンドがあります。



File: gnus-ja.info, Node: Agent Regeneration, Next: Agent and flags, Prev: Agent Expiry, Up: Gnus Unplugged

エージェントを作り直す
----------------------

`nnagent' によって使われるローカルのデータ構造は、ある例外的な条件によっ
ておかしくなってしまうかもしれません。これが起こると `nnagent' の機能性
が下がるかもしれないし、失敗しさえするかもしれません。この問題の解決策
は、内部の矛盾をすべて削除することによって、ローカルのデータ構造を修復
することです。

例えば、記事をエージェントにダウンロードしている間にサーバーへの接続が
切れてしまう場合、ローカルのデータ構造は接続が切れる前に記事が首尾良く
ダウンロードされたかどうかを知りません。`gnus-agent-regenerate' または
`gnus-agent-regenerate-group' を実行すると、そのような記事を二回ダウン
ロードしなくても済むようにデータ構造を更新します。

`gnus-agent-regenerate' コマンドは、すべてのエージェント化されたグルー
プで `gnus-agent-regenerate-group' を実行します。どのバッファー上でも
`gnus-agent-regenerate' を実行することができますが、最初にすべての概略
バッファーを閉じることを強く勧めます。

`gnus-agent-regenerate-group' コマンドは、ローカルの NOV (ヘッダー) デー
タベースを修復するために、個々の記事のローカルなコピーを使います。その
後それは、どの記事がローカルに格納されるかを記録しておくための内部デー
タ構造を更新します。引数を与えると、エージェントの中の記事に未読の印を
付けます。



File: gnus-ja.info, Node: Agent and flags, Next: Agent and IMAP, Prev: Agent Regeneration, Up: Gnus Unplugged

エージェントとフラグ
--------------------

エージェントは Gnus のどんなバックエンドでも、例えばサーバーにフラグ
(既読(read)、可視(ticked) など) を格納する nnimap のようなものでも動作
します。しかし悲しいかな、エージェントはどのバックンドがそれらのフラグ
を `.newsrc' ではなく、そのバックエンドのサーバーで維持するかを、実際に
は知りません。そのためエージェントは、unplugged または接続されていない
間に行なったすべてのフラグへの変更を、常に自身のファイルに記録します。

再び接続すると、Gnus は変更されたすべてのフラグを検査して、それらをサー
バーと同期させるかどうかを尋ねます。この挙動は
`gnus-agent-synchronize-flags' でカスタマイズすることができます。

`gnus-agent-synchronize-flags' が `nil' だったら、エージェントは自動的
にフラグを同期させることはしません。それがディフォルトの `ask' だったら、
エージェントはあなたが再接続したときにあなたが何らかの変更を行なってい
たかどうかを調べて、もしそうだったら、それらを同期させたいかどうかを尋
ねます。それら以外の値だった場合は、すべてのフラグは自動的に同期させら
れます。

再接続したときに自動でフラグを同期させたくないなら、手動でそれを行なう
こともできます。これにはグループバッファーの `J Y' キーに割り当てられた
`gnus-agent-synchronize-flags' コマンドを使ってください。

技術的注釈: すべてのローカルなフラグをサーバーに「押し込む」同期のアル
ゴリズムは動作しませんが、利用者によって変更されたフラグだけを変更して、
サーバー側で見えるフラグを一つずつ更新することは可能です。したがって、
あなたが記事の一つのフラグをセットして、そのグループを抜け出てから再度
そのグループを選択してそのフラグを消せば、あなたが「同期」の操作を行なっ
たときに、そのフラグはセットされてサーバーからは削除されます。順番待ち
(queue) に入れられたフラグに関する動作は、エージェントディレクトリーに
あるサーバー毎の `flags' ファイルの中で見つかるでしょう。それらはあなた
がフラグを同期させたときに空になります。



File: gnus-ja.info, Node: Agent and IMAP, Next: Outgoing Messages, Prev: Agent and flags, Up: Gnus Unplugged

エージェントを IMAP で使う方法
------------------------------

エージェントは nnimap を含む Gnus のどんなバックエンドでも動作します。
しかし NNTP と IMAP にはいくつかの概念の違いがあるので、この章ではサー
バーとの接続が絶たれたモードでの IMAP のクライアントとして、Gnus エージェ
ントをより円滑に使えるようにするための、いくつかの情報を提供します。

サーバーとの接続が絶たれているときの IMAP クライアントにあなたが期待す
るであろういくつかの機能は、現在のエージェントには盛り込まれていません。
それらは以下の通りです:

   * Unplugged のときの nnimap グループへのコピーと移動。

   * Unplugged のときの nnimap グループの作成と削除。



File: gnus-ja.info, Node: Outgoing Messages, Next: Agent Variables, Prev: Agent and IMAP, Up: Gnus Unplugged

差出用メッセージ
----------------

Gnus が unplugged のとき、ディフォルトではすべての差出用メッセージ (メー
ルとニュースの両方) は下書きグループ“queue”(*Note Drafts::) に格納さ
れます。投稿した後でも、そこでそのメッセージを見たり編集するのは意のま
まです。

送出するメールが queue される (順番待ちになる) 状況を制御することは可能
です (`gnus-agent-queue-mail', *Note Agent Variables:: 参照)。Gnus が
unplugged のとき、外に送り出すニュースは常に queue されるだけです。

下書きグループから、そこで使える特別な命令を使ってメッセージを送信する
こともできるし、グループバッファー内で `J S' を使って、下書きグループ内
のすべての送信可能なメッセージを送信することもできます。ニュースの投稿
は Gnus が plugged のときだけできますが、メールはいつでも送信することが
できます。

Unplugged のときにメールの送信ができなくて、かつ unplugged のときにうっ
かり `J S' を叩いてしまうことが心配ならば、Gnus にあなたの行動を確認さ
せることができます (`gnus-agent-prompt-send-queue', *Note Agent
Variables:: 参照)。



File: gnus-ja.info, Node: Agent Variables, Next: Example Setup, Prev: Outgoing Messages, Up: Gnus Unplugged

エージェント変数
----------------

`gnus-agent'
     エージェントが有効になっているかどうか。ディフォルトは `t' です。
     最初に有効にされると、いくつかのバックエンドを自動的にエージェント
     化するために、エージェントは `gnus-agent-auto-agentize-methods' を
     使います。サーバーバッファーでエージェントのコマンドを使うことによっ
     て、どのバックエンドをエージェント化するかを変更することができます。

     サーバーバッファーに入るには、グループバッファーで `^'
     (`gnus-group-enter-server-mode') を使ってください。

`gnus-agent-directory'
     Gnus エージェントがファイルを格納する場所です。ディフォルトは
     `~/News/agent/' です。

`gnus-agent-handle-level'
     この変数の値より高いレベル (*Note Group Levels::) のグループは、エー
     ジェントからは無視されます。ディフォルトは
     `gnus-level-subscribed' で、これはディフォルトでは、購読しているグ
     ループのみがエージェントの処理の対象となるということです。

`gnus-agent-plugged-hook'
     ネットワークに接続されたときに実行されるフックです。

`gnus-agent-unplugged-hook'
     ネットワークから切断されたときに実行されるフックです。

`gnus-agent-fetched-hook'
     記事を取り込み終わったときに実行されるフックです。

`gnus-agent-cache'
     Plugged のときに、ローカルに格納されている NOV と記事を使うかどう
     かを制御する変数で、例えばエージェントをキャッシュとして使うには必
     須です。ディフォルトでは非-`nil' で、エージェントをキャッシュとし
     て使います。

`gnus-agent-go-online'
     `gnus-agent-go-online' が `nil' だったら、エージェントはオフライン
     状態のサーバーをオンライン状態にしません。`ask' だったら、それがディ
     フォルトですが、エージェントは再接続するときにオフライン状態のサー
     バーをオンライン状態にしたいかどうかを尋ねます。それ以外の値だった
     ら、オフライン状態のサーバーは自動的にオンライン状態になります。

`gnus-agent-mark-unread-after-downloaded'
     `gnus-agent-mark-unread-after-downloaded' が 非-`nil' だったら、ダ
     ウンロードした後で記事に未読の印を付けます。これは通常、新しくダウ
     ンロードされた記事を明確に未読にするための安全な行為です。ディフォ
     ルトは `t' です。

`gnus-agent-synchronize-flags'
     `gnus-agent-synchronize-flags' が `nil' だったら、エージェントは決
     して自動的にフラグを同期させません。それが `ask' だったら (それが
     ディフォルトです)、エージェントはすべての変更を検査して、再び接続
     したときにそれらを同期させるかどうかを尋ねます。`nil' でも `ask'
     でもなかったら、すべてのフラグが自動的に同期させられます。

`gnus-agent-consider-all-articles'
     `gnus-agent-consider-all-articles' が非-`nil' だったら、エージェン
     トはすべての記事について、それらをダウンロードする必要があるかどう
     かをエージェントの述語に決定させます。`nil' だった場合、それがディ
     フォルトですが、エージェントは未読の記事をダウンロードするかどうか
     だけを述語に決定させます。これを有効にするのならば、後でエージェン
     トが期限切れ消去する記事を何度も繰り返しダウンロードしないように、
     エージェントの期限切れ消去の設定 (*Note Category Variables::) を見
     直す必要があるでしょう。

`gnus-agent-max-fetch-size'
     エージェントは、取得した記事を個々のファイルに入れるための解析を行
     なう前に、それらを一時的なバッファーへ取り込みます。最大のバッファー
     サイズを超過しないようにするために、記事がすべて取得されるまで、エー
     ジェントは取得と解析を交互に行ないます。
     `gnus-agent-max-fetch-size' は、繰り返しがどれくらい頻繁に起きるか
     を制御するための、サイズの限界を規定します。大きな値は性能を向上さ
     せます。小さな値は、万が一取得している間に接続が切れた場合に、遅れ
     時間を最小にします (グループの状態を更新するために
     `gnus-agent-regenerate-group' を実行する必要があるかもしれません。
     でも、接続が切れる前に解析されたすべての記事は、unplugged の期間に
     利用することができるでしょう。)。繰り返しに遭遇することは珍しいの
     で、ディフォルトは 10M です

`gnus-server-unopen-status'
     エージェント変数ではないかもしれないけれどエージェントに密接に関連
     するこの変数は、Gnus がサーバーに接続できないときに何をするかを指
     示します。エージェントが活性化されると、ディフォルトの `nil' では、
     サーバーとの接続を絶つかエージェントを unplugged にするかを利用者
     に尋ねます。エージェントが不活性化されると、Gnus はいつも単にサー
     バーとの接続を絶ちます。この変数の他の選択肢には `denied' と
     `offline' があり、後者はエージェントを使う場合だけ有効です。

`gnus-auto-goto-ignores'
     おおかたの人は、エージェント変数ではないけれども密接に関連するもう
     一つの変数をここで探すでしょう。この変数は、ダウンロードされていな
     い (ヘッダーだけがエージェントに格納された)、そして取り込まれてい
     ない (記事もヘッダーも格納されていない) 記事の周りでどう移動するか
     を概略バッファーに伝えます。

     有効な値は `nil' (どの記事にも移動する)、
     `undownloaded' (unplugged のときは取り込まれていない記事を無視する)、
     `always-undownloaded' (取り込まれていない記事を常に無視する)、
     `unfetched' (ヘッダーが取り込まれていない記事を無視する) です。

`gnus-agent-queue-mail'
     `gnus-agent-queue-mail' を `always' にすると、Gnus はメールを
     いきなり送信してしまうのではなく、常に queue (順番待ち) に入れます。
     `t' だったら Gnus は unplugged のときだけメールを queue に入れます。
     `nil' だったら queue に入れません。ディフォルトは `t' です。

`gnus-agent-prompt-send-queue'
     `gnus-agent-prompt-send-queue' が非-`nil' だったら、unplugged であ
     るのにもかかわらず `J S' を叩いた場合に、Gnus は本当にそれを行なっ
     ても良いかどうかを確認します。ディフォルトは `nil' です。

`gnus-agent-auto-agentize-methods'
     あなたが以前にエージェントを使ったことが無い (もっと技術的には
     `~/News/agent/lib/servers' が無い場合)、Gnus はほんの少数のサーバー
     を自動的にエージェント化します。この変数はどのバックエンドを自動で
     エージェント化すべきかを制御します。一般に、エージェント化すること
     が有用なのは遠隔バックエンドに対してだけです。自動的にエージェント
     化することは、サーバーに対して `J a' を実行するのと同じ効果があり
     ます (*Note Server Agent Commands::)。もしファイルが存在するならば、
     それらを追加したり削除するためにサーバーを手動で操作しなければなり
     ません。この変数は最初に Gnus を起動したときだけ適用されます。ディ
     フォルトは `(nntp nnimap)' です。



File: gnus-ja.info, Node: Example Setup, Next: Batching Agents, Prev: Agent Variables, Up: Gnus Unplugged

設定例
------

あなたがこのマニュアルを読みたくなくて、ごく標準的な設定を行なっている
のならば、`~/.gnus.el' ファイルとして何か以下のようなものを使って始めて
も良いでしょう。

     ;; Gnus がどのようにニュースを取得するかを定義します。ここ
     ;; では ISP のサーバーから NNTP で取ってくることにします。
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;; Gnus がどのようにメールを読むかを定義します。
     ;; ISP の POP サーバーからメールを読むことにします。
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;; Gnus がメールをどのように格納するかを指定します。
     ;; nnml グループを使うことにします。
     (setq gnus-secondary-select-methods '((nnml "")))

     ;; Gnus をオフラインニュースリーダーにします。
     ;; (gnus-agentize) ; 旧式の設定。
     ;; (setq gnus-agent t) ; 現在のディフォルト。

基本的にはこれだけで良いはずです。これを `~/.gnus.el' ファイルに入れて、
必要に応じて編集し、PPP (や何か) を起動して、`M-x gnus' とタイプしてく
ださい。

あなたが Gnus を走らせたのが初めてであれば、自動的にわずかなディフォル
トのニュースグループが読めるようになります。おそらくもっとたくさんのグ
ループを購読したくなるでしょう。そのためには、`A A' 命令でグループの完
全なリストを NNTP サーバーに問い合わせなければなりません。これは普通は
とても時間がかかりますが、一度だけしか実行する必要はありません。

読み込みと解析にしばらく時間を費やした後で、グループの一覧が現れます。
そうしたら、読みたいグループを `u' 命令で購読できるようにしてください。
読みたいグループを全部購読できるようにしたら、`l' で killed (削除された)
グループをすべて画面から消去しましょう。(`A k' で killed グループはすべ
て戻ってきます。)

今やすぐにグループを読むこともできるし、`J s' 命令で記事をダウンロード
することもできます。あとはこのマニュアルの残りを読んで、他の億千万の項
目からカスタマイズしたいことを見つけ出してください。



File: gnus-ja.info, Node: Batching Agents, Next: Agent Caveats, Prev: Example Setup, Up: Gnus Unplugged

一括エージェント処理
--------------------

Gnus エージェントに記事を取得させるのは (そしてあなたの書いた何かのメッ
セージを投稿するのは)、いったんものごとを正しく設定してしまえば非常に簡
単です。以下のシェルスクリプトは必要なことをすべてやってくれるでしょう。

以下の呪文をコマンドラインで使うことによって、完全なバッチコマンドを走
らせることができます:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-agent-batch >/dev/null 2>&1



File: gnus-ja.info, Node: Agent Caveats, Prev: Batching Agents, Up: Gnus Unplugged

エージェントの問題点
--------------------

Gnus エージェントは、よくある他のオフラインニュースリーダーのようには動
作しません。これらは架空の人々からの良くある質問です:

"Plugged のときに記事を読んだら、それはエージェントに入るのですか?"

     *いいえ*。この動作をお望みなら `gnus-select-article-hook' に関数
     `gnus-agent-fetch-selected-article' を加えてください。

"Plugged のときに記事を読んで、エージェントに記事が存在している場合、"
     もう一回ダウンロードされるのですか?

     *いいえ*、ただし `gnus-agent-cache' が `nil' でなかったら、ですが。

要約すると、Gnus が unplugged のときはローカルに保存された記事を見るだ
けです。Plugged のときは ISP と話し、かつローカルに持っている記事も使う
でしょう。



File: gnus-ja.info, Node: Scoring, Next: Various, Prev: Select Methods, Up: Top

スコア
******

ほかの人たちは「削除ファイル」("kill files") を使いますが、ここ Gnus タ
ワーにいる私たちは削除よりもスコアの方が好きです。彼らとけんかをするよ
りは切り替えてしまう方がましでしょう。それらは完全に違うことをするので、
真っ直ぐに座って注意を払ってください!

すべての記事はディフォルトのスコア (`gnus-summary-default-score') の値
を持っていて、ディフォルトでは 0 です。このスコアは対話的に、またはスコ
アファイル (score file) によって、上げられるか下げられるかします。
`gnus-summary-mark-below' よりも低いスコアを持っている記事には既読の印
が付きます。

Gnus は概略バッファーを作成する前に、現在のグループに適用されるどんな
「スコアファイル」も読み込みます。

現在の記事に基づいてスコアのエントリーを挿入する、複数の概略バッファー
の命令があります。例えば、Gnus に特定の表題の記事のスコアを下げたり上げ
たりするように求めることができます。

二種類のスコア・エントリーがあります: 永続的なものと一時的なものです。
一時的なスコア・エントリーは、自分自身で期限切れ消去するエントリーです。
例えば一週間以上使われていないエントリーは、スコアファイルの大きさを小
さくしておくために静かに削除されます。

* Menu:

* Summary Score Commands::      現在のグループのためのスコア・エントリーを追加する
* Group Score Commands::        一般的なスコア命令
* Score Variables::             あなたのスコアをカスタマイズする
* Score File Format::           スコアファイルには何が入っているか
* Score File Editing::          手でスコアファイルを編集することもできる
* Adaptive Scoring::            Big Sister Gnus はあなたが何を読んだか知っている
* Home Score File::             新しいスコア・エントリーがどこへ行くかを指示する方法
* Followups To Yourself::       人があなたに返答したときに Gnus に気付かせる
* Scoring On Other Headers::    標準ではないヘッダーにスコアを付ける
* Scoring Tips::                効果的にスコアを付ける方法
* Reverse Scoring::             歳をとった問題児は問題ではない
* Global Score Files::          地を覆い、耳を切り裂くスコアファイル
* Kill Files::                  それらはまだここにあるが、無視することができる
* Converting Kill Files::       消去ファイルをスコアファイルに翻訳する
* Advanced Scoring::            スコアの規則を作るために論理表現を使う
* Score Decays::                スコアを減衰させるのは役に立つこともある



File: gnus-ja.info, Node: Summary Score Commands, Next: Group Score Commands, Prev: Scoring, Up: Scoring

概略スコア命令
==============

スコア・エントリーを変更するスコア命令は、実際に本当のスコアファイルを
修正するわけではありません。それはあまりに非効率です。Gnus は以前にロー
ドされたスコアファイルのキャッシュを保持していて、その一つが「現在のス
コアファイルの連想リスト」だと見なされます。スコア命令は単にこのリスト
にエントリーを挿入し、グループから出るときに、このリストは保存されます。

現在のスコアファイルは、実際にそのようなスコアファイルが存在しない場合
でも、ディフォルトでグループのローカルスコアファイルになります。スコア
命令を何か他のスコアファイル (例えば `all.SCORE') に挿入するには、まず
このスコアファイルを現在のものにしなければなりません。

以下はスコアファイルを実際に変更しない、一般的なスコア命令です:

`V s'
     現在の記事のスコアを設定します (`gnus-summary-set-score')。

`V S'
     現在の記事のスコアを表示します (`gnus-summary-current-score')。

`V t'
     現在の記事に使われているすべてのスコア規則を表示します
     (`gnus-score-find-trace')。`*Score Trace*' バッファーにおいて、現
     在の行のスコア規則に対応するスコアファイルを編集するには `e' を、
     スコアファイルの清書 (`gnus-score-pretty-print') と編集を行なうた
     めには `f' をタイプしてください。

`V w'
     スコアで使われている語のリストを表示します
     (`gnus-score-find-favourite-words')。

`V R'
     現在の概略でスコアの処理を実行します (`gnus-summay-rescore')。
     Gnus には内緒でスコアファイルをいじり回して、その効果を見たいとき
     に役立つでしょう。

`V c'
     違うスコアファイルを現在のものにします
     (`gnus-score-change-score-file')。

`V e'
     現在のスコアファイルを編集します
     (`gnus-score-edit-current-scores')。`gnus-score-mode' バッファーが
     現れるしょう (*Note Score File Editing::)。

`V f'
     スコアファイルを編集して、このスコアファイルを現在のものにします
     (`gnus-score-edit-file')。

`V F'
     キャッシュされているスコアを捨てます (`gnus-score-flush-cache')。
     これはスコアファイルを編集した後で役に立ちます。

`V C'
     視覚的に快適な方法でスコアファイルをカスタマイズします
     (`gnus-score-customize')。

以下の命令はローカルスコアファイルを変更します:

`V m'
     スコアの入力を求めて、それよりも低いスコアのすべての記事に既読の印
     を付けます (`gnus-score-set-mark-below')。

`V x'
     スコアの入力を求めて、そのスコアより低いすべての記事を削除するため
     のスコア規則を現在のスコアファイルに付け加えます
     (`gnus-score-set-expunge-below')。

スコア・エントリーを実際に作るためのキー操作は、非常に規則正しい様式に
のっとっているので、それらすべての (何百もある) 命令を列挙する必要は無
いでしょう。

  1. 最初にタイプするキーは、スコアを増やすときは `I' (i の大文字) で、
     スコアを下げるときは `L' です。
  2. 二番目のキーは、どのヘッダーでスコアを付けるかを指定します。以下の
     キーを使うことができます:

     `a'
          著者 (author) の名前でスコアを付けます。

     `s'
          表題 (subject) の行でスコアを付けます。

     `x'
          `Xref' 行、すなわちクロスポスト行でスコアを付けます。

     `r'
          `References' 行でスコアを付けます。

     `d'
          日付 (date) でスコアを付けます。

     `l'
          行数 (number of lines) でスコアを付けます。

     `i'
          `Messsage-ID' ヘッダーでスコアを付けます。

     `e'
          NNTP サーバーが追加のヘッダーのデータを overview で捕捉してい
          れば、その「追加」のヘッダー (すなわち (`gnus-extra-headers'
          に設定されているもの) の一つでスコアを付けます。

     `f'
          フォローアップ (followup) でスコアを付けます--これは著者名と
          合致するかどうかを調べて、この著者へのフォローアップでスコア
          を加えます。(このキーを使うことは、`ADAPT' ファイルの生成をも
          たらします。)

     `b'
          記事の本文でスコアを付けます。

     `h'
          ヘッダーでスコアを付けます。

     `t'
          スレッドでスコアを付けます。(このキーを使うことは、`ADAPT' ファ
          イルの生成をもたらします。)

  3. 三番目のキーは合致の型です。どの合致の型が有効なのかは、どのヘッダー
     でスコアを付けようとしているかに依ります。

     `文字列 (strings)'

          `e'
               正確な (exact) 合致です。

          `s'
               文字列の一部の (substring) 合致です。

          `f'
               大雑把な (fuzzy) 合致です (*Note Fuzzy Matching::)。

          `r'
               正規表現 (regexp) の合致です。

     `日付 (date)'

          `b'
               日付の前 (before) です。

          `a'
               日付の後 (after) です。

          `n'
               その日付です。

     `数値 (number)'

          `<'
               数値より小さいものです。

          `='
               数値と等しいものです。

          `>'
               数値より大きいものです。

  4. 普通はこれで最後の四つ目のキーは、これが一時的な (すなわち期限切れ
     消去される) スコア・エントリーか、永続的な (すなわち期限切れ消去で
     ない) スコア・エントリーか、またはスコアファイルに追加せずにただち
     にスコア付けを行なうか、のどれかを指定します。

     `t'
          一時的な (temporary) スコア・エントリーです。

     `p'
          永続的な (permanent) スコア・エントリーです。

     `i'
          ただちに (immediate) スコア付けを行ないます。

  5. もし `e' (追加の (extra)) ヘッダーでスコア付けを行なっていると、それでス
     コア付けをしたいヘッダーの名前を尋ねられるでしょう。これ
     は `gnus-extra-headers' にある名前でなければなりません。
     `TAB' による補完ができます。

そういうわけで、現在の著者への、正確な合致に基づいて、永続的なスコアを、
増やしたい、という場合のキーは `I a e p' です。表題への、文字列の一部合
致に基づいて、一時的なスコア・エントリーを作り、そのスコアを下げたい、
という場合のキーは `L s s t' です。ずいぶん簡単ですね。

ものごとを少し複雑にするためにショートカット・キーがあります。二番目か
三番目のキーに大文字を使うと、Gnus は残る一つか二つのキーにディフォルト
値を使います。ディフォルトは「文字列の一部」と「一時的」です。ですから
`I A' は `I a s t' と同じで、`I a R' は `I a r t' と同じです。

これらの関数は、数値接頭引数とシンボル接頭引数を受け付けます (*Note
Symbolic Prefixes::)。数値接頭引数はどのくらい記事のスコアを下げる (も
しくは上げる) かを指定します。シンボル接頭引数 `a' は、現在のスコアファ
イルの代わりに `all.SCORE' ファイルをその命令のために使うことを指示しま
す。

`gnus-score-mimic-keymap' はこれらの命令がキーマップであるかのように振
る舞うかどうかを指定します。



File: gnus-ja.info, Node: Group Score Commands, Next: Score Variables, Prev: Summary Score Commands, Up: Scoring

グループスコア命令
==================

残念ながら、まだたくさんはありません。

`W e'
     すべてのグループに適用される all.SCORE ファイルを編集します。
     `gnus-score-mode' のバッファーが現れるでしょう (*Note Score File
     Editing::)。

`W f'
     何度もスコア連想リストを再読み込みすることを避けるために、Gnus は
     それらのキャッシュを保持しています。この命令はキャッシュを空っぽに
     します (`gnus-score-flush-cache')。

以下のようなやり方で、コマンド行からスコア付けをすることができます:

     & emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score



File: gnus-ja.info, Node: Score Variables, Next: Score File Format, Prev: Group Score Commands, Up: Scoring

スコア変数
==========

`gnus-use-scoring'
     `nil' であれば、Gnus はスコアファイルを調べず、一般的にはスコア関
     連の仕事をまったくしません。これはディフォルトで `t' です。

`gnus-kill-killed'
     この変数が `nil' であれば、Gnus はすでに削除 (kill) の処理を実行さ
     れた記事に決してスコアファイルを適用しません。これはたくさんの時間
     を節約する一方、削除ファイルをグループに適用していて、削除ファイル
     を変更し、もっと多くの記事を削除するためにそれを再実行しても、それ
     は動作しないということにもなります。それをするためにはこの変数を
     `t' にしなければなりません。(これはディフォルトで `t' です。)

`gnus-kill-files-directory'
     すべての削除 (kill) とスコアのファイルはこのディレクトリーに格納さ
     れます。その値は、ディフォルトでは環境変数 `SAVEDIR' によって初期
     化されます。ディフォルトは `~/News/' です。

`gnus-score-file-suffix'
     スコアファイルの名前を得るためにグループ名に加える接尾語です (ディ
     フォルトは `SCORE' です)。

`gnus-score-uncacheable-files'
     通常すべてのスコアファイルは、スコアファイルの過剰な再読み込みを避けるた
     めにキャッシュされます。しかし、このために Emacs が大きく肥大化するかも
     しれません。そこで、再び必要とされそうもないスコアファイルを取り除くため
     にこの正規表現を使うことができます。`all.SCORE' のキャッシュをやめ
     てしまうのは間違った考えですが、
     `comp.infosystems.www.authoring.misc.ADAPT' をキャッシュしないのは
     良い考えかもしれません。実際のところ、この変数のディフォルトは
     `ADAPT$' で、適応スコアファイルはキャッシュされません。

`gnus-save-score'
     もし本当に複雑なスコアファイルを持っていて、たくさんの一括
     (batch) スコア付けを行なうのであれば、この変数を `t' に設定しても
     良いでしょう。これは Gnus にスコアを `.newsrc.eld' ファイルに保存
     させます。

     これを `t' に設定しないと、手動で付けたスコア (`V s'
     (`gnus-summary-set-score') で設定したようなもの) は訪れたグループ
     群を横切って保持されることはありません。

`gnus-score-interactive-default-score'
     スコアを上げ/下げするために、すべての対話的スコア上げ/下げ命令によっ
     て使われるスコアです。ディフォルトは 1000 で、過剰に思えるかもしれ
     ませんが、適応スコア付けをするための十分な余地を確保するためです。
     手で入力したデータを、適応スコア付けからの小さな変更で上書きされた
     くはないのです。

`gnus-summary-default-score'
     記事のスコアのディフォルトで、ディフォルトでは 0 になっています。

`gnus-summary-expunge-below'
     この変数より低いスコアを持つ記事は概略の行に表示されません。ディフォ
     ルトは `nil' で、どの記事も隠されないということです。これは各概略
     バッファーにおけるローカル変数で、`gnus-summary-mode-hook' によっ
     て設定されなければなりません。

`gnus-score-over-mark'
     ディフォルトのスコアより大きなスコアを持つ記事に対して (概略行の三
     桁目で) 使われる印です。ディフォルトは `+' です。

`gnus-score-below-mark'
     ディフォルトのスコアより小さなスコアを持つ記事に対して (概略行の三
     桁目で) 使われる印です。ディフォルトは `-' です。

`gnus-score-find-score-files-function'
     現在のグループのためのスコアファイルを見つけるために使われる関数で
     す。この関数はグループ名を引数として呼ばれます。

     あらかじめ定義されている使用可能な関数は:

     `gnus-score-find-single'
          グループ自身のスコアファイルだけを適用します。

     `gnus-score-find-bnews'
          すべての合致するスコアファイルを bnews 構文を使って適用します。
          これがディフォルトです。例えば、現在のグループが
          `gnu.emacs.gnus' ならば、`gnu.all.SCORE', `not.alt.SCORE' と
          `gnu.all.SCORE' がすべて適用されます。要するに、スコアファイ
          ル名の `all' が `.*' に変換され、それから正規表現の合致がなさ
          れます。

          これは、すべてのグループに適用したいスコア・エントリーがいく
          つかある場合は、それらのエントリーを `all.SCORE' ファイルに入
          れるということです。

          Gnus は、より一般的なスコアファイルを、より特定のスコアファイ
          ルより前に適用しようとするものの、スコアファイルはややランダ
          ムな順番で適用されます。これはスコアファイル名の要素の数を調
          べることによって行なわれます---`all' 要素を取り除いて。

     `gnus-score-find-hierarchical'
          すべての親グループから、順にすべてのスコアファイルを適用しま
          す。これは `all.SCORE' のようなスコアファイルを持つことはでき
          ないけれど、`SCORE', `comp.SCORE' および `comp.emacs.SCORE'
          を、それぞれのサーバーに対して持つことができるということです。

     この変数は関数のリストであることもできます。その場合、これらすべて
     の関数がグループ名を引数として呼ばれ、返されたすべてのスコアファイ
     ルのリストが適用されます。これらの関数は、直接スコア連想リストのリ
     ストのリストを返すこともできます。その場合、それらのファイルでない
     スコア連想リストを返す関数は、返される最後のスコアファイルがローカ
     ルスコアファイルであることを確実にするために、おそらく「本当の」ス
     コアファイル関数よりも前に置かれるべきでしょう。ふぅ。

     例えば、サーバーを特定しない全体スコアファイルを使って、階層的に
     (親グループから順に) スコア付けを行なうならば、次の値を使えば良い
     でしょう。

          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     この変数は、使われていないスコアファイルエントリーが期限切れ消去さ
     れるまでに、どのくらいの日数が経過すべきかを指定します。この変数が
     `nil' であると、スコアファイルエントリーは削除されません。ディフォ
     ルトは 7 です。

`gnus-update-score-entry-dates'
     この変数が `nil' でないと、一時的に合致したスコア・エントリーは日
     付が更新されます。(これは Gnus が期限切れ消去を操作している方法で
     す--すべての合致しないエントリーは古くなりすぎるのに対して、合致す
     るエントリーは新鮮で若いままです。) しかし、この変数を `nil' に設
     定すると、合致するエントリーでさえも古くなって、ああ、そう、あの冷
     酷な死神と直面することになるでしょう。

`gnus-score-after-write-file-function'
     スコアファイルが書かれた直後に、その名前を引数として呼ばれる関数で
     す。

`gnus-score-thread-simplify'
     この変数が `nil' でないと、記事の表題は表題でスコア付けを行なうた
     めに、スレッドと同じやり方で (現在の
     `gnus-simplify-subject-functions' の値に従って) 単純化されます。ス
     コア・エントリーが「文字列の一部への合致」か「正確な合致」を使って
     いると、その合致もこのやり方で単純化されます。



File: gnus-ja.info, Node: Score File Format, Next: Score File Editing, Prev: Score Variables, Up: Scoring

スコアファイル様式
==================

スコアファイルは普通は単一の様式だけを含む `emacs-lisp' ファイルです。
無頓着な利用者はこれを編集しないでください。すべては概略バッファーから
変更することができます。

にもかかわらず、それを自分でいじってみたくなったのなら、例があります:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

この例はたいていのスコアファイルの要素を説明しています。別のやり方につ
いては、*Note Advanced Scoring:: を見てください。

これがとても Lisp コードのように見えるとしても、実際はここにあるものは
何も `eval' (評価) されません。しかしこの様式を読み込むために Lisp リー
ダーが使われるので、意味的に有効でないとしても、文法的には正当なもので
す。

この連想リストでは六つのキーがサポートされています:

`文字列 (STRING)'
     キーが文字列だったら、それは合致が実行されるヘッダーの名前です。ス
     コア付けはこれら八つのヘッダーだけで行なうことができます: `From',
     `Subject', `References', `Message-ID', `Xref', `Lines', `Chars' お
     よび `Date' です。これらのヘッダーに加えて、Gnus に、記事全体を取
     得して記事のより大きな部分で合致を行なわせる三つの文字列があります:
     `Body' は記事の本文で合致を行ない、`Head' は記事のヘッダーで合致を
     行ない、`All' は記事全体で合致を行ないます。これら最後の三つのキー
     を使うと、グループに入る速度を *かなり* 遅くしてしまうことに気を付
     けてください。スコアを付けることができる最後の「ヘッダー」は
     `Followup' です。これらのスコア・エントリーは、これらのスコア・エ
     ントリーに合致する記事へのすべてのフォローアップのための追加が行な
     われている、新しいスコア・エントリーに帰着するでしょう。

     このキーに続くのは任意の数のスコア・エントリーで、それぞれのスコア・
     エントリーは一つから四つまでの要素を持ちます。

       1. 最初の要素は「合致要素」です。これはたいていのヘッダーでは文
          字列ですが、Lines と Chars ヘッダーでは整数でなければなりませ
          ん。

       2. もし二番目の要素があるなら、それは数値の「スコア要素」でなけ
          ればなりません。この数値は負の無限大から正の無限大までの間の
          整数でなければなりません。合致が成功すると、この数値が記事の
          スコアに加えられます。この要素が存在していない場合は、代わり
          に `gnus-score-interactive-default-score' の数値が使われます。
          ディフォルトは 1000 です。

       3. もし三番目の要素があるなら、それは数値の「日付要素」でなけれ
          ばなりません。この日付は最後にこのスコア・エントリーが合致し
          た時刻を示し、それはスコア・エントリーを期限切れ消去するため
          の機構を提供します。この要素が存在していないと、スコア・エン
          トリーは永続になります。日付は紀元前 1年12月31日からの経過し
          た日数で表されます。

       4. もし四番目の要素があるなら、それはシンボルの「型要素」でなけ
          ればなりません。この要素は、このスコア・エントリーが記事に合
          致するかどうかを調べるために、どの関数が使われるべきかを指定
          します。

          "From, Subject, References, Xref, Message-ID"
               たいていのヘッダー型のために、`r' と `R' (正規表現
               (regexp))、`s' と `S' (文字列の一部(substring)) 型、`e'
               と `E' (正確な合致(exact match))、および `w' (語の合致
               ((word match)) 型があります。もしこの要素が無いと、Gnus
               は文字列の一部の合致が用いられるべきであると仮定します。
               `R', `S', `E' は、合致が大文字と小文字を区別する方法で行
               なわれる点で他のものと異なります。これらすべての一文字型
               は、本当は `regexp', `exact', `word' 型の短縮形で、この
               方が好みならば代わりに使うことができます。

          "Extra"
               overview ヘッダーの標準の文字列に的を絞って
               `gnus-extra-headers' を使っていれば、それらのヘッダーの
               値でスコアを付けることができます。この場合スコア・エント
               リーの五番目の要素が、スコアを付けるヘッダーの名前になり
               ます。NNTP サーバーが overview で `NNTP-Posting-Host' を
               捕捉しているならば、`all.SCORE' ファイルの以下のエントリー
               は、単一のホストを起源とする spam の攻撃に対して有効です:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

          "Lines, Chars"
               これらの二つのヘッダーは別の合致の型を使います: `<', `>',
               `=', `>=', `<=' です。

               これらの述語は

                    (PREDICATE HEADER MATCH)

               の評価が `nil' ではない場合に真です。例えば、上級合致
               `("lines" 4 <)' (*Note Advanced Scoring::) は結果として
               以下の式になります:

                    (< header-value 4)

               言い換えると、4 を合致として `<' を `Lines' で使っている
               ときは、記事が 4 行よりも少ないときにスコアが加算される
               ということです。(混乱して、それが反対ではないかと考えが
               ちです。でも、そうではないのです。私が思うに。)

               合致を `Lines' で行なっていると、いくつかのバックエンド
               (`nndir' のようなもの) は `Lines' ヘッダーを作成しないの
               で、すべての記事が 0 行であるとして扱われてしまうことに
               気を付けてください。これは、少しの行しかない記事のスコア
               を下げている場合に、変な結果を導くことがあり得ます。

          "Date"
               Date (日付) ヘッダーには三つのなんとなくばかげている合致
               の型があります: `before', `at', `after' です。私は本当に
               これが役立つような機会を想像できないのですが、この関数を
               提供しないのもなんとなくばかげています。そうした場合のた
               めにあるのです。いつ必要になるかは誰にもわかりません。転
               ばぬ先の杖。羹(あつもの)に懲りて膾(なます)を吹く。本をカ
               バーで判断してはいけません。初めてのデートでエッチしては
               いけません。(しかし、私は少なくとも一人、引用しますが、
               「この関数は欠かせないものであることがわかった」と言った
               人がいると聞いています。)

               もっと役に立つ合致の型は「正規表現」です。それによって、
               日付の文字列に正規表現を使って合致させることができます。
               日付はまず ISO8601 の短縮様式 (compact format) に標準化
               されます---YYYYMMDD`T'HHMMSS です。例えば、すべての年の
               4月1日に投稿されたすべての記事に合致させたいのであれば、
               合致文字列として `....0401.........' を使うことができま
               す。(日付は元々の標準時で保存されているので、その記事が
               投稿された場所での 4月1日に投稿された記事に合致すること
               に注意してください。“Time zones”は家族全員の健全な楽し
               みですね? (訳注: いくつかある“Time zones”というタイト
               ルの曲のことを言っているのかもしれません。))

          "Head, Body, All"
               これらの三つの合致のキーは `From' ヘッダー (など) と同じ
               合致の型を使います。

          "Followup"
               この合致のキーはやや特別で、それは `From' ヘッダーに合致
               し、合致した記事だけでなくその記事へのすべてのフォローアッ
               プのスコアにも影響します。これは例えば、あなた自身の記事
               へのフォローアップのスコアを増やしたり、良く知られた問題
               児へのフォローアップ記事のスコアを下げたりするのに使われ
               ます。`From' ヘッダーが使うのと同じ型の合致を使います。
               (この合致キーを使うと、`ADAPT' ファイルを作ることになり
               ます。)

          "Thread"
               この合致キーは `Followup' 合致キーと同じ方針に沿って動作
               します。`Message-ID' X で始まっているスレッド (または副
               スレッド) にスコアを付けたいのであれば、`thread' 合致を
               付け加えてください。これは `Reference' ヘッダーに X を持
               つそれぞれの記事に、新しい `thread' 合致を追加します。
               (これらの新しい `thread' 合致はこれらの合致する記事の
               `Message-ID' を使います。) これはスレッドのいくつかの記
               事が完全な `References' ヘッダーを持っていなかったとして
               も、スレッド全体のスコアを上げ/下げできることを保証しま
               す。これを使うと、スレッドの記事に決定的でないスコアが付
               くかもしれないということに注意してください。(この合致キー
               を使うと、`ADAPT' ファイルを作ることになります。)

`mark'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事にも既読の印が付きます。

`expunge'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事も概略バッファーから削除されます。

`mark-and-expunge'
     このエントリーの値は数値でなければなりません。この数値より低いスコ
     アのどんな記事にも既読の印が付き、概略バッファーから削除されます。

`thread-mark-and-expunge'
     このエントリーの値は数値でなければなりません。スコアの総計がこの数
     値より低いスレッドのすべての記事には既読の印が付き、概略バッファー
     から削除されます。`gnus-thread-score-function' はスレッドのスコア
     の総計をどのように計算するかを指定します。

`files'
     このエントリーの値は任意の数のファイル名でなければなりません。それ
     らのファイルもスコアファイルであるとみなされ、これがされたのと同じ
     方法で読み込まれます。

`exclude-files'
     このエントリーの手がかりは任意の数のファイル名でなければなりません。
     これらのファイルが何らかの理由で普通は読み込まれるようになっていた
     としても、読み込まれません。

`eval'
     このエントリーの値は `eval' (評価) されます。この要素はグローバル
     スコアファイルを扱っているときは無視されます。

`read-only'
     読み込み専用スコアファイルは更新されたり保存されたりしません。グロー
     バルスコアファイルはこのアトムを使用するべきです (*Note Global
     Score Files::)。(注意: 「グローバル」はここでは本当に「全体的」と
     いう意味です。個人的なすべてのグループに適用するスコアファイルのこ
     とではありません。)

`orphan'
     このエントリーの値は数値でなければなりません。親記事を持たない記事
     のスコアにこの数値が加えられます。`comp.lang.c' のような流通量の多
     いニュースグループを追いかけていると想像してください。おそらくほん
     の少しのスレッドだけを追いたいでしょう。さらに新しいスレッドは見た
     いでしょう。

     以下の二つのスコアファイルエントリーによって、それをすることができ
     ます:

                  (orphan -500)
                  (mark-and-expunge -100)

     最初にこのグループに入ったときは、新しいスレッドだけを見るでしょう。
     そうしたら、興味を持ったスレッドのスコアを上げ (`I T' または `I
     S' で)、残りを無視 (`C y') してください。次にグループに入ったとき
     は、興味を持ったスレッドの新しい記事と、まったく新しいスレッドを見
     ることになります。

     すなわち orphan (孤児) スコアアトムは、普通のスコア規則では自動的
     に発見できない、興味深いスレッドが少し存在しする、流通量が多いグルー
     プのためにあります。

`adapt'
     このエントリーは適応スコア付けを制御します。これが `t' だったら、
     ディフォルトの適応スコア規則が使われます。`ignore' だったら、この
     グループでは適応スコア付けは行なわれません。もしリストだったら、そ
     のリストが適応スコア規則として用いられます。もしそれが存在しないか
     `t' や `ignore' 以外の何かだったら、ディフォルトの適応スコア規則が
     使われます。たいていのグループで適応スコア付けを使いたいのであれば、
     `gnus-use-adaptive-scorint' を `t' に設定し、適応スコア付けをした
     くないグループに `(adapt ignore)' を挿入すればよいでしょう。少しの
     グループでだけ適応スコアを行ないたいのであれば、
     `gnus-use-adaptive-scoring' を `nil' に設定し、それを行ないたいグ
     ループのスコアファイルに `(adapt t)' を挿入しましょう。

`adapt-file'
     すべての適応スコア・エントリーは、このエントリーによって名づけられ
     たファイルに入ります。さらにそれはグループに入るときにも適用されま
     す。このアトムは、多くのグループで同じ適応スコアファイルを用いるこ
     とによって、複数のグループに一度に適応スコアを付けたいときに便利で
     しょう。

`local'
     このエントリーの値は `(VAR VALUE)' の形式の対のリストでなければな
     りません。それぞれの VAR は現在の概略バッファーでバッファーローカ
     ルになり、指定された値 (VALUE) に設定されます。これは少し風変わり
     ですが、フックがあまり好きでないならば、いくつかのグループで変数を
     設定するのに便利な方法です。VALUE は評価されないことに注意してくだ
     さい。



File: gnus-ja.info, Node: Score File Editing, Next: Adaptive Scoring, Prev: Score File Format, Up: Scoring

スコアファイルの編集
====================

普通はすべてのスコア命令を概略バッファーから発行しますが、手でそれらを
編集したくなることもあるかもしれないので、それのためのモードを用意して
います。

それは以下に列挙する命令を使えるように、少しカスタマイズしただけの
`emacs-lisp' モードです:

`C-c C-c'
     あなたが行なった変更を保存して概略バッファーに戻ります
     (`gnus-score-edit-exit')。

`C-c C-d'
     現在の日付を数値の様式で挿入します
     (`gnus-score-edit-insert-date')。これはどのようなものだろうと考え
     ているのなら、これは本当に日の数値です。

`C-c C-p'
     適応スコアファイルは整形されずに保存されます。もしこれらのファイル
     の一つを読むつもりなら、まず "pretty print" (整形して印字) したい
     でしょう。この命令 (`gnus-score-pretty-print') がそれを行ないます。

このモードを使うには `M-x gnus-score-mode' とタイプしてください。

`gnus-score-menu-hook' がスコアモードのバッファーで実行されます。

概略バッファーでは、`V f'、`V e' および `V t' のような命令でスコアファ
イルの編集を始めることができます。



File: gnus-ja.info, Node: Adaptive Scoring, Next: Home Score File, Prev: Score File Editing, Up: Scoring

適応スコア付け
==============

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、Gnus に
はこれらをすべて自動的に--まるで魔法でも使ったように作成する方法があり
ます。いやむしろ、人工無能によって、という方が正確かな。

記事を読んだとき、記事に既読の印を付けたとき、あるいは記事を削除したと
きに、その印を残しておいてください。グループから出るときに、Gnus はそれ
らの印の辺りを嗅ぎ回り、何の印を見つけたかに応じてスコア要素を追加しま
す。この機能は `gnus-use-adaptive-scoring' を `t' か `(line)' に設定す
ると有効になります。もしスコアを、表題に現れる個別の単語をもとに適応さ
せたければ、この変数を `(word)' に設定してください。両方の適応方法を使
いたければ、この変数を `(word line)' に設定してください。

スコア付けの処理を完全に制御するために
`gnus-default-adaptive-score-alist' 変数をカスタマイズしてください。例
えば、こんな感じになるでしょう:

     (setq gnus-default-adaptive-score-alist
           '((gnus-unread-mark)
             (gnus-ticked-mark (from 4))
             (gnus-dormant-mark (from 5))
             (gnus-del-mark (from -4) (subject -1))
             (gnus-read-mark (from 4) (subject 2))
             (gnus-expirable-mark (from -1) (subject -1))
             (gnus-killed-mark (from -1) (subject -3))
             (gnus-kill-file-mark)
             (gnus-ancient-mark)
             (gnus-low-score-mark)
             (gnus-catchup-mark (from -1) (subject -1))))

ご覧のように、この連想リストの各要素は、キーとして印 (変数名か「実際の」
印すなわち文字のいずれか) を持ちます。このキーの後には任意の数のヘッダー
/スコアの組が続きます。もしそのキーの後にヘッダー/スコアの組が一つもな
ければ、そのキーが記事の印として付いている記事に対しては適応型スコア付
けは行なわれません。例えば上記の例では、`gnus-unread-mark' が付いている
記事は、適応型スコア付けのエントリーを持ちません。

各記事は一つしか印を持ち得ないので、それぞれの記事にはこれらの規則のう
ちの一つだけが適用されます。

`gnus-del-mark' を例に取りましょう--この連想リストでの意味は、この印
(すなわち `e' の印) が付いている記事はすべて、`From' ヘッダーをもと
に -4 下げられ `Subject' で -1 下げられるスコア・エントリーが追加されま
す。これをあなたの偏見に合わせて変更してください。

もし 10 個の記事に同じ subject で `gnus-del-mark' の印が付いていたとす
ると、この印に対する規則は十回適用されます。それはつまり、その subject
は -1 の十倍のスコアを得ます。その値は、私が大きく誤解していないかぎ
り -10 のはずです。

もし自動期限切れ消去 (メール) グループ (*Note Expiring Mail::) があれば、
既読記事にはすべて `E' 印が付けられます。これはおそらく適応型スコア付け
をちょっとばかりやりにくくするので、自動期限切れ消去と適応型スコア付け
は、一緒には現実にあまりうまくやっていけません。

スコアを付けられるヘッダーには `from', `subject', `message-id',
`references', `xref', `lines', `chars' および `date' があります。さらに
`followup' にもスコア付けができて、これは現在の記事の `Message-ID' を使っ
て `References' ヘッダーに合致、すなわちこれに続くスレッドに合致する適
応型スコア・エントリーを作成します。

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を避ける
ために、スコアファイルの `mark' アトムを何か小さい値--ひょっとする
と -300 くらいに設定しておくべきです。

適応型スコア付けを一週間かそこら使ってくると、Gnus はそれ相応に調教され、
あなたが何も言わなくても、あなたの好きな投稿者を強調し、あまり好きでは
ない投稿者を消去するようになるはずです。

どのグループにおいて適応型スコア付けを作動させるかは、スコアファイル
(*Note Score File Format::) を使うことによって制御できます。またこれを
使って、違ったグループに対して違った規則を使うようにもできます。

適応型スコア・エントリーは、グループ名に `gnus-adaptive-file-suffix' を
付加した名前のファイルに入れられます。ディフォルトは `ADAPT' です。

適応型スコアファイルは巨大になり得るので、人の手で編集されることは想定
されていません。`gnus-adaptive-pretty-print' が `nil' (ディフォルト) で
あると、それらのファイルは人に読めるような形式では書かれません。

適応型スコア付けを行なうときは、部分文字列一致やファジーな一致を行なっ
た方が、おそらくほとんどの場合において良い結果が得られるでしょう。しか
し、ヘッダーの一致する部分が短い場合、意図に反する動作をする可能性が大
きいので、`gnus-score-exact-adapt-limit' より短い長さしか一致しない場合
は完全一致が行なわれます。この変数が `nil' であれば、この問題が起こらな
いように常に完全一致が行なわれます。

上で述べたように、個別の単語ででもヘッダー全体ででも適応を行なうことが
できます。単語で適応を行なう場合には、それぞれの単語の事例が、ある印に
どんなスコアを加えるかを、`gnus-default-adaptive-word-score-alist' 変数
によって指定します。

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

これがディフォルト値です。単語での適応を有効にすると、`gnus-read-mark'
の印が付いている記事の表題に現れるすべての単語が、スコアに 30 点追加す
るというスコア規則を生み出します。

`gnus-default-ignored-adaptive-words' のリストに現れる単語は無視されま
す。無視したい単語を追加したいときは、この変数ではなく
`gnus-ignored-adaptive-words' リストの方を使ってください。

短い単語では適応型スコア付けを作動させるべきではないと思う人もいるでしょ
う。もしそうなら `gnus-adaptive-word-length-limit' に整数を設定すること
ができ、この数値より短い単語は無視されます。この変数のディフォルトは
`nil' です。

スコア付けが行なわれるとき、`gnus-adaptive-word-syntax-table' が実際に
使われるシンタックステーブルです。これは標準シンタックステーブルと似て
いますが、数字を単語の構成要素ではない文字だと認識します。

もし `gnus-adaptive-word-minimum' に数値が設定されていると、単語適応型
スコア付け処理において、記事のスコアがこの数値よりも小さくなることはあ
りません。ディフォルトは `nil' です。

`gnus-acaptive-word-no-group-words' が `t' に設定されていると、Gnus は
グループ名のすべての語について、単語適応型スコア付けをしません。ほとん
どの表題が `emacs' という語を含んでいる `comp.editors.emacs' のようなグ
ループで便利です。

この機構をしばらく使ってみた後で、規則を解析することによってあなたがど
んな単語が好きでどんな単語が嫌いかを診断する `gnus-psychoanalyze-user'
(利用者精神分析命令) を書いてみると良いかもしれません。いや、良くないか
な。

単語適応型スコア付けは高度に実験的なものなので、将来変更されるであろう
ことは心に留めておいてください。第一印象では、これは現状ではまったく使
い物にならないように思えます。これをもっと使えるようにするためには、(よ
り厳密な統計的手法を巻き込んで) さらなる作業が行なわれる必要があるでしょ
う。



File: gnus-ja.info, Node: Home Score File, Next: Followups To Yourself, Prev: Adaptive Scoring, Up: Scoring

ホームスコアファイル
====================

新しいスコアファイルエントリーが入れられるスコアファイルは、ホームスコ
アファイル "home score file" と呼ばれます。これは通常 (ディフォルトで)
そのグループ自身のためのスコアファイルになります。例えば
`gnu.emacs.gnus' 用のホームスコアファイルは `gnu.emacs.gnus.SCORE' です。

しかしながら、これはあなたのお望みではないかもしれません。たくさんのグ
ループの間で共通のホームスコアファイルを共有することはしばしば便利で
す--例えばすべての `emacs' グループが、ことによると同じホームスコアファ
イルを使うことができます。

これを制御する変数が `gnus-home-score-file' です。これは以下の値を取り
得ます:

  1. 文字列。この場合、このファイルがすべてのグループでホームスコアファ
     イルとして使用されます。

  2. 関数。この関数の結果がホームスコアファイルとして使用されます。この
     関数はグループの名前を引数として呼び出されます。

  3. リスト。このリストの要素は以下の値を取り得ます:

       1. `(REGEXP FILE-NAME)'。REGEXP がグループ名に合致すると、
          FILE-NAME がホームスコアファイルとして使用されます。

       2. 関数。この関数が `nil' 以外を返せば、その戻り値がホームスコア
          ファイルとして使用されます。グループ名が引数として関数に渡さ
          れます。

       3. 文字列。この文字列をホームスコアファイルとして使用します。

     このリストは、合致するものを探すために先頭から終りに向かってなぞら
     れます。

というわけで、単一のスコアファイルだけを使いたい場合は、以下のようにす
れば良いでしょう:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

すべての `gnu' グループに対して `gnu.SCORE' を、すべての `rec' グループ
に対して `rec.SCORE' (等々) を使いたい場合は、このように設定することが
できます:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

これは利用者の便宜のために、あらかじめ提供されている関数です。他に以下
の関数があります:

`gnus-current-home-score-file'
     「現在の」標準スコアファイルを返します。これはスコア命令群に「最深」
     の合致するスコアファイルにエントリーを加えさせます。

`emacs' グループ用に一つのスコアファイルを、それとは別のものを `comp'
グループ用に用意する一方、他のすべてのグループではそれぞれ独自のスコア
ファイルを使うようにしたいなら、こんな設定で良いでしょう:

     (setq gnus-home-score-file
           ;; 正規表現 `"\\.emacs"' に合致するすべてのグループ
           '(("\\.emacs" "emacs.SCORE")
             ;; すべての comp グループを単一のスコアファイルで
             ("^comp" "comp.SCORE")))

`gnus-home-adapt-file' は `gnus-home-score-file' とまったく同じやり方で
動作しますが、代わりにこれで、何をホーム適応スコアファイルにするかを指
定します。すべての新しい適応ファイルエントリーは、この変数で指定される
ファイルに入れられ、同じ文法を使うことができます。

`gnus-home-score-file' と `gnus-home-adapt-file' を使うことに加えて、グ
ループパラメーター (*Note Group Parameters::) とトピックパラメーター
(*Note Topic Parameters::) を使っても、ほぼ同様のことを成し遂げることが
できます。グループ、トピックパラメーターはこの変数よりも優先されます。



File: gnus-ja.info, Node: Followups To Yourself, Next: Scoring On Other Headers, Prev: Home Score File, Up: Scoring

自分自身へのフォローアップ
==========================

Gnus は現在のバッファーから `Message-ID' ヘッダーを見つけ出すための二つ
の命令を提供します。そして Gnus は、他の記事の `References' ヘッダーに
あるこの `Message-ID' を使ってスコアを付けるためのスコア規則を追加しま
す。これは事実上、現在のバッファーにある記事に返答したすべての記事のス
コアを増加させます。これは、あなたが言ったことに人々が答えたら、それに
容易に気付かせてもらいたいときに、とても便利です。

`gnus-score-followup-article'
     これは、あなた自身の記事に直接フォローアップした記事にスコアを加え
     ます。

`gnus-score-followup-thread'
     これは、あなたの記事より「下」のスレッドに現れるすべての記事にスコ
     アを加えます。

これら二つの関数は、本来どちらも `message-sent-hook' のようなフックの中
で、例えばこのように使うためのものです:

     (add-hook 'message-sent-hook 'gnus-score-followup-thread)

自分の `Message-ID' をじっくりと眺めてみると、はじめの二〜三文字は常に
同じであることに気が付くでしょう。以下の二つは私のものです:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

したがって、このマシンでは `x6' で「私」かどうかを見分けることができま
す。これは使えます--以下の規則は、私自身へのすべてのフォローアップのス
コアを上げるでしょう:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

「あなたの」が最初の二文字になるか最初の三文字になるかは、システムに依
存します。



File: gnus-ja.info, Node: Scoring On Other Headers, Next: Scoring Tips, Prev: Followups To Yourself, Up: Scoring

他のヘッダーにスコアを付ける
============================

Gnus が「伝統的」なヘッダー ---`From', `Subject' など--にスコアを付ける
のはとても速いです。ですが、他のヘッダーにスコアを付けるには `head' の
スコアのための規則を書く必要があり、それは合致を探すために Gnus が毎回
バックエンドから単独の記事を取り寄せなければならないことを意味します。
これは大きなグループでは長い時間がかかります。

ヘッダーまたは本文の遅いスコア付けは、変数 `gnus-inhibit-slow-scoring'
を設定することによって禁止することができます。もし
`gnus-inhibit-slow-scoring' が正規表現だったら、グループがその正規表現
に合致する場合に遅いスコア付けが禁止されます。それが `t' だったら、すべ
てのグループで遅いスコア付けが禁止されます。

さて、これに関してニュースグループでの遅さのためにできることは多くはあ
りませんが、メールグループのためにはより優れた手段があります。*Note To
From Newsgroups:: の章でこの機構がどう働くかが詳しく説明されていますが、
ここではどうしたら `nnml' で `To' と `Cc' ヘッダーにスコアを付けること
ができるかの調理の例を挙げましょう。

以下を `~/.gnus.el' ファイルに置いてください。

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

Gnus を再起動して、`M-x nnml-generate-nov-databases' コマンドで `nnml'
の overview ファイルを作り直してください。たくさんのメールを持っている
と、これには長い時間がかかるでしょう。

そして `I e s p To RET <your name> RET' のようにすると、`To' と `Cc' ヘッ
ダーに“extra headers”としてスコアを付けることができます。

わかったかな? 簡単だよね。



File: gnus-ja.info, Node: Scoring Tips, Next: Reverse Scoring, Prev: Scoring On Other Headers, Up: Scoring

スコア付けの奥義
================

"クロスポスト"
     クロスポストのスコアを低くしたければ、合致させるべき行は `Xref' ヘッ
     ダーです。

          ("xref" (" talk.politics.misc:" -1000))

"複数のクロスポスト"
     ある数、例えば三つ以上のグループにクロスポストされている記事のスコ
     アを低くしたければ、

          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"本文への合致"
     これは一般的にはあまり良い考えではありません--とても長い時間がかか
     るからです。実際 Gnus は、それぞれの記事を個別にサーバーから取得し
     てこなければならないのです。でも、とにかくあなたはやりたいのでしょ
     うね。合致させるキーは三つ (`Head', `Body', `All') あるのですが、
     それぞれのスコアファイルで一つを選んで、それに固執すべきです。もし
     二つを使うと、それぞれの記事は *二回* 取得されてしまいます。もし
     `Head' でちょっとだけ、`Body' でもちょっとだけ合致させたい、という
     のであれば、素直に `All' を使って全部合致させてください。

"既読として印を付ける"
     ある一定の値より低いスコアを持つ記事には、おそらく既読の印を付けて
     しまいたくなるでしょう。これは `all.SCORE' ファイルに以下のものを
     入れておくことによって、最も簡単に実現できます。

          ((mark -100))

     同様のことを `expunge' で行なうことを考えても良いでしょう。

"否定文字クラス"
     もし `[^abcd]*' みたいなものを指定すると、期待外れの結果で終わるか
     もしれません。これは改行文字にも合致してしまうので、えーと、未知の
     ものまで引きずり出してしまうもしれません。代わりに `[^abcd\n]*' を
     使いましょう。



File: gnus-ja.info, Node: Reverse Scoring, Next: Global Score Files, Prev: Scoring Tips, Up: Scoring

逆スコア
========

もし、表題ヘッダーに `Sex with Emacs' という文字がある記事だけを残して、
その他の記事すべてを消去してしまいたければ、スコアファイルに以下のよう
なものを入れることができます:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

これで `Sex with Emacs' に合致するすべての記事のスコアが上がって、残り
の記事には既読の印が付き、おまけにそれらは消去されるでしょう。



File: gnus-ja.info, Node: Global Score Files, Next: Kill Files, Prev: Reverse Scoring, Up: Scoring

グローバルスコアファイル
========================

間違いなく、他のニュースリーダーは「グローバル削除ファイル (global
kill file)」を持っています。それらは普通、すべてのグループに適用される、
利用者のホームディレクトリーに格納されている一つの削除ファイル以上の何
物でもありません。ふふん!  つまらない、低能なニュースリーダーだね。

私がここで話しているのはグローバルスコアファイルです。全世界の、あらゆ
る地域の利用者のスコアファイル。それはすべての国家を巨大な一つの幸せな
スコアファイル同盟に団結させる!  スコア天使!  新しい、でもテストされて
いない!

他人のスコアファイルを使うためにしなければならないのは、
`gnus-global-score-files' 変数を設定することがすべてです。それぞれのス
コアファイルにつき一つ、またはそれぞれのスコアファイルディレクトリーに
つき一つのエントリーになります。Gnus はどのスコアファイルをどのグループ
に使うのが適切であるかを自分で決定します。

例えはスコアファイル
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' および
`/ftp@ftp.some-where:/pub/score' ディレクトリーにあるすべてのスコアファ
イルを使いたければ、このように設定してください:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

単純でしょう?  ディレクトリー名は `/' で終わらなくてはなりません。これ
らのディレクトリーは、一般に Gnus を使う一回の期間中に一回だけしか読み
込まれません。もし遠隔ディレクトリーを手動で再読み込みすることが必要だ
と思ったら、`gnus-score-search-global-directories' 命令を使ってください。

ただし、現時点ではこのオプションを使うと、グループに入るのがいくらか遅
くなります。(つまり--かなり、ですけど。)

他の人たちに使ってもらうためにスコアファイルを維持管理したくなったら、
単にあなたのスコアファイルを匿名 ftp に置いて、世界に公表してください。
逆行司会者になりましょう!  その後に続いて間違いなく起こる逆行司会者戦争、
すなわち人々の共感を勝ち取るための戦いに参加して、彼らのスコアファイル
に偽りの前提を使わせるように誘導するのです!  やったね!  これでネットは
救われる!

     `retro-' を「逆行」と訳しました。日本では「レトロ」を「古き善き時
     代の」のような肯定的な意味で使うことが少なくないのですが、ここでは
     本来の「時代に逆行した」「使えねー」のような意味で使っています。

以下に、逆行司会者なりたがりのための秘技をいくつか、即席で述べます:

   * 非常に多くの場所にクロスポストされている記事は間違いなく屑である。
   * 一個の不適切な記事を減点するには、`Message-ID' で減点する。
   * 特に素晴らしい投稿者たちは永続的な基準で加算して良い。
   * そのグループの憲章を無視した投稿を頻繁に繰り返す投稿者は、絶滅させ
     てしまって差し支えない。
   * `mark' と `expunge' アトムを設定し、汚らわしい記事を完全に葬り去る。

   * 期限切れ消去のスコア・エントリーを使って、ファイルの大きさを小さく
     抑える。もっとも、サイトによって古い記事を長期間保存するように、お
     そらく長い期限切れ消去の期間を取るでしょうけれども。

... 果たして他のニュースリーダーは、将来グローバルスコアファイルをサ
ポートするでしょうか?  *うふふ*。そう、どう考えてみたって、Blue Wave や
xrn や 1stReader とかいったニュースリーダーは、スコアをサポートするべき
ですね。今は固唾を飲んで見守ることにしましょうか?



File: gnus-ja.info, Node: Kill Files, Next: Converting Kill Files, Prev: Global Score Files, Up: Scoring

消去ファイル
============

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。実際消
去ファイルの項目はもう消してもよいのですが、それは Daniel Quinlan がス
コアファイルを考え出す前に私が書いたものなので、そのコードはまだ残して
あるのです。

要するに、消去処理はスコア処理よりもかなり (私に言わせれば *ものすごく
*) 遅いので、あなたの消去ファイルはスコアファイルに書き換えた方が良いか
もしれません。

いずれにせよ、消去ファイルは普通の `emacs-lisp' ファイルです。このファ
イルの中にはどんな形式でも入れることができます。つまり消去ファイルをグ
ループに入ったときに実行する一種の原始的なフック関数のように使うことが
できます。まあそれがあまりいい方法ではないとしてもね。

通常の消去ファイルは以下のようになります:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

これは私が書いたすべての記事に既読の印を付け、概略バッファーから印の付
いた記事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムではまったく違う消去ファイルの構文を使っています。Gnus は
`rn' の消去ファイルらしきものに出会うと、何とかそれを解釈しようとします。

GNUS 消去ファイルを編集するための二つの概略バッファー関数があります:

`M-k'
     このグループの消去ファイルを編集します
     (`gnus-summary-edit-local-kill')。

`M-K'
     一般消去ファイルを編集します (`gnus-summary-edit-global-kill')。

消去ファイルを編集する二つのグループモード関数があります:

`M-k'
     このグループの消去ファイルを編集します
     (`gnus-group-edit-local-kill')。

`M-K'
     一般消去ファイルを編集します (`gnus-group-edit-global-kill')。

消去ファイル変数:

`gnus-kill-file-name'
     `soc.motss' グループ用の消去ファイルは通常 `soc.motss.KILL' という
     名前です。このファイル名を得るためにグループ名に付加される接尾語は、
     `gnus-kill-file-name' 変数で与えられます。「グローバル」消去ファイ
     ルは (スコアファイルの意味での「グローバル」じゃないよ、もちろん)
     単に `KILL' という名前です。

`gnus-kill-save-kill-file'
     この変数が `nil' 以外であれば、Gnus は処理の後に消去ファイルを保存
     します。これは期限切れ消去を行なう消去を使っているときに必要です。

`gnus-apply-kill-hook'
     グループに消去ファイルを適用するために呼び出されるフック。これはディ
     フォルトでは `(gnus-apply-kill-file)' です。同じグループのためのス
     コアファイルがある場合に消去ファイルを無視したければ、このフックを
     `(gnus-apply-kill-file-unless-scored)' に設定してください。消去ファ
     イルを処理させたくなければ、この変数を `nil' に設定してください。

`gnus-kill-file-mode-hook'
     消去ファイルモードのバッファー内で呼び出されるフック。



File: gnus-ja.info, Node: Converting Kill Files, Next: Advanced Scoring, Prev: Kill Files, Up: Scoring

消去ファイルの変換
==================

あなたが古い消去ファイルをどっさり持っているのであれば、それらをスコア
ファイルに変換したくなるでしょう。もしそれらが「普通の」ものであれば、
`gnus-kill-to-score.el' パッケージを使うことができます。そうでなければ、
手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準では Emacs には
含まれていません。それは Gnus の配布の contrib ディレクトリー、または
`http://heim.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el' から
入手することができます。

あなたの消去ファイルが非常に複雑なのであれば--それに `gnus-kill' 形式以
外のものがたくさん含まれているのなら、それらを手で変換しなければならな
いでしょう。あるいは、単そのままにしておいてください。Gnus は以前と同様
にそれらを使ってくれるでしょう。



File: gnus-ja.info, Node: Advanced Scoring, Next: Score Decays, Prev: Converting Kill Files, Up: Scoring

上級スコア付け
==============

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、本当に興味があ
るのが、特定の表題に関してある人が言っていることだけだった場合はどうす
れば良いでしょう?  もしくは、A さんが B さんにフォローアップしていると
きは彼女が言っていることを読みたくないけれど、C さんにフォローアップし
ているときは何を言っているかを知りたいという場合は?

上級スコア規則を使えば、どんな複雑なスコアのパターンでも作成することが
できます。

* Menu:

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限に利用する



File: gnus-ja.info, Node: Advanced Scoring Syntax, Next: Advanced Scoring Examples, Prev: Advanced Scoring, Up: Advanced Scoring

上級スコア付け構文
------------------

普通のスコア規則では、規則の最初の要素が文字列です。上級スコア付け規則
では、最初の要素はリストです。二番目の要素は、最初の要素が `nil' でない
値として評価されたときに適用されるスコアです。

これらのリストは三つの論理演算子、一つのリダイレクト演算子 (訳注: 本文
では間接演算子と表記されています)、および様々な合致演算子で構成すること
ができます。

論理演算子:

`&'
`and'
     この論理演算子は、それぞれの引数を順に評価して、ある評価の結果が
     `false' になったら停止します。すべての引数が `true' の値に評価され
     た場合、この演算子は `true' を返します。

`|'
`or'
     この論理演算子は、それぞれの引数を順に評価して、ある評価の結果が
     `true' になったら停止します。どの引数も `true' でなかったら、この
     演算子は `false' を返します。

`!'
`not'
`,A,'
     この論理演算子はたった一つの引数を取ります。その引数の値の論理否定
     を返します。

スコア付けされている現在の記事の先祖たちに対して、その引数群を適用する
「間接演算子」があります。例えば `1-' は、現在の記事の親にもスコア規則
を適用します。`2-' は現在の記事の祖父母にスコア規則を適用します。代わり
に `^^' を書くこともでき、`^' (caret==キャレット) の数でどのくらい祖先
の記事までさかのぼるかを示します。

最後に合致演算子があります。これらが本当の仕事をするものです。合致演算
子はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合
致演算子は `("form" "Lars Ingebrigtsen" s)' のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。



File: gnus-ja.info, Node: Advanced Scoring Examples, Next: Advanced Scoring Tips, Prev: Advanced Scoring Syntax, Up: Advanced Scoring

上級スコア付けの例
------------------

以下の例はスコアファイルの規則であることに注意してください。それらを使っ
て完璧なスコアファイルを作るには、別の括弧の組でそれらを囲んでください。

Lars が Gnus に関して話をしているときに、彼によって書かれた記事のスコア
を増やしたいとしましょう:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

ふん、簡単すぎるかな?

彼が長い記事を書くとき、時々何か素敵なことを言います:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigil Logge")))
      -100000)

Redmondo が消えた靴下について書いたときにフォローアップしたすべての人の
スコアが上げられますが、それは彼らが白い靴下について語っているときのみ
です。しかし Lars が靴下について話をしているときは、たいていあまりおも
しろくありません:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

大量の記事が流れているグループを読んでいて、返答にしか興味が無いとしま
しょう。そういう場合にやることは、"Re:"、"Fw:" または "Fwd:" で始まる表
題を持っていないすべての記事のスコアを下げて、返答の印で始まる表題を持っ
ている記事のすべての親のスコアを上げることです。

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

可能性は無限大です。



File: gnus-ja.info, Node: Advanced Scoring Tips, Prev: Advanced Scoring Examples, Up: Advanced Scoring

上級スコアのちょっとした秘訣
----------------------------

`&' と `|' 論理演算子は、無意味な処理を迂回する論理 (原典:
short-circuit logic) に基づいて動作します。すなわち、その処理の結果が明
らかになった時点で、引数を処理することを止めます。例えば `&' の引数の一
つが `false' に評価されると、残りの引数を評価する意味がありませんから。
これは遅い合致 (`body' や `header') を最後に持ってきて、速い合致
(`from' や `subject') を最初に持ってくるべきであることを示唆します。

間接演算子 (`1-' など) は、それらの引数をスレッドの一世代前に作用させま
す。次のようなことをすると:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

これは「現在の記事の祖父母の from ヘッダーでスコアを付ける」ということ
を意味します。間接演算子の処理はとても速いのですが、以下のやり方の方が:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

次のものより良いです:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))



File: gnus-ja.info, Node: Score Decays, Prev: Advanced Scoring, Up: Scoring

スコアを減衰させる
==================

スコアは (特に適応スコアを使っていると) 際限無く膨れ上がる傾向があるこ
とに気が付くでしょう。スコアが大きくなりすぎると、それらはすべての意味
を失います--それらは単に最大値に達してしまうので、意味のある方法で使う
ことは難しくなります。

Gnus はこの問題の解決を助けるためにスコアを減衰させる機構を提供します。
スコアファイルが読み込まれて、`gnus-decay-scores' が `nil' ではないと、
Gnus はスコアファイルを減衰機構に通して、すべての永続でないスコア規則の
スコアを下げます。もし `gnus-decay-scores' が正規表現だったら、それに合
致するスコアファイルだけが扱われます。例えば *adaptive* スコアファイル
だけを減衰させるには、それを `\\.ADAPT\\'' に設定すれば良いでしょう。減
衰そのものは `gnus-decay-score-function' 関数によって実行され、ディフォ
ルトは `gnus-decay-score' です。以下はその関数の定義です:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

`gnus-score-decay-constant' はディフォルトで 3、
`gnus-score-decay-scale' は 0.05 です。これは以下のようなことを引き起こ
します:

  1. この関数が呼ばれたときに -3 から 3 の間のスコアは 0 に設定されます。

  2. 3 から 60 までの間の大きさのスコアは 3 減らされます。

  3. 60 より大きいスコアはスコアの 5% が減らされます。

もしこの減衰関数がお気に召さないなら、自分用の関数を書いてください。そ
れは減衰させるべきスコアを唯一の引数として呼ばれ、新しいスコアを整数で
返さなければなりません。

Gnus は一日に一回スコアを減衰させようとします。例えば Gnus を四日間走ら
せていないと、Gnus はスコアを四回減衰させます。




File: gnus-ja.info, Node: Various, Next: The End, Prev: Scoring, Up: Top

いろいろ
********

* Menu:

* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーの見栄えを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Compilation::                 Gnus を速くするには
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Buttons::                     たった十回たたいただけで腱鞘炎になる!
* Daemons::                     Gnus はあなたの裏で仕事をすることができる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* Image Enhancements::          最新の Emacs/XEmacs は画像を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        頼んでもいない広告メールを避ける簡単な方法
* Spam Package::                Spam を濾過して処理するためのパッケージ
* The Gnus Registry::           記事を Message-ID で辿るためのパッケージ
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの



File: gnus-ja.info, Node: Process/Prefix, Next: Interactive, Prev: Various, Up: Various

プロセス/接頭引数
=================

多くの関数、その中でも記事の移動、デコード、保存をするための関数は、
「プロセス/接頭引数の習慣」として知られているものを使います。

これは、利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

数値接頭引数が N だったら、現在の記事を含めた次の N 個の記事に対して作
業を実行します。もし数値接頭引数が負だったら、現在の記事を含めた前の N
個の記事に対して作業を実行します。

`transient-mark-mode' が `nil' ではなく、リージョンが設定されていたら、
リージョンにあるすべての記事で作業が行なわれます。

数値接頭引数が無くても、いくつかの記事はプロセス印が付いている場合には、
プロセス印が付いている記事で作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事でだけ
作業を実行します。

これは実際とても単純なのですが、びっくりされないためにも、はっきりさせ
ておく必要があります。

プロセス印に反応するコマンドは、現在プロセス印が付いている記事のリスト
をスタックに積んで、記事のすべてのプロセス印を消去します。前回の設定を
`M P y' で復旧させることができます (*Note Setting Process Marks::)。

多くの人々をぎょっとさせ、恐がらせると思われることの一つは、例えば `3
d' が、本当に `d' `d' `d' と同じことをすることです。それぞれの `d' (こ
れは現在の記事に既読の印を付けます) は、ディフォルトでは印を付けた後で
次の未読記事に移動するので、`3 d' は概略バッファーがどうなっていても、
次の三つの未読記事を既読にします。動作をもっと分かりやすくするには、
`gnus-summary-goto-unread' を `nil' に設定してください。

多くのコマンドはプロセス/接頭引数の習慣を使いません。それをしないすべて
のコマンドは、このマニュアルで明記されています。そういうコマンドにプロ
セス/接頭引数の習慣を適用するには、`M-&' コマンドを使ってください。例え
ば、そのグループのすべての記事を期限切れ消去可能として印を付けるには
`M P b M-& E' とします。



File: gnus-ja.info, Node: Interactive, Next: Symbolic Prefixes, Prev: Process/Prefix, Up: Various

利用者との相互作用
==================

`gnus-novice-user'
     この変数が `nil' でないのは、あなたは Usenet の世界の新参者か非常
     に慎重な人のどちらかだというです。これは本当に良いことです。何か危
     険なことをする前に、「本当にこれをしたいのですか?」というような質
     問を受けます。これはディフォルトでは `t' です。

`gnus-expert-user'
     この変数が `nil' でないと、あなたが Gnus から質問を受けることは滅
     多に無いでしょう。これは単純に、あなたがどんな変なことをしても、何
     をしているかをわかっていると見なします。

`gnus-interactive-catchup'
     `nil' でないと、グループに追いつく (catchup, 未読の記事を読んだこ
     とにしてしまう) 前に、確認を求めます。ディフォルトで `t' です。

`gnus-interactive-exit'
     Gnus を終了する前に確認を求めます。ディフォルトで `t' です。



