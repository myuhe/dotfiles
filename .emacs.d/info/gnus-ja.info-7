Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006, 2007 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契
     約書第 1.2 版またはそれ以降の版が定める条件の下で複製、配布、ある
     いは変更することを許可します。変更不可部分は指定しません。“A GNU
     Manual”は表表紙テキスト、以下の (a) は裏表紙テキストです。この利
     用許諾契約書の複写は“Emacs manual”の「GNU フリー文書利用許諾契約
     書」という章に含まれています。

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     (a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフト
     ウェアのように複製したり変更する自由があります。複製はフリーソフト
     ウェア財団によって出版されました。(フリーソフトウェア財団は) GNU
     の開発のために必要な資金を集めています。」

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.

     この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集
     著作物の一部です。もしあなたがこの文書を収集著作物から分離して配布
     したいときは、契約書の第 6 章に記述されているように、文書に契約書
     の複写を付加することによって、行なうことができます。



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY





File: gnus-ja.info, Node: Mail Source Customization, Next: Fetching Mail, Prev: Mail Source Specifiers, Up: Mail Sources

メールソースのカスタマイズ
..........................

以下はメールの取得方法に影響する変数の一覧です。普通はこれらのどれも設
定または変更する必要は無いでしょう。

`mail-source-crash-box'
     メールが、それを処理している期間中に格納されている場所です。ディフォ
     ルトは `~/.emacs-mail-crash-box' です。

`mail-source-delete-incoming'
     `nil' でなければ、入って来たメールを一時的に格納したファイルを、そ
     れを処理した後で消去します。`t' ではファイルをただちに消去し、
     `nil' ではいかなるファイルも消しません。正の数だった場合は、その日
     数以上に古いファイルを消去します (消去は新着メールを受け取るときだ
     け行なわれます)。`mail-source-delete-incoming' を `nil' にしておい
     て、`mail-source-delete-old-incoming' をフックで呼ぶか、または対話
     的に呼ぶこともできます。

`mail-source-delete-old-incoming-confirm'
     非-`nil' だったら、古い incoming (メールの到着時に使われた) ファイ
     ルを消去するときに確認を求めます。この変数は
     `mail-source-delete-incoming' が正の数である場合だけ使われます。

`mail-source-ignore-errors'
     非-`nil' だったら、メールソースからメールを読むときのエラーを無視
     します。

`mail-source-directory'
     入ってきたメールソースのファイルが (もしあれば) 格納されるディレク
     トリーです。ディフォルトは `~/Mail/' です。現時点でこれが使われる
     唯一のものは、変数 `mail-source-delete-incoming' が `nil' または数
     値であった場合に、入ってきたメールを格納するファイルの置き場所の指
     定です。

`mail-source-incoming-file-prefix'
     入ってきたメールを一時的に格納するファイルの名前の接頭語です。ディ
     フォルトは `Incoming' で、この場合ファイルは `Incoming30630D_' や
     `Incoming298602ZD' のようになります。これが本当に関係するのは
     `mail-source-delete-incoming' が `nil' または数値の場合だけすが。

`mail-source-default-file-modes'
     すべての新しいメールファイルはこのファイルモードになります。ディフォ
     ルトは 384 です。

`mail-source-movemail-program'
     `nil' でなかったら、新着メールを取り込むためのプログラムの名前であ
     ると解釈されます。`nil' だったら `exec-directory' にある
     `movemail' が使われます。



File: gnus-ja.info, Node: Fetching Mail, Prev: Mail Source Customization, Up: Mail Sources

メールの取得
............

新しいメールをどこから取得するかを実際に Gnus に指示する手段は、
`mail-sources' をメールソース指示子のリストに設定することです (*Note
Mail Source Specifiers::)。

この変数 (と旧式の `nnmail-spool-file') が `nil' であれば、メールバック
エンドは決して自分自身ではメールを取得しようとしません。

ローカルのスプールと POP メールサーバーの両方からメールを取得したいなら、
このようにすることができます:

     (setq mail-sources
           '((file)
             (pop :server "pop3.mail.server"
                  :password "secret")))

あるいは、これらのキーワードのどんなディフォルトも使いたくなければ、こ
のようにして下さい:

     (setq mail-sources
           '((file :path "/var/spool/mail/user-name")
             (pop :server "pop3.mail.server"
                  :user "user-name"
                  :port "pop3"
                  :password "secret")))

あなたがメールバックエンドを使うとき、Gnus はすべてのメールを inbox か
ら吸い上げてホームディレクトリーに放り込みます。あなたがメールバックエ
ンドを使っていないときは、Gnus は一通もメールを移動しません--そういう場
合には、最初にたくさんの魔法を唱えなければなりません。まず五芳星を描き、
蝋燭を灯し、山羊を生け贄として捧げ終えた後には、Gnus があなたのメールを
移動したとしても、あなたは実際にはあまり驚かないはずです。



File: gnus-ja.info, Node: Mail Back End Variables, Next: Fancy Mail Splitting, Prev: Mail Sources, Up: Getting Mail

メールバックエンド変数
----------------------

これらの変数 (のほとんど) は、すべてのさまざまなメールバックエンドに関
連します。

`nnmail-read-incoming-hook'
     すべてのメールバックエンドは、新しいメールを読み込んだ後にこのフッ
     クを呼びます。そうしたければ、何かのメール監視プログラムに知らせる
     ためにこのフックを使うことができます。

`nnmail-split-hook'
     それぞれのメッセージがそのヘッダーに基づいて分割がなされる直前に、
     それが格納されているバッファーで実行されるフックです。このフックは、
     それがふさわしいと考えられるようにするために、どんなやり方ででも自
     由にバッファーの内容を編集することができます--バッファーは分割が終
     わった後で捨てられ、バッファーで行なわれた変更はどのファイルにも現
     れません。`gnus-article-decode-rfc1522' は、このフックに加えられる
     ことがありそうな関数の一つです。

`nnmail-pre-get-new-mail-hook'
`nnmail-post-get-new-mail-hook'
     これらは、入ってくるメールを処理するときに実行される、有用な二つの
     フックです---`nnmail-pre-get-new-mail-hook' は新しいメールを処理す
     る直前に呼ばれ、`nnmail-post-get-new-mail-hook' はメールの扱う処理
     が終わったときに呼ばれます。以下はこれらの二つのフックを使って、新
     しいメールのファイルのファイルモードを変更する例です:

          (add-hook 'nnmail-pre-get-new-mail-hook
                    (lambda () (set-default-file-modes 511)))

          (add-hook 'nnmail-post-get-new-mail-hook
                    (lambda () (set-default-file-modes 551)))

`nnmail-use-long-file-names'
     `nil' でないなら、メールバックエンドは長いファイル名とディレクトリー
     名を使います。`mail.misc' のようなグループは `mail.misc' という長
     い名前のディレクトリーかファイルに収められます (`nnml' バックエン
     ドの場合はディレクトリー、`nnfolder' バックエンドの場合はファイル
     です)。`nil' だったら、同じグループは `mail/misc' に収められます。

`nnmail-delete-file-function'
     ファイルを消去するために呼ばれる関数です。ディフォルトは
     `delete-file' です。

`nnmail-cache-accepted-message-ids'
     `nil' でないと、バックエンドに (例えば `Gcc' によって) 入って来た
     記事の `Message-ID' を、メールの重複を発見するためのキャッシュに入
     れます。ディフォルトは `nil' です。

`nnmail-cache-ignore-groups'
     正規表現か正規表現のリストです。名前がどれかの正規表現に合致するグ
     ループの記事は、`Message-ID' キャッシュに記録されません。

     例えば特級分割 (*Note Fancy Mail Splitting::) を関数
     `nnmail-split-fancy-with-parent' とともに使っている場合に役立つで
     しょう。



File: gnus-ja.info, Node: Fancy Mail Splitting, Next: Group Mail Splitting, Prev: Mail Back End Variables, Up: Getting Mail

特級メール分割
--------------

     訳注: "Fancy" という単語は、創造的、空想的、気まぐれな、好きな、派
     手な、上等な、極上の、変わり種の、等々のさまざまな意味で使われます
     が、ここでは助動詞無しで使える利便を考えて「特級」という訳語を割り
     当てました。

比較的単純な、標準のメール分割指定の方法では思い通りにならないならば、
`nnmail-split-methods' を `nnmail-split-fancy' に設定すると良いでしょう。
そうすると、変数 `nnmail-split-fancy' で遊ぶことができるようになります。

まずこの変数の値の例を見てみましょう:

     ;; メイラーデーモンから送られたメッセージが、普通のグループにクロス
     ;; ポストされないようにします。警告は本当のエラーとは違ったグループ
     ;; に入れます。
     (| ("from" mail (| ("subject" "warn.*" "mail.warning")
                        "mail.misc"))
        ;; エラーでないメッセージはすべての関連するグループにクロスポスト
        ;; しますが、(ding) メーリングリストと他の (ding) 関連のメールの
        ;; ためのグループにはクロスポストしません。
        (& (| (any "ding@ifi\\.uio\\.no" "ding.list")
              ("subject" "ding" "ding.misc"))
           ;; 他のメーリングリスト...
           (any "procmail@informatik\\.rwth-aachen\\.de" "procmail.list")
           (any "SmartList@informatik\\.rwth-aachen\\.de" "SmartList.list")
           ;; 以下のどちらのメーリングリストも同じ接尾語なので、bugs- だ
           ;; けに投稿されたものが mypkg.list にクロスポストされないよう
           ;; にしています。しかし本当にクロスポストされた記事をクロスポ
           ;; ストすることはできるようになっています。
           (any "bugs-mypackage@somewhere" "mypkg.bugs")
           (any "mypackage@somewhere" - "bugs-mypackage" "mypkg.list")
           ;; 人々...
           (any "larsi@ifi\\.uio\\.no" "people.Lars_Magne_Ingebrigtsen"))
        ;; 合致しなかったメールはすべてを捕まえるグループへ行きます。
        "misc.misc")

この変数は「分割」の様式になっています。分割は (ことによると) それぞれ
の分割が他の分割を含む再帰的構造です。以下は使うことができる分割の構文
です:

`group'
     分割が文字列だったら、それはグループ名であるとみなされます。通常の正規表
     現の展開が行なわれます。後述の例 (訳注: `\\&',
     `\\1'〜`\\9') を見て下さい。

`(FIELD VALUE [- RESTRICT [...] ] SPLIT [INVERT-PARTIAL])'
     この分割は少なくとも三つの要素を含んでいる必要があります。最初の要
     素 FIELD (正規表現) に合致するヘッダーが VALUE (これも正規表現) に
     合致する文字列を含んでいたならば、SPLIT で指定されたグループにメッ
     セージを格納します。

     FIELD の後にあって、しかも合致した VALUE の最後尾より前にある何か
     の文字列に RESTRICT (これもまた正規表現) が合致したら、SPLIT は無
     視されます。いくつかの RESTRICT のどれもが合致しなければ SPLIT が
     実行されます。

     最後の要素 INVERT-PARTIAL は任意です。これが省略されていなくて、し
     かも値が `nil' でなければ、語 (word) の境界をまたいで正規表現の合
     致を行なうかどうかの振る舞い
     (`nnmail-split-fancy-match-partial-words' 変数によって制御されます;
     下記参照) が反転します。(Gnus 5.10.7 の新機能)

`(| SPLIT ...)'
     分割がリストで、最初の要素が `|' (垂直棒) だったら、それぞれの
     SPLIT をそのうちの一つが合致するまで実行します。ここで言う「合致」
     とは、ある SPLIT がメッセージを一つ以上のグループに格納しようとす
     ることです。

`(& SPLIT ...)'
     分割がリストで、最初の要素が `&' だったら、そのリストにあるすべて
     の SPLIT を実行します。

`junk'
     もし分割がシンボル `junk' だったら、そのメッセージを保存しません
     (すなわち、消去してしまいます)。非常に注意して使って下さい。

`(: FUNCTION ARG1 ARG2 ...)'
     もし分割がリストで、最初の要素が `:' だったら、二番目の要素が
     ARGS を引数として関数として呼ばれます。関数は SPLIT を返さなければ
     なりません。

     例えば以下の関数は、記事のボディーに基づいた分割に使えるでしょう:

          (defun split-on-body ()
            (save-excursion
              (save-restriction
                (widen)
                (goto-char (point-min))
                (when (re-search-forward "Some.*string" nil t)
                  "string.group"))))

     FUNCTION が実行されるとき、バッファーはメッセージの部分に狭められ
     ます。それが上記の例で `save-excursion' と `save-restriction' の後
     で `(widen)' を呼ぶ必要がある理由です。さらに `nnimap' バックエン
     ドの場合、ディフォルトでは記事のボディーがダウンロードされないこと
     に注意して下さい。それをするためには `nnimap-split-download-body'
     を `t' に設定する必要があります (*Note Splitting in IMAP::)。

`(! FUNC SPLIT)'
     分割がリストで最初の要素が `!' だったら、SPLIT が実行され、FUNC は
     SPLIT の結果を引数として呼ばれます。FUNC は分割を返さなければなり
     ません。

`nil'
     分割が `nil' だったら、それは無視されます。

これらの分割で FILELD は完全なフィールド名 (と言うかヘッダー名) に合致
しなければなりません。

通常これらの分割における VALUE は、基礎モード (fundamental mode) 構文テー
ブル (syntax table) に従って、完全に *語* (word) に合致しなければなりま
せん。言い換えれば、すべての VALUE は暗に `\<...\>' 印 (語の区切り記号)
で囲まれます。したがって、例えば以下の分割を使うと、

     (any "joe" "joemail")

`joedavis@foo.org' からやって来たメッセージは、通常 `joemail' には格納
されないでしょう。この振る舞いを変更したければ、以下の三つのやり方のど
れでもを使うことができます:

  1. `nnmail-split-fancy-match-partial-words' 変数を `nil' ではない値に
     設定することによって、語の境界を無視させることができます。すると、
     合致はより grep ふうになります。この変数は、特級分割で語の境界をま
     たいだ合致を行なうかどうかを制御します。ディフォルト値は `nil' で
     す。

     分割の規則のすべての VALUE に影響することに注意して下さい。

  2. `.*' で始まる VALUE は、語の前にある語の境界を無視させます。
     同様に `.*' で終わる VALUE は、語の後ろにある語の境界を無視さ
     せます。例えば `"@example\\.com"' とい
     う VALUE は `foo@example.com' に合致しませんが、
     `".*@example\\.com"' ならば合致します。

  3. この章の最初の方で述べた INVERT-PARTIAL フラグを、`(FIELD
     VALUE ...)' 型の分割規則で使うことができます。このフラグが設定され
     ていると、`nnmail-split-fancy-match-partial-words' が `nil' であっ
     ても、語の両側にある語の境界は無視されます。逆に、このフラグが設定
     されていると、`nnmail-split-fancy-match-partial-words' が `nil' で
     はない値であっても、語の境界は無視されません。(Gnus 5.10.7 の新機
     能)

FIELD と VALUE は Lisp シンボルであることもできます。その場合それらは
`nnmail-split-abbrev-alist' で指定された内容に従って展開されます。これ
はセルの CAR がキーを含んでいて、CDR が関連付けられた値を持っているコン
スセル (cons cell) の連想リストです。以下の項目が、あらかじめ
`nnmail-split-abbrev-alist' に定義されています:

`from'
     `From'、`Sender' および `Resent-From' の各フィールドに合致します。
`to'
     `To'、`Cc'、`Apparently-To'、`Resent-To' および `Resent-Cc' の各
     フィールドに合致します。
`any'
     `from' と `to' を統合したものです。

`nnmail-split-fancy-syntax-table' は、これらのすべての分割が実行されて
いるときに有効な構文テーブルです。

ヘッダーのいくつかの情報に基づいて、Gnus に動的にグループを作らせたい
(例えば、グループ名の一部を `replace-match' のようなやり方で置き換えさ
せたい) ならば、次のようなことができます。

     (any "debian-\\b\\(\\w+\\)@lists.debian.org" "mail.debian.\\1")

この例では、`debian-foo@lists.debian.org' に送られたメールは
`mail.debian.foo' というグループに入れられます。

文字列が要素 `\\&' を含んでいる場合は、直前に合致した文字列で置き換えら
れます。同様に、要素 `\\1' から `\\9' までは、合致した文字列の一部で置
き換えられます (訳注: 正規表現の中に `\\(' と `\\)' を使ってグループに
まとめられたものが一つ以上ある場合に、`\\N' はその正規表現の N 個目のグ
ループに合致する文字列の一部で置き換えられます)。

その際、合致した文字列を小文字にしたもので置き換えるべきかどうかを
`nnmail-split-lowercase-expanded' が決定します。これを非-`nil' にするこ
とによって、アドレスで大文字と小文字が区別せずに使われている (例えば
mailing-list@domain と Mailing-List@Domain) 場合でも、複数のグループが
生成されてしまうことを避けることができます。ディフォルトは `t' です。

関数 `nnmail-split-fancy-with-parent' は、フォローアップ記事を親記事と
同じグループに振り分けるために使います。メールの振り分けを一生懸命設定
してみても完璧にはできないことがありますね。例えば、上司から個人宛ての
メールが届いたとします。自分が携っているプロジェクトとは別の話です。け
れど「他のメールと区別できるようにこれこれこういう言葉を表題に書いて下
さい」と上司に向かって指図するわけにはいきませんから、結局自分の手を煩
わしてひとつひとつメールを正しいグループに振り分けるはめになります。そ
んなときにこの関数を使うと、この面倒な作業を一スレッドにつき一回きりで
済ますことができます。

この機能を利用するためには、まず変数 `nnmail-treat-duplicates' および
`nnmail-cache-accepted-message-ids' の値を `nil' ではない値に設定する必
要があります。それができたら `nnmail-split-fancy-with-parent' を使って
みて下さい。コロンを使ってこんな風に書きます:

     (setq nnmail-treat-duplicates 'warn     ; または `delete'
           nnmail-cache-accepted-message-ids t
           nnmail-split-fancy
           '(| (: nnmail-split-fancy-with-parent)
               ;; 残りの振り分け方はここに書く
             ))

この機能は実際、次の様に働いています: 変数 `nnmail-treat-duplicates' の
値が非-`nil' の場合、Gnus は見つけた全記事のメッセージ ID を変数
`nnmail-message-id-cache-file' で指定されたファイルに記録します。このと
き、それぞれの記事が格納されたグループの名前を併記します (ただしメール
ではないメッセージの場合は、グループ名は省略されます)。さて、いよいよメー
ルの振り分けが始まると、関数 `nnmail-split-fancy-with-parent' は、分割
される各記事の References (と In-Reply-To) ヘッダーを調べ、
`nnmail-message-id-cache-file' で指定されたファイルにそれらのメッセージ
ID があるかどうか調べます。親記事が見つかると、そのグループ名が正規表現
`nnmail-split-fancy-with-parent-ignore-groups' に合致しなければ、この関
数は対応するグループ名を返すわけです。ここで、変数
`nnmail-message-id-cache-length' の値をディフォルトよりも幾らか大きな値
に設定することを勧めます。そうすると、今調べられたメッセージ ID たちは
今しばらくキャッシュの中に存続できます (5000 に設定するとキャッシュファ
イルの大きさはだいたい 300 キロバイトぐらいになるみたいです)。さらに、
変数 `nnmail-cache-accepted-message-ids' の値を非-`nil' に設定すれば、
Gnus は移動された記事のメッセージ ID をも記録するので、フォローアップ記
事は親記事の移動先と同じグループに入るようになります。

特定のグループをキャッシュに記録したくない場合は、変数
`nnmail-cache-ignore-groups' も参照して下さい。例えば、外に出すすべての
メッセージを“outgoing”グループに保存しているのならば、
`nnmail-cache-ignore-groups' をそのグループ名に合致するように設定すれば
良いでしょう。さもないとあなたのすべてのメッセージに対する返事が
“outgoing”グループに入ってしまいます。



File: gnus-ja.info, Node: Group Mail Splitting, Next: Incorporating Old Mail, Prev: Fancy Mail Splitting, Up: Getting Mail

グループメール分割
------------------

何ダースものメーリングリストを購読しているけれど、手でメール分割規則を
維持したくないというときのために、グループメール分割というものがありま
す。あなたがしなければならないことは、グループパラメーターかグループカ
スタマイズで `to-list', `to-address' の両方もしくはどちらかを設定して
`nnmail-split-methods' を `gnus-group-split' に設定するだけです。分割関
数はすべてのグループでこれらのパラメーターを走査し、それに従って分割し
ます。すなわち、メールグループのパラメーター `to-list' か `to-address'
で指定されたアドレスから投稿されたものか、そのアドレスへ投稿されたメッ
セージがそのグループに保存されます。

ときには、メーリングリストには複数のアドレスがあり、メール分割にそれら
すべてを認識させる必要があるかもしれません: `extra-aliases' グループパ
ラメーターを追加のアドレスのリストに設定するだけで終りです。あえて正規
表現を使いたければ、`split-regexp' を設定して下さい。

これらのすべてのグループのパラメーターは、`nnmail-split-fancy' の分割を
作成するために使用されます。その分割の仕様の中身は、FIELD の値が `any'
であり、VALUE の値が `to-list' と `to-address' と `extra-aliases' のす
べてと `split-regexp' に合致するもののすべてに合致する単一の正規表現、
そして SPLIT がグループの名前になります。RESTRICT も使うことができます:
それには `split-exclude' パラメーターを正規表現のリストに設定して下さい。

これらのすべてのパラメーターを使って正しい分割が生成されないときや、何
かもっと凝ったものが必要なときは、`split-spec' パラメーターを
`nnmail-split-fancy' の分割に設定することができます。この場合は、前もっ
て書かれたすべてのパラメーターは `gnus-group-split' に無視されます。特
に、`split-spec' は `nil' (訳注: これも `nnmail-split-fancy' の分割の一
種です) に設定することができ、その場合そのグループは
`gnus-group-split' に無視されます。

それぞれのグループのために、一つの分割を含む単一の `&' 特級分割を定義す
ることによって、`gnus-group-split' は合致するすべてのグループにクロスポ
ストをします。どの分割にも合致しないメッセージは、どれかのグループで
SPLIT-SPEC が `catch-all' に設定されていない場合は
`gnus-group-split-default-catch-all-group' で指定された名前のグループに
格納されます。その場合、そのグループはすべてを受け取る (catch-all) グルー
プとして使われます。この変数はしばしばグループを指定するためだけに使わ
れますが、任意の複雑な特級分割に設定することもできるので (結局のところ
グループ名は特級分割なのです)、個人のメールフォルダーにそれらのメールが
格納されるどのメーリングリストにも当てはまらないメールを、分割するのに
便利でしょう。なおこの特級分割は、`|' 分割リスト (それは、グループパラ
メーターから抽出された規則を持った `&' 分割をも含んでいます) の最後の要
素として追加されることに注意して下さい。

そろそろ例を出すべきでしょう。以下のグループパラメーターが定義されてい
ることを仮定します:

     nnml:mail.bar:
     ((to-address . "bar@femail.com")
      (split-regexp . ".*@femail\\.com"))
     nnml:mail.foo:
     ((to-list . "foo@nowhere.gov")
      (extra-aliases "foo@localhost" "foo-redist@home")
      (split-exclude "bugs-foo" "rambling-foo")
      (admin-address . "foo-request@nowhere.gov"))
     nnml:mail.others:
     ((split-spec . catch-all))

`nnmail-split-methods' を `gnus-group-split' に設定すると、
`nnmail-split-fancy' が選択されていて、かつ変数 `nnmail-split-fancy' が
以下のように設定されているかのように振舞います:

     (| (& (any "\\(bar@femail\\.com\\|.*@femail\\.com\\)" "mail.bar")
           (any "\\(foo@nowhere\\.gov\\|foo@localhost\\|foo-redist@home\\)"
                - "bugs-foo" - "rambling-foo" "mail.foo"))
        "mail.others")

グループ分割をすべてのメールグループで積極的には使いたくなければ、
`nnmail-split-fancy' の分割を次のように使用することで、いくつかのグルー
プだけで使うことができます。

     (: gnus-group-split-fancy GROUPS NO-CROSSPOST CATCH-ALL)

GROUPS は、出力の分割を生成するためにパラメーターが走査されるグループ名
のリストか、それらのグループ名に合致する正規表現です。NO-CROSSPOST はク
ロスポストを禁止するために使うことができ、その場合は、単一の `|' 分割が
出力されます。CATCH-ALL は `gnus-group-split-default-catch-all-group'
のように、最後の手段として使われる特級分割です。CATCH-ALL が `nil' に設
定されているか、`split-regexp' がどれかの選択されたグループで空の文字列
に合致すると、すべてを受け取る (catch-all) 分割は発行されません。そうで
ない場合、あるグループに `catch-all' に設定されている `split-spec' があ
ると、そのグループは CATCH-ALL 引数の値よりも優先されます。

不運なことに、すべてのグループとそれらのパラメーターを走査することは、
特にすべてのメッセージに対して行なわなければならないことを考慮に入れる
と、非常に遅くなるでしょう。でも、絶望してはいけません。
`gnus-group-split-setup' 関数を、はるかに効率的な方法で
`gnus-group-split' を動作させるために使うことができます。それは
`nnmail-split-methods' を `nnmail-split-fancy' に設定し、
`nnmail-split-fancy' を `gnus-group-split-fancy' で生成される分割に設定
します。そうすることによって、どんなに分割するメッセージがたくさんあっ
ても、グループパラメーターは一度だけ走査されるようになります。

しかしながら、グループパラメーターを変更すると、`nnmail-split-fancy' を
手で更新しなければならなくなるでしょう。`gnus-group-split-update' を実
行することによって、それを行なうことができます。どちらかと言えば、それ
を自動的に更新したい場合には、`gnus-group-split-setup' にそれを実行する
ように指示して下さい。例えば、`~/.gnus.el' に以下のものを追加すれば良い
でしょう:

     (gnus-group-split-setup AUTO-UPDATE CATCH-ALL)

AUTO-UPDATE が `nil' でなければ `gnus-group-split-update' が
`nnmail-pre-get-new-mail-hook' に追加されるので、二度と
`nnmail-split-fancy' の更新について心配する必要はありません。CATCH-ALL
を省略しない場合は (それはオプションで `nil' と等価です)、
`gnus-group-split-default-catch-all-group' がその値に設定されます。

`gnus-group-split-update' によって設定された `nnmail-split-fancy' を後
で変更する必要があるときのために、この関数 (`gnus-group-split-update')
は終了する直前に `gnus-group-split-update-hook' を実行します。



File: gnus-ja.info, Node: Incorporating Old Mail, Next: Expiring Mail, Prev: Group Mail Splitting, Up: Getting Mail

古いメールを取り込む
--------------------

たいていの人は色々なファイルフォーマットで保存されたたくさんの古いメー
ルを持っているでしょう。Gnus の粋なメールバックエンドの一つを使うように
設定したのであれば、おそらく古いメールをメールグループに取り込みたいと
思いますよね。

それをすることはとても簡単です。

例を挙げましょう: `nnml' (*Note Mail Spool::) を使ってメールを読んでい
て、`nnmail-split-methods' を申し分の無い値に設定しているものとしましょ
う。重要な、しかし古いメールで、古い Unix mbox ファイルが満たされていま
す。あなたはそれを `nnml' グループに移動したいと思っています。

方法です:

  1. グループバッファーに行って下さい。

  2. `G f' をタイプして下さい。`nndoc' グループを作成するための元になる
     mbox ファイルの名前を求められるので、それを入力して下さい (*Note
     Foreign Groups::)。

  3. `SPACE' をタイプして、新しく作られたグループに入って下さい。

  4. `M P b' をタイプして、グループバッファーのすべての記事に実行印を付
     けて下さい (*Note Setting Process Marks::)。

  5. `B r' をタイプしてプロセス印の付いたすべての記事を再スプールして下
     さい。その際に入力を求められるので、`nnml' と答えて下さい (*Note
     Mail Group Commands::)。

今や mbox ファイルのすべてのメールメッセージは、あなたの `nnml' グルー
プ群にもばらまかれています。それらに入って、ものごとが変な故障も無く、
うまくいったかどうかを調べて下さい。大丈夫なようであれば、mbox ファイル
を消そうと思うかもしれませんが、私はすべてのメールがあるべきところに納
まったことを完全に確認するまでは、そうはしません。

再スプールすることは、あるメールバックエンドを別のものに変更するときに
も便利なものです。古いメールグループにあるメールは、新しいメールバック
エンドを使ってただ再スプールすれば良いのです。



File: gnus-ja.info, Node: Expiring Mail, Next: Washing Mail, Prev: Incorporating Old Mail, Up: Getting Mail

メールの期限切れ消去
--------------------

伝統的なメールリーダーは、既読の印を付けるとメールの記事を何らかの方法
で削除する傾向があります。Gnus はメールを読むことに対して、基本的に違う
方法を取ります。

基本的に Gnus は、メールを少々変わった方法で受け取られたニュースである
とみなします。実際にメールを変更したり、メールメッセージを消す権限があ
るとは考えません。あなたがメールグループに入って記事に「既読」の印を付
けたり、何らかの他のやり方で切ったりしても、メールの記事はまだシステム
に存在しています。繰り返します: Gnus はあなたの古い既読のメールを消去し
ません。もちろん、あなたがそうしろと要求しない限りの話ですが。

要らないメールを Gnus に削除させるには、記事に「期限切れ消去可能」
(expirable) の印を付けなければなりません。(ディフォルトのキー割り当てで
は、`E' をタイプしなければならないということです。) しかしながら、これ
は記事が即座に消え去るということではありません。一般的にメール記事は、
1) 期限切れ消去可能の印が付いていて、かつ 2) 一週間以上経っている、とい
う場合に、システムによって削除されます。記事を期限切れ消去可能にしなけ
れば、それは地獄が凍りつくまでシステムに残り続けます。このことは、もう
一度強調付きで繰り返されるに足るものです: 「もし」あなたが記事を「期限
切れ消去可能」に「しない」なら、Gnus は「決して」それらの「記事」を消去
しません。

手作業で記事に期限切れ消去可能の印を付けなければならないわけではありま
せん。Gnus は“auto-expire”および“total-expire”と呼ばれる二つの機能
を提供して、あなたの手助けをします。かいつまんで言えば“auto-expire”は
あなたが記事を選択したときに Gnus が `E' を叩いてくれることを意味します。
そして“total-expire”は、すべての既読の記事は期限切れ消去可能であると
Gnus が解釈することを意味します。したがって `E' の印が付けられた記事に
加えて、`r', `R', `O', `K', `Y' などの印が付けられた記事も期限切れ消去
可能であると解釈されます。

では auto-expire または total-expire は、いつ使用されるべきなのでしょう
か?  メーリングリストを購読しているほとんどの人々は、それぞれのリストが
それ用のグループに分割されるようにして、それらのグループに対して
auto-expire または total-expire を有効にしています。(それぞれのリストを
それ用のグループへの分割する件についてのさらなる情報は *Note Splitting
Mail:: を参照して下さい。)

auto-expire と total-expire のどちらが良いのでしょうか?  それに答えるの
は簡単ではありません。概して言えば、たぶん auto-expire が速いでしょう。
auto-expire の別の利点は、より多くの印を後で読み返すつもりの記事に使う
ことができる、つまり今までどおりに可視 (tick)、保留 (dormant) または既
読 (read) の中から選ぶことができるということです。しかし total-expire
では、dormant と ticked からしか選べません。total-expire の利点は、適応
スコア付け (*Note Adaptive Scoring::) で良好に働くことです。
auto-expire は通常のスコア付けでは動作しますが、適応スコア付けではだめ
です。

正規表現 `gnus-auto-expirable-newsgroups' に合致するグループでは、読ん
だすべての記事に自動的に期限切れ消去可能の印が付けられます。期限切れ消
去可能の印の付いたすべての記事は、概略バッファーの最初の桁に `E' が表示
されます。

自動期限切れ消去を有効にすると、ディフォルトではあなたが読んだすべての
記事に、以前に読まれたかどうかに関わらず、 Gnus は期限切れ消去可能の印
を付けます。既読の印が付いている記事に、自動的に期限切れ消去可能の印が
付けられるのを避けるには、以下のようなものを `~/.gnus.el' ファイルに置
いておけば良いでしょう:

     (remove-hook 'gnus-mark-article-hook
                  'gnus-summary-mark-read-and-unread-as-read)
     (add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read)

グループを自動期限切れ消去可能にしても、すべての既読の記事が期限切れ消
去されるわけではなく、期限切れ消去可能の印が付いている記事だけが期限切
れ消去されることに気を付けて下さい。また、`d' 命令が自動的に記事を期限
切れ消去可能にするのでは無いことにも気を付けて下さい--自動期限切れ消去
可能にしたグループでは、記事に既読の印が半自動で付けられることによって
のみ、記事が期限切れ消去可能になるということです。

2〜3 のメーリングリストを講読していて、読み終わってしばらく経ったら記事
が消えてしまうようにしたいなら、例えばこんな風に設定しましょう:

     (setq gnus-auto-expirable-newsgroups
           "mail.nosense-list\\|mail.nice-list")

自動期限切れ消去を行なわせるもう一つの方法は、そのグループのグループパ
ラメーターに `auto-expire' という要素を持たせることです。

もし適応スコア付け (*Note Adaptive Scoring::) と自動期限切れ消去を使用
していると、問題が起こるでしょう。自動期限切れ消去と適応スコア付けはあ
まり良く調和しません。

変数 `nnmail-expiry-wait' で、期限切れ消去可能な記事をどれくらいの期間
残しておくかのディフォルトの時間を設定します。Gnus はメッセージが送り出
されたときではなく、それが *到着* してからの日数を計算します。ディフォ
ルトは 7 日間です。

Gnus は記事がどのグループに属しているかに基づいて、それをどのくらい残し
ておくかをこまめに設定する関数も提供しています。以下の例では
`mail.private' グループは一ヶ月、`mail.junk' グループは一日、その他全部
は六日間に、それぞれ期限を設定します:

     (setq nnmail-expiry-wait-function
           (lambda (group)
            (cond ((string= group "mail.private")
                    31)
                  ((string= group "mail.junk")
                    1)
                  ((string= group "important")
                   'never)
                  (t
                    6))))

この関数に与えられるグループ名には「装飾」すなわち `nnml:' のようなもの
は付きません。

変数 `nnmail-expiry-wait' と関数 `nnmail-expiry-wait-function' は、数値
(整数である必要はありません) かシンボルの `immediate' か `never' のどち
らかにすることができます。

期限切れ期間を選択的に変更するために、グループパラメーターの
`expiry-wait' を使うこともできます (*Note Group Parameters::)。

記事を期限切れ消去するときに取られる通常の動作は、それらを消去すること
です。しかし、場合によってはそれらを消去するよりも別のグループに移動し
た方が有意義かもしれません。変数 `nnmail-expiry-target' (とグループパラ
メーター `expiry-target') はこれを制御します。この変数の値はすべてのグ
ループに対するディフォルトになりますが、特定のグループごとにグループパ
ラメーターを使って指定すれば、そちらを優先させることができます。ディフォ
ルトの値は `delete' ですが、文字列 (記事を移動する先のグループ名) また
は移動先のグループ名か `delete' を返す関数にすることができます (関数の
場合は、記事に範囲を狭めたバッファーで、その記事が存在しているグループ
名が引数として与えられます)。

グループ名を指定する場合の例:
     (setq nnmail-expiry-target "nnml:expired")

Gnus には期限切れのメールをグループに移動させるための関数があります。そ
れは変数 `nnmail-fancy-expiry-targets' に従って動作します。例です:

      (setq nnmail-expiry-target 'nnmail-fancy-expiry-target
            nnmail-fancy-expiry-targets
            '((to-from "boss" "nnfolder:Work")
              ("subject" "IMPORTANT" "nnfolder:IMPORTANT.%Y.%b")
              ("from" ".*" "nnfolder:Archive-%Y")))

この設定を行なうことにより、表題ヘッダーに `IMPORTANT' を持っていて、
`YYYY' 年 `MMM' 月に発信されたいかなるメールも、期限になると
`nnfolder:IMPORTANT.YYYY.MMM' グループに移動させられます。また、From ま
たは To ヘッダーが文字列 `boss' を含んでいるメールは `nnfolder:Work' に、
それ以外のすべてのメールは `nnfolder:Archive-YYYY' に、それぞれ期限にな
ると移動させられます。

`nnmail-keep-last-article' が `nil' でないと、Gnus はメールグループの最
後の記事を決して期限切れ消去しません。これは procmail の利用者の人生を
より楽にするためのものです。

補足: 上記の、Gnus が決して期限切れ消去可能でない記事を期限切れ消去する
ことはない、というのは嘘です。`total-expire' をグループパラメーターに入
れても、記事に期限切れ消去の印が付くことはありませんが、読んだすべての
記事は期限切れ消去の処理に通されます。非常に注意して使って下さい。さら
に危険なのは変数 `gnus-total-expirable-newsgroups' です。この正規表現に
合致するすべてのグループでは、読んだすべての記事が期限切れ消去の処理に
通されます。これは、当のグループの *すべて* の古いメールの記事は、しば
らく後で削除されるということです。非常に注意して使って下さい。そして、
あなたが使った正規表現が間違ったグループに合致してしまい、すべての重要
なメールが消えてしまったと言って、私に泣き付いて来ないで下さい。しっか
しりなさい! (直訳: 男になりなさい、あるいは女になりなさい、さもなければ
もっと気持ちいい何にでもなりなさい!) ほうら、言わんこっちゃない!

たいていの人はほとんどのメールグループを total-expirable (全体期限切れ
消去可能) にしますが。

`gnus-inhibit-user-auto-expire' が `nil' でなければ、グループで自動期限
切れ消去が有効になっていても、利用者が印を付ける命令が記事に期限切れ消
去可能の印を付けることはありません。



File: gnus-ja.info, Node: Washing Mail, Next: Duplicates, Prev: Expiring Mail, Up: Getting Mail

メール洗濯
----------

メイラーやメーリングリストのサーバーは、メールに対して本当に本当に馬鹿
げたことをすることで悪名高いです。「わぁ、RFC822 はサーバーを通っていく
メッセージのすべての行の最後に `wE aRe ElItE!!!!!1!!' を加えることを明
示的に禁止はしていないぞ。さぁ、やってみよう!!!!1!」えぇ、そのとおりで
すが、RFC822 はおろか者が読むようには書かれていません。当たり前なこと
(訳注: 良識から逸脱すること) はそこでは議論されていません。ですから、こ
の章が必要なのです。

適例: ドイツ語版の Microsoft Exchange は返答の表題に `Re: ' の代わりに
`AW: ' を付け加えます。私はこれに動揺して狼狽しているふりをすることもで
きましたが、そうする気力がありませんでした。それは笑うべきことです。

Gnus は表示する記事を洗濯するために多すぎるほどの関数を提供していますが、
メールをディスクに保存する前にふるいにかけることができた方が良いかもし
れません。その目的のために、三つのフックとそれらのフックに入れることが
できる色々な関数を用意しています。

`nnmail-prepare-incoming-hook'
     このフックはメールに何かをする前に呼ばれ、総括的に掃除してきれいに
     する所作のためにあります。それは新しいすべての入ってきたメールを含
     んでいるバッファーで呼ばれます。使うことのできる関数は:

     `nnheader-ms-strip-cr'
          それぞれの行から、最後にあるキャリッジリターン (carriage
          return) を取り除きます。これは MS のマシン上で動作している
          Emacs のディフォルトです。

`nnmail-prepare-incoming-header-hook'
     このフックはそれぞれのメールのヘッダーに範囲を狭められて呼ばれます。
     ヘッダーをきれいにするときに使うことができます。使うことのできる関
     数は:

     `nnmail-remove-leading-whitespace'
          「役に立つ」メーリングリストのサーバーが、見栄えを良くするた
          めだと称して、ヘッダーの前の方に付け加えた空白を無くします
          (訳注: 例えば `Subject:' などの直後に二つ以上の空白文字があっ
          たら、一つを残して消します)。まったくもう。

          (この関数はすべてのメッセージのボディーの中にあるヘッダー (ボ
          ディーの中にある別のメッセージが持っているヘッダー行のような
          もの) に対しても動作するので、使用に際しては潜在的な危険を孕
          んでいます。したがってバグを修正するよりは、そういう特徴があ
          ることを文書で説明するのが、もちろん正しい解決の道です。)

     `nnmail-remove-list-identifiers'
          いくつかのメーリングリストのサーバーは、そのリストが配信した
          メールであることを同定するための識別子--例えば `(idm)'---をす
          べての `Subject' ヘッダーの先頭に付け加えます。石器時代のメー
          ルリーダーを使っている人たちには、それは確かに良いことです。
          この関数は正規表現 `nnmail-list-identifiers' に合致する文字列
          を取り除きます。それは正規表現のリストでも構いません。ただし
          正規表現に `\\(..\\)' を含めてはいけません。

          例えば `(idm)' と `nagnagnag' という識別子を取り除きたいのな
          ら:

               (setq nnmail-list-identifiers
                     '("(idm)" "nagnagnag"))

          これは `gnus-list-identifiers' で非破壊的に行なうこともできます。
          *Note Article Hiding::.

     `nnmail-remove-tabs'
          すべての `TAB' 文字を `SPACE' 文字に変換します。

     `nnmail-ignore-broken-references'
          いくつかの MUA (例えば Eudora と Pegasus) は壊れた `References' ヘッ
          ダーを作成しますが、`In-Reply-To' ヘッダーにはちゃんとしたものを入
          れます。この関数は、ヘッダー部に正規表
          現 `nnmail-broken-references-mailers' に合致する行があったら、
          `References' ヘッダーを取り除きます。

`nnmail-prepare-incoming-message-hook'
     このフックはそれぞれのメッセージに範囲を狭められて呼ばれます (訳注:
     一度に複数のメールを受信した場合でも、一通ずつ呼ばれるということで
     す)。使うことのできる関数は:

     `article-de-quoted-unreadable'
          Quoted Readable エンコードをデコードします (訳注: 実際に行な
          うのは quoted printable のデコードです)。



File: gnus-ja.info, Node: Duplicates, Next: Not Reading Mail, Prev: Washing Mail, Up: Getting Mail

重複
----

いくつかのメーリングリストのメンバーなら、時々同じメールを二つ受け取る
ことがあるでしょう。これはとても煩わしいので、`nnmail' はそれが見つけた
どんな重複をも、調べて処理します。これをするために、`nnmail' は古い
`Message-ID' を `nnmail-messagge-id-cache-file' (ディフォルトでは
`~/.nnmail-cache') に保存します。それに保存される `Message-ID' のおおよ
その最大数は変数 `nnmail-message-id-cache-length' で制御され、ディフォ
ルトは 1000 です。(ですから千個の `Message-ID' が溜められます。) これで
怖気をふるったなら、`nnmail-treat-duplicates' を `warn' (ディフォルトで
はそのようになっていますが) に設定しても良いでしょう。そうすると、
`nnmail' は重複したメールを消去しない代わりに、それが別のメッセージの重
複であるという警告をメールのヘッダーに挿入します。

この変数は関数であることもできます。その場合、関数は当のメッセージに範
囲を狭められたバッファーから `Message-ID' を引数として呼ばれます。この
関数は `nil', `warn', `delete' のどれかを返さなければなりません。

変数を `nil' に設定することによって、この機能を完全に使わないようにする
ことができます。

もしすべての重複したメールを特別な "duplicates" グループに入れたいので
あれば、普通のメール分割方法を使ってそれをすることができます:

     (setq nnmail-split-fancy
           '(| ;; 重複したメッセージは分かれたグループへ。
             ("gnus-warning" "duplicat\\(e\\|ion\\) of message" "duplicate")
             ;; デーモンやポストマスターなどからのメッセージは他へ。
             (any mail "mail.misc")
             ;; 他の規則。
             [ ... ] ))

もしくは次のようなもの:

     (setq nnmail-split-methods
           '(("duplicates" "^Gnus-Warning:.*duplicate")
             ;; 他の規則。
             [...]))

すてきな使い方があるよ: 受け手である彼女がメールを Gnus で読んでいるこ
とと、彼女が `nnmail-treat-duplicates' を `delete' に設定してあることを
知っていれば、彼女がすでに受け取ったことがわかっているメールの
`Message-ID' そのものを使って、考えられる限りたくさんの侮辱を送ることが
できるんだぜ。その面白さを考えてみてよ! 彼女はそれらを決して見ることは
ないんだ! わぉ!



File: gnus-ja.info, Node: Not Reading Mail, Next: Choosing a Mail Back End, Prev: Duplicates, Up: Getting Mail

メールを読むのではない
----------------------

あなたが使い始めたどんなメールバックエンドでも、あなたがそれらでメール
を読みたいと思っていると仮定するという、悩ましい癖を持っていることに気
が付くでしょう。これは決して不合理ではないかもしれませんが、あなたの望
むことではないかもしれません。

`mail-sources' と `nnmail-spool-file' を `nil' に設定すれば、どのバック
エンドも入ってくるメールを読もうとしなくなって、それは助けになるはずで
す。

でも、それは行き過ぎでしょう。あなたが、例えば `nnml' でメールを読むこ
とと、しまいこんである古い Rmail ファイルを `nnbabyl' を使ってざっと覗
くことだけで、まったく満足していているのならば。すべてのバックエンドに
は バックエンド-`get-new-mail' という変数があります。もし `nnbabyl' が
メールを読み込みをやめさせたいのであれば、そのグループの仮想サーバー編
集して、`nnbabyl-get-new-mail' を `nil' に設定しましょう。

すべてのメールバックエンドは、入ってくるメールを読み込むときに、保存さ
れるべき記事に範囲を狭めて `nn'*`-prepare-save-mail-hook' を呼びます。



File: gnus-ja.info, Node: Choosing a Mail Back End, Prev: Not Reading Mail, Up: Getting Mail

メールバックエンドを選ぶ
------------------------

メールグループを動作するようにすると Gnus はメールスプールを読み込みま
す。メールのファイルはまずあなたのホームディレクトリーに複写されます。
その後で何が起こるかは、メールをどの様式で格納したいかによります。

標準の Gnus では六つの違ったメールバックエンドがあり、さらに多くのバッ
クエンドを個別に手に入れることができます。ほとんどの人が使うメールバッ
クエンドは (それがたぶん最速なので) `nnml' です (*Note Mail Spool::)。

* Menu:

* Unix Mail Box::               (とても) 標準的な Un*x mbox を使う
* Rmail Babyl::                 Emacs のプログラムは Rmail の Babyl フォーマットを使う
* Mail Spool::                  あなたのメールを私的なスプールに溜める?
* MH Spool::                    mhspool のようなバックエンド
* Maildir::                     もう一つの１ファイル/１メッセージ形式
* Mail Folders::                それぞれのグループに対して一つのファイルを持つ
* Comparing Mail Back Ends::    得失の深い洞察



File: gnus-ja.info, Node: Unix Mail Box, Next: Rmail Babyl, Prev: Choosing a Mail Back End, Up: Choosing a Mail Back End

Unix メールボックス
...................

"nnmbox" バックエンドはメールを格納するために標準の Un*x mbox ファイル
を用います。`nnmbox' はそれぞれのメール記事にそれがどのグループに属して
いるかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

`nnmbox-mbox-file'
     利用者のホームディレクトリーのメールボックスの名前。ディフォルトは
     `~/mbox' です。

`nnmbox-activate-file'
     メールボックスのアクティブファイルの名前。ディフォルトは
     `~/.mbox-active' です。

`nnmbox-get-new-mail'
     `nil' でなければ、`nnmbox' は入って来たメールを読み込んでグループ
     に分割します。ディフォルトは `t' です。



File: gnus-ja.info, Node: Rmail Babyl, Next: Mail Spool, Prev: Unix Mail Box, Up: Choosing a Mail Back End

Rmail Babyl
...........

"nnbabyl" バックエンドはメールを格納するために Babyl メールボックス (別
名 "Rmail mbox") を使います。`nnbabyl' はそれぞれの記事にそれがどのグルー
プに属しているかを示す追加のヘッダーを加えます。

仮想サーバーの設定:

`nnbabyl-mbox-file'
     Rmail mbox ファイルの名前。ディフォルトは `~/RMAIL' です。

`nnbabyl-active-file'
     Rmail mbox のためのアクティブファイルの名前。ディフォルトは
     `~/.rmail-active' です。

`nnbabyl-get-new-mail'
     `nil' でなければ、`nnbabyl' は入ってくるメールを読み込みます。ディ
     フォルトは `t' です。



File: gnus-ja.info, Node: Mail Spool, Next: MH Spool, Prev: Rmail Babyl, Up: Choosing a Mail Back End

メールスプール
..............

"nnml" スプールメール様式は他の知られている様式とは互換性がありません。
それは少し注意して使われるべきです。

このバックエンドを使うと、Gnus は入ってくるメールを、それぞれのメールを
1 ファイルとしてファイルに分割し、記事を変数 `nnml-directory' で指定さ
れたディレクトリーの下の対応するディレクトリーに入れます。ディフォルト
の値は `~/Mail/' です。

前もってディレクトリーを作っておく必要はありません。その面倒は Gnus が
すべて見てくれます。

あなたのアカウントに保存できるファイルの数に厳密な制限があるなら、この
バックエンドを使うべきではありません。それぞれのメールはそれ自身のファ
イルを伴うので、数週間で数千の iノードを占有する可能性は十分にあります。
あなたにとってこれが問題でなく、親切なシステム管理者が気が狂ったように
「誰が僕の i ノードを食いつぶしているんだ? 誰だ? 誰!?!」と叫びながら歩
き回ることも問題でないなら、これがおそらく使うことのできる一番速い様式
であるということは知っておくべきでしょう。新しいメールを読むためだけに
大きな mbox ファイルを重い足取りで探す必要はありません。

`nnml' は記事分割に関してはおそらく一番遅いバックエンドでしょう。多くの
ファイルを作らなければならず、入ってくるメールのための NOV データベース
も作成しなければなりません。これのために、メールを読むことに関してはた
ぶん最速のバックエンドになるのです。

印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
`nnml' サーバーは `tar' などを使ってバックアップしたり、後であなたが付
けた印がすべて保たれた状態で Gnus に戻す (本来の `nnml' サーバーによっ
て追加する) ことができる特質を持つようになります。グループの印はそれぞ
れの `nnml' グループのディレクトリー内の、通常 `.marks' ファイル
(`nnml-marks-file-name' を参照) に格納されます。また、個々の `nnml' グ
ループについてもバックアップすることが可能で、そうするには (バックアッ
プを nnml ディレクトリーに戻した後で) `G m' キーを使ってそのグループを
元に戻して下さい。

何らかの理由によって `.marks' ファイルがおかしくなっていると思ったとき
は、単にそれら全部を消してしまえば良いでしょう。Gnus は次回起動するとき
に、それらを正しく再作成してくれます。

仮想サーバーの設定:

`nnml-directory'
     すべての `nnml' ディレクトリーはこのディレクトリーの下に置かれます。
     ディフォルトは `message-directory' の値 (そのディフォルト値は
     `~/Mail') です。

`nnml-active-file'
     `nnml' サーバーのためのアクティブファイル。ディフォルトは
     `~/Mail/active' です。

`nnml-newsgroups-file'
     `nnml' グループ記述ファイル。*Note Newsgroups File Format::. ディ
     フォルトは `~/Mail/newsgroups' です。

`nnml-get-new-mail'
     `nil' でなければ、`nnml' は入って来たメール読み込みます。ディフォ
     ルトは `t' です。

`nnml-nov-is-evil'
     `nil' でなければ、このバックエンドはどの NOV ファイルも無視します。
     ディフォルトは `nil' です。

`nnml-nov-file-name'
     NOV ファイルの名前。ディフォルトは `.overview' です。

`nnml-prepare-save-mail-hook'
     保存する前に一つの記事に範囲を狭めて実行するフックです。

`nnml-marks-is-evil'
     非-`nil' であると、このバックエンドはいかなる 印 ファイルも無視し
     ます。ディフォルトは `nil' です。

`nnml-marks-file-name'
     「印」ファイルの名前です。ディフォルトは `.marks' です。

`nnml-use-compressed-files'
     非-`nil' だったら、`nnml' は圧縮されたメッセージファイルを扱うこと
     ができるようになります。ただし `auto-compression-mode' が有効になっ
     ていなければなりません (*Note Compressed Files: (emacs)Compressed
     Files.)。`nnml-use-compressed-files' の値が文字列だった場合、それ
     は圧縮プログラムを指定するファイル拡張子として使われます。Emacs が
     それをサポートしていれば、それを `.bz2' に設定することができます。
     値 `t' は `.gz' と等価です。

`nnml-compressed-files-size-threshold'
     メッセージファイルを圧縮するかどうかを判断するための、サイズの閾値
     です。`nnml-use-compressed-files' が非-`nil' に設定されていて、本
     文の文字数がこの変数の値より大きかったら、メッセージファイルは圧縮
     されます。

`nnml' グループと NOV ファイルの調子が完全に狂ってしまったら、`M-x
nnml-generate-nov-databases' とタイプすることによって、完全に更新するこ
とができます。この命令は、それぞれすべてのファイルを見ることによって
`nnml' 階層全体をトロール魚網でさらうので、それが終わるまでには時間がか
かるかもしれません。この機能へのより良いインターフェースはサーバーバッ
ファーで見つかるでしょう (*Note Server Commands::)。

訳注: 単一の `nnml' グループの NOV データベースを再生成させるための
`nnml-generate-nov-databases-1' という命令もあります。



File: gnus-ja.info, Node: MH Spool, Next: Maildir, Prev: Mail Spool, Up: Choosing a Mail Back End

MH スプール
...........

`nnmh' は、NOV データベースを作らないこととアクティブファイルや印ファイ
ルを保持しないことを除いて、`nnml' と似ています。このことは `nnmh' を
`nnml' より *かなり* 遅いバックエンドにしていますが、procmail のスクリ
プトを書くことはずっとやりやすくなってもいます。

仮想サーバーの設定:

`nnmh-directory'
     すべての `nnmh' ディレクトリーはこのディレクトリーの下に置かれます。
     ディフォルトは `message-directory' の値 (そのディフォルトは
     `~/Mail') です。

`nnmh-get-new-mail'
     `nil' でなければ、`nnmh' は入ってくるメールを読み込みます。ディフォ
     ルトは `t' です。

`nnmh-be-safe'
     `nil' でなければ、`nnmh' はフォルダーにある記事が実際に Gnus が考
     えているものと同じであるかを調べるという馬鹿げたことをやります。そ
     れは日付と目に入るすべての情報を調べるので、これを `t' に設定する
     と深刻な速度低下が起こります。`nnmh' の記事を読むのに Gnus 以外の
     ものを使っていないのであれば、この変数を `t' に設定する必要はあり
     ません。ディフォルトは `nil' です。



File: gnus-ja.info, Node: Maildir, Next: Mail Folders, Prev: MH Spool, Up: Choosing a Mail Back End

Maildir
.......

`nnmaildir' は各々の Gnus のグループに対応する maildir に、maildir フォー
マットでメールを格納します。このフォーマットは
`http://cr.yp.to/proto/maildir.html' および
`http://www.qmail.org/man/man5/maildir.html' で文書化されています。また
`nnmaildir' は maildir の中の `.nnmaildir/' ディレクトリーに追加の情報
を格納します。

Maildir フォーマットは、配送と講読を、ロックを必要とせずに同時に行なう
ことができるようにするために設計されました。他のバックエンドでは、メー
ルを何らかのスプールに渡した後で、そのスプールからグループに分割するた
めに、Gnus を設定しなければならないでしょう。それは今まで通り
`nnmaildir' で行なうことができますが、もっと普通のやり方は、Gnus のグルー
プとして現われる maildir に配送されたメールを、直接手にすることです。

`nnmaildir' は完全に信頼できることを目指しています: `C-g' はメモリー中
のデータを壊さないし、`SIGKILL' がファイルの中のデータを壊すことはあり
ません。

`nnmaildir' は記事の印と NOV データを、それぞれの maildir に格納します。
それによって、ある Gnus の環境から別の場所に maildir 全体をコピーするこ
とができ、印は保持されます。

仮想サーバーの設定:

`directory'
     それぞれの `nnmaildir' サーバー (一つを越えるサーバーが必要だとは
     とても思えませんが) に対してディレクトリーを作り、それを maildir
     または maildir へのシンボリックリンクとして実装する必要があります
     (maildir のためだけにです。他の目的のためにすでに使われているディ
     レクトリーを選んではいけません)。それぞれの maildir は、そのサーバー
     のニュースグループとして Gnus に現れ、シンボリックリンクのファイル
     名がそのグループの名前になります。ディレクトリーにある `.' で始ま
     るどんなファイル名も無視されます。ディレクトリーは最初に Gnus を起
     動したときとグループバッファーで `g' をタイプしたときはいつでも走
     査され、どれかの maildir が削除または追加されていると、
     `nnmaildir' はそのときにそれを知ります。

     `directory' パラメーターの値は Lisp 式でなければなりません。それは
     このサーバーのためのディレクトリーのパスを得るために `eval' と
     `expand-file-name' で処理されます。その式はサーバーが開かれたとき
     だけ `eval' され、その結果得られた文字列が、サーバーが閉じられるま
     で使われます (もし、式や `eval' を知らなくでも心配ご無用; 単なる文
     字列で動作します)。このパラメーターは任意ではなく、必ず設定しなけ
     ればなりません。`"~/Mail"' やそれのサブディレクトリーを使うことは
     推奨しません。なぜかと言うと、Gnus の他の複数の部分がそれをディフォ
     ルトでいろんなものに使うので、`nnmaildir' でもそれを使うと混乱する
     かもしれないからです。`"~/.nnmaildir"' が一般的な値です。

`target-prefix'
     これは Lisp 式でなければなりません。それは `eval' と
     `expand-file-name' で処理されます。その式が `eval' されるのはサー
     バーが開かれたときだけで、その結果得られた文字列がサーバーが閉じら
     れるまで使われます。

     `nnmaildir' サーバーにグループを作ると、その名前の頭に
     `target-prefix' が付加された maildir と、その maildir を指し示すシ
     ンボリックリンクが素のグループ名の名前で作成されます。したがって、
     `directory' が `"~/.nnmaildir"' で、`target-prefix' が
     `"../maildirs/"' だった場合に `foo' というグループを作ると、
     `nnmaildir' は maildir として `~/.nnmaildir/../maildirs/foo' を、
     `../maildirs/foo' へのシンボリックリンクとして `~/.nnmaildir/foo'
     を作成します。

     同じ `directory' に maildirs とシンボリックリンクの両方を作成する
     ために、スラッシュを含まない文字列を `target-prefix' に設定するこ
     とができます。この場合は、`directory' で見つかる名前が
     `target-prefix' で始まるどの maildir も、グループとは見なされませ
     ん (が、それらを指し示すシンボリックリンクがグループになります)。

     特別な場合として `target-prefix' が `""' (それがディフォルトです)
     だったら、グループを作るときに、対応するシンボリックリンクを持たな
     い maildir が `directory' において作成されます。そのようなグループ
     に対しては、`force' 引数を与えないと `gnus-group-delete-group' が
     使えないことに気をつけて下さい。

`directory-files'
     これは `directory-files' と同じインターフェースを持っている関数
     (または `directory-files' そのもの) でなければなりません。これは
     maildir 用のサーバーの `directory' を走査するために使われます。こ
     のパラメーターは任意です。ディフォルトは、
     `nnheader-directory-files-is-safe' が `nil' だったら
     `nnheader-directory-files-safe' で、それ以外の場合は
     `directory-files' です (`nnheader-directory-files-is-safe' はサー
     バーが開いたときに一回だけ検査されますが、ディレクトリーが走査され
     るときに毎回チェックさせたいのならば、それを行なう関数をあなたが自
     前で用意する必要があります)。

`get-new-mail'
     非-`nil' にしておくと、いつもの通りにグループの maildir 自体におい
     て新着メールを走査した後で、このサーバーはさらに `mail-sources' か
     ら、`nnmail-split-methods' か `nnmail-split-fancy' の設定に従って、
     従来の Gnus の方法でメールを取り込みます。ディフォルト値は `nil'
     です。

     `mail-sources' と `nnmaildir' グループの両方で同じ maildir を使っ
     ては *いけません*。その結果は運良く有益になるかもしれませんが、そ
     んな意図では設計されていませんし、将来は違う結果をもたらす可能性が
     あります。あなたの分割規則が新しいグループを作るようになっている場
     合は、`create-directory' サーバーパラメーターを設定することを忘れ
     ないで下さい。


グループパラメーター
....................

`nnmaildir' は複数のグループパラメーターを使います。これらのすべてを無
視しても安全です。ディフォルトの `nnmaildir' の動作は、他のメールバック
エンドのディフォルト (記事が一週間後に消去される、など) と同じです。期
限切れ消去のパラメーターを除いて、この機能はすべて `nnmaildir' だけにあ
るものです。したがって、別のバックエンドですでに行なっている動作を単に
踏襲させようというのであれば、これを無視することができます。

これらのパラメーターのうちのどれでも、その値がベクトルである場合は、オ
リジナルの値に代わって、第一の要素が Lisp 式として評価された結果が使わ
れます。値がベクトルでない場合は、その値そのものが Lisp 式として評価さ
れます。(それが、これらのパラメーターが他とは違う名前、すなわち他のバッ
クエンドでサポートされているものとは違うけれども似た意味を持っている同
様のパラメーターを使っている理由です。) (数値、文字列、`nil'、および
`t' についても `eval' の関与を無視することができます。他の値について、
そうすることがふさわしい場合には、追加のクオートを使い、かつベクトルで
値を包むことを忘れないで下さい。)

`expire-age'
     記事が消去されるまでの寿命の秒数を指定する整数、あるいは記事が期限
     切れ消去されてはならないことを指定する `never' というシンボルです。
     このパラメーターが設定されていないと、いつもの
     `nnmail-expiry-wait' 変数または `nnmail-expiry-wait-function' 変数
     を最後のよりどころにします (`expiry-wait' グループパラメーターが設
     定されていると、その値が `nnmail-expiry-wait' より優先して使われ、
     `nnmail-expiry-wait-function' は無効にされます)。3日の値が必要なら
     ば、`[(* 3 24 60 60)]' のようなものを使って下さい。`nnmaildir' は
     式を評価して、その結果を使います。記事の寿命は記事ファイルの変更時
     刻を基点に計測されます。通常これは記事が配送された時刻と同じですが、
     記事の編集はそれを若くします。(期限切れ消去以外の) 記事の移動もま
     た、記事を若くしてしまうでしょう。

`expire-group'
     これが以下のような完全な Gnus のグループ名の文字列で、

          "backend+server.address.string:group.name"

     かつこのパラメーターが設定されているグループの名前と同じではなかっ
     たら、期限切れ消去が行なわれる際に、記事は消去される代わりに、これ
     で指定されたグループに移動させられます。*これが `nnmaildir' グルー
     プに設定されていると、移動先のグループにおいて、記事は元のグループ
     にあったときとちょうど同じ古さになります。* したがって、移動先のグ
     ループにおける `expire-age' には注意して下さい。これがパラメーター
     が設定されているのと同じグループの名前に設定されると、記事はまった
     く期限切れ消去されません。ベクトルの式を使うと、最初の要素が一回、
     それぞれの記事について評価されます。したがって記事をどこに置くかを
     決めるために、その式は `nnmaildir-article-file-name' などに照会す
     ることができます。*たとえこのパラメーターが設定されていなくても、
     `nnmaildir' は `expiry-target' グループパラメーターや
     `nnmail-expiry-target' 変数を顧みません。*

`read-only'
     これが `t' に設定されていると、`nnmaildir' はその記事をこの
     maildir では読み出し専用として扱います。この意味は、記事は `new/'
     から `cur/' に改名されない、記事は `cur/' ではなく `new/' でのみ見
     つかる、記事は消去されない、記事は編集できない、ということです。
     `new/' は他の maildir の `new/' ディレクトリーへのシンボリックリン
     クであると想定されます (そのディレクトリーには、例えばみんなが興味
     があるメーリングリストを含んでいる、システムで共通のメールボックス
     があります)。`new/' 以外の maildir にあるすべてのものは、読み出し
     専用として扱われ *ません*。したがって、みんなで共有するメールボッ
     クスに対しては、あなた自身の maildir を設置する (または 共有のメー
     ルボックスに書き込み権限を持つ) 必要が依然としてあります。そうすれ
     ば、あなたの maildir は記事の余分なコピーをまったく含まなくて済む
     でしょう。

`directory-files'
     `directory-files' と同じインターフェースの関数です。記事を見つける
     ために、このグループに対応する maildir のディレクトリーを走査する
     ために使われます。ディフォルトはそのサーバーの `directory-files'
     パラメーターで設定されている関数です。

`distrust-Lines:'
     非-`nil' にしておくと、`nnmaildir' は `Lines:' ヘッダーフィールド
     を使う代わりにいつも記事の行数を数えます。`nil' だった場合は、あれ
     ばそのヘッダーフィールドが使われます。

`always-marks'
     `['(read expire)]' のような印シンボルのリストです。Gnus が記事の印
     を `nnmaildir' に尋ねるときはいつでも、ファイルシステムに格納され
     ている印が何であるかとは無関係に、`nnmaildir' はすべての記事がこれ
     らの印を持っていると答えます。これは機能を検証するためのもので、お
     そらく結局は削除されるでしょう。それは Gnus 本体で行なわれるか、あ
     るいは有益でなければ放棄されるべきです。

`never-marks'
     `['(tick expire)]' のような印シンボルのリストです。Gnus が記事の印
     を `nnmaildir' に尋ねるときはいつでも、ファイルシステムに格納され
     ている印が何であるかとは無関係に、`nnmaildir' はこれらの印を持って
     いる記事は無いと答えます。`never-marks' は `always-marks' よりも優
     先されます。これは機能を検証するためのもので、おそらく結局は削除さ
     れるでしょう。それは Gnus 本体で行なわれるか、あるいは有益でなけれ
     ば放棄されるべきです。

`nov-cache-size'
     NOV メモリーキャッシュのサイズを指定する整数です。スピードアップの
     ために、`nnmaildir' はそれぞれのグループの限定された数の記事に対し
     て、メモリー上に NOV データを保持します。(これはたぶん有用ではなく、
     将来はおそらく削除されるでしょう)。このパラメーターの値は、サーバー
     が開かれた後で最初にグループが見られたとき、すなわち一般には最初に
     Gnus を起動したときだけ注目されます。サーバーが閉じられて再び開か
     れるまでは、NOV キャッシュのサイズは変更されません。ディフォルトは
     概略バッファーに表示される記事の数の見積り (`tick' 印がある記事の
     数か `read' が無い記事の数に、少々の余分を加えたもの) です。


記事の識別
..........
記事はそれぞれの maildir の `cur/' ディレクトリーに格納されます。各々の
記事には `uniq:info' のような名前が付けられます。ここで `uniq' はコロン
を含みません。`nnmaildir' は `:info' の部分を保持しますが無視します。
(他の maildir リーダーは一般に印を格納するためにこの部分を使います。)
`uniq' の部分は記事をユニークに識別し、maildir の `.nnmaildir/' サブディ
レクトリーの色々な場所に、対応する記事の情報を格納するために使われます。
記事の完全なパス名は、概略バッファーで記事を要求した後で
`nnmaildir-article-file-name' 変数から得られます。


NOV データ
..........
`uniq' によって識別される記事は、その NOV データ (概略バッファーの行を
生成するために使われる) を `.nnmaildir/nov/uniq' に格納します。
`nnmaildir-generate-nov-databases' 関数はありません。(その必要はあまり
ありません。記事の NOV データは記事か `nnmail-extra-headers' が変化した
ときに自動的に更新されます。) 対応する NOV ファイルを消すことによって、
単一の記事だけの NOV データの生成を `nnmaildir' に強制することはできま
す。しかし *ご用心*。これは `nnmaildir' にこの記事に新しい記事番号を割
り振らせるので、`seen' 印、エージェント、およびキャッシュにとって面倒な
ことになります。


記事の印
........
`.nnmaildir/marks/flag/uniq' ファイルがある場合に、`uniq' によって識別
される記事は、`flag' 印を持つものと考えられます。Gnus が `nnmaildir' に
グループの印を尋ねると、`nnmaildir' はそのようなファイルを探して、見つ
けた印のセットを報告します。Gnus が `nnmaildir' に印のセットを格納する
ことを要求すると、`nnmaildir' は必要に応じて対応するファイルを生成し、
または消去します。(実際は、それぞれの印のために新しいファイルを作るので
はなく、iノードを節約するために単に `.nnmaildir/markfile' へのハードリ
ンクを張ります。)

`.nnmaildir/marks/' に新しいディレクトリーを作ることによって、新しい印
を創造することができます。印を保持しつつ maildir を tar でまとめてサー
バーからそれを削除し、後で tar をほどくと、印は保持されています。印ファ
イルを作成または消去することによって、あなた自身が印を追加または削除す
ることができます。Gnus が動作していて `nnmaildir' サーバーが開いている
ときにこれを行なう場合は、最初にすべての `nnmaildir' グループの概略バッ
ファーから退出してグループバッファーで `s' をタイプし、その後グループバッ
ファーで `g' か `M-g' をタイプするのが最良です。そうしないと Gnus は変
更を捉えてくれずに、それらを元に戻してしまうかもしれません。



File: gnus-ja.info, Node: Mail Folders, Next: Comparing Mail Back Ends, Prev: Maildir, Up: Choosing a Mail Back End

メールフォルダー
................

`nnfolder' はそれぞれのメールグループを別々ファイルに格納するバックエン
ドです。それぞれのファイルは標準の Un*x mbox 様式です。`nnfolder' は記
事番号と到着時刻を見失わないようにするための追加のヘッダーを加えます。

印ファイル (訳注: marks file) が使われると (それがディフォルトですが)、
`nnfolder' サーバーは `tar' などを使ってバックアップしたり、後であなた
が付けた印がすべて保たれた状態で Gnus に戻す (本来の `nnfolder' サーバー
によって追加する) ことができる特質を持つようになります。グループの印は
`nnfolder' ディレクトリー内の、mbox ファイルに通常 `.mrk'
(`nnfolder-marks-file-name' を参照) が付加された名前のファイルに格納さ
れます。また、個々の `nnfolder' グループについてもバックアップすること
が可能で、(バックアップを nnfolder ディレクトリーに戻した後で) `G m' キー
を使えば、そのグループは元に戻ります。

仮想サーバーの設定:

`nnfolder-directory'
     すべての `nnfolder' メールボックスはこのディレクトリーの下に置かれ
     ます。ディフォルトは `message-directory' の値 (そのディフォルトは
     `~/Mail') です。

`nnfolder-active-file'
     アクティブファイルの名前。ディフォルトは `~/Mail/active' です。

`nnfolder-newgroups-file'
     グループ記述ファイルの名前。*Note Newsgroups File Format::. ディフォ
     ルトは `~/Mail/newsgroups"' です。

`nnfolder-get-new-mail'
     `nil' でなければ、`nnfolder' は入ってくるメールを読み込みます。ディ
     フォルトは `t' です。

`nnfolder-save-buffer-hook'
     フォルダーを保存する前に実行されるフックです。`nnfolder' バッファー
     に対してさえも、Emacs は通常とおりファイル名を変更してバックアップを行な
     うことに注意して下さい。この機能を無効にしたいのであれば、
     `~/.gnus.el' ファイルで次のようなことをすれば良いでしょう:

          (defun turn-off-backup ()
            (set (make-local-variable 'backup-inhibited) t))

          (add-hook 'nnfolder-save-buffer-hook 'turn-off-backup)

`nnfolder-delete-mail-hook'
     これから消去されるメッセージに範囲を狭められて実行されるフックです。
     この関数は別の場所にメッセージをコピーしたり、消去する前に何らかの
     情報を取り出すために使うことができます。

`nnfolder-nov-is-evil'
     もし非-`nil' なら、このバックエンドはどんな NOV ファイルをも無視し
     ます。ディフォルトは `nil' です。

`nnfolder-nov-file-suffix'
     NOV ファイルの拡張子です。ディフォルトは `.nov' です。

`nnfolder-nov-directory'
     NOV ファイルが格納されるディレクトリーです。`nil' だったら
     `nnfolder-directory' が使われます。

`nnfolder-marks-is-evil'
     非-`nil' であると、このバックエンドはいかなる 印 ファイルをも無視
     します。ディフォルトは `nil' です。

`nnfolder-marks-file-suffix'
     印 ファイルの拡張子です。ディフォルトは `.mrk' です。

`nnfolder-marks-directory'
     印 ファイルが格納されるディレクトリーです。`nil' だったら
     `nnfolder-directory' が使われます。

`nnfolder' で読みたいたくさんの `nnfolder' に似たファイルを持っているの
なら、そのようなすべてのファイルが `nnfolder-directory' にあることを
`nnfolder' に気付かせるために、`M-x nnfolder-generate-active-file' 命令
を使って下さい。もっとも、これは長いファイル名を使っているときだけ動作
しますが。



File: gnus-ja.info, Node: Comparing Mail Back Ends, Prev: Mail Folders, Up: Choosing a Mail Back End

メールバックエンドの比較
........................

まず用語としての「バックエンド」(back end) は、それによってなにものかが
取得される、低次のアクセス手段、あるいはそう言いたければ輸送手段です。
それが意図するのはどこからかメールを取ってくることなので、Gnus がすぐに
手が届く距離の範囲内でメールを受け取るための、適当なバックエンドを選択
する必要があります。

同じ概念が Usenet 自身にも存在します。近ごろでは記事へのアクセスは一般
的に NNTP で行なわれますが、凄涼たる暗黒の昔には、世界中の誰もが、記事
を置いてあるマシン (今日では NNTP サーバーと呼ぶもの) でリーダーを動作
させることによって Usenet に接続したものでした。また、アクセスは記事の
ディレクトリーのスプールの領域に直接に踏み込むリーダーによって行なわれ
ました。たまたまそういうサーバーにいるのなら (あるいは NFS を介して、と
にかくそれのスプールのディレクトリーを見ることができるのなら)、今でも
`nntp' か `nnspool' バックエンドのどちらかを選ぶことができます。

     (訳注:「凄涼たる暗黒の昔には」はポーの詩「大鴉」の冒頭部分“Once
     upon a midnight dreary”。)

メールバックエンドを選択することの行き着く先は、元の形式を処理し、かつ
将来便利に使える形式でメールを残すことを、同時に実現するのに適した方法
を選び出すことです。それぞれいくつかの良い点と悪い点があります:

`nnmbox'
     歴史的に UNIX システムは、とても一般的で行き届いた定義のたった一つ
     の形式を持っています。すべてのメッセージは単一の「スプールファイル」
     に到着し、それらは正規表現 `^From_' に合致する行で区切られています。
     (`_' という記号はスペースを意味し、この例ではこれが RFC で規定され
     ている `From:' ヘッダーではないことをはっきりさせるために使ってい
     ます。) Emacs それに Gnus も歴史的に Unix 環境から始まっているので、
     元の mailbox 形式をあまりいじくり回さずに済めば、それが最も単純で
     す。したがってこのバックエンドを選んだ場合に、本当のスプールからメー
     ルを取得して Gnus にとって都合が好いディレクトリーにメールを移動す
     るために Gnus が主に行なうのは、処理の過程で何も (目立つような) 変
     更をせずに、単にそれを複製することです。それは Gnus が処理を行なう
     ことができる環境にメールを移動するための「最も気が利かない」方法で
     す。これは移動させることを速くしますが、Gnus がどこに何があるかを
     調べるときは、解析が遅くなります。

`nnbabyl'
     むかしむかしあるところに DEC-10 と DEC-20 がありました。それらは
     TOPS というオペレーティングシステムや似たようなものを実行していて、
     メールを読むための普通の (もしかしたら唯一の?) 環境は Babyl という
     ものでした。そのシステムに届いたメールでどんな形式が使われていたか
     はわかりませんが、Babyl にはメールを変換するための、それ用の内部形
     式がありました。その変換とは、Babyl 特有のヘッダーと状態ビットを、
     ファイルにあるそれぞれのメッセージの先頭に挿入するための仕組みによっ
     て、スプールファイル風の実体を作ることでした。Rmail は Emacs の最
     初のメールリーダーで、Richard Stallman によって書かれました。
     Stallman はその TOPS/Babyl の環境の出身だったので、すでに存在して
     いたメールファイルの一族を理解するように Rmail を書きました。Gnus
     は (この件に関しては VM も) この形式をサポートし続けています。それ
     は、そのメーラー特有のヘッダー/ステータス・ビットというものが、か
     なり良質だと認められているからです。Rmail 自身ももちろんまだ存在し
     ていて、今でも Stallman によって維持されています。

     上記の両方の形式は、メールをファイルシステムにおける単一のファイル
     に置いたままにするので、メールを見るたびにファイル全体を解析しなけ
     ればなりません。

`nnml'
     `nnml' は、あたかも `nnspool' でアクセスされる Usenet システムで実
     際に操作しているかのような感じのするバックエンドです。(実際のとこ
     ろ、`nnml' はすごく以前に `nnspool' から枝分かれしたものだと思いま
     す。) メールは元のスプールファイルから取り出された後で、個々のファ
     イルに 1:1 で切り分けられます。Usenet 様式のアクティブファイル
     (INN や CNews に基づいたニュースシステムの `/var/lib/news/active'
     ファイル (例えば) や、`NNTP LIST' 命令で返されるものに類似したもの)
     を維持し、今ではかなりの年数にわたって NNTP サーバーのために定義さ
     れている "overview" ファイルも、グループへ入るときの効率を良くする
     ために作成します。たくさんのファイルを作成し、`nnml' アクティブファ
     イルを更新し、さらにメッセージ毎に overview への追加を行なうので、
     メール分割では遅くなりますが、アクセスするときには、アクティブファ
     イルと overview によって提供される索引機能に支援されて、とてつもな
     く速くなります。

     `nnml' は "inode" を非常にたくさん消費します。すなわち、新しいファ
     イルを置くことができる場所をファイルシステム上に定めるための資源を、
     たくさん占有します。ぎっしりつまった共有ファイルシステムで大量の
     inode を占有することを、システム管理者は快く思いません。もっとも、
     そのファイルシステムが自分自身のもので、容量が希少ではない個人のマ
     シンにいるのならば、`nnml' には非常に大きな利点があるのですが。

     FAT16 の Windows の世界にいる場合にも、たくさんの小さなファイルで
     多くの場所を取られてしまう点で問題があります。

`nnmh'
     Rand MH メール閲覧システムは UNIX システムにかなり長い間存在してい
     ます。それはメッセージのスプールファイルを個々のファイルに分割する
     ことによって動作しますが、索引機能は少ししか、あるいはまったくあり
     ません---`nnmh' は、意味的には「アクティブファイルまたは overview
     の無い `nnml'」と等価です。これはおそらく最悪の選択でしょう。なぜ
     ならば、個々のファイルを作ることの遅さが、何がグループで新しいかを
     知るときに解析するために行なうアクセスの遅さに結び付くからです。

`nnfolder'
     基本的に `nnfolder' が実現することは、グループ毎の `nnmbox' (上で
     説明されている最初の方法) です。すなわち `nnmbox' 自体は *すべて*
     のメールを一つのファイルに入れます。でも `nnfolder' はメールグルー
     プのそれぞれが Unix mail box ファイルを持つように、ほんの少し最適
     化をします。それぞれのグループは別々に解析されるので `nnmobx' より
     も速く、しかもなお、メールを移動させるのに最小限の労力しか要求しな
     い、単純な Unix mail box 形式を提供します。加えて「アクティブ」ファ
     イルを維持し、Gnus がそれぞれの別のグループにどのくらいのメッセー
     ジがあるかを調べることをとても速くします。

     もしたくさんの量のメッセージを受け取ることが予想されるグループがあ
     るなら、`nnfolder' は最善の選択ではありませんが、ほどほどの量のメー
     ルしか受け取らないなら、おそらく `nnfolder' はすべての中で最も都合
     の良いバックエンドでしょう。

`nnmaildir'
     期限切れ消去その他もろもろを設定するのに、`nnmaildir' は他のメール
     バックエンドとは少々異なった、互換性の無いグループパラメーターを使
     います。

     `nnmaildir' は大方 `nnml' と似たものですが、いくらか顕著な違いがあ
     ります。それぞれのメッセージは別々のファイルに格納されますが、ファ
     イル名は Gnus の記事番号と関係がありません。また `nnmaildir' は
     `nnml' の overview に相当するファイルを記事ごとに一つ格納するので、
     `nnml' の約二倍の量の iノードを使います。(`df -i' を使って iノード
     の割り当てがどれほどたくさんあるかを調べて下さい。) そのために遅く
     なったり多くの場所を取ってしまうようならば、ReiserFS
     (http://www.namesys.com/) や他の非ブロック構造のファイルシステムへ
     の転換を検討して下さい。

     maildir は受信配送のためのロックを必要としないので、あなたがグルー
     プとして使っている maildir は、配送されてきたメールを直接受け取る
     ための maildir にすることもできます。これは、メールが配送されてく
     る過程で異なるメールボックスに仕分されるようになっているのならば、
     Gnus のメール分割を省略できることを意味します。`mail-sources' にお
     ける `directory' の項には (訳注: maildir を使わなくても) 似た効果
     がありますが、配送されてくるメールをスプールするためのメールボック
     スの一揃い (mbox 形式ではそのためにメッセージの本文が壊れる) と、
     他の (何であれあなたの好みの形式の) グループとして使われる組が必要
     です。一方 maildir は、`new/' サブディレクトリーに置かれる組み込み
     スプールを持ちます。メール分割による代わりに `new/' から `cur/' に
     移動されたメールは、ダブっているかどうかをチェックするような処理を
     今のところは受けないことに注意してください。

     `nnmaildir' はグループの記事の印を、それに対応する maildir に格納し
     ます。Gnus の外からそれらを簡単に操作できるようにするために、そのように
     作られているのです。maildir を tar でまとめてから別のどこかで展開しても、
     印はそのままです。`nnml' も印を格納しますが、
     `nnmaildir' で Gnus の外からそれらを使うように簡単ではありません。

     `nnmaildir' は速度を上げるためにかなりの量のメモリを使います。
     (`nnml' の場合はファイルに格納し、`nnmh' では何度もメッセージファ
     イルを解析して得るものごとを、それはメモリ上に保持します。) これが
     あなたにとって問題ならば、`nov-cache-size' グループパラメーターを
     何か小さな値 (0 はおそらくだめですが 1 だったらたぶん働きます) に
     設定することによって、少ないメモリで済むようにすることができます。
     このキャッシュ機構は、おそらく将来は削除されるでしょう。

     起動は他のバックエンドよりも `nnmaildir' の方が遅いでしょう。ファ
     イルシステムに依存していないすべての部分では速いでしょう。

     `nnmaildir' は `nnoo' を使わないので、`nnmaildir' から派生したバッ
     クエンドを書くのに `nnoo' は使えません。



File: gnus-ja.info, Node: Browsing the Web, Next: IMAP, Prev: Getting Mail, Up: Select Methods

Browsing the Web
================

ウェブに基づいた議論の場はどんどん広まっています。多くの分野で、ウェブ
の掲示板は最も重要な場になり、メーリングリストやニュースグループの重要
性を翳らせています。理由は簡単です--新しい利用者が使い易いからです。た
だ場所をクリックするだけで、議論の場があります。メーリングリストでは、
面倒な購読手続きをしなければならず、ほとんどの人はニュースグループとい
うものがが何であるかすら知りません。

この筋書きから浮かび上がる問題は、ウェブブラウザーはニュースリーダーと
してはあまり良くないということです。どんな記事を読んだかを記録しません。
興味のある表題にスコアを付けることができません。オフラインで読むことが
できません。何度もクリックすることを要求し、最後にはあなたを怒らせます。

ならば--ウェブブラウザーが掲示板を読むのに適していないのなら、代わりに
Gnus を使いませんか?

Gnus はこれらのソースへのインターフェースを提供するバックエンド群を少し
備えつつあります。

* Menu:

* Archiving Mail::
* Web Searches::                文字列に合致する記事からグループを作る
* Slashdot::                    Slashdot のコメントを読む
* Ultimate::                    Ultimate Bulletin Board システム
* Web Archive::                 ウェブに保管されたメーリングリストを読む
* RSS::                         RDF Site Summary を読む
* Customizing W3::              Gnus から Emacs/W3 を操作する

すべてのウェブソースは、動作させるために Emacs/W3 と url ライブラリー、
またはそれらの代替が必要です。

これらのウェブソースの一番の問題は、長期間は動作しない可能性が高いこと
です。HTML のデータから情報を拾い集めるのはせいぜい推測で、その構造が変
化したときには、Gnus バックエンドは動作しません。でも、ある程度新しいバー
ジョンのバックエンドを使っていれば大丈夫のはずです。

これらのウェブの手段に共通することは、ウェブソースはしばしば落ちていた
り、使用可能でなかったり、はっきり言って楽しむには遅すぎる、ということ
です。そういう場合に、Gnus Agent (*Note Gnus Unplugged::) に記事のダウ
ンロードを任せて、ローカルディスクから好きなときに読むようにすることは、
大いに意義があります。これで World Wide Wait とはおさらばです。



