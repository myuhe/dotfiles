Info file: libtool-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `libtool-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.




INFO-DIR-SECTION GNU programming tools
START-INFO-DIR-ENTRY
* Libtool(ja): (libtool-ja).           Generic shared library support script.
END-INFO-DIR-ENTRY


INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* libtoolize(ja): (libtool-ja)Invoking libtoolize.     Adding libtool support.
END-INFO-DIR-ENTRY


このファイルは，GNU Libtool 1.5を説明します．

Copyright (C) 1996-2003 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
no Invariant Sections, with no Front-Cover Texts, and with no
Back-Cover Texts.  A copy of the license is included in the section
entitled "GNU Free Documentation License".






File: libtool-ja.info, Node: Autoconf .o macros, Prev: Invoking libtoolize, Up: Distributing

Autoconfの`.o'マクロ
--------------------

Autoconfパッケージは，テストを実行するいくつかのマクロをもたらし，それ
は，オブジェクトファイル名に対応して変数を設定します．libtoolオブジェ
クトに対応する名前を使用する必要があるときもあります．

libtoolオブジェクトがリストアップする変数名には以下のものがあります．

 -- Variable: LTALLOCA
     `AC_FUNC_ALLOCA'で置換されます(*Note Particular Function Checks:
     (autoconf)Particular Functions.)．空，または`alloca.lo'を含みます．

 -- Variable: LTLIBOBJS
     `AC_REPLACE_FUNCS'(*Note Generic Function Checks:
     (autoconf)Generic Functions.)とその他の関数で置換されます．

残念ながら，安定版のリリースのAutoconf(これを書いている時期は，2.13)は，
libtoolでこれらの変数を提供する方法が全くありません．そのため，それに
依存して，パッケージの`configure.in'で`AC_OUTPUT'を呼び出す前に，以下
のコードの実装を使用してください．

     LTLIBOBJS=`echo "$LIBOBJS" | sed 's/\.[^.]* /.lo /g;s/\.[^.]*$/.lo/'`
     AC_SUBST(LTLIBOBJS)
     LTALLOCA=`echo "$ALLOCA" | sed 's/\.[^.]* /.lo /g;s/\.[^.]*$/.lo/'`
     AC_SUBST(LTALLOCA)
     AC_OUTPUT(...)



File: libtool-ja.info, Node: Static-only libraries, Prev: Distributing, Up: Integrating libtool

スタティックのみのライブラリ
============================

パッケージを開発しているとき，パッケージを`--disable-shared'フラグでコ
ンフィグレーションしたり，`AC_DISABLE_SHARED'Autoconfマクロ(*Note The
`AC_PROG_LIBTOOL' macro: AC_PROG_LIBTOOL.)を使用して，
`AC_PROG_LIBTOOL'のデフォルトに優先することに価値があることもよくあり
ます．これは，libtoolが共有ライブラリをビルドすることを避け，それには，
いくつかの利点があります．

   * 二回目のコンパイルを速くし，開発サイクルを高速にします．

   * 共有ライブラリによって加えられる複雑さの詳細が不要なので，デバッ
     グがより簡単になります．

   * スタティックのみのプラットフォームでのlibtoolの動作方法が分かりま
     す．

パッケージの`README'に，他の開発者に`--disable-shared'で時間を稼げるこ
とを知らせるため，ちょっとした注意を書きたいかもしれません．以下の例の
注意は，GIMP (1) (*Note Static-only libraries-Footnotes::) 配布物の
`README'から持ってきました．

     The GIMP uses GNU Libtool in order to build shared libraries on a
     variety of systems. While this is very nice for making usable
     binaries, it can be a pain when trying to debug a program. For that
     reason, compilation of shared libraries can be turned off by
     specifying the `--disable-shared' option to `configure'.


File: libtool-ja.info  Node: Static-only libraries-Footnotes, Up: Static-only libraries

(1) 思い切りがよくない人のためのGNU Image Manipulation Programです．
`http://www.gimp.org/'を参照してください．



File: libtool-ja.info, Node: Versioning, Next: Library tips, Prev: Integrating libtool, Up: Top

ライブラリインターフェースのバージョン
**************************************

共有ライブラリで導入された発行物で，最も難しいものは，実行時の依存性の
作成と解決です．プログラムとライブラリの依存性は，`sed'のような単一の
名前の用語で，よく記述されます．そのため"libtoolはsedに依存する" と告
げ，それで十分目的を果たせます．

しかし，規則的にインターフェースが変更されるとき，我々はより具体的に告
げる必要があります．"Gnus 5.1はEmacs 19.28以上を要求する．"ここでは，
名前からなるインターフェースの記述と"バージョンナンバー"です．

種類の説明はいくつかの目的において十分でないことすらあります．Emacs 20 
で変更された場合，Gnus 5.1を破壊するのに十分ではないでしょうか？

同じ問題は，共有ライブラリでも存在します．我々は，プログラムが必要とし
ているインターフェースを提供するライブラリのみとリンクされることを，ダ
イナミックリンカが保証できるように，プログラムが依存する共有ライブラリ
を記述するために，公式なバージョン管理システムが必要です．

* Menu:

* Interfaces::                  What are library interfaces?
* Libtool versioning::          Libtool's versioning system.
* Updating version info::       Changing version information before releases.
* Release numbers::             Breaking binary compatibility for aesthetics.



File: libtool-ja.info, Node: Interfaces, Next: Libtool versioning, Prev: Versioning, Up: Versioning

ライブラリインターフェースとは？
================================

ライブラリのインターフェースは，以下の何か(またはそれ以上)でしょう．

   * グローバル変数: 名前と型

   * グローバル関数: 引数の型と数，返り値の型，関数名

   * 標準入力，標準出力，標準エラー，そしてファイル形式

   * ソケット，パイプ，プロセス間通信のプロトコル書式

スタティック関数は，ライブラリのユーザが直接利用不可能なので，インター
フェースに数えられないことに注意してください．



File: libtool-ja.info, Node: Libtool versioning, Next: Updating version info, Prev: Interfaces, Up: Versioning

libtoolのバージョン管理システム
===============================

libtoolは独自の公式のバージョン管理システムがあります．それは，あまり
柔軟ではありませんが，強力なバージョン管理システムで，確かに最も単純で
す．

ライブラリとは，整数で任意に表示できるインターフェースのいくつかの組を
エクスポートするものだと考えて下さい．プログラムがライブラリとリンクさ
れるとき，これらのインターフェースのサブセットを利用するかもしれません．

プログラムが使用するインターフェースのlibtoolの記述は単純です．それは，
結果のバイナリにある最大と最小のインターフェースの番号を符号化します
(FIRST-INTERFACE, LAST-INTERFACE)．

ダイナミックリンカは，ライブラリがFIRST-INTERFACEとLAST-INTERFACEの間
の*すべての*インターフェースの番号をサポートする場合，プログラムがライ
ブラリとリンク可能なことを保証します．

libtoolの移植性の要求が，実際に必要と言うよりは厳密なので，問題を生じ
る可能性があることに注意してください．

さて，`libhello'がインターフェースの5，16，17，18，と19をサポートし，
libtoolは`libhello'を`test'にリンクするとき使用されると仮定します．

libtoolは`test'に数字5と19を符号化し，ダイナミックリンカは，5と19 の間
の*すべての*インターフェースをサポートしているライブラリのみと，`test'
をリンクします．そのため，ダイナミックリンカは`libhello'と`test'をリン
クすることを拒否するのです！

この問題を排除するために，libtoolはライブラリは，連続したインターフェー
ス番号を宣言することのみ可能としています．そのため，`libhello'は，16 
から19までのインターフェースをサポートすることを宣言するのが精一杯です．
そして，ダイナミックリンカは，`libhello'を`test'とリンクします．

そのため，libtoolライブラリバージョンは，三つの整数で宣言されます．

CURRENT
     このライブラリで実装されている，最も新しいインターフェース番号．

REVISION
     CURRENTのインターフェースの実装番号．

AGE
     このライブラリで実装されている，最新と最古のインターフェースの違
     い．言い換えると，ライブラリは，`CURRENT - AGE'から`CURRENT'まで
     の番号の範囲で，すべてのインターフェース番号を実装しています．

二つのライブラリが，個別のCURRENTとAGEを持つ場合，ダイナミックリンカは，
より大きいREVISION番号を選択します．



File: libtool-ja.info, Node: Updating version info, Next: Release numbers, Prev: Libtool versioning, Up: Versioning

ライブラリバージョン情報の更新
==============================

libtoolのバージョン管理システムを使用したい場合，リンクモード(*Note
Link mode::)で，`-version-info'フラグを使用して，libtool にバージョン
情報を指定する必要があります．

このフラグは，`CURRENT[:REVISION[:AGE]]'の形式の引数を受け入れます．そ
して，`-version-info 3:12:1'を渡すと，CURRENTを3，REVISIONを12，そして
AGEを1に設定します．

REVISIONやAGEが省略された場合，デフォルトは0になります．また，AGEは
CURRENTインターフェース番号以下にする必要があることに注意してください．

ライブラリバージョン情報を更新する助けとなる規則の集合は，以下のように
なります．

  1. バージョン情報は，それぞれのlibtoolライブラリに対し`0:0:0'で始め
     てください．

  2. ソフトウェアの一般へのリリースの直前にのみ，バージョン情報を更新
     してください．より頻繁な更新は不要で，現在のインターフェース番号
     が速くなることを確実にするだけです．

  3. 前回の更新から，ライブラリソースコードが完全に変更された場合，
     REVISIONを増加してください(`C:R:A'は`C:r+1:A'となります)．

  4. 前回の更新から，インターフェースが加えられた，削除された，または
     変更された場合，CURRENTを増加し，REVISIONを0に設定してください．

  5. 前回の一般へのリリースから，あるインターフェースが削除された場合，
     AGEを0に設定してください．

  6. 前回の一般へのリリースから，あるインターフェースが削除された場合，
     AGEを0に設定してください．

パッケージのリリース番号に対応するように，インターフェース番号を設定す
る試みは**決して**しないでください．これは，ライブラリバージョンの目的
の誤解を促進する悪習にすぎません．その代わり，`-release'フラグ(*Note
Release numbers::)を使用しますが，パッケージが他のリリースとバイナリ互
換でないことを警告されます．



File: libtool-ja.info, Node: Release numbers, Prev: Updating version info, Up: Versioning

リリース情報の管理
==================

プログラムをライブラリにリンクしたいユーザに明確になるように，パッケー
ジリリース名を共有ライブラリに符号化したいこともよくあります．この便利
さは，特にGNU/Linuxで使用されます．

     trick$ ls /usr/lib/libbfd*
     /usr/lib/libbfd.a	    /usr/lib/libbfd.so.2.7.0.2
     /usr/lib/libbfd.so
     trick$

`trick'として，`/usr/lib/libbfd.so'は`libbfd.so.2.7.0.2' へのシンボリッ
クリンクで，それは`binutils-2.7.0.2'の一部として配布されています．

ライブラリインターフェースは，リリース番号のように，滅多に同時に変更さ
れず，ライブラリ接尾子はすべてのプラットフォームを跨り，すべて同じでは
ないので，残念ながらこの便利さはlibtoolのライブラリバージョンの情報の
考えと直接衝突します．

そのため，両方の見方に適応するため，`-version-info'を使用したくないラ
イブラリに対し，リリース情報を設定するにあたり，`-release'フラグを使用
することができます．`libbfd'の例では，libtoolが使用する次のリリースは，
`-release 2.9.0'でビルドされるべきで，それは，GNU/Linuxで，以下のファ
イルを生成します．

     trick$ ls /usr/lib/libbfd*
     /usr/lib/libbfd-2.9.0.so     /usr/lib/libbfd.a
     /usr/lib/libbfd.so
     trick$

この場合，`/usr/lib/libbfd.so'は`libbfd-2.9.0.so'へのシンボリックリン
クです．これは`binutils-2.9.0'を扱っているユーザにとって，バージョン情
報のlibtoolの考えに妥協することなく，明白になります．

このオプションはライブラリ名を編集することに注意し，過去のライブラリリ
リースとのバイナリ互換を壊したくない場合は使用しないでください．一般的
に，パッケージの内部ライブラリや，大変頻繁に変更されるインターフェース
を持つ物に対してのみ`-release'を使用してください．



File: libtool-ja.info, Node: Library tips, Next: Inter-library dependencies, Prev: Versioning, Up: Top

インターフェース設計に対する助言
********************************

良いライブラリインターフェースと書くことは，多くの経験とライブラリが解
決する問題への完全な理解が必要です．

良いインターフェースを設計した場合，頻繁に変更する必要がなく，ドキュメ
ントを更新し続ける必要がなく，ユーザはライブラリの使用方法を何度も学習
する必要がありません．

ここにライブラリインターフェースの設計に関するヒントの短いリストがあり，
それは仕事上で役立つでしょう．

計画前
     エントリポイントを頻繁に削除する必要がないように，すべてのインター
     フェースを本当に最小限にするように試みてください．

インターフェースの変更を避ける
     エントリポイントの再設計と変更を地獄のように繰り返すのが好きな人
     もいます(注意：関数の*名前変更*はエントリポイントの変更と考えられ
     ます)．インターフェースを再設計する必要がある場合，ユーザが既存の
     コードを書き換える必要がないように，互換機能を残すことを試みてく
     ださい．

不透明なデータ型の使用
     ライブラリユーザがアクセスするデータ型の定義は，少ないければ少な
     いほど良いでしょう．可能な場合，一般的な(内部データにキャスト可能
     な)ポインタを受け入れる関数を設計し，ライブラリユーザが直接データ
     を操作するのを許可するのではなく，アクセスする関数を提供してくだ
     さい．そうすることで，インターフェースを変更せずに，データ構造を
     変更することが自由になります．

     これは，本質的にオブジェクト指向のシステムで抽象的なデータ型と継
     承を使用するのと同じです．

ヘッダファイルの使用
     ライブラリのグローバル関数と変数のそれぞれのドキュメントをヘッダ
     ファイルに注意して書いていて，ライブラリソースファイルに含めてい
     る場合，コンパイラは偶然にインターフェースの変更の有無を知らせる
     でしょう(*Note C header files::)．

可能な場所での`static'キーワード(またはその等価物)の使用
     ライブラリが持つグローバル関数は，減らせば減らすほど，より柔軟に変更で
     きます．スタティック関数と変数は，形式を変更したいとき変更できます
     ...ユーザはそれらにアクセスできず，そのためインターフェースは変更
     されません．

配列の次元に対する注意
     大域的な配列の要素数は，たとえヘッダで`extern int foo[];'と宣言し
     ていたとしても，それはインターフェースの一部です．これはi386とそ
     の他のSVR4/ELFシステムでは，アプリケーションが共有ライブラリのデー
     タを参照する時，データのサイズ(と型)はアプリケーションの実行形式
     に含められます．配列や文字列の大きさを変更したくなければ，配列で
     はなくポインタとして提供してください．

* Menu:

* C header files::              How to write portable include files.



File: libtool-ja.info, Node: C header files, Prev: Library tips, Up: Library tips

Cヘッダファイルを書く
=====================

移植性の高いCヘッダファイルを書くことは難しく，それは異なる形式のコン
パイラで読まれる可能性があるためです．

C++コンパイラ
     C++コンパイラは，Cより強固に形式化されているため，完全なプロトタ
     イプで宣言された関数を要求します．C関数と変数は，名前がおかしくな
     らないように，`extern "C"'ディレクティブで宣言する必要があります．
     libtool でC++の使用に関連したその他の問題は，*Note C++
     libraries::.

ANSI Cコンパイラ
     ANSI Cコンパイラは，C++コンパイラほど厳密ではありませんが，関数の
     プロトタイプは，ヘッダファイルを`#include'したときの不必要な警告
     を避けるため，行う方が良いでしょう．

非ANSI Cコンパイラ
     Non-ANSIコンパイラは，関数がプロトタイプされている場合，エラーを
     報告します．

これらの複雑さは，上記それぞれのコンパイラを利用可能にするため，ライブ
ラリインファーフェースヘッダで，いくつかのCプリプロセッサの魔法を使用
する必要があることを意味します．

libtool配布物の`demo'サブディレクトリの`foo.h'は，安全にシステムディレ
クトリにインストール可能な，ヘッダファイルの書き方の例を提供します．

そのファイルの関連する部分は，以下のようになっています．

     /* BEGIN_C_DECLS should be used at the beginning of your declarations,
        so that C++ compilers don't mangle their names.  Use END_C_DECLS at
        the end of C declarations. */
     #undef BEGIN_C_DECLS
     #undef END_C_DECLS
     #ifdef __cplusplus
     # define BEGIN_C_DECLS extern "C" {
     # define END_C_DECLS }
     #else
     # define BEGIN_C_DECLS /* empty */
     # define END_C_DECLS /* empty */
     #endif

     /* PARAMS is a macro used to wrap function prototypes, so that
        compilers that don't understand ANSI C prototypes still work,
        and ANSI C compilers can issue warnings about type mismatches. */
     #undef PARAMS
     #if defined (__STDC__) || defined (_AIX) \
             || (defined (__mips) && defined (_SYSTYPE_SVR4)) \
             || defined(WIN32) || defined(__cplusplus)
     # define PARAMS(protos) protos
     #else
     # define PARAMS(protos) ()
     #endif

これらのマクロは，以下のように`foo.h'で使用されます．

     #ifndef FOO_H
     #define FOO_H 1

     /* The above macro definitions. */
     #include "..."

     BEGIN_C_DECLS

     int foo PARAMS((void));
     int hello PARAMS((void));

     END_C_DECLS

     #endif /* !FOO_H */

`#ifndef FOO_H'が，`foo.h'の本体を，与えられたコンパイルで一回以上読み
込むことを避けることに注意してください．

また，`BEGIN_C_DECLS'/`END_C_DECLS'の組の外側あるものだけが，
`#include'行にあります．厳密にいうと，それは，保護が必要なCのシンボル
名ですが，ヘッダの内容の中心周辺にこれらのマクロの単一の組がある場合，
ヘッダファイルはより管理しやすくなります．

`PARAMS'，`BEGIN_C_DECLS'，そして`END_C_DECLS'のこれらの定義を独自のヘッ
ダで使用すべきです．そして，C++，ANSI，そして非ANSI のコンパイラ (1)
(*Note C header files-Footnotes::)で有効なヘッダファイルを作成するため
に，それらを使用することが可能となります．

移植可能なコードをネイティブに書かないでください，上記のヒントに続ける
ことで，最も明白な問題を無くすことに役立ちますが，明らかに別の微妙な問
題があります．以下の問題に対処する必要があるかもしれません．

   * ANSI以前のコンパイラは，一般的なポインタ型`void *'を常にサポート
     するわけではなく，そこでは`char *'を使用する必要があります．

   * `const'，`signed'そして`signed'キーワードは，サポートされていない
     コンパイラもあり，特にANSI以前のコンパイラがあげられます．

   * `long double'型は，多くのコンパイラでサポートされていません．


File: libtool-ja.info  Node: C header files-Footnotes, Up: C header files

(1) 我々は，`__P'，`__BEGIN_DECLS'そして`__END_DECLS'の
使用を推奨していました．アンダースコアで始まるシンボル(とプリプロセッ
サマクロさえも)がコンパイラの使用で予約されているので，悪いアドバイス
でした．



File: libtool-ja.info, Node: Inter-library dependencies, Next: Dlopened modules, Prev: Library tips, Up: Top

ライブラリ内部の依存性
**********************

定義では，すべての共有ライブラリシステムは，シンボル解決が実行時まで延
期されるように，実行形式をライブラリに依存させる方法を提供します．

"ライブラリ内部の依存性"は，他のライブラリに依存するライブラリにありま
す．例えば，libtoolライブラリ`libhello'が`cos'関数を使用する場合，それ
は`libm'に対するライブラリ内部の依存性があり，数学ライブラリが`cos'を
実装しています．

共有ライブラリシステムには，内部で一貫した方法で，この機能を提供するも
のもあります．これらのシステムは，潜在的に無限長の依存性の連鎖を認めま
す．

しかし，ほとんどの共有ライブラリのシステムは，単一レベルの依存のみを認
めるという制限があります．これらのシステムでは，プログラムは共有ライブ
ラリに依存しますが，共有ライブラリは他の共有ライブラリに依存しません．

あらゆる事象で，ライブラリ内部の依存性を宣言するため，libtoolは単純な
メカニズムを提供します．独自のライブラリに依存するすべてのライブラリ
`libNAME'に対しライブラリを作成するとき，対応する`-lNAME'オプションを
リンク行に単純に加えます．`libm'に依存する`libhello'の例をビルドしてみ
ます．

     burger$ libtool --mode=link gcc -g -O -o libhello.la foo.lo hello.lo \
                     -rpath /usr/local/lib -lm
     burger$

プログラムを`libhello'に対しリンクするとき，`-l'オプションを再び指定す
る必要はありません．必要なライブラリがすべて見つかることを保証するため，
libtoolがそれを行います．この制約は，スタティックライブラリシステムと，
単純なダイナミックライブラリシステムとの互換性を保つために必要です．

AIXのように，この柔軟性さえ許可されないプラットフォームもあります．共
有ライブラリをビルドするため，それは完全に自己内蔵型である必要があり
(すなわち，`.lo'ファイルや`-l'で指定されたライブラリでシンボルが見つか
るもののみを参照する)，-NO-UNDEFINEDフラグを指定する必要があります．デ
フォルトで，libtoolはこの種のプラットフォームではスタティックライブラ
リのみをビルドします．

1.2以前のlibtoolのリリースのコードにおける，単純に考えられたライブラリ
内部の依存性の追跡は，ライブラリを他のライブラリとリンクすることが可能
なときが明白でないため，それが利用ができず，複雑な異常終了が発生します．
この概念のより複雑な実装は，リリース1.3の前に再導入されましたが，
libtoolがサポートするすべてのプラットフォームに移植されませんでした．
デフォルトで，保守的な動作は，ライブラリが他のライブラリとリンクするこ
とを避け，プログラムがリンクされるときのみに，その内部依存性が導入され
ます．



File: libtool-ja.info, Node: Dlopened modules, Next: Using libltdl, Prev: Inter-library dependencies, Up: Top

dlopenモジュール
****************

"ダイナミックリンク"の議論では，その用語が二つの異なる概念を述べるとき
に使用されるので，混乱することがあります．

  1. 共有ライブラリに対しプログラムをコンパイルとリンクし，それは，ダ
     イナミックリンカにより実行時に自動的に解決される．この処理では，
     ダイナミックリンクはアプリケーション透過です．

  2. アプリケーションの，`dlopen' (1) (*Note Dlopened
     modules-Footnotes::)のような関数の呼び出しで，それは，ユーザが指
     定したモジュールを実行時に任意にロードします．この形式のダイナミッ
     クリンクは，アプリケーションで明示的に制御されます．

混乱を軽減するため，このマニュアルは二番目の形式のダイナミックリンクを
"dlopen"モジュールとして述べることにします．

dlopenモジュールの主な利点は，プログラムを拡張するために，インタプリタ
言語を使用するのではなく，コンパイルされたオブジェクトコードにアクセス
する能力です．実際，dlopenは，言語を拡張する効果的な方法を提供するため，
インタプリタ言語でよく使用されます．

バージョン1.5の現在は，libtoolはdlopenされるモジュールのサポートを提供
します．しかし，パッケージがそのようなサポートを行うことを，
`configure.in'で，マクロ`AC_LIBTOOL_DLOPEN'を使用して指示した方が良い
でしょう．このマクロが使用されない(または`AC_PROG_LIBTOOL'の*後で*使用
される)場合，libtoolはdlopenメカニズムが利用不可能と仮定し，シミュレー
ションを試みます．

この章ではdlopenでアクセス可能なモジュールを生成するため，dlopenアプリ
ケーション開発者がlibtoolを使用する方法を議論します．

* Menu:

* Building modules::            Creating dlopenable objects and libraries.
* Dlpreopening::                Dlopening that works on static platforms.
* Finding the dlname::          Choosing the right file to `dlopen'.
* Dlopen issues::               Unresolved problems that need your attention.


File: libtool-ja.info  Node: Dlopened modules-Footnotes, Up: Dlopened modules

(1) HP-UXでは異なり，`shl_load'という名の関数が使用されます．



File: libtool-ja.info, Node: Building modules, Next: Dlpreopening, Prev: Dlopened modules, Up: Dlopened modules

dlopenのためのモジュールのビルド
================================

オペレーティングシステムには，プログラムシンボルを`dlsym'(またはその等
価)関数を用いてダイナミックに解決するために，特別に宣言する必要がある
ものもあります．

libtoolは，`-export-dynamic'と`-module'リンクフラグを提供し(*Note Link
mode::)，それはこの宣言を行います．他のモジュールやdlopen されている
libtoolライブラリをdlopenするアプリケーションプログラムをリンクする場
合，これらのフラグを使用する必要があります．

例えば，後でアプリケーションにdlopenされる共有ライブラリ`libhello'をビ
ルドしたい場合，他のリンクオプションに`-module'を加えます．

     burger$ libtool --mode=link gcc -module -o libhello.la foo.lo \
                     hello.lo -rpath /usr/local/lib -lm
     burger$

*実行形式*からのシンボルが，dlopenしたいライブラリの未解決の参照を満足
させる必要がある場合，フラグ`-export-dynamic'を使用する必要があります．
dlopenを呼び出す実行形式をリンクするとき，`-export-dynamic' を使用して
ください．

     burger$ libtool --mode=link gcc -export-dynamic -o hell-dlopener main.o
     burger$



File: libtool-ja.info, Node: Dlpreopening, Next: Finding the dlname, Prev: Building modules, Up: Dlopened modules

dlopen
======

libtoolは，dlopenするlibtoolオブジェクトとlibtoolライブラリファイルに
対し，*たとえ`dlopen'と`dlsym'関数が無いプラットフォームでも*，そのシ
ンボルが解決できるように，特別のサポートを提供します．

"laziness"の増加順にプログラムにコードをロードする，以下の別の方法を考
慮します．

  1. 参照するしないに関わらない，実行形式の一部となるオブジェクトファ
     イルへのリンクです．オブジェクトファイルが見つからない場合，リン
     カは実行形式の作成を停止します．

  2. 上記のオブジェクトファイルでの未定義の参照を満足させるように，リ
     ンク時に検索されるようにするための，リンカに対するスタティックラ
     イブラリの宣言です．スタティックライブラリが見つからない場合，リ
     ンカは実行形式の作成を停止します．

  3. 上記のファイルでの未定義の参照を満足させるために，実行時に検索さ
     れるようにするための，実行時リンクの共有ライブラリの宣言です．共
     有ライブラリが見つからない場合，ダイナミックリンカは実行形式の作
     成を停止します．

  4. アプリケーション自身が解決することができるように，参照をダイナミッ
     クに解決するdlopenモジュールです．モジュールを開くときエラーが発
     生したり，モジュールが見つからない場合，アプリケーションは壊れる
     ことなく回復します．

libtoolは，コンパイル時にオブジェクトファイルをプログラムにリンクし，
プログラムのシンボルテーブルを表現するデータ構造を作成することで，スタ
ティックなプラットフォームで`-dlopen'オプションをエミュレートします．

この特徴を使用するため，プログラムのリンク時(*Note Link mode::)に
`-dlopen'や`-dlpreopen'フラグを使用することで，アプリケーションで
dlopenしたいオブジェクトを宣言する必要があります．

 -- Structure: struct lt_dlsymlist  const char *NAME; lt_ptr ADDRESS; 
     NAME属性は，`"fprintf"'のような，シンボル名のNULL終端されている文
     字列です．ADDRESS属性は，`&fprintf'のような対応するオブジェクトへ
     の一般的なポインタです．

 -- Variable: const lt_dlsymlist * lt_preloaded_symbols
     LT_SYMBOL構造体の配列で，プログラムにリンクされる，プリロードされ
     ているすべてのシンボルを表現します．それぞれの`-dlpreloaded'ファ
     イルに対し，ファイルのNAMEを用いた要素と，`0'のADDRESSがあり，こ
     のファイルからエクスポートされるすべてのシンボルが続きます．実行
     形式自身に対し，特別の名前@PROGRAM@が使用されます．最後の要素は，
     NAMEと`0'のADDRESSを持ちます．

ドル記号のような，ANSI Cでは有効ではない識別子を許可するコンパイラもあ
ります．libtoolはANSI Cで有効なシンボル(最初がASCII文字またはアンダー
スコアで，ゼロ個以上のASCII文字，数字，そしてアンダースコアが続くもの) 
のみ認識するので，非ASCIIシンボルはLT_PRELOADED_SYMBOLSに出現しません．



File: libtool-ja.info, Node: Finding the dlname, Next: Dlopen issues, Prev: Dlpreopening, Up: Dlopened modules

dlopenで正しい名前の検索
========================

`-module'を用いてライブラリがリンクされた後，dlopen可能になります．残
念ながら ライブラリ名が変更されるため，パッケージでdlopenの正しいファ
イルを決定する必要があります．

最も率直で柔軟な実装は，インストールされた`.la'ファイルを探し，以下の
行を検索することで実行時に決定することです．

     # The name that we can `dlopen'.
     dlname='DLNAME'

DLNAMEが空の場合，ライブラリはdlopenされません．それ以外では，それでラ
イブラリのdlnameを与えます．そのため，ライブラリが
`/usr/local/lib/libhello.la'にインストールされていて，DLNAMEが
`libhello.so.3'の場合，`/usr/local/lib/libhello.so.3'がdlopenされます．

プログラムがこのアプローチを行っている場合，ライブラリが最終的にインス
トールされるディレクトリと同じように，`LD_LIBRARY_PATH' (1) (*Note
Finding the dlname-Footnotes::)環境変数でリストアップされているディレ
クトリで検索します．この変数(または同等物)を検索することで，インストー
ル前でも，プログラムがlibtoolを使用してリンクし提供されているdlopenモ
ジュールを見つけることを保証します．


File: libtool-ja.info  Node: Finding the dlname-Footnotes, Up: Finding the dlname

(1) AIXでの`LIBPATH'とHP-UXでの`SHLIB_PATH'です．



File: libtool-ja.info, Node: Dlopen issues, Prev: Finding the dlname, Up: Dlopened modules

未解決のdlopenの問題
====================

以下の問題は，libtoolのdlopenサポートを使用しても解決しません．

   * dlopen関数は一般に，共有ライブラリプラットフォームでのみ利用可能
     です．パッケージをスタティックなプラットフォームに移植したい場合，
     libltdl (*Note Using libltdl::)を使用する，または，代わりとなる独
     自のdlopenダイナミックコードを開発する必要があります．最も妥当な
     解決方法は，`dlopen'ファミリーのラッパー関数を書くことを必要とし，
     それは，与えられたプラットフォームでdlopenがサポートされていない
     または利用不可能なときの，パッケージ特有のトリックです．

   * 関数の`dlopen'ファミリーの実装には大きな違いがあります．同じ関数
     名を用いないプラットフォーム(特にHP-UXでは`shl_load'ファミリーを
     用います)さえ存在します．

   * アプリケーション開発者は，`dlopen'に渡す正しいモジュール名を発見
     するために，カスタムの検索関数を書く必要があります．



File: libtool-ja.info, Node: Using libltdl, Next: Other languages, Prev: Dlopened modules, Up: Top

libltdlの使用
*************

libtoolは，`libltdl'と呼ばれる小さなライブラリを提供し，それは，dlopen
ライブラリの様々な困難をプログラマから隠すことを目指します．それは，
dlopenの機能で必要とされるアプリケーションとともに配布可能な，ヘッダファ
イルと小さなCソースファイルから成り立ちます．`libltdl'サービスの単純な
実装に対し，あまりに制限が多いダイナミックリンカをもつプラットフォーム
上では，GNU DLDを要求したり，libtoolのdlpreopenメカニズムを用いてダイ
ナミックリンクをエミュレートするだけのものもあります．

libltdlは，現在以下のダイナミックリンクメカニズムをサポートします．

   * `dlopen' (Solaris，Linux，そして様々なBSD)
   * `shl_load' (HP-UX)
   * `LoadLibrary' (Win16とWin32)
   * `load_add_on' (BeOS)
   * GNU DLD (スタティックライブラリに対するダイナミックリンクのエミュ
     レーション)
   * libtoolのdlpreopen (*Note Dlpreopening::)

以下の例外で，libltdlはGNUライブラリ公有使用許諾書の条件下でライセンス
されています．

     GNU Lesser General Public Licenseの特別な例外として，GNU libtool
     を使用してビルドされるプログラムやライブラリの一部としてこのファ
     イルを配布する場合，プログラムの残りに対して使用する配布条件と同
     じものにして，それを含めることができます．

* Menu:

* Libltdl interface::           How to use libltdl in your programs.
* Modules for libltdl::         Creating modules that can be `dlopen'ed.
* Thread Saftey in libltdl::	Registering callbacks for multi-thread safety.
* User defined module data::    Associating data with loaded modules.
* Module loaders for libltdl::  Creating user defined module loaders.
* Distributing libltdl::        How to distribute libltdl with your package.



File: libtool-ja.info, Node: Libltdl interface, Next: Modules for libltdl, Prev: Using libltdl, Up: Using libltdl

プログラムでのlibltdlの使用法
=============================

libltdl APIは，強力なSolarisとLinuxのdlopenインターフェースに似ていて，
それは，非常に簡単ですが強力です．

プログラムでlibltdlを使用するために，ヘッダファイル`ltdl.h'をインクルー
ドする必要があります．

     #include <ltdl.h>

libltdlの前回のリリースでは，POSIX名前空間の慣習に違反していたシンボル
をいくつか使用していました．これらのシンボルの使用は，現在では非難され
るので，ここで記述されるように置換されました．古い非難されそうなシンボ
ル名に依存したコードがある場合，`ltdl.h'をインクルードする前に
`LT_NON_POSIX_NAMESPACE'を定義すると，変換されたマクロが提供されます．
使用するシンボルの組が何であっても，新しいAPIは前回のものとバイナリ互
換ではないので，このバージョンのlibltdlを使用するため，アプリケーショ
ンを再コンパイルする必要があるでしょう．

libltdlがスレッドセーフでない，すなわち，マルチスレッドアプリケーショ
ンは，libtoolに対しミューテックスを使用する必要があることに注意してく
ださい．それは，GNU/Linuxのglibc 2.0の`RTLD_LAZY'を用いた`dlopen'が(デ
フォルトでlibtoolを使用します)，スレッドセーフではないことが報告されて
いますが，この問題は，glibc 2.1でおそらく修正されるでしょ．一方，
`RTLD_NOW'は，FreeBSD上のマルチスレッドアプリケーションで問題が生じた
と報告されています．これらの問題に関する作業は，読者の演習として残って
います．貢献は，きっと歓迎されます．

以下の型は`ltdl.h'で定義されています．

 -- Type: lt_ptr
     `lt_ptr'は，汎用ポインタです．

 -- Type: lt_dlhandle
     `lt_dlhandle'はモジュール"ハンドル"です．すべてのlt_dlopenされる
     モジュールはそれに関連付けされたハンドルがあります．

 -- Type: lt_dlsymlist
     `lt_dlsymlist'はdlpreopenされるモジュールのシンボルリストです．こ
     の構造体は，*Note Dlpreopening::で記述されます．

libltdlは以下の関数を提供します．

 -- Function: int lt_dlinit (void)
     libltdlを初期化します．この関数は，libltdl使用する前に呼び出す必
     要があり，複数回呼び出すことが可能です．成功したら0，それ以外では
     エラーの番号を返します．

 -- Function: int lt_dlexit (void)
     libltdlを終了し，すべてのモジュールを閉じます．この関数は，
     `lt_dlinit'が正常に呼び出された回数と同じだけ呼び出されたとき，
     libltdlを終了するだけです．成功したら0，それ以外ではエラーの番号
     を返します．

 -- Function: lt_dlhandle lt_dlopen (const char *FILENAME)
     ファイル名FILENAMEを用いてモジュールを開き，そのハンドルを返しま
     す．`lt_dlopen'は，libtoolダイナミックモジュール，プリロードされ
     たスタティックモジュール，プログラム自身，そしてネイティブなダイ
     ナミックライブラリを開くことが可能です．

     モジュール内の未解決のシンボルは，それが依存する(まだ実装されてい
     ない) ライブラリと，前もってdlopenされたモジュールを用いて解決さ
     れます．このモジュールを使用している実行形式が`-export-dynamic'フ
     ラグでリンクされている場合，実行形式の大域的なシンボルもモジュー
     ル内の参照の解決に使用されます．

     FILENAMEが`NULL'でプログラムが`-export-dynamic'や`-dlopen self'を
     用いてリンクされている場合，`lt_dlopen'はプログラム自身のハンドル
     を返し，それはそのシンボルのアクセスに使用可能です．

     libltdlがライブラリを見つけられず，ファイル名FILENAMEがディレクト
     リコンポーネントを持たない場合，それは，以下の検索パスを(以下の順
     番で)，さらにモジュールを検索します．

       1. ユーザ定義の検索パス：この検索パスは，関数
          `lt_dlsetsearchpath'，`lt_dladdsearchdir'，そして
          `lt_dlinsertsearchdir'を用いたプログラムで変更可能です．

       2. libltdlの検索パス：この検索パスは，環境変数LTDL_LIBRARY_PATH
          の値です．

       3. システムのライブラリ検索パス：システム依存のライブラリ検索パ
          スです(例えば，LinuxではLD_LIBRARY_PATHになります)．

     それぞれの検索パスは，例えば`"/usr/lib/mypkg:/lib/foo"'のように，
     コロンで分離された絶対的なディレクトリのリストにする必要がありま
     す．

     同じモジュールが複数回ロードされた場合，同じハンドルが返されます．
     あらゆる原因で`lt_dlopen'が失敗した場合，`NULL'が返されます．

 -- Function: lt_dlhandle lt_dlopenext (const char *FILENAME)
     ファイル名に異なるファイル名の拡張子を追加を試みる以外は，
     `lt_dlopen'と同じです．ファイル名FILENAMEを持つファイルが見つから
     ない場合，libltdlは，以下の拡張子の追加を試みます．

       1. libtoolのアーカイブ拡張子`.la'
       2. ホストプラットフォームの本来のダイナミックライブラリに使用さ
          れる拡張子で，例えば，`.so'，`.sl'等です．

     この探索手法は，本来のダイナミックライブラリの命名規則を知らない
     プログラムが，そのようなライブラリを，libtoolモジュールと同様に，
     透過的に`dlopen'することを可能にするために設計されています．

 -- Function: int lt_dlclose (lt_dlhandle HANDLE)
     モジュールHANDLEの参照カウントを減らします．ゼロになったり，この
     モジュールに依存する他のモジュールがない場合，モジュールはアンロー
     ドされます．成功時には0を返します．

 -- Function: lt_ptr lt_dlsym (lt_dlhandle HANDLE, const char *NAME)
     モジュールHANDLE内のアドレスを返し，そこでは，ヌルで終端された文
     字列NAMEで与えられるシンボルがロードされています．シンボルが見つ
     からない場合は`NULL'を返します．

 -- Function: const char * lt_dlerror (void)
     libltdlのあらゆる関数から発生した最も新しいエラーを記述する，可読
     性の高い文字列を返します．初期化からまたは最後に呼び出されてから
     エラーが発生していない場合，`NULL'を返します．

 -- Function: int lt_dlpreload (const lt_dlsymlist *PRELOADED)
     プリロードされているモジュールPRELOADEDのリストを登録します．
     PRELOADEDが`NULL'の場合，`lt_dlpreload_default'で設定されているリ
     スト以外の，これまで登録されているすべてのシンボルリストが検出さ
     れます．成功時には0を返します．

 -- Function: int lt_dlpreload_default (const lt_dlsymlist *PRELOADED)
     プリロードされているモジュールリストのデフォルトをPRELOADEDに設定
     し，それは`lt_dlpreload'で検出されません．この関数は，`lt_dlinit'
     を使用して初期化されるためにlibltdlを要求し*ない* ことと，デフォ
     ルトでプリロードされるモジュールを登録するためにプログラムで使用
     できることに注意してください．この関数を直接呼び出す代わりに，ほ
     とんどのプログラムはマクロ`LTDL_SET_PRELOADED_SYMBOLS'を使用しま
     す．

     成功時には0を返します．

 -- Macro: LTDL_SET_PRELOADED_SYMBOLS
     プリロードされるシンボルのデフォルトリストを設定します．プリロー
     ドされるlibltdlのモジュールを初期化するために，プログラムで使用し
     た方が良いでしょう．

          #include <ltdl.h>

          int main() {
            /* ... */
            LTDL_SET_PRELOADED_SYMBOLS();
            /* ... */
          }

 -- Function: int lt_dladdsearchdir (const char *SEARCH_DIR)
     検索ディレクトリSEARCH_DIRを現在のユーザ定義のライブラリ検索パス
     に後置します．成功時には0を返します．

 -- Function: int lt_dlinsertsearchdir (const char *BEFORE, const char *SEARCH_DIR)
     検索ディレクトリSEARCH_DIRをユーザ定義のライブラリ検索パスを，ア
     ドレスBEFOREで始まる項目の直前に挿入します．BEFOREが`NULL'の場合，
     `lt_dladdsearchdir'が呼び出されたのと同様に後置します．成功時には
     0を返します．

 -- Function: int lt_dlsetsearchpath (const char *SEARCH_PATH)
     現在のユーザ定義のライブラリ検索パスをSEARCH_PATHで置換し，それは
     コロンで分けられた絶対的なディレクトリのリストにする必要がありま
     す．成功時には0を返します．

 -- Function: const char * lt_dlgetsearchpath (void)
     現在のユーザ定義のライブラリ検索パスを返します．

 -- Function: int lt_dlforeachfile (const char *SEARCH_PATH, int (*FUNC) (const char *FILENAME, lt_ptr DATA), lt_ptr DATA)
     アプリケーションによっては，既知の名前でモジュールを個別にロード
     したくなく，むしろディレクトリの組みからすべてのモジュールを見つ
     けたり，初期化中にすべてロードしたいかもしれません．この関数を用
     いると，libltdlに候補となるSEARCH_PATH内のコロンで分離されたディ
     レクトリリストを走査させ，それらを独自のコールバック関数FUNCに渡
     すDATAと併せて渡すことが可能です．SEACH_PATHが`NULL'の場合，
     `lt_dlopen'が調査する標準的な場所をすべて検索します．この関数は，
     これらの呼び出しの一つでもゼロ以外の値が返されるまで，またはファ
     イルが亡くなるまで，SEARCH_PATHで見つかったそれぞれのファイルに対
     し，FUNCを呼び出し続けます．`lt_dlforeachfile'は最後のFUNCの呼び
     出しの返り値を返します．

     例えば，最初のベクトル(配列)のアドレスを保持しているDATAを使用し
     ているファイルの，順番になっている"argv"のようなベクトル(配列)を
     構築するために，FUNCを定義することも可能です．

 -- Function: int lt_dlmakeresident (lt_dlhandle HANDLE)
     モジュールを`lt_dlclose'できないように印を付けます．モジュールが
     プロジェクトの中心部の機能を実装している場合，削除されるとコード
     が壊れるので，これは役に立つはずです．成功すると0を返します．

     実行しているバイナリに対するHANDLEを取得するために`lt_dlopen
     (NULL)'を使用する場合，そのハンドルは常駐しているような印が常に付
     き，したがってうまく`lt_dlclose'することができません．

 -- Function: int lt_dlisresident (lt_dlhandle HANDLE)
     特定のモジュールが常駐しているように印が付いているかどうか調査し，
     その場合は1を返し，それ以外では0を返します．この関数の実行中にエ
     ラーがある場合， -1 が返され，`lt_dlerror'を用いて回収されるエラー
     メッセージが設定されます．

 -- Variable: lt_ptr (*) (size_t SIZE) lt_dlmalloc
 -- Variable: void (*) (lt_ptr PTR) lt_dlfree
     これらの変数は，デフォルトで`malloc'と`free'に設定されますが，同
     等の機能を提供する他の関数に設定可能です．しかし，
     `lt_dlpreopen_default'やマクロ`LTDL_SET_PRELOADED_SYMBOLS'以外の
     あらゆるlibltdl関数の呼び出し後に，その値を編集すべきではありませ
     ん．



File: libtool-ja.info, Node: Modules for libltdl, Next: Thread Saftey in libltdl, Prev: Libltdl interface, Up: Using libltdl

`dlopen'可能なモジュールの作成
==============================

libtoolモジュールは，いくつかの例外はありますが，通常のlibtoolライブラ
リに似ています．

libtoolの`-module'スイッチを用いて，モジュールとリンクする必要があり，
そして，dlopenをサポートしていないプラットフォームでlibtoolがdlpreopen
できるよう，`-dlopen modulename.la'を用いてモジュールをdlopenするため
に，あらゆるプログラムとリンクすべきです．モジュールが，あらゆる他のラ
イブラリに依存する場合，モジュールとリンクするときや，それをdlopenする
プログラムをリンクするとき，それらを確実に指定してください．特定のモ
ジュールに対し*Note Versioning::を使用禁止にしたい場合，
`-avoid-version'スイッチを用いてリンクすべきです．libtoolモジュールは，
"lib"接頭辞が不要なことに注意してください．しかし，automake 1.4 やそれ
以降のものは，そのようなモジュールのビルドが必要です．

通常，その内部を知る必要なしにプログラムがdlopenできるよう，一組のモ
ジュールは同じインターフェース提供し，すなわち同じシンボルをエクスポー
トします．すべてのエクスポートされたシンボルで，シンボルの衝突を避ける
ため，"modulename_LTX_"を前置する必要があります(`modulename'はモジュー
ル名です)．内部シンボルは，例えば"_modulename_"を前置するといった，他
のモジュールと衝突しないような方法で命名する必要があります．一回以上宣
言された，同じシンボルを持つことをサポートするシステムもありますがそれ
は通常移植性がなく，そのようなモジュールをdlpreopenすることを不可能に
します．libltdlは，シンボルの本当の名前を得るとき，自動的に接頭辞を切
り取ります．さらに，非libtoolモジュールもdlopenできるよう，接頭辞を使
用していないモジュールをサポートします．

`foo1.c'は移植可能なlibtoolモジュールの例です．エクスポートされたシン
ボルは"foo1_LTX_"，内部シンボルは"_foo1_"が前置されています．コードの
可読性を高めるため，エイリアスは最初に定義されています．

     /* aliases for the exported symbols */
     #define foo	foo1_LTX_foo
     #define bar	foo1_LTX_bar

     /* a global variable definition */
     int bar = 1;

     /* a private function */
     int _foo1_helper() {
       return bar;
     }

     /* an exported function */
     int foo() {
       return _foo1_helper();
     }

`Makefile.am'は，モジュール`foo1.la'をビルドするのに必要な規則を含んで
います．

     ...
     lib_LTLIBRARIES = foo1.la

     foo1_la_SOURCES = foo1.c
     foo1_la_LDFLAGS = -module
     ...




File: libtool-ja.info, Node: Thread Saftey in libltdl, Next: User defined module data, Prev: Modules for libltdl, Up: Using libltdl

マルチスレッド環境でのlibtldlの使用
===================================

`lt_dlmutex_register()'関数を使用し，適切なコールバック関数の定義を提
供することで，libltdlをマルチスレッド環境で使用することが可能です．

 -- Type: void lt_dlmutex_lock (void)
     これは，ミューテックスロックが必要なlibltdlの実装コードの部分の，
     最初に呼び出される関数のアドレスを持っている，関数のポインタ型で
     す．

     libltdlは本質的に再帰的なので，これらのコールバック関数によって使
     用されるロックメカニズムが再入可能であることは重要で，そうでなけ
     れば，おかしな問題が発生します．

 -- Type: void lt_dlmutex_unlock (void)
     アンロック関数に一致する型です．

 -- Type: void lt_dlmutex_seterror (const char *ERROR);
     libltdl APIの関数の多くは，エラーを発生したクライアントを示す，特
     殊な返り値をとります．通常(シングルスレッドアプリケーションでは)，
     内部から回収することができるエラーを記述する文字列は，
     `lt_dlerror()' に保存されます．

     この形式の関数は，それがマルチスレッドのコンテクストで動作するよ
     うに，ライブラリに登録される必要があります．関数は，スレッドロー
     カルストレージに渡されるあらゆるエラーメッセージを保存すべきです．

 -- Type: const char * lt_dlmutex_geterror (void)
     スレッドローカルのストレージに，最後にエラーメッセージを保存した
     ものに関連するコールバック関数に一致する型です．

     正しく登録されたとき，クライアントに対するエラーメッセージを回収
     するために，全てのスレッドから`lt_dlerror())'によって，この関数は
     使用されます．

 -- Function: int lt_dlmutex_register (lt_dlmutex_lock *LOCK, lt_dlmutex_unlock *UNLOCK, lt_dlmutex_set_error *SETERROR, lt_dlmutex_geterror *GETERROR)
     libltdlのマルチスレッドの準備で，上記のそれぞれの関数の型を登録す
     るために，この関数を使用してください．全ての引数は，有効な`NULL'
     でない関数アドレスにする必要があり，また，そうでない場合は，シン
     グルスレッドオペレーションへの返り値として，全て`NULL'にする必要
     があります．




File: libtool-ja.info, Node: User defined module data, Next: Module loaders for libltdl, Prev: Thread Saftey in libltdl, Up: Using libltdl

ロードされたモジュールに関連するデータ
======================================

libltdlが管理している，それぞれのロードされたモジュールに関する内部情
報には，ユーザが利用可能なものもあり，それは以下のような構造体の形式で
す．

 -- Type: struct lt_dlinfo  char *FILENAME; char *NAME; int REF_COUNT; 
     `lt_dlinfo'は，モジュールの情報を保存するために使用されます．
     FILENAME属性は，`NULL'で終端された，実際のモジュールファイル名の
     文字列です．モジュールがlibtoolモジュールの場合，NAMEはそのモジュー
     ル名(例えば，`"dir/libfoo.la"'に対する`"libfoo"') で，それ以外で
     は`NULL'に設定されます．REF_COUNT属性は，現在ロードされている同じ
     モジュールの回数を記述する参照カウンタです．

以下の関数は，与えられたHANDLEに対するこの構造体のlibltdlの内部のコピー
へのポインタを返します．

 -- Function: const lt_dlinfo * lt_dlgetinfo (lt_dlhandle HANDLE)
     モジュールHANDLEに関するいくつかの情報を含む構造体の，ポインタを
     返します．構造体の内容は編集してはなりません．失敗時には`NULL'が
     返ります．

さらに，ロードした全てのモジュールのハンドルリストを保持する手助けをす
るために，これらの関数で，ロードされているモジュールのlibltdlのリスト
全体を繰り返すことが可能となります．

 -- Function: int lt_dlforeach (int (*FUNC) (lt_dlhandle HANDLE, lt_ptr DATA), lt_ptr DATA)
     ロードされているそれぞれのモジュールに対し関数FUNCを呼び出します．
     引数のHANDLEは，ロードされているモジュールのハンドルの一つで，
     DATAは，`lt_dlforeach'に渡すDATA引数です．FUNC がハンドルの一つに
     対し，ゼロでない値を返すとすぐに，`lt_dlforeach'はFUNCの呼び出し
     を停止し，直ちに1を返します．それ以外は0が返ります．

 -- Function: lt_dlhandle lt_dlhandle_next (lt_dlhandle place)
     PLACEが`NULL'の場合は，リスト内の最初のハンドルを返し，そして順番
     に次ものを呼び出すことで，ロードされているモジュール全体を繰り返
     します．PLACEが，ロードされているモジュールリスト内の最後の要素の
     場合，この関数は`NULL'を返します．

もちろん，アプリケーションの目的のために，それぞれのハンドルに関連付け
する必要があるデータがある場合，libltdlで管理されるリストと平行して，
ロードされたモジュールハンドルの独自のリストの管理が必要になります．し
かし，個別のモジュールハンドルを用いたアプリケーションデータに，ロード
されたものとして関連付けさせるために，以下のAPIの呼び出しを使用する場
合には，実際にはそうする必要はありません．前もって保存したデータを回収
するために後で利用するlibltdlからのユニークな呼び出しidを，最初に取得
する必要があります．これで，ロードされているモジュールに対する独自のデー
タを個別に保存したい異なるライブラリが，もう一つの(ライブラリ)のデータ
へのインターフェースなしでそれを行うことが可能となります．

 -- Type: lt_dlcaller_id
     個別のデータセットのキーを保つ，透過でない型です．

 -- Function: lt_dlcaller_id lt_dlcaller_register (void)
     モジュールデータごとに個別のセットを，保存し回収するためのユニー
     クなキーを取得するために，これを使用してください．

 -- Function: lt_ptr lt_dlcaller_set_data (lt_dlcaller_id KEY, lt_dlhandle HANDLE, lt_ptr DATA)
     後で回収するために，KEYとHANDLEにユニークに関連付けされたデータの
     セットとして，DATAを設定します．この関数は，以前に関連付けされた
     KEYとHANDLEがある場合は，そのDATAを返します．0の結果は，前回のエ
     ラー(が存在する場合)に対する診断結果が，`lt_dlerror()' で利用可能
     であることを示している可能性があります．

     例えば，いくつかの関連データを正しく削除するために，以下のように
     します．

              lt_ptr stale = lt_dlcaller_set_data (key, handle, 0);
              if (stale == NULL)
                {
                  char *error_msg = lt_dlerror ();

                  if (error_msg != NULL)
                    {
                      my_error_handler (error_msg);
                      return STATUS_FAILED;
                    }
                }
              else
                {
                  free (stale);
                }

 -- Function: lt_ptr lt_dlcaller_get_data (lt_dlcaller_id KEY, lt_dlhandle HANDLE)
     KEYとHANDLEに関連付けされているDATAのアドレス，または，無い場合は
     `NULL'を返します．

ここまでの関数は，アプリケーションにロードされたりアンロードされたりし
たモジュールを追跡させる必要なく，オペレーションの検索と適用を実装する
ために，`lt_dlforeach'と組み合わせることが可能です．

     int
     my_dlcaller_callback (lt_dlhandle handle, lt_ptr key_ptr)
     {
       struct my_module_data *my_data;

       my_data = lt_dlcaller_get_data (handle, (lt_dlcaller_id) *key_ptr);

       return process (my_data);
     }

     int
     my_dlcaller_foreach (lt_dlcaller_id key)
     {
       lt_dlforeach (my_dlcaller_callback, (lt_ptr) &key);
     }




File: libtool-ja.info, Node: Module loaders for libltdl, Next: Distributing libltdl, Prev: User defined module data, Up: Using libltdl

新しいモジュールローダの作成方法と登録方法
==========================================

モジュールにアクセスするためのlibltdlの方法は多いけれど，プロジェクト
の目的に十分でないときもあります．独自のローダを書き，`lt_dlopen' が利
用できるように，libltdlでそれを登録することが可能です．

ローダを書くことは，`lt_dlopen'，`lt_dlsym'そして`lt_dlclose'で呼び出
し可能な，少なくとも三つの関数を書くことを必要とします．オプションで，
`lt_dlexit'が実行されるときクリーンアップ処理を実行する終了関数と，
`lt_dlsym'に渡されるあらゆるシンボルに前置されるシンボルの前置文字を提
供することも可能です．これらの関数は，以下の関数のポインタ型に一致する
必要があり，その後，それらを`lt_user_dlloader'の代わりに関連付けし，登
録することが可能です．

ローダの登録には，`lt_dlloader_find'が認識でき，`lt_dlloader_remove'で
削除できるように，それに対する名前を選択することが必要です．選択した名
前はユニークである必要があり，libltdlの組み込みローダで既に使用してい
るものはいけません．

"dlopen"
     存在する場合は，システムのダイナミックローダ．
"dld"
     libltdlがビルドされたときに`libdld'がインストールされている場合は，
     GNU dldローダ．
"dlpreload"
     プリロードされているスタティックモジュールの`lt_dlopen'のためのロー
     ダ．

前置される"dl"は，libltdlの将来のバージョンで提供されるローダとして予
約されているので，独自のローダ名に使用すべきではありません．

以下の型は，`ltdl.h'で定義されています．

 -- Type: lt_module
     `lt_module'はモジュール依存のdlloaderです．ダイナミックモジュール
     ローダの拡張は，これらの低レベルの型を使用して通信を行ないます．

 -- Type: lt_dlloader
     `lt_dlloader'はモジュールローダの型に対するハンドルです．

 -- Type: lt_user_data
     `lt_user_data'はローダのインスタンスデータに対して使用されます．

 -- Type: struct lt_user_dlloader const char *SYM_PREFIX; lt_module_open *MODULE_OPEN; lt_module_close *MODULE_CLOSE; lt_find_sym *FIND_SYM; lt_dlloader_exit *DLLOADER_EXIT; 
     ダイナミックモジュールを開くために新しい方法を定義したくて，それ
     を使用した`lt_dlopen' APIがある場合，これらの構造体のインスタンス
     を作成し，それを`lt_dlloader_add'に渡す必要があります．好みの
     DLLOADER_DATAフィールドで渡すことが可能で，それは，関数ポインタ
     フィールドで指定されている，それぞれの関数への最初のパラメータの
     値として返されます．

 -- Type: lt_module lt_module_open (const char *FILENAME)
     `lt_dlloader'モジュールローダに対するローダ関数の型です．`struct
     lt_user_dlloader'構造体のdlloader_dataフィールドに設定される値は，
     LOADER_DATAパラメータで，この関数に渡されます．そのような関数の実
     装は，指名されたモジュールのロードを試み，関連する
     `lt_module_close'と`lt_sym_find'関数のポインタに渡すのに適切な
     `lt_module'を返すべきです．関数が失敗した場合は`NULL'を返し，
     `lt_dlseterror'を用いてエラーメッセージを設定すべきです．

 -- Type: int lt_module_close (lt_user_data LOADER_DATA, lt_module MODULE)
     ユーザが定義したモジュールローダに対するアンローダの型です．その
     ような関数の実装は，MODULEモジュールに結び付けられたあらゆるリソー
     スの解放を試み，その後でメモリからアンロードすべきです．理由があっ
     て関数が失敗した場合，`lt_dlseterror'を用いてエラーメッセージを設
     定し，ゼロ以外を返すべきです．

 -- Type: lt_ptr lt_find_sym (lt_module MODULE, const char *SYMBOL)
     ユーザが定義したモジュールローダに対する，シンボルルックアップ関
     数の型です．そのような関数の実装は，モジュールMODULE内の指名され
     たSYMBOLのアドレスを返す，もしくは，検査が失敗した場合は，エラー
     メッセージを`lt_dlseterror'で設定し，`NULL'を返すべきです．

 -- Type: int lt_dlloader_exit (lt_user_data LOADER_DATA)
     ユーザが定義したモジュールローダに対する，終了関数の型です．その
     ような関数の実装は，ローダに関連するあらゆるリソースを解放すべき
     で，それには`lt_user_dlloader'の`dlloader_data'フィールド内部にあ
     るユーザが指定したあらゆるデータを含みます．`NULL'でない場合は，
     関数は`lt_dlexit'と`lt_dlloader_remove'から呼び出されます．

例えば，以下のようにします．

     int
     register_myloader (void)
     {
       lt_user_dlloader dlloader;

       /* User modules are responsible for their own initialisation. */
       if (myloader_init () != 0)
         return MYLOADER_INIT_ERROR;

       dlloader.sym_prefix    = NULL;
       dlloader.module_open   = myloader_open;
       dlloader.module_close  = myloader_close;
       dlloader.find_sym      = myloader_find_sym.
       dlloader.dlloader_exit = myloader_exit;
       dlloader.dlloader_data = (lt_user_data)myloader_function;

       /* Add my loader as the default module loader. */
       if (lt_dlloader_add (lt_dlloader_next (NULL), &dlloader, "myloader") != 0)
         return ERROR;

       return OK;
     }

ローダに対する必要な初期化がある場合は，ローダが登録される前に手動で実
行する必要があることに注意してください -- libltdlはユーザローダの初期
化を扱いません．

終了はlibltdlで扱われ*ます*が，`dlloader_exit'のコールバックが初期化
フェーズの間に要求された，あらゆるリソースを解放することを確かめること
は重要です．

libltdlは，独自のモジュールローダを書くために，以下の関数を提供します．

 -- Function: int lt_dlloader_add (lt_dlloader *PLACE, lt_user_dlloader *DLLOADER, const char *LOADER_NAME)
     新しいモジュールローダを全てのローダリストに加え，それは，(PLACE 
     が`NULL'の場合は)最後のローダとして，それ以外ではPLACEとして渡さ
     れたローダの直前に加えます．LOADER_NAMEは，新しく登録されたローダ
     が渡された場合，`lt_dlloader_name'を返します，これらのLOADER_NAME
     は，ユニークである必要があり，そうでない場合は，
     `lt_dlloader_remove'と`lt_dlloader_find'は動作不可能です．成功に
     対し0を返します．

          {
            /* Make myloader be the last one. */
            if (lt_dlloader_add (NULL, myloader) != 0)
              perror (lt_dlerror ());
          }

 -- Function: int lt_dlloader_remove (const char *LOADER_NAME)
     ユニークな名前LOADER_NAMEで識別されているローダを削除します．これ
     が成功可能となる前に，指名されたローダにより開かれている全てのモ
     ジュールを，閉じておく必要があります．成功に対し0を返し，それ以外
     では，エラーメッセージが`lt_dlerror'から取得可能です．

          {
            /* Remove myloader. */
            if (lt_dlloader_remove ("myloader") != 0)
              perror (lt_dlerror ());
          }

 -- Function: lt_dlloader * lt_dlloader_next (lt_dlloader *PLACE)
     ローダモジュール全体を繰り返し，それは，PLACEが`NULL'の場合は最初
     のローダを返し，順番に次を呼び出すことで行います．ハンドルは，
     `lt_dlloader_add'用です．

          {
            /* Make myloader be the first one. */
            if (lt_dlloader_add (lt_dlloader_next (NULL), myloader) != 0)
              return ERROR;
          }

 -- Function: lt_dlloader * lt_dlloader_find (const char *LOADER_NAME)
     LOADER_NAME識別子に一致する最初のローダを返し，識別子が見つからな
     い場合は`NULL'を返します．

     libltdl自身で使用可能な識別子は，ホストアーキテクチャがサポートし
     ている場合は"dlopen" (1) (*Note Module loaders for
     libltdl-Footnotes::)，"dld"，そして"dlpreload"です．


          {
            /* Add a user loader as the next module loader to be tried if
               the standard dlopen loader were to fail when lt_dlopening. */
            if (lt_dlloader_add (lt_dlloader_find ("dlopen"), myloader) != 0)
              return ERROR;
          }

 -- Function: const char * lt_dlloader_name (lt_dlloader *PLACE)
     `lt_dlloader_next'や`lt_dlloader_find'で取得される，PLACEの識別名
     を返します．この関数が失敗する場合，`NULL'を返し，`lt_dlerror'で
     回収するためのエラーを設定します．

 -- Function: lt_user_data * lt_dlloader_data (lt_dlloader *PLACE)
     `lt_dlloader_next'や`lt_dlloader_find'で取得される，PLACEのアドレ
     スを返します．この関数が失敗する場合，`NULL'を返し，`lt_dlerror'
     で回収するためのエラーを設定します．


ユーザモジュールローダでのエラー処理
------------------------------------

 -- Function: int lt_dladderror (const char *DIAGNOSTIC)
     この関数で，独自のエラーメッセージを`lt_dlerror'に組み込むことが
     可能となります．`lt_dlerror'で返すための適切な診断メッセージに渡
     すものと，`lt_dlseterror'で使用されるエラー識別子が返されます．

     識別子の割り当てが失敗した場合，この関数は-1を返します．

          int myerror = lt_dladderror ("Doh!");
          if (myerror < 0)
            perror (lt_dlerror ());

 -- Function: int lt_dlseterror (int ERRORCODE)
     独自のモジュールローダを書くとき，`lt_dlerror'インターフェースを
     通じて伝搬されるようにエラーを発生させるために，この関数を使用す
     べきです．libltdlで使用される標準エラーの全ては，`ltdl.h'で宣言さ
     れていて，そうでなければ，`lt_dladderror'を用いて独自に書き加える
     ことが可能です．

          if (lt_dlseterror (LTDL_ERROR_NO_MEMORY) != 0)
            perror (lt_dlerror ());


File: libtool-ja.info  Node: Module loaders for libltdl-Footnotes, Up: Module loaders for libltdl

(1) これは，モジュールをロードしているAPI に依存します -- 例
えば，`shl_load'と`LoadLibrary'です



File: libtool-ja.info, Node: Distributing libltdl, Prev: Module loaders for libltdl, Up: Using libltdl

パッケージとともにlibltdlを配布する方法
=======================================

libltdlはlibtoolとともにインストールされるのですが，libtoolやlibltdlを
インストールしていないパッケージユーザの利便性のため，パッケージの配布
物にlibltdlを含めたいと思うかもしれません．この場合，手動でパッケージ
に加える`ltdl'オブジェクト，または，使用したいlibltdlの特色を決定する
必要があります．それは，コンビニエンスライブラリやインストール可能な
libtoolライブラリです．

`libltdl'をッケージに加える最も簡単な方法は，ソースファイルの`ltdl.c'
と`ltdl.h'をパッケージのソースディレクトリにコピーし，ソースの残りと一
緒にリンクすることです．これの手助けをするため，autoconfのm4マクロが
`ltdl.m4'で利用可能です．autoconfを実行する前に，それらが`aclocal.m4'
で利用可能かどうかを確かめる必要があります -- automakeを使用している場
合は`ltdl.m4'の内容を`acinclude.m4'に加え，そうでない場合は
`aclocal.m4'に加えます．マクロを利用可能にした後，`ltdl.o'を正しくビル
ドするために必要なコンフィグレーション時の調査を実行するため，
`AC_LIB_LTDL'マクロの呼び出しを，パッケージの`configure.in'に加える必
要があります．インストールされているlibltdl やlibltdlに依存しているラ
イブラリと，パケージのバイナリをリンクしようとする場合，この手法には問
題があります．シンボルの二重定義の問題があるかもしれません．

コンビニエンスライブラリの利点の一つは，インストールされていないという
ことなので，libtoolを使用するという事実はユーザにとって明白ではなく，
ユーザが以前にインストールしているlibtoolのバージョンを上書きしません．
一方，(例えば，バグフィックスといった)理由があって，libltdlをアップグ
レードしたい場合，インストールされているバージョンのlibtoolを置き換え
る代わりに，パッケージを再コンパイルする必要があります．しかし，プログ
ラムやライブラリが以前にインストールされているバージョンのlibltdlを使
用しているライブラリとリンクする場合，リンカエラーが発生し実行時にクラッ
シュするかもしれません．もう一つの問題は，一つ以上のlibtoolライブラリ
へコンビニエンスライブラリをリンクできないことで，複製されたシンボルを
得る可能性があるので，そのときは，これらのライブラリを用いた単一のプロ
グラムとリンクしてください．一般的に，libtoolを使用している他のライブ
ラリに依存しないプログラムでは，コンビニエンスライブラリを問題なく使用
可能です．libltdlのこの特徴を利用可能にするため，
`AC_LIBLTDL_CONVENIENCE'行を`configure.in'に，`AC_PROG_LIBTOOL'の*前に
*加えた方が良いでしょう．

インストール可能なバージョンのlibltdlを選択するために，マクロ
`AC_LIBLTDL_INSTALLABLE'の呼び出しを`configure.in'に，
`AC_PROG_LIBTOOL'の*前に*加えた方が良いでしょう．このマクロは，libltdl
が既にインストールされているかどうか調査し，そうでない場合，ビルドしイ
ンストールされるパッケージlibltdlを埋め込むことを要求します．しかし，
バージョン調査は実行されないことに注意してください．ユーザは，コンフィ
グレーションスイッチ`--enable-ltdl-install'を使用することで，他のバー
ジョンの存在に関係なく，テストを優先し，埋め込まれたlibtoolをインストー
ルする必要があるか決定することができます．

libtoolをパッケージに埋め込むため，`libtoolize'コマンドラインに
`--ltdl'のみ加えてください．それで，パッケージのサブディレクトリ
`libltdl'にlibtoolのソースをコピーします．どちらのマクロも，`libltdl'
ディレクトリの位置を指定する追加の引数を受け入れます．デフォルトで，ど
ちらのマクロも`${top_srcdir}/libltdl'を仮定します．

どのマクロを使用しても，`configure.in'は`AC_CONFIG_SUBDIRS' を使用して，
libltdlをコンフィグレーションし，`Makefile'が，例えば，automakeの
SUBDIRSを使用して，libtoolのディレクトリでサブmakeを開始することを確実
にするのはあなたです．どちらのマクロも，libltdlでリンクするために使用
するリンクフラグのシェル変数LIBLTDLと，`ltdl.h'をインクルードするプロ
グラムをコンパイルするために使用するプリプロセッサフラグLTDLINCLを定義
します．この変数が`Makefile'で利用可能にすることを確実にするため
`AC_SUBST'を使用したり，デフォルトで`AC_SUBST'される，LIBSとCPPFLAGSの
ような変数に加えるのはあなた次第です．

コンビニエンスlibltdlを使用している場合，LIBLTDLはコンビニエンス
libltdlのバージョンに対するパス名で，LTDLINCLはlibltdlを含むディレクト
リが続く`-I'になり，どちらも`${top_builddir}/'，または，
`${top_srcdir}/'で，それぞれ始まります．

インストールされているlibltdlのバージョンを要求し，それが見つかった場
合 (1) (*Note Distributing libltdl-Footnotes::)，LIBLTDLは`-lltdl'に，
LTDLINCLは空に設定されます(それは，libltdlがライブラリパスにある場合，
`ltdl.h'がインクルードパスのどこかにあるという，暗黙の仮定です)．イン
ストール可能なlibltdlのバージョンをビルドする必要がある場合，
`${top_builddir}/'で始まるそのパス名は，LIBLTDLに保存され，LTDLINCLは
コンビニエンスライブラリの場合と同様に設定されます．

そのため，libltdlとプログラムをリンクしたいときは，それをインストール
された，またはインストール可能なコンビニエンスライブラリにし，すなわち，
libtoolを使用して，LTDLINCLを用いてコンパイルし，`$(LIBLTDL)'を用いて
リンクしてください．

おそらく`AC_LIBTOOL_DLOPEN'も`configure.in'に，`AC_PROG_LIBTOOL'の*前
に*加えた方が良く，そうしない場合は，libtoolはdlopenメカニズムがサポー
トされていないと仮定し，おそらく希望していないdlpreopenに逆戻りします．

libltdlとプログラムをリンクするとき，`-static'や`-all-static'スイッチ
の使用を避けてください．dlopen関数はスタティックリンクに対して利用可能
でない可能性があるので，これはすべてのプラットフォームで動作するわけで
はありません．

以下の例は，パッケージにコンビニエンスlibltdlを埋め込む方法を示します．
インストール可能な形態を使用するために，`AC_LIBLTDL_CONVENIENCE' を
`AC_LIBLTDL_INSTALLABLE'で置換してください．我々は，libltdlが
`libtoolize --ltdl'を使用して埋め込まれていると仮定しています．

configure.inは以下のようになります．
     ...
     dnl Enable building of the convenience library
     dnl and set LIBLTDL accordingly
     AC_LIBLTDL_CONVENIENCE
     dnl Substitute LTDLINCL and LIBLTDL in the Makefiles
     AC_SUBST(LTDLINCL)
     AC_SUBST(LIBLTDL)
     dnl Check for dlopen support
     AC_LIBTOOL_DLOPEN
     dnl Configure libtool
     AC_PROG_LIBTOOL
     dnl Configure libltdl
     AC_CONFIG_SUBDIRS(libltdl)
     ...

Makefile.amは以下のようになります．
     ...
     SUBDIRS = libltdl

     INCLUDES = $(LTDLINCL)

     myprog_LDFLAGS = -export-dynamic
     # The quotes around -dlopen below fool automake <= 1.4 into accepting it
     myprog_LDADD = $(LIBLTDL) "-dlopen" self "-dlopen" foo1.la
     myprog_DEPENDENCIES = $(LIBLTDL) foo1.la
     ...


File: libtool-ja.info  Node: Distributing libltdl-Footnotes, Up: Distributing libltdl

(1) たとえ，libltdlがインストールされていても，libltdlがCライブラリ以
外のライブラリが提供するシンボルに依存する場合，
`AC_LIBLTDL_INSTALLABLE'は検出に失敗する可能性があります．この場
合，libltdlのビルドとインストールは不必要です．



File: libtool-ja.info, Node: Other languages, Next: Troubleshooting, Prev: Using libltdl, Up: Top

他の言語でlibtoolを使用する
***************************

libtoolは最初に，C言語での共有ライブラリを書くことに対するサポートを加
えるために実装されました．しかし，時間が経ち，プログラマが好みのプログ
ラム言語での共有ライブラリの便利さを自由に得られるように，libtoolは他
の言語と統合されています．

この章は，libtoolが他の言語と相互作用する方法と，Cを用いない場合に必要
とされる特記事項を記述します．

* Menu:

* C++ libraries::



File: libtool-ja.info, Node: C++ libraries, Prev: Other languages, Up: Other languages

C++に対するライブラリを書く
===========================

C++コードのライブラリを作成することは，そのオブジェクトファイルがCのも
のと三つの点で異なっているだけので，かなり簡単な処理になります．

  1. 名前をmangleするため，C++ライブラリはC++コンパイラで作成されたも
     のだけ利用可能です．この決定は，コンストラクタ，例外処理，そして
     RTTIのような機能の実装との衝突からユーザを守るため，C++の設計者に
     よってなされました．

  2. システムによっては，ダイナミックリンカがダイナミック(すなわち実行
     時)に初期化の実行するため，C++コンパイラは特別な動作を行なう必要
     があります．これは，そのようなライブラリとリンクするため，`ld'を
     直接呼び出すべきではなく，その代わりにC++コンパイラを使用するべき
     だということを意味します．

  3. C++コンパイラは，いくつかの標準C++ライブラリとデフォルトでリンク
     しますが，libtoolは，これらのライブラリがどれかを知らないため，そ
     れに対してリンクする方法を調査するため，ライブラリ内部の依存の解
     析さえ実行できません．それゆえ，C++プログラムやライブラリとリンク
     するため`ld'を実行すると失敗すると思われます．

これらの問題のため，C++プログラムとライブラリをコンパイルしリンクする
ために，常にC++コンパイラを使用するように設計されています．プログラム
の`main()'関数のインスタンスによっては，スタティックなC++オブジェクト
を適切に初期化するため，C++コンパイラでコンパイルする必要があるものも
あります．



File: libtool-ja.info, Node: Troubleshooting, Next: Maintaining, Prev: Other languages, Up: Top

トラブルシューティング
**********************

libtoolは，現在のオペレーティングシステムで最新を保つよう変更しながら，
コンスタントに開発されていています．libtoolがプラットフォーム上で思っ
たように動作しない場合，問題点と解決方法を決定する助けとなる，この章を
読んだ方が良いでしょう．

* Menu:

* Libtool test suite::          Libtool's self-tests.
* Reporting bugs::              How to report problems with libtool.



File: libtool-ja.info, Node: Libtool test suite, Next: Reporting bugs, Prev: Troubleshooting, Up: Troubleshooting

libtoolのテストスイート
=======================

libtoolは，その能力をテストし，libtoolプログラムの明らかなバグを報告す
る，プログラムの独自のセットとともにあります．これらのテストは，
libtoolの過去の問題と他のオペレーティングシステム内の既知の欠陥を基に
して，絶えず進化もしています．

`INSTALL'ファイルに記述されているように，libtoolのビルド後，基本的な機
能要求に合っていることを確めるために，`make check'を実行することが可能
です．

* Menu:

* Test descriptions::           The contents of the test suite.
* When tests fail::             What to do when a test fails.



File: libtool-ja.info, Node: Test descriptions, Next: When tests fail, Prev: Libtool test suite, Up: Libtool test suite

テストスイートの記述
--------------------

テストスイートの現在のプログラムと，それらがテストするもののリストは以
下のようになっています．


`cdemo-conf.test'
`cdemo-exec.test'
`cdemo-make.test'
`cdemo-static.test'
`cdemo-shared.test'
     これらのプログラムは，libtool配布物の`cdemo'サブディレクトリが，
     正しくコンフィグレーションされ，ビルドされることを知るための調査
     を行ないます．

     `cdemo'サブディレクトリは，libtoolのコンビニエンスライブラリのデ
     モンストレーションと，ビルド時にスタティックライブラリの作成を可
     能とするメカニズムを含んでいて，コンポーネントが共有ライブラリで
     あったとしても，プログラムや他のライブラリと後でリンクされること
     を可能とする方法です．

     `cdemo-make.test'と`cdemo-exec.test'のテストは，三つの異なる
     libtoolコンフィグレーションで，三回実行されます．
     `cdemo-conf.test'は，スタティックライブラリと共有ライブラリの両方
     をビルドするために(両方サポートしているプラットフォームではデフォ
     ルトです)`cdemo/libtool'をコンフィグレーションし，
     `cdemo-static.test'はスタティックライブラリのみビルドし
     (`--disable-shared')，そして`cdemo-shared.test' は共有ライブラリ
     のみビルドします(`--disable-static')．

`demo-conf.test'
`demo-exec.test'
`demo-inst.test'
`demo-make.test'
`demo-unst.test'
`demo-static.test'
`demo-shared.test'
`demo-nofast.test'
`demo-pic.test'
`demo-nopic.test'
     これらのプログラムは，libtool配布物の`demo'サブディレクトリが，コ
     ンフィグレーション，ビルド，インストール，そしてアンインストール
     が正しくできることを知るために調査します．

     `demo'サブディレクトリは，libtoolを使用する平凡なパッケージのデモ
     ンストレーションを含んでいます．テストの`demo-make.test'，
     `demo-exec.test'，`demo-inst.test'，そして`demo-unst.test'は，四
     つの異なるlibtoolのコンフィグレーションの下で，四回実行されます．
     `demo-conf.test'は，スタティックと共有の両方のライブラリをビルド
     するために`demo/libtool'をコンフィグレーションし，
     `demo-static.test'は，スタティックライブラリのみビルドし
     (`--disable-shared')，そして`demo-shared.test'は，共有ライブラリ
     のみをビルドします(`--disable-static')．`demo-nofast.test'は，高
     速インストールモードを使用禁止にするために
     (`--enable-fast-install=no')，`demo/libtool'をコンフィグレーショ
     ンします．`demo-pic.test'は，PICコードをビルドしたいときは
     (`--with-pic')，非PICコードをビルドしたいときは(`--without-pic')
     にするように，`demo/libtool'をコンフィグレーションします．

`deplibs.test'
     スタティックライブラリを共有ライブラリにリンク不可能なシステムも
     たくさんあります．そのような場合を避けるため，libtoolは
     `deplibs_check_method'を使用します．このテストは，libtoolの
     `deplibs_check_method'が正しく動作するかどうか調査します．

`hardcode.test'
     共有ライブラリを持つすべてのシステムで，実行形式に対しリンクされ
     るライブラリの位置が実行形式の内部に符号化されるはずです*Note
     Linking executables::．このテストは，システムリンカがライブラリの
     位置をハードコードし，libtool自身のリンカの動作方法の概念と一致す
     ることを保証する条件を調査します．

`build-relink.test'
     変数SHLIBPATH_OVERRIDES_RUNPATHが正しく設定されているかどうか調査
     します．テストが失敗し，VERBOSEが設定されている場合，それは変数を
     設定する必要がないことを示します．

`noinst-link.test'
     libtoolが，たった今ビルドされたライブラリにリンクする方が良い時，
     以前にインストールされているバージョンにリンクしようとしないかど
     うか調査します．

`depdemo-conf.test'
`depdemo-exec.test'
`depdemo-inst.test'
`depdemo-make.test'
`depdemo-unst.test'
`depdemo-static.test'
`depdemo-shared.test'
`depdemo-nofast.test'
     これらのプログラムは，libtool配布物の`depdemo'サブディレクトリの，
     コンフィグレーション，ビルド，インストール，そしてアンインストー
     ルを，正しく行えることを判定するための調査を行います．

     `depdemo'サブディレクトリは，libtoolに依存する内部ライブラリのデ
     モンストレーションを含みます．このテストプログラムは，いくつかの
     交互依存しているライブラリをリンクします．

     テストの，`depdemo-make.test'，`depdemo-exec.test'，
     `depdemo-inst.test'，そして`depdemo-unst.test'は，四つの異なる
     libtoolのコンフィグレーションの下で，四回実行されます．
     `depdemo-conf.test'は，スタティックと共有の両方のライブラリをビル
     ドするために，`depdemo/libtool'をコンフィグレーションし，
     `depdemo-static.test'はスタティックライブラリのみビルドし
     (`--disable-shared')，`depdemo-shared.test'は共有ライブラリのみビ
     ルドします(`--disable-static')．`depdemo-nofast.test' は高速イン
     ストールモード(`--enable-fast-install=no')を利用不可能にするため
     に，`depdemo/libtool'をコンフィグレーションします．

`mdemo-conf.test'
`mdemo-exec.test'
`mdemo-inst.test'
`mdemo-make.test'
`mdemo-unst.test'
`mdemo-static.test'
`mdemo-shared.test'
     これらのプログラムは，libtool配布物の`mdemo'サブディレクトリが，
     コンフィグレーション，ビルド，インストール，そしてアンインストー
     ルが正しくできることを知るために調査します．

     `mdemo'サブディレクトリは，libtoolと，システム非依存のモジュール
     ロードのための，dlopenラッパー`libltdl'を使用するパッケージのデモ
     ンストレーションを含みます．ライブラリ`libltdl'は，様々なプラット
     フォーム(Linux，Solaris，HP/UX等)に対する，dlpreopenモジュールに
     対するサポートを含む(*Note Dlpreopening::)dlopenラッパーを提供し
     ます．

     テストの`mdemo-make.test'，`mdemo-exec.test'，`mdemo-inst.test'，
     そして`mdemo-unst.test'は，三つの異なるlibtoolのコンフィグレーショ
     ンの下で，三回実行されます．`mdemo-conf.test'は，スタティックと共
     有の両方のライブラリをビルドするために`mdemo/libtool'をコンフィグ
     レーションし，`mdemo-static.test'は，スタティックライブラリのみビ
     ルドし(`--disable-shared')，そして`mdemo-shared.test'は，共有ライ
     ブラリのみをビルドします(`--disable-static')．

`dryrun.test'
     このテストは，libtoolの`--dry-run'モードが正しく動作するかどうか
     を調査します．

`assign.test'
     libtoolスクリプト内の割り当てられている同じ行で，停止したり，続け
     たりしないかどうか調査します．

`link.test'
     このテストは，libtoolでないスタティックライブラリに対する直接的な
     リンクが正しく動作することを保証します．

`link-2.test'
     このテストは，`.lo'で終わるファイルがプログラムファイルに直接リン
     クされないことを確かめます．

`nomode.test'
     実際にlibtoolの助けが可能かどうか調査します．

`quote.test'
     このプログラムはlibtoolのメタ文字を引用符で囲むことを調査します．

`sh.test'
     `test'コマンドがlibtoolで忘れられていないか調査します．

`suffix.test'
     他のプログラミング言語がlibtoolで使用されるとき(*Note Other
     languages::)，ソースファイルは`.c'以外の接尾子で終わるかもしれま
     せん．このテストは，サポートするすべてのファイル形式に対する接尾
     子を扱うこと可能で，接尾子が不当なときは失敗することを確認します．




