Info file: m4-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `m4-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.




START-INFO-DIR-ENTRY
* m4-ja: (m4-ja).		A powerful macro processor.
END-INFO-DIR-ENTRY

This file documents the GNU `m4' utility.

Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994 Free Software
Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.




File: m4-ja.info, Node: Top, Next: Preliminaries, Prev: (dir), Up: (dir)

GNU `m4'
********

GNU `m4'はUNIXに古くからあるマクロプロセッサの実装です。SVR4版とほぼ互
換性がありますが、いくつかの機能が拡張がされています(たとえば、9個を超
える位置パラメータをマクロで扱うことができます)。`m4'にはマクロの展開
機能に加え、ファイルのインクルード、シェルコマンドの実行、計算、その他
のための関数も組み込まれています。Autoconfで`configure'スクリプトを生
成するにはGNU `m4'が必要ですが、スクリプトを実行するときには必要ありま
せん。

Ren'e SeindalがGNU `m4'を最初に書きました。続いて、Franc,ois Pinardや
その他のインターネット上のボランティアたちが変更を行ないました。これら
の人たちの氏名と電子メールアドレスは、GNU `m4'の配布用アーカイブファイ
ルに含まれている`THANKS'ファイルにすべて記載されています。

本GNU `m4'はリリース1.4です。現在すでに安定していることを考えると、今
後のリリースではバグの修正や速度の向上、ドキュメントの改善だけをするべ
きでしょう。しかし...

`m4'の実用性をさらに増す思われる、試験的なある機能(*Note Changeword::) 
を使うと、`m4'において何が"単語"（word）として認識されるかを決めている
規則を変更できるようになります。この機能を試してみたい人は、.
/configure --enable-changeword としてコンパイル時にこの機能が組み込ま
れるようにしてください。現在の実装では`m4'の動作がかなり遅くなってしま
うので、これをそのまま採用するには抵抗があります。したがって将来この機
能が削除されるということも考えられるので、まだこの機能に依存した使い方
はしないでください。


* Menu:

* Preliminaries::               序論
* Syntax::                      字句・構文解析の規則

* Macros::                      マクロを呼び出す方法
* Definitions::                 新たにマクロを定義する方法
* Conditionals::                条件分岐、ループ、再帰

* Debugging::                   マクロや入力をデバッグする方法

* Input Control::               入力制御
* File Inclusion::              ファイルのインクルード
* Diversions::                  出力の切替え（divert）と逆切替え（undivert）

* Text handling::               テキスト操作用の組み込みマクロ
* Arithmetic::                  計算用の組み込みマクロ
* UNIX commands::               UNIXコマンド実行用の組み込みマクロ
* Miscellaneous::               その他の組み込みマクロ
* Frozen files::                凍結状態（frozen state）の高速ロード

* Compatibility::               他の版のm4との互換性
* Concept index::               さまざまな概念の索引
* Macro index::                 m4マクロすべての索引

 -- The Detailed Node Listing ---

序論

* Intro::                       `m4'序説
* History::                     `m4'の由来

* Invoking m4::                 `m4'の起動(オプション一覧)
* Bugs::                        問題やバグへの対処方法
* Manual::                      このマニュアルの読み方

字句・構文解析の規則

* Names::                       入力トークン: マクロ名
* Quoted strings::              入力トークン: クォートされた文字列
* Other tokens::                入力トークン: その他
* Comments::                    m4への入力中のコメント

マクロを呼び出す方法

* Invocation::                  マクロの呼び出し
* Inhibiting Invocation::       マクロの呼び出しを抑制する
* Macro Arguments::             マクロの引数
* Quoting Arguments::           マクロの引数をクォートする
* Macro expansion::             マクロの展開

新たにマクロを定義する方法

* Define::                      新しいマクロを定義する
* Arguments::                   マクロの引数
* Pseudo Arguments::            マクロの疑似引数
* Undefine::                    マクロの削除
* Defn::                        マクロ名の変更
* Pushdef::                     マクロの一時的な再定義

* Indir::                       マクロの間接的な呼び出し
* Builtin::                     組み込みマクロの間接的な呼び出し

条件分岐、ループ、再帰

* Ifdef::                       マクロが定義済みかを判定する
* Ifelse::                      If-else 構文と多重分岐
* Loops::                       m4におけるループと再帰

マクロや入力をデバッグする方法

* Dumpdef::                     マクロの定義を表示する
* Trace::                       マクロの呼び出しをトレースする
* Debug Levels::                デバッグ出力の制御
* Debug Output::                デバッグ出力の保存

入力制御

* Dnl::                         空白（whitespace）を入力から削除する
* Changequote::                 引用符（quote characters）の変更
* Changecom::                   コメントデリミタ（comment delimiters）の変更
* Changeword::                  単語（word）の字句構造を変更する
* M4wrap::                      入力の一部を入力が終るまで保存（save）しておく

ファイルのインクルード

* Include::                     名前を指定してファイルをインクルードする
* Search Path::                 インクルードするファイルのサーチ

出力の切替え（divert）と逆切替え（undivert）

* Divert::                      出力を切替える（divert）
* Undivert::                    出力を逆切替えする（undivert）
* Divnum::                      出力切替え先番号（diversion number）
* Cleardiv::                    出力切替え先のテキストを破棄する

テキスト操作用の組み込みマクロ

* Len::                         文字列の長さを計算する
* Index::                       部分文字列で検索する
* Regexp::                      正規表現で検索する
* Substr::                      部分文字列を抽出する
* Translit::                    文字の置換
* Patsubst::                    正規表現でテキストの置換をする
* Format::                      文字列を(printf風に)フォーマットする

計算用の組み込みマクロ

* Incr::                        インクリメント演算子とデクリメント演算子
* Eval::                        整数式を計算する

UNIXコマンド実行用の組み込みマクロ

* Syscmd::                      単一のコマンドを実行する
* Esyscmd::                     コマンドの出力を読む
* Sysval::                      終了コード
* Maketemp::                    一時ファイル用の名前を生成する

その他の組み込みマクロ

* Errprint::                    エラーメッセージを表示する
* M4exit::                      m4を終了させる

他の版の`m4'との互換性

* Extensions::                  GNU m4で拡張された機能
* Incompatibilities::           System V m4にあってGNU m4にない機能
* Other Incompat::              その他の非互換性




File: m4-ja.info, Node: Preliminaries, Next: Syntax, Prev: Top, Up: Top

序論
****

この章ではGNU `m4'とは何か、その由来、このマニュアルの読み方と使い方、
`m4'を起動する方法、バグを報告する方法などを説明します。マニュアルの続
きを読むにあたっての助言をもってこの章は終ります。

ここから後の章では`m4'言語のすべての機能を詳しく説明します。

* Menu:

* Intro::                       `m4'序説
* History::                     `m4'の由来
* Invoking m4::                 `m4'の起動(オプション一覧)
* Bugs::                        問題やバグへの対処方法
* Manual::                      このマニュアルの読み方



File: m4-ja.info, Node: Intro, Next: History, Prev: Preliminaries, Up: Preliminaries

`m4'序説
========

マクロを展開しながら入力を出力へコピーするという意味で、`m4'はマクロプ
ロセッサだと言えます。マクロには`m4'に最初から組み込まれている組み込み
（builtin）マクロと、ユーザが自分で定義するユーザ定義（user-defined）
マクロの2種類があります。マクロは何個でも引数を取ることができます。
`m4'には単なるマクロの展開機能に加え、ファイルのインクルード、UNIXコマ
ンドの実行、整数演算、さまざまな方法でのテキスト操作、再帰、その他のた
めの関数がそろっています。`m4'はコンパイラのフロントエンドとして、また
マクロプロセッサそのものとしても使うことができます。

`m4'マクロプロセッサは、ほとんどすべてのUNIXで利用することができます。
通常その存在に気づいているのは、ほんのわずかな人たちだけです。しかし実
際に気づいた人たちは往々にして熱心なユーザとなります。GNU Autoconfで
`configure'スクリプトを*生成*するにはGNU `m4'が必要なため、GNU
Autoconfの人気が高まったのがきっかけとなってGNU `m4'をインストールする
人が増えました。もっとも、そういう人が自分で`m4'のプログラミングをする
ことは無いでしょう。GNU `m4'はわずかな違いを除けばSystem V, Release 3 
版とほぼ互換性があります。詳細は*Note Compatibility::を参照してくださ
い。

ユーザの中には`m4'中毒になってしまった人たちもいます。そういう人たちは
最初は簡単なことに`m4'を使い、徐々に複雑な`m4'マクロの書き方を習得しな
がら、大きなこと大きなことへと挑戦していくのです。いちど病みつきになっ
てしまえば、簡単な問題を解くためにさえ洗練された`m4'アプリケーションを
書こうとして、実際の仕事よりも自分の`m4'スクリプトのデバッグに多くの時
間をさくことになるのです。熱中しやすいプログラマーは`m4'で健康を損なう
おそれがあるので注意しましょう。



File: m4-ja.info, Node: History, Next: Invoking m4, Prev: Intro, Up: Preliminaries

`m4'の由来
==========

ここに記されている歴史に関する覚え書きはきわめて不完全なものであり、な
んら権威あるものでもありません。事情に通じている方は、どうかこの節をふ
さわしいものにするのを手伝ってください。

`GPM'は`m4'の重要な祖先です。C. Stratchey: "A General Purpose Macro
generator", Computer Journal 8,3 (1965), pp. 225 ff を参照してください。
`GPM'は、David Gries classic "Compiler Construction for Digital
Computers"でも簡潔に説明されています。

`GPM'は*純粋*だったのに対して、`m4'は実生活にまつわる本物の複雑さを扱
うことを意図したものでした。そのため、たとえばマクロは前もって宣言しな
くても認識されるようになり、改行文字などの空白（whitespace）をスキップ
するのは簡単になり、多くの構成要素が借り物ではなく内蔵されるようになり
ました。

もともと`m4'はRational FORTRANプリプロセッサすなわち`ratfor'(`cpp'に相
当)のエンジンでした。



File: m4-ja.info, Node: Invoking m4, Next: Bugs, Prev: History, Up: Preliminaries

`m4'の起動(オプション一覧)
==========================

`m4'コマンドの形式は次のようになります。

     `m4' [OPTION...] [MACRO-DEFINITIONS...] [INPUT-FILE...]

オプションは、短いオプション名を使うときは`-'で始め、長いオプション名
を使うときは`--'で始めます。長いオプション名は、そのオプションだと明確
に特定できる先頭部分を書くだけで十分です。`m4'は次のオプションを受けつ
けます。

`--version'
     プログラムのバージョン番号を標準出力に出力し、INPUT-FILESはいっさ
     い読まずに、ただちに`m4'の実行を終了します。

`--help'
     ヘルプ情報の要約を標準出力へ出力し、INPUT-FILESはいっさい読まずに、
     ただちに`m4'の実行を終了します。

`-G'
`--traditional'
     System V版と比べて、この実装で拡張された機能をすべて抑制します。
     これらの一覧は*Note Compatibility::を参照してください。

`-E'
`--fatal-warnings'
     すべての警告(warning)を致命的なものと見なし、最初の警告が発行され
     た時点で`m4'の実行を停止し終了します。

`-dFLAGS'
`--debug=FLAGS'
     デバッグ・レベルをFLAGSに設定します。デバッグ・レベルはデバッグ用
     関数が表示する情報の形式と量の制御に使われます。FLAGSの形式と意味
     についての詳細は*Note Debug Levels::を参照してください。

`-lNUM'
`--arglength=NUM'
     マクロをトレースすることによって生じる出力の量を制限します。詳細
     は*Note Debug Levels::を参照してください。

`-oFILE'
`--error-output=FILE'
     デバッグやトレースの出力を名前が指定されたファイルへリダイレクト
     （redirect）します。エラーメッセージは通常どおり標準エラー出力へ
     出力します。詳細は*Note Debug Output::を参照してください。

`-IDIR'
`--include=DIR'
     インクルード指定されたファイルが現在の作業ディレクトリ（the
     current working directory）で見つからない場合に、`m4'がDIRを探す
     ようにします。詳細は*Note Search Path::を参照してください。

`-e'
`--interactive'
     起動時に`m4'を対話的な状態（interactive）にします。これは、すべて
     の出力をバッファリング無しで行ない、割り込み（interrupt）を無視す
     るということを意味します。

`-s'
`--synclines'
     Cプリプロセッサやそれに類するツールで使うための同期情報を含む行を
     生成します。これは`m4'をコンパイラのフロントエンドとして使うとき
     などに便利です。ソースファイル名と行番号の情報は、`#line LINENUM
     "FILENAME"'という形式の指令（directive）によって表され、出力の途
     中へ必要に応じて挿入されます。この指令（directive）は次の行が入力
     ファイルFILENAMEの第LINENUM行そのものであるか、もしくはその行の展
     開によるものであることを意味します。`"FILENAME"'の部分は、ファイ
     ル名が前の指令（directive）と変わらない場合はしばしば省かれます。

     このような同期指令は、必ずそれ自身で完全な一行に対してのみ与えら
     れます。ある出力行の途中に同期情報の食い違いがあるときは、対応す
     る同期指令の出力は次の行へと持ち越されます。

`-P'
`--prefix-builtins'
     `m4'の内部に登録されている*すべて*の組み込みマクロの名前を接頭辞
     `m4_'が付いたものに変更します。このオプションを使ったときには、た
     とえば`define'の代わりに`m4_define'、`__file__'の代わりに
     `m4___file__'と書かなければなりません。

`-WREGEXP'
`--word-regexp=REGEXP'
     マクロ名の字句構成規則を指定します。このオプションは試験的なもの
     であり、このオプションを含まないGNU `m4'の実装も存在する可能性が
     あります。(*Note Changeword::)

`-HN'
`--hashsize=N'
     シンボルを表引きするための内部ハッシュテーブルの項目数をNにします。
     この数は素数にするべきです。デフォルトは509項目です。極端に多くの
     マクロを定義しないかぎり、この値を増やす必要は無いはずです。

`-LN'
`--nesting-limit=N'
     入れ子になったマクロの呼び出しをN段階に制限し、この制限を超えたと
     きは、プログラムの実行を停止します。指定がない状態では、入れ子は
     250段階に制限されています。

     このオプションの正確な効力は、動的な再帰構造というよりは、テキス
     ト上での入れ子構造に対して発揮されるものだと理解したほうがより正
     しいでしょう。このオプションは、機械的な方法で`m4'への複雑な入力
     を生成したときに役に立ったという例もありますが、大部分のユーザに
     とっては無用の長物でしょう。目障りだということになったときは、こ
     のオプションは(まだ試験段階です)削除されてしまうかも知れません。

     このオプションを使っても、再走査(rescanning)による無限ループを抜け出す
     ことは*できません*。その一方で、再走査ループは必ずしもメモリや
     スタック領域を大量に消費するわけではありません。
     再走査ループをうまく使えば、複雑で時間のかかる処理を`m4'に
     やらせることができます。
     この領域に制限をもうけるのは、`m4'の能力を弱めてしまうことになるでしょう。
     異常な使い方の例はいくらでもあります。
     `define(`a', `a')a'はもっとも単純なものの例です
     (しかし*Note Compatibility::)。
     GNU `m4'がこのようなケースを検出するのを期待するのは、
     コンパイラシステムが無限ループを検出し、診断メッセージをだすのを
     期待することに似ています。つまり、決定不能ではないとしても、
     一般にとても*ハード*な問題です。

`-Q'
`--quiet'
`--silent'
     マクロの呼び出しで、引数が不足していたり余分にあるときの警告を抑
     制します。

`-B'
`-S'
`-T'
     これらのオプションはSystem V版`m4'との互換性のために存在しますが、
     この実装では何の効果もありません。

`-NN'
`--diversions=N'
     これらのオプションはGNU `m4'の以前のバージョンとの互換性のためだ
     けに存在し、同時に使うことができる出力切替え先（diversion）の数を
     制御するために使われていました。現在は固定された制限値がなくなっ
     たので、何の働きもしません。


`-D'や`-U'オプションを使うと、コマンドライン上でマクロを定義したり削除
したりすることができます。これらは次の形式をとります。

`-DNAME'
`-DNAME=VALUE'
`--define=NAME'
`--define=NAME=VALUE'
     どの入力ファイルを読むよりも前に、NAMEをシンボルテーブルに登録し
     ます。`=VALUE'が省略されたときは、値は空文字列として解釈します。
     VALUEはどんな文字列でもよく、したがって、マクロは入力内で定義する
     ときと同じように引数を取るものとして定義することもできます。

`-UNAME'
`--undefine=NAME'
     NAMEのすでに定義された意味を削除します。当然、この方法で削除でき
     るのは定義済みのマクロだけです。

`-tNAME'
`--trace=NAME'
     NAMEを未定義として、しかしトレースが行われるように、シンボルテー
     ブルへ登録します。その結果、このマクロは定義された時点からトレー
     スされるようになります。

`-FFILE'
`--freeze-state FILE'
     実行が終了すると、凍結状態（frozen state）の内容を指定されたFILE
     (*Note Frozen files::)へ書き出します。

`-RFILE'
`--reload-state FILE'
     実行の前に、指定された凍結ファイルFILE (*Note Frozen files::)から
     内部状態を復元します。


コマンドライン上の残りの引数は、入力ファイルの名前として解釈します。ファ
イル名の指定がないときは、標準入力から読み込みます。ファイル名`-'は、
標準入力を意味するものとして解釈します。

入力ファイルは、指定された順番に読み込みます。標準入力は1度しか読むこ
とができませんので、ファイル名`-'はコマンドライン上で1度しか使えません。



File: m4-ja.info, Node: Bugs, Next: Manual, Prev: Invoking m4, Up: Preliminaries

問題やバグへの対処方法
======================

GNU `m4'に関して問題が起こったり、バグと思われることを見つけたときは、
どうか、それを報告してください。バグを報告する前に、実際にそれが本物の
バグなのか確かめてください。注意深くドキュメントを読み直して、あなたの
しようとしたことが実際にできると本当に書いてあるか確かめてください。も
し、ある事ができるのかどうか明確でないときは、それも報告してください。
それはドキュメントのバグです!

バグを報告したり、自分で直そうとする前に、そのバグを発現させる、できる
だけ小さな入力ファイルを作れないか試してください。作ることができたとき
は、その入力ファイルと`m4'が出す正確な結果を私たちに送ってください。ま
た、あなたはどうなるはずだと思ったのかも添えてください。これは、問題の
原因が実はドキュメントにあるものなのか判断するのに役立ちます。

問題を正確に把握したら、電子メールを(インターネット) `bug-m4@gnu.org'
または(UUCP) `mit-eddie!prep.ai.mit.edu!bug-gnu-utils'へ送ってください。
あなたが使っている`m4'のバージョン番号も書いてください、コマンド`m4
--version'で調べられます。

バグの報告以外の提案もいつでも歓迎します。ドキュメントの不明確なところ
や分かりにくい機能についての質問があれば、それも送ってください。



File: m4-ja.info, Node: Manual, Prev: Bugs, Up: Preliminaries

このマニュアルの読み方
======================

このマニュアルには`m4'の入力と出力の例がたくさん含まれており、入力、出
力および`m4'からのエラーメッセージを区別するための簡単な表記法が用いら
れています。これらの例は通常の文章とは間隔をあけて、固定幅フォントで次
のように表示されます。

     This is an example of an example!

入力と出力を区別するため、`m4'からの出力にはすべて`=>'が、エラーメッセー
ジにはすべて`error-->'が先頭につきます。したがって次のようになります。

     Example of input line (入力行の例)
     =>Output line from m4 (m4からの出力行の例)
     error-->and an error message (エラーメッセージの例)

`m4'に最初から定義されているマクロの説明では、マクロの呼び出しのプロト
タイプが、引数に分かりやすい名前をつけて示されます。これは次のようにな
ります。

     regexp(STRING, REGEXP, opt REPLACEMENT)

`m4'ではマクロの引数はすべて文字列ですが、数字、ファイル名、正規表現と
してなど特別な解釈のされかたをするものもあります。

3番目の引数の前にある`opt'は、この引数が省略可能であることを表していま
す。省略したときは、空文字列として解釈されます。引数リストの最後にある
省略記号(`...')は、その後にいくつでも引数を続けてよいことを示してます。




File: m4-ja.info, Node: Syntax, Next: Macros, Prev: Preliminaries, Up: Top

字句・構文解析の規則
********************

`m4'は入力を読み込むと、それを"トークン"（token）に分割します。トーク
ン（token）は名前（name）、クォートされた文字列(quoted string)、それら
の構成要素とならない個々の文字のどれか1つの種類に属します。また、`m4'
への入力にはコメントを含めることができます。

* Menu:

* Names::                       入力トークン: マクロ名
* Quoted strings::              入力トークン: クォートされた文字列
* Other tokens::                入力トークン: その他
* Comments::                    m4への入力中のコメント



File: m4-ja.info, Node: Names, Next: Quoted strings, Prev: Syntax, Up: Syntax

入力トークン: マクロ名
======================

名前（name）はアルファベット、数字、`_'(アンダースコア) を自由に並べた
もののうち、先頭の文字が数字でないものです。名前にマクロの定義が存在す
るときは、マクロの呼び出しとして認識され、展開の対象となります(*Note
Macros::)。

正しい名前（name）の例を挙げると`foo', `_tmp', `name01'などがあります。



File: m4-ja.info, Node: Quoted strings, Next: Other tokens, Prev: Names, Up: Syntax

入力トークン: クォートされた文字列
==================================

クォートされた文字列（quoted string）は、引用符``'と`''に囲まれた文字
列のうち、文字列の内部で開始引用符``'と終了引用符`''の数が釣り合ってい
るものです。クォートされた文字列（quoted string）のトークンとしての値
は、いちばん外側にある引用符を一対だけ取った文字列です。したがって、

     `'

の値は空文字列です。そして、

     ``quoted''

の値は次の文字列になります。

     `quoted'

引用符を表す文字は、組み込みマクロ`changequote'を使って、いつでも替え
ることができます。詳細は*Note Changequote::を参照してください。



File: m4-ja.info, Node: Other tokens, Next: Comments, Prev: Quoted strings, Up: Syntax

入力トークン: その他
====================

名前（name）とクォートされた文字列（quoted string）の構成要素にならな
い文字はすべて、それ自身で一つのトークンとなります。



File: m4-ja.info, Node: Comments, Prev: Other tokens, Up: Syntax

コメント
========

`m4'では通常`#'と改行文字で区切られた部分がコメントとなります。これら
コメントデリミタ（comment delimiters）の間にあるすべての文字は処理の対
象とならず無視されます。しかし、コメントデリミタ（comment delimiters）
を含むコメント全体は、出力へそのまま流されて行きます。つまり`m4'におい
てコメントは破棄*されません*。

コメントを入れ子にすることはできません。したがって、`#'の後の最初の改
行文字でコメントは終りとなります。コメント開始文字をクォートすることに
よって、コメント開始文字としての働きを抑制できます。

コメントデリミタ（comment delimiters）は組み込みマクロ`changecom'を使っ
て、いつでも好きな文字列に変更できます。詳細は*Note Changecom::を参照
してください。




File: m4-ja.info, Node: Macros, Next: Definitions, Prev: Syntax, Up: Top

マクロを呼び出す方法
********************

この章ではマクロの呼び出し、マクロの引数、マクロの展開が行われる過程に
ついて説明します。

* Menu:

* Invocation::                  マクロの呼び出し
* Inhibiting Invocation::       マクロの呼び出しを抑制する
* Macro Arguments::             マクロの引数
* Quoting Arguments::           マクロの引数をクォートする
* Macro expansion::             マクロの展開



File: m4-ja.info, Node: Invocation, Next: Inhibiting Invocation, Prev: Macros, Up: Macros

マクロの呼び出し
================

マクロを呼び出すときの形式には次のものがあります。

     name

これは引数を伴わないマクロの呼び出しです。

     name(arg1, arg2, ..., argN)

これはN個の引数を伴うマクロの呼び出しです。マクロはいくつでも引数を取
ることができます。すべての引数は文字列ですが、マクロによって引数の解釈
のしかたが違うことがあります。

開きカッコ`('は、スペースを入れずにNAMEの*直後に*書かなければいけませ
ん。そうしないと、そのマクロは引数なしで呼び出されてしまいます。

引数なしでマクロを呼び出すためには、カッコを付けては*いけません*。たと
えば、

     name()

これは、空の文字列を1つだけ引数として持つマクロの呼び出しであり、引数
を伴わないマクロの呼び出しではありません。



File: m4-ja.info, Node: Inhibiting Invocation, Next: Macro Arguments, Prev: Invocation, Up: Macros

マクロの呼び出しを抑制する
==========================

先行するマクロプロセッサ(Stratcheyの`GPM'など)に比べて、`m4'言語の革新
的なところは、先頭に特別な文字をつけて書くといったことをしなくても、マ
クロの呼び出しを識別できる能力です。この機能は多くの場合において便利な
のですが、ときには不必要なマクロの呼び出しの原因となることがあります。
そこで、GNU `m4'には名前（name）がマクロの呼び出しとして認識されるのを
抑制するいくつかの機構やテクニックがあります。

まず、多くの組み込みマクロは引数なしで呼び出しても意味がないので、それ
らの名前の直後に開きカッコがないときは、組み込みマクロは呼び出されませ
ん。これによって、`include'や`eval'がマクロとして認識されてしまうといっ
たよくあるケースに対処できます。後ほど、この文書に出てくる"このマクロ
は引数が与えられたときだけ認識されます"という文は、この動作を意味しま
す。

また、コマンドオプション(`--prefix-builtins', または`-P') を使うと、組
み込みマクロを呼び出すときは、その名前の先頭に`m4_'をつけなければ認識
されなくなります。たとえば`m4_dnl'や、さらには`m4_m4exit'と書かなけれ
ばならなくなります。ちなみに、このオプションはユーザ定義のマクロには何
の効果ももちません。

`changeword'機能がコンパイル時に組み込まれた`m4'を使用しているときは、
マクロ名の認識に使われる字句構成規則をはるかに柔軟に指定することができ
ます。この規則は組み込みマクロとユーザ定義マクロ両方の名前に作用します。
この試験的な機能の詳細は*Note Changeword::を参照してください。

もちろん、ある名前がマクロの呼び出しとして認識されるのを防ぐ、もっとも
単純な方法は、その名前をクォートする(引用符で囲む)ことです。この節の残
り部分では、クォートすることがマクロの呼び出しにどのように影響するのか、
またマクロの呼び出しを抑制するにはそれをどのように使えよいのかを、もう
すこし詳しく見ていきます。

マクロの呼び出しを抑制したいときは名前全体をクォートするのが普通ですが、
名前の数文字をクォートするだけでも同じ効果があります。また、空文字列を
クォートするだけでもよいのですが、この場合は名前の*内部*でないと効果は
ありません。たとえば、

     `divert'
     `d'ivert
     di`ver't
     div`'ert

これらの結果はすべて文字列`divert'となりますが、

     `'divert
     divert`'

こちらは両方とも組み込みマクロ`divert'が呼ばれます。

マクロを評価して生じた出力は常に再走査(rescan)されます。
次の例では、`m4'に`substr(abcde, 3, 2)'を入力として
与えたときと同様に、文字列`de'が生成されます。

     define(`x', `substr(ab')
     define(`y', `cde, 3, 2)')
     x`'y

クォートされた文字列（quoted string）の両端にあるクォートされていない
文字列は、マクロ名として認識される対象となります。次の例では、空文字列
をクォートすることによって`dnl'マクロが認識されるようになります。

     define(`macro', `di$1')
     macro(v)`'dnl

もし引用符がなかったら、文字列`divdnl'とそれに続く改行文字が生成される
だけでしょう。

クォートすることで、マクロ展開による文字列とその周囲の文字を連結したも
のがマクロの名前として認識されるのを防ぐことができます。たとえば、

     define(`macro', `di$1')
     macro(v)`ert'

この入力からは、文字列`divert'が生み出されます。もし引用符がなければ、
組み込みマクロ`divert'が呼びだされるでしょう。



File: m4-ja.info, Node: Macro Arguments, Next: Quoting Arguments, Prev: Inhibiting Invocation, Up: Macros

マクロの引数
============

ある名前（name）が認識され、その名前に対するマクロの定義が存在するとき、
それはマクロとして展開されます。

その名前の直後に開きカッコ`('があるときは、引数をすべて集めてから、マ
クロが呼び出されます。足りない引数があるときは、空文字列が与えられたも
のとして解釈されます。余分な引数は無視されます。

組み込みマクロの呼び出しで引数の数が不足しているとき、通常なら`m4'は警
告を発しますが、コマンドライン・オプション`-Q'を使えば、この警告を抑制
できます。ユーザ定義マクロに対する引数の個数チェックはありません。

引数の収集が行われているときでも、通常と同じようにマクロの展開は行われ
ます。そして展開後のテキストに出現した、コンマ、引用符、カッコなどはす
べて個々の引数の定義に寄与します。したがってFOOが`, b, c'に展開される
とき、次のマクロの呼び出し、

     bar(a foo, d)

は、4つの引数、`a ', `b', `c', `d' を伴うマクロの呼び出しとなります。
なぜ最初の引数に空白（whitespace）が含まれているのか理解するには、引数
の前にある空白はすべて削除されるのに対して、引数の後ろにある空白は削除
されないことを覚えておくとよいでしょう。



File: m4-ja.info, Node: Quoting Arguments, Next: Macro expansion, Prev: Macro Arguments, Up: Macros

マクロの引数をクォートする
==========================

個々の引数の前にある、クォートされていない空白（whitespace）は削除され
ます。各引数の内部では、クォートされていないカッコはすべて対になってい
なければなりません。たとえば、FOOがマクロのとき、

     foo(() (`(') `(')

これはひとつの引数を伴ったマクロの呼び出しで、
その引数の値は`() (() ('です。

引数自体がマクロ展開の対象になって欲しいのでない限り、マクロへの引数は
すべてクォートするのが普通です。したがって、上記のカッコを含む例の`正
しい'書き方は次のようになります。

     foo(`() (() (')

しかし、ときにはいくつかの引数をクォートしないでおく必要がある場合もあ
り、また、そうすることに何ら問題はありません。ただ、注意を怠ると人生が
すこしばかり厳しいものになるだけです。



File: m4-ja.info, Node: Macro expansion, Prev: Quoting Arguments, Up: Macros

マクロの展開
============

マクロの呼び出しが引数を伴うときはその収集が行われたあと、マクロは展開
されます。そして展開後のテキストは入力に(クォートされずに)戻され、そし
て再び読み込まれます(再走査)。したがって、マクロを1つ呼び出したことで
得られたテキストの中に、完全なマクロの呼び出しやその一部が含まれている
場合、そこから更に多くのマクロが呼ばれることもあるわけです。

非常に簡単な例を挙げると、FOOが`bar'へ展開され、BARが`Hello world'へ展
開されるとすると、入力

     foo

は最初に`bar'へ展開された後、再び走査が行われ`Hello world'へ展開されま
す。



File: m4-ja.info, Node: Definitions, Next: Conditionals, Prev: Macros, Up: Top

新たにマクロを定義する方法
**************************

マクロはいくつかの異なる方法で定義、再定義、削除することができます。ま
た現在の定義を失うことなく一時的にマクロを再定義しておいて、後で元の定
義に戻すこともできます。

* Menu:

* Define::                      新しいマクロを定義する
* Arguments::                   マクロの引数
* Pseudo Arguments::            マクロの疑似引数
* Undefine::                    マクロの削除
* Defn::                        マクロ名の変更
* Pushdef::                     マクロの一時的な再定義

* Indir::                       マクロの間接的な呼び出し
* Builtin::                     組み込みマクロの間接的な呼び出し



File: m4-ja.info, Node: Define, Next: Arguments, Prev: Definitions, Up: Definitions

マクロの定義方法
================

通常はマクロを定義したり再定義するときは、組み込みマクロ`define'を使い
ます。

     define(NAME [, EXPANSION])

これはNAMEがEXPANSIONに展開されるように定義します。もしEXPANSIONが与え
られなかったときは、空文字列だと見なされます。

`define'は展開されると消滅します。

次の例では、マクロFOOが`Hello World.'に展開されるように定義しています。

     define(`foo', `Hello world.')
     =>
     foo
     =>Hello world.

出力に空行がある理由は、マクロ定義の直後にある改行文字が定義の一部では
なく、従って出力にそのままコピーされるためです。これは`dnl'マクロを使
うことで避けることができます。詳しくは*Note Dnl::を参照してください。

マクロ`define'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Arguments, Next: Pseudo Arguments, Prev: Define, Up: Definitions

マクロの引数
============

マクロは引数を取ることができます。N番目の引数は`$n'として展開用テキス
トの中で示し、マクロが展開されるときにN番目の実引数（actual argument）
に置き換えられます。次の例は2つの引数を取るマクロです。2つの引数の順番
を単純に交換します。

     define(`exch', `$2, $1')
     =>
     exch(arg1, arg2)
     =>arg2, arg1

これは`define'への引数の順番を逆にしたいときなどに使えます。

     define(`exch', `$2, $1')
     =>
     define(exch("expansion text", "macro"))
     =>
     macro
     =>expansion text

二重になった引用符の説明については*Note Quoting Arguments::を参照して
ください。

GNU `m4'では`$'に続く数字は複数の桁でもよいので、マクロはいくつでも引
数を取ることができます。これと違いUNIXの`m4'では1桁の数字しか認識され
ません。

特殊なケースとして、0番目の引数`$0'は常に現在展開されているマクロの名
前となります。

     define(`test', "Macro name: $0")
     =>
     test
     =>Macro name: test

クォートされたテキストを展開後のテキストに含めたい時は、クォートは入れ
子にできることを思い出しましょう。したがって、

     define(`foo', `This is macro `foo'.')
     =>
     foo
     =>This is macro foo.

展開されたテキストに含まれる`foo'は、クォートされた文字列（quoted
string）であり名前（name）ではないので、再走査によって展開は*されず*、
引用符がはぎ取られるだけです(*Note Syntax::)。



File: m4-ja.info, Node: Pseudo Arguments, Next: Undefine, Prev: Arguments, Up: Definitions

マクロの特殊な引数
==================

与えられた実引数（actual arguments）の個数や全ての実引数をまとめて表す
ための特別な表記方法があります。

マクロを呼び出すときに与えられた実引数の個数は、展開用テキストの中で
`$#'として表します。したがって与えられた実引数の個数を表示するマクロは
次のようになります。

     define(`nargs', `$#')
     =>
     nargs
     =>0
     nargs()
     =>1
     nargs(arg1, arg2, arg3)
     =>3

展開用テキストの中で`$*'という表記をすることで、全ての実引数を(クォー
トはせずに)コンマで区切ったものを表すことができます。

     define(`echo', `$*')
     =>
     echo(arg1,    arg2, arg3 , arg4)
     =>arg1,arg2,arg3 ,arg4

引数をそれぞれクォートしなければならないことがよくありますが、そんなと
きは`$@'という表記を使います。これは各引数がクォートされることを除けば
`$*'と同じです。

     define(`echo', `$@')
     =>
     echo(arg1,    arg2, arg3 , arg4)
     =>arg1,arg2,arg3 ,arg4

引用符はどこに行ったのでしょうか? もちろん展開後のテキストを再走査した
ときに`m4'が食べてしまったのです。違いを見るために、次のようにしてみま
しょう。

     define(`echo1', `$*')
     =>
     define(`echo2', `$@')
     =>
     define(`foo', `This is macro `foo'.')
     =>
     echo1(foo)
     =>This is macro This is macro foo..
     echo2(foo)
     =>This is macro foo.

これが理解できないときは*Note Trace::を参照してください。

展開用テキストに記号`$'が存在し、それに続く部分が`m4'に理解できるもの
でないときは、`$'は他のテキストと同じようにマクロ展開後のテキストへ単
にコピーされます。

     define(`foo', `$$$ hello $$$')
     =>
     foo
     =>$$$ hello $$$

マクロを`$12'などに展開させたいときは、`$'の後に一組の引用符を置きます。
これによって、`m4'がその`$'記号を引数への参照だと解釈してまうのを防ぐ
ことができます。



File: m4-ja.info, Node: Undefine, Next: Defn, Prev: Pseudo Arguments, Up: Definitions

マクロの削除
============

`undefine'を使えばマクロの定義を削除することができます。

     undefine(NAME)

これによってマクロNAMEが削除されます。展開されてしまうのを防ぐためにマ
クロの名前は必ずクォートしなくてはなりません。

`undefine'は展開されると消滅します。

     foo
     =>foo
     define(`foo', `expansion text')
     =>
     foo
     =>expansion text
     undefine(`foo')
     =>
     foo
     =>foo

NAMEがマクロとして定義されていなくても問題はありません。その場合は
`undefine'が何もしないだけです。

`undefine'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Defn, Next: Pushdef, Prev: Undefine, Up: Definitions

マクロ名の変更
==============

すでに定義済みのマクロの名前を替えることができます。それには組み込みマ
クロ`defn'が必要となります。

     defn(NAME)

これはNAMEの*定義をクォートしたもの*に展開されます。引数が定義済みのマ
クロでないときは展開されると消滅します。

NAMEがユーザ定義マクロの場合、クォートされた定義とは単にクォートされた
展開用テキストのことです。NAMEが組み込みマクロの場合、展開後のテキスト
は、`m4'の内部にある組み込みマクロの定義を指す特殊なトークンとなります。
このトークンは、`define' (および `pushdef') の第2引数としてのみ意味を
持ち、その他の文脈では無視されます。

通常の使用方法は、次の例で`undefine'の名前を`zap'に換える方法を見るの
が一番分かりやすいでしょう。

     define(`zap', defn(`undefine'))
     =>
     zap(`undefine')
     =>
     undefine(`zap')
     =>undefine(zap)

このように`defn'はユーザ定義マクロの定義や組み込みマクロの定義をコピー
するために使うことができます。たとえ元のマクロが削除されても、もう一方
の名前を使って定義にアクセスすることができます。

`defn'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Pushdef, Next: Indir, Prev: Defn, Up: Definitions

マクロの一時的な再定義
======================

あるマクロを一時的に再定義しておき、後で元の定義に戻すことができます。
それには`define'と`undefine'に良く似た、組み込みマクロ`pushdef'と
`popdef'を使います。

     pushdef(NAME [, EXPANSION])
     popdef(NAME)

これらのマクロはスタック（stack）に似た仕組みで機能します。`pushdef'は、
あるマクロを一時的に再定義します。このときNAMEの前の定義は、新しい定義
によって置き換えられる前に保存されます。もし前の定義が存在しない場合は、
`pushdef'は`define'とまったく同じように機能します。

あるマクロに複数の定義が存在する場合(その中の一つだけがアクセス可能で
す)、`popdef'を使って一番上の定義を削除することができます。前の定義が
無い場合、`popdef'は`undefine'のように機能します。

     define(`foo', `Expansion one.')
     =>
     foo
     =>Expansion one.
     pushdef(`foo', `Expansion two.')
     =>
     foo
     =>Expansion two.
     popdef(`foo')
     =>
     foo
     =>Expansion one.
     popdef(`foo')
     =>
     foo
     =>foo

`define'によって、複数の定義を持つマクロを再定義したときは、一番上の定
義が新しい定義で*置き換え*られます。`undefine'によって定義を削除すると
きは、一番上のもの一つだけではなく、*すべて*の定義が削除されます。

     define(`foo', `Expansion one.')
     =>
     foo
     =>Expansion one.
     pushdef(`foo', `Expansion two.')
     =>
     foo
     =>Expansion two.
     define(`foo', `Second expansion two.')
     =>
     foo
     =>Second expansion two.
     undefine(`foo')
     =>
     foo
     =>foo

`pushdef'と`defn'を使えば、組み込みマクロを一時的に再定義することがで
きます。

マクロ`pushdef'と`popdef'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Indir, Next: Builtin, Prev: Pushdef, Up: Definitions

マクロの間接的な呼び出し
========================

`indir'を使うと、どんなマクロでも間接的に呼び出すことができます。

     indir(NAME, ...)

`indir'はマクロNAMEを残りの引数と共に呼び出します。これを"不正な"名前
を持つマクロを呼ぶのに使うことができます(`define' はそういう名前でも定
義できます。)

     define(`$$internal$macro', `Internal macro (name `$0')')
     =>
     $$internal$macro
     =>$$internal$macro
     indir(`$$internal$macro')
     =>Internal macro (name $$internal$macro)

ここでの要点は、大きなマクロ・パッケージで、間違って呼ばれてしまうこと
のないマクロを定義できるということです。それらは組み込みマクロ`indir'
によって*だけ*呼びだすことができます。




File: m4-ja.info, Node: Builtin, Prev: Indir, Up: Definitions

組み込みマクロの間接的な呼び出し
================================

`builtin'を使えば、組み込みマクロを間接的に呼び出すことができます。

     builtin(NAME, ...)

これは組み込みマクロNAMEを、残りの引数と共に呼び出します。たとえNAMEに
本来の定義を隠している別の定義が与えられていても、本来の定義を呼び出し
ます。

マクロ`builtin'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Conditionals, Next: Debugging, Prev: Definitions, Up: Top

条件分岐、ループ、再帰
**********************

単純なテキストに展開されるようなマクロだけでは、引数を取ることができる
としても、十分ではありません。実行時に下される判断にもとづいて、異なる
展開がおこなわれるようなマクロが必要でしょう。たとえば、何らかの条件構
文が必要です。また、ある処理を何回も繰り返したり、条件が真の間だけ繰り
返したりするために、ある種のループ構文も必要でしょう。

* Menu:

* Ifdef::                       マクロが定義済みかを判定する
* Ifelse::                      If-else 構文と多重分岐
* Loops::                       m4におけるループと再帰



File: m4-ja.info, Node: Ifdef, Next: Ifelse, Prev: Conditionals, Up: Conditionals

マクロが定義済みかを判定する
============================

`m4'には2つの異なる条件構文が組み込まれています。その1つは`ifdef'です。

     ifdef(NAME, STRING-1, opt STRING-2)

これにより、あるマクロが定義されているかどうかをテストできるようになり
ます。NAMEがマクロとして定義されていれば`ifdef'はSTRING-1に展開され、
そうでないときはSTRING-2に展開されます。STRING-2が省略されたときは(通
常の規則に従い)空文字列として解釈されます。

     ifdef(`foo', "foo' is defined', "foo' is not defined')
     =>foo is not defined
     define(`foo', `')
     =>
     ifdef(`foo', "foo' is defined', "foo' is not defined')
     =>foo is defined

マクロ`ifdef'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Ifelse, Next: Loops, Prev: Ifdef, Up: Conditionals

文字列の比較
============

もう一方の条件構文`ifelse'はずっとパワフルです。与える引数の個数によっ
て長いコメントの挿入のためや、if-else構文、多重分岐などとして使うこと
ができます。

     ifelse(COMMENT)
     ifelse(STRING-1, STRING-2, EQUAL, opt NOT-EQUAL)
     ifelse(STRING-1, STRING-2, EQUAL, ...)

`ifelse'に1つだけ引数を与えた場合、それは単に捨てられて、何も出力され
ません。これは`dnl'を何度も使わずにブロック・コメントを挿入するために
良く使われる、`m4'におけるイディオムです。GNU `m4'ではこの特殊な使用法
が認められているので、引数が足りないことに対する警告はこのケースでは発
せられません。

`ifelse'に3つ、または4つの引数を与えて呼び出すと、STRING-1とSTRING-2が
(文字毎に比べて)等しければEQUALに展開されます。等しくなければNOT-EQUAL
に展開されます。

     ifelse(foo, bar, `true')
     =>
     ifelse(foo, foo, `true')
     =>true
     ifelse(foo, bar, `true', `false')
     =>false
     ifelse(foo, foo, `true', `false')
     =>true

また`ifelse'には4つ以上の引数を与えることができます。この場合、
`ifelse'は伝統的なプログラミング言語における`case'文や`switch'文と同じ
ように機能します。STRING-1とSTRING-2が等しければ`ifelse'はEQUALに展開
され、等しくなければ最初の3つの引数が捨てられたあと、まったくおなじ手
続きが繰り返されます。例で示したほうがいいでしょう。

     ifelse(foo, bar, `third', gnu, gnats, `sixth', `seventh')
     =>seventh

もちろん、通常はこれらの例よりもうすこし高度な使い方をするでしょう。
`ifelse'のよくある使い方のひとつは、さまざまな種類のループ処理を実装す
るマクロの中で使用する場合です。

マクロ`ifelse'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Loops, Prev: Ifelse, Up: Conditionals

ループと再帰
============

`m4'ではループ処理が直接的にはサポートされていませんが、再帰的なマクロ
を定義することはできます。使用しているハードウェアとオペレーティング・
システムによるもの以外、再帰の深さに制限はありません。

ループ処理は再帰とすでに説明した条件構文を使うことで実現できます。

マクロの実引数を反復処理するときには組み込みマクロ`shift'を使うことが
できます。


     shift(...)

このマクロは任意の個数の引数を受け取り、最初の引数を除く残りの引数をそ
れぞれクォートしてから、それらをコンマで区切ったものに展開します。

     shift(bar)
     =>
     shift(foo, bar, baz)
     =>bar,baz

`shift'を使った次の例では引数の順番を逆にするマクロを定義しています。

     define(`reverse', `ifelse($#, 0, , $#, 1, "$1",
     			  `reverse(shift($@)), `$1")')
     =>
     reverse
     =>
     reverse(foo)
     =>foo
     reverse(foo, bar, gnats, and gnus)
     =>and gnus, gnats, bar, foo

それほど興味深いマクロではありませんが、`shift'と`ifelse'そして再帰を
使えばループ処理をどんなに簡単に実現できるか示しています。

次に挙げるのは、単純なforループを実現するマクロの例です。単純な数え上
げのためなどに使えます。

     forloop(`i', 1, 8, `i ')
     =>1 2 3 4 5 6 7 8

それぞれの引数は順に、反復変数（iteration variable）の名前、開始値、終
了値、そして反復するたびに展開されるテキストです。このマクロにおいて、
マクロ`i'はループ処理の内部でだけ定義されています。`i'が以前に値を持っ
ていた場合は、ループが終ればまたその値にもどります。

`forloop'は次のように入れ子にすることもできます。

     forloop(`i', 1, 4, `forloop(`j', 1, 8, `(i, j) ')
     ')
     =>(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8)
     =>(2, 1) (2, 2) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 8)
     =>(3, 1) (3, 2) (3, 3) (3, 4) (3, 5) (3, 6) (3, 7) (3, 8)
     =>(4, 1) (4, 2) (4, 3) (4, 4) (4, 5) (4, 6) (4, 7) (4, 8)
     =>

`forloop'マクロはとても簡潔に実装することができます。`forloop'マクロ自
体は単なるラッパー(wrapper)で、第1引数が持つ元の定義を保存してから、内
部マクロ`_forloop'を呼び、再び保存しておいた第1引数の定義を再確立しま
す。

マクロ`_forloop'は第4引数を一度展開し、これで反復が終りかどうか調べま
す。もし終りでなければ、反復変数を(すでに定義済みのマクロ`incr'を使っ
て) 1増やしてから、自分自身を再帰的に呼び出します。

`forloop'の実際の実装は次のようになります:

     define(`forloop',
            `pushdef(`$1', `$2')_forloop(`$1', `$2', `$3', `$4')popdef(`$1')')
     define(`_forloop',
            `$4`'ifelse($1, `$3', ,
     		   `define(`$1', incr($1))_forloop(`$1', `$2', `$3', `$4')')')

注意深い引用符の使い方に注目してください。マクロの引数でクォートされて
いないのは3つだけで、それぞれに固有の理由があります。これら3つの引数が
クォートされていないのはなぜか、その*理由*を見つけてください、これらが
クォートされていると、どうなるのかも確かめてみてください。


これら2つのマクロは便利ではありますが、一般の使用に耐えるほど堅牢では
ありません。開始値が終了値より小さい場合や、第1引数が名前でなかった場
合など、初歩的なエラー対策さえ欠いています。これら不備の訂正は、読者へ
の課題として残しておきます。



File: m4-ja.info, Node: Debugging, Next: Input Control, Prev: Conditionals, Up: Top

マクロや入力をデバッグする方法
******************************

`m4'のマクロを書いていると、(たいていのプログラミング言語の場合と同様
に) 往々にしてそれらは思ったようには動いてくれないものです。`m4'にはデ
バッグをサポートするしくみがいくつか存在します。

* Menu:

* Dumpdef::                     マクロの定義を表示する
* Trace::                       マクロの呼び出しをトレースする
* Debug Levels::                デバッグ出力の制御
* Debug Output::                デバッグ出力の保存



File: m4-ja.info, Node: Dumpdef, Next: Trace, Prev: Debugging, Up: Debugging

マクロの定義を表示する
======================

ある名前（name）が展開されるとどうなるのか調べたいときは、組み込みマク
ロ`dumpdef'を使用することができます。

     dumpdef(...)

このマクロは任意の個数の引数を取ります。引数を与ずに呼びだすと、既知の
名前すべての定義を表示します。それ以外の場合は与えた引数の定義を表示し
ます。出力は標準エラー出力に直接行われます。

`dumpdef'は展開されると消滅します。

     define(`foo', `Hello world.')
     =>
     dumpdef(`foo')
     error-->foo:	`Hello world.'
     =>
     dumpdef(`define')
     error-->define:	<define>
     =>

最後の例は組み込みマクロの定義が表示される様子です。

表示の詳細を調整するための情報については*Note Debug Levels::を参照して
ください。



File: m4-ja.info, Node: Trace, Next: Debug Levels, Prev: Dumpdef, Up: Debugging

マクロの呼び出しをトレースする
==============================

組み込みマクロ`traceon'と`traceoff'を使うと、マクロの呼び出しと展開を
トレース（trace）することができます。

     traceon(...)
     traceoff(...)

`traceon'と`traceoff'を引数なしで呼ぶと、すべての定義済みのマクロに対
してトレースがそれぞれオンまたはオフとなります。引数を指定した場合、そ
の名前のマクロに対してだけ作用します。

`traceon'と`traceoff'は展開されると消滅します。

トレース中のマクロが呼ばれるたびに、そのマクロの呼び出しに関する情報が
引数の収集が終ったあとに表示されます。マクロの呼び出しが展開後に消滅し
ないときは展開の結果が表示されます。出力は標準エラー出力へ直接行われま
す。

     define(`foo', `Hello World.')
     =>
     define(`echo', `$@')
     =>
     traceon(`foo', `echo')
     =>
     foo
     error-->m4trace: -1- foo -> `Hello World.'
     =>Hello World.
     echo(gnus, and gnats)
     error-->m4trace: -1- echo(`gnus', `and gnats') -> "gnus',`and gnats"
     =>gnus,and gnats

ダッシュ(-)の間にある数字は展開の深さを表します。たいていは最も外側の
レベルでの展開を表す1となりますが、クォートされていないマクロの呼び出
しを引数が含む場合には増えていきます。

表示の詳細を調整するための情報については*Note Debug Levels::を参照して
ください。



File: m4-ja.info, Node: Debug Levels, Next: Debug Output, Prev: Trace, Up: Debugging

デバッグ出力の制御
==================

`m4'に`-d'オプションを与えることにより、これまでの節に記載されているマ
クロを使ったときに表示される情報の詳しさを制御します。

このオプションに続けて次のうち1つまたは複数のフラグを指定します。

`t'
     今回起動する`m4'におけるマクロの呼び出しを全てトレースします。

`a'
     マクロの呼び出しに伴う実引数を表示します。`t'フラグと共に指定した
     ときは全てのマクロの呼び出しが対象となりますが、それ以外の場合は
     `traceon'マクロによってトレースしているマクロだけが対象となります。

`e'
     マクロの呼び出しが展開後に消滅しない場合、展開後のテキストを表示
     します。`t'フラグと共に指定したときは全てのマクロの呼び出しが対象
     となりますが、それ以外の場合は`traceon'マクロによってトレースして
     いるマクロだけが対象となります。

`q'
     実引数やマクロの展開後のテキストを表示するときに現在の引用符でクォー
     トします。

`c'
     ひとつのマクロの呼び出しにつき複数のトレース行を表示します。マク
     ロが認識された時点で引数を集める前に1行表示し、引数を集め終った後
     に2行目を、マクロの呼び出しが完了したあとに3行目を表示します。

`x'
     トレースの各出力行にマクロの呼び出し毎に異なる`識別番号(id)'を加
     えます。これは上記の`c'フラグを使うときに便利です。

`f'
     トレースの各出力行に、現在の入力ファイルの名前を表示します。

`l'
     トレースの各出力行に、現在の入力行番号を表示します。

`p'
     指定した名前のファイルをパス・サーチ機構(*Note Search Path::)を使っ
     て見つけたときは、実際に使われるファイル名を表示します。

`i'
     現在の入力ファイルが替わるたびに、ファイル名と入力行番号を表示し
     ます。

`V'
     上記すべてのフラグを表す簡略表記です。

`-d'オプションに何もフラグを指定しない場合、デフォルトで`aeq'が使われ
ます。前2つの節にある例は、これらデフォルトのフラグを使うことを想定し
ています。

組み込みマクロ`debugmode'を使うと、実行時にデバッグ出力のフォーマット
を制御できます。

     debugmode(opt FLAGS)

引数FLAGSは上に列挙されている文字をいくつか指定します。特殊なケースと
して引数を`+'で始めると、それらのフラグが現在のデバッグ・フラグ群に追
加されます。また引数を`-'で始めると現在のデバッグ・フラグ群から削除さ
れます。引数をまったく与えない場合、デバッグ・フラグは(`-d'を与えない
場合と同様に) すべてゼロに設定されます。引数として空文字列を与えるとフ
ラグはデフォルトの値にリセットされます。



File: m4-ja.info, Node: Debug Output, Prev: Debug Levels, Up: Debugging

デバッグ出力の保存
==================

デバッグとトレースの出力は、`m4'に`-o'オプションを与えるか組み込みマク
ロ`debugfile'を使うことで、ファイルにリダイレクト（redirect）すること
ができます。

     debugfile(opt FILENAME)

このマクロにより、ここから後に発生するデバッグとトレースの出力はすべて
FILENAMEへ送られます。FILENAMEが空文字列のときはデバッグとトレースの出
力は捨てられます。`debugfile'が引数無しで呼ばれたときは、デバッグとト
レースの出力は標準エラー出力へ送られます。



File: m4-ja.info, Node: Input Control, Next: File Inclusion, Prev: Debugging, Up: Top

入力制御
********

この章では`m4'への入力を制御するための、さまざまな組み込みマクロを説明
します。

* Menu:

* Dnl::                         入力中の空白（whitespace）を削除する
* Changequote::                 引用符（quote characters）を変更する
* Changecom::                   コメントデリミタ（comment delimiters）を変更する
* Changeword::                  単語（word）の字句構造を変更する
* M4wrap::                      入力の一部を入力が終るまで保存（save）しておく



File: m4-ja.info, Node: Dnl, Next: Changequote, Prev: Input Control, Up: Input Control

入力中の空白（whitespace）を削除する
====================================

組み込みマクロ`dnl'は最初の改行文字までにある文字をすべて読み込んでか
ら改行文字も含めてそれらを捨てます。

     dnl

次の例のように`define'の呼び出しの後に続く改行を取り除くために、
`define'と一緒によく使います。

     define(`foo', `Macro `foo'.')dnl A very simple macro, indeed.
     foo
     =>Macro foo.

コメントの扱かわれ方とは対照的に(*Note Comments::)、次の改行までの入力
が改行を含めて捨てられます。


通常`dnl'の後ろには、行末もしくはその他の空白（whitespace）が続きます。
GNU `m4'は`dnl'に続いて開きカッコがあるとき、それを警告する診断メッセー
ジを出します。この場合`dnl'は閉じカッコを探しながら、すべての引数を集
め処理します。この引数の収集が原因となる予想可能な副作用はすべて起こり
ます。このとき`dnl'は何も出力しません。閉じカッコのあとに続く次の改行
までの入力は、それがどの行にあっても、改行を含めてやはり捨てられます。



File: m4-ja.info, Node: Changequote, Next: Changecom, Prev: Dnl, Up: Input Control

引用符（quote characters）を変更する
====================================

デフォルトの引用符は組み込みマクロ`changequote'によって変更できます。

     changequote(opt START, opt END)

STARTは新しい開始引用符でENDは新しい終了引用符です。もし欠けている引数
があるときは、デフォルトの引用符(``' と `'') がその欠けている引数の代
わりに使用されます。

`changequote'は展開されると消滅します。

     changequote([, ])
     =>
     define([foo], [Macro [foo].])
     =>
     foo
     =>Macro foo.

適切な文字がないときはSTARTやENDを好きな長さにしてかまいません。

     changequote([[, ]])
     =>
     define([[foo]], [[Macro [[[foo]]].]])
     =>
     foo
     =>Macro [foo].

引用符を両方とも空文字列にすると、事実上クォート機構が無効になり、テキ
ストをクォートする方法が無くなります。

     define(`foo', `Macro `FOO'.')
     =>
     changequote(, )
     =>
     foo
     =>Macro `FOO'.
     `foo'
     =>`Macro `FOO'.'

`changequote'を使って現在の引用符を替えない限り、終了引用符と対になっ
ていない開始引用符を含む文字列をクォートする方法は`m4'には存在しません。

入力に含まれる名前と混同されてしまうので、どちらの引用符も記号でない普
通の文字や`_' (アンダースコア)で始めるべきではありません。そうした場合
はクォート機構が無効になります。



File: m4-ja.info, Node: Changecom, Next: Changeword, Prev: Changequote, Up: Input Control

コメントデリミタ（comment delimiters）を変更する
================================================

デフォルトのコメントデリミタ（comment delimiters）は組み込みマクロ
`changecom'で変更できます。

     changecom(opt START, opt END)

STARTが新しいコメント開始デリミタ（start-comment delimiter）で、ENDが
新しいコメント終了デリミタ（end-comment delimiter）です。欠けている引
数があるときは、デフォルトのコメント区切り記号(`#' と 改行文字)がその
欠けている引数の代わりに使用されます。コメント区切り記号は任意の長さに
することができます。

`changecom'は展開されると消滅します。

     define(`comment', `COMMENT')
     =>
     # A normal comment
     =># A normal comment
     changecom(`/*', `*/')
     =>
     # Not a comment anymore
     =># Not a COMMENT anymore
     But: /* this is a comment now */ while this is not a comment
     =>But: /* this is a comment now */ while this is not a COMMENT

クォートされた文字列であるかのようにコメントが出力にコピーされている様
子に注目しましょう。コメント内部のテキストが展開されるようにしたいとき
は、コメント開始デリミタをクォートしてください。

引数なしで`changecom'を呼ぶとコメント機構が完全に無効になります。

     define(`comment', `COMMENT')
     =>
     changecom
     =>
     # Not a comment anymore
     =># Not a COMMENT anymore



File: m4-ja.info, Node: Changeword, Next: M4wrap, Prev: Changecom, Up: Input Control

単語（word）の字句構造を変更する
================================

     マクロ`changeword'とそれに関連する機能すべてが実験段階にあります。
     GNU `m4'をインストールする際`configure'に`--enable-changeword'オ
     プションを与えたときだけこの機能を使用することができます。これか
     ら先、この機能が変更されたり、削除されてしまうことさえありえます。
     したがって、*この機能に依存した使い方はしないで下さい*。この機能
     について意見を寄せていただくときはバグを報告するときと同じ方法で
     行ってください。

`m4'によって処理されるファイルは、クォートされた文字列、単語(潜在的な
マクロ名)、そして単純なトークン(その他の単一の文字すべて) に分割されま
す。初めに単語は次の正規表現によって定義されています。

     [_a-zA-Z][_a-zA-Z0-9]*

`changeword'を使えばこの正規表現を変更できます。たとえば数字が含まれて
いるファイルに置換をかけたい場合など、`m4'の字句構成規則を緩めると便利
なときもあるでしょう。

     changeword(`[_a-zA-Z0-9]+')
     define(1, 0)
     =>1

字句構成規則を厳しくすると組み込みマクロのうちいくつかが使えなくなって
しまうことが多いので、緩める場合ほど便利にはなりません。次の例のように、
間違って組み込みマクロを呼んでしまうのを避けるために使うことはできるで
しょう。

     define(`_indir', defn(`indir'))
     changeword(`_[_a-zA-Z0-9]*')
     esyscmd(foo)
     _indir(`esyscmd', `ls')

`m4'は単語を一度に一文字ずつ構築するので、`changeword'に渡すことができ
る正規表現には制限があります。これは、もし指定した正規表現が`foo'を受
理するなら`f'と`fo'も受理しなければならないというものです。

`changeword'には、もう一つ機能があります。指定した正規表現に角括弧でく
くられた部分が1つ以上存在する場合、最初の角括弧でくくられた部分の外側
にあるテキストが、シンボルを表引きする前に捨てられます。

     changecom(`/*', `*/')
     changeword(`#\([_a-zA-Z0-9]*\)')
     #esyscmd(ls)

こうすると、`m4'はすべてのマクロの呼び出しの先頭に`#'記号を必要とする
ようになるので、`m4'でシェル・スクリプトを処理するときに`shift'コマン
ドが`m4'に飲み込まれてしまわないようにできます。また種々の一般的な単語
を失うことなくプレーン・テキストを処理できるようになります。

`m4'のマクロ置換はテキストに基づいていますが、TeXのものはトークンに基
づいています。`changeword'によって、この違いを浮き彫りにすることができ
ます。たとえば次の例は同じアイデアをTeXと`m4'で表現したものです。初め
はTeX バージョンからです。

     \def\a{\message{Hello}}
     \catcode`\@=0
     \catcode`\\=12
     =>@a
     =>@bye

つぎに`m4'バージョンです。

     define(a, `errprint(`Hello')')
     changeword(`@\([_a-zA-Z0-9]*\)')
     =>@a

TeXの例において、最初の行はマクロ`a'が`Hello'メッセージを表示するよう
に定義しています。2行目は\の代わりに@をエスケープ文字として使えるよう
に定義しています。3行目は\をエスケープ文字ではなく通常の表示可能文字と
して定義しています。4行目はマクロ`a'を呼び出しています。したがって、こ
のファイルに対してTeXを走らせると`Hello'メッセージを表示します。

`m4'の例を`m4'に与えると`errprint(Hello)'を表示します。この理由はTeXは
マクロが*定義されたとき*にマクロ定義の字句解析を行うのに対し、`m4'は単
純にテキストを保存しておき、字句解析は実際にマクロが*使われる*まで後回
しにするからです。

`changeword'を使用すると、`m4'の速度が7倍ほど遅くなることに注意してく
ださい。



File: m4-ja.info, Node: M4wrap, Prev: Changeword, Up: Input Control

入力の保存（save）
==================

通常の入力が終りになるまで、テキストを`保存（save）'しておくことができ
ます。保存されたテキストは通常の入力が終った段階で`m4'に再び読み込まれ
ます。通常この機能は一時ファイルの削除など正常終了前に行うクリーンアッ
プ動作を開始するために使われます。

入力テキストを保存するためには組み込みマクロ`m4wrap'を使います。

     m4wrap(STRING, ...)

STRINGと残りの引数は入力が終端に達したときに再び読み込まれるように安全
な場所に保存されます。

     define(`cleanup', `This is the `cleanup' actions.
     ')
     =>
     m4wrap(`cleanup')
     =>
     This is the first and last normal input line.
     =>This is the first and last normal input line.
     ^D
     =>This is the cleanup actions.

保存されている入力は通常の入力が終端に達したときだけ再び読み込まれます。
`m4'を終了するために`m4exit'が使われたときは再読み込みは行われません。

保存されたテキストの中で`m4wrap'を呼びだしても差し支えありませんが、そ
のとき保存されたテキストが再読み込みされる順番は決まっていません。
`m4wrap'が再帰的に使われていない場合、保存された各テキストはそれぞれが
保存されたのと逆の順番(LIFO--last in, first out)で再読み込みが行われま
す。



File: m4-ja.info, Node: File Inclusion, Next: Diversions, Prev: Input Control, Up: Top

ファイルのインクルード
**********************


`m4'では入力のどこででも名前を指定してファイルをインクルード（include）
することができます。

* Menu:

* Include::                     名前を指定してファイルをインクルードする
* Search Path::                 インクルードするファイルのサーチ



File: m4-ja.info, Node: Include, Next: Search Path, Prev: File Inclusion, Up: File Inclusion

名前を指定してファイルをインクルードする
========================================

`m4'にはファイルをインクルードするための組み込みマクロが2つあります。

     include(FILENAME)
     sinclude(FILENAME)

どちらもFILENAMEという名前のファイルを`m4'に読み込ませます。そのファイ
ルの終りに達すると以前の入力ファイルから入力を再開します。

したがって`include'と`sinclude'は展開後にFILENAMEの内容となります。

`include'に指定したファイルが存在しないとエラーとなります。ファイルが
存在しない事についてのエラー・メッセージを避けたいときは`sinclude'を使
います。`sinclude'は、もしファイルが存在すればそのファイルをインクルー
ドし、存在しなければ消滅します。

     include(`no-such-file')
     =>
     error-->30.include:2: m4: Cannot open no-such-file: No such file or directory
     sinclude(`no-such-file')
     =>

これ以降ファイル`incl.m4'の内容は仮に以下のものだとします。
     Include file start
     foo
     Include file end

通常、ファイルのインクルードはファイルの内容を入力ストリームに挿入する
ために使用されます。インクルードされたファイルの内容は`m4'によって読ま
れ、そのファイルに含まれるマクロの呼び出しは展開されます。

     define(`foo', `FOO')
     =>
     include(`incl.m4')
     =>Include file start
     =>FOO
     =>Include file end
     =>

`include'と`sinclude'がファイルの内容に展開されることを利用して、ファ
イル全体に作用するマクロを定義することができます。次の例では`bar'が
`incl.m4'の内容に展開されるように定義しています。

     define(`bar', include(`incl.m4'))
     =>
     This is `bar':  >>>bar<<<
     =>This is bar:  >>>Include file start
     =>foo
     =>Include file end
     =><<<

もっとも、これは`include'のごく普通の使い方ではありません。なぜならファ
イルにはクォート、コンマ、括弧といった`m4'のパーサ（parser）が動作する
方法に干渉するものが含まれている可能性があるからです。

組み込みマクロ`include'と`sinclude'は引数が与えられたときだけ認識され
ます。



File: m4-ja.info, Node: Search Path, Prev: Include, Up: File Inclusion

インクルードするファイルのサーチ
================================

GNU `m4'ではインクルード対象のファイルが現在の作業ディレクトリ
（current working directory）とは別のディレクトリにあってもかまいませ
ん。

ファイルが現在の作業ディレクトリで見つからずファイル名が絶対ファイル名
（absolute file name）でないとき、GNU `m4'は指定されたサーチ・パス
（search path）を使ってそのファイルを探します。最初に`-I'オプションで
指定された各ディレクトリの中をコマンド・ラインに書かれている順番に探し
ます。次に環境変数`M4PATH'が設定されているときは、それをコロン(:)で区
切られたディレクトリのリストとして解釈し、それらの中を順に探します。

インクルード・ファイルの自動サーチがトラブルの原因となったときは、`p'
デバッグ・フラグ(*Note Debug Levels::)が問題の切り分けに役立つでしょう。



File: m4-ja.info, Node: Diversions, Next: Text handling, Prev: File Inclusion, Up: Top

出力の切替え（divert）と逆切替え（undivert）
********************************************

出力切替え（diversions）は出力を一時的に保存しておく方法です。`m4'では
好きなときに出力を一時ファイルへ切替え（divert）ておき、後で再び出力ス
トリームへと逆切替え（"undiverted"）することができます。

切り替え先番号は0から数え上げます。切替え先0は通常の出力ストリームです。
同時に存在できる切替え先の数は主としてそれらを記述するために使われるメ
モリによって制限されます。これはGNU `m4'が切替え先の情報とそこへの出力
をメモリに置いておこうとするためです。しかし全ての切替え先に必要なメモ
リの総量には制限があります(現在は512Kです)。この最大値を超えそうになっ
たときは、一番大きな切替え先の内容を入れるために一時ファイルが作られ、
その分のメモリが他の切替え先のために開放されます。したがって理論上は切
替え先の数が利用可能なファイル・ディスクリプタの数によって制限されるこ
とがありえます。


* Menu:

* Divert::                      出力を切替える（divert）
* Undivert::                    出力を逆切替え（undivert）する
* Divnum::                      出力切替え先番号（diversion number）
* Cleardiv::                    出力切替え先のテキストを破棄する



File: m4-ja.info, Node: Divert, Next: Undivert, Prev: Diversions, Up: Diversions

出力を切替える（divert）
========================

出力は`divert'を使って切替えます。

     divert(opt NUMBER)

NUMBERは使用する切替え先です。NUMBERを省略したときはゼロとして解釈され
ます。

`divert'は展開されると消滅します。

`m4'への入力がすべて処理されると、その時点で存在するすべての切替え先が
自動的に番号の順で逆切替え（undivert）されて、そこにたまっていたテキス
トが出力されます。

     divert(1)
     This text is diverted.
     divert
     =>
     This text is not diverted.
     =>This text is not diverted.
     ^D
     =>
     =>This text is diverted.

同じ引数で`divert'を何回か呼び出すと、切替え先にある以前のテキストは上
書きされずに、新しいテキストが以前のテキストの後に追加されてゆきます。

存在するはずのない切替え先へ出力を切替えるとそこから後の出力は単に捨て
られます。よくある不要な出力の例はマクロ定義の後にある改行です。次はそ
れらを避ける方法です。

     divert(-1)
     define(`foo', `Macro `foo'.')
     define(`bar', `Macro `bar'.')
     divert
     =>

これは`m4'でのプログラミング上の一般的な慣用句のひとつです。



File: m4-ja.info, Node: Undivert, Next: Divnum, Prev: Divert, Up: Diversions

出力を逆切替え（undivert）する
==============================

切替え先に出力されたテキスト（diverted text）は組み込みマクロ
`undivert'を使って明示的に逆切替え（undivert）することができます。

     undivert(opt NUMBER, ...)

このマクロは引数で指定された切替え先を、指定された順に逆切替えして出力
します。引数が与えられなかったときは、すべての切替え先を番号順に逆切替
えします。


`undivert'は展開されると消滅します。

     divert(1)
     This text is diverted.
     divert
     =>
     This text is not diverted.
     =>This text is not diverted.
     undivert(1)
     =>
     =>This text is diverted.
     =>

最後にある2つの空行に注目してください。1つは`undivert'に続く改行による
もので、もう一方はなんと`divert'に続く改行によるものです!  切替え先の
テキストはしばしばこのような空行で始まります。

切替え先のテキスト（diverted text）は逆切替え(undiverted)されると、
`m4'によって再走査*されずに*、現在の出力(切替え先)に直接コピーされます。
したがってある切替え先（diversion）に出力中に、逆切替え（undivert）し
ても問題ありません。

逆切替えをすると、その切替え先にあるテキストは破棄されるのでそのテキス
トを取り出せるのは1回だけです。

     divert(1)
     This text is diverted first.
     divert(0)undivert(1)dnl
     =>
     =>This text is diverted first.
     undivert(1)
     =>
     divert(1)
     This text is also diverted but not appended.
     divert(0)undivert(1)dnl
     =>
     =>This text is also diverted but not appended.

現在の切替え先（current diversion）を逆切替え（undivert）しようとして
も黙殺されます。

GNU `m4'では名前を指定したファイルを逆切替え（undivert）することができ
ます。数字以外の引数を与えると、その名前をもつファイルの内容が現在の出
力(切替え先)に解釈されずにコピーされます。これによって組み込みマクロ
`include'の機能が補完されます(*Note Include::)。次の例で違いを説明しま
す。ファイル`foo'の内容は`bar'だとします。

     define(`bar', `BAR')
     =>
     undivert(`foo')
     =>bar
     =>
     include(`foo')
     =>BAR
     =>



File: m4-ja.info, Node: Divnum, Next: Cleardiv, Prev: Undivert, Up: Diversions

出力切替え先番号（diversion number）
====================================

組み込みマクロ`divnum'は現在の切替え先（current diversion）の番号に展
開されます。

     divnum

     Initial divnum
     =>Initial 0
     divert(1)
     Diversion one: divnum
     divert(2)
     Diversion two: divnum
     divert
     =>
     ^D
     =>
     =>Diversion one: 1
     =>
     =>Diversion two: 2

逆切替えされて出力されるテキスト自身が切替え先に出力されてしまうのを防
ぐために最後にある引数無しの`divert'の呼び出しが必要です。(訳者注: 誤
訳の可能性あり。原文はThe last call of `divert' without argument is
necessary, since the undiverted text would otherwise be diverted
itself.)



File: m4-ja.info, Node: Cleardiv, Prev: Divnum, Up: Diversions

出力切替え先のテキストを破棄する
================================

出力を切替えているときは切替え先のテキストが実際に必要となるかどうかは
分からないことがよくあります。テキストが溜っている切替え先は入力が終り
に達した段階でメインの出力ストリームにすべて出力されるので、切替え先に
たまっているテキストを破棄するためのなんらかの手段が必要です。すべての
切替え先のテキストを破棄したいときは`m4'への入力を`divert(-1)'とそれに
続く明示的な`undivert' で終えるのが最も簡単でしょう。

     divert(1)
     Diversion one: divnum
     divert(2)
     Diversion two: divnum
     divert(-1)
     undivert
     ^D

このとき出力はいっさいありません。

特定の切替え先のテキストは次のマクロで消去できます。

     define(`cleardivert',
     `pushdef(`_num', divnum)divert(-1)undivert($@)divert(_num)popdef(`_num')')
     =>

`undivert'と同じように呼び出しますが、その効果は引数として与えられた切
替え先のテキストを消去することです。(このマクロにはひどいバグがありま
す!  それを見つけて直せるか挑戦してみてください。)



File: m4-ja.info, Node: Text handling, Next: Arithmetic, Prev: Diversions, Up: Top

テキスト操作用の組み込みマクロ
******************************

`m4'には部分文字列の抽出、検索、置換など様々な方法でテキストを操作する
ための組み込みマクロがあります。

* Menu:

* Len::                         文字列の長さを計算する
* Index::                       部分文字列で検索する
* Regexp::                      正規表現で検索する
* Substr::                      部分文字列を抽出する
* Translit::                    文字の置換
* Patsubst::                    正規表現でテキストの置換をする
* Format::                      文字列を(printf風に)フォーマットする



File: m4-ja.info, Node: Len, Next: Index, Prev: Text handling, Up: Text handling

文字列の長さを計算する
======================

文字列の長さは`len'で計算できます。

     len(STRING)

このマクロはSTRINGの長さを表す10進数に展開されます。

     len()
     =>0
     len(`abcdef')
     =>6

組み込みマクロ`len'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Index, Next: Regexp, Prev: Len, Up: Text handling

部分文字列で検索する
====================

部分文字列の検索は`index'で行います。

     index(STRING, SUBSTRING)

このマクロはSTRINGの中でSUBSTRINGが最初に出現する位置のインデックスに
展開されます。STRINGの先頭にある文字のインデックスは0です。SUBSTRINGが
STRINGに含まれないとき、`index'は`-1'に展開されます。

     index(`gnus, gnats, and armadillos', `nat')
     =>7
     index(`gnus, gnats, and armadillos', `dag')
     =>-1

組み込みマクロ`index'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Regexp, Next: Substr, Prev: Index, Up: Text handling

正規表現で検索する
==================

正規表現の検索は組み込みマクロ`regexp'で行います。

     regexp(STRING, REGEXP, opt REPLACEMENT)

このマクロはREGEXPでSTRINGの中を検索します。正規表現の構文はGNU Emacs
のものと同じです。*Note Syntax of Regular Expressions: (emacs)Regexps.

REPLACEMENTを省略すると、`regexp'はSTRINGの中でREGEXPに最初にマッチし
た部分のインデックスに展開されます。REGEXPがSTRINGのどこにもマッチしな
い場合は-1に展開されます。

     regexp(`GNUs not Unix', `\<[a-z]\w+')
     =>5
     regexp(`GNUs not Unix', `\<Q\w*')
     =>-1

REPLACEMENTを与えたときは、`regexp'はこの引数の値に展開されます。この
ときREPLACEMENTに含まれる`\N'はREGEXP中のN番目のカッコでくくられた部分
式にマッチしたテキストに置き換えられ、`\&'は正規表現全体にマッチしたテ
キストに置き換えられます。

     regexp(`GNUs not Unix', `\w\(\w+\)$', `*** \& *** \1 ***')
     =>*** Unix *** nix ***

組み込みマクロ`regexp'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Substr, Next: Translit, Prev: Regexp, Up: Text handling

部分文字列を抽出する
====================

部分文字列は`substr'を使って抽出します。

     substr(STRING, FROM, opt LENGTH)

このマクロはSTRINGのインデックスFROMから始まるLENGTH文字分の部分文字列
に展開されます。LENGTHを省いたときはSTRINGの最後までになります。文字列
の最初のインデックスは常に0です。

     substr(`gnus, gnats, and armadillos', 6)
     =>gnats, and armadillos
     substr(`gnus, gnats, and armadillos', 6, 5)
     =>gnats

組み込みマクロ`substr'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Translit, Next: Patsubst, Prev: Substr, Up: Text handling

文字の置換
==========

文字の置き換えは`translit'で行います。

     translit(STRING, CHARS, REPLACEMENT)

STRINGの各文字のうちCHARSに出て来る文字をそれぞれREPLACEMENT中で同じ位
置にある文字に置き換えたものに展開されます。

REPLACEMENTがCHARSより短いときは余分な文字は展開後のテキストから削除さ
れます。REPLACEMENTを省略すると展開後のテキストはSTRINGからCHARSに含ま
れる文字すべてを削除したものになります。

CHARSとREPLACEMENTのどちらにも文字範囲を含めることができます。たとえば
`a-z' (すべての小文字アルファベット)や`0-9' (すべての数字)などです。
CHARSやREPLACEMENTにダッシュ`-'そのものを含めるときは最初か最後に置い
てください。

範囲の最後の文字が最初の文字より`小さい'場合もエラーではありません。そ
ういうケースでは範囲が逆に広がります。つまり`9-0'は文字列`9876543210'
を意味します。

     translit(`GNUs not Unix', `A-Z')
     =>s not nix
     translit(`GNUs not Unix', `a-z', `A-Z')
     =>GNUS NOT UNIX
     translit(`GNUs not Unix', `A-Z', `z-a')
     =>tmfs not fnix

最初の例は大文字のアルファベットをすべて削除します。2番目の例は小文字
を大文字に変換します。3番目の例は大文字すべてを小文字に変換しながら`反
射'させます。最初の2つの例のほうがはるかに一般的です。

組み込みマクロ`translit'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Patsubst, Next: Format, Prev: Translit, Up: Text handling

正規表現でテキストの置換をする
==============================

文字列の全置換（global substitution）は`patsubst'で行います。

     patsubst(STRING, REGEXP, opt REPLACEMENT)

STRING中でREGEXPにマッチする部分を探し、それらをすべてREPLACEMENTに置
換します。正規表現の構文はGNU Emacsのものと同じです。

STRINGの中でREGEXPに適合するどの箇所にも含まれない部分は展開後のテキス
トにそのまま残ります。マッチする箇所が見つかるたびに、サーチはそのマッ
チした箇所の終りから続行されます。したがってSTRING内のある文字が2回置
換されることは決してありません。REGEXPが長さ0の文字列にマッチしたとき
は、無限ループを避けるためサーチの開始位置は1文字前に進められます。

置き換えが行われるときは、REPLACEMENTに含まれる`\N'をREGEXP内のカッコ
でくくられたN番目の部分式にマッチしたテキストに置き換え、`\&'を正規表
現全体にマッチしたテキストに置き換えたものが展開後のテキストに挿入され
ます。

引数REPLACEMENTは省略することができます。そのときはREGEXPにマッチした
テキストは削除されます。

     patsubst(`GNUs not Unix', `^', `OBS: ')
     =>OBS: GNUs not Unix
     patsubst(`GNUs not Unix', `\<', `OBS: ')
     =>OBS: GNUs OBS: not OBS: Unix
     patsubst(`GNUs not Unix', `\w*', `(\&)')
     =>(GNUs)() (not)() (Unix)
     patsubst(`GNUs not Unix', `\w+', `(\&)')
     =>(GNUs) (not) (Unix)
     patsubst(`GNUs not Unix', `[A-Z][a-z]+')
     =>GN not 

次はもうすこし現実的な例です。文字列の中にマクロ`upcase'と`downcase'の
呼び出しを挿入することで、単独の単語または文全体をキャピタライズ
（capitalize）します。

     define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl
     define(`downcase', `translit(`$*', `A-Z', `a-z')')dnl
     define(`capitalize1',
          `regexp(`$1', `^\(\w\)\(\w*\)', `upcase(`\1')`'downcase(`\2')')')dnl
     define(`capitalize',
          `patsubst(`$1', `\w+', `capitalize1(`\&')')')dnl
     capitalize(`GNUs not Unix')
     =>Gnus Not Unix

組み込みマクロ`patsubst'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Format, Prev: Patsubst, Up: Text handling

書式付き出力
============

書式付き出力は`format'を使って行うことができます。

     format(FORMAT-STRING, ...)

このマクロはC言語の関数`printf'とよく似た動作をします。最初の引数は書
式指定文字列で`%'指定を含めることができます。`format'は展開されると書
式付の文字列になります。

2, 3の例を使って説明するのが一番でしょう。

     define(`foo', `The brown fox jumped over the lazy dog')
     =>
     format(`The string "%s" is %d characters long', foo, len(foo))
     =>The string "The brown fox jumped over the lazy dog" is 38 characters long

*Note Loops::で定義されている`forloop'マクロを使って表形式の出力をする
ときは`format'を次のように使うことができます。

     forloop(`i', 1, 10, `format(`%6d squared is %10d
     ', i, eval(i**2))')
     =>     1 squared is	    1
     =>     2 squared is	    4
     =>     3 squared is	    9
     =>     4 squared is	   16
     =>     5 squared is	   25
     =>     6 squared is	   36
     =>     7 squared is	   49
     =>     8 squared is	   64
     =>     9 squared is	   81
     =>    10 squared is	  100

組み込みマクロ`format'はANSI Cの`printf'関数をモデルとしており、
次の標準的な`%'指定をサポートしています: `c', `s', `d',
`o', `x', `X', `u', `e', `E', `f'。
またフィールド幅と精度指定、モディファイア `+', `-', ` ',
`0', `#', `h', `l'をサポートしています。
`printf'の動作について更に詳しいことは
C ライブラリ・マニュアルを見てください。




File: m4-ja.info, Node: Arithmetic, Next: UNIX commands, Prev: Text handling, Up: Top

計算用の組み込みマクロ
**********************

`m4'にはCに似た文法の整数演算機構が組み込まれています。単純なインクリ
メントとデクリメント操作のための組み込みマクロが便利な省略記法として用
意されています。

* Menu:

* Incr::                        インクリメント演算子とデクリメント演算子
* Eval::                        整数式を計算する



File: m4-ja.info, Node: Incr, Next: Eval, Prev: Arithmetic, Up: Arithmetic

インクリメント演算子とデクリメント演算子
========================================

整数のインクリメントとデクリメントは組み込みマクロ`incr'と`decr' によっ
てサポートされています。

     incr(NUMBER)
     decr(NUMBER)

NUMBERの数値を1だけ増やした値または1だけ減らした値に展開されます。

     incr(4)
     =>5
     decr(7)
     =>6

組み込みマクロ`incr'および`decr'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Eval, Prev: Incr, Up: Arithmetic

整数式を計算する
================

整数式は`eval'を使って計算します。

     eval(EXPRESSION, opt RADIX, opt WIDTH)

このマクロはEXPRESSIONの値に展開されます。

式（expression）には次の演算子を含めることができます。リストは優先順位
の高い順に並んでいます。

`-'
     単項差（unary minus）
`**'
     累乗（exponentiation）
`*  /  %'
     積（multiplication）、商（division）、剰余（modulo）
`+  -'
     和（addition）、差（subtraction）
`<<  >>'
     左シフト（shift left）、右シフト（shift right）
`==  !=  >  >=  <  <='
     関係演算子（relational operator）
`!'
     論理否定（logical negation）
`~'
     ビットごとの論理否定（bitwise negation）
`&'
     ビットごとの論理積（bitwise and）
`^'
     ビットごとの排他的論理和（bitwise exclusive-or）
`|'
     ビットごとの論理和（bitwise or）
`&&'
     論理積（logical and）
`||'
     論理和（logical or）

累乗（exponentiation）を除いたすべての演算子は左結合（left associative）
をします。

`m4'の実装には`^'を累乗（exponentiation）演算子の代用として使うものが
多くありますが、`^'をビットごとの排他的論理和（bitwise exclusive-or）
に使っている実装も多くあります。GNU `m4'はこの点について動作の変更を行
いました。かつて`^'は累乗を行う演算子でしたが、現在はビットごとの排他
的論理和を行う演算子となっています。

特別な接頭辞（prefix）がついていない数字は10進数となります。
`0'のみの接頭辞は8進数の始まりを表します。
`0x'は16進数の始まりを表します。
`0b'は2進数の始まりを表します。
`0r'は1から36までの任意の基数で表現した数字の始まりを表します。
`0r'の後には10進数で表現した基数、コロン（:）、
および数値を表す数字列を続けなくてはなりません。
いずれの基数で表すにしても数字としては`0', `1', `2',
...を使い、`9'から上は`a', `b' ... `z'までを
数字として使います。アルファベットの大文字と小文字は基数を表す接頭辞お
よび数値を表す数字列のなかで区別なく使用することができます。

部分式をグループ化するために必要なときはカッコを使うことができます。関
係演算子は関係が真のときは`1'を返し、偽のときは`0'を返します。

`eval'の使用例をいくつか次に挙げます。

     eval(-3 * 5)
     =>-15
     eval(index(`Hello world', `llo') >= 0)
     =>1
     define(`square', `eval(($1)**2)')
     =>
     square(9)
     =>81
     square(square(5)+1)
     =>676
     define(`foo', `666')
     =>
     eval(`foo'/6)
     error-->51.eval:14: m4: Bad expression in eval: foo/6
     =>
     eval(foo/6)
     =>111

最後から2番目の例が示しているように`eval'がマクロ名を勝手に展開するこ
とはありません。例えそれらが有効な式(もしくは有効な式の一部)に展開され
るにしてもです。したがって全てのマクロは`eval'に渡される前に展開済であ
る必要があります。

RADIXを指定すると展開後のテキストではその基数が使われます。デフォルト
の基数は10です。`eval'の結果は常に符号付き（signed）であると解釈されま
す。引数WIDTHは最低限の出力幅を指定します。展開後のテキストが要求され
た幅になるように結果には0が埋め草（zero-padded）として付加されます。

     eval(666, 10)
     =>666
     eval(666, 11)
     =>556
     eval(666, 6)
     =>3030
     eval(666, 6, 10)
     =>0000003030
     eval(-666, 6, 10)
     =>-000003030

RADIXは36より大きくてはいけないことに注意してください。

組み込みマクロ`eval'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: UNIX commands, Next: Miscellaneous, Prev: Arithmetic, Up: Top

UNIXコマンド実行用の組み込みマクロ
**********************************

UNIXコマンドを`m4'内部から呼び出すための組み込みマクロが`m4'にはいくつ
か存在します。

* Menu:

* Syscmd::                      単一のコマンドを実行する
* Esyscmd::                     コマンドの出力を読む
* Sysval::                      終了コード
* Maketemp::                    一時ファイル用の名前を生成する



File: m4-ja.info, Node: Syscmd, Next: Esyscmd, Prev: UNIX commands, Up: UNIX commands

単一のコマンドを実行する
========================

`syscmd'を使えば任意のシェル・コマンドを実行することができます。

     syscmd(SHELL-COMMAND)

シェル・コマンドとしてSHELL-COMMANDを実行します。

`syscmd'は展開後、SHELL-COMMANDからの出力には*ならず*に消滅します。
SHELL-COMMANDからの出力やエラー・メッセージは`m4'には読み込まれません。
コマンドの出力を処理する必要があるときは*Note Esyscmd::を参照してくだ
さい。

コマンドの実行に先立ち、`m4'は自分の出力バッファをフラッシュします。
SHELL-COMMANDにおけるデフォルトの標準入力、標準出力、および標準エラー
出力は`m4'のものと同じです。

`syscmd'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Esyscmd, Next: Sysval, Prev: Syscmd, Up: UNIX commands

コマンドの出力を読む
====================

UNIXコマンドの出力を`m4'に読み込ませたいときは`esyscmd'を使ってくださ
い。

     esyscmd(SHELL-COMMAND)

シェル・コマンドSHELL-COMMANDの標準出力の内容に展開されます。

`m4'はコマンドの実行に先立ち自分の出力バッファをフラッシュします。
SHELL-COMMANDのデフォルトの標準入力および標準エラー出力は`m4'のものと
同じになります。SHELL-COMMANDのエラー出力は展開テキストの一部にはなり
ません― `m4'のエラー出力と一緒に出てくるでしょう。

次の例ではGNU `m4'ディストリビューションの`checks'ディレクトリにいると
仮定します。

     define(`vice', `esyscmd(grep Vice ../COPYING)')
     =>
     vice
     =>  Ty Coon, President of Vice
     =>

`esyscmd'の展開によるテキストの後ろに改行がついている様子に注意してく
ださい。

`esyscmd'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Sysval, Next: Maketemp, Prev: Esyscmd, Up: UNIX commands

終了コード
==========

シェル・コマンドの実行が成功したか調べるときは`sysval'を使ってください。

     sysval

このマクロは`syscmd'や`esyscmd'で実行した最後のシェル・コマンドの終了
ステータス（exit status）に展開されます。

     syscmd(`false')
     =>
     ifelse(sysval, 0, zero, non-zero)
     =>non-zero
     syscmd(`true')
     =>
     sysval
     =>0



File: m4-ja.info, Node: Maketemp, Prev: Sysval, Up: UNIX commands

一時ファイル用の名前を生成
==========================

`syscmd'や`esyscmd'に指定されたコマンドが出力やその他の目的で一時ファ
イルを必要とすることもあるでしょう。一時ファイルの名前を生成するために
組み込みマクロ`maketemp'が用意されています。

     maketemp(TEMPLATE)

このマクロはTEMPLATEを元に作られた現時点で存在しないファイルの名前に展
開されます。TEMPLATEは文字列`XXXXXX'で終らなければなりません。この6つ
の`X'はファイル名をユニークにするために`m4'のプロセスidを含む何らかの
文字列によって置き換えられます。

     maketemp(`/tmp/fooXXXXXX')
     =>/tmp/fooa07346
     maketemp(`/tmp/fooXXXXXX')
     =>/tmp/fooa07346

例にあるように`maketemp'を複数回呼び出すと同じ文字列に展開されることが
あります。これは選択の基準がファイルが存在するかどうかだからです。
`maketemp'を次に呼び出すより前にファイルが作成されていないときは、2つ
の`maketemp'マクロの呼び出しは同じ名前に展開される可能性があります。

`maketemp'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Miscellaneous, Next: Frozen files, Prev: UNIX commands, Up: Top

その他の組み込みマクロ
**********************

この章では、これまでのどの章にも分類できない様々な組み込みマクロを説明
します。

* Menu:

* Errprint::                    エラーメッセージを表示する
* M4exit::                      m4を終了させる



File: m4-ja.info, Node: Errprint, Next: M4exit, Prev: Miscellaneous, Up: Miscellaneous

エラーメッセージを表示する
==========================

エラー・メッセージは`errprint'を使って表示することができます。

     errprint(MESSAGE, ...)

このマクロはMESSAGEと残りの引数の標準エラー出力への表示だけを行います。

`errprint'は展開されると消滅します。

     errprint(`Illegal arguments to forloop
     ')
     error-->Illegal arguments to forloop
     =>

末尾の改行は自動的に印字され*ません*。したがって例にあるように引数の一
部として与えなければなりません。(BSDフレーバーの`m4'は`errprint'呼び出
しごとに改行を1つ末尾に付加します。)

エラーの場所を特定するための組み込みユーティリティ・マクロが2つありま
す。

     __file__
     __line__

これらは現在の入力ファイルの名前をクォートしたものとそのファイル内での
現在の入力行番号に展開されます。

     errprint(`m4:'__file__:__line__: `Input error
     ')
     error-->m4:56.errprint:2: Input error
     =>



File: m4-ja.info, Node: M4exit, Prev: Errprint, Up: Miscellaneous

`m4'を終了させる
================

すべての入力を読み込んでしまう前に`m4'を終了したいときは`m4exit'を使う
ことができます。

     m4exit(opt CODE)

このマクロはCODEを終了コード（exit code）として`m4'を終了させます。
CODEを省略したときは終了コードは0になります。

     define(`fatal_error', `errprint(`m4: '__file__: __line__`: fatal error: $*
     ')m4exit(1)')
     =>
     fatal_error(`This is a BAD one, buster')
     error-->m4: 57.m4exit: 5: fatal error: This is a BAD one, buster

この例ではFATAL_ERRORマクロが呼び出された後、`m4'は終了コード1で終了し
ます。このマクロはエラー終了を行うためだけのものです、なぜなら通常の終
了手続き、例えば出力切替え先のテキスト（diverted text）の逆切替え
（undivert）や保存されているテキスト(*Note M4wrap::)の再読み込みなどが
行われないからです。



File: m4-ja.info, Node: Frozen files, Next: Compatibility, Prev: Miscellaneous, Up: Top

凍結状態（frozen state）の高速ロード
************************************

何百もの定義や手間がかかるその他の初期化を含んだ共通の基盤を土台として、
複数のさらに大きな`m4'アプリケーションを構築することができます。通常は
その共通の基盤を1つ以上のファイルに格納しておいて`m4'を起動するたびに
ユーザの入力ファイル名の前にそれらのファイル名を羅列するか、ユーザの入
力ファイルから`include'します。

巨大なアプリケーションの共通基盤を何度も何度も繰り返し読み込むのは時間
がかかることでしょう。`m4'には大きな共通基盤を使うアプリケーションの開
始時間をスピードアップするための機構が用意されています。ユーザが次のコ
マンドラインを繰り返し使うとします。

     m4 base.m4 input.m4

ここで`input.m4'は起動のたびにいろいろな内容を持ち、`base.m4'はかなり
固定的な内容を持っているとします。こういうときは、次のようにした方がい
いでしょう。

     m4 -F base.m4f base.m4

このように一度実行しておき、必要になるたびに次のように実行します。

     m4 -R base.m4f input.m4

最初の`-F'オプションを含んでいる呼び出しは`base.m4'を読んで実行するこ
とで、さまざまなアプリケーション・マクロの定義やその他の初期化を行いま
す。入力ファイル`base.m4'の処理が完全に終ってから、GNU `m4'は凍結
（"frozen"）ファイルを`base.m4f'として生成します。このファイルは`m4'の
内部状態のある種のスナップ・ショットとなっています。

後者の`-R'オプションを含んでいる呼び出しでは、どの入力ファイルが読み込
まれるよりも*前*に、`base.m4f'から`m4'のメモリの内部状態をリロード
（reload）しておくことができます。このようにして、まっさらな状態の`m4'
から始めるかわりに前に起動したときの結果を効率的に回復したあとで入力を
読み込みます。この例では`base.m4'を新たに読んだときと効果は同じですが、
それをずっと速く行うことができます。

`m4'の1回の起動で作ったり読み込んだりできる凍結ファイルはそれぞれ1つだ
けです。一度に2つの凍結ファイルの内容を回復することはできません。しか
し`-R'と`-F'オプションを同時につかうことで、凍結ファイルをすこしずつ更
新していくことはできます。

     m4 file1.m4 file2.m4 file3.m4 file4.m4

これは多少の注意を払えば同じ出力を段々と蓄積していく次の一連のコマンド
に分けることができるでしょう。

     m4 -F file1.m4f file1.m4
     m4 -R file1.m4f -F file2.m4f file2.m4
     m4 -R file2.m4f -F file3.m4f file3.m4
     m4 -R file3.m4f file4.m4

多少の注意を払う必要があるというのは、これがどんな場合にもうまく動くよ
うにするためのあらゆる対策がなされているわけではないからです。とりわけ、
マクロのトレース属性には対応していませんし`changeword'の現在の設定に関
してもそうです。`m4'のいくつかのオプションが1度目で使用されて、次は使
用されなかった場合にどのように作用するかも完全には検討されていません。
一方で`pushdef'された定義のスタックが正しく扱われることは保証されてい
ます。また`undefine'された定義、組み込みマクロの名前変更、引用符やコメ
ント記号の変更についても同様です。

`m4'の実行が凍結されるとき、実行終了時に起こる自動的な出力の逆切替え
（undiversion）は抑制されます。そのかわり全ての正の番号をもつ出力切替
え先の内容は凍結ファイルに保存されます。使用中の出力切替え先の番号も伝
えられます。

リロード（reload）しようとしている凍結ファイルがカレント・ディレクトリ
にある必要はありません。凍結ファイルを探す方法はインクルード・ファイル
（`include'）の場合と同じです。(*Note Search Path::)

凍結ファイルは複数のアーキテクチャで共有することができます。1つのマシ
ンで凍結ファイルを作り、それを他のマシンで使うときは2番目のマシンで同
じか新しいバージョンのGNU `m4'を使っているなら確実です。これらのファイ
ルは単純な(編集可能な)テキストファイルで、アルファベット大文字で始まり
改行文字(NL)で終る指令から成り立っています。指令があるはずの場所に`#'
があるときはコメント行の始まりとなり、空行とあわせて無視されます。次の
説明ではLENGTHは常に対応するSTRINGを参照します。数字は常に10進数で表さ
れます。指令の一覧です。

`V NUMBER NL'
     凍結ファイルのフォーマットを確認します。NUMBERは1にします。

`C LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     STRING1とSTRING2を開始コメントと終了コメント文字列として使います。

`Q LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     STRING1とSTRING2を開始クォートと終了クォート文字列として使います。

`F LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     `pushdef'を使い、STRING1が組み込みマクロとして名前STRING2をもつ関
     数に展開されるように定義します。

`T LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     `pushdef'を使い、STRING1がテキストSTRING2に展開されるように定義し
     ます。

`D NUMBER, LENGTH NL STRING NL'
     番号NUMBERの出力切替え先を選択し、それを現在の出力切替え先
     （current diversion）にして、STRINGを現在の出力切替え先にコピーし
     ます。NUMBERは存在しない出力切替え先を表す負数にすることができま
     す。現在の出力切替え先の選択だけをしたいときは、STRINGを空文字列
     にして、このコマンドを使います。出力切替え先番号NUMBERとして0を使
     うと、リロード時にSTRINGが標準出力へ出力されるでしょう、しかし
     `m4'内部からこのようにこのコマンドが生成されることはありません。




File: m4-ja.info, Node: Compatibility, Next: Concept index, Prev: Frozen files, Up: Top

他の版の`m4'との互換性
**********************

この章では`m4'の本実装とUNIXとりわけSystem V, Release 3における実装と
の相違点を説明します。


* Menu:

* Extensions::                  GNU m4で拡張された機能
* Incompatibilities::           System V m4にあってGNU m4にない機能
* Other Incompat::              その他の非互換性



File: m4-ja.info, Node: Extensions, Next: Incompatibilities, Prev: Compatibility, Up: Compatibility

GNU `m4'で拡張された機能
========================

本バージョンの`m4'にはSystem V `m4'に存在しない機能がいくつかあります。
これらの追加された機能はコマンドライン・オプション`-G'を使うことで、他
のコマンドライン・オプションによって無効にされない限り、すべて抑制され
ます。

   * マクロの引数を表す`$'N表記において、Nは複数の数字を含むことができ
     ますが、System V `m4'は1つの数字しか受けつけません。これによりGNU
     `m4'ではマクロが引数を9つだけでなくいくつでも取ることができます。
     (*Note Arguments::)

   * `include'と`sinclude'でインクルードされるファイルは、作業ディレク
     トリで見つからないときは指定されたサーチ・パスのなかから捜し出さ
     れます。サーチ・パスは`-I'オプションと環境引数`M4PATH'で指定しま
     す。(*Note Search Path::)

   * `undivert'への引数は数字以外でもよく、そのときはその名前を持つファ
     イルを解釈しないまま出力に含めます。(*Note Undivert::)

   * 書式付き出力が、Cのライブラリ関数`printf'をモデルとした組み込みマ
     クロ`format'を通じてサポートされています。(*Note Format::)

   * 正規表現を使った探索とテキストの置換が組み込みマクロ`regexp'
     (*Note Regexp::)と`patsubst' (*Note Patsubst::)によってサポートさ
     れています。

   * シェル・コマンドの出力を`esyscmd' (*Note Esyscmd::)で`m4'に読み込
     むことができます。

   * `builtin' (*Note Builtin::)により任意の組み込みマクロへ間接的にア
     クセスできます。

   * `indir' (*Note Indir::)を通じてマクロを間接的に呼び出せます。

   * 組み込みマクロ`__file__'と`__line__' (*Note Errprint::) を通じて
     現在の入力ファイルの名前と現在の入力行番号へアクセスできます。

   * `dumpdef'とマクロ・トレースの出力書式を`debugmode' (*Note Debug
     Levels::)で制御することができます。

   * トレースとデバッグの出力先を`debugfile' (*Note Debug Output::) で
     制御可能です。

上記の拡張に加えGNU `m4'には次のコマンドライン・オプションが実装されて
います ― `-F', `-G', `-I', `-L', `-R', `-V', `-W', `-d', `-l', `-o',
`-t'。これらオプションの説明は*Note Invoking m4::を参照してください。

またGNU `m4'のデバッグとトレース機構は他バージョンの`m4'にあるものより
遥かに大規模です。



File: m4-ja.info, Node: Incompatibilities, Next: Other Incompat, Prev: Extensions, Up: Compatibility

System V `m4' にあってGNU `m4'にない機能
========================================

System Vバージョンの`m4'にはGNU `m4'にまだ実装されていない機能がいくつ
かあります。

   * System V `m4'は`defn'への複数の引数をサポートしています。GNU `m4'
     はこれを実装していません。この機能の有用性が筆者にははっきりしま
     せん。



File: m4-ja.info, Node: Other Incompat, Prev: Incompatibilities, Up: Compatibility

その他の非互換性
================

System Vバージョンの`m4'と本実装との間には他にいくつか非互換な部分があ
ります。

   * テキストが出力切替え先（diversion）に送られるときのときの同期行の
     実装がGNU `m4'とSystem V `m4'では異なります。GNU `m4'はテキストが
     出力切替え先に送られるときに同期行を出力しますが、System V `m4'で
     はこれが、出力切替え先のテキストが引き戻されるときになります。

     問題は出力切替え先に送られる、または送られていたテキストにどの行
     番号とファイル名をつけ加えるかです。System V `m4'は出力切替え先に
     送られていたすべてのテキストが`undivert'の呼び出しを含むソース行
     によって生成されたと見なしますが、GNU `m4'は出力切替え先に送られ
     る時にテキストが生成されたと見なします。

     私は同期行オプションを使うのは大抵`m4'をコンパイラのフロントエン
     ドとして使うときだと考えます。もし出力切替え先に送られた行がコン
     パイラエラーを引き起こしたら、エラーメッセージは出力切替え先のテ
     キストが挿入しなおされた場所ではなく、出力切替え先に送られた場所
     をおそらく指し示すべきでしょう。

   * GNU `m4'は自己参照的な定義を防ごうとはしません。

          define(`x', `x')
          define(`x', `x ')

     `x'が`x'を返すように定義することに、本質的に間違っているところは
     ありません。間違っているのはクォートされていない`x'を展開すること
     です。他のプログラミング言語で変数を使うのと同じように、`m4'で文
     字列を保持するためにマクロ使い、さらにそれを次のようにチェックす
     る人もいるでしょう:

          ifelse(defn(`HOLDER'), `VALUE', ...)

     このような場合、マクロが自分自身の名前を保持するのを禁止するのは
     余計なお世話でしょう。もちろん、これはGNU `m4'ユーザが自分で首を
     くくるためのロープを放置しておくことにはなります!  再走査によるハ
     ング（hang）は、伝統的なプログラミング言語において無限ループに対
     するときのような、注意深いプログラミングによって避けることができ
     るでしょう。

   * GNU `m4'は`-G'オプション無しだと、`__gnu__'が空行に展開されるよう
     に定義します。

     UNIX システム上においてGNU `m4'は`-G'オプションをつけるとマクロ
     `__unix__'、つけないときはマクロ`unix'を定義します。両方とも空文
     字列に展開されます。



File: m4-ja.info, Node: Concept index, Next: Macro index, Prev: Compatibility, Up: Top

Concept index
*************


* Menu:

* マクロへの引数:               Arguments.              5.
* Arguments to macros:          Arguments.              5.
* 整数演算:                     Arithmetic.             5.
* 計算, 演算:                   Arithmetic.             5.
* 組み込みマクロを間接的に呼び出す: Builtin.            5.
* 出力にコピーされるコメント:   Changecom.              29.
* コメントデリミタを変更:       Changecom.              5.
* 引用符を変更:                 Changequote.            5.
* 単語の字句構造:               Changeword.             5.
* 出力切替え先のテキストを破棄する: Cleardiv.           5.
* コメント:                     Comments.               5.
* 互換性:                       Compatibility.          5.
* デバッグ出力の制御:           Debug Levels.           5.
* デバッグ出力を保存:           Debug Output.           5.
* マクロを新しく定義する方法:   Definitions.            5.
* マクロの名前をかえる方法:     Defn.                   5.
* 入力の空白を削除:             Dnl.                    5.
* マクロの定義を表示:           Dumpdef.                5.
* エラーメッセージの表示:       Errprint.               5.
* 整数式の評価:                 Eval.                   5.
* 整数式の計算:                 Eval.                   5.
* ファイルのインクルード:       File Inclusion.         5.
* 書式付き出力:                 Format.                 5.
* GNU拡張:                      Arguments.              27.
* GNU拡張:                      Builtin.                5.
* GNU拡張:                      Debug Levels.           58.
* GNU拡張:                      Debug Output.           5.
* GNU拡張:                      Esyscmd.                5.
* GNU拡張:                      Extensions.             5.
* GNU拡張:                      Format.                 5.
* GNU拡張:                      Frozen files.           5.
* GNU拡張:                      Indir.                  5.
* GNU拡張:                      Patsubst.               5.
* GNU拡張:                      Regexp.                 5.
* GNU拡張:                      Search Path.            5.
* GNU拡張:                      Undivert.               56.
* GNU extensions:               Arguments.              27.
* GNU extensions:               Builtin.                5.
* GNU extensions:               Debug Levels.           58.
* GNU extensions:               Debug Output.           5.
* GNU extensions:               Esyscmd.                5.
* GNU extensions:               Extensions.             5.
* GNU extensions:               Format.                 5.
* GNU extensions:               Frozen files.           5.
* GNU extensions:               Indir.                  5.
* GNU extensions:               Patsubst.               5.
* GNU extensions:               Regexp.                 5.
* GNU extensions:               Search Path.            5.
* GNU extensions:               Undivert.               56.
* 条件構文:                     Ifdef.                  5.
* 多重分岐:                     Ifelse.                 32.
* 文字列の比較:                 Ifelse.                 5.
* デクリメント演算子:           Incr.                   5.
* インクリメント演算子:         Incr.                   5.
* マクロを間接的に呼び出す:     Indir.                  5.
* マクロ呼び出し:               Invocation.             5.
* マクロの呼び出し:             Invocation.             5.
* コマンドライン上でマクロを定義: Invoking m4.          142.
* コマンドライン上のファイル名: Invoking m4.            176.
* コマンドライン, オプション:   Invoking m4.            9.
* 文字列の長さ:                 Len.                    5.
* ループの回数を数える:         Loops.                  40.
* 再帰的なマクロ:               Loops.                  5.
* ループ:                       Loops.                  9.
* 入力を保存:                   M4wrap.                 5.
* 引数:                         Macro Arguments.        5.
* マクロの引数:                 Macro Arguments.        5.
* マクロへの引数:               Macro Arguments.        5.
* マクロの展開:                 Macro expansion.        5.
* 一時ファイル名:               Maketemp.               5.
* 名前:                         Names.                  5.
* パターンマッチ:               Patsubst.               5.
* 正規表現で置換:               Patsubst.               5.
* マクロの特殊な引数:           Pseudo Arguments.       5.
* マクロを一時的に再定義:       Pushdef.                5.
* 引用符で括られた文字列:       Quoted strings.         5.
* 引用符で囲まれた文字列:       Quoted strings.         5.
* クォートされた文字列:         Quoted strings.         5.
* クォートされたマクロの引数:   Quoting Arguments.      5.
* 正規表現:                     Regexp.                 5.
* インクルードファイルのサーチパス: Search Path.        5.
* 部分文字列を切り出す:         Substr.                 5.
* 部分文字列を抽出:             Substr.                 5.
* トークン:                     Syntax.                 5.
* 入力トークン:                 Syntax.                 5.
* マクロの展開をトレース:       Trace.                  5.
* 文字の置き換え:               Translit.               5.
* 文字の置換:                   Translit.               5.
* UNIXコマンドの終了コード:     Sysval.                 5.
* UNIXコマンドの実行:           UNIX commands.          5.
* UNIX commands, exit code from: Sysval.                5.
* UNIX commands, running:       UNIX commands.          5.
* マクロを削除する方法:         Undefine.               5.
* ファイルのインクルード:       Undivert.               56.
* arguments, quoted macro:      Quoting Arguments.      5.
* arguments to macros:          Macro Arguments.        5.
* arguments to macros, special: Pseudo Arguments.       5.
* arithmetic:                   Arithmetic.             5.
* builtins, indirect call of:   Builtin.                5.
* call of builtins, indirect:   Builtin.                5.
* call of macros, indirect:     Indir.                  5.
* changing comment delimiters:  Changecom.              5.
* changing the quote delimiters: Changequote.           5.
* characters, translating:      Translit.               5.
* command line, filenames on the: Invoking m4.          176.
* command line, macro definitions on the: Invoking m4.  142.
* command line, options:        Invoking m4.            9.
* commands, exit code from UNIX: Sysval.                5.
* commands, running UNIX:       UNIX commands.          5.
* comment delimiters, changing: Changecom.              5.
* comments:                     Comments.               5.
* comments, copied to output:   Changecom.              29.
* comparing strings:            Ifelse.                 5.
* compatibility:                Compatibility.          5.
* conditionals:                 Ifdef.                  5.
* controlling debugging output: Debug Levels.           5.
* counting loops:               Loops.                  40.
* debugging output, controlling: Debug Levels.          5.
* debugging output, saving:     Debug Output.           5.
* decrement operator:           Incr.                   5.
* defining new macros:          Definitions.            5.
* definitions, displaying macro: Dumpdef.               5.
* deleting macros:              Undefine.               5.
* deleting whitespace in input: Dnl.                    5.
* discarding diverted text:     Cleardiv.               5.
* displaying macro definitions: Dumpdef.                5.
* 出力切替え先番号（diversion number）: Divnum.         5.
* diversion numbers:            Divnum.                 5.
* 出力をファイルへ切替える（divert）: Divert.           5.
* diverted text, discarding:    Cleardiv.               5.
* diverting output to files:    Divert.                 5.
* dumping into frozen file:     Frozen files.           5.
* error messages, printing:     Errprint.               5.
* evaluation, of integer expressions: Eval.             5.
* executing UNIX commands:      UNIX commands.          5.
* exit code from UNIX commands: Sysval.                 5.
* exiting from `m4':            M4exit.                 5.
* expansion of macros:          Macro expansion.        5.
* expansion, tracing macro:     Trace.                  5.
* expressions, evaluation of integer: Eval.             5.
* extracting substrings:        Substr.                 5.
* fast loading of frozen files: Frozen files.           5.
* file inclusion:               File Inclusion.         5.
* file inclusion:               Undivert.               56.
* filenames, on the command line: Invoking m4.          176.
* files, diverting output to:   Divert.                 5.
* files, names of temporary:    Maketemp.               5.
* forloops:                     Loops.                  40.
* formatted output:             Format.                 5.
* frozen files for fast loading: Frozen files.          5.
* 凍結状態（frozen state）の高速ロード: Frozen files.   5.
* included files, search path for: Search Path.         5.
* inclusion, of files:          File Inclusion.         5.
* inclusion, of files:          Undivert.               56.
* increment operator:           Incr.                   5.
* indirect call of builtins:    Builtin.                5.
* indirect call of macros:      Indir.                  5.
* initialization, frozen states: Frozen files.          5.
* input, saving:                M4wrap.                 5.
* input tokens:                 Syntax.                 5.
* integer arithmetic:           Arithmetic.             5.
* integer expression evaluation: Eval.                  5.
* length of strings:            Len.                    5.
* lexical structure of words:   Changeword.             5.
* loops:                        Loops.                  9.
* loops, counting:              Loops.                  40.
* m4を終了させる:               M4exit.                 5.
* macro definitions, on the command line: Invoking m4.  142.
* macro expansion, tracing:     Trace.                  5.
* macro invocation:             Invocation.             5.
* macros, arguments to:         Arguments.              5.
* macros, arguments to:         Macro Arguments.        5.
* macros, displaying definitions: Dumpdef.              5.
* macros, expansion of:         Macro expansion.        5.
* macros, how to define new:    Definitions.            5.
* macros, how to delete:        Undefine.               5.
* macros, how to rename:        Defn.                   5.
* macros, indirect call of:     Indir.                  5.
* macros, quoted arguments to:  Quoting Arguments.      5.
* macros, recursive:            Loops.                  5.
* macros, special arguments to: Pseudo Arguments.       5.
* macros, temporary redefinition of: Pushdef.           5.
* messages, printing error:     Errprint.               5.
* multibranches:                Ifelse.                 32.
* names:                        Names.                  5.
* options, command line:        Invoking m4.            9.
* output, diverting to files:   Divert.                 5.
* output, formatted:            Format.                 5.
* output, saving debugging:     Debug Output.           5.
* pattern substitution:         Patsubst.               5.
* printing error messages:      Errprint.               5.
* quote delimiters, changing the: Changequote.          5.
* quoted macro arguments:       Quoting Arguments.      5.
* quoted string:                Quoted strings.         5.
* recursive macros:             Loops.                  5.
* redefinition of macros, temporary: Pushdef.           5.
* regular expressions:          Patsubst.               5.
* regular expressions:          Regexp.                 5.
* reloading a frozen file:      Frozen files.           5.
* renaming macros:              Defn.                   5.
* running UNIX commands:        UNIX commands.          5.
* saving debugging output:      Debug Output.           5.
* saving input:                 M4wrap.                 5.
* search path for included files: Search Path.          5.
* special arguments to macros:  Pseudo Arguments.       5.
* strings, length of:           Len.                    5.
* substitution by regular expression: Patsubst.         5.
* substrings, extracting:       Substr.                 5.
* temporary filenames:          Maketemp.               5.
* temporary redefinition of macros: Pushdef.            5.
* tokens:                       Syntax.                 5.
* tracing macro expansion:      Trace.                  5.
* translating characters:       Translit.               5.
* undefining macros:            Undefine.               5.
* words, lexical structure of:  Changeword.             5.



File: m4-ja.info, Node: Macro index, Prev: Concept index, Up: Top

Macro index
***********

参照先は組み込みマクロが最初に紹介されている場所だけです。索引では始め
や終りに`__'のある名前はそれらが取り除かれています。



* Menu:

* builtin:                      Builtin.                5.
* changecom:                    Changecom.              5.
* changequote:                  Changequote.            5.
* changeword:                   Changeword.             5.
* debugfile:                    Debug Output.           5.
* debugmode:                    Debug Levels.           58.
* decr:                         Incr.                   5.
* define:                       Define.                 5.
* defn:                         Defn.                   5.
* divert:                       Divert.                 5.
* divnum:                       Divnum.                 5.
* dnl:                          Dnl.                    5.
* dumpdef:                      Dumpdef.                5.
* errprint:                     Errprint.               5.
* esyscmd:                      Esyscmd.                5.
* eval:                         Eval.                   5.
* file:                         Errprint.               25.
* format:                       Format.                 5.
* gnu:                          Other Incompat.         48.
* ifdef:                        Ifdef.                  5.
* ifelse:                       Ifelse.                 5.
* include:                      Include.                5.
* incr:                         Incr.                   5.
* index:                        Index.                  5.
* indir:                        Indir.                  5.
* len:                          Len.                    5.
* line:                         Errprint.               25.
* m4exit:                       M4exit.                 5.
* m4wrap:                       M4wrap.                 5.
* maketemp:                     Maketemp.               5.
* patsubst:                     Patsubst.               5.
* popdef:                       Pushdef.                6.
* pushdef:                      Pushdef.                6.
* regexp:                       Regexp.                 5.
* shift:                        Loops.                  11.
* sinclude:                     Include.                5.
* substr:                       Substr.                 5.
* syscmd:                       Syscmd.                 5.
* sysval:                       Sysval.                 5.
* traceoff:                     Trace.                  5.
* traceon:                      Trace.                  5.
* translit:                     Translit.               5.
* undefine:                     Undefine.               5.
* undivert:                     Undivert.               5.
* unix:                         Other Incompat.         51.


Tag table:
Node: Top1017
Node: Preliminaries5637
Node: Intro6087
Node: History7080
Node: Invoking m47716
Node: Bugs12092
Node: Manual12827
Node: Syntax13608
Node: Names14066
Node: Quoted strings14363
Node: Other tokens14826
Node: Comments15023
Node: Macros15498
Node: Invocation15876
Node: Inhibiting Invocation16369
Node: Macro Arguments18272
Node: Quoting Arguments18964
Node: Macro expansion19491
Node: Definitions19891
Node: Define20454
Node: Arguments21010
Node: Pseudo Arguments22027
Node: Undefine23361
Node: Defn23853
Node: Pushdef24578
Node: Indir25872
Node: Builtin26437
Node: Conditionals26734
Node: Ifdef27179
Node: Ifelse27777
Node: Loops28939
Node: Debugging31078
Node: Dumpdef31503
Node: Trace32069
Node: Debug Levels33017
Node: Debug Output34433
Node: Input Control34806
Node: Dnl35255
Node: Changequote35927
Node: Changecom36902
Node: Changeword37976
Node: M4wrap40081
Node: File Inclusion40931
Node: Include41225
Node: Search Path42659
Node: Diversions43198
Node: Divert44009
Node: Undivert44822
Node: Divnum46340
Node: Cleardiv46980
Node: Text handling47712
Node: Len48226
Node: Index48502
Node: Regexp48946
Node: Substr49729
Node: Translit50191
Node: Patsubst51108
Node: Format52654
Node: Arithmetic53846
Node: Incr54160
Node: Eval54524
Node: UNIX commands56781
Node: Syscmd57162
Node: Esyscmd57656
Node: Sysval58285
Node: Maketemp58649
Node: Miscellaneous59335
Node: Errprint59602
Node: M4exit60308
Node: Frozen files60956
Node: Compatibility64002
Node: Extensions64352
Node: Incompatibilities65872
Node: Other Incompat66205
Node: Concept index67616
Node: Macro index79852

End tag table
