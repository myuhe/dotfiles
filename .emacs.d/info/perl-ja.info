




File: perl-ja.info, Node: Top, Next: Copying, Prev: (dir), Up: (dir)

PERL5
*****

This is Edition 0.1, last updated Dec 30, 1998, of `The Perl5 Manual',
for Perl, Version 5.00.

参照しやすいように Perl のマニュアルは、いくつかの節に分割しました。

* Menu:

* Copying::			
* Function Index::		関数索引
* Variable Index::		変数索引
* Concept Index::		概念索引


(初めて、1通り読もうと考えているならば、ここに並べた順番で読めば、おそ
らく前方参照を減らすようになっていると思います。)

プログラムの実行時に何か変なことが起こって、どこを参照したらよいかわか
らない場合には、取り敢えず `-w' スイッチを試してみてください。これで、
問題か所を特定できる場合も、多々あります。





File: perl-ja.info, Node: Copying, Next: Function Index, Prev: Top, Up: Top

Copying
*******

この Texinfo 形式の Perl5 の日本語マニュアルは、

     吉村寿人さん( UXM54026@pcvan.or.jp,
                   JAE00534@niftyserve.or.jp,
                   ideal@mix.or.jp,
                   net49602@asciinet.or.jp )

によって翻訳された Perl5 日本語マニュアルを、以下の両名が Texinfo 形式
に変換したものです。

   * 土屋雅稔 <tsuchiya@pine.kuee.kyoto-u.ac.jp>
   * 大城尚紀 <oshiro@tec.u-ryukyu.ac.jp>

このマニュアルの著作権は、翻訳者である吉村さんに帰属します。配布及び再
利用については、GPL または Artistic License に従います。ただし、現在は、
まだ校正作業中ですので、再配布は御遠慮下さい。

なお、Texinfo に変換する際に、文書の大意を変えない範囲で多少の編集を行
ないました。そのため、文書の順が元のマニュアルと一致しない部分や、抜け
落ちている文があります。






File: perl-ja.info, Node: 概要, Next: データ構造, Prev: Copying, Up: Top

概要
****

Perl は、テキストファイルを読み取り、そこから情報を引き出し、その情報
を元に様々な報告を行なうように設計された、インタプリタ言語です。また、
多くのシステムマネジメントの作業を行なうのに適した言語でもあります。こ
の言語は、綺麗さ (小規模、エレガント、最少) ではなく、実用性(使い易さ、
効率、完全性)を目指しています。

この言語は、(少なくとも作者の意見では) C, sed, sh の良い部分を組み合わ
せているので、これらの言語に馴染みのある方には、それほど難しいものでは
ないでしょう。(言語歴史学者はまた、csh, Pascal あるいは BASIC-PLUS の
痕跡にも気付くかもしれません。) 式の構文はかなりの部分で、C の式の構文
に対応したものとなっています。多くの UNIX のユーティリティとは違って、
Perl はデータの大きさに恣意的な制限を設けません。つまり Perl では、メ
モリさえ十分にあれば、ファイルを丸ごと1つの文字列に入れてしまうことも
できます。再帰の深さにも制限がありません。また、連想配列が使用するハッ
シュテーブルは、パフォーマンスを損なわないように、必要に応じて、自動的
に大きくなります。Perl では、大量のデータをすばやく走査できるように、
工夫を凝らしたパターンマッチの技術を使っています。テキストの走査のため
に設計されてはいますが、Perl では、バイナリデータを扱うこともできます
し、(dbm が使えるところでは) dbm ファイルを連想配列のようにして扱うこ
ともできるようになっています。データフロートレース機構を使って、単純ミ
スによるセキュリティホールを塞ぐようにしているため、多くの場合、setuid
Perl スクリプトは C のプログラムよりも安全です。

普通は sed や awk や sh で書くような問題でも、少し荷が重すぎるようなと
き、多少でも実行速度を速くしなければならないときや、C で書く程でもない
ときには、Perl が最適でしょう。また、sed や awk のスクリプトを Perl の
スクリプトに変換するトランスレータも用意されています。

ちょっと待ってください、まだあります...

Perl version 5 は、ほとんど全て書き直しており、以下のようなことが追加
されています:

多くの利便性に関する拡張
     より読みやすい Perl コードが書けるようになりました(たとえ正規表現
     の中でも)。以前の暗号的な変数名は覚えやすい識別子で置き換えること
     ができます。エラーメッセージの情報量が多くなり、オプションの警告
     によって、初心者が犯すような過ちを見つけやすくなっています。これ
     は、あまり強要してはいません。何かおかしな動作を見つけたら、`-w' 
     スイッチを使ってみてください!!!  変な動作が見つからない場合にも 
     `-w' スイッチを使ってください。

単純化された文法
     新しい `yacc' 文法は以前に比べて、半分の大きさになりました。任意
     文法規則の多くが正規化されました。予約語の数は 2/3 ほどに切り詰め
     ています。それにもかかわらず、ほとんどすべての古い Perl のスクリ
     プトを変更なしに使うことができます。

文面に従ったスコープ
     Perl の変数を、C の "auto" 変数のように、字句スコープで宣言するこ
     とができます。これは効率的であるばかりでなく、「大規模プログラミ
     ング」におけるプライバシーの保護にも役立ちます。

任意の多重データ構造
     任意のスカラ変数 (配列の要素でもよい) が、他の変数やサブルーティ
     ンへのリファレンスを持つことができます。名前のない変数やサブルー
     ティンを作ることが簡単にできます。また、Perl がリファレンスの参照
     数を管理してくれます。

モジュール性と再利用性
     Perl ライブラリは、様々なパッケージで簡単に共有できるモジュールと
     いう形で定義されるようになりました。パッケージは、モジュールが公
     開しているインタフェースのすべて、あるいは一部をインポートするこ
     とを選択できます。プラグマ (コンパイラディレクティブのこと) は同
     じ機構によって定義され、使用されます。

オブジェクト指向プログラミング
     パッケージはクラスとして機能します。少しばかり新しい文法を導入し
     て、動的多重継承や仮想メソッドを、明快な方法でサポートしています。
     ファイルハンドルをオブジェクトとして扱うことができるようになりま
     した。

組み込み容易性と拡張性
     Perl は簡単に C や C++ のアプリケーションに組み込めるようになり、
     文書化されているインタフェースを使って、それらのルーティンとの間
     で、相互に呼び出しを行なったりすることができます。プリプロセッサ 
     `XS' は、C や C++ のルーティンを Perl に張り付けるのを手伝ってく
     れます。動的なモジュールのロードがサポートされています。

POSIX 親和性
     主な新規モジュールとして POSIX モジュールがあり、適切なところでオ
     ブジェクトクラスを介するようにして、利用可能な POSIX のルーティン
     や定義をアクセスすることができます。

パッケージコンストラクタとデストラクタ
     新しい `BEGIN' と `END' ブロックは、パッケージがコンパイルされる
     ときと、プログラムが終了した後に制御を受け取るために使われます。
     縮退した形として、`-p' や `-n' スイッチを用いたときには awk の 
     `BEGIN' と `END' のように動作します。

複数の同時 DBM インプリメンテーション
     一つのスクリプトから、Perl プログラムが DBM、NDBM、SDBM、GDBM、バー
     クレイ DB のファイルを、同時にアクセスできるようになりました。実
     際には、旧 `dbmopen' インタフェースは、任意の変数をアクセスメソッ
     ドを定義しているオブジェクトクラスに `tie' する形式に一般化されま
     した。

サブルーティン定義の自動ロード
     実際には、AUTOLOAD 機構では、未定義のサブルーティンコールのために、
     任意の内容を定義することができるようにしています。自動ロードのた
     めだけではありません。

正規表現の拡張
     最長一致ではない数量子を指定することができます。後方参照とならな
     いグループ化が可能になりました。正規表現の中に空白やコメントを書
     くことができ、読みやすさが向上します。すべての古い正規表現にアッ
     パーコンパチな一貫した拡張性機構が組み込まれました。


さあ、誇大広告にはこれくらいにしましょう。

* Menu:

* 環境変数::
* ファイル::
* 診断::
* バグ::
* 注釈::




File: perl-ja.info, Node: 環境変数, Next: ファイル, Prev: 概要, Up: 概要

環境変数
========

HOME
     `chdir' が引数なしで使われたときに参照されます。

LOGDIR
     `chdir' が引数なしで使われたときに、HOME が設定されていないと参照
     されます。

PATH
     サブプロセスを実行するときと、`-S' を使ったときにスクリプトを探す
     ために参照されます。

PERL5LIB
     Perl のライブラリファイルを探すときに、標準のライブラリディレクト
     リとカレントディレクトリよりも前に探しにいくディレクトリを、コン
     マで区切って並べたリストです。PERL5LIB が定義されていないときには、
     PERLLIB が使われます。

PERL5DB
     デバッグのコードを持ってくるためのコマンドを指定します。設定され
     ていないときには

          BEGIN { require 'perl5db.pl' }

     がデフォルトとして使用されます。

PERLLIB
     Perl のライブラリファイルを探すときに、標準のライブラリディレクト
     リとカレントディレクトリよりも前に探しにいくディレクトリを、コン
     マで区切って並べたリストです。PERL5LIB が定義されているときには、
     PERLLIB は使われません。

これら以外は、実行されるスクリプトとチャイルドプロセスから環境変数が使
えるようにするのを除いて Perl は環境変数を使用しません。しかし、setuid 
で実行するスクリプトは何よりもまず以下を行なうようにしてください:

     $ENV{'PATH'}  = '/bin:/usr/bin';    # 必要なものを
     $ENV{'SHELL'} = '/bin/sh' if defined $ENV{'SHELL'};
     $ENV{'IFS'}   = '' if defined $ENV{'IFS'};





File: perl-ja.info, Node: ファイル, Next: 診断, Prev: 環境変数, Up: 概要

ファイル
========

"/tmp/perl-e$$"
     `-e' commands によるテンポラリファイル

"@INC"
     Perl 5 ライブラリの位置





File: perl-ja.info, Node: 診断, Next: バグ, Prev: ファイル, Up: 概要

診断
====

`-w' スイッチは、幾分わかりやすい診断メッセージを出します。

すべての Perl の診断メッセージについては、*Note 診断メッセージ::, を参
照してください。

コンパイル時のエラーでは、エラーの起こった行番号に、次に調べられるはず
だったトークンかトークンの型を示します。(スクリプトが `-e' スイッチで 
Perl に渡される場合には、`-e' スイッチ1が1行とカウントされます。)

setuid スクリプトでは、制限事項が増えるため、"Insecure dependency" と
いったエラーメッセージが表示されることがあります。*Note セキュリティ::, 
を参照してください。

絶対に `-w' スイッチを使った方が良いっていうのは、もう書きましたっけ?





File: perl-ja.info, Node: バグ, Next: 注釈, Prev: 診断, Up: 概要

バグ
====

`-w' スイッチが必須になっていません。

Perl は型のキャストや `atof()' や `sprintf()' のような様々な操作のマシ
ンごとの定義に依存します。

使用している標準入出力ライブラリが、`read' と `write' の間に `seek' や 
`eof' が必要なものであれば、Perl でも同様となります。(ただし、
`sysread()' や `syswrite()' には適用されません。)

組み込みのデータ型には (メモリサイズからくるものを除いて) 恣意的なサイ
ズの制限はありませんが、それでもいくつかの恣意的制限は存在します: どの
識別子も 255 文字より長くてはなりませんし、`-S' を使った時、どの PATH 
も 255 文字より長くてはいけません。正規表現は、内部的にコンパイルされ
た時、32767 バイトを越えることができません。

Perl は本当は「病的折衷主義ガラクタ出力機」(Pathologically Eclectic
Rubbish Lister) を意味していますが、私がそういった事をばらしてはいけま
せん。





File: perl-ja.info, Node: 注釈, Prev: バグ, Up: 概要

注釈
====

Perl のモットーは「やり方は 1 通りではない。」ということです。このマニュ
アルを、後いくつに分割できるかは、宿題とします。

プログラマの3つの美徳は、無精、短気、傲慢です。理由は、キャメルブック
を参照してください。




File: perl-ja.info, Node: データ構造, Next: 構文, Prev: 概要, Up: Top

データ構造
**********

Perl には、スカラ、スカラの配列、「ハッシュ」とも呼ばれるスカラの連想
配列という 3 つのデータ構造があります。通常の配列は 0 を基点とする数値
でインデクスされます。(負の添字は、配列の終わりからインデクスします。) 
ハッシュ配列は、文字列でインデクスされます。

* Menu:

* 変数名::
* コンテキスト::
* スカラ値::
* スカラ値の構成::
* リスト値の構成::





File: perl-ja.info, Node: 変数名, Next: コンテキスト, Prev: データ構造, Up: データ構造

変数名
======

Perl には、スカラ、スカラの配列、「ハッシュ」とも呼ばれるスカラの連想
配列という 3 つのデータ構造があります。通常の配列は 0 を基点とする数値
でインデクスされます。(負の添字は、配列の終わりからインデクスします。) 
ハッシュ配列は、文字列でインデクスされます。

スカラ値の参照は、配列の一要素であるスカラを参照する場合でも、常に名前
に `$' を付けます。以下のようなものが使えます:

     $days               # 単純なスカラ変数 "days" の値
     $days[28]           # 配列 @days の 29 番目の要素の値
     $days{'Feb'}        # ハッシュ %days の 'Feb' の値
     $#days              # 配列 @days の最後のインデクス値

ただし、配列全体や配列のスライスは `@' で示します:

     @days               # ($days[0], $days[1],..., $days[n])
     @days[3,4,5]        # @days[3..5] と同じ
     @days{'a','c'}      # ($days{'a'},$days{'c'}) と同じ

ハッシュ全体は `%' で示します:

     %days               # (key1, val1, key2, val2,...)

さらに、サブルーティンは名前の前に `&' を付けて示しますが、曖昧になら
なければ、(英語でもほとんど使われなくなった "do" のように)省略すること
ができます。シンボルテーブルのエントリは、名前に `*' を付けて示すこと
ができますが、使用に際しては十分に注意する必要があります。

変数のすべての型には、それぞれの名前空間があります。衝突を心配せずに、
スカラ変数、配列、ハッシュ (ついでにファイルハンドルやサブルーティン名、
ラベル) に、同じ名前を付けることができます。つまり、`$foo' と `@foo' 
は2つの異なる変数であるということです。また、`$foo[1]' は `@foo' の一
部であって、`$foo' の一部ではありません。奇妙に思えるかもしれませんが、
それで良いのです。奇妙なのですから。

変数と配列の参照は、いつも `$'、`@'、`%' で始まりますから、「予約」語
は、変数名としては、本当の意味で予約されているわけではありません。(し
かしながら、先頭に特別な文字を付けない、ラベルやファイルハンドルとして
は、予約されていることになります。たとえば、`log' といった名前のファイ
ルハンドルを使うことはできません。ヒント: `open(log,'logfile')' などで
はなく、`open(LOG,'logfile')' としてください。大文字のファイルハンドル
を使えば、読みやすくもなりますし、将来に渡る予約語との衝突も避けられま
す。大文字と小文字は区別されますから、`FOO'、`Foo'、`foo' は、すべて違
う名前です。英字と下線で始まる名前は、名前の一部に数字や下線を含むこと
ができます。

そのような英数字の名前を、その型のオブジェクトへのリファレンスを返す式
で置き換えることも可能です。詳しくは、*Note リファレンスとデータ構造の
ネスト::, を参照してください。

数字で始まる名前には、数字しか含めることができません。英字、下線、数字
以外の文字で始まる名前は、`$%' や `$$' のように 1 文字に限定されます。
(これら 1 文字の名前の多くは、Perl があらかじめ意味を定めています。た
とえば、`$$' はカレントプロセスのプロセス id を示します。) (訳注:
`$^A' など 2 文字が続く変数が Version 3 の終わり頃から、いくつかできて
います。ただし、^A の 2 文字を control-A の1 文字 (16 進数の 0x01) で
置き換えることも可能です。)





File: perl-ja.info, Node: コンテキスト, Next: スカラ値, Prev: 変数名, Up: データ構造

コンテキスト
============

Perl における演算や値の解釈は、その演算や値の置かれたコンテキストから
の要求に依存する場合があります。このコンテキストというものには大きく2
つあり、スカラコンテキストとリストコンテキストと呼ばれます。リストが要
求されるコンテキストではリスト値を返し、そうでなければスカラ値を返すよ
うな演算も存在します。(そのような演算については、ドキュメントでその演
算に触れるときに付記しています。)言い方を変えると、Perl では、ある種の
演算が1つの値を返して欲しいか、複数の値を返して欲しいかによって多重定
義されているということです。("fish" や "sheep" といった、単複同形の英
単語と似ているかもしれません。) 逆に、演算子は自分の引数が、スカラコン
テキストとリストコンテキストのどちらで解釈されるかを決めてしまいます。
たとえば、

     int( <STDIN> )

と書くと、int 演算子は、自分の引数である <STDIN> 演算子がスカラコンテ
キストで評価されることを期待するため、<STDIN> は、STDIN から1行を読み
出し int 演算子に渡します。int 演算子は、その行から整数値を取り出して
返すことになります。これに比べて、もし、

     sort( <STDIN> )

と書いたなら、sort 演算子は、<STDIN> 演算子がリストコンテキストで評価
されるようにするため、<STDIN> は STDIN から読める限り最後の行まで読み
出し、その行のリストを sort のルーティンに返します。sort ルーティンは
受け取った行のリストをソートして、ソートした結果のリストが値となります。

代入演算は少し特殊です。代入では、右引数のコンテキストを決めるために左
引数が使われます。スカラへの代入では、右側をスカラコンテキストで評価し
ますが、配列や配列のスライスに対する代入では、右側をリストコンテキスト
で評価することになります。リストへの代入も右側をリストコンテキストで評
価することになります。

ユーザが定義するサブルーティンは、自分がスカラコンテキストで呼ばれたか、
リストコンテキストで呼ばれたかを意識することができますが、多くのサブルー
ティンでは意識する必要もないでしょう。スカラ値は自動的にリストの要素に
なることができるからです。*Note 組み込み関数::,の wantarray の項を参照
してください。





File: perl-ja.info, Node: スカラ値, Next: スカラ値の構成, Prev: コンテキスト, Up: データ構造

スカラ値
========

スカラ変数には、数値、文字列、リファレンスのような、さまざまな種類の単
独データを保持することができます。一般に、1つの形式から他への変換は透
過的です。(スカラに複数の値を保持することはできませんが、複数の値を持っ
ている配列やハッシュへのリファレンスを保持することができます。)スカラ
の値どうしは、自動的に変換されるので、スカラを返す演算や関数では、コン
テキストが文字列を要求しているのか、数値を要求しているのかを意識する必
要がないのです (実際は意識することができないのですが)。

スカラ値は、その値が空文字列か数値の 0 (あるいは同値な文字列 '') 以外
の場合には、ブール値の真として扱われます。ブール値が必要となるコンテキ
ストは、単に特別なスカラコンテキストとして扱われます。スカラのヌルには、
実は defined と undefined の 2 種類があります。undefined のヌルは、エ
ラーがあったときや、ファイルの終わりに達したとき、初期化していない変数
や配列要素を参照したときなど、何かに対する実際の値が存在しないときに返
されます。undefined のヌルは、最初に defined であるかのように使ったと
きに defined となり得ますが、それに先立って値が defined かどうかを調べ
るために defined() 演算子を使うことができます。

配列の大きさはスカラ値です。配列 `@days' の大きさは、csh のように 
`$#days' を評価するとわかります。(実際は、これは大きさではなく、最後の
要素に対する添え字になります。(通常は) 0 番目の要素があるからです。)
`$#days' に代入を行なうと、配列の大きさも変化します。この方法で配列を
小さくすると、見えなくなった部分の値は破壊されます。小さくした配列を再
び大きくしても、以前存在した要素に対する前の値が回復することはありませ
ん。(Perl 4 では回復可能でしたが、デストラクタが期待どうりの時点で呼ば
れることを保証するために、これを止めました。)大きくなるであろう配列を、
あらかじめ大きくしておくことで、ある程度の効率を得ることもできます。
(最後の要素よりも後ろに離れた位置に代入を行なうことでも、配列を大きく
することができます。)配列に空リスト () を代入すると何も無い状態にまで、
切り詰めることができます。以下の 2 つは等価です:

     @whatever = ();
     $#whatever = $[ - 1;

名前のある配列をスカラコンテキストで評価すると、配列の大きさが返されま
す。(これは、リストに対しては成り立ちません。この場合には、C のコンマ
演算子と同じく最後の値が返されます。)以下は常に真となります:

     scalar(@whatever) == $#whatever - $[ + 1;

Perl version 5 では `$[' の意味を変更し、`$[' を設定していないファイル
で、他のファイルがこの変数を変更しているかどうかを、気にする必要がなく
なりました。(言い換えると、`$[' は使わないほうが良いと言うことです。)
ですから、普通は以下のようになります。

     scalar(@whatever) == $#whatever + 1;

ハッシュをスカラコンテキストで評価した場合、ハッシュの中に1つでも 
key/value のペアが登録されているときにだけ、真となる値が返されます。
(key/value のペアが登録されていれば、返される値は、使用しているエント
リの数と、割り付けられているエントリの数を、スラッシュで区切った文字列
です。これは、与えたデータに対して、Perl の (コンパイルされた) ハッシュ
のアルゴリズムが、うまく動作しないかを確認するときくらいにしか使えませ
んが。たとえば、ハッシュに 10,000 のものを入れ、`%HASH' をスカラコンテ
キストで評価したときに "1/16" が得られれば、16 のうち 1 つのエントリだ
けが使われ、おそらくそこに 10,000 すべてが入っていることを意味します。
ほとんど起こりそうもないことですが。)





File: perl-ja.info, Node: スカラ値の構成, Next: リスト値の構成, Prev: スカラ値, Up: データ構造

スカラ値の構成
==============

数値リテラルは、慣習的な浮動小数点数と整数の形式で示されます:

     12345
     12345.67
     .23E-10
     0xffff              # 16 進数
     0377                # 8 進数
     4_294_967_296       # 下線は読みやすさのため

文字列リテラルは、シングルクォートかダブルクォートで区切られます。これ
らは、シェルのクォートと同じように扱われ、ダブルクォートの文字列リテラ
ルでは、バックスラッシュの置換と変数の置換が行なわれ、シングルクォート
の文字列では、("\'" と "\\"を除いて)これらの置換は行なわれません。普通
の UNIX でのバックスラッシュの置換規則は、改行やタブを始め、ある種の変
わった形式のためにも使われます。一覧は perlop manpage の qq のところを
ご覧ください。

また、文字列に直接、改行を埋め込むこともできます。つまり、文字列は、開
始した行で終了する必要はないと言うことです。これは素晴らしいのですが、
終了のクォートを付け忘れた場合には、次にクォート文字が見つかるまでの間、
Perl はエラーを見つけることができなくなります。それは、スクリプト上で
ずっと先になるかもしれません。文字列中での変数の置換は、スカラ変数と配
列と配列のスライスに限定されています。(言い換えれば、$ や@ で始まる識
別子か、それに大括弧で括った添え字をつけたものです。)次のプログラムは 
"The price is $100." と印字します。

     $Price = '$100';                    # 置換されない
     print "The price is $Price.\n";     # 置換される

いくつかのシェルと同じように、識別子の前後に中括弧を入れて、つながって
いる英数字から切り離すことができます。また、シングルクォート文字列は、
その前の単語とスペースで区切らなければならないことに注意してください。
シングルクォートが (使わないように言われていますが) 識別子を構成する文
字として有効なものだからです (perlmod manpage のパッケージのところを参
照してください)。

`__LINE__' と `__FILE__' という 2 つの特別なリテラルがあって、プログラ
ムのその時点での行番号とファイル名を示します。これらは、独立したトーク
ンとしてだけ使用することができ、文字列の中に展開することはできません。
さらに、トークン `__END__' は、スクリプトを納めたファイルの実際の最後
よりも前で、論理的にスクリプトが終わるとき、その位置を示すのに使うこと
ができます。それ以降のテキストは無視されますが、DATA というファイルハ
ンドルを通して読むことができます。(ファイルハンドル DATA は、main のス
クリプトからだけ読むことができ、require されたファイルや eval された文
字列からは読めません。)コントロール文字 ^D と ^Z を `__END__' の同義語
として使うことができます。

文法的に別の解釈ができない単語は、クォート文字列であるかのように扱われ
ます。これは「裸の単語」と言われます。ファイルハンドルやラベルと同様に、
小文字だけからなる裸の単語は、将来的に予約後とぶつかる危険がありますか
ら、そのような単語があった場合、`-w' スイッチをつけることで、Perl がそ
の単語を指摘してくれます。裸の単語をなくして欲しいという方もいらっしゃ
います。もし、

     use strict 'subs';

と書いておけば、サブルーティンコールと解釈できない裸の単語がコンパイル
時にエラーとなります。この制約は囲っているブロックの終わりまで有効です。
内側のブロックで `no strict 'subs'' と書くことで、この機能を撤回するこ
ともできます。

配列変数は、ダブルクォート文字列中で、配列のすべての要素を変数 `$"' 中
に示す区切文字 (デフォルトはスペース) でつなげて展開されます。以下は同
値です:

     $temp = join($",@ARGV);
     system "echo $temp";

     system "echo @ARGV";

検索パターン (ここでも、ダブルクォートのような置換が行なわれます) の中
では、解釈する上で曖昧となる場合ができてきます。`/$foo[bar]/' は、
`/${foo}[bar]/' と解釈される (この場合 `[bar]' は、正規表現の文字クラ
ス) のでしょうか、`/${foo[bar]}/' と解釈される (この場合 `[bar]' は、
配列 `@foo' の添え字) のでしょうか。`@foo' が他に存在しない場合には、
明らかに文字クラスとなります。@foo が存在すれば、Perl が `[bar]' の意
味に見当をつけますが、たいてい正しい解釈をします。もし、見当があたって
いないときや、偏執的にこだわりたい時には、上に書いたように中括弧を付け
て、強制的に解釈のしかたを決めることができます。

行指向形式のクォートは、シェルの「ヒアドキュメント」構文をもとにしてい
ます。<< の後にクォートされるものを終了する文字列を示し、現在行の次の
行からその終了文字列に一致する行の前の行までが、その項目の値となります。
終了文字列には、識別子(単語) かクォートされたテキストが許されます。クォー
トされている場合には、そのクォート文字の種類によって、実際にクォートさ
れるテキストの扱いが、通常のクォートと同様にして決められます。クォート
されていない識別子とした場合には、ダブルクォートのように扱われます。<< 
と識別子の間にスペースを入れてはいけません。(もしスペースを入れると、
空識別子として扱われ、最初の空行にマッチするようになります。下記の 
Merry Christmas の例を参照してください。)終了文字列は、その終了を示す
行に単独で (クォートもしないで、前後に空白を入れることも無く) 置かなけ
ればなりません。

         print <<EOF;    # 上記と同じ
     The price is $Price.
     EOF

         print <<"EOF";  # これも同じ
     The price is $Price.
     EOF

         print << x 10;  # 正しいが、使わないように。<<"" を使う。
     Merry Christmas!

         print <<`EOC`;  # 実際にクォートされたコマンドを実行
     echo hi there
     echo lo there
     EOC

         print <<"foo", <<"bar"; # スタックすることも可能
     I said foo.
     foo
     I said bar.
     bar

         myfunc(<<"THIS", 23, <<'THAT");
     Here's a line
     or two.
     THIS
     and here another.
     THAT

文を終了するためのセミコロンを付けなければいけないことは、忘れないでく
ださい。以下のようにしたいのではないと言うことを Perl が知ることはでき
ないのですから:

         print <<ABC
     179231
     ABC
         + 20;





File: perl-ja.info, Node: リスト値の構成, Prev: スカラ値の構成, Up: データ構造

リスト値の構成
==============

リスト値は、個々の値をコンマで区切って (必要に応じて括弧で括って) 示さ
れます:

     (LIST)

リスト値が要求されていないコンテキストでは、リストリテラルの値としては、
C のコンマ演算子の場合のように、最後の要素の値が使われます。たとえば、

     @foo = ('cc', '-E', $bar);

は、リスト値全体を配列 `@foo' に代入しますが、

     $foo = ('cc', '-E', $bar);

は、変数 `$bar' の値を変数 `$foo' に代入します。本物の配列がスカラコン
テキストで評価されたときの値は、その配列の大きさとなります。以下の例で
は、`$foo' に 3 という値が代入されます:

     @foo = ('cc', '-E', $bar);
     $foo = @foo;                # $foo は 3 となる

リストリテラルの閉じ括弧の前には余分にコンマを置いてかまいませんので、

     @foo = (
         1,
         2,
         3,
     );

と書くことができます。

リストの中にリストがある場合には、自動的に展開されてしまいます。これは、
外側のリストが評価されると、リストの個々の要素がリストコンテキストで評
価され、その結果のリスト値の個々の値が、元のリストの要素であるかのよう
に展開されるのです。つまり、リストの中では配列も、その性質が現れてきま
せん。

     (@foo,@bar,&SomeSub)

というリストは、`@foo' のすべての要素の後に `@bar' のすべての要素を続
け、その後に SomeSub というサブルーティンが返すすべての要素を続けたも
のを要素として持ちます。展開されないリストのリファレンスを作るためには、
perlref manpage を参照してください。

空リストは () で表わされます。リスト中で空リストを展開しても何も起こり
ません。つまり、 ((),(),()) は () と等価です。同様に、要素のない配列を
展開することは、その場所に何も展開しなかったのと同じことになります。

リスト値にも通常の配列と同じように、添え字をつけることができます。リス
トには、曖昧さをなくすために、括弧を付けなくてはなりません。例:

     # stat はリスト値を返す
     $time = (stat($file))[8];

     # 16 進の数字を探す
     $hexdigit = ('a','b','c','d','e','f')[$digit-10];

     # 「逆コンマ演算子」
     return (pop(@foo),pop(@foo))[0];

リストを構成する個々の要素すべてに代入が許される場合には、全体のリスト
に代入を行なうことができます:

     ($a, $b, $c) = (1, 2, 3);

     ($map{'red'}, $map{'blue'}, $map{'green'})
                                     = (0x00f, 0x0f0, 0xf00);

リストの最後の要素は、配列やハッシュでもかまいません:

     ($a, $b, @rest) = split;
     local($a, $b, %rest) = @_;

実際は、リストの任意の要素として配列を使うことができますが、リスト中の
最初の配列が、右辺の値をすべて取り込んでしまうため、それ以降のものはヌ
ルしか受け取ることができません。これは、local() や my() では有用かもし
れません。

ハッシュリテラルは key と value と解釈される値のペアで構成されます:

     # 上記の map の代入と同じ
     %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);

key と value のペアの間には `=>' 演算子を使うと読みやすくなります (実
際のところ `=>' 演算子は、見た目に目立つコンマの同義語でしかありません):

     %map = (
              'red'   => 0x00f,
              'blue'  => 0x0f0,
              'green' => 0xf00,
            );

スカラコンテキストにおける配列代入は、代入の右辺の式で作られる要素の数
を返します:

     $x = (($foo,$bar) = (3,2,1));       # $x は 2 ではなく 3

これは、ブールコンテキストでリストの代入を行ないたい時に、とても便利で
す。多くのリスト関数は最終的に空リストを返し、それが代入されると 0 と
なり、偽として解釈されるからです。




File: perl-ja.info, Node: 構文, Next: 演算子と優先順位, Prev: データ構造, Up: Top

構文
****

Perl のスクリプトは宣言と実行文の列で構成されます。Perl で宣言の必要が
あるのは、レポートフォーマットとサブルーティンだけです。これらの宣言に
ついては、後ほど詳しく述べます。ユーザが造った初期化していないすべての
オブジェクトは、代入などの明示的な操作で定義されない限り、ヌルもしくは 
0 の値を持っているとものとして扱われます。(しかし、未定義の値を使った
場合に警告を出すようにすることもできます。) sed や awk のスクリプトで
は、実行文の列は入力行ごとに繰り返して実行されますが、Perl では、実行
文の列は 1 度実行されるだけです。これは、入力ファイルに対して明示的に
自分でループを行なわなければならないことを意味していますが、どのファイ
ルのどの行に注目するかを自由に制御できることも意味しています。(本当は、
私はウソを付いています。`-n' か `-p' スイッチを使えば、暗黙にループを
行なうことができます。sed や awk のように必須のデフォルトになっていな
いだけのことです。)

Perl は、ほとんどすべての部分で、自由形式の言語です。(理由は自明である
と思われますが、フォーマット宣言が唯一の例外となっています。)コメント
は、文字 "#" によって示され、行末までとなります。C のスタイルの /* */ 
を使おうとした場合には、文脈によって、割り算かパターンマッチかのいずれ
かに解釈され、C++ の // コメントは、空の正規表現に見えます。使わないよ
うにしましょう。

宣言は実行文が置けるところであれば、どこにでも置けますが、実行文の列を
実行するのに影響を与えません。宣言はコンパイル時にのみ意味を持ちます。
普通は、すべての宣言をスクリプトの最初か、最後にまとめておきます。

Perl 5 から、サブルーティンを宣言することで、宣言した場所以降では、サ
ブルーティン名をリスト演算子のようにして使うことができるようになりまし
た。サブルーティンは以下のように、定義しないで宣言することができます:

     sub myname;
     $me = myname $0 or die "can't get myname";

リスト演算子として働きはしますが、単項演算子ではありませんので、`||' 
ではなく `or' を使うことに注意してください。

サブルーティンの宣言は、`use' 文を使ってインポートすることもできます。

Perl 5 からはまた、実行文の列に字句スコープの変数宣言を、含めることが
できるようになりましたが、変数名を宣言することを除けば、宣言文は通常の
実行文と同様に働き、通常の実行文であるかのように他の文の中に埋め込まれ
るのです。

* Menu:

* 単純実行文::
* 複合実行文::





File: perl-ja.info, Node: 単純実行文, Next: 複合実行文, Prev: 構文, Up: 構文

単純実行文
==========

唯一の単純実行文は、副作用を目的として評価される式です。個々の単純実行
文は、それがブロックの最後の文でなければ、お尻にセミコロンを付けなくて
はなりません。ブロックの最後の文では、セミコロンが省略可能です。(ブロッ
クが複数の行から成るのであれば、やはりセミコロンは付けた方が良いでしょ
う。あとで、行を増やすこともあるでしょうから。) eval {} や do {} のよ
うに複合文に見える演算子もありますが、これは複合文ではありません (式の
中の「項」でしかありません) し、実行文の最後の項となった場合には、明示
的にセミコロンが必要です。

どんな単純実行文にも、最後のセミコロン (もしくは、ブロックの終わり) の
直前に 1 つだけ修飾子を付けることができます。修飾子としては:

     if EXPR
     unless EXPR
     while EXPR
     until EXPR

が使えます。

if 修飾子と unless 修飾子は、英語ができる方なら、期待通りの意味となり
ます。while 修飾子と until 修飾子も通常の "while loop" の意味 (条件が
先に評価される) となりますが、do-BLOCK (と現在は使わないようにしている 
do-SUBROUTINE 文) に対して使用すると、条件が評価される前に 1 度だけブ
ロックが実行されます。これは:

     do {
         $_ = <STDIN>;
         ...
     } until $_ eq ".\n";

のようなループが書けるようにするためです。perlfunc manpage を参照して
ください。後述するループ制御文は、この構文では使用できないことにも注意
してください。修飾子にはループラベルを付けることができないからです。ご
めんなさい。そういったことがしたい場合には、別のブロックを被せてしまう
とよいでしょう。)





File: perl-ja.info, Node: 複合実行文, Prev: 単純実行文, Up: 構文

複合実行文
==========

Perl では、スコープが定義される実行文の列をブロックと呼んでいます。と
きにはブロックは、そのブロックを含むファイルの単位で区切られ (この場合 
require で読み込まれるか、プログラム全体ということになります)、また文
字列として区切られる場合もあります (eval される場合です)。

しかし、一般にはブロックは中括弧 (`{}') で区切られるのが普通です。この
構文上の構造を BLOCK と呼ぶことにします。

以下の複合実行文を、流れの制御のために使うことができます:

     if (EXPR) BLOCK
     if (EXPR) BLOCK else BLOCK
     if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
     LABEL while (EXPR) BLOCK
     LABEL while (EXPR) BLOCK continue BLOCK
     LABEL for (EXPR; EXPR; EXPR) BLOCK
     LABEL foreach VAR (ARRAY) BLOCK
     LABEL BLOCK continue BLOCK

C や Pascal と違って、文ではなく、BLOCK を使って定義されていることに注
意してください。これは中括弧が必須ということで、中ぶらりんの実行文が許
されないということです。中括弧を使わないで条件を書きたい場合には、方法
がいくつかあります:

     if (!open(FOO)) { die "Can't open $FOO: $!"; }
     die "Can't open $FOO: $!" unless open(FOO);
     open(FOO) or die "Can't open $FOO: $!";     # FOO or bust!
     open(FOO) ? 'hi mom' : die "Can't open $FOO: $!";
                         # a bit exotic, that last one

はすべて同じことをします。

if 文は見た通りです。BLOCK は必ず中括弧で括られますから、if と else の
対応が曖昧になることはありません。if の代わりに unless を使えば、テス
トの意味が逆になります。

while 文は、式が真である間 (評価結果が、空文字列、0、"0" のいずれかで
ない間) ブロックを実行します。LABEL はあっても無くてもよく、もし存在す
る時には、識別子にコロンを続けたものです。LABEL は、next、last、redo 
というループ制御文が、ループを識別できるようにするものです (以下を参照)。
continue BLOCK があれば、C の for ループの 3 番目の部分のように、次に
条件が評価される直前に実行されます。ですから、(C の continue 文と同様
に) たとえ next 文でループを進めるときにも、ループ変数のインクリメント
が行なうことができます。

while を until で置き換えると、テストの意味が逆になりますが、繰り返し
の前に、条件が評価されることは変わりません。

if 文または while 文において、"(EXPR)" を BLOCK で置き換えることができ、
ブロックの最後に実行した文が真であれば、条件も真となります。(この機能
は Perl 5 でも機能しますが、使わないようにしてください。"if BLOCK" の
代わりに "if (do BLOCK)" とすればよいでしょう。)

C スタイルの for ループは、完全に対応する while ループと同じように動作
します:

     for ($i = 1; $i < 10; $i++) {
         ...
     }

は、

     $i = 1;
     while ($i < 10) {
         ...
     } continue {
         $i++;
     }

と同じことです。

foreach ループは通常のリスト値で繰り返しを行ない、変数 VAR にそのリス
トの値を順番に設定します。その変数は、(前もって my で宣言したのでなけ
れば) 暗黙のうちにループ内にローカルとなり、ループを抜けると以前の値に
戻ります。キーワードの foreach は、実際にはキーワード for の同義語であ
り、読みやすさのために foreach を、簡潔さのために for を使い分けること
が可能です。VAR を省略すると、`$_' に個々の値が順に設定されます。もし、
ARRAY が (リスト値を返す式ではなく) 本物の配列の時には、ループの中で 
VAR を修正することによって、その時に対応している配列の要素自身を修正す
ることができます。例:

     for (@ary) { s/foo/bar/; }

     foreach $elem (@elements) {
         $elem *= 2;
     }

     for ((10,9,8,7,6,5,4,3,2,1,'BOOM')) {
         print $_, "\n"; sleep(1);
     }

     for (1..15) { print "Merry Christmas\n"; }

     foreach $item (split(/:[\\\n:]*/, $ENV{'TERMCAP'})) {
         print "Item: $item\n";
     }

BLOCK 自身は (ラベルが付いていても、いなくても) 意味的には、1度だけ実
行されるループと同じです。つまり、ブロックを抜けたり、再度実行したりす
るのに、ループ制御文が使えるということです。continue BLOCK はあっても
無くてもかまいません。この構成は、case 構文を組み立てるのに便利です。

     SWITCH: {
         if (/^abc/) { $abc = 1; last SWITCH; }
         if (/^def/) { $def = 1; last SWITCH; }
         if (/^xyz/) { $xyz = 1; last SWITCH; }
         $nothing = 1;
     }

Perl には、公に switch 文は存在しません。同値なものが既にいくつもある
からです。上にあげたものの他に、

     SWITCH: {
         $abc = 1, last SWITCH  if /^abc/;
         $def = 1, last SWITCH  if /^def/;
         $xyz = 1, last SWITCH  if /^xyz/;
         $nothing = 1;
     }

とも書けます。(これは、ループ制御「演算子」を式の中で使えることに気が
付けば、見た目ほど奇妙なものではありません。普通の C のコンマ演算子で
す。)

また、

     SWITCH: {
         /^abc/ && do { $abc = 1; last SWITCH; };
         /^def/ && do { $def = 1; last SWITCH; };
         /^xyz/ && do { $xyz = 1; last SWITCH; };
         $nothing = 1;
     }

とも書けますし、もう少し「正当な」switch 文のように整形すると:

     SWITCH: {
         /^abc/      && do {
                             $abc = 1;
                             last SWITCH;
                        };

         /^def/      && do {
                             $def = 1;
                             last SWITCH;
                        };

         /^xyz/      && do {
                             $xyz = 1;
                             last SWITCH;
                         };
         $nothing = 1;
     }

となりますし、

     SWITCH: {
         /^abc/ and $abc = 1, last SWITCH;
         /^def/ and $def = 1, last SWITCH;
         /^xyz/ and $xyz = 1, last SWITCH;
         $nothing = 1;
     }

や、醜くも

     if (/^abc/)
         { $abc = 1 }
     elsif (/^def/)
         { $def = 1 }
     elsif (/^xyz/)
         { $xyz = 1 }
     else
         { $nothing = 1 }

としてもよいでしょう。




File: perl-ja.info, Node: 演算子と優先順位, Next: 正規表現, Prev: 構文, Up: Top

演算子と優先順位
****************

* Menu:

* 優先順位::
* 項とリスト演算子 (左方向)::
* アロー演算子::
* インクリメントとデクリメント::
* 指数演算子::
* 単項演算子::
* 拘束演算子::
* 乗法演算子::
* 加法演算子::
* シフト演算子::
* 名前付き単項演算子::
* 比較演算子::
* 等価演算子::
* ビットごとの AND::
* ビットごとの OR と XOR::
* C スタイルの論理積::
* C スタイルの論理和::
* 範囲演算子::
* 条件演算子::
* 代入演算子::
* コンマ演算子::
* リスト演算子 (右方向)::
* 論理否定::
* 論理積::
* 論理和と排他論理和::
* Perl にない C の演算子::
* クォートとクォートのような演算子::
* I/O 演算子::
* 定数の畳み込み::
* 整数演算::





File: perl-ja.info, Node: 優先順位, Next: 項とリスト演算子 (左方向), Prev: 演算子と優先順位, Up: 演算子と優先順位

優先順位
========

Perl の演算子には、以下のような結合性と優先順位 (高い優先順位から低い
ものへ並べている) があります。C から持ってきた演算子の優先順位は、C で
の優先順位が多少おかしくても、そのままにしてあることに注意してください。
(これによって、C を使っている方が Perl に移りやすくなっています。)

     左結合      項 リスト演算子 (左方向に対して)
     左結合      ->
     非結合      ++ --
     右結合      **
     右結合      ! ~ \ 単項の+ 単項の-
     左結合      =~ !~
     左結合      * / % x
     左結合      + - .
     左結合      << >>
     非結合      名前付き単項演算子
     非結合      < > <= >= lt gt le ge
     非結合      == != <=> eq ne cmp
     左結合      &
     左結合      | ^
     左結合      &&
     左結合      ||
     非結合      ..
     右結合      ?:
     右結合      = += -= *= などの代入演算子
     左結合      , =>
     非結合      リスト演算子 (右方向に対して)
     左結合      not
     左結合      and
     左結合      or xor





File: perl-ja.info, Node: 項とリスト演算子 (左方向), Next: アロー演算子, Prev: 優先順位, Up: 演算子と優先順位

項とリスト演算子 (左方向)
=========================

「項」は Perl でもっとも優先順位が高いものです。これには、変数、クォー
トとクォート的な演算子、括弧で括った任意の式、引数を括弧で括った任意の
関数が含まれます。実際には、この意味では本当の関数はなく、リスト演算子
と関数のように働く単項演算子が、引数を括弧で括るためそのように見えます。
これらはすべて perlfunc manpage に記述しています。

もし、リスト演算子 (`print()' など) や単項演算子 (`chdir()' など) の名
前の後に開き括弧が続く場合には、その演算子と括弧内の引数は、通常の関数
呼び出しのように、もっとも高い優先順位で処理されます。

括弧が無い場合には、`print', `sort', `chmod' のようなリスト演算子の優
先順位は、演算子の左側をからすると非常に高く、右側からすると非常に低く
見えます。たとえば、

     @ary = (1, 3, sort 4, 2);
     print @ary;         # 1324 と印字

では、`sort' の右のコンマは `sort' よりも前に評価されます (右側から見
ると `sort' の優先順位が低い) が、左側のコンマは `sort' のあとに評価さ
れます (左側から見ると `sort' の方が優先順位が高くなっている)。言い方
を変えると、リスト演算子は自分の後にある引数をすべて使って処理を行ない、
その結果を自分の前の式に対する「項」であるかのように見せるということで
す。ただし、括弧には気を付けないといけません:

     # 以下は print を行なう前に exit を評価します:
     print($foo, exit);  # 明らかにやりたいことではないでしょう。
     print $foo, exit;   # これでもない。

     # 以下は exit を評価する前に print を行ないます:
     (print $foo), exit; # これがしたかった。
     print($foo), exit;  # これでもいい。
     print ($foo), exit; # これも OK。

また、

     print ($foo & 255) + 1, "\n";

の動作を一目見ただけで判断するのは、難しいでしょう。詳しくは、*Note 名
前付き単項演算子::,の節を参照してください。

この他に「項」として解析されるものには、do {} や eval {} の構成、サブ
ルーティンやメソッドの呼び出し、無名のコンストラクタ [] と {} がありま
す。

後の方の*Note クォートとクォートのような演算子::,の節や*Note I/O 演算
子::,の節も参照してください。





File: perl-ja.info, Node: アロー演算子, Next: インクリメントとデクリメント, Prev: 項とリスト演算子 (左方向), Up: 演算子と優先順位

アロー演算子
============

C や C++ と同じように "->" は中置の被参照演算子です。右側が [...] か 
{...} の形の添字であれば、左側は配列かハッシュへのハードリファレンスか
シンボリックリファレンス (あるいは、左辺値 (代入可能) であればハードリ
ファレンスを保持できる場所)でなければなりません。*Note リファレンスと
データ構造のネスト::,を参照してください。

そうでなければ、右側はメソッド名かメソッド名を持った単純スカラ変数で、
左側はオブジェクト (bless されたリファレンス) かクラス名でなければなり
ません。perlobj manpage を参照してください。





File: perl-ja.info, Node: インクリメントとデクリメント, Next: 指数演算子, Prev: アロー演算子, Up: 演算子と優先順位

インクリメントとデクリメント
============================

"++" と "--" は、C の場合と同じように動作します。つまり、変数の前に置
かれれば、値を返す前に変数をインクリメントまたはデクリメントし、後に置
かれれば、値を返した後で変数をインクリメントまたはデクリメントします。

インクリメント演算子には、ちょっと風変わりな機能が組み込まれています。
数値が入った変数や、数値の文脈で使われてきた変数をインクリメントする場
合には、通常のインクリメントとして動作します。しかし、その変数が設定さ
れてからずっと文字列の文脈でしか使われていなくて、空でない 
/^[a-zA-Z]*[0-9]*$/ にマッチする値を持っているときには、個々の文字の範
囲を保ちながら桁あげを行なって、文字列としてインクリメントが行なわれま
す (マジカルインクリメントと呼ばれます):

     print ++($foo = '99');      # '100' と印字
     print ++($foo = 'a0');      # 'a1' と印字
     print ++($foo = 'Az');      # 'Ba' と印字
     print ++($foo = 'zz');      # 'aaa' と印字

デクリメント演算子には、マジカルなものはありません。





File: perl-ja.info, Node: 指数演算子, Next: 単項演算子, Prev: インクリメントとデクリメント, Up: 演算子と優先順位

指数演算子
==========

二項演算子の "**" は指数演算子です。この演算子は、単項のマイナスよりも
結合が強い演算子で、-2**4 は (-2)**4 ではなく、-(2**4) と解釈されます。





File: perl-ja.info, Node: 単項演算子, Next: 拘束演算子, Prev: 指数演算子, Up: 演算子と優先順位

単項演算子
==========

単項演算子の "!" は論理否定を行ないます。つまり not ということです。こ
の演算子の優先順位を低くしたものとして、"not" が用意されています。

単項演算子の "-" は被演算子が数値であれば、算術否定を行ないます。被演
算子が識別子ならば、マイナス記号にその識別子をつなげた文字列が返されま
す。これ以外で被演算子の最初の文字がプラスかマイナスのときには、その記
号を逆のものに置き換えた文字列を返します。この規則の結果、-bareword が 
"-bareword" に等価となります。

単項演算子の "~" はビットごとの否定を行ないます。つまり、1 の補数を返
します。

単項演算子の "+" は、たとえ文字列に対して用いられた場合にも、何もしま
せん。関数名に続けて括弧付きの式を書く場合に、関数の引数リストと解釈さ
れないようにするために用いることができます。(下記「名前付き単項演算子」
の節の例を参照してください。)

単項演算子の "\" はその後に続くものへのリファレンスを生成します。*Note 
リファレンスとデータ構造のネスト::,を参照してください。この用法も文字
列中のバックスラッシュも、後に続くものが解釈されるのを防ぐことになりま
すが、動作を混同しないでください。





File: perl-ja.info, Node: 拘束演算子, Next: 乗法演算子, Prev: 単項演算子, Up: 演算子と優先順位

拘束演算子
==========

二項演算子の "=~" は、式をパターンマッチに拘束します。デフォルトで $_ 
の文字列を検索したり、変更したりする演算があります。この演算子は、その
ような演算を他の文字列に対して行なわせるようにするものです。右引数は、
検索パターン、置換、変換のいずれかです。左引数は、デフォルトの $_ の代
わりに検索、置換、変換の対象となる対象となります。返却値は演算の結果が
成功したか否かです。(右引数が検索パターン、置換、変換ではなく、式であ
れば、それは実行時に決まる検索パターンと解釈されます。これは /o を使わ
ない限り、明示的な検索に比べて効率が落ちます。式が評価されるたびにパター
ンをコンパイルする必要があるからです。)

二項演算子の "!~" は、返される値が論理否定されることを除いて"=~" と同
じです。





File: perl-ja.info, Node: 乗法演算子, Next: 加法演算子, Prev: 拘束演算子, Up: 演算子と優先順位

乗法演算子
==========

二項演算子の "*" は 2 つの数値の積を返します。

二項演算子の "/" は 2 つの数値の商を返します。

二項演算子の "%" は 2 つの数値の剰余を返します。

二項演算子の "x" は繰り返し演算子です。スカラコンテキストでは、左被演
算子を右被演算子に示す数だけ繰り返したもので構成される文字列を返します。
リストコンテキストでは、左被演算子が括弧で括られたリストであれば、リス
トを繰り返します。

     print '-' x 80;               # 1 列のダッシュを印字

     print "\t" x ($tab/8), ' ' x ($tab%8); # タブに畳み込み

     @ones = (1) x 80;            # 80 個の 1 を含むリスト
     @ones = (5) x @ones;        # すべての要素を 5 にする





File: perl-ja.info, Node: 加法演算子, Next: シフト演算子, Prev: 乗法演算子, Up: 演算子と優先順位

加法演算子
==========

二項演算子の "+" は 2 つの数値の和を返します。

二項演算子の "-" は 2 つの数値の差を返します。

二項演算子の "." は 2 つの文字列を連結します。





File: perl-ja.info, Node: シフト演算子, Next: 名前付き単項演算子, Prev: 加法演算子, Up: 演算子と優先順位

シフト演算子
============

二項演算子の "<<" は左引数の値を、右引数で示すビット数だけ、左にシフト
した値を返します。引数は整数でなければなりません。

二項演算子の ">>" は左引数の値を、右引数で示すビット数だけ、右にシフト
した値を返します。引数は整数でなければなりません。





File: perl-ja.info, Node: 名前付き単項演算子, Next: 比較演算子, Prev: シフト演算子, Up: 演算子と優先順位

名前付き単項演算子
==================

さまざまな名前付き単項演算子が、引数を 1 つ持ち、括弧が省略可能な、関
数として扱われます。これには -f や -M のようなファイルテスト演算子も含
まれます。*Note 組み込み関数::,を参照してください。

リスト演算子 (print() など) や単項演算子 (chdir() など) は、すべて次の
トークンとして開き括弧が続くと、その演算子と括弧内の引数は、通常の関数
呼び出しのようにもっとも高い優先順位として扱われます。たとえば、|| は 
chdir より優先順位が低いので、

     chdir $foo    || die;       # (chdir $foo) || die
     chdir($foo)   || die;       # (chdir $foo) || die
     chdir ($foo)  || die;       # (chdir $foo) || die
     chdir +($foo) || die;       # (chdir $foo) || die

ですが、* は chdir や rand よりも高い優先順位となっているので:

     chdir $foo * 20;    # chdir ($foo * 20)
     chdir($foo) * 20;   # (chdir $foo) * 20
     chdir ($foo) * 20;  # (chdir $foo) * 20
     chdir +($foo) * 20; # chdir ($foo * 20)

     rand 10 * 20;       # rand (10 * 20)
     rand(10) * 20;      # (rand 10) * 20
     rand (10) * 20;     # (rand 10) * 20
     rand +(10) * 20;    # rand (10 * 20)

となります。*Note 項とリスト演算子 (左方向)::,の節を参照してください。


     


File: perl-ja.info, Node: 比較演算子, Next: 等価演算子, Prev: 名前付き単項演算子, Up: 演算子と優先順位

比較演算子
==========

二項演算子の "<" は左引数が数値的に右引数よりも小さければ、真を返しま
す。

二項演算子の ">" は左引数が数値的に右引数よりも大きければ、真を返しま
す。

二項演算子の "<=" は左引数が数値的に右引数よりも小さいか等しければ、真
を返します。

二項演算子の ">=" は左引数が数値的に右引数よりも大きいか等しければ、真
を返します。

二項演算子の "lt" は左引数が文字列的に右引数よりも小さければ、真を返し
ます。

二項演算子の "gt" は左引数が文字列的に右引数よりも大きければ、真を返し
ます。

二項演算子の "le" は左引数が文字列的に右引数よりも小さいか等しければ、
真を返します。

二項演算子の "ge" は左引数が文字列的に右引数よりも大きいか等しければ、
真を返します。


     


File: perl-ja.info, Node: 等価演算子, Next: ビットごとの AND, Prev: 比較演算子, Up: 演算子と優先順位

等価演算子
==========

二項演算子の "==" は左引数が数値的に右引数と等しければ、真を返します。

二項演算子の "!=" は左引数が数値的に右引数と等しくなければ、真を返しま
す。

二項演算子の "<=>" は左引数が数値的に右引数より小さいか、等しいか、大
きいかに従って、-1, 0, 1 を返します。

二項演算子の "eq" は左引数が文字列的に右引数と等しければ、真を返します。

二項演算子の "ne" は左引数が文字列的に右引数と等しくなければ、真を返し
ます。

二項演算子の "cmp" は左引数が文字列的に右引数より小さいか、等しいか、
大きいかに従って、-1, 0, 1 を返します。


     


File: perl-ja.info, Node: ビットごとの AND, Next: ビットごとの OR と XOR, Prev: 等価演算子, Up: 演算子と優先順位

ビットごとの AND
================

二項演算子の "&" は、両被演算子のビットごとに論理積をとって、その結果
を返します。


     


File: perl-ja.info, Node: ビットごとの OR と XOR, Next: C スタイルの論理積, Prev: ビットごとの AND, Up: 演算子と優先順位

ビットごとの OR と XOR
======================

二項演算子の "|" は、両被演算子のビットごとに論理和をとって、その結果
を返します。

二項演算子の "^" は、両被演算子のビットごとに排他論理和をとって、その
結果を返します。





File: perl-ja.info, Node: C スタイルの論理積, Next: C スタイルの論理和, Prev: ビットごとの OR と XOR, Up: 演算子と優先順位

C スタイルの論理積
==================

二項演算子の "&&" は、短絡の論理積演算を行ないます。つまり、左被演算子
が偽であれば、右被演算子は評価さえ行なわれないということです。評価され
る場合には、スカラかリストかというコンテキストは、右被演算子にも及びま
す。





File: perl-ja.info, Node: C スタイルの論理和, Next: 範囲演算子, Prev: C スタイルの論理積, Up: 演算子と優先順位

C スタイルの論理和
==================

二項演算子の "||" は、短絡の論理和演算を行ないます。つまり、左被演算子
が真であれば、右被演算子は評価さえ行なわれないということです。評価され
る場合には、スカラかリストかというコンテキストは、右被演算子にも及びま
す。

|| 演算子と && 演算子は、単に 0 や 1 を返すのではなく、最後に評価され
た値を返すという点において、C と違っています。これにより、かなり一般的
に使えるホームディレクトリ ("0" でないとして) を探す方法は:

     $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
         (getpwuid($<))[7] || die "You're homeless!\n";

のようにすることができます。

Perl では、多少読みやすい && と || の同義語として、"and" 演算子と "or" 
演算子が用意されています (下記参照)。短絡の動作は全く同じです。しかし、
"and" と "or" の優先順位はかなり低くしてあるので、引数に括弧を使ってい
ないリスト演算子のあとに続けて使う場合にも、安心して使うことができます:

     unlink "alpha", "beta", "gamma"
             or gripe(), next LINE;

C スタイルの演算子では:

     unlink("alpha", "beta", "gamma")
             || (gripe(), next LINE);

のように書く必要があります。


     


File: perl-ja.info, Node: 範囲演算子, Next: 条件演算子, Prev: C スタイルの論理和, Up: 演算子と優先順位

範囲演算子
==========

二項演算子の ".." は範囲演算子で、使われるコンテキストによって異なる動
作をする 2 つの演算子を合わせたものです。リストコンテキストでは、左の
値から右の値まで (1 づつ) 数えあげた値からなる配列を返します。これは、
for (1..10) のようなループを書くときや、配列のスライス演算を行なうとき
に便利です。現状のインプリメントでは、テンポラリの配列が作られるので:

     for (1 .. 1_000_000) {
         # プログラム
     }

のようなことを書くと、メモリを使い果たして、悲惨な結果になりかねません
ので注意してください。

スカラコンテキストで使われたときには、".." はブール値を返します。この
演算子は、フリップフロップのように 2 値安定で、sed や awk や多くのエディ
タでの行範囲 (コンマ) 演算子をエミュレートするものとなります。各々の 
".."  演算子がそれぞれに独立して自分のブール状態を管理します。はじめは、
左被演算子が偽である間、演算全体も偽となっています。範囲演算子は、いっ
たん左被演算子が真になると、右被演算子が真である間、真を返すようになり
ます。右被演算子が偽になると、演算子も偽を返すようになります。(次に範
囲演算子が評価されるまでは、偽とはなりません。(awk でのように) 真となっ
た、その評価の中で右被演算子をテストし、偽とすることができますが、1 度
は真を返すことになります。(sed でのように) 次に評価されるまで、右被演
算子をテストしたくなければ、2 個のドットの代わりに 3 つのドット 
("...") を使ってください。右被演算子は、演算子の状態が「偽」である間は
評価されることがなく、左被演算子は、演算子の状態が「真」である間は評価
されることがありません。優先順位は、|| と && の少し下です。偽としては
空文字列が返され、真としては (1 から始まる) 順に並んだ数値が返されます。
この通し番号は、新たに範囲が始まるごとにリセットされます。範囲の最後の
数字には、文字列 "E0" がお尻につけられます。これは、数値としては何の影
響もありませんが、範囲の終わりで何か特別なことをしたい場合に、目印とし
て使うことができます。範囲の始まりで何かしたい場合には、通し番号が 1 
よりも大きくなるのを待っていればよいでしょう。スカラの ".." の被演算子
が数値リテラルであるときは、その被演算子は暗黙に、変数 $. (現行番号)と
比較されることになります。例:

スカラ演算子として:

     if (101 .. 200) { print; }  # 101 行目から 200 行目を印字
     next line if (1 .. /^$/);   # ヘッダをスキップし、
     s/^/> / if (/^$/ .. eof()); # 本文を引用する。

リスト演算子として:

     for (101 .. 200) { print; } # $_ を 100 回、印字する
     @foo = @foo[$[ .. $#foo];   # コストがかかるが何もしない
     @foo = @foo[$#foo-4 .. $#foo]; # 最後の 5 要素のスライス

(リストコンテキストでの) 範囲演算子は、被演算子が文字列であるときには、
マジカルインクリメントの機能を使います。大文字すべての配列を得るのに

     @alphabet = ('A' .. 'Z');

と書けますし、

     $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];

と書けば、16 進の数字が得られますし、

     @z2 = ('01' .. '31');  print $z2[$mday];

とすれば、0 付きの日付が得られます。マジカルインクリメントによって得ら
れる値の中に指定した最終値にちょうど一致するものが見つからないような場
合には、マジカルインクリメントによって得られる次の値の文字列長が、最終
値として指定した値のものより長くなるまでインクリメントが続けられます。





File: perl-ja.info, Node: 条件演算子, Next: 代入演算子, Prev: 範囲演算子, Up: 演算子と優先順位

条件演算子
==========

三項演算子の "?:" は、C の場合と同じ条件演算子です。これは、
if-then-else のように働きます。"?" の前の引数が真であれば、":" の前の
引数が返されますが、真でなければ、":" の後の引数が返されます。スカラコ
ンテキストかリストコンテキストかという状況は、選択された 2 番目もしく
は 3 番目の引数にまで伝わります。2 番目と 3 番目の引数双方が左辺値 (代
入可能ということ)であれば、この演算子に代入を行なうこともできます:

     ($a_or_b ? $a : $b) = $c;

このことがプログラムの読みやすさにつながるかどうかは、別問題なので注意
してください。


     


File: perl-ja.info, Node: 代入演算子, Next: コンマ演算子, Prev: 条件演算子, Up: 演算子と優先順位

代入演算子
==========

"=" は通常の代入演算子です。

代入演算子は C の場合と同様の働きをします。つまり、

     $a += 2;

は、

     $a = $a + 2;

と等価ですが、tie() のようなもので起こる左辺値の被参照による副作用が 2 
回起こることはありません。他の代入演算も同様に働きます。以下のものが認
識されます:

              **=    +=    *=    &=    <<=    &&=
                     -=    /=    |=    >>=    ||=
                     .=    %=    ^=
                           x=

グループ分けしてありますが、これらはいずれも代入演算子として同じ優先順
位となっています。

C と違って、代入演算子は有効な左辺値を作り出します。代入を修正すること
は、代入を行なってから、その代入された変数を修正するのと同じことになり
ます。これは:

     ($tmp = $global) =~ tr [A-Z] [a-z];

ように何かのコピーを変更したいときに便利です。同じように、

     ($a += 2) *= 3;

は、

     $a += 2;
     $a *= 3;

と等価となります。





File: perl-ja.info, Node: コンマ演算子, Next: リスト演算子 (右方向), Prev: 代入演算子, Up: 演算子と優先順位

コンマ演算子
============
二項演算子の "," はコンマ演算子です。スカラコンテキストでは、その左引
数を評価し、その値を捨てて、それから右引数を評価し、その値を返します。
これはちょうど、C のコンマ演算子と同じです。

リストコンテキストでは、これは単にリスト引数の区切り文字で、双方の引数
をそのリストに挿入する働きがあります。


     


File: perl-ja.info, Node: リスト演算子 (右方向), Next: 論理否定, Prev: コンマ演算子, Up: 演算子と優先順位

リスト演算子 (右方向)
=====================

リスト演算子の右側のものにとって、リスト演算子はとても低い優先順位にな
ります。これによってコンマで区切った式をリスト演算子の引数として、置く
ことができます。これよりも優先順位が低いものは、論理演算子の "and",
"or", "not" のみで、余分な括弧を付けないリスト演算子の呼び出しを評価す
るために使うことができます:

     open HANDLE, "filename"
         or die "Can't open: $!\n";

「*Note 項とリスト演算子 (左方向)::,」の節の記述も参照してください。


     


File: perl-ja.info, Node: 論理否定, Next: 論理積, Prev: リスト演算子 (右方向), Up: 演算子と優先順位

論理否定
========

単項演算子の "not" は右側に来る式の否定を返します。これは、優先順位が
ずっと低いことを除いては "!" と等価です。




File: perl-ja.info, Node: 論理積, Next: 論理和と排他論理和, Prev: 論理否定, Up: 演算子と優先順位

論理積
======

二項演算子の "and" は両側の式の論理積を返します。これは、優先順位がずっ
と低いことを除けば && と等価です。つまり、これも短絡演算を行ない、右側
の式は左側の式が「真」であった場合にのみ評価されます。




File: perl-ja.info, Node: 論理和と排他論理和, Next: Perl にない C の演算子, Prev: 論理積, Up: 演算子と優先順位

論理和と排他論理和
==================

二項演算子の "or" は両側の式の論理和を返します。これは、優先順位がずっ
と低いことを除いて || と等価です。つまり、これも短絡演算を行ない、右側
の式は左側の式が「偽」であった場合にのみ評価されます。

二項演算子の "xor" は両側の式の排他論理和を返します。これはもちろん、
短絡ではありません。


     


File: perl-ja.info, Node: Perl にない C の演算子, Next: クォートとクォートのような演算子, Prev: 論理和と排他論理和, Up: 演算子と優先順位

Perl にない C の演算子
======================

C にあって Perl に無いものは以下の通りです:

単項 &
     アドレス演算子。("\" 演算子がリファレンスのために用いられます。)

単項 *
     被アドレス参照演算子。 (Perl の被参照プリフィクス演算子が型づけを
     行なう: $, @, %, &。)

(型)
     型のキャスト演算子。





File: perl-ja.info, Node: クォートとクォートのような演算子, Next: I/O 演算子, Prev: Perl にない C の演算子, Up: 演算子と優先順位

クォートとクォートのような演算子
================================

クォートはリテラル値であると考えるのが普通ですが、Perl において、クォー
トは演算子として働き、さまざまな展開やパターンマッチの機能を持っていま
す。そのような動作をさせるのに、Perl は慣習的にクォート文字を使ってい
ますが、どの種類のクォートも、自分でクォート文字を選べるようになってい
ます。以下の表では、{} がその選んだ区切文字のペアを示しています。選ん
だ区切文字が括弧の類でない場合には、前後の文字として同一のものを使いま
すが、4 つの括弧 ((), <>, [], {}) の場合にはネストできます。

     通常記法  汎用記法      意味         展開
     ==========================================
        ''       q{}       リテラル       不可
        ""      qq{}       リテラル        可
        ``      qx{}       コマンド        可
                qw{}      単語リスト      不可
        //       m{}    パターンマッチ     可
                 s{}{}       置換          可
                tr{}{}       変換         不可

展開が行なわれる構文では、"$" や "@" で始まる変数が、以下のシーケンス
と同時に展開されます:

     \t          タブ
     \n          改行
     \r          復帰
     \f          改ページ
     \v          垂直タブ (それが何であっても)
                 (訳注: これは使えないように見える)
     \b          バックスペース
     \a          アラーム (ベル)
     \e          エスケープ
     \033        8 進数で表した文字
     \x1b        16 進数で表した文字
     \c[         コントロール文字
     \l          次の文字を小文字にする
     \u          次の文字を大文字にする
     \L          \E まで小文字にする
     \U          \E まで大文字にする
     \E          変更の終わり
     \Q          \E まで正規表現のメタ文字をクォートする

パターンはさらに、正規表現として展開が行なわれます。これは、変数が展開
された後の 2 回目のパスで行なわれるので、変数に正規表現を含めておき、
パターンの中へ展開することができます。もし、そうしたくないのであれば、
\Q を使うと変数の内容を文字どおりに展開することができます。

上記のものを除けば、複数の段階を踏んで展開が行なわれることはありません。
特に、シェルのプログラマの期待とは裏腹に、バッククォートはダブルクォー
トの中では展開されませんし、シングルクォートがダブルクォートの中で使わ
れても、変数の展開を妨げることはありません。

?PATTERN?
     これは、reset() 演算子を呼び出すごとに 1 度だけしかマッチしないこ
     とを除いては /pattern/ による検索と全く同じです。たとえば、ファイ
     ルの集まりの中で個々のファイルについて、あるものを探すとき、最初
     の 1 つだけの存在がわかれば良いのであれば、この機能を使って最適化
     をはかることができます。現在のパッケージにローカルとなっている 
     ?PATTERN? のパターンだけが reset されます。

     この方法は、あまりお勧めしません。Perl の将来のバージョンでは削除
     されるかもしれません。

m/PATTERN/gimosx
/PATTERN/gimosx
     パターンマッチで文字列検索を行ない、スカラコンテキストでは真 (1) 
     または偽 (") を返す。=~ 演算子か !~ 演算子で検索対象の文字列を示
     さなかったときには、$_の文字列が検索対象となります。(=~ で指定さ
     れる文字列は、左辺値である必要はありません。式を評価した結果でも
     かまいませんが、=~ の優先順位がいくぶん高いことに注意してください。)
     perlre manpage を参照してください。

     オプションには、

        g   グローバルにマッチ、つまり、すべてを探し出す
        i   大文字、小文字を区別しない
        m   文字列を複数行として扱う
        o   パターンのコンパイルを 1 度だけにする
        s   文字列を単一行として扱う
        x   拡張正規表現を使用する

     があります。

     区切文字が "/" のときには、最初の m は付けても付けなくてもかまい
     ません。m を付けるときには、英数字でも空白でもない、任意の任意の
     文字のペアを、区切文字として使うことができます。これは "/" を含む 
     UNIX のパス名にパターンパッチを行なうときに便利でしょう。\/ といっ
     た LTS (楊枝偏執症候群) を避けるためにも。

     PATTERN には、変数が含まれていてもよく、パターンが評価されるごと
     に、変数は展開され (パターンが再コンパイルされ) ます。(2 つの変数 
     $) と $| は文字列の終わりを調べるパターンであると解釈されるので、
     展開されません。)パターンがコンパイルされるのを 1 度だけにしたい
     場合には、終わりの区切文字の後に /o 修飾子を付けます。これにより、
     実行時に再コンパイルが頻繁に起こることが避けられ、展開する値がス
     クリプトの実行中に変化しない場合に有効なものとなります。しかし、
     /o を付けることは、パターンの中の変数を変更しないことを約束するも
     のです。変更したとしても、Perl がそれに気付くことはありません。

     PATTERN を評価した結果が空文字列となった場合には、最後に実行され 
     (コンパイルに成功し) た正規表現が、代わりに使われます。

     パターンマッチが、リスト値が要求されるコンテキストで使われると、
     パターンの中の括弧で括られた部分列にマッチしたもので構成されるリ
     ストを返します。これは、($1, $2, $3, ...) ということです。(この場
     合、$1 なども設定されます。この点で Perl 4 の動作と違っています。)
     マッチが失敗した場合には、空配列が返されます。マッチが成功した場
     合で、括弧が無い場合には、リスト値 (1) が返されます。

     例:
          open(TTY, '/dev/tty');
          <TTY> =~ /^y/i && foo();    # 要望により foo を実行

          if (/Version: *([0-9.]*)/) { $version = $1; }

          next if m#^/usr/spool/uucp#;

          # 安上がりな grep
          $arg = shift;
          while (<>) {
              print if /$arg/o;       # 1 度だけコンパイル
          }

          if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

     最後の例は、$foo を最初の 2 つの単語と行の残りに分解し、$F1 と 
     $F2 と $Etc に代入しています。変数に代入されれば、すなわちパター
     ンがマッチすれば、if の条件が真となります。

     /g 修飾子は、グローバルなパターンマッチを指定するもので、文字列の
     中で可能な限りたくさんマッチを行ないます。この動作は、コンテキス
     トに依存します。リストコンテキストでは、正規表現内のすべての括弧
     付けされたものにマッチした部分文字列全部のリストが返されます。括
     弧がなければ、パターン全体を括弧で括っていたかのように、すべての
     マッチした文字列のリストが返されます。

     スカラコンテキストでは、m//g は文字列内で繰り返しを行ない、マッチ
     するごとに「真」を返し、最終的にマッチしなくなったときに「偽」を
     返します。(言い換えると、前回止まった場所を覚えていて、その場所か
     ら検索を再開するということです。文字列の現在の検索位置は、関数 
     pos() を使って知ることができます。*Note 組み込み関数::,を参照して
     ください。)いかなる方法でも、対象の文字列を変更すると、検索位置は
     先頭にリセットされます。

     例:
          # リストコンテキスト
          ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

          # スカラコンテキスト
          $/ = ""; $* = 1;  # Perl 5 では、$* は使わないほうがよい
          while ($paragraph = <>) {
              while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
                  $sentences++;
              }
          }
          print "$sentences\n";

q/STRING/
'STRING'
     シングルクォートされた、リテラル文字列です。バックスラッシュは、
     後ろに続くものが区切文字か、別のバックスラッシュである場合を除い
     て無視されます。区切文字やバックスラッシュが続く場合には、その区
     切文字自身もしくはバックスラッシュそのものが展開されます。

          $foo = q!I said, "You said, 'She said it.'"!;
          $bar = q('This is it.');

qq/STRING/
"STRING"
     ダブルクォートされた、リテラル文字列です。

          $_ .= qq
           (*** The previous line contains the naughty word "$1".\n)
                      if /(tcl|rexx|python)/;      # :-)


qx/STRING/
`STRING`
     展開され、システムのコマンドとして実行される文字列です。そのコマ
     ンドの、標準出力を集めたものが返されます。スカラコンテキストでは、
     (複数行を含むかもしれない) 1 つの文字列が戻ってきます。リストコン
     テキストでは、($/ もしくは $INPUT_RECORD_SEPARATOR をどのように設
     定していても) 行のリストを返します。

          $today = qx{ date };

     詳しくは「*Note I/O 演算子::,」の節を参照してください。

qw/STRING/
     埋め込まれた空白を区切文字として、STRING から抜き出した単語のリス
     トを返します。これは、

          split(' ', q/STRING/);

     と完全に同じになります。

     よく行なわれる例としては:

          use POSIX qw( setlocale localeconv );
          @EXPORT = qw( foo bar baz );

     というものがあります。

s/PATTERN/REPLACEMENT/egimosx
     文字列中でパターンを検索し、もし見つかれば、置換テキストで置き換
     え、置換した数を返します。見つからなければ、偽 (0) を返します。

     =~ 演算子や !~ 演算子によって文字列が指定されていなければ、変数 $_ が検
     索され、修正されます。(=~ で指定される文字列は、スカラ変数、配列
     要素、ハッシュ要素、あるいは、これらへの代入式といった左辺値でな
     ければなりません。)

     あとで述べますが、区切り文字はスラッシュとは限りません。シングル
     クォートを区切り文字として使った場合には、PATTERN にも 
     REPLACEMENT にも変数の展開を行ないません。 それ以外の場合、文字列
     の最後を表わすものには見えない $ が PATTERN に含まれると、実行時
     に変数がパターン内に展開されます。最初に変数が展開されるときにだ
     けパターンのコンパイルを行ないたいときには、/o オプションを使って
     ください。パターンの評価結果が空文字列になった場合には、最後に実
     行され (コンパイルに成功し) た正規表現が代わりに使われます。これ
     についてさらに詳しくは、*Note 正規表現::,を参照してください。

     オプションには、

        e   式の右側の評価を行なう
        g   グローバルな置換、つまり見つかったものすべて
        i   大文字、小文字を区別しないで検索
        m   文字列を複数行として扱う
        o   パターンのコンパイルを 1 度だけにする
        s   文字列を単一行として扱う
        x   拡張正規表現を使用する

     があります。

     英数字、空白ではない任意の区切り文字で、スラッシュを置き換えるこ
     とができます。先に述べたように、シングルクォートを使うと置換文字
     列での展開はされません (/e 修飾子を使えば可能です)。バッククォー
     トを用いると、置換文字列をコマンドとして実行して、その出力が実際
     の置換文字列に使われます。PATTERN を括弧類で括った場合には、
     REPLACEMENT 用にもう一組の区切り文字を用意します。これは、括弧類
     であっても、なくてもかまいません。例: s(foo)(bar) や s<foo>/bar/。
     /e は置換文字列を完全な Perl の式として解釈し、その場所で直ちに
     eval() します。しかし、これはコンパイル時に構文チェックされます。

     例:
          s/\bgreen\b/mauve/g;  # wintergreen は変更しない

          $path =~ s|/usr/bin|/usr/local/bin|;

          s/Login: $foo/Login: $bar/; # 実行時パターン

          ($foo = $bar) =~ s/this/that/;

          $count = ($paragraph =~ s/Mister\b/Mr./g);

          $_ = 'abc123xyz';
          s/\d+/$&*2/e;               # 'abc246xyz' となる
          s/\d+/sprintf("%5d",$&)/e;  # 'abc  246xyz'
          s/\w/$& x 2/eg;             # 'aabbcc  224466xxyyzz'

          s/%(.)/$percent{$1}/g;      # パーセントエスケー
                                                       # プを変更; /e なし
          s/%(.)/$percent{$1} || $&/ge;  # 式となるので /e
          s/^=(\w+)/&pod($1)/ge;      # 関数呼び出しを使う

          # /e はネスト可能;
          # $_ に単純に埋め込まれた変数を展開する
          s/(\$\w+)/$1/eeg;

          # C コメントの削除
          $program =~ s {
              /\*     (?# 開始区切り文字にマッチ)
              .*?     (?# 最短一致でマッチ)
              \*/     (?# 終了区切り文字にマッチ)
          } []gsx;

          s/^\s*(.*?)\s*$/$1/;        # 空白の切り詰め

          s/([^ ]*) *([^ ]*)/$2 $1/;  # 最初の 2 語の入れ替え

     最後の例で \ の代わりに $ を使っているのに注意してください。sed 
     と違って、\<数字> の形式はパターンの方でのみ使用できます。その他
     の場所では、$<数字> を使います。

     ときには、/g を付けるだけでは、すべてを変更することができないこと
     があります。2 つ例を示します:

          # 整数の適切な位置にコンマを入れる
          1 while s/(.*\d)(\d\d\d)/$1,$2/g;      # perl4
          1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;  # perl5

          # タブを 8 カラムのスペースに展開
          1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

tr/SEARCHLIST/REPLACEMENTLIST/cds
y/SEARCHLIST/REPLACEMENTLIST/cds
     検索リスト (SEARCHLIST) に含まれる文字を、対応する置換リスト 
     (REPLACEMENTLIST) の文字に変換します。置換または削除が行なわれた、
     文字数を返します。=~ 演算子や =! 演算子で文字列が指定されていなけ
     れば、$_の文字列が変換されます。(=~ で指定される文字列は、スカラ
     変数、配列要素、ハッシュ要素、あるいは、これらへの代入式といった
     左辺値でなければなりません。) sed の信仰者のために y が tr の同義
     語として提供されています。SEARCHLIST を括弧類で括った場合には、
     REPLACEMENTLIST 用に、もう一組の区切り文字を用意します。これは、
     括弧類であっても、なくてもかまいません。

          例: tr[A-Z][a-z] や tr(+-*/)/ABCD/。

     オプションには、

        c   SEARCHLIST を補集合にする
        d   見つかったが置換されなかった文字を削除する
        s   置換された文字が重なったときに圧縮する

     があります。

     /c 修飾子が指定されると、SEARCHLIST には補集合が指定されたものと
     解釈されます。/d 修飾子が指定されると、SEARCHLIST に指定されて、
     REPLACEMENTLIST に対応するものがない文字が削除されます。(これは、
     SEARCHLIST で見つかったものを削除する、ただそれだけの、ある種の 
     tr プログラムの動作よりと比べれば、いく分柔軟なものになっています。)
     /s 修飾子が指定されると、同じ文字に置き換えられた文字の並びを、そ
     の文字 1 文字だけに圧縮します。

     /d 修飾子が使われると、REPLACEMENTLIST は、常に指定された通りに解
     釈されます。/d が指定されない場合で、REPLACEMENTLIST が 
     SEARCHLIST よりも短いと、同じ長さになるまで、REPLACEMENTLIST の最
     後の文字が繰り返されているものとして扱われます。REPLACEMENTLIST 
     が空文字列でのときには、SEARCHLIST と同じになります。後者は、ある
     文字クラスに含まれる文字数を数えるときや、ある文字クラスの文字の
     並びを圧縮するようなときに便利です。

     例:
          $ARGV[1] =~ tr/A-Z/a-z/;    # 小文字に統一

          $cnt = tr/*/*/;             # $_ 内の * を数える

          $cnt = $sky =~ tr/*/*/;     # $sky 内の * を数える

          $cnt = tr/0-9//;            # $_ 内の数字を数える

          tr/a-zA-Z//s;               # bookkeeper -> bokeper

          ($HOST = $host) =~ tr/a-z/A-Z/;

          tr/a-zA-Z/ /cs;             # 英字以外を 1 つの
                                      # スペースに変換する

          tr [\200-\377]
             [\000-\177];             # 8th bit 目を削除

     変換テーブルはコンパイル時に作られるので、SEARCHLIST も 
     REPLACEMENTLIST もダブルクォート展開の対象とはなりません。変数を
     使いたい場合には、eval() を使わなければならないということです:

          eval "tr/$oldlist/$newlist/";
          die $@ if $@;

          eval "tr/$oldlist/$newlist/, 1" or die $@;


     


File: perl-ja.info, Node: I/O 演算子, Next: 定数の畳み込み, Prev: クォートとクォートのような演算子, Up: 演算子と優先順位

I/O 演算子
==========

知っておいた方がよい I/O 演算子もいくつかあります。バッククォートで括
られた文字列は、まず、ダブルクォート文字列のように、変数の展開が行なわ
れます。その後、シェルでの場合と同じように、コマンドとして解釈され、そ
のコマンドの出力がこの擬似リテラルの値となります。スカラコンテキストで
は、出力すべてを含む一個の文字列が返されます。リストコンテキストでは、
出力の 1 行 1 行が個々の要素となるリストが返されます。($/ を設定すれば、
行の終わりを示す文字を変えることができます。)コマンドは、この擬似リテ
ラルが評価されるごとに実行されます。コマンドのステータス値は $? に返さ
れます ($?  の解釈については、*Note 定義済み変数::,を参照してください)。
csh での場合とは違って、結果のデータに対する変換は行なわれず、改行は改
行のままです。どのシェルとも違って、シングルクォートがコマンド中の変数
名を解釈させないようにすることはありません。シェルに$ を渡すには、バッ
クスラッシュでエスケープしなければなりません。バッククォートの一般形は、
qx// です。

山括弧の中のファイルハンドルを評価すると、そのファイルから、次の行を読
み込むことになります (改行も含まれるので、未定義値が返される EOF に達
するまでは、偽と評価される値が返ることはありません)。通常は、その値を
変数に代入しなければなりませんが、自動的に代入される場合が 1 つだけあ
ります。この入力シンボルが、while ループの条件式中に単独で現れた場合だ
けは、その値が自動的に変数 $_ に代入されます。(これは、奇妙に思えるか
もしれませんが、ほとんどすべての Perl スクリプトでこれが必要になること
でしょう。)いずれにせよ、以下のものは、お互いに同値なものです:

     while ($_ = <STDIN>) { print; }
     while (<STDIN>) { print; }
     for (;<STDIN>;) { print; }
     print while $_ = <STDIN>;
     print while <STDIN>;

STDIN、STDOUT、STDERR というファイルハンドルは、あらかじめ定義されてい
ます。(stdin、stdout、stderr というファイルハンドルも、ローカルな名前
でこれらのグローバルな名前が見えなくなっているパッケージを除けば、使用
することができます。)その他のファイルハンドルは、open() 関数で作ること
ができます。

<FILEHANDLE> がリストを必要とするコンテキストで用いられると、1 要素に 
1 行の入力行すべてからなるリストが返されます。これを使うと簡単に巨大な
データが作られてしまいますので、注意を要します。

ヌルファイルハンドル <> は特別で、sed や awk の動作をエミュレートする
ために使われます。<> からの入力は、標準入力からか、コマンドライン上に
並べられた個々のファイルから行なわれます。動作の概要は、以下のようにな
ります。最初に <> が評価されると、配列 @ARGV が調べられ、空であれば、
$ARGV[0] に "-"を設定します。これは、open されるとき標準入力となります。
その後、配列 @ARGV がファイル名のリストとして処理されます。

     while (<>) {
         ...                     # 行ごとの処理
     }

というループは、

     unshift(@ARGV, '-') if $#ARGV < $[;
     while ($ARGV = shift) {
         open(ARGV, $ARGV);
         while (<ARGV>) {
             ...         # 行ごとの処理
         }
     }

のような Perl の擬似コードと等価です。わずらわしく書かなくても、動作し
ます。実際に @ARGV を shift しますし、その時点のファイル名を変数 $ARGV 
に入れています。また、内部的にファイルハンドル ARGV を使っていて、<> 
は不思議な <ARGV> の同義語となっています。(上記の擬似コードは、<ARGV> 
を通常のものとして扱っているので、うまく動作しません。)

終的に、@ARGV に扱いたいと思っているファイル名が含まれるのであれば、最
初に <> を評価する前に @ARGV を変更することも可能です。行番号 ($.) は、
入力ファイルがあたかも 1 つの大きなファイルであるかのように、続けてカ
ウントされます。(個々のファイルごとにリセットする方法は、perlfunc
manpage の eof() の例を参照してください。)

最初から @ARGV に自分でファイルのリストを設定してもかまいません。スク
リプトにスイッチを渡したいのであれば、Getopts モジュールを使うこともで
きますし、実際の処理の前に

     while ($_ = $ARGV[0], /^-/) {
         shift;
         last if /^--$/;
         if (/^-D(.*)/) { $debug = $1 }
         if (/^-v/)     { $verbose++  }
         ...             # その他のスイッチ
     }
     while (<>) {
         ...             # 個々のファイルに対するコード
     }

のようなループを置くこともできます。

シンボル <> が「偽」を返すのは一度きりです。偽となったあとで、もう一度
呼び出すと、新たに別の @ARGV を処理するものとみなされ、その時に @ARGV 
を設定しなおしていないと、STDIN から読み込むことになります。

山括弧の中の文字列が (<$foo> のような) スカラ変数の参照となっていれば、
その変数が入力を行なうファイルハンドルの名前を示しているとみなされます。

山括弧の中の文字列がファイルハンドルでなければ、グロブを行なうファイル
名のパターンと解釈され、コンテキストによって、ファイル名のリストか、そ
のリストの次のファイル名が返されます。まず、1 段階だけ $ の展開が行な
われますが、前の段落に書いた間接ファイルハンドルと同じになる、<$foo> 
のようには書けません。ファイル名グロブと解釈させるには <${foo}> のよう
に中括弧を入れる必要があります。(別の方法として、glob($foo) と内部関数
を呼ぶこともできます。おそらく、まず、こちらの方で試すのが正解でしょう。) 
例:

     while (<*.c>) {
         chmod 0644, $_;
     }

は、

     open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
     while (<FOO>) {
         chop;
         chmod 0644, $_;
     }

と等価です。実際、現在はそのようにインプリメントされています。(つまり、
マシン上に csh(1) がないと、スペースを含むファイル名は、うまく扱えない
ということです。)もちろん、もっと簡単に

     chmod 0644, <*.c>;

と書けます。

グロブはシェルを呼び出しますから、自分で readdir() を呼んで、得られた
ファイル名に grep() した方が速い場合もあります。さらに、現在のインプリ
メントがシェルを使うために、(/bin/csh として tcsh(1L) をインストールし
ていない限り) glob() ルーティンで "Arg list too long" エラーが発生する
場合があります。


     


File: perl-ja.info, Node: 定数の畳み込み, Next: 整数演算, Prev: I/O 演算子, Up: 演算子と優先順位

定数の畳み込み
==============

C と同じように Perl でも、演算子に対するすべての引数がスタティックで、
副作用がないと判断できれば、コンパイル時に式の評価を行なってしまいます。
特に、変数置換の無いリテラルどうしの文字列連結はコンパイル時に行なわれ
ます。バックスラッシュの解釈もコンパイル時に行なわれます。

     'Now is the time for all' . "\n" .
         'good men to come to.'

と書いても、内部的に 1 つの文字列になります。同様に

     foreach $file (@filenames) {
         if (-s $file > 5 + 100 * 2**16) { ... }
     }

と書くとコンパイラは、式が表わす数値をあらかじめ計算しますので、インタ
プリタで計算する必要がなくなっています。


     


File: perl-ja.info, Node: 整数演算, Prev: 定数の畳み込み, Up: 演算子と優先順位

整数演算
========

デフォルトでは、Perl は演算を浮動小数で行なわなければならないものとし
ていますが、

         use integer;

と書けば、その場所から現在の BLOCK の終わりまでは、整数演算を行なって
よいと、コンパイラに指示することができます。内部の BLOCK で、

         no integer;

と書けば、その BLOCK の終わりまでは、指示を取り消すことになります。




File: perl-ja.info, Node: 正規表現, Next: 実行とオプション, Prev: 演算子と優先順位, Up: Top

正規表現
********

マッチ演算子においてどのように正規表現を使うかについての説明は、*Note 
演算子と優先順位::,の m// や s/// を参照してください。マッチ演算子は、
いくつかの修飾子をとり、中の正規表現の解釈の仕方を変更することができま
す。修飾子には、

   i   大文字小文字の区別をしないパターンマッチを行なう。
   m   文字列を複数行として扱う。
   s   文字列を単一行として扱う。
   x   拡張正規表現を使用する。

があります。これらは通常、使用する区切り文字にスラッシュ以外のものを使
うときでも、「/x 修飾子」のように書かれます。実際には、これらの修飾子
は、(?...) という新しい形式で正規表現の中に埋め込んでしまうこともでき
ます。これについては、あとで述べます。

/x 修飾子について、もう少し説明しておきましょう。これは、正規表現のパー
ザに、バックスラッシュでエスケープされている空白、文字クラス内で使われ
ている空白以外の空白を無視するように指示するものです。これを使えば、正
規表現を (少しは) 読みやすい単位に分割して使うことができるでしょう。あ
とで述べる、埋め込みコメントの機能とともに、Perl 5 を読みやすい言語に
することに貢献しています。*Note 演算子と優先順位::,にあげた C のコメン
トを削除する例を参照してください。

* Menu:

* 正規表現の書き方::
* Version 8 正規表現::

     



File: perl-ja.info, Node: 正規表現の書き方, Next: Version 8 正規表現, Prev: 正規表現, Up: 正規表現

正規表現の書き方
================

パターンマッチで用いるパターンは、Version 8 regexp ルーティンで提供さ
れているような正規表現です。(実際、使用しているルーティンは、Henry
Spencer が書き直した再配布可能な V8 のルーティンを元にしています。)詳
しくは、「*Note Version 8 正規表現::,」の節を参照してください。

特に、以下のメタ文字は、標準的な egrep(1) と同様の意味を表わします:

   \   次のメタ文字をクォートする
   ^   行の最初にマッチする
   .   (改行以外の) すべての文字にマッチする
   $   行の終わりにマッチする
   |   選択
   ()  グループ化
   []  文字クラス

デフォルトでは、文字 "^" は文字列の最初にだけ、文字 "$" は最後 (もしく
は、最後の改行の前) にだけマッチすることが保証されており、Perl は文字
列には 1 行だけが含まれていると仮定して、最適化を行ないます。文字列の
中に埋め込まれた改行は、"^" や"$" はマッチしません。しかし、文字列を複
数行のバッファとして扱い、"^" はすべての改行のあとにマッチし、"$" はす
べての改行の前にマッチするようにしたい場合もあるでしょう。少しばかり負
荷がかかりますが、パターンマッチ演算子に /m 修飾子を付けると、そのよう
にすることができるようになります。(昔のプログラムでは $* を設定するこ
とでこれを行なっていましたが、Perl 5 でこれを行なうことは芳しくありま
せん。)

複数行の置換を容易にするため、/s 修飾子を使わない限り、文字 "." は改行
文字にマッチしません。この /s 修飾子は、文字列がたとえ複数行であっても
単一行であるかのように扱うよう Perl に指示するものです。/s 修飾子は、
他のモジュールで $* を設定するような (よくない) 過去のコードを持ってき
たような場合にも、その $* の設定を無効にします。

次のような標準の数量子が認識されます:

   *      0 回以上にマッチ
   +      1 回以上にマッチ
   ?      1 回または 0 回にマッチ
   {n}    ちょうど n 回にマッチ
   {n,}   n 回以上にマッチ
   {n,m}  n 回以上 m 回以下にマッチ

(中括弧が他の文脈であらわれた場合には、通常の文字として扱われます。)
"*" 修飾子は {0,}、"+" は {1,}、"?" は {0,1} と等価なものとして扱われ
ます。n や m の大きさに制限はありませんが、大きな数はそれだけメモリを
消費します。

デフォルトでは、数量子を付けたサブパターンは、「最長一致」となり、残り
のパターンがマッチしなくならない範囲で、できる限り多くのものにマッチす
るようになっています。つまり、標準の数量子は、すべて「最長一致」で、
(適切な開始位置を与えると) パターンが失敗しない範囲で可能な限り長い範
囲にマッチします。もし、最短の範囲でマッチさせたいのであれば、数量子の
後に "?" を付けて指定します。この場合、「最短一致」となるだけで、意味
するところは変わりありません:

   *?     0 回以上にマッチ
   +?     1 回以上にマッチ
   ??     1 回または 0 回にマッチ
   {n}?   ちょうど n 回にマッチ
   {n,}?  n 回以上にマッチ
   {n,m}? n 回以上 m 回以下にマッチ

パターンはダブルクォート文字列として処理されますから、

     \t          タブ
     \n          改行
     \r          復帰
     \f          改ページ
     \v          垂直タブ (それが何であっても)
                 (訳注: これは使えないように見える)
     \a          アラーム (ベル)
     \e          エスケープ
     \033        8 進数で表した文字
     \x1b        16 進数で表した文字
     \c[         コントロール文字
     \l          次の文字を小文字にする
     \u          次の文字を大文字にする
     \L          \E まで小文字にする
     \U          \E まで大文字にする
     \E          変更の終わり
     \Q          \E まで正規表現のメタ文字をクォートする

も使用できます。さらに、Perl では以下のものが定義されています:

     \w  「単語」の構成文字 (英数字と "_") にマッチ
     \W  単語の構成文字以外にマッチ
     \s  空白文字にマッチ
     \S  空白文字以外にマッチ
     \d  数字にマッチ
     \D  数字以外にマッチ

\w は 1 字の英数字にマッチするのであって、単語全体にマッチするのではな
いことに注意してください。単語全体にマッチさせるためには \w+ とする必
要があります。\w, \W, \s, \S, \d, \Dは文字クラス内 (で範囲を指定する両
端の文字以外の場所) でも使うことができます。

Perl では以下の長さのない、位置指定子を定義しています:

     \b  単語の境界にマッチ
     \B  単語の境界以外にマッチ
     \A  文字列の最初にのみマッチ
     \Z  文字列の最後にのみマッチ
     \G  前回の m//g が終わったところにのみマッチ

単語の境界 (\b) は \w で定義される文字と \W で定義される文字の間という
ように定義されます (順番はどちらが先でもよい)。文字列の最初と最後には 
\W に含まれる仮想的な文字があるものとして扱われます。(文字クラスの中で
は \b は単語境界ではなく、バックスペースを表わします。)\A と \Z は /m 
修飾子が用いられた場合にも 1 か所でしかマッチしないことを除いて "^" と 
"$"と同じ事になります。"^" と "$" は内部的な行の境界にもマッチします。

括弧括り ( ... ) の形式を用いている場合には、\<数字> がその括られてい
る「数字」番目の部分文字列にマッチします。(パターンの外では、数字の前
の "\" の代わりに "$" を使います。) $<数字> (と $`, $&, $') のスコープ
は、BLOCK や eval 文字列の終わりや、次の部分式を使ったパターンマッチま
でとなります。サブパターンとして記録せずに、括弧で括ってサブパターンを
区切りたい (たとえば、選択肢をまとめる) 場合、"(" の後に "?" を続けま
す。\<数字> の記法は、そのパターンの外で使える場合もあるかもしれません
が、これに頼ってはなりません。括弧は、好きなだけ使ってかまいません。10 
個以上の部分文字列は、$10,$11 などで参照することができます。そのパター
ンの中では、後方参照の前に最低限、参照している番号の数だけの開き括弧が
あれば、\10, \11 などで参照できます。その番号の数だけの開き括弧が無い
場合には、(以前のバージョンとの互換性のために) \10 は、\010 (バックス
ペース)、\11 は \011 (タブ) といった意味になります。(\1 から \9 は、常
に後方参照を意味します。)

$+ は、最後の括弧対にマッチしたものを返します。$& は、マッチした文字列
全体を返します。(以前は、$0 がこの意味に使われましたが、現在は使えませ
ん。) $` は、マッチした文字列の前にあったものを返します。$' は、マッチ
した文字列の後にあったものを返します。例:

     s/^([^ ]*) *([^ ]*)/$2 $1/;     # 最初の 2 語を入替える

     if (/Time: (..):(..):(..)/) {
         $hours = $1;
         $minutes = $2;
         $seconds = $3;
     }

Perl におけるすべてのバックスラッシュ付きのメタ文字が、\b,\w, \n といっ
た英数字であることにお気付きかもしれません。他のいくつかの正規表現言語
とは違って、英数字以外にバックスラッシュ付きの記号はありません。つまり、
\\, \(, \), \<, \>,\{, \} といったものはすべて、メタ文字ではなく、リテ
ラル文字として解釈されます。このことによって、パターンとして使いたい文
字列に、メタ文字と解釈される文字が含まれている可能性があるときに、たや
すくクォートすることができるようになっています。単に英数字以外の文字を、
すべてクォートすればよいのです:

     $pattern =~ s/(\W)/\\$1/g;

同じことを行なうために、組み込みの関数 quotemeta() を使うこともできま
す。マッチ演算子の中でより簡単にメタ文字をクォートするには、

     /$unquoted\Q$quoted\E$unquoted/

とすればよいでしょう。

Perl 5 では、正規表現に一貫した拡張構文を定義しています。構文は、括弧
のペアの中に、最初の文字としてクエスチョンマークを置いたものとなってい
ます (これは、Perl 4 では構文エラーです)。クエスチョンマークに続く文字
で、拡張の機能のどれを使うのかを示します。いくつかの拡張が、既にサポー
トされています:

(?#text)
     コメント。Text は無視されます。

(?:regexp)
     これは、"()" と同じようにグループ化を行ないますが、"()" のように
     後方参照を生成しません。つまり

          split(/\b(?:a|b|c)\b/)

     は、

          split(/\b(a|b|c)\b/)

     と似ていますが、余分なフィールドを作りません。

(?=regexp)
     長さの無い、前方参照位置指定子。たとえば、/\w+(?=\t)/ は、後ろに
     タブが続く単語にマッチしますが、そのタブは $& には含まれません。

(?!regexp)
     長さの無い、前方参照否定位置指定子。たとえば、/foo(?!bar)/ は、後
     ろに "bar" が続かない "foo" にマッチします。前方参照と後方参照は、
     同じではないことに注意してください。この構文を後方を参照するため
     に使うことはできません。/(?!foo)bar/ では、"foo" 以外のものに続く 
     "bar" を見つけるものではありません。(?!foo) は次にくるものが 
     "foo" でないとだけ言っているからで、次が "bar" であれば、当然
     "foo" ではありませんから、"foobar" がマッチします。先の目的のため
     には、/(?!foo)...bar/ のように書かなくてはならないでしょう。「よ
     うに」といったのは、"bar" の前に 3 文字無い場合もあるだろうからで
     す。これもカバーするには、/(?:(?!foo)...|^..?)bar/ というように書
     けるでしょう。単に:

          if (/foo/ && $` =~ /bar$/)

     と書いた方が簡単なこともあります。(訳注: これは if(/bar(?=foo)/) 
     かな。($' を除く))

(?imsx)
     パターンマッチ修飾子の埋め込み。これは、パターンが、どこかの表に
     示され、そのうちのいくつかは大文字小文字を区別せず、いくつかは区
     別するといった場合に便利です。区別するものでは、単にパターンの先
     頭に (?i) を付け加えればよいのです。たとえば:

          $pattern = "foobar";
          if ( /$pattern/i )

          # パターンに埋め込めば、より柔軟:

          $pattern = "(?i)foobar";
          if ( /$pattern/ )

この構文や新しい最短一致の構文にクエスチョンマークを選らんだのは、1) 
以前の正規表現においてクエスチョンマークが使われることが少なかったこと、
2) これを見つけた人は「疑問」に思ってなにが起こるのかを考えるべきだと
いうことによります。これこそ、心理学 ...


     


File: perl-ja.info, Node: Version 8 正規表現, Prev: 正規表現の書き方, Up: 正規表現

Version 8 正規表現
==================

万が一、みなさんが「正規の」Version 8 正規表現ルーティンを知らなかった
場合のために、これまでに書いていないパターンマッチの規則を示します。

ある 1 文字は、その文字がこの節かこれまでに示した「メタ文字」でない場
合には、その文字自身にマッチします。通常はメタ文字として働く文字も、前
に "\" を付けることで、文字通りに解釈されるようにすることができます。
(たとえば、"\." は任意の 1 文字ではなく、"." という文字にマッチします。)
文字の並びは、対象の文字列の中の同じ文字の並びにマッチしますから、
blurfl というパターンは、対象となる文字列の "blurfl" にマッチします。

文字のリストを [] で囲って、そのリストのいずれかの文字にマッチする、文
字クラスを指定することができます。"[" に続く最初の文字が "^" であれば、
その文字クラスは、リストに無い文字にマッチするようになります。リストの
中では、"-" が範囲を示すのに使われ、a-z は "a" から "z" までのすべての
文字を表わします。

C で使われているのと非常によく似たメタ文字構文を使って、文字を指定する
ことができます。"\n" が改行、"\t" がタブ、"\r"が復帰、"\f" が改ページ
といった具合です。さらに一般的には、nnn を 8 進数の数字として、\nnn は 
ASCII 値が nnn の文字にマッチします。同様に、nn を 16 進数の数字として、
\xnn はASCII 値が nn の文字にマッチします。\cx という式は、ASCII 文字 
control-x にマッチします。最後に、メタ文字 "." は (/s を使っているとき
を除いて) "\n" を除くどんな文字にもマッチします。

"|" で区切ることで、パターンの選択肢を示すことができますから、
fee|fie|foe は、対象の文字列の "fee" か "fie" か "foe" のいずれかにマッ
チします (f(e|i|o)e と同じ)。最初の選択肢には、最後の区切文字 ("(" か 
"[" かパターンの始め) の後から最初の"|" の前までが含まれ、最後の選択肢
には、最後の "|" の後から次のパターンの区切文字の前までが含まれます。
この事から、最初と最後をはっきりさせるために、選択肢を括弧に入れること
がよく行なわれます。(fee|fie|foe) というパターンは、[fee|fie|foe] とい
うパターンとは違うことに注意してください。前者が対象文字列の "fee" か 
"fie" か "foe" にマッチするのに対して、後者は [fee] か [fie] か [foe] 
のいずれかの文字クラスにマッチするものにマッチします (つまり、文字クラ
ス [feio] です)。

パターンではあとで参照するために、括弧で括ってサブパターンを指定でき、
そのパターンの中で n 番目のサブパターンを \n というメタ文字で参照する
ことができます。サブパターンは、左から右に向かって、開き括弧に対して番
号がつけられます。後方参照は、サブパターンが調べられる文字列中で、実際
にマッチしたものにマッチするのであって、そのサブパターン規則そのものに
マッチするのではありません。ですから、([0|0x])\d*\s\1\d* というパター
ンは、"0x1234 0x4321" にマッチしますが、"0x1234 01234" にはマッチしま
せん。たとえ [0|0x] という規則が 2 番目の数字の前の 0 にマッチすること
ができるとしても、サブパターン 1 は、"0x" にマッチしたものだからです。




File: perl-ja.info, Node: 実行とオプション, Next: 組み込み関数, Prev: 正規表現, Up: Top

実行とオプション
****************

実行にあたって、Perl は指定されたスクリプトを以下に示す場所で探します:

  1. コマンドライン上で `-e' スイッチで指定された行。

  2. コマンドライン上で最初のファイル名として示されたファイルの中。(#! 
     記法をサポートしているシステムでは、このようにしてインタプリタを
     呼び出します。)

  3. 標準入力から非明示に渡される。ファイル名を示す引数が無い場合にの
     みうまくいきます。STDIN からのスクリプトに引数を渡すには、スクリ
     プト名として明示的に "-" を指定しなくてはなりません、

2 番目、3 番目の方法では、`-x' スイッチを指定した場合を除いて、Perl は
入力ファイルを最初から解析し始めます。`-x' スイッチを指定した場合には、
まず、最初に #! と "perl" という文字列を含む行を探し、そこから解析を始
めます。これは、大きなテキストにスクリプトを埋め込んで、実行するような
ときに便利です。(この場合、スクリプトの終わりは、トークン `__END__' を
使って示すとよいでしょう。)

Perl 5 からは、#! を含む行のスイッチが必ず解析されるようになりました。
つまり、#! の行で引数が一つしか許されない、あるいはもっと悪く、#! の行
が認識されないといったシステムで運用している場合にも、`-x' でスクリプ
トの開始位置を見つけた場合を含め、どのように Perl が起動されたかによら
ず、一貫したスイッチの動作を期待できるようになっています。

多くの OS で、カーネルによる #! 行の解釈が、エラーなしに 32文字で打ち
切られてしまいますので、あるスイッチはコマンドラインに渡され、あるスイッ
チは渡されないといったことが起こります。注意しないと、文字が続かない 
"-" だけが渡されるといったことも起こり得ます。すべてのスイッチが、32 
文字境界の前か後ろかを確かめたいことでしょう。多くのスイッチは、余分に
処理されても問題ありませんが、完全なスイッチの代わりに - が入っていた
場合には、スクリプトの代わりに、標準入力を Perl に実行させることになっ
てしまいます。`-I' スイッチが中途半端になった場合にもおかしな結果とな
り得ます。

#! スイッチの解析は、行内で "perl" が示された位置から始まります。とり
わけ "-*" と "- " という文字の並びは無視されますので、

     #!/bin/sh -- # -*- perl -*- -p
     eval 'exec perl $0 -S ${1+"$@"}'
         if 0;

のように書けば、Perl に `-p' スイッチを渡すことができます。

#! 行に "perl" という語が含まれていなければ、#! の後に指定されたプログ
ラムが Perl インタプリタの代わりに実行されます。これは少し変わっていま
すが、#! が行なえないマシンを使っている方には有効でしょう。プログラム
に対して使っている SHELL が /usr/bin/perl だと言っておけば、Perl が正
しいインタプリタを起動してくれるからです。

スクリプトの場所が特定できたなら、Perl はスクリプト全体を内部形式にコ
ンパイルし始めます。コンパイルエラーが見つかった時には、スクリプトの実
行は行なわれません。(これは、構文エラーがある場合にも、途中まで実行さ
れる可能性のある、典型的なシェルのスクリプトと異なる点です。)

スクリプトが構文的に正しければ、実行されることになります。スクリプトが、
exit() 演算子にも die() 演算子にも当たらないで最後まで到達すると、正常
に完了したことを示すために、暗黙の exit(0) が行なわれます。

1 文字のスイッチは、次に続くスイッチがあれば、それとつなげることができ
ます。

     #!/usr/bin/perl -spi.bak    # -s -p -i.bak と同じ

* Menu:

* スイッチ一覧::




File: perl-ja.info, Node: スイッチ一覧, Prev: 実行とオプション, Up: 実行とオプション

スイッチ一覧
============

-0digits
     レコードセパレータ ($/) を 8 進数で示します。digitsを指定しないと、
     ヌル文字がセパレータになります。他のスイッチを前に置いてもかまい
     ませんし、digits のあとにつなげてもかまいません。たとえば、ファイ
     ル名をヌル文字で区切って表示できる find があれば:

          find . -name '*.bak' -print0 | perl -n0e unlink

     のようにできます。

     00 という特別な値は、Perl にパラグラフモードで、ファイルを読ませ
     ます。0777 という値は、該当する文字がないため、Perl にファイル全
     体を読ませることになります。

-a
     `-n' や `-p' といっしょに用いると、自動 split モードになります。
     `-n' や `-p' で作られる暗黙のループ内の最初の文として、配列 @F へ
     の暗黙の split コマンドが実行されます。

          perl -ane 'print pop(@F), "\n";'

     は、

          while (<>) {
              @F = split(' ');
              print pop(@F), "\n";
          }

     と等価です。`-F' を使って区切文字を変更することができます。

-c
     Perl にスクリプトの構文のチェックを行なわせ、実行せずに抜けるよう
     にします。

-d
     Perl デバッガの下でスクリプトを実行します。*Note デバッグ::,を参
     照してください。

-Dnumber
-Dlist
     デバッグフラグを設定します。スクリプトがどのように実行されるかを
     見るには、`-D14' を使ってください。(これは、`-DDEBUGGING' を指定
     して Perl にデバッグ機能を盛り込んでコンパイルしたときにだけ働き
     ます。)この他に役に立つ値としては、コンパイルされた構文トリーを表
     示する、`-D1024' があげられます。`-D512' は、コンパイルした正規表
     現を表示します。数字の代わりに文字のリストを指定することもできま
     す (たとえば、`-D14' は `-Dtls' と等価です):

              1  p  トークン化と構文解析
              2  s  スタックの表示
              4  l  ラベルスタックの処理
              8  t  実行のトレース
             16  o  演算子ノードの構造
             32  c  文字列/数値変換
             64  P  -P のためのプリプロセッサコマンドの表示
            128  m  メモリ配置
            256  f  フォーマットの処理
            512  r  正規表現の解析
           1024  x  構文トリーのダンプ
           2048  u  汚染チェック
           4096  L  メモリリーク (既にサポートされていない)
           8192  H  ハッシュのダンプ -- values() の横取り
          16384  X  スクラッチパッドの配置
          32768  D  全消去

-e commandline
     1 行のスクリプトを指定するのに使用します。`-e' が指定されると 
     Perl は引数のリストからはスクリプトのファイル名を探しません。複数
     の `-e' コマンドで、複数行のスクリプトを構成することができます。
     通常のプログラムでセミコロンを置くところには、セミコロンを使うこ
     とに気を付けてください。

-Fregexp
     `-a' が有効なときに、split を行なう正規表現を指定します。正規表現
     の前後に // があっても、そのスラッシュは無視されます。

-iextension
     <> の構文で処理されたファイルを置き換えるための拡張子を指定します。
     これは、入力ファイルをリネームし、元の名前で出力ファイルを open 
     し、print() 文のデフォルトとしてその出力ファイルを select するこ
     とで行ないます。extension が指定されると、昔の内容のバックアップ
     を行なうファイル名の拡張子として、元のファイル名に付け加えられま
     す。extension が指定されないと、バックアップを作りません。シェル
     からは

          $ perl -p -i.bak -e "s/foo/bar/; ... "

     とすれば、

          #!/usr/bin/perl -pi.bak
          s/foo/bar/;

     とスクリプトで書くのと同じで、これは、

          #!/usr/bin/perl
          while (<>) {
              if ($ARGV ne $oldargv) {
                  rename($ARGV, $ARGV . '.bak');
                  open(ARGVOUT, ">$ARGV");
                  select(ARGVOUT);
                  $oldargv = $ARGV;
              }
              s/foo/bar/;
          }
          continue {
              print;  # 元のファイル名に出力する
          }
          select(STDOUT);

     と書くのと、`-i' の形式が、いつファイル名が変わったかを知るために、
     $ARGV と $oldargv を比較する必要がないのを除いて、同値です。しか
     しながら、選択するファイルハンドルとして ARGVOUT は使用します。ルー
     プのあとは、STDOUTがデフォルトのファイルハンドルとして再設定され
     ます。

     個々のファイルの終わりに何かを付け加えたいときや、行番号をリセッ
     トしたいような場合に、個々の入力ファイルの終わりを知るために、括
     弧の無い eof を使うことができます。

     (*Note 組み込み関数::,の eof の項の例を参照してください。)

-Idirectory
     `-P' といっしょに使って、C プリプロセッサにインクルードファイルを
     探す場所を示します。デフォルトでは、/usr/include と /usr/lib/perl 
     が検索されます。

-loctnum
     自動の行末処理を行なうようにします。これには、2 つの機能がありま
     す。 1 つには、`-n' や `-p' を使ったときに、自動的に行末文字を 
     chomp します。2 つめに octnum を"$\" に代入し、print 文で行末文字
     を追加できるようにします。octnum を指定しなかった場合には、その時
     点の "$/" の値を "$\" に設定します。たとえば、行を 80 カラムに切
     り詰めるには:

          perl -lpe 'substr($_, 80) = ""'

     とします。

     $\ = $/ という代入は、`-l' スイッチが処理されるときに実行されると
     きに行なわれますので、`-l' スイッチの後に `-0' スイッチを置くよう
     にすれば、入力レコードセパレータを、出力レコードセパレータと違う
     ようにもできます:

          gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

     これはまず、$\ に改行 ($/ のデフォルト値) を設定し、それから $/ 
     にヌル文字を設定します。

-n
     以下のようなループが、実際のスクリプトの回りにあるかのように Perl 
     に指示します。sed -n や awk のようにファイル名引数上で繰り返しを
     行なうことになります:

          while (<>) {
              ...             # ここでスクリプトが実行される
          }

     デフォルトでは、各行が印字されることはありません。各行の印字を行
     なうには `-p' を参照してください。以下にあげるのは、1 週間以上たっ
     たファイルを効率的に削除するものです:

          find . -mtime +7 -print | perl -nle 'unlink;'

     これは、ファイル名が見つかるごとにプロセスを起動しなくて済みます
     ので、find の -exec スイッチを使うよりも速くなります。

     awk と同じように、暗黙に実行されるループの前後に実行されるコード
     を指定するために、BEGIN ブロックと END ブロックを使うことができま
     す。

-p
     以下のようなループが、実際のスクリプトの回りにあるかのように Perl 
     に指示します。sed のようにファイル名引数上で繰り返しを行なうこと
     になります:

          while (<>) {
              ...             # ここでスクリプトが実行される
          } continue {
              print;
          }

     各行は、自動的に印字されることになります。印字を抑制するには、
     `-n' スイッチを使ってください。`-p' は `-n' スイッチを無効にしま
     す。

     awk と同じように、暗黙に実行されるループの前後に実行されるコード
     を指定するために、BEGIN ブロックと END ブロックを使うことができま
     す。

-P
     Perl によるコンパイルを行なう前に、スクリプトを C プリプロセッサ
     にかけるようにします。(コメントも CPP のディレクティブも # で始ま
     りますから、コメントの最初を Cプリプロセッサが認識してしまう 
     "if", "else", "define"といった単語で始めるべきではありません。)

-s
     コマンドライン上のスクリプト名の後から、ファイル名引数(または --) 
     の前までのスイッチのための、原始的な解析を行なえるようにします。
     ここで見つかったスイッチは、@ARGV から取り除かれ、対応する Perl 
     スクリプトの変数に設定されます。以下のスクリプトは、`-xyz' という
     スイッチを付けて実行された時にだけ、"ture" と表示するものです。

          #!/usr/bin/perl -s
          if ($xyz) { print "true\n"; }

-S
     Perl がスクリプトを探すときに環境変数 PATH を参照するようにします 
     (スクリプト名がスラッシュで始めるときを除きます)。これは、#! をサ
     ポートしていないマシンで、#! による実行をエミュレートするために、
     以下のようにして使います:

          #!/usr/bin/perl
          eval "exec /usr/bin/perl -S $0 $*"
                  if $running_under_some_shell;

     システムは、最初の行を無視し、スクリプトを /bin/sh に渡し、
     /bin/sh は Perl スクリプトをシェルスクリプトとして実行しようとし
     ます。シェルは 2 行目を通常のシェルコマンドとして実行し、Perl イ
     ンタプリタを起動することになります。$0 にフルパス名が入っていると
     は限らないシステムもありますので、`-S' が Perl に必要に応じてスク
     リプトを探すように指示します。Perl がスクリプトを見つけると、これ
     らの行の解析を始めますが、$running_under_some_shell が真になるこ
     とがないため、無視することになります。$* を使うよりもファイル名内
     に埋め込まれたスペースなどを扱うことのできる ${1+"$@"} の方がよい
     のですが、スクリプトがcsh で解釈される場合には、うまくいきません。
     csh ではなく、sh を起動するように、いくつかのシステムでは、#!  の
     行を Perl も無視することになっている、コロンだけの行で置き換える
     必要があるかもしれません。そういった制御が効かないシステムでは、
     csh でも sh でも Perl でも使える、回りくどい方法を使うことが必要
     です:

          eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
          & eval 'exec /usr/bin/perl -S $0 $argv:q'
                  if 0;

-T
     「汚染」チェックをオンにします。通常、このチェックはsetuid や 
     setgid のスクリプトを実行するときにだけ、行なわれます。*Note セキュ
     リティ::,を参照してください。

-u
     スクリプトのコンパイル後、コアダンプを行なうようにします。このコ
     アダンプを持ってきて、(Perl の配布では提供されていませんが)
     undump プログラムを使って、実行ファイルに変換することができます。
     これは多少ディスク容量を食いますが (実行ファイルを sprit すること
     で少しは減ります)、実行開始を速くすることができます。(減らしても、
     "hello world" の実行ファイルは、私のマシンで 200K 程になります。)
     ダンプする前に部分的にスクリプトを実行しておきたい場合には、この
     スイッチの代わりに dump() 演算子を使ってください。undump が実行で
     きるのは特定の環境下ですし、これが使えない移植バージョンの Perl 
     もあるでしょう。

-U
     Perl に安全でない演算を許可します。現在のところ、「安全でない」演
     算には、スーパーユーザとして実行中にディレクトリを削除することと、
     致命的な汚染チェックを警告に替えて、setuid プログラムを実行するこ
     とが含まれます。

-v
     Perl 実行ファイルのバージョンとパッチレベルを表示します。

-w
     1 度しか使われない識別子、設定される前に使われている変数に警告を
     出します。サブルーティンの再定義、未定義のファイルハンドルの参照
     や、read-only でオープンしたファイルハンドルへの書き込みにも警告
     を出します。また、数値に見えない値を数値として使った場合、配列を
     スカラであるかのように使った場合、100 段階以上のサブルーティンの
     再帰、その他たくさんの事に警告を出します。*Note デバッグ::,と
     *Note 不注意によるわな::,を参照してください。

-x directory
     テキスト中にスクリプトが埋め込まれている事を Perl につたえます。
     最初の #! で始まり、"perl" という文字列を含む行までの、先行するゴ
     ミは捨てられます。その行にある意味を持つスイッチは、(通常の #! 処
     理と同じく 1 つのまとまりだけですが) 適用されます。directory が指
     定されると、Perl はスクリプトの実行前に、そのディレクトリに移りま
     す。`-x' スイッチは先行するゴミの処分を制御するだけです。スクリプ
     トの後に無視すべきゴミがある場合には、__ END__ でスクリプトを終了
     する必要があります (その、後に続くゴミの一部または全部は、必要に
     応じて DATA ファイルハンドルを通して、そのスクリプトで処理する事
     ができます)。




File: perl-ja.info, Node: 組み込み関数, Next: 定義済み変数, Prev: 実行とオプション, Up: Top

組み込み関数
************

この節の関数は、式の中で項として使うことができます。これらは、大きく 2 
つに分けられます: リスト演算子と名前付き単項演算子です。これらの違いは、
その後に出て来るコンマとの優先順位の関係にあります。( *Note 演算子と優
先順位::,の優先順位の表を参照してください。)リスト演算子は 2 個以上の
引数をとるのに対して、単項演算子が複数の引数をとることはありません。つ
まり、コンマは単項演算子の引数の終わりとなりますが、リスト演算子の場合
には、引数の区切りでしかありません。単項演算子は一般に、引数に対してス
カラコンテキストを与えるのに対して、スカラ演算子の場合には、引数に対し
てスカラコンテキストを与える場合も、リストコンテキストを与える場合もあ
ります。1 つのリスト演算子が両方のコンテキストを与える場合には、スカラ
引数がいくつか並び、最後にリスト引数が 1 つ続きます。(リスト引数は 1 
つだけです。)たとえば、splice() は 3 つのスカラ引数に 1 つのリスト引数
が続きます。

後に載せる構文記述では、リストをとり (そのリストの要素にリストコンテキ
ストを与える) リスト演算子は、引数として LIST をとるように書いています。
そのようなリストには、任意のスカラ引数の組み合わせやリスト値を含めるこ
とができ、リスト値はリストの中に、個々の要素が展開されたように埋め込ま
れます。1 次元の長いリスト値が形成されることになります。LIST の要素は、
コンマで区切られている必要がありあます。

下のリストの関数はすべて、引数の前後の括弧は省略可能となっています。
(構文記述では省略しています。)括弧を使うときには、単純な (しかし、とき
には驚く結果となる) 規則が適用できます: 関数に見えるならば、それは関数
で、優先順位は関係ない。そう見えなければ、それはリスト演算子か単項演算
子で、優先順位が関係する。また、関数と開き括弧の間の空白は関係ありませ
んので、ときに気を付けなければなりません:

     print 1+2+3;        # 6 と出力
     print(1+2) + 3;     # 3 と出力
     print (1+2)+3;      # これも 3!
     print +(1+2)+3;     # 6 と出力
     print ((1+2)+3);    # 6 と出力

Perl に `-w' スイッチを付けて実行すれば、こういったものには警告を出し
てくれます。たとえば、上記の 3 つめは:

     print (...) interpreted as function at - line 1.
     Useless use of integer addition in void context at - line 1.

となります。スカラコンテキストでも、リストコンテキストでも使える関数は、
致命的でないエラーを示すために、スカラコンテキストでは未定義値を返し、
リストコンテキストでは空リストを返します。

以下の規則を覚えておいてください:

   * 「リストをスカラに変換するための、一般的な規則はない」

それぞれの演算子や関数について、スカラコンテキストにおいて、どんな値を
返すのが望ましいかを吟味しています。ある種の演算子では、リストコンテキ
ストであったなら、返すはずのリストの長さを返すようにしています。いくつ
の演算子は、リストの最初の値を返します。また、別の演算子は、演算がうま
くいった数を返すようにしています。一般に、一貫性さえ望まなければ、やり
たいことが、できるようになっています。

* Menu:

* 流れ制御::
* サブルーティン、パッケージ、モジュール::
* 数学関数::
* 変換関数::
* 文字列関数::
* 検索・置換関数::
* 配列関数とリスト関数::
* ファイル操作関数::
* 入出力関数::
* ディレクトリ読み出し関数::
* システム操作関数::
* ネットワーク操作関数::
* SystemV IPC 関数::
* その他の関数::







File: perl-ja.info, Node: 流れ制御, Next: サブルーティン、パッケージ、モジュール, Prev: 組み込み関数, Up: 組み込み関数

流れ制御
========


 -- Function: goto LABEL
 -- Function: goto &NAME
     `goto LABEL' の形式は、LABEL というラベルの付いた文を探して、そこ
     へ実行を移すものです。サブルーティンや`foreach' ループなど、何ら
     かの初期化が必要な構造の中に入り込むことは許されません。最適化に
     よってなくなってしまう構造の中にも `goto' することはできません。
     これ以外は、サブルーティンの外を含む、動的スコープ内のほとんどす
     べての場所へ行くために使用できますが、普通は、`last' や `die' と
     いった別の構造を使った方が良いでしょう。Perl の作者はこの形式の 
     `goto' を使う必要を感じたことは、1 度もありません (Perl では。C 
     は別のお話です)。

     `goto &NAME' の形式は、かなりマジカルなもので、現在実行中のサブルー
     ティンを、NAME で指定されたサブルーティンの呼び出しで置き換えます。
     これは、AUTOLOAD サブルーティンが別のサブルーティンをロードして、
     その別のサブルーティンが最初に呼ばれたようにするために使われます 
     (ただし、現在のサブルーティンで @_ を修正した場合には、そのその別
     のサブルーティンに伝えられます)。`goto' のあとは、`caller()' でさ
     えも、現在のサブルーティンが最初に呼び出されたと言うことができま
     せん。


 -- Function: last LABEL
 -- Function: last
     `last' コマンドは、(ループ内で使った) C の break 文と同じようなも
     ので、LABEL で指定されるループを即座に抜けます。LABEL が省略され
     ると、一番内側のループが対象となります。`continue' ブロックがあっ
     ても実行されません:

          LINE: while (<STDIN>) {
              last LINE if /^$/;      # ヘッダが終わったら抜ける
              ...
          }


 -- Function: next LABEL
 -- Function: next
     `next' コマンドは、C での continue 文のようなもので、ループの次の
     繰り返しを開始します:

          LINE: while (<STDIN>) {
              next LINE if /^#/;      # コメントを捨てる
              ...
          }

     `continue' ブロックが存在すれば、たとえ捨てられる行にあっても、そ
     れが実行されます。LABEL が省略されると、このコマンドは、もっとも
     内側のループを参照します。


 -- Function: redo LABEL
 -- Function: redo
     `redo' は、条件を再評価しないで、ループブロックの始めからもう一度
     実行を開始します。`continue' ブロックがあっても、実行されません。
     LABEL が省略されると、このコマンドは、もっとも内側のループを参照
     します。このコマンドは通常、自分への入力を欺くために使用します:

          # 単純な Pascal のコメント除去プログラム
          # (警告: 文字列中には { や } がないと仮定)
          LINE: while (<STDIN>) {
              while (s|({.*}.*){.*}|$1 |) {}
              s|{.*}| |;
              if (s|{.*| |) {
                  $front = $_;
                  while (<STDIN>) {
                      if (/}/) {      # コメントの終わり
                          s|^|$front{|;
                          redo LINE;
                      }
                  }
              }
              print;
          }







File: perl-ja.info, Node: サブルーティン、パッケージ、モジュール, Next: 数学関数, Prev: 流れ制御, Up: 組み込み関数

サブルーティン、パッケージ、モジュール
======================================


 -- Function: bless REF,PACKAGE
 -- Function: bless REF
     この関数は、(REF で渡された) 参照されるオブジェクトに対し、
     PACKAGE 内のオブジェクトとなったことを伝えます。通常は PACKAGE が
     省略され、その場合には、その時点のパッケージとなります。`bless()' 
     は通常、コンストラクタの最後に置かれますので、簡便のためにそのリ
     ファレンスを返します。オブジェクトの `bless' (や再`bless') につい
     て、詳しくは*Note オブジェクト::,を参照してください。


 -- Function: caller EXPR
 -- Function: caller
     その時点のサブルーティン呼び出しのコンテキストを返します。スカラ
     コンテキストでは、呼び元がある場合 (サブルーティン、`eval()'、
     `require()' の中にいるとき) には真を返し、その他のときには偽を返
     します。リストコンテキストでは、

          ($package,$filename,$line) = caller;

     を返します。

     EXPR を付けると、デバッガがスタックトレースを表示するために使う情
     報を返します。EXPR の値は、現状から数えて、いくつ前のコールフレー
     ムまで戻るかを示します。


 -- Function: do SUBROUTINE(LIST)
     望ましくないサブルーティン呼び出しの形式。*Note サブルーティン::,
     を参照してください。


 -- Function: do BLOCK
     実際は関数ではありません。$var{block} で示されるコマンド列の最後
     の値を返します。ループ修飾子で修飾すると、ループ条件を調べる前に 
     1 度、$var{block} を実行します。(これ以外の実行文は、ループ修飾子
     により、条件が最初に調べられます。)


 -- Function: do EXPR
     EXPR の値をファイル名として用い、そのファイルの中身を Perl のスク
     リプトとして実行します。主に、Perlのサブルーティンライブラリから
     サブルーティンをインクルードするために用います。

          do 'stat.pl';

     は、

          eval `cat stat.pl`;

     と同じようなものですが、より効率的で、簡潔であり、エラーメッセー
     ジでファイル名がわかる、カレントディレクトリでファイルが見つから
     なかったときに、`-I' に指定された全てのディレクトリを探す、といっ
     たことがあります(*Note 定義済み変数::,の「定義済み名」にある @INC 
     配列も参照してください)。しかし、呼び出すたびにファイルを解析し直
     すという点では同じですから、ループ内でこれを使おうなどとは、間違っ
     ても思ったりしないように。

     ライブラリモジュールのインクルードには、`use()' 演算子や 
     `require()' 演算子を使った方が良いでしょう。


 -- Function: import
     組み込みの `import()' 関数というものはありません。これは単に、別
     のモジュールに名前をエクスポートしたいモジュールが定義した、通常
     のメソッドサブルーティンです。`use()' 関数は、使用されるパッケー
     ジのために、`import()' メソッドを呼び出します。このドキュメントの 
     `use' の項と*Note モジュール::,を参照してください。


 -- Function: no MODULE LIST
     `use' 関数を参照してください。 `no' は、その逆を行なうものです。


 -- Function: require EXPR
 -- Function: require
     指定する EXPR か、EXPR 省略時には $_ によって、いくつかの意味を使
     い分けます。EXPR が数値のときには、実行中の Perl のバージョン ($] 
     か $PERL_VERSION) がEXPR 以上であることが必要となります。

     数値でない場合には、既に読み込まれていないときに、読み込むライブ
     ラリファイルを要求するものとなります。そのファイルは、基本的には 
     `eval()' の一種である、do-FILE によって読み込まれます。意味的には、
     次のようなサブルーティンと同じようなものです:

          sub require {
              local($filename) = @_;
              return 1 if $INC{$filename};
              local($realfilename,$result);
              ITER: {
                  foreach $prefix (@INC) {
                      $realfilename = "$prefix/$filename";
                      if (-f $realfilename) {
                          $result = do $realfilename;
                          last ITER;
                      }
                  }
                  die "Can't find $filename in \@INC";
              }
              die $@ if $@;
              die "$filename did not return true value" unless $result;
              $INC{$filename} = $realfilename;
              $result;
          }

     ファイルは、同じ名前で 2 回読み込まれることはありません。初期化コー
     ドの実行がうまくいったことを示すために、ファイルは真を返さなけれ
     ばなりませんから、真を返すようになっている自信がある場合を除いて
     は、ファイルの最後に "1;" と書くのが習慣です。実行文を追加するよ
     うな場合に備えて、"1;" と書いておいた方が良いでしょう。

     EXPR が裸の単語であるときには、標準モジュールのロードを簡単にする
     ように、`require' は拡張子が `.pm' であると仮定します。この形式の
     モジュールロードは、名前空間を変更してしまう危険はありません。

     より強力な import 機能については、このドキュメントの `use()' の項
     と、*Note モジュール::,を参照してください。


 -- Function: return LIST
     サブルーティンや `eval' から指定した値をもって、リターンします。
     (サブルーティンや `eval' に `return' がなければ、最後に評価された
     値で、自動的にリターンします。)


 -- Function: tie VARIABLE,PACKAGENAME,LIST
     この関数は、変数を、その変数のインプリメンテーションを行なうパッ
     ケージと結び付けます。VARIABLE は、魔法をかける変数の名前です。
     PACKAGENAME は、正しい型のオブジェクトをインプリメントする、パッ
     ケージの名前です。他に引数があれば、そのパッケージの `new' メソッ
     ドに渡されます。通常、これらは、C の dbm_open()などの関数に渡す引
     数となります。

     大きな DBM ファイルでは、`keys()' や `values()' のような関数は、
     大きな配列値を返す可能性があります。大きなDBM ファイルでは、
     `each()' 関数を使って繰り返しを行なった方が、よいかもしれません。
     例:

          # print out history file offsets
          tie(%HIST, NDBM_File, '/usr/lib/news/history', 1, 0);
          while (($key,$val) = each %HIST) {
              print $key, ' = ', unpack('L',$val), "\n";
          }
          untie(%HIST);

     連想配列をインプリメントするパッケージでは、次のようなメソッドを
     用意します:

        TIEHASH objectname, LIST
        DESTROY this
        FETCH this, key
        STORE this, key, value
        DELETE this, key
        EXISTS this, key
        FIRSTKEY this
        NEXTKEY this, lastkey

     通常の配列をインプリメントするパッケージでは、次のようなメソッド
     を用意します:

        TIEARRAY objectname, LIST
        DESTROY this
        FETCH this, key
        STORE this, key, value
        [others TBD]

     スカラ変数をインプリメントするパッケージでは、次のようなメソッド
     を用意します:

        * TIESCALAR objectname, LIST
        * DESTROY this
        * FETCH this,
        * STORE this, value


 -- Function: untie VARIABLE
     変数とパッケージの間の結合を解きます。(`tie()' を参照してください。)


 -- Function: use MODULE LIST
 -- Function: use MODULE
     指定したモジュールから、現在のパッケージにさまざまな内容をインポー
     トします。多くは、パッケージのサブルーティン名や、変数名に別名を
     付けることで、実現されています。これは、

          BEGIN { require Module; import Module LIST; }

     というのと、全く同値です。名前空間を変更したくない場合には、代わ
     りに `require' を使ってください。

     BEGIN によって、`require' や `import' は、コンパイル時に実行され
     ることになります。`require' は、モジュールがまだ、メモリーにロー
     ドされていなければ、ロードします。`import' は、組込みの関数ではな
     く、さまざまな機能を現在のパッケージにインポートするように、
     `Module' パッケージに伝えるために呼ばれる、通常の静的メソッドです。
     モジュール側では、`import' メソッドをどのようにでもインプリメント
     することができますが、多くのモジュールでは、`Exporter' モジュール
     で定義された、`Exporter' クラスからの継承によって、`import' メソッ
     ドを行なうようにしています。

     これは、広く公開されているインタフェースですので、プラグマ (コン
     パイラディレクティブ) は、この方法でインプリメントされています。
     現在インプリメントされているプラグマには、以下のものがあります:

          use integer;
          use sigtrap qw(SEGV BUS);
          use strict  qw(subs vars refs);
          use subs    qw(afunc blurfl);

     通常のモジュールが、現在のパッケージにシンボルをインポートする 
     (これは、ファイルの終わりまで有効です) のに対して、これらの擬似モ
     ジュールは、現在のブロックスコープにインポートを行ないます。

     これに対して、`no' コマンドという、`use' によってインポートされた
     ものを、インポートされていないことにするものがあります。

          no integer;
          no strict 'refs';

     標準モジュールやプラグマの一覧は、*Note モジュール::,を参照してく
     ださい。







File: perl-ja.info, Node: 数学関数, Next: 変換関数, Prev: サブルーティン、パッケージ、モジュール, Up: 組み込み関数

数学関数
========


 -- Function: abs VALUE
     引数の絶対値を返す。


 -- Function: atan2 Y,X
     -πからπの範囲で Y/X の逆正接を返す。


 -- Function: cos EXPR
     (ラジアンで示した) EXPR の余弦を返します。EXPR が省略されたときに
     は、$_ の余弦を取ります。


 -- Function: exp EXPR
     e (自然対数の底) の EXPR 乗を返す。EXPR を省略した場合には、
     `exp($_)' を返す。


 -- Function: int EXPR
     EXPR の整数部を返します。EXPR を省略すると、$_ を使います。


 -- Function: log EXPR
     EXPR の (e を底とする) 対数を返します。EXPR が省略されると、$_ の
     対数を返します。


 -- Function: rand EXPR
 -- Function: rand
     0 から EXPR の値までの小数の乱数値を返します。(EXPR は正の数であ
     る必要があります。) EXPR を省略すると、0 から 1 までの値を返しま
     す。この関数は、`srand()' を呼ばなければ、数列を繰り返して生成す
     るかもしれません。`srand()' も参照してください。

     (注: もし、rand 関数が、常に大きい値ばかりや、小さい数ばかりを返
     すようなら、お使いになっている Perl が、良くない RANDBITS を使っ
     てコンパイルされている可能性があります。取り敢えず、EXPR に適切な
     範囲に収まるように 2 のべき乗をかけることで凌ぐ事ができます。ただ
     し、このようにした場合には、移植性に欠けたものになります。できれ
     ば、再コンパイルした方が、良いでしょう。)


 -- Function: sin EXPR
     (ラジアンで示した) EXPR の正弦を返します。EXPR が省略されたときに
     は、$_ の正弦を取ります。


 -- Function: sqrt EXPR
     EXPR の平方根を返します。EXPR を省略すると、$_ の平方根を返します。


 -- Function: srand EXPR
     `rand' 演算子のためのシード値を設定します。EXPR を省略すると、
     `srand(time)' を実行します。もちろん、現在時間を想像するのは容易
     いことですから、暗号処理には、もっとランダムな値を使う必要がある
     があります。急激に変化する OS のステータス値プログラムの出力を圧
     縮して、チェックサムをとる、というようなことが普通、行なわれます。
     例は、定期定期に comp.security.unix に投稿されます。


 -- Function: time
     UTC で 1970 年 1 月 1 日 00:00:00 からの連続秒数を返します。
     `gmtime()' や `localtime()' への入力形式にあっています。







File: perl-ja.info, Node: 変換関数, Next: 文字列関数, Prev: 数学関数, Up: 組み込み関数

変換関数
========


 -- Function: chr NUMBER
     特定の文字セットでの NUMBER で表わされる文字を返す。たとえば、
     `chr(65)' は ASCII では "A" となります。


 -- Function: gmtime EXPR
     `time' 関数が返す時刻を、グリニッジタイムゾーンで測った時刻として、
     9 要素の配列に変換します。通常は、

          ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime(time);

     のようにして使用します。

     すべての配列要素は数値で、tm 構造体から直接持ってきます。これは特
     に、$mon が 0..11 の範囲で、$wday が 0..6 の範囲となるということ
     です。EXPR が省略されると、gmtime(time()) を行ないます。


 -- Function: hex EXPR
     EXPR を 16 進数の文字列と解釈して、10 進数の値を返します。(0 や 
     0x で始まる文字列の解釈には、`oct()' を参照してください。) EXPR 
     が省略されると、$_ を使用します。


 -- Function: localtime EXPR
     `time' 関数が返す時刻を、ローカルなタイムゾーンで測った時刻として、
     9 要素の配列に変換します。通常は、

          ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);

     のようにして使用します。

     すべての配列要素は数値で、tm 構造体から直接持ってきます。これは特
     に、$mon が 0..11 の範囲で、$wday が0..6 の範囲となるということで
     す。EXPR が省略されると、`localtime(time())' を行ないます。

     スカラコンテキストでは、ctime(3) の値を返します:

          $now_string = localtime;  # 例 "Thu Oct 13 04:54:34 1994"

     *Note モジュール::,の `timelocal' の項や POSIX モジュールによって
     使用できる strftime(3) 関数も参照してください。(訳注: と書いてあ
     るが、*Note モジュール::,に `timelocal' はない。)


 -- Function: oct EXPR
     EXPR を 8 進数文字列と解釈して、10 進数の値を返します。(EXPR が 
     0x で始まるときには、16 進数文字列と解釈します。)以下の例は、標準
     的な Perl や C の記法での 10 進数、8 進数、16 進数を扱います:

          $val = oct($val) if $val =~ /^0/;

     EXPR を省略すると、$_ を使用します。


 -- Function: ord EXPR
     EXPR の最初の文字の ASCII 値を返します。EXPR を省略した場合には、
     $_ を使用します。


 -- Function: pack TEMPLATE,LIST
     配列か値のリストをとり、バイナリの構造体に入れ、その構造体を含む
     文字列を返します。TEMPLATE は、以下のような値の型と順番を指定する
     文字を並べたものです:

        a   ASCII 文字列、ヌル文字で埋める
        A   ASCII 文字列、スペース文字で埋める
        b   ビット列 (昇ビット順、vec() と同じ)
        B   ビット列 (降ビット順)
        h   16 進数文字列 (低位ニブルが先)
        H   16 進数文字列 (高位ニブルが先)

        c   signed char 値
        C   unsigned char 値
        s   signed short 値
        S   unsigned short 値
        i   signed int 値
        I   unsigned int 値
        l   signed long 値
        L   unsigned long 値

        n   "network" 順序 (ビッグエンディアン) の short
        N   "network" 順序 (ビッグエンディアン) の long
        v   "VAX" 順序 (リトルエンディアン) の short
        V   "VAX" 順序 (リトルエンディアン) の long

        f   機種依存の単精度浮動小数点数
        d   機種依存の倍精度浮動小数点数

        p   ヌル文字で終端する文字列へのポインタ
        P   構造体 (固定長文字列) へのポインタ

        u   uuencode 文字列

        x   ヌル文字
        X   1 文字後退
        @   絶対位置までヌル文字で埋める

     これらの文字の後には、繰り返し数を示す数字を付けることができます。
     "a"、"A"、"b"、"B"、"h"、"H" を以外の型を使うとき、`pack' 関数は、
     LIST からその数の値を取り出して使います。くり返し数に * を指定す
     ると、その時点で残っているすべての要素を意味します。"a" や"A" と
     いう型を使うと、値を一つだけ取り出して使いますが、繰り返し数で示
     す長さの文字列となるように、必要に応じてヌル文字かスペース文字を
     付け足します。(unpackするとき、"A" は後続のスペース文字やヌル文字
     を取り除きますが、"a" はそのままにします。)同様に、"b" や"B" は、
     繰り返し数で示すビット長のビット列に `pack' します。(訳注: LIST 
     から要素を 1 つだけ取り出し、その要素を文字列と見て、各文字の下位 
     1 ビットづつを取り出して `pack' します。最終的に半端なビットは 0 
     で埋められます。) "h" や "H" は、そのニブル長のニブル列に `pack' 
     します。"P" は、指定した長さの構造体へのポインタを pcide{pack} し
     ます。実数 (float と double) は、機種依存のフォーマットしかありま
     せん。いろんな浮動小数点数のフォーマットが在り、標準的な 
     "network" 表現といったものがないため、データ交換のための機能は用
     意してありません。つまり、あるマシンで `pack' した浮動小数点数は、
     別のマシンでは読めないかもしれないということです。たとえ双方で 
     IEEE フォーマットの浮動小数点数演算を行なっていてもです (IEEE の
     仕様では、メモリ表現上のバイト順序までは、規定されていないからで
     す)。Perl では、(訳注: 特に指定しない限り) すべての数値演算のため
     に、内部的に double を使用しています。double から float へ変換し、
     それから再び double に戻すと精度が落ちることになります (つまり、
     `unpack("f", pack("f", $foo))' は、一般には $foo と同じではないと
     いうことです)。

     例:
          $foo = pack("cccc",65,66,67,68);
          # $foo eq "ABCD"
          $foo = pack("c4",65,66,67,68);
          # 同じ

          $foo = pack("ccxxcc",65,66,67,68);
          # $foo eq "AB\0\0CD"

          $foo = pack("s2",1,2);
          # リトルエンディアンでは、"\1\0\2\0"
          # ビッグエンディアンでは、"\0\1\0\2"

          $foo = pack("a4","abcd","x","y","z");
          # "abcd"

          $foo = pack("aaaa","abcd","x","y","z");
          # "axyz"

          $foo = pack("a14","abcdefg");
          # "abcdefg\0\0\0\0\0\0\0"

          $foo = pack("i9pl", gmtime);
          # 実際の struct tm (とにかく私のシステムでは)

          sub bintodec {
              unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
          }

     一般には、`pack' で使用したものと同じテンプレートが、`unpack' 関
     数でも使用できます。


 -- Function: unpack TEMPLATE,EXPR
     `unpack' は `pack' の逆を行ないます: 構造体を表わす文字列をとり、
     リスト値に展開し、その配列値を返します。(スカラコンテキストでは、
     単に最初の値を返します。) TEMPLATE は、`pack' 関数と同じフォーマッ
     トを使います。部分文字列を取り出すうサブルーティンの例を示します:

          sub substr {
              local($what,$where,$howmuch) = @_;
              unpack("x$where a$howmuch", $what);
          }

     そして、

          sub ordinal { unpack("c",$_[0]); } # ord() と同じ

     ということもできます。

     さらに、フィールドの前に %<数値> というものを付けて、項目自身の代
     わりに、その項目の <数値>-ビットのチェックサムを計算させることが
     できます。デフォルトは、16-ビットチェックサムです。たとえば、

          while (<>) {
              $checksum += unpack("%16C*", $_);
          }
          $checksum %= 65536;

     は、System V の sum プログラムと同じ値を計算します。

     また、

          $setbits = unpack("%32b*", $selectmask);

     は、効率的に、ビットベクターの設定されているビットを数えるもので
     す。


 -- Function: vec EXPR,OFFSET,BITS
     文字列 EXPR を unsigned int のベクターとして扱い、OFFSET と BITS 
     で指定されるビットフィールドの値を返します。左辺値として、代入の
     対象にすることもできます。BIT は、1 から 32 までの 2 のべきを値と
     して使うことができます (1, 2, 4, 8, 16, 32)。

     `vec()' で作られたベクターは、論理演算子 |、&、^ で扱うこともでき
     ます。これらの演算子は、両方の被演算子に文字列を使うと、ビットベ
     クター演算を行ないます。

     ビットベクターを、0 と 1 の文字列や配列に変換するには、

          $bits = unpack("b*", $vector);
          @bits = split(//, unpack("b*", $vector));

     のようにします。ビット長が分かっていれば、* の代わりにその長さを
     使うことができます。







File: perl-ja.info, Node: 文字列関数, Next: 検索・置換関数, Prev: 変換関数, Up: 組み込み関数

文字列関数
==========


 -- Function: chomp VARIABLE
 -- Function: chomp LIST
 -- Function: chomp
     少しばかり安全な `chop' (以下を参照してください) です。$/
     (English モジュールでは、$INPUT_RECORD_SEPARATORとも言う) のその
     時点の値に対応する行末文字を削除します。削除した文字数を返します。
     入力レコードから、改行を削除したいのだけれど、最後のレコードには
     改行が入っているのかわからないような場合に、使用することができま
     す。段落モード ($/ = "") では、レコードの最後の改行をすべて取り除
     きます。VARIABLE が省略されると、$_ を対象として `chomp' します。
     例:

          while (<>) {
              chomp;  # 最後のフィールドの \n を避ける
              @array = split(/:/);
              ...
          }

     左辺値であれば、代入を含めて、任意のものを `chomp' できます:

          chomp($cwd = `pwd`);
          chomp($answer = <STDIN>);

     リストを `chomp' すると、個々の要素が `chomp' され、削除された文
     字数の合計が返されます。


 -- Function: chop VARIABLE
 -- Function: chop LIST
 -- Function: chop
     文字列の最後の文字を切り捨てて、その切り取った文字を返します。主
     に、入力レコード末の改行を削除するために使われますが、文字列の検
     索もコピーも行ないませんので s/\n// よりも、ずっと効率的です。
     VARIABLE が省略されると、$_ を対象として `chop' します。例:

          while (<>) {
              chop;   # 最後のフィールドの \n を避ける
              @array = split(/:/);
              ...
          }

     左辺値であれば、代入を含めて、任意のものを `chop' できます:

          chop($cwd = `pwd`);
          chop($answer = <STDIN>);

     リストを `chop' すると、個々の要素が `chop' されます。最後の 
     `chop' の値だけが返されます。


 -- Function: crypt PLAINTEXT,SALT
     C ライブラリの crypt(3) 関数と全く同じように、文字列を暗号化しま
     す。パスワードファイルの中で、あまり良くないものをチェックするた
     めに使うことができます。公正な人だけが、これを行なうべきです。

     プログラムを実行する人が、自分のパスワードを知っていることを確認
     する例です:

          $pwd = (getpwuid($<))[1];
          $salt = substr($pwd, 0, 2);

          system "stty -echo";
          print "Password: ";
          chop($word = <STDIN>);
          print "\n";
          system "stty echo";

          if (crypt($word, $salt) ne $pwd) {
              die "Sorry...\n";
          } else {
              print "ok\n";
          }

     もちろん、聞かれれば、誰にでもパスワードを打ってあげるなんてのは、
     もってのほかです。


 -- Function: eval EXPR
 -- Function: eval BLOCK
     EXPR が Perl のプログラムであるかのように、解析し、実行します。そ
     の時点の Perl プログラムの脈絡の中で実行されますので、変数の設定、
     サブルーティンやフォーマットの定義は、その後も残っています。返さ
     れる値は、サブルーティン同様に、最後に評価した式の値か、return 文
     の値です。

     構文エラーや実行エラーが発生するか、`die()' 文が実行されると、
     `eval()' の値として未定義値が返され、$@ にエラーメッセージが設定
     されます。エラーがなければ、$@は、空文字列であることが保証されま
     す。EXPR を省略すると、$_ を評価します。最後のセミコロンは、式か
     ら省くことができます。

     `eval()' は、致命的エラーとなるようなものをトラップすることができ
     ますから、(`dbmopen()' や `symlink()' といった) 特定の機能がイン
     プリメントされているかを、調べるために使うことができます。die 演
     算子が例外を発生させるものとすれば、これはまた、Perl の例外捕捉機
     能と捉えることもできます。

     実行するコードが変わらないのであれば、毎回多量の再コンパイルする
     ことなしに、実行時エラーのトラップを行なうために、eval-BLOCK 形式
     を使うことができます。エラーがあれば、やはり $@ に返されます。例:

          # 0 除算を致命的でなくす
          eval { $answer = $a / $b; }; warn $@ if $@;

          # 効率的ではないが、同じ
          eval '$answer = $a / $b'; warn $@ if $@;

          # コンパイル時エラー
          eval { $answer = };

          # 実行時エラー
          eval '$answer =';   # $@ を設定

     eval() では、何が調べられるかに、特に注意しておくことが必要です:

          eval $x;            # CASE 1
          eval "$x";          # CASE 2

          eval '$x';          # CASE 3
          eval { $x };        # CASE 4

          eval "\$$x++"       # CASE 5
          $$x++;              # CASE 6

     上記の CASE 1 と CASE 2 の動作は同一で、変数 $x 内のコードを実行
     します。(ただし、CASE 2 では、必要のないダブルクォートによって、
     読む人が何が起こるか混乱することでしょう (何も起こりませんが)。)
     同様に CASE 3 と CASE 4 の動作も等しく、何もしない「$x」というコー
     ドを実行します。(純粋に見た目の問題で、CASE 4 が好まれます。)CASE
     5 の場合は、通常ダブルクォートを使用します。この状況を除けば、
     CASE 6 のように、単にシンボリックリファレンスを使えば良いでしょう。


 -- Function: lc EXPR
     EXPR を小文字に変換したものを返します。これは、ダブルクォート文字
     列における、\L エスケープをインプリメントする内部関数です。


 -- Function: lcfirst EXPR
     最初の文字だけを小文字にした、EXPR を返します。これは、ダブルクォー
     ト文字列における、\l エスケープをインプリメントする内部関数です。


 -- Function: length EXPR
     EXPR の値の文字列長を返します。EXPR が省略されたときには、$_ の長
     さを返します。


 -- Function: q/STRING/
 -- Function: qq/STRING/
 -- Function: qx/STRING/
 -- Function: qw/STRING/
     汎用のクォート。*Note 演算子と優先順位::,を参照。


 -- Function: quotemeta EXPR
     EXPR の中のすべての正規表現のメタ文字をバックスラッシュでエスケー
     プしたものを返します。これは、ダブルクォート文字列での \Q エスケー
     プをインプリメントするための内部関数です。


 -- Function: substr EXPR,OFFSET,LEN
 -- Function: substr EXPR,OFFSET
     EXPR から、部分文字列を取り出して返します。最初の文字がオフセット 
     0 もしくは、$[ に設定した値となります。OFFSET に負の値を設定する
     と、EXPR の終わりからのオフセットとなります。LEN を省略すると、
     EXPR の最後まですべてが返されます。`substr()' を左辺値として使用
     することも可能で、その場合には、EXPR が左辺値でなければなりません。
     LEN より短いものを代入したときには、EXPR は短くなり、LEN より長い
     ものを代入したときには、EXPR はそれに合わせて伸びることになります。
     EXPR の長さを一定に保つためには、`sprintf()' を使って、代入する値
     の長さを調整することが、必要になるかもしれません。


 -- Function: uc EXPR
     EXPR を大文字に変換したものを返します。これは、ダブルクォート文字
     列における、\U エスケープをインプリメントする内部関数です。


 -- Function: ucfirst EXPR
     最初の文字だけを大文字にした、EXPR を返します。これは、ダブルクォー
     ト文字列における、\u エスケープをインプリメントする内部関数です。







File: perl-ja.info, Node: 検索・置換関数, Next: 配列関数とリスト関数, Prev: 文字列関数, Up: 組み込み関数

検索・置換関数
==============


 -- Function: index STR,SUBSTR,POSITION
 -- Function: index STR,SUBSTR
     STR の中の POSITION の位置以降で、最初に SUBSTR が見つかった位置
     を返します。POSITION が省略された場合には、STR の最初から探し始め
     ます。返却値のベースは、0 もしくは、変数 $[ に設定した値です。
     SURSTR が見つからなかった場合には、ベースよりも 1 小さい値、通常
     は -1 が返されます。


 -- Function: m//
     マッチ演算子。*Note 演算子と優先順位::,を参照してください。


 -- Function: pos SCALAR
     対象の変数に対して、前回の `m//g' が終了した場所のオフセットを返
     します。そのオフセットを変えるために、変更することができます。


 -- Function: reset EXPR
 -- Function: reset
     通常、ループの最後に、変数をクリアし、?? 検索を再び動作するように
     リセットするため、`continue' ブロックで使われます。EXPR は、文字
     を並べたもの (範囲を指定するのに、ハイフンが使えます) と解釈され
     ます。名前がその文字のいずれかで始まる変数や配列は、最初の状態に
     リセットされます。EXPR を省略すると、1回検索(`?PATTERN?') を再び
     マッチするようにリセットできます。カレントパッケージの変数もしく
     は検索だけがリセットされます。常に 1 を返します。例:

          reset 'X';          # すべての X 変数をリセット
          reset 'a-z';        # 小文字変数をリセット
          reset;              # ?? 検索だけをリセット

     `reset "A-Z"' とすると、ARGV や ENV といった配列もなくなってしま
     いますから、止めた方が良いでしょう。パッケージ変数だけがリセット
     されます。字句変数は、影響を受けませんが、スコープから外れれば、
     自動的に綺麗になりますので、これからは、こちらを使うようにした方
     がよいでしょう。このドキュメントの `my' の項を参照してください。


 -- Function: rindex STR,SUBSTR,POSITION
 -- Function: rindex STR,SUBSTR
     STR 中で最後に見つかった SUBSTR の位置を返すことを除いて、`index' 
     と同じように動作します。POSITION を指定すると、その位置より前の、
     最後の位置を返します。


 -- Function: s///
     置換演算子。*Note クォートとクォートのような演算子::,を参照してく
     ださい。


 -- Function: study SCALAR
 -- Function: study
     次に変更される前に、何回も文字列に対するパターンマッチを行なうア
     プリケーションで、そのような文字列 SCALAR (省略時には $_) を予め
     学習しておきます。これは、検索のために、どのようなパターンを何回
     使うかによって、また、検索される文字列内の文字頻度の分布によって、
     時間を節約することになるかもしれませんし、逆に浪費することになる
     かもしれません。予習をした場合と、しない場合の実行時間を比較して、
     どちらが速いか調べることが、必要でしょう。短い固定文字列 (複雑な
     パターンの固定部分を含みます) をたくさん検索するループで、もっと
     も効果があるでしょう。一つの時点では、一つの `study' だけが有効で
     す。別のスカラを `study' した場合には、以前に学習した内容は「忘却」
     されてしまいます。(この `study' の仕組みは、まず、検索される文字
     列内のすべての文字のリンクされたリストが作られ、たとえば、すべて
     の 'k' がどこにあるかがわかるようになります。各おのの検索文字列か
     ら、C プログラムや英語のテキストから作られた、頻度の統計情報に基
     づいて、もっともめずらしい文字が選ばれます。この「めずらしい」文
     字を含む場所だけが調べられるのです。)

     たとえば、特定のパターンを含む行の前にインデクスを付けるエントリ
     を入れる例を示します。

          while (<>) {
              study;
              print ".IX foo\n" if /\bfoo\b/;
              print ".IX bar\n" if /\bbar\b/;
              print ".IX blurfl\n" if /\bblurfl\b/;
              ...
              print;
          }

     "f" は "o" よりもめずらしいので、`/\bfoo\b/' を探すとき、$_ で 
     "f" を含む場所だけが探されます。一般に、病的な場合を除いて、かな
     りの結果が得られます。唯一の問題は、節約できる時間が、最初にリン
     クリストを作る時間よりも多いかどうかです、

     実行時まで、探そうとする文字列がわからないときには、ループ全体を
     文字列として組み立てて、`eval' すれば、いつも、ずべてのパターンを
     再コンパイルするという事態は避けられます。ファイル全体を一つのレ
     コードとして入力するために、$/ を未定義にすれば、かなり速くなり、
     多くの場合 fgrep(1) のような専用のプログラムより速くなります。以
     下の例は、ファイルのリスト (@files) から単語のリスト (@words) を
     探して、マッチするものがあったファイル名を出力します。

          $search = 'while (<>) { study;';
          foreach $word (@words) {
              $search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";
          }
          $search .= "}";
          @ARGV = @files;
          undef $/;
          eval $search;               # ぶっ飛ばす
          $/ = "\n";          # 入力のデリミタをもとに戻す
          foreach $file (sort keys(%seen)) {
              print $file, "\n";
          }


 -- Function: tr///
     変換演算子。*Note 演算子と優先順位::,を参照してください。


 -- Function: y///
     変換演算子。*Note 演算子と優先順位::,の `tr///' の節を参照してく
     ださい。







File: perl-ja.info, Node: 配列関数とリスト関数, Next: ファイル操作関数, Prev: 検索・置換関数, Up: 組み込み関数

配列関数とリスト関数
====================


 -- Function: delete EXPR
     ハッシュ配列から指定された value を削除します。削除された値か、
     (何も削除されなかった場合には) 未定義値が返されます。`$ENV{}' か
     ら削除を行なうと、実際に環境変数を変更します。DBM ファイルに 
     `tie' された配列からの削除は、その DBM ファイルからエントリを削除
     します。(しかし、`tie' されたハッシュからの削除が、値を返すとは限
     りません。)

     以下は、連想配列のすべての value を削除します:

          foreach $key (keys %ARRAY) {
              delete $ARRAY{$key};
          }

     (ただし、`undef()' コマンドを使った方が速いでしょう。)最終的な操
     作がハッシュの key による検索である限りは、$var{expr} には任意の
     複雑な式を置くことができます:

          delete $ref->[$x][$y]{$key};


 -- Function: each ASSOC_ARRAY
     連想配列の次の value に対する、key と value からなる 2 要素の配列
     を返しますので、連想配列上での繰り返しを行なうことができます。エ
     ントリは見かけ上、ランダムな順序で返されます。配列をすべて読み込
     んでしまうと、空配列が返されます (これは代入されると、偽 (0) とな
     ります)。そのあと、もう一度 `each()' を呼び出すと、再び繰り返しを
     始めます。反復子は、配列の要素をすべて読むことによってのみリセッ
     トすることができます。繰り返しを行なっている間に、配列に要素を追
     加してはなりません。連想配列ごとに反復子が 1 つあり、プログラム中
     のすべての `each()' 関数、`keys()' 関数、`values()' 関数で共用さ
     れます。以下のプログラムは、順番が異なるものの、printenv(1) プロ
     グラムのように環境変数を表示します:

          while (($key,$value) = each %ENV) {
              print "$key=$value\n";
          }

     `keys()' や `values()' も参照してください。


 -- Function: exists EXPR
     指定されたハッシュ key が、ハッシュ配列に存在すれば、たとえ対応す
     る value が未定義でも「真」を返します。

          print "Exists\n" if exists $array{$key};
          print "Defined\n" if defined $array{$key};
          print "True\n" if $array{$key};

     ハッシュ要素は、定義されているときにのみ真となり、存在していると
     きにのみ定義されますが、逆は必ずしも真ではありません。

     最終的な操作がハッシュの key による検索である限りは、$var{expr} 
     には任意の複雑な式を置くことができます:

          if (exists $ref->[$x][$y]{$key}) { ... }


 -- Function: grep BLOCK LIST
 -- Function: grep EXPR,LIST
     LIST の個々の要素に対して、BLOCK か EXPR を評価し($_ は、ローカル
     に個々の要素が設定されます) 、その要素のうち、評価した式が真となっ
     たものからなるリスト値が返されます。スカラコンテキストでは、式が
     真となった回数を返します。例:

          @foo = grep(!/^#/, @bar);    # コメント行の除去

     は

          @foo = grep {!/^#/} @bar;    # コメント行の除去

     は、同じことをします。

     $_ は、LIST の値へのリファレンスですので、配列の要素を変更するた
     めに使うことができます。これは、便利でサポートされていますが、
     LIST が名前の付いた配列でないと、悲惨な結果になります。


 -- Function: join EXPR,LIST
     LIST の個別の文字列を、EXPR の値で区切って1 つの文字列につなげ、
     その文字列を返します。例:

          $_ = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

     この*Note 組み込み関数::,の `split' の項も参照してください。


 -- Function: keys ASSOC_ARRAY
     指定した連想配列のすべての key からなる、通常配列を返します。(ス
     カラコンテキストでは、key の数を返します。)返される key の順序は、
     見た目にばらばらなものですが (連想配列に変更がなければ)、
     `values()' 関数や `each()' 関数で返されるものと同じ順序です。環境
     変数を表示する別の例です:

          @keys = keys %ENV;
          @values = values %ENV;
          while ($#keys >= 0) {
              print pop(@keys), '=', pop(@values), "\n";
          }

     key をソートしてもいいでしょう:

          foreach $key (sort(keys %ENV)) {
              print $key, '=', $ENV{$key}, "\n";
          }


 -- Function: map BLOCK LIST
 -- Function: map EXPR,LIST
     LIST の個々の要素に対して、BLOCK か EXPR を評価し($_ は、ローカル
     に個々の要素が設定されます) 、それぞれの評価結果からなるリスト値
     が返されます。BLOCK やEXPR をリストコンテキストで評価しますので、
     LIST の個々の要素によって作られる、返却値であるリストの要素数は、
     0 個の場合もあれば、複数の場合もあります。

          @chars = map(chr, @nums);

     は、数のリストを対応する文字に変換します。また、

          %hash = map {&key($_), $_} @array;

     は、

          %hash = ();
          foreach $_ (@array) {
              $hash{&key($_)} = $_;
          }

     をちょっと変わった書き方で書いたものです。


 -- Function: pop ARRAY
     配列の最後の値をポップして返し、配列の大きさを 1 だけ小さくします。
     これは、

          $tmp = $ARRAY[$#ARRAY--];

     と同じ効果があります。指定された配列に要素がなければ、未定義値が
     返されます。


 -- Function: push ARRAY,LIST
     ARRAY をスタックとして扱い、LIST 内の値を ARRAY の終わりにプッシュ
     します。ARRAY の大きさは、LIST の長さ分だけ大きくなります。これは、

          for $value (LIST) {
              $ARRAY[++$#ARRAY] = $value;
          }

     とするのと同じ効果がありますが、より効率的です。変更後の配列の要
     素数を返します。


 -- Function: reverse LIST
     リストコンテキストでは、LIST を構成するよ要素を逆順に並べた、リス
     ト値を返します。スカラコンテキストでは、LIST の最初の要素のバイト
     順序を逆順にした文字列を返します。(訳注: 4.036 では、スカラコンテ
     キストで最初の要素ではなく、最後の要素の逆順にします。5.0000 では、
     スカラコンテキストでリストをつなげた文字列を反転しているようです。)


 -- Function: scalar EXPR
     EXPR を強制的にスカラコンテキストで解釈されるようにして、EXPR の
     値を返します。


 -- Function: shift ARRAY
 -- Function: shift
     配列の最初の値を取り出して、その値を返し、配列を一つ短くして、す
     べての要素を前へずらします。配列に要素がなければ、未定義値を返し
     ます。ARRAY を省略すると、メインプログラムでは、@ARGV 配列を 
     `shift' し、サブルーティンでは、@_ 配列を `shift' します。(これは、
     文面上で決まります。) `unshift()'、`push()'、`pop()' も参照してく
     ださい。`shift()' と `unshift()' は、`push()' と `pop()' が配列の
     右端で行なうことを、左端で行ないます。


 -- Function: sort SUBNAME LIST
 -- Function: sort BLOCK LIST
 -- Function: sort LIST
     LIST をソートし、ソートされたリスト値を返します。配列内の存在しな
     い値は、なくなります。SUBNAME やBLOCK を省略すると、標準の文字列
     比較の順番でソートが行なわれます。SUBNAME を指定すると、それは、
     配列の要素をどのような順番に並べるかに応じて、負、ゼロ、正の整数
     を返すサブルーティンの名前であると解釈されます。(このようなルーティ
     ンには、`<=>' 演算子や `cmp' 演算子が、たいへん便利です。)
     SUBNAME は、スカラ変数でもよく、その場合には、その値が使用するサ
     ブルーティンの名前と解釈されます。SUBNAME の代わりに、無名のイン
     ラインソートルーティンとして、BLOCK を書くことができます。

     効率化のために、このサブルーティンでは、通常の呼び出し処理は行な
     われず、以下のような制約があります。このサブルーティンは、再帰サ
     ブルーティンであってはなりません。比較のためサブルーティンに渡さ
     れる 2 つの要素は、@_ ではなく、$a と $b で渡されます (次の例を参
     照してください)。これらはリファレンスによって渡されるので、$a や 
     $b を変更しないでください。

     例:
          # 文字の順でソート
          @articles = sort @files;

          # 同じことを明示的にソートルーティンを指定して
          @articles = sort {$a cmp $b} @files;

          # 同じことを逆順に
          @articles = sort {$b cmp $a} @files;

          # 数値の昇順にソート
          @articles = sort {$a <=> $b} @files;

          # 数値の降順にソート
          @articles = sort {$b <=> $a} @files;

          # サブルーティン名を指定してソート
          sub byage {
              $age{$a} <=> $age{$b};  # 整数を仮定
          }
          @sortedclass = sort byage @class;

          sub backwards { $b cmp $a; }
          @harry = ('dog','cat','x','Cain','Abel');
          @george = ('gone','chased','yz','Punished','Axed');
          print sort @harry;
                  # AbelCaincatdogx と出力
          print sort backwards @harry;
                  # xdogcatCainAbel と出力
          print sort @george, 'to', @harry;
                  # AbelAxedCainPunishedcatchaseddoggonetoxyz と出力


 -- Function: splice ARRAY,OFFSET,LENGTH,LIST
 -- Function: splice ARRAY,OFFSET,LENGTH
 -- Function: splice ARRAY,OFFSET
     ARRAY から OFFSET、LENGTH で指定される要素を取り除き、LIST があれ
     ば、それを代わりに挿入します。配列から取り除かれた要素を返します。
     配列は、必要に応じて、大きくなったり、小さくなったりします。
     LENGTH が省略されると、OFFSET 以降のすべての要素を取り除きます。
     以下は、($[ == 0 と仮定すると) それぞれ、等価です。

          push(@a,$x,$y)      splice(@a,$#a+1,0,$x,$y)
          pop(@a)             splice(@a,-1)
          shift(@a)           splice(@a,0,1)
          unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
          $a[$x] = $y         splice(@a,$x,1,$y);

     次の例では、配列の前に、それぞれの配列の大きさが渡されるものとし
     ています:

          sub aeq {   # 2 つのリスト値を比較する
              local(@a) = splice(@_,0,shift);
              local(@b) = splice(@_,0,shift);
              return 0 unless @a == @b;    # 長さは等しいか
              while (@a) {
                  return 0 if pop(@a) ne pop(@b);
              }
              return 1;
          }
          if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }


 -- Function: split /PATTERN/,EXPR,LIMIT
 -- Function: split /PATTERN/,EXPR
 -- Function: split /PATTERN/
 -- Function: split
     文字列を文字列の配列に分割して、それを返します。

     リストコンテキストでない場合には、見つかったフィールドの数を返し、
     配列 @_ に分割結果を設定します。(リストコンテキストでは、パターン
     の区切り文字に ?? を使うことで、強制的に @_ に分割結果を残すこと
     ができますが、返却値は配列値のままです。)しかし、暗黙の @_への 
     `split' は使わないようにしてください。

     EXPR を省略すると、文字列 $_ を `split' します。もし、PATTERN も
     省略すると、空白 (/[ \t\n]+/) で `split' します。PATTERN にマッチ
     するものは、フィールドを分割するデリミタとして扱われます。(デリミ
     タは、1 文字とは限りません。)負でない LIMIT を指定した場合には、
     最大その数までのフィールドに `split' します (しかし、それより少な
     いことはあります)。LIMIT を指定しないと、末尾の空フィールドを捨て
     てしまいます (`pop()' を行なうときには気を付けないといけません)。
     LIMIT が負ならば、LIMIT に任意の大きな数を指定したのと同じことに
     なります。

     空文字列にマッチするパターン (ヌルパターン // と混同しないでくだ
     さい。これは、空文字列にマッチするパターンの一つでしかありません) 
     は、どの場所にもマッチし、EXPR の値を1 文字ずつに分割します。たと
     えば、

          print join(':', split(/ */, 'hi there'));

     は、'h:i:t:h:e:r:e' という出力になります。

     LIMIT を使うと、行を部分的に `split' することができます。

          ($login, $passwd, $remainder) = split(/:/, $_, 3);

     リストへ代入するとき、LIMIT を省略すると、Perl は、無駄な仕事を避
     けるため、そのリストの変数の数より、1つだけ大きい LIMIT が与えら
     れたものとして処理を行ないます。上のリストの場合には、LIMIT はデ
     フォルトで 4 になります。時間が問題となるアプリケーションでは、必
     要以上のフィールドに分けないようにする必要があります。

     PATTERN に括弧が含まれていると、デリミタ内の部分文字列にマッチす
     るものも、配列要素に含まれるようになります。

          split(/([,-])/, "1-10,20");

     は、リスト値

          (1, '-', 10, ',', 20)

     を生成します。

     `/PATTERN/' は、実行時に変わるパターンを指定する式で置き換えるこ
     とができます。(実行時のコンパイルを 1 度にするために、
     `/$variable/o' を使ってください。) 特別な場合として、スペース ('
     ') を指定すると、引数なしの `split' のように空白で `split' を行な
     いますが、先頭の空白で、最初に空のフィールドができません。つまり、
     `split(' ')' は、awk のデフォルトの動作をエミュレートするために使
     うことができ、`split(/ /)' は行頭のスペースの数に応じた空フィール
     ドができます。

     例:
          open(passwd, '/etc/passwd');
          while (<passwd>) {
              ($login, $passwd, $uid, $gid,
                       $gcos, $home, $shell) = split(/:/);
              ...
          }

     (上記の $shell には、まだ改行がついたままです。このドキュメントの 
     `chop'、`chomp'、`join' の項を参照してください。)


 -- Function: unshift ARRAY,LIST
     `shift' の逆操作を行ないます。見方を変えれば、`push' の逆操作とも
     考えられます。LIST を ARRAY の先頭に入れて、新しくできた配列の要
     素の数を返します。

          unshift(ARGV, '-e') unless $ARGV[0] =~ /^-/;

     LIST は、はらばらにではなく、一度に登録されるので、順番はそのまま
     です。逆順に登録するには、`reverse' を使ってください。


 -- Function: values ASSOC_ARRAY
     指定した連想配列のすべての value からなる通常配列を返します。(ス
     カラコンテキストでは、value の数を返します。) 返される value の順
     序は、見た目にばらばらなものですが、同じ配列に対して、`keys()' 関
     数や `each()' 関数が返すものと同じ順序です。`keys()' と `each()' 
     も参照してください。







File: perl-ja.info, Node: ファイル操作関数, Next: 入出力関数, Prev: 配列関数とリスト関数, Up: 組み込み関数

ファイル操作関数
================


 -- Function: -X FILEHANDLE
 -- Function: -X EXPR
 -- Function: -X
     X は以下にあげる文字で、ファイルテストを行なう。この単項演算子は、
     ファイル名かファイルハンドルを唯一の引数として動作し、「あること」
     について真であるか否かを判定した結果を返します。引数が省略される
     と、`-t' では STDIN を調べますが、その他は $_ を調べます。特に記
     述されていなければ、真として 1 を返し、偽として '' を返し、ファイ
     ルが存在しなければ、未定義値を返します。みかけは変わっていますが、
     優先順位は名前付き単項演算子と同じで、他の単項演算子と同じく、引
     数を括弧で括ることもできます。演算子には:

        -r  ファイルが実効 uid/gid で読み出し可
        -w  ファイルが実効 uid/gid で書き込み可
        -x  ファイルが実効 uid/gid で実行可
        -o  ファイルが実効 uid の所有物

        -R  ファイルが実 uid/gid で読み出し可
        -W  ファイルが実 uid/gid で書き込み可
        -X  ファイルが実 uid/gid で実行可
        -O  ファイルが実 uid の所有物

        -e  ファイルが存在する
        -z  ファイルの大きさがゼロ
        -s  ファイルの大きさがゼロ以外 (大きさを返す)

        -f  ファイルは通常ファイル
        -d  ファイルはディレクトリ
        -l  ファイルはシンボリックリンク
        -p  ファイルは名前付きパイプ (FIFO)
        -S  ファイルはソケット
        -b  ファイルはブロック特殊ファイル
        -c  ファイルはキャラクタ特殊ファイル
        -t  ファイルハンドルは tty にオープンされている

        -u  ファイルの setuid ビットがセットされている
        -g  ファイルの setgid ビットがセットされている
        -k  ファイルの sticky ビットがセットされている

        -T  ファイルはテキストファイル
        -B  ファイルはバイナリファイル (-T の反対)

        -M  スクリプト実行開始時のファイル修正からの日数
        -A  同様にアクセスがあってからの日数
        -C  同様に inode が変更されてからの日数

     があります。

     ファイルのパーミッション演算子 `-r', `-R', `-w', `-W', `-x', `-X' 
     の解釈は、ファイルのモードとユーザの実効／実 uidと実効／実 gid の
     みから判断されます。実際にファイルが読めたり、書けたり、実行でき
     たりするためには、別の条件が必要かもしれません。スーパーユーザに
     は、`-r', `-R', `-w', `-W' に対して、常に 1 が返り、モード中のい
     ずれかの実行許可ビットが立っていれば、`-x', `-X' にも 1 が返るこ
     とにも注意してください。スーパーユーザが実行するスクリプトでは、
     ファイルのモードを調べるためには、stat() を行なうか、uid を一時的
     に別のものにする必要があるでしょう。

     例:
          while (<>) {
              chop;
              next unless -f $_;  # 通常ファイル以外はスキップ
              ...
          }

     -s/a/b は、置換演算 (s///) の符号反転ではありません。しかし、-exp($foo) 
     は期待どおりに動作します。マイナス記号の後に英字が 1 字続くときに
     のみ、ファイルテストと解釈されます。

     ファイルテスト `-T' と `-B' の動作原理は、次のようになっています。
     ファイルの最初の数ブロックを調べて、変わった制御コードや上位ビッ
     トがセットされているような、通常のテキストには現れない文字を探し
     ます。そのような文字が、たくさん (>30%) 見つかるようであれば、そ
     のファイルは `-B' ファイルであると判断され、それほど見つからなけ
     れば、`-T' ファイルとなります。最初のブロックにヌル文字が含まれる
     ファイルも、バイナリファイルとみなされます。`-T' や `-B' をファイ
     ルハンドルに対して用いると、最初のブロックを調べる代わりに、標準
     入出力バッファを調べます。調べたファイルの中身が何もないときや、
     ファイルハンドルを調べたときに EOF に達していたときには、`-T' も 
     `-B' も「真」を返します。

     どのファイルテスト (あるいは、stat() や lstat()) 演算子にも、下線
     だけから成る特別なファイルハンドルを与えると、前回のファイルテス
     ト (や stat) の stat 構造体が使われ、システムコールを省きます。
     (`-t' には使えませんし、lstat() や `-l' は実ファイルではなく、シ
     ンボリックリンクの情報を stat 構造体に残すことを覚えておく必要が
     あります。) 例:

          print "Can do.\n" if -r $a || -w _ || -x _;

          stat($filename);
          print "Readable\n" if -r _;
          print "Writable\n" if -w _;
          print "Executable\n" if -x _;
          print "Setuid\n" if -u _;
          print "Setgid\n" if -g _;
          print "Sticky\n" if -k _;
          print "Text\n" if -T _;
          print "Binary\n" if -B _;


 -- Function: chmod LIST
     LIST に含まれるファイルの、パーミッションを変更します。LIST の最
     初の要素は、数値表現のモードでなければなりません。変更に成功した
     ファイルの数を返します。

          $cnt = chmod 0755, 'foo', 'bar';
          chmod 0755, @executables;


 -- Function: chown LIST
     LIST に含まれるファイルの所有者 (とグループ) を変更します。LIST 
     の最初の 2 つの要素には、「数値表現」の uid と gid をこの順序で与
     えなければなりません。変更に成功したファイルの数が返されます。

          $cnt = chown $uid, $gid, 'foo', 'bar';
          chown $uid, $gid, @filenames;

     passwd ファイルから数値表現でない uid を検索する例を示します:

          print "User: ";
          chop($user = <STDIN>);
          print "Files: "
          chop($pattern = <STDIN>);

          ($login,$pass,$uid,$gid) = getpwnam($user)
              or die "$user not in passwd file";

          @ary = <${pattern}>;        # ファイル名の展開
          chown $uid, $gid, @ary;


 -- Function: link OLDFILE,NEWFILE
     OLDFILE にリンクされた、新しいファイル NEWFILE を作ります。成功時
     には 1 を、失敗時には 0 を返します。


 -- Function: lstat FILEHANDLE
 -- Function: lstat EXPR
     `stat()' 関数と同じことをするが、シンボリックリンクが指しているファ
     イルではなく、シンボリック自体の `stat'をとります。シンボリックリ
     ンクがシステムにインプリメントされていないと、通常の `stat()' が
     行なわれます。


 -- Function: mkdir FILENAME,MODE
     FILENAME で指定したディレクトリを、MODE で指定した許可モード (を 
     `umask' で修正したもの) で作成します。成功時には 1 を返し、失敗時
     には 0 を返して $! (errno)を設定します。


 -- Function: readlink EXPR
     シンボリックリンクがインプリメントされていれば、シンボリックリン
     クの値を返します。インプリメントされていないときには、致命的エラー
     となります。何らかのシステムエラーが検出されると、未定義値を返し、
     $! (errno)を設定します。EXPR を省略すると、$_ を使用します。


 -- Function: rename OLDNAME,NEWNAME
     ファイルの名前を変更します。成功時には 1、失敗時には 0 を返します。
     ファイルシステムにまたがって、パス名を付け替えることはできません。


 -- Function: rmdir FILENAME
     FILENAME で指定したディレクトリが空であれば、そのディレクトリを削
     除します。成功時には 1 を返し、失敗時には 0 を返し、$! (errno) を
     設定します。FILENAME を省略した場合には、$_ を使用します。


 -- Function: stat FILEHANDLE
 -- Function: stat EXPR
     FILEHANDLE を通じてオープンされているファイルか、EXPR で指定され
     るファイルの情報を与える、13 要素の配列を返します。`stat' に失敗
     した場合には、空リストを返します。普通は、

          ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
             $atime,$mtime,$ctime,$blksize,$blocks)
                 = stat($filename);

     のようにして使います。

     下線だけの _ という、特別なファイルハンドルを、`stat' に渡すと、
     実際には `stat' を行なわず、stat 構造体に残っている、前回の 
     `stat' やファイルテストの情報が返されます。例:

          if (-x $file && (($d) = stat(_)) && $d < 0) {
              print "$file is executable NFS file\n";
          }

     (これは、NFS のもとでデバイス番号が負になるマシンでのみ動作します。)


 -- Function: symlink OLDFILE,NEWFILE
     NEWFILE として、OLDFILE へのシンボリックリンクを生成します。成功
     時には 1 を返し、失敗時には 0 を返します。シンボリックリンクをサ
     ポートしていないシステムでは、実行時に致命的エラーが発生します。
     これをチェックするには、`eval' を使用します:

          $symlink_exists = (eval 'symlink("","");', $@ eq ");


 -- Function: truncate FILEHANDLE,LENGTH
 -- Function: truncate EXPR,LENGTH
     FILEHANDLE 上にオープンされたファイルか、EXPR で名前を表わしたファ
     イルを、指定した長さに切り詰めます。システム上に `truncate' がイ
     ンプリメントされていなければ、致命的エラーとなります。


 -- Function: unlink LIST
     LIST に含まれるファイルを削除します。削除に成功したファイルの数を
     返します。

          $cnt = unlink 'a', 'b', 'c';
          unlink @goners;
          unlink <*.bak>;

     注: スーパーユーザ権限で、Perl に `-U' を付けて実行した場合でなけ
     れば、`unlink' でディレクトリを削除することはありません。この条件
     にあう場合にも、ディレクトリの削除は、ファイルシステムに多大な損
     害を与える可能性がありますので、特に注意が必要です。`rmdir' を代
     わりに使ってください。


 -- Function: utime LIST
     ファイルのアクセス時刻と修正時刻を変更します。LIST の最初の 2 つ
     の要素に、数値で表わしたアクセス時刻と修正時刻を順に指定します。
     LIST の残りの要素が、変更の対象となるファイルです。変更に成功した
     ファイルの数を返します。各ファイルの inode 修正時刻には、その時点
     の時刻が設定されます。`touch' コマンドの例です:

          #!/usr/bin/perl
          $now = time;
          utime $now, $now, @ARGV;







File: perl-ja.info, Node: 入出力関数, Next: ディレクトリ読み出し関数, Prev: ファイル操作関数, Up: 組み込み関数

入出力関数
==========


 -- Function: binmode FILEHANDLE
     バイナリファイルとテキストファイルを区別する OS において、指定ファ
     イルを「バイナリ」で読み書きするように指定します。バイナリモード
     ではないファイルは、入力時に CR LF の連続が LF に置き換えられ、出
     力時に LF が CR LF の列に置き換えられます。`binmode' は、UNIX で
     は何の影響もなく、DOS では必須かもしれません。FILEHANDLE が式であ
     る場合には、その式の値がファイルハンドルの名前として使われます。


 -- Function: close FILEHANDLE
     FILEHANDLE に対応したファイルまたはパイプをクローズし、標準入出力
     が正常にバッファのフラッシュを行なって、ファイル記述子のクローズ
     したときにのみ「真」を返します。クローズしてすぐにまた、同じファ
     イルハンドルに対してオープンを行なう場合には、`open' が自動的に 
     `close' を行ないますので、`close FILEHANDLE' する必要はありません。
     (`open()' 参照。)ただし、明示的にクローズを行なったときにのみ入力
     ファイルの行番号 ($.) のリセットが行なわれ、`open()' によって行な
     われる暗黙の `close' では行なわれません。また、後でパイプの出力を
     見たい場合のために、パイプのクローズでは、パイプ上で実行されてい
     るプロセスの完了を待ちます。明示的なパイプのクローズはまた、コマ
     ンドのステータス値を $?  に設定します。例:

          open(OUTPUT, '|sort >foo'); # sort へのパイプ
          ...                         # 出力
          close OUTPUT;               # sort の完了を待つ
          open(INPUT, 'foo');         # 結果を入力

     FILEHANDLE は、実際のファイルハンドル名を値とする式でもかまいませ
     ん。


 -- Function: dbmclose ASSOC_ARRAY
     [この関数は、`untie()' 関数にとって代わられました。]

     DBM ファイルと連想配列の連結をはずします。


 -- Function: dbmopen ASSOC,DBNAME,MODE
     [この関数は、tie() 関数にとって代わられました。]

     dbm(3) ファイルまたは ndbm(3) ファイルを連想配列に結び付けます。
     ASSOC は、その連想配列の名前です。(普通の `open' とは違って、最初
     の引数はファイルハンドルではありません。まあ、似たようなものです
     が。) DBNAME は、データベースの名前です (拡張子の .dir や .pag は
     つけません)。データベースが存在しなければ、MODE (を `umask()' で
     修正したもの) で指定されたモードで作られます。古い DBM 関数のみを
     サポートしているシステムでは、プログラム中で 1 度だけ `dbmopen()' 
     を実行することができます。DBM も ndbm も持っていないシステムでは、
     `dbmopen()' を呼び出すと致命的エラーになります。

     DBM ファイルに対して、書き込み権が無いときには、連想配列を読みだ
     すことだけができ、設定することはできません。書けるか否かを調べた
     い場合には、ファイルテスト演算子を使うか、エラーをトラップしてく
     れる、`eval()' の中で、ダミーのエントリを設定してみることになりま
     す。

     大きな DBM ファイルを扱うときには、`keys()' や `values()' のよう
     な関数は、巨大は配列を返します。大きな DBM ファイルでは、`each()' 
     関数を使って繰り返しを行なった方が良いかもしれません。例:

          # history ファイルのオフセットを印字
          dbmopen(%HIST,'/usr/lib/news/history',0666);
          while (($key,$val) = each %HIST) {
              print $key, ' = ', unpack('L',$val), "\n";
          }
          dbmclose(%HIST);


 -- Function: eof FILEHANDLE
 -- Function: eof
     次に FILEHANDLE 上で読み込みを行なったときに、 EOF が返されるとき
     か、FILEHANDLE がオープンされていないと、1 を返します。FILEHANDLE 
     は、値が実際のファイルハンドル名を示す式であってもかまいません。
     (この関数は、実際に文字を読み、`ungetc()' を行ないますので、対話
     型の場合には、それ程有用ではありません。)引数を省略した `eof' は、
     最後に読み込みを行なったファイルの EOF 状態を返します。空の括弧 
     () は、コマンドラインのファイルリストで構成される、擬似ファイルを
     示すために用いられます。つまり `eof()' は、`while (<>)' ループの
     中で、最終ファイルの最後を検出するために使えます。`while (<>)' ルー
     プの個々のファイルを調べるには、`eof(ARGV)' か、括弧なしの `eof' 
     を用います。例:

          # 最後のファイルの最終行の前にダッシュを入れる
          while (<>) {
              if (eof()) {
                  print "--------------\n";
              }
              print;
          }

          # ファイルごとに行番号をリセットする
          while (<>) {
              print "$.\t$_";
              if (eof) {      # eof() ではない
                  close(ARGV);
              }
          }

     現実的なヒント: Perl で `eof' が必要となることは、ほとんどありま
     せん。データがなくなったときに、入力演算子が未定義値を返してくれ
     るからです。


 -- Function: fcntl FILEHANDLE,FUNCTION,SCALAR
     fcntl(2) 関数をインプリメントします。正しい関数定義を得るために、
     まず、

          use Fcntl;

     と書くことが必要でしょう。引数の処理と返却値については、下記の 
     ioctl() と同様に動作します。fcntl(2)がインプリメントされていない
     マシンでは、fcntl() は致命的エラーを引き起こします。使用例:

          use Fcntl;
          fcntl($filehandle, F_GETLK, $packed_return_buffer);


 -- Function: fileno FILEHANDLE
     ファイルハンドルに対するファイル記述子を返します。`select()' に対
     する、ビットマップを構成するときに便利です。FILEHANDLE が式であれ
     ば、その値がファイルハンドルの名前として使われます。


 -- Function: flock FILEHANDLE,OPERATION
     FILEHANDLE に対して flock(2) を呼び出します。OPERATION の記述につ
     いては、flock(2) manpage を参照してください。成功時には真を、失敗
     時には偽を返します。flock(2) がインプリメントされていないマシンで
     の実行は、致命的エラーとなります。BSD システムでのメールボックス
     への追加処理の例を示します。

          $LOCK_SH = 1;
          $LOCK_EX = 2;
          $LOCK_NB = 4;
          $LOCK_UN = 8;

          sub lock {
              flock(MBOX,$LOCK_EX);
              # さらに、待っている間に書き足した
              # 人がいるといけないので ...
              seek(MBOX, 0, 2);
          }

          sub unlock {
              flock(MBOX,$LOCK_UN);
          }

          open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
                  or die "Can't open mailbox: $!";

          lock();
          print MBOX $msg,"\n\n";
          unlock();

     `flock()' ではネットワークをまたがって、ロックは行なえません。こ
     のためには、`fcntl()' を使ってロックしなくてはなりません。


 -- Function: formline PICTURE, LIST
     これは、`format' が使用する内部関数ですが、直接呼び出すこともでき
     ます。これは、PICTURE の内容にしたがって、LIST の値を整形し 
     (*Note フォーマット文::,を参照してください)、結果をフォーマット出
     力アキュムレータ $^A に納めます。最終的に、WRITE() がなされると、
     $^A の中身が、何らかのファイルハンドルに書き出されますが、自分で 
     $^A を読んで、$^A の内容を "" に戻してもかまいません。`format' は
     通常、1 行ごとに `formline()' を行ないますが、`formline()' 関数自
     身は、PICTURE の中にいくつの改行が入っているかは、関係がありませ
     ん。ダブルクォートで PICTURE を囲む場合には、"@" という文字が配列
     名の始まりと解釈されますので、注意してください。

     `formline()' は常に「真」を返します。


 -- Function: getc FILEHANDLE
 -- Function: getc
     FILEHANDLE につながれている入力ファイルから、次の一文字を返します。
     EOF では、空文字列を返します。FILEHANDLE が省略された場合には、
     STDIN から読み込みを行ないます。


 -- Function: ioctl FILEHANDLE,FUNCTION,SCALAR
     ioctl(2) 関数をインプリメントします。正しい関数の定義を得るために、
     おそらく最初に

          require "ioctl.ph"; # たぶん /usr/local/lib/perl/ioctl.ph

     としなくてはならないでしょう。ioctl.h がないか、間違った定義をし
     ている場合には、<sys/ioctl.ph> のような C のヘッダファイルをもと
     に、自分で作らなければなりません。(これを手助けしてくれる、h2ph 
     という Perl スクリプトが Perl の配布キットに入っています。)
     FUNCTION に応じて SCALAR が読み書きされます。SCALAR の文字列値へ
     のポインタが、実際の ioctl コールの 3 番目の引数として渡されます。
     (SCALAR が文字列値を持っておらず、数値を持っている場合には、文字
     列値へのポインタの代わりに、その値が渡されます。このことを保証す
     るためには、使用する前に SCALAR に 0 を足してください。)
     `ioctl()' で使われる構造体の値を操作するには、`pack()' 関数と 
     `unpack()' 関数が便利です。以下の例は、1 文字削除の文字として DEL 
     を指定します。

          require 'ioctl.ph';
          $sgttyb_t = "ccccs";   # 4 つの char と 1 つの short
          if (ioctl(STDIN,$TIOCGETP,$sgttyb)) {
              @ary = unpack($sgttyb_t,$sgttyb);
              $ary[2] = 127;
              $sgttyb = pack($sgttyb_t,@ary);
              ioctl(STDIN,$TIOCSETP,$sgttyb)
                  || die "Can't ioctl: $!";
          }

     ioctl (と fcntl) の返却値は、

            OS からの返却値  |  Perl の返却値
          -------------------+-----------------------------
                  -1         |  未定義値
                   0         |  "0 but true" という文字列
                その他       |  OS からの返却値

     のようになっています。

     つまり Perl は、成功時に「真」、失敗時に「偽」を返すことになり、
     OS が実際に返した値も、

          ($retval = ioctl(...)) || ($retval = -1);
          printf "System returned %d\n", $retval;

     のように簡単に知ることができます。


 -- Function: open FILEHANDLE,EXPR
 -- Function: open FILEHANDLE
     EXPR でファイル名を指定するファイルをオープンして、FILEHANDLE に
     対応させます。FILEHANDLE が式のときには、その値が実際に使用するファ
     イルハンドルの名前として使われます。EXPR を省略すると、FILEHANDLE 
     と同じ名前のスカラ変数に、ファイル名が入れられているものとして処
     理されます。ファイル名の先頭に "<" を付けるか、何も付けなかった場
     合には、入力用としてオープンされることになります。先頭に ">" を付
     けると、ファイルは出力用にオープンされます。同じように ">>" を付
     けるとアペンド用にオープンされます。(">" や "<" の前に "+" を置く
     ことで、ファイルを読み書き両用にすることもできます。)ファイル名の
     先頭に "|" を付けると、そのファイル名をコマンドとして解釈し、ファ
     イルハンドルへの出力がパイプを通じて、そのコマンドへ入力されます。
     逆にファイル名の最後に "|" を付けた場合には、同様にファイル名をコ
     マンドと解釈し、そのコマンドの出力がパイプを通じて、ファイルハン
     ドルから入力として読み込むことができるようになります。(入出力両用
     にパイプするコマンドは使えません。訳注: ただし、Perl モジュール 
     `IPC::Open2' や `IPC::Open3' が使えます。) "-" を `open' すると 
     STDIN がオープンされ、">-" を `open' すると STDOUT がオープンされ
     ます。`open' は、成功時には、ゼロ以外を返し、失敗時には未定義値を
     返します。パイプに関る `open' のときには、返却値はサブプロセスの 
     pid となります。例:

          $ARTICLE = 100;
          open ARTICLE or die "Can't find article $ARTICLE: $!\n";
          while (<ARTICLE>) {...

          open(LOG, '>>/usr/spool/news/twitlog'); # (log は予約語)

          open(article, "caesar <$article |");    # 記事の復号

          open(extract, "|sort >/tmp/Tmp$$");     # $$ は現 pid

          # include を使っているファイルのリストを処理する

          foreach $file (@ARGV) {
              process($file, 'fh00');
          }

          sub process {
              local($filename, $input) = @_;
              $input++;               # マジカルインクリメント
              unless (open($input, $filename)) {
                  print STDERR "Can't open $filename: $!\n";
                  return;
              }
              while (<$input>) {        # 間接ファイルハンドル
                  if (/^#include "(.*)"/) {
                      process($1, $input);
                      next;
                  }
                  ...         # 好きな処理
              }
          }

     Bourne シェルの慣例にしたがって、EXPR の先頭に ">&"を付けると、
     EXPR の残りの文字列をファイルハンドル名(数字であれば、ファイル記
     述子) と解釈して、それを dupしてオープンします。"&" は、">"、">>"、
     "<"、"+>"、"+>>"、"+<" というモード指定に付けることができます。指
     定するモード指定は、もとのファイルハンドルのモードと合っていない
     といけません。STDOUT と STDERR をいったん保存し、リダイレクトし、
     元に戻すスクリプトを示します。

          #!/usr/bin/perl
          open(SAVEOUT, ">&STDOUT");
          open(SAVEERR, ">&STDERR");

          open(STDOUT, ">foo.out") || die "Can't redirect stdout";
          open(STDERR, ">&STDOUT") || die "Can't dup stdout";

          select(STDERR); $| = 1;     # バッファリングしない
          select(STDOUT); $| = 1;     # バッファリングしない

          print STDOUT "stdout 1\n";  # これはサブプロセス
          print STDERR "stderr 1\n";  # でも働きます

          close(STDOUT);
          close(STDERR);

          open(STDOUT, ">&SAVEOUT");
          open(STDERR, ">&SAVEERR");

          print STDOUT "stdout 2\n";
          print STDERR "stderr 2\n";

     N を数値として、"<&=N" と指定すると、Perl は、そのファイル記述子
     に対する C の fdopen() と同じことを行ないます。たとえば:

          open(FILEHANDLE, "<&=$fd")

     "-|" や "|-" というふうに、"-" というコマンドにパイプをオープンす
     ると、`fork' が行なわれ、`open' の返却値として、親プロセスにはチャ
     イルドプロセスの pid が、チャイルドプロセスには 0 が返されます。
     (open が成功したかどうかは、`defined($pid)' のようにして調べるこ
     とができます。) 親プロセスでは、このファイルハンドルは通常通りに
     動作しますが、行なわれる入出力は、チャイルドプロセスの 
     STDIN/STDOUT にパイプされます。チャイルドプロセス側では、そのファ
     イルハンドルはオープンされず、入出力は新しい STDOUT か STDIN に対
     して行なわれます。これは、setuid で実行して、シェルコマンドのメタ
     文字を検索させたくないような場合に、パイプコマンドの起動の仕方を
     制御したいとき、普通のパイプの `open' と同じように使います。以下
     の組み合わせは、だいたい同じものです:

          open(FOO, "|tr '[a-z]' '[A-Z]'");
          open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';

          open(FOO, "cat -n '$file'|");
          open(FOO, "-|") || exec 'cat', '-n', $file;

     パイプのファイルハンドルを明示的に `close' することで、親プロセス
     は、チャイルドプロセスの終了を待ち、$? にステータス値を返します。
     注: `fork' を行なう操作では、フラッシュされていないバッファがある
     と、`fork' 後には、そのバッファの内容が両方のプロセスで残ったまま
     になってしまいますから、出力がダブらないように $| を設定する必要
     があるかもしれません。

     オープンするために渡されたファイル名は、はじめと終わりの空白が取
     り除かれます。妙な文字が含まれているようなファイル名をオープンす
     るには、次のようにして、最初と最後の空白を保護します:

          $file =~ s#^(\s)#./$1#;
          open(FOO, "< $file\0");


 -- Function: pipe READHANDLE,WRITEHANDLE
     対応するシステムコールと同じように、接続されたパイプのペアをオー
     プンします。パイプでプロセスをループにするときには、よほど気を付
     けないと、デッドロックは起こります。さらに、Perl のパイプでは、
     stdio のバッファリングを使いますから、アプリケーションによっては、
     コマンドごとに WRITEHANDLE をフラッシュするように、$| を設定する
     ことが必要になるかもしれません。


 -- Function: print FILEHANDLE LIST
 -- Function: print LIST
 -- Function: print
     文字列かコンマで区切った文字列のリストを出力します。成功時には、
     ゼロ以外を返します。FAILEHANDLE は、スカラ変数名でもよく、その場
     合には、その変数にファイルハンドル名が入っているものとして扱われ
     ますから、一段階の間接指定が行なえます。(注: FILEHANDLE に変数を
     使い、次のトークンが「項」のときには、間に + を置くか、引数の前後
     を括弧で括らなければ、誤って解釈されることがあります。)
     FILEHANDLE を省略した場合には、標準出力 (か、最後に選択された出力
     チャネル -- `select()' を参照) に出力します。LIST も省略すると、
     $_ を STDOUT に出力することになります。デフォルトの出力チャネルを 
     STDOUT 以外にしたければ、`select' 演算子を使ってください。`print' 
     の引数は LIST です。LIST の中のものは、すべてリストコンテキストで
     評価されます。サブルーティンの呼び出しがあれば、リストコンテキス
     トでは、複数の値を返すかもしれません。また、すべての引数を括弧で
     括るのでなければ、`print' というキーワードの次に開き括弧を書いて
     はいけません。`print' と引数の間に "+" を書くか、すべての引数を括
     弧で括ってください。


 -- Function: printf FILEHANDLE LIST
 -- Function: printf LIST
     `print FILEHANDLE sprintf(LIST)' と等価です。LIST の最初の要素は、
     `printf' フォーマットと解釈されます。


 -- Function: read FILEHANDLE,SCALAR,LENGTH,OFFSET
 -- Function: read FILEHANDLE,SCALAR,LENGTH
     指定した FILEHANDLE から、変数 SCALAR に LENGTH バイトのデータを
     読み込みます。実際に読み込まれたバイト数か、エラー時には `undef' 
     を返します。SCALAR は、実際に読み込んだ長さに応じて、伸び縮みしま
     す。OFFSETを指定すると、SCALAR の先頭以外の場所から、読み込みを行
     ないうことができます。この関数は、stdio ライブラリの fread() 関数
     を使ってインプリメントしています。実際のシステムコールを利用する
     には、`sysread()' を参照してください。


 -- Function: seek FILEHANDLE,POSITION,WHENCE
     stdio ライブラリの fseek() 関数のように、FILEHANDLE のファイルポ
     インタを任意の位置に設定します。FILEHANDLE は、実際のファイルハン
     ドル名を与える式でもかまいません。WHENCE の値が、0 ならば、ファイ
     ルポインタを POSITION の位置へ、1 ならば、現在位置からPOSITION 離
     れた位置へ、2 ならば、EOF から POSITION だけ離れた位置へ、ファイ
     ルポインタを設定します。この値には、POSIX モジュールで使われてい
     る SEEK_SET、SEEK_CUR、SEEK_END を使うこともできます。成功時には、
     1 を、失敗時には 0 を返します。


 -- Function: select FILEHANDLE
 -- Function: select
     その時点で、選択されていたファイルハンドルを返します。FILEHANDLE 
     を指定した場合には、その値を出力のデフォルトファイルハンドルに設
     定します。これには、2 つの効果があります。まず、ファイルハンドル
     を指定しないで `write' や `print' を行なった場合のデフォルトが、
     この FILEHANDLE になります。もう一つは、出力関連の変数への参照は、
     この出力チャネルを参照するようになります。たとえば、複数の出力チャ
     ネルに対して、ページ先頭フォーマットを設定しなければならないので
     あれば、

          select(REPORT1);
          $^ = 'report1_top';
          select(REPORT2);
          $^ = 'report2_top';

     のようにしなければならないでしょう。

     FILEHANDLE は、実際のファイルハンドルの名前を示す、式でもかまいま
     せん。つまり、

          $oldfh = select(STDERR); $| = 1; select($oldfh);

     のようなものです。

     Perl 5 では、ファイルハンドルはメソッドを持ったオブジェクトですか
     ら、最後の例は

          use FileHandle;
          STDERR->autoflush(1);

     のように書くと良いでしょう。


 -- Function: select RBITS,WBITS,EBITS,TIMEOUT
     これは、select(2) システムコールを、指定したビットマスクで呼び出
     します。ビットマスクは、`fileno()' と `vec()' を使って、

          $rin = $win = $ein = ";
          vec($rin,fileno(STDIN),1) = 1;
          vec($win,fileno(STDOUT),1) = 1;
          $ein = $rin | $win;

     のようにして作成することができます。

     複数のファイルハンドルに `select' を行ないたいのであれば、

          sub fhbits {
              local(@fhlist) = split(' ',$_[0]);
              local($bits);
              for (@fhlist) {
                  vec($bits,fileno($_),1) = 1;
              }
              $bits;
          }
          $rin = &fhbits('STDIN TTY SOCK');

     のようなサブルーティンを書くとよいでしょう。

     通常は、

          ($nfound,$timeleft) =
            select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

     のように使い、いずれかの準備が整うまでブロックするには、

          $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);

     のようにします。どのビットマスクにも `undef' を設定することができ
     ます。TIMEOUT を指定するときは、秒数で指定し、少数でかまいません。
     注: すべてのインプリメンテーションで、$timeleft が返せるものでは
     ありません。その場合、$timeleft には、常に指定した TIMEOUT と同じ
     値が返されます。

     250 ミリ秒の `sleep' と同じ効果が、

          select(undef, undef, undef, 0.25);

     のようにして得られます。(マイクロ秒じゃないよ :-))


 -- Function: sprintf FORMAT,LIST
     普通の C 言語の printf 記法のフォーマットで、整形された文字列を返
     します。(長さの間接指定のための * 文字はサポートされていませんが、
     変数をパターン内で展開すれば、同じ結果となります。)


 -- Function: sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
 -- Function: sysread FILEHANDLE,SCALAR,LENGTH
     システムコール read(2) を用いて、指定した FILEHANDLE から、変数 
     SCALAR へ、LENGTH バイトのデータの読み込みを試みます。これは、
     stdio ルーティンを通りませんから、他の入力関数と混ぜて使うと、入
     力がおかしくなるかもしれません。実際に読み込まれたデータの長さか、
     エラー時には `undef' が返されます。SCALAR は、実際に読み込んだ長
     さに応じて、伸び縮みします。OFFSET を指定すると、SCALAR の先頭以
     外の場所から、読み込みを行ないうことができます。


 -- Function: syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
 -- Function: syswrite FILEHANDLE,SCALAR,LENGTH
     write(2) システムコールを使って、指定した FILEHANDLE へ、変数 
     SCALAR から、LENGTH バイトのデータの書き込みを試みます。これは、
     stdio ルーティンを通りませんから、他の出力関数と混ぜて使うと、出
     力がおかしくなるかもしれません。実際に読み込まれたデータの長さか、
     エラー時には `undef' が返されます。OFFSET を指定すると、SCALAR の
     先頭以外の場所から、データを取り出して、書き込みを行ないうことが
     できます。


 -- Function: tell FILEHANDLE
 -- Function: tell
     FILEHANDLE の現在のファイル位置を返します。FILEHANDLE は、実際の
     ファイルハンドル名を示す式でもかまいません。FILEHANDLE が省略され
     た場合には、最後に読み込みを行なったファイルについて調べます。


 -- Function: write FILEHANDLE
 -- Function: write EXPR
 -- Function: write
     指定されたファイルに対して、そのファイルに対応させたフォーマット
     を使って、(複数行の場合もある) 整形されたレコードを書き出します。
     デフォルトでは、ファイルに対応するフォーマットは、ファイルハンド
     ルと同じ名前のものですが、その時点の出力チャネル (`select()' 関数
     の項を参照) のフォーマットは、その名前を明示的に、変数 $~ に代入
     することで、変更が可能です。

     ページの先頭の処理は、自動的に行なわれます。現在のページに整形さ
     れたレコードを出力するだけのスペースがない場合には、改ページを行
     なってページを進め、新しいページヘッダを整形するため、ページ先頭
     フォーマットが使われ、その後でレコードが書かれます。デフォルトで
     は、ページ先頭フォーマットは、ファイルハンドルの名前に "_TOP" を
     つなげたものですが、ファイルハンドルが選択されている間に、変数 $^ 
     に名前を設定すれば、動的にフォーマットを変更することができます。
     そのページの残り行数は、変数 $- に入っており、この変数を 0 に設定
     することで、強制的に改ページを行なうことができます。

     FILEHANDLE を指定しないと、出力はその時点のデフォルト出力チャネル
     に対して行なわれます。これは、スクリプトの開始時点では STDOUT で
     すが、`select()' 演算子で変更することができます。FILEHANDLE が 
     EXPR ならば、式が評価され、その結果の文字列が実行時に FILEHANDLE 
     の名前として見られます。フォーマットについて、さらには、*Note フォー
     マット文::,を参照してください。

     残念ながら、`write' は `read' の反対のことをするものではありませ
     ん。







File: perl-ja.info, Node: ディレクトリ読み出し関数, Next: システム操作関数, Prev: 入出力関数, Up: 組み込み関数

ディレクトリ読み出し関数
========================


 -- Function: closedir DIRHANDLE
     `opendir()' でオープンしたディレクトリをクローズします。


 -- Function: opendir DIRHANDLE,EXPR
     `readdir()', `telldir()', `seekdir()', `rewinddir()',
     `closedir()' で処理するために、EXPR で指定された名前のディレクト
     リをオープンします。成功時には真を返します。DIRHANDLE は、
     FILEHANDLE とは別に名前空間を持っています。


 -- Function: readdir DIRHANDLE
     `opendir()' でオープンしたディレクトリで、次のディレクトリエント
     リを返します。リストコンテキストで用いると、そのディレクトリの残
     りのエントリを、すべて返します。エントリが残っていない場合には、
     スカラコンテキストでは未定義値を、リストコンテキストでは空リスト
     を返します。


 -- Function: rewinddir DIRHANDLE
     DIRHANDLE に対する `readdir()' ルーティンの現在位置をディレクトリ
     の最初に設定します。


 -- Function: seekdir DIRHANDLE,POS
     DIRHANDLE での `readdir()' ルーティンの現在位置を設定します。POS 
     は、`telldir()' が返す値でなければなりません。同名のシステムライ
     ブラリルーティンと同じく、ディレクトリ縮小時の問題が考えられます。


 -- Function: telldir DIRHANDLE
     DIRHANDLE 上の `readdir()' ルーティンに対する現在位置を返します。
     値は、そのディレクトリで特定の位置をアクセスするため、`seekdir()' 
     に渡すことができます。同名のシステムライブラリルーティンと同じく、
     ディレクトリ縮小時の問題が考えられます。







File: perl-ja.info, Node: システム操作関数, Next: ネットワーク操作関数, Prev: ディレクトリ読み出し関数, Up: 組み込み関数

システム操作関数
================


 -- Function: alarm SECONDS
     指定した秒数が経過した後に、自プロセスに SIGALRM が送られてくるよ
     うにします。(マシンによっては、秒の数え方が異なるため、指定した秒
     数よりも最大で 1 秒少ない経過時間となります。)一度には 1 つのタイ
     マだけが設定可能です。呼び出しを行なう度に、以前のタイマを無効に
     しますし、新しくタイマを起動しないで以前のタイマをキャンセルする
     ために引数に 0 を指定して呼び出すことができます。以前のタイマの残
     り時間が、返却値となります。

     1 秒より精度の高いスリープを行なうには、setitimer(2) をサポートし
     ているシステムでは、Perl の syscall() インタフェースを使ってアク
     セスすることができますし、サポートしていなければ、このドキュメン
     トのどこかにある select() の項を参照してください。


 -- Function: chdir EXPR
     (可能であれば、) カレントディレクトリを EXPR に移します。EXPR を
     指定しないと、ホームディレクトリに移ります。成功時には真を返し、
     そうでなければ偽を返します。`die()' の項の例を参照してください。


 -- Function: chroot FILENAME
     同じ名前のシステムコールと同じことをします。それが何をするものか
     を、知らなくても気にしないでください。FILENAME を省略すると、$_ 
     へ `chroot' します。


 -- Function: die LIST
     `eval()' の外では、LIST の値を STDERR に出力し、その時点の $!
     (errno) の値で exit します。$! の値が 0 ならば、($? >> 8)
     (`command` のステータス) の値で exitします。($? >> 8) も 0 であれ
     ば、255 で exit することになります。`eval()' の中で使用すると、エ
     ラーメッセージが、$@ に入れられます。`eval()' は中断され、未定義
     値を返します。

     同値な例:
          die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
          chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

     $var{list} の評価結果が改行で終わっていなければ、その時点のスクリ
     プト名とスクリプトの行番号、(もしあれば) 入力ファイルの行番号と改
     行文字が、続けて表示されます。ヒント: メッセージの最後を ",
     stopped" のようなもので終わるようにしておけば、"at foo line 123" 
     のように追加されて、わかりやすくなります。"canasta" というスクリ
     プトを実行しているとすると、

          die "/etc/games is no good";
          die "/etc/games is no good, stopped";

     は、それぞれ

          /etc/games is no good at canasta line 123.
          /etc/games is no good, stopped at canasta line 123.

     と表示することになります。`exit()' と `warn()' も参照してください。


 -- Function: exec LIST
     `exec()' 関数は、システムのコマンドを実行し、戻ってはきません。戻っ
     て欲しい場合には、`system()' 関数を使ってください。

     LIST に複数の引数がある場合か、LIST が複数の値を持つ配列の場合に
     は、LIST の引数を使って、execvp(3) を呼び出します。1 つのスカラ引
     数のみの場合には、その引数からシェルのメタ文字をチェックします。
     もし、メタ文字があれば、引数全体を `/bin/sh -c' に渡して解析させ
     ます。もし、なければ、その引数を単語に分け、より効率的な execvp() 
     に直接、渡します。注: `exec()' (と `system()')は出力バッファをフ
     ラッシュしませんので、出力をなくしたくなければ、$| を設定する必要
     があるかもしれません。例:

          exec '/bin/echo', 'Your arguments are: ', @ARGV;
          exec "sort $outfile | uniq";

     第一引数に指定するものを本当に実行したいが、実行するプログラムに
     対して別の名前を教えたい場合には、LIST の前に、「間接オブジェクト」
     (コンマなし) として、実際に実行したいプログラムを指定することがで
     きます。(これによって、LIST に単一のスカラしかなくても、複数値の
     リストであるように、LIST の解釈を行ないます。)例:

          $shell = '/bin/csh';
          exec $shell '-sh';          # login シェルの振りをする

     あるいは、より直接的に、

          exec {'/bin/csh'} '-sh';    # login シェルの振りをする


 -- Function: exit EXPR
     EXPR を評価し、即座にその値を持って終了します。(実際には、まず、
     定義されている END ルーティンを呼び出しますが、END ルーティンは 
     exit を止められません。同様に、呼び出す必要のあるオブジェクトデス
     トラクタはすべて、exit の前に呼び出されます。) 例:

          $ans = <STDIN>;
          exit 0 if $ans =~ /^[Xx]/;

     `die()' も参照してください。EXPR が省略された場合には、ステータス
     を 0 として終了します。


 -- Function: fork
     システムコール fork(2) を行ないます。親プロセスには、チャイルドプ
     ロセスの pid を、チャイルドプロセスに 0 を返しますが、fork に失敗
     したときには、未定義値を返します。注: フラッシュされていないバッ
     ファは、どちらのプロセスに対しても、フラッシュされていないままと
     なっています。これは、出力がダブルのを避けるためには、$| (English 
     では $AUTOFLUSH) を設定するか、ファイルハンドルメソッド 
     autoflush() を呼ぶ必要があるかもしれないということです。

     チャイルドプロセスの終了を待たずに、fork() を繰り返せば、ゾンビを
     ため込むことになります:

          $SIG{'CHLD'} = sub { wait };

     ダブル `fork' という仕掛けも使えます (`fork' の返却値のエラーチェッ
     クは省いています);

          unless ($pid = fork) {
              unless (fork) {
                  exec "what you really wanna do";
                  die "no exec";
                  # ... または ...
                  some_perl_code_here;
                  exit 0;
              }
              exit 0;
          }
          waitpid($pid,0);


 -- Function: getlogin
     もしあれば、/etc/utmp から現在のログイン名を返します。ヌルであれ
     ば、`getpwuid()' を使ってください。

          $login = getlogin || (getpwuid($<))[0] || "Kilroy";


 -- Function: getpgrp PID
 -- Function: getpgrp
     指定された PID の現在のプロセスグループを返します。PID に 0 を与
     えるとカレントプロセスの指定となります。getpgrp(2) をインプリメン
     トしていないマシンで実行した場合には、致命的エラーとなります。PID 
     を省略するとカレントプロセスのプロセスグループを返します。


 -- Function: getppid
     親プロセスのプロセス id を返します。


 -- Function: getpriority WHICH,WHO
     プロセス、プロセスグループ、ユーザに対する現在の優先度を返します。
     (getpriority(2) manpage を参照してください。)getpriority(2) をイ
     ンプリメントしていないマシンで実行した場合には、致命的エラーとな
     ります。


 -- Function: getpwnam NAME
 -- Function: getgrnam NAME
 -- Function: gethostbyname NAME
 -- Function: getnetbyname NAME
 -- Function: getprotobyname NAME
 -- Function: getpwuid UID
 -- Function: getgrgid GID
 -- Function: getservbyname NAME,PROTO
 -- Function: gethostbyaddr ADDR,ADDRTYPE
 -- Function: getnetbyaddr ADDR,ADDRTYPE
 -- Function: getprotobynumber NUMBER
 -- Function: getservbyport PORT,PROTO
 -- Function: getpwent
 -- Function: getgrent
 -- Function: gethostent
 -- Function: getnetent
 -- Function: getprotoent
 -- Function: getservent
 -- Function: setpwent
 -- Function: setgrent
 -- Function: sethostent STAYOPEN
 -- Function: setnetent STAYOPEN
 -- Function: setprotoent STAYOPEN
 -- Function: setservent STAYOPEN
 -- Function: endpwent
 -- Function: endgrent
 -- Function: endhostent
 -- Function: endnetent
 -- Function: endprotoent
 -- Function: endservent
     これらのルーティンは、システムライブラリの同名の関数を実行します。
     リストコンテキストでは、さまざまな get ルーティンからの返却値は、
     次のようになります:

          ($name,$passwd,$uid,$gid,
             $quota,$comment,$gcos,$dir,$shell) = getpw*
          ($name,$passwd,$gid,$members) = getgr*
          ($name,$aliases,$addrtype,$length,@addrs) = gethost*
          ($name,$aliases,$addrtype,$net) = getnet*
          ($name,$aliases,$proto) = getproto*
          ($name,$aliases,$port,$proto) = getserv*

     (エントリが存在しなければ、空リストが返されます。)

     スカラコンテキストでは、*nam、*byname といった NAME で検索するも
     の以外は、name を返し、NAME で検索するものは、何か別のものを返し
     ます。(エントリが存在しなければ、未定義値が返ります。)たとえば:

          $uid = getpwnam
          $name = getpwuid
          $name = getpwent
          $gid = getgrnam
          $name = getgrgid
          $name = getgrent
          etc.

     getgr*() によって返る値 $members は、グループのメンバのログイン名
     をスペースで区切ったものです。

     gethost*() 関数では、C で h_errno 変数がサポートされていれば、関数呼出が
     失敗したときに、$? を通して、その値が返されます。成功時に返される 
     @addrs 値は、対応するシステムコールが返す、生のアドレスのリストです。イ
     ンターネットドメインでは、個々のアドレスは、4 バイト長で、

          ($a,$b,$c,$d) = unpack('C4',$addr[0]);

     のようにして、`unpack' することができます。


 -- Function: glob EXPR
     EXPR の値を、シェルが行なうように、ファイル名の展開を行なって返し
     ます。これは、<*.*> 演算子をインプリメントする内部関数です。


 -- Function: kill LIST
     プロセスのリストにシグナルを送ります。LIST の最初の要素は、送信す
     るシグナルでなくてはなりません。シグナル送信に成功したプロセスの
     数を返します。

          $cnt = kill 1, $child1, $child2;
          kill 9, @goners;

     シェルとは異なり、Perl では、シグナルに負の数を与えると、プロセス
     ではなく、プロセスグループに対して、kill を行ないます。(Syetem V 
     では、プロセス番号として負の値を与えても、プロセスグループの kill 
     を行ないますが、移植性がありません。)すなわち、通常は、負のシグナ
     ルは用いず、正のシグナルを使うことになります。シグナル名をクォー
     トして使うこともできます。


 -- Function: setpgrp PID,PGRP
     指定した PID (0 を指定するとカレントプロセス) に対するプロセスグ
     ループを設定します。setpgrp(2) がインプリメントされていないマシン
     では、致命的エラーが発生します。


 -- Function: setpriority WHICH,WHO,PRIORITY
     プロセス、プロセスグループ、ユーザに対する優先順位を設定します。
     (setpriority(2) を参照してください。) setpriority(2) がインプリメ
     ントされていないマシンでは、致命的エラーが発生します。


 -- Function: sleep EXPR
 -- Function: sleep
     スクリプトを EXPR で指定した秒数 (省略時には、永久に)スリープさせ
     ます。そのプロセスには、`SIGALRM' を送ることで、割り込みを掛ける
     ことができます。実際にスリープした秒数を返します。`sleep()' は、
     `alarm()' を使ってインプリメントされることが多いので、`alarm()' 
     と `sleep()' は、おそらく混ぜて使用することはできません。

     古いシステムでは、どのように秒を数えるかによって、要求した秒数に
     完全に満たないうちに、スリープから抜ける場合があります。最近のシ
     ステムでは、常に完全にスリープします。


 -- Function: syscall LIST
     LIST の最初の要素で指定するシステムコールを、残りの要素をそのシス
     テムコールの引数として呼び出します。インプリメントされていないと
     きには、致命的エラーとなります。引数は、以下のように解釈されます: 
     引数が数字であれば、int として引数を渡します。そうでなければ、文
     字列値へのポインタが渡されます。文字列に結果を受け取るときには、
     その結果を受け取るのに十分なくらいに、文字列を予め伸ばしておく必
     要があります。整数引数が、リテラルでなく、数値コンテキストで評価
     されたことのないものであれば、数値として解釈されるように、0 を足
     しておく必要があるかもしれません。

          require 'syscall.ph'; # h2ph を実行する必要があるかも
          syscall(&SYS_write, fileno(STDOUT), "hi there\n", 9);

     Perl は、システムコールに最大 14 個の引数しか渡せませんが、実用上
     問題はないでしょう。


 -- Function: system LIST
     `exec LIST' とほとんど同じですが、まず `fork' を行ない、親プロセ
     スではチャイルドプロセスが終了するのを `wait' します。`exec' の項
     で述べたように、引数の処理は、引数の数によって異なることに注意し
     てください。返却値は、`wait()' が返すプログラムの exit 状態です。
     実際の exit 値を得るには 256 で割ってください。このドキュメントの 
     `exec' の項も参照してください。


 -- Function: times
     現プロセスと、そのチャイルドプロセスに対する、ユーザ時間とシステ
     ム時間を秒で示した、4 要素のリスト値を返します。

          ($user,$system,$cuser,$csystem) = times;


 -- Function: umask EXPR
 -- Function: umask
     現在のプロセスの umask を設定し、以前の値を返します。EXPR が省略
     されると、単にその時点の umask の値を返します。


 -- Function: wait
     チャイルドプロセスが終了するのを待ち、消滅したプロセスの pid を返
     します。チャイルドプロセスが存在しないときには、-1 を返します。ス
     テータスは $?  に返されます。


 -- Function: waitpid PID,FLAGS
     特定のチャイルドプロセスが終了するのを待ち、消滅したプロセスの 
     pid を返します。指定したチャイルドプロセスが存在しないときには、-
     1 を返します。ステータスは $? に返されます。

          use POSIX "wait_h";
          ...
          waitpid(-1,&WNOHANG);

     とすると、ブロックが起こらないようにして、任意のプロセスを `wait' 
     します。ブロックなしの `wait' は、システムコール waitpid(2) か、
     システムコール wait4(2) をサポートしているマシンでのみ利用可能で
     す。しかしながら、特定の pid を 0 の FLAGS での `wait' はどこでも
     インプリメントされています。(exit したプロセスのステータス値を覚
     えておいて、Perl がシステムコールをエミュレートしますが、Perl ス
     クリプトには取り入れられていません。)


 -- Function: warn LIST
     `die()' と同じように STDERR にメッセージを出力しますが、exit した
     り、例外を発生させたりしません。







File: perl-ja.info, Node: ネットワーク操作関数, Next: SystemV IPC 関数, Prev: システム操作関数, Up: 組み込み関数

ネットワーク操作関数
====================


 -- Function: accept NEWSOCKET,GENERICSOCKET
     accept(2) システムコールと同様に、着信するソケットの接続を受け付
     けます。成功時にはパックされたアドレスを返し、失敗すれば偽を返し
     ます。*Note プロセス間通信::,の例を参照してください。


 -- Function: bind SOCKET,NAME
     bind(2) システムコールと同様に、ネットワークアドレスをソケットに
     結び付けます。成功時には真を返し、失敗時には偽を返します。NAME は、
     ソケットに対する、適切な型のパックされたアドレスでなければなりま
     せん。*Note プロセス間通信::,の例を参照してください。


 -- Function: connect SOCKET,NAME
     connect(2) システムコールと同様に、リモートソケットへの接続を試み
     ます。成功時には真を返し、失敗時には偽を返します。NAME は、ソケッ
     トに対する、適切な型のパックされたアドレスでなければなりません。
     *Note プロセス間通信::,の例を参照してください。


 -- Function: getpeername SOCKET
     SOCKET コネクションの向こう側のパックされた aockaddr アドレスを返
     します。

          # インターネットの sockaddr
          $sockaddr = 'S n a4 x8';
          $hersockaddr = getpeername(S);
          ($family, $port, $heraddr) = unpack($sockaddr,$hersockaddr);


 -- Function: getsockname SOCKET
     SOCKET コネクションのこちら側のパックされた aockaddr アドレスを返
     します。

          # インターネット sockaddr
          $sockaddr = 'S n a4 x8';
          $mysockaddr = getsockname(S);
          ($family, $port, $myaddr) = unpack($sockaddr,$mysockaddr);


 -- Function: getsockopt SOCKET,LEVEL,OPTNAME
     要求されたソケットオプションを返します。エラーの場合には、未定義
     値を返します。


 -- Function: listen SOCKET,QUEUESIZE
     listen(2) システムコールと同じことをします。成功時には真を返し、
     失敗時には偽を返します。*Note プロセス間通信::,の例を参照してくだ
     さい。


 -- Function: recv SOCKET,SCALAR,LEN,FLAGS
     ソケット上のメッセージを受信します。指定されたファイルハンドル 
     SOCKET から、変数 SCALAR に LENGTH バイトのデータを読み込もうとし
     ます。実際には、C の recvfrom() を呼びますので、送信側のアドレス
     を返すことができます。エラー発生時には、未定義値を返します。
     SCALAR は、実際に読まれた長さによって、大きくなったり、小さくなっ
     たりします。同名のシステムコールと同じ FLAGS を使います。


 -- Function: send SOCKET,MSG,FLAGS,TO
 -- Function: send SOCKET,MSG,FLAGS
     SOCKET に MSG を送ります。FLAGS には、同名のシステムコールと同じ
     フラグを指定します。接続していないソケットには、送信先 TO を指定
     しなければならず、この場合、C の sendto() を実行します。送信した
     文字数か、エラー時には、未定義値を返します。


 -- Function: setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
     要求したソケットオプションを設定します。エラー時には、未定義値が
     返されます。引数を渡したくない場合には、OPTVAL に `undef' を指定
     します。


 -- Function: shutdown SOCKET,HOW
     同名のシステムコールと同じように解釈される HOW によって、指定され
     た方法でソケット接続のシャットダウンを行ないます。


 -- Function: socket SOCKET,DOMAIN,TYPE,PROTOCOL
     指定した種類のソケットをオープンし、ファイルハンドルSOCKET にアタッ
     チします。DOMAIN、TYPE、PROTOCOL は、同名のシステムコールと同じよ
     うに指定します。適切な定義を `import' するために、まず、`use
     Socket;' とするとよいでしょう。*Note プロセス間通信::,の例を参照
     してください。


 -- Function: socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
     指定した DOMAIN に、指定した TYPE で名前の無いソケットのペアを生
     成します。DOMAIN、TYPE、PROTOCOL は、同名のシステムコールと同じよ
     うに指定します。インプリメントされていない場合には、致命的エラー
     となります。成功時には真を返します。







File: perl-ja.info, Node: SystemV IPC 関数, Next: その他の関数, Prev: ネットワーク操作関数, Up: 組み込み関数

SystemV IPC 関数
================


 -- Function: msgctl ID,CMD,ARG
     System V IPC 関数 msgctl を呼び出します。CMD が`&IPC_STAT' であれ
     ば、ARG は返される msqid_ds 構造体を納める変数でなければなりませ
     ん。`ioctl' と同じように、エラー時には未定義値、ゼロのときは "0
     but true"、それ以外なら、その値そのものを返します。


 -- Function: msgget KEY,FLAGS
     System V IPC 関数 msgget を呼び出します。メッセージキューの ID か、
     エラー時には未定義値を返します。


 -- Function: msgrcv ID,VAR,SIZE,TYPE,FLAGS
     System V IPC 関数 msgrcv を呼び出し、メッセージキュー ID から、変
     数 VAR に最大メッセージ長 SIZE のメッセージを受信します。メッセー
     ジが受信されたならば、VAR の先頭がメッセージタイプとなり、VAR の
     最大長は、SIZE にこのメッセージタイプの長さを加えたものになります。
     成功時には真を返し、エラー時には偽を返します。


 -- Function: msgsnd ID,MSG,FLAGS
     System V IPC 関数 msgsnd を呼び出し、メッセージキュー ID にメッセー
     ジ MSG を送信します。MSG の先頭は、long 整数のメッセージタイプで
     なければならず、これは、`pack("L", $type)' として生成できます。成
     功時には真を、エラー時には偽を返します。


 -- Function: semctl ID,SEMNUM,CMD,ARG
     System V IPC 関数 semctl を呼び出します。CMD が、`&IPC_STAT' か 
     `&GETALL' のときには、ARG は、返されるsemid_ds 構造体か、セマフォ
     値の配列を納める変数でなければなりません。`ioctl' と同じように、
     エラー時には未定義値、ゼロのときは "0 but true"、それ以外なら、そ
     の値そのものを返します。


 -- Function: semget KEY,NSEMS,FLAGS
     System V IPC 関数 semget を呼び出します。セマフォ ID か、エラー時
     には未定義値を返します。


 -- Function: semop KEY,OPSTRING
     シグナルを送信や、待ち合わせなどのセマフォ操作を行なうために、
     System V IPC 関数 semop を呼び出します。OPSTRING は、semop 構造体
     の `pack' された配列でなければなりません。semop 構造体は、それぞ
     れ、`pack("sss", $semnum, $semop, $semflag)' のように作ることがで
     きます。セマフォ操作の数は、OPSTRING の長さからわかります。成功時
     には真を、エラー時には偽を返します。例として、

          $semop = pack("sss", $semnum, -1, 0);
          die "Semaphore trouble: $!\n" unless semop($semid, $semop);

     は、セマフォ ID $semid のセマフォ $semnum で待ち合わせを行ないま
     す。セマフォにシグナルを送るには、"-1"を "1" に変更してください。


 -- Function: shmctl ID,CMD,ARG
     System V IPC 関数 shmctl を呼び出します。CMD が、`&IPC_STAT' なら
     ば、ARG は、返される shmid 構造体を納める変数でなければなりません。
     ioctl と同じように、エラー時には未定義値、ゼロのときは "0 but
     true"、それ以外なら、その値そのものを返します。


 -- Function: shmget KEY,SIZE,FLAGS
     System V IPC 関数 shmget を呼び出します。共有メモリのセグメント 
     ID か、エラー時には未定義値を返します。


 -- Function: shmread ID,VAR,POS,SIZE
 -- Function: shmwrite ID,STRING,POS,SIZE
     System V 共有メモリセグメント ID に対し、アタッチして、コピーを行
     ない、デタッチするという形で、位置 POS から、サイズ SIZE だけ、読
     み込みか書き込みを行ないます。読み込み時には、VAR は読み込んだデー
     タを納める変数でなければなりません。書き込み時には、STRING が長す
     ぎても、SIZE バイトだけが使われます。STRING が短すぎる場合には、
     SIZE バイトを埋めるために、ヌル文字が書き込まれます。成功時には真
     を、エラー時には偽を返します。







File: perl-ja.info, Node: その他の関数, Prev: SystemV IPC 関数, Up: 組み込み関数

その他の関数
============


 -- Function: defined EXPR
     左辺値 EXPR が実際に値を持つか否かを示す、ブール値を返します。多
     くの演算子が、EOF や未初期化変数、システムエラーといった、例外的
     な条件で未定義値を返すようになっています。この関数は、配列の要素
     の参照のように、実際にヌル文字列を返す演算について、未定義のヌル
     スカラと、定義済みのヌルスカラを区別するときに使います。配列やサ
     ブルーティンの存在を、確かめることもできます。あらかじめ定義され
     た予約変数に対して用いても、直感的に想像できるような値を返すこと
     は保証されていません。

     ハッシュの要素に対して用いると、value が定義されているか否かを返
     すものであって、ハッシュに key が存在するか否かを返すのではありま
     せん。これには、`exits()'を使ってください。

     例:

          print if defined $switch{'D'};
          print "$val\n" while defined($val = pop(@ary));
          die "Can't readlink $sym: $!"
              unless defined($value = readlink $sym);
          eval '@foo = ()' if defined(@foo);
          die "No XYZ package defined" unless defined %_XYZ;
          sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }

     `undef()' も参照してください。


 -- Function: dump LABEL
     即座にコアダンプを行ないます。プログラムの先頭で、すべての変数を
     初期化したあとのコアダンプを `undump' プログラムを使って実行ファ
     イルに返ることができます。この新しいバイナリが実行されると、`goto
     LABEL' から始めます (`goto' に関する制限はすべて適用されます)。コ
     アダンプをはさんで再生する `goto' と考えてください。$var{label} 
     が省略されると、プログラムを先頭から再開します。警告: `dump' 時点
     でオープンされていたファイルは、プログラムが再生されたときには、
     もはやオープンされていません。Perl を部分的に混乱させる可能性があ
     ります。$xref{実行とオプション}の `-u' オプションも参照してくださ
     い。

     例:
          #!/usr/bin/perl
          require 'getopt.pl';
          require 'stat.pl';
          %days = (
              'Sun' => 1,
              'Mon' => 2,
              'Tue' => 3,
              'Wed' => 4,
              'Thu' => 5,
              'Fri' => 6,
              'Sat' => 7,
          );
          dump QUICKSTART if $ARGV[0] eq '-d';
          QUICKSTART:
          Getopt('f');


 -- Function: local EXPR
     一般には、`local' よりも `my' を使うべきでしょう。速く、安全だか
     らです。しかし、`format' 文の変数には、`local' やローカルな値が呼
     び出されたサブルーティンから見えるような変数を使わなければなりま
     せん。これは、動的スコープと呼ばれます。文面上の静的なスコープは、
     `my' を使って得られ、C の AUTO 宣言と同じように働きます。

     `local' はリストアップされた変数を、囲っているブロックやサブルー
     ティン、`eval' や `do' の中で、ローカルなものにします。複数の値を
     並べる場合には、括弧で括る必要があります。並べる要素は、左辺値と
     して使用できるものでなければなりません。この演算子は LIST 中の、
     それらの変数の現在の値を隠れたスタックに保存し、ブロックやサブルー
     ティンや eval から抜けるときに、それらの値を戻します。これによっ
     て、呼ばれたサブルーティンはグローバルな変数ではなく、ローカルな
     変数を参照することができます。EXPR に代入を行なうことも可能で、ロー
     カルな変数の初期化として使うことができます。(初期化子を与えなかっ
     た変数の値は、未定義値となります。) これはよく、サブルーティンの
     引数に名前を付けるのに使われます。例:

          sub RANGEVAL {
              local($min, $max, $thunk) = @_;
              local $result = ";
              local $i;

              # $thunk が $i へのリファレンスを作るとでしょう

              for ($i = $min; $i < $max; $i++) {
                  $result .= eval $thunk;
              }

              $result;
          }

          if ($sw eq '-v') {
              # ローカル配列をグローバル配列で初期化
              local @ARGV = @ARGV;
              unshift(@ARGV,'echo');
              system @ARGV;
          }
          # @ARGV が戻される

          # 一時的に連想配列 digits に加算
          if ($base12) {
              # (NOTE: これにこだわらない方が効率的 !)
              local(%digits) = (%digits,'t',10,'e',11);
              parse_num();
          }

     `local()' は実行時のコマンドですから、ループを通るごとに実行され
     ることに注意してください。Perl 4 では、ループを抜けるまで、それぞ
     れスタックメモリを使いました。Perl 5 はそれぞれスペースを取り戻し
     ますが、変数をループの外で宣言した方が効率的なのは、変わりありま
     せん。

     EXPR に代入を行なうとき、local は EXPR がスカラとして参照されるか、
     配列として参照されるかには、影響しません。つまり、

          local($foo) = <STDIN>;
          local @FOO = <STDIN>;

     は、どちらも右辺にリストコンテキストをもたらしますが、

          local $foo = <STDIN>;

     では、スカラコンテキストになります。


 -- Function: my EXPR
     `my' はリストアップされた変数を、囲っているブロックやサブルーティ
     ン、`eval' や `do' の中で (文面上の意味で)ローカルなものにします。
     複数の値を並べる場合には、括弧で括る必要があります。並べる要素は、
     左辺値として使用できるものでなければなりません。英数字の識別子だ
     けが、文面上の字句スコープに入れることができます。$/ のような、マ
     ジカルな組み込み変数をローカル化するには、`local' を使う必要があ
     ります。特に、

          my $_;      # 不正

     とはできません。

     `local' の宣言とは違って、`my' で宣言した変数は、呼び出したサブルー
     ティンを含む、外界からは完全に見えないものになります (たとえ、そ
     れが同一のサブルーティンであってもです。呼出ごとに新しいものにな
     ります)。

     (しかし、`eval()' を使えば、その `eval()' 自身の中で宣言によって、
     名前が見えないようになっているのでない限り、評価が行なわれる字句
     スコープの変数を見ることができます。)*Note リファレンスとデータ構
     造のネスト::,を参照してください。

     EXPR に代入を行なうことも可能で、変数の初期化に使うことができます。
     (初期化子を与えなかった変数の値は、未定義値となります。)これはよ
     く、サブルーティンの引数に名前を付けるのに使われます。例:

          sub RANGEVAL {
              my($min, $max, $thunk) = @_;
              my $result = ";
              my $i;

              # $thunk が $i へのリファレンスを作るとでしょう

              for ($i = $min; $i < $max; $i++) {
                  $result .= eval $thunk;
              }

              $result;
          }

          if ($sw eq '-v') {
              # my 配列をグローバル配列で初期化
              my @ARGV = @ARGV;
              unshift(@ARGV,'echo');
              system @ARGV;
          }
          # 外部の @ARGV が再び見えるようになる

     EXPR に代入を行なうとき、`my' は EXPR がスカラとして参照されるか、
     配列として参照されるかには、影響しません。つまり、

          my($foo) = <STDIN>;
          my @FOO = <STDIN>;

     は、どちらも右辺にリストコンテキストをもたらしますが、

          my $foo = <STDIN>;

     では、スカラコンテキストになります。

     なるべく、字句スコープの変数を使うようにすることもあるでしょう。
     暗黙のうちに、パッケージ変数を参照してしまうのを検出するために、

          use strict 'vars';

     とすれば、その場所から囲っているブロックの最後までは、字句変数か、
     パッケージ名で完全に修飾した変数でなければ、参照できないように制
     限できます。それ以外の変数参照は、コンパイルエラーとなります。内
     側のブロックで、`no strict 'vars'' として、これを打ち消すことがで
     きます。


 -- Function: ref EXPR
     EXPR がリファレンスであれば、真を返し、さもなくば、偽を返します。
     返される値は、リファレンスが参照するものの型に依存します。組み込
     みの型には、

        REF
        SCALAR
        ARRAY
        HASH
        CODE
        GLOB

     があります。参照されるオブジェクトが、何らかのパッケージに 
     `bless' されたものであれば、これらの代わりに、そのパッケージ名が
     返されます。`ref()' は、`typeof()' 演算子のように考えることができ
     ます。

          if (ref($r) eq "HASH") {
              print "r is a reference to an associative array.\n";
          }
          if (!ref ($r) {
              print "r is not a reference at all.\n";
          }

     *Note リファレンスとデータ構造のネスト::,も参照してください。


 -- Function: undef EXPR
 -- Function: undef
     左辺値である EXPR の値を未定義にします。スカラ値、配列全体、("&" 
     を使った) サブルーティン名だけに使用します。(特殊変数や DBM リス
     ト値に `undef()' しても、おそらく期待通りの結果にはなりませんから、
     しないでください。)常に未定義値を返します。EXPR は省略することが
     でき、その場合には、何も未定義にされませんが、未定義値は返されま
     すので、それを、たとえば、サブルーティンの返却値として使うことが
     できます。例:

          undef $foo;
          undef $bar{'blurfl'};
          undef @ary;
          undef %assoc;
          undef &mysub;
          return (wantarray ? () : undef) if $they_blew_it;


 -- Function: wantarray
     現在実行中のサブルーティンがのコンテキストが、リスト値を要求する
     ものであれば、「真」を返します。スカラを要求するコンテキストであ
     れば、「偽」を返します。

          return wantarray ? () : undef;




File: perl-ja.info, Node: 定義済み変数, Next: サブルーティン, Prev: 組み込み関数, Up: Top

定義済み変数
************

以下の名前は Perl では特別な意味を持ちます。記号的な名前の多くは記憶法
があるか、シェルでの類推が可能です。それでも長い名前を使用したい場合に
は

     use English;

とプログラムの最初に書いてください。これは、すべての短い名前の別名とし
て、カレントパッケージで長い名前を付けるものです。awk から持ってきた中
間的な名前を持っているものもあります。

もう一歩すすめて、現在選択されているファイルハンドルに依存する変数の場
合には、代わりに `FileHandle' オブジェクトに関するオブジェクトメソッド
を呼び出して設定することができます。 (以下の要約では HANDLE という語を
含んでいます。) まず最初に必ず、

     use FileHandle;

と書き、その後で

     method HANDLE EXPR

もしくは

     HANDLE->method(EXPR)

を使います。

それぞれのメソッドは、ファイルハンドル属性の昔の値を返します。メソッド
はそれぞれ EXPR をとることができ、指定した場合には、問題の 
`FileHandle' 属性の新しい値を指定することになります。指定しない場合に
は、多くのメソッドでは現在の値に対して何もしませんが、`autoflush()' で
は 1 を指定されたものとします。

これらの変数の中には "read-only" として扱われるものもあります。つまり、
そういった変数に対して、直接にしろ、リファレンスを介して間接にしろ、代
入を行なおうとした場合には、実行時に例外処理が起動されます。


 -- Variable: $ARG
 -- Variable: $_
     デフォルトの入力とパターン検索のスペース。以下の 2つは同値です:

          while (<>) {...}    # while の中でだけ同値 !
          while ($_ = <>) {...}

          /^Subject:/
          $_ =~ /^Subject:/

          tr/a-z/A-Z/
          $_ =~ tr/a-z/A-Z/

          chop
          chop($_)

     (記憶法: 下線はある操作を覚えるためのもの。)


 -- Variable: $<digit>
     最後のパターンマッチで対応する括弧のサブパターンにマッチした文字
     列が入っているが、既に抜けてしまったブロックでのパターンマッチは
     勘定に入れない。(記憶法: \digit のようなもの。)これらの変数はすべ
     て read-only です。


 -- Variable: $MATCH
 -- Variable: $&
     最後に成功したパターンマッチでマッチした文字列 (現在の BLOCK で囲
     まれた BLOCK や eval() で隠れている部分でのマッチは勘定に入れない)。
     (記憶法: あるエディタの & ようなもの。) この変数は read-only です。


 -- Variable: $PREMATCH
 -- Variable: $`
     最後の成功したパターンマッチ (現在のBLOCK で囲まれた BLOCK や 
     `eval()' に隠れている部分でのマッチは勘定に入れない) でマッチした
     部分の前の文字列。(記憶法: ` は多くの場合クォートされた文字列の前
     にある。) この変数は read-only です。


 -- Variable: $POSTMATCH
 -- Variable: $'
     最後の成功したパターンマッチ (現在のBLOCK で囲まれたBLOCK や 
     `eval()' に隠れている部分でのマッチは勘定に入れない) でマッチした
     部分に続く文字列。(記憶法: ' は多くの場合クォートされた文字列の後
     にある。) 例:
          $_ = 'abcdefghi';
          /def/;
          print "$`:$&:$'\n";         # abc:def:ghi と印字

     この変数は read-only です。


 -- Variable: $LAST_PAREN_MATCH
 -- Variable: $+
     最後に検索されたパターンの最後の括弧にマッチした文字列。これはい
     くつかの選択肢の中でどれがマッチするのかわからないような場合に使
     うと便利です。たとえば:

          /Version: (.*)|Revision: (.*)/ && ($rev = $+);

     (記憶法: ポジティブで前向き。) この変数は read-only です。


 -- Variable: $MULTILINE_MATCHING
 -- Variable: $*
     文字列中で複数行マッチを行なうために 1 に設定し、0 にすると、Perl 
     が文字列に 1 行しか無いと仮定して、ある種のパターンマッチに関する
     最適化を行なうようになります。複数の改行を含む文字列でのパターン
     マッチを "$*" が 0 のまま行なうと結果は信用のないものになります。
     デフォルトでは 0 になっています。(記憶法: * は複数のものにマッチ
     します。)この変数は "^" と "$" の解釈にのみ影響します。リテラルの
     改行文字は、$* が 0 であっても検索することが可能です。

     Perl 5 では "$*" を使わないようにしてください。


 -- Method: input_line_number HANDLE EXPR
 -- Variable: $INPUT_LINE_NUMBER
 -- Variable: $NR
 -- Variable: $.
     最後に読み込みを行なったファイルハンドルの現在の入力行番号。この
     変数は、read-only と考えるべきです。明示的にファイルハンドルをク
     ローズした場合にだけ、行番号がリセットされることに注意してくださ
     い。"<>" 構文では明示的にクローズを行ないませんから、ARGV のファ
     イルに跨って行番号が数えられることになります (が、`eof()' の例を
     参照してください)。(記憶法: 多くのプログラムで "." が現在行番号を
     示すように使われています。)


 -- Method: input_record_separator HANDLE EXPR
 -- Variable: $INPUT_RECORD_SEPARATOR
 -- Variable: $RS
 -- Variable: $/
     入力レコードセパレータで、デフォルトでは改行文字。空文字列に設定
     されると、空行を区切りとして扱うことを含めて、awk の変数 RS のよ
     うに働きます。複数文字の区切文字を示すために、文字列を設定するこ
     ともできます。この変数に "\n\n" を設定すると、空行が続く場合にお
     いて、"" を設定した場合とわずかに違う動作をするようになります。"" 
     を設定した場合には、複数の空行も 1 つの空行であるかのように扱いま
     す。"\n\n" を設定した場合には、単純に次の文字が (たとえ改行文字で
     あっても)次の段落に含まれるものとして扱います。(記憶法: / は、詩
     を引用するときに、行の区切りを示すのに使う文字です。)

          undef $/;
          $_ = <FH>;          # ファイル全体が読まれる
          s/\n[ \t]+/ /g;


 -- Method: autoflush HANDLE EXPR
 -- Variable: $OUTPUT_AUTOFLUSH
 -- Variable: $|
     0 以外に設定されると、その時点で選択されている出力チャネルに 
     write や print を行なうごとに、強制的にフラッシュします。デフォル
     トでは 0 となっています。STDOUT は通常では、端末への出力時には行
     バッファリング、それ以外ではブロックバッファリングであることに注
     意してください。これは、Perl のスクリプトを rsh 配下で実行して、
     実行状況を確認したい場合のように、パイプに出力するときに特に便利
     でしょう。(記憶法: パイプをホットな状態にしておくために使う。)


 -- Method: output_field_separator HANDLE EXPR
 -- Variable: $OUTPUT_FIELD_SEPARATOR
 -- Variable: $OFS
 -- Variable: $,
     print 演算子のための出力フィールドセパレータ。通常 `print' 演算子
     は、コンマで区切って指定したフィールドを単純に印字します。より、
     awk に近い動作をさせるには、フィールドの区切りとして印字されるも
     のとして awk の変数 OFS に設定するものを、この変数に設定します。
     (記憶法: print 文で , を書いた場所に印字されるもの。)


 -- Method: output_record_separator HANDLE EXPR
 -- Variable: $OUTPUT_RECORD_SEPARATOR
 -- Variable: $ORS
 -- Variable: $\
     `print' 演算子のための出力レコードセパレータ。通常`print' 演算子
     は、コンマで区切って指定したフィールドを単純に印字し、改行などレ
     コードセパレータと想定するものをつけません。より、awk に近い動作
     をさせるには、print の最後に印字されるものとして awk の変数 ORS 
     に設定するものを、この変数に設定します。(記憶法: print の最後に 
     \n を付け加える代わりに "$\" を設定する。また、/ に似通っているが、
     Perl から「バック」されるものです。)


 -- Variable: $LIST_SEPARATOR
 -- Variable: $"
     "$," と同様ですが、これは 2 重引用符で括られた文字列(または、同様
     に扱われる文字列) 内で配列値が展開される際に適用されます。デフォ
     ルトではスペースになっています。(記憶法: 明らかでしょう。)


 -- Variable: $SUBSCRIPT_SEPARATOR
 -- Variable: $SUBSEP
 -- Variable: $;
     多次元配列のエミュレートのための添え字の区切文字。ハッシュの要素
     を

          $foo{$a,$b,$c}

     のようにして参照すると、実際には

          $foo{join($;, $a, $b, $c)}

     という意味になります。しかし、

          @foo{$a,$b,$c}      # スライス -- @ に注意

     としてはいけません。これは、

          ($foo{$a},$foo{$b},$foo{$c})

     という意味になります。

     デフォルトは "\034" で、awk の SUBSEP と同じです。使おうとしてい
     る key の値がバイナリのデータを含むならば、"$;" に設定する安全な
     値などはないことになります。(記憶法: コンマ (構文上の添え字区切り
     文字) はセミ−セミコロンなのです。ええ、詭弁だとはわかってますが、
     "$," はもう既にもっと重要な任務を持ってるんです。)

     Perl 5 では「本物の」多次元配列を使うようにしてください。


 -- Variable: $OFMT
 -- Variable: $#
     数字を印字する際の出力フォーマット。この変数は、不十分ではありま
     すが、awk の変数 OFMT をエミュレートしようとするものです。しかし
     ながら、awk と Perl は異なる記法で数値を表わしています。また、初
     期値は %.6gではなく、%.20g となっていますので、awk での値を得るに
     は、明示的に "$#" を設定する必要があります。(記憶法: # は数値記号
     です。)

     Perl 5 では "$#" を使わないようにしてください。


 -- Method: format_page_number HANDLE EXPR
 -- Variable: $FORMAT_PAGE_NUMBER
 -- Variable: $%
     その時点で選択されている出力チャネルの、その時点でのページ番号。
     (記憶法: % は、nroff でのページ番号です。)


 -- Method: format_lines_per_page HANDLE EXPR
 -- Variable: $FORMAT_LINES_PER_PAGE
 -- Variable: $=
     その時点で選択されている出力チャネルの、その時点でのページ長 (印
     字可能行数)。デフォルトは 60 です。(記憶法: = には複数の水平線 
     (行) が含まれます。)


 -- Method: format_lines_left HANDLE EXPR
 -- Variable: $FORMAT_LINES_LEFT
 -- Variable: $-
     その時点で選択されている出力チャネルの、ページに残っている行数。
     (記憶法: "ページ行数" - "印字済み行数")


 -- Method: format_name HANDLE EXPR
 -- Variable: $FORMAT_NAME
 -- Variable: $~
     その時点で選択されている出力チャネルの、その時点でのフォーマット
     名。デフォルトでは、ファイルハンドルと同名。(記憶法: "$^" の兄弟。)


 -- Method: format_top_name HANDLE EXPR
 -- Variable: $FORMAT_TOP_NAME
 -- Variable: $^
     その時点で選択されている出力チャネルの、その時点でのページ先頭フォー
     マット名。デフォルトでは、ファイルハンドル名に _TOP を続けたもの。
     (記憶法: ページの先頭へのポインタ。)


 -- Method: format_line_break_characters HANDLE EXPR
 -- Variable: $FORMAT_LINE_BREAK_CHARACTERS
 -- Variable: $:
     フォーマットの充填継続フィールド (^ で始まるもの) への文字列で行
     分割を許す文字集合。デフォルトは " \n-"で空白か改行の後で行分割が
     可能となっています。(記憶法: 詩では「コロン」は、行の一部。)


 -- Method: format_formfeed HANDLE EXPR
 -- Variable: $FORMAT_FORMFEED
 -- Variable: $^L
     フォーマット出力で、改ページのために出力されるもの。デフォルトは 
     \f。


 -- Variable: $ACCUMULATOR
 -- Variable: $^A
     `format' 行のための、その時点での `write()' アキュムレータの値。
     format には、$^A に結果を残す、`formline()' コマンドが含まれます。
     自分のフォーマットを呼び出した後で、`write()' は $^A の内容を出力
     してから消去します。したがって、自分で `formline()' を呼び出すの
     でなければ、$^A の値が見えることはありません。*Note フォーマット
     文::,と*Note 組み込み関数::,の `formline()' の項を参照してくださ
     い。


 -- Variable: $CHILD_ERROR
 -- Variable: $?
     最後に `close' したパイプ、バッククォート (``) コマンド、
     `system()' 演算子が返したステータス。このステータスワードは 
     `wait()' システムコールが返したものですから、サブプロセスの exit 
     値は、実際には ($? >> 8) であることに注意してください。つまり多く
     のシステムで$? & 255 は、もしあれば、そのプロセスを止めたシグナル
     とコアダンプがあるかどうかを示します。(記憶法: sh や ksh と同様。)


 -- Variable: $OS_ERROR
 -- Variable: $ERRNO
 -- Variable: $!
     数値コンテキストで用いられると、その時点の errno の値が (通常の注
     意事項と供に) 得られます。(これは、システムエラーを示す特定のエラー
     が得られた場合でもなければ、"$!" の値が、特に何かを示すものである
     と、頼ってはならないということです。)文字列コンテキストで使われる
     と、対応するシステムエラーのメッセージ文字列が得られます。たとえ
     ば、"$!" にエラーの文字列を返して欲しいならば、errno を設定するた
     め、あるいは、die() 演算子の exit 値を設定するために、"$!" へ代入
     を行なうことが可能です。(記憶法: 何が bang(!) したか。)


 -- Variable: $EVAL_ERROR
 -- Variable: $@
     最後の eval() コマンドによる Perl の構文エラーメッセージです。空
     文字列であれば、最後の eval() が正常に解析され、実行されたことに
     なります (が、実行した演算子が、通常の意味で失敗しているかもしれ
     ません)。(記憶法: どこで ("at" where) 構文エラーが起ったか。)


 -- Variable: $PROCESS_ID
 -- Variable: $PID
 -- Variable: $$
     スクリプトを実行している Perl のプロセス番号です。(記憶法: シェル
     と同じ。)


 -- Variable: $REAL_USER_ID
 -- Variable: $UID
 -- Variable: $<
     本プロセスの実 uid を示します。(記憶法: setuid で実行中であれば、
     そこ「から」来た uid です。)


 -- Variable: $EFFECTIVE_USER_ID
 -- Variable: $EUID
 -- Variable: $>
     本プロセスの実効 uid を示します、例:

          $< = $>;            # 実 uid に実効 uid を設定
          ($<,$>) = ($>,$<);  # 実 uid と実効 uid を交換

     (記憶法: setuid で実行中であれば、そこ「へ」行く uidです。)"$<" 
     と "$>" の交換は、setreuid() をサポートしているマシンでのみ可能で
     す。


 -- Variable: $REAL_GROUP_ID
 -- Variable: $GID
 -- Variable: $(
     本プロセスの実 gid を示します。同時に複数のグループに所属できるマ
     シンでは、所属するグループをスペースで区切ったリストが得られます。
     最初の数値は、getgid() で返されるものです。その後に getgroups()が
     返す値が続き、その中の 1 つは、最初の値と同じかもしれません。(記
     憶法: 括弧は、グループ化に使われます。setgid で実行中であれば、実 
     gid は LEFT した、つまり離れたグループです。)


 -- Variable: $EFFECTIVE_GROUP_ID
 -- Variable: $EGID
 -- Variable: $)
     本プロセスの実効 gid を示します。同時に複数のグループに所属できる
     マシンでは、所属するグループをスペースで区切ったリストが得られま
     す。最初の数値は、`getegid()' で返されるものです。その後に 
     `getgroups()' が返す値が続き、その中の 1 つは、最初の値と同じかも
     しれません。(記憶法: 括弧は、グループ化に使われます。setgid で実
     行中であれば、実効 gid は RIGHT な、つまり正しいグループです。)

     注: "$<"、"$>"、"$("、"$)" は、実行するマシンで、対応する 
     `set[re][ug]id()' ルーティンがサポートされているときにのみ設定可
     能です。"$(" と "$)" の交換は、`setregid()' がサポートされている
     マシンでのみ可能です。


 -- Variable: $PROGRAM_NAME
 -- Variable: $0
     実行されている Perl スクリプトの、ファイル名を示します。"$0" に代
     入を行なうと、ps(1) プログラムが覗く、引数エリアを修正します。実
     行しているプログラムを隠すよりは、実行中のプログラムの状態を表示
     するときに、使うとよいでしょう。(記憶法: sh や ksh と同じ。)


 -- Variable: $[
     配列の最初の要素や、文字列の最初の文字のインデクスを示します。デ
     フォルトは 0 ですが、`index()' 関数や `substr()' 関数を評価すると
     きに、Perl の動作をより awk (や Fortran) に近づけるため、1 に設定
     することもできます。(記憶法: [ は添え字付けの始め。)

     Perl 5 では "$[" への代入は、コンパイラへのディレクティブとして扱
     われ、他のファイルの動作に影響を与えることがなくなりました。この
     変数は使わないようにしてください。


 -- Variable: $PERL_VERSION
 -- Variable: $]
     `perl -v' としたときに表示される文字列を示します。スクリプトの最
     初で、そのスクリプトを実行しているインタプリタのバージョンが適切
     な範囲内にあるかを調べる、といったことができます。数値コンテキス
     トで使われると、version + patchlevel / 1000 が返されます。例:

          # ファイル名補完の確認 (5.000 ではバグ)
          ($version,$patchlevel) = $] =~ /(\d+\.\d+).*\nPatch level: (\d+)/;
          print STDERR "(No filename completion available.)\n"
                if $version * 1000 + $patchlevel < 2016;

     あるいは、数値的に

          warn "No checksumming!\n" if $] < 3.019;

     (記憶法: Perl のバージョンは、正しい範囲 (right bracket) にあるか。)


 -- Variable: $DEBUGGING
 -- Variable: $^D
     デバッグフラグの現在の値を示します。(記憶法: `-D' スイッチの値。)


 -- Variable: $SYSTEM_FD_MAX
 -- Variable: $^F
     システムが使用するファイル記述子の最大値を示し、通常は 2 です。シ
     ステムファイル記述子は、`exec()' されたプロセスに渡されますが、そ
     れ以降のファイル記述子は渡されません。また、`open()' の実行中は、
     システムファイル記述子は、たとえ `open()' が失敗しても、保存され
     ます。(通常のファイル記述子は、`open()' が実行される前にクローズ
     されます。)ファイル記述子の close-on-execのステータスは、exec 時
     ではなく、open 時の $^F の値によって決められます。


 -- Variable: $INPLACE_EDIT
 -- Variable: $^I
     置き換え編集の拡張子の値を示します。置き換え編集を禁止するために
     は、`undef' を設定します。(記憶法: `-i' スイッチの値。)


 -- Variable: $PERLDB
 -- Variable: $^P
     デバッガが自分自身をデバッグしないようにクリアする、内部フラグで
     す。これをクリアして、デバッグしないようにすることも考えられます。


 -- Variable: $BASETIME
 -- Variable: $^T
     スクリプトを実行開始した時刻を、紀元 (1970) からの秒数で示したも
     のです。ファイルテスト `-M', `-A', `-C' で返される値は、この値に
     基づいています。


 -- Variable: $WARNING
 -- Variable: $^W
     警告スイッチの値で、真か偽が設定されます。(記憶法: `-w' スイッチ
     に関係します。)


 -- Variable: $EXECUTABLE_NAME
 -- Variable: $^X
     Perl バイナリ自身が実行された時の名前を C の argv[0]から持ってき
     たものです。


 -- Variable: $ARGV
     <> から読込みを行なっているとき、その時点のファイル名を示します。


 -- Variable: @ARGV
     配列 @ARGV は、コマンドラインからスクリプトに渡す引数が入れられま
     す。$ARGV[0] がコマンド名ではなく、最初の引数ですから、$#ARGV は
     一般には、引数の個数 - 1となります。コマンド名については、"$0" を
     参照してください。


 -- Variable: @INC
     配列 @INC には、`do EXPR', `require', `use' によって評価する Perl 
     スクリプトを探す場所のリストが納められています。初期状態では、コ
     マンドラインスイッチ -I の引数とデフォルトの Perl ライブラリディ
     レクトリ (おそらく"/usr/local/lib/perl5") とカレントディレクトリ
     を表わす "."  を順につなげたものです。


 -- Variable: %INC
     ハッシュ %INC は、`do' や `require' によってインクルードされた、
     個々のファイル名をエントリとして持っています。key は指定したファ
     イル名で、value は実際に見つかった場所となっています。`require' 
     コマンドは、指定されたファイル名が既にインクルードされているかを、
     この配列を使って調べます。


 -- Variable: $ENV{expr}
     ハッシュ %ENV には、その時点の環境変数が設定されています。%ENV に
     値を設定することで、チャイルドプロセスの環境変数を変更します。


 -- Variable: $SIG{expr}
     ハッシュ %SIG は、さまざまなシグナルのハンドラを設定するのに使用
     されます。例:

          sub handler {       # 第一引数はシグナル名
              local($sig) = @_;
              print "Caught a SIG$sig--shutting down\n";
              close(LOG);
              exit(0);
          }

          $SIG{'INT'} = 'handler';
          $SIG{'QUIT'} = 'handler';
          ...
          $SIG{'INT'} = 'DEFAULT';    # デフォルトに戻す
          $SIG{'QUIT'} = 'IGNORE';    # SIGQUIT を無視する

     配列 %SIG には、Perl スクリプト内で実際に設定されたシグナルに対す
     る値だけを保持しています。いくつか他にも例を示します:

          $SIG{PIPE} = Plumber;       # やめて !!
          $SIG{"PIPE"} = "Plumber";   # よい、main::Plumber を仮定
          $SIG{"PIPE"} = \&Plumber;   # よい、現在の Plumber を仮定
          $SIG{"PIPE"} = Plumber();   # え？ Plumber() が返したもの？

     「やめて」と書いたのは、裸の単語なので、問題となるからです。時に
     は関数を表現する文字列となりますが、時にはその時点、その場所で呼
     び出されるサブルーティンコールとなるからです。確実にする最善の方
     法は、クォートするか、リファレンスをとることです。*Plumber でもか
     まいません。*Note サブルーティン::,を参照してください。




File: perl-ja.info, Node: サブルーティン, Next: モジュールについて, Prev: 定義済み変数, Up: Top

サブルーティン
**************


Synopsis
========

サブルーティンの宣言:
          sub NAME;      # 「前方」宣言
          sub NAME BLOCK # 宣言かつ定義

サブルーティンのインポート:
          use PACKAGE qw(NAME1 NAME2 NAME3);

サブルーティンの呼び出し:
          &NAME          # その時点の @_ をサブルーティンに渡す。
          &NAME(LIST);   # & 形式では、引数に括弧が必要。
          NAME(LIST);    # 括弧があるときには & はなくてもよい。
          NAME LIST;     # 宣言済み/インポート済みのとき括弧はなく
                         # てもよい。




Description
===========

サブルーティンに渡された引数は、配列 @_ (すなわち $_[0], $_[1], ...) 
として参照できます。配列 @_ はローカルな配列ですが、その値は実際のスカ
ラ引数へのリファレンスです。サブルーティンが返却する値は、最後に評価さ
れた値であり、リスト値である場合も、スカラ値である場合もあります。これ
とは別に、return 文を使うと、返却する値を指定して、サブルーティンから
抜けることができます。ローカルな変数を作るには、*Note 組み込み関数::,
の `local()' 演算子と `my()' 演算子を参照してください。

サブルーティンは、"&" という記号を頭に付けて呼び出すことができます。
Perl 5 では、"&" はなくてもよく、宣言済みのときには、括弧も省略できま
す。(ただし、`defined()' や `undef()' の引数として使う場合のように、サ
ブルーティンを名指しするときには"&" は省略できないことに気を付けてくだ
さい。また、サブルーティン名や、`&$subref()' や `&{$SUBREF}()' 構造を
使ったリファレンスでサブルーティンの間接呼び出しをするときにも省略でき
ません。さらには、*Note リファレンスとデータ構造のネスト::,を参照して
ください。)

例:
     sub MAX {
         my $max = pop(@_);
         foreach $foo (@_) {
             $max = $foo if $max < $foo;
         }
         $max;
     }
     ...
     $bestday = &MAX($mon,$tue,$wed,$thu,$fri);

例:
     # 空白で始まる行をつなげて、1 行入力する

     sub get_line {
         $thisline = $lookahead;
         LINE: while ($lookahead = <STDIN>) {
             if ($lookahead =~ /^[ \t]/) {
                 $thisline .= $lookahead;
             }
             else {
                 last LINE;
             }
         }
         $thisline;
     }

     $lookahead = <STDIN>;       # 最初の行を先読み
     while ($_ = get_line()) {
         ...
     }

形式引数に名前を付けるには、ローカルリストへの配列代入を行ないます:

     sub maybeset {
         my($key, $value) = @_;
         $foo{$key} = $value unless $foo{$key};
     }

代入では値をコピーしますから、参照呼び出しのサブルーティンを値呼び出し
のサブルーティンに変える働きもあります。

サブルーティンは再帰的に呼び出すこともできます。サブルーティンを "&" 
形式で呼び出す場合、引数リストは省略できます。省略した場合には、そのサ
ブルーティンに対しては、@_ 配列が設定されません。呼び出し時点での配列 
@_ が、そのままサブルーティン側でも見えることになります。

     &foo(1,2,3);        # 3 つの引数を渡す
     foo(1,2,3);         # 同じ

     foo();              # 空リストを渡す
     &foo();             # 同じ
     &foo;               # 何も渡さない (より効率的)


* Menu:

* シンボルテーブルのエントリを渡す::
* 組み込み関数の再定義::
* 自動ロード::





File: perl-ja.info, Node: シンボルテーブルのエントリを渡す, Next: 組み込み関数の再定義, Prev: サブルーティン, Up: サブルーティン

シンボルテーブルのエントリを渡す
================================

[注意:この節で記述する機能は Perl 5 でもちゃんと動作しますが、一般的に
は新規に追加されたリファレンス機能の方が扱いやすいでしょう。*Note リファ
レンスとデータ構造のネスト::, を参照してください。]

配列のローカルなものではなく、グローバルなものの変更ができるように、配
列の値ではなく、名前を渡したいようなことがあるでしょう。Perl では、名
前の前にアスタリスクをつけて、`*foo' のようにして、特定の名前のすべて
のオブジェクトを参照することができます。先頭のアスタリスクは、変数やサ
ブルーティンに付ける記号すべてにマッチする、ワイルドカードのように考え
ることができますから、よく「型グロブ」とよばれます。

型グロブは評価されると、その名前のすべてのオブジェクト (これには、ファ
イルハンドル、フォーマット、サブルーティンなども含まれます) を参照する
スカラ値となります。代入されると、指定された名前で、"*" 値に代入された
ものを参照するようになります。例:

     sub doubleary {
         local(*someary) = @_;
         foreach $elem (@someary) {
             $elem *= 2;
         }
     }
     doubleary(*foo);
     doubleary(*bar);

スカラ値は、サブルーティンに対して、すでにリファレンスとして渡されてい
ますから、この機能を使わなくても、明示的に $_[0]などを参照して、スカラ
引数を修正することができます。配列の要素をすべてスカラとして渡すことで、
その全部の要素を変更することができますが、`push'、`pop' や配列の大きさ
を変えるなどの操作には、* の機能 (あるいは同等のリファレンスの機能) を
使う必要があります。型グロブ (やリファレンス) を渡す方が確実に速くなり
ます。

配列を変更したい場合でなくても、1 つの LIST のなかで、複数の配列を渡し
たいときなどに、この方法が役に立ちます。通常は、LIST のしくみによって、
配列の値がつなげられていまうので、配列を個々に取り出すことができなくなっ
てしまうからです。





File: perl-ja.info, Node: 組み込み関数の再定義, Next: 自動ロード, Prev: シンボルテーブルのエントリを渡す, Up: サブルーティン

組み込み関数の再定義
====================

多くの組み込み関数は、再定義することができますが、これは、ちゃんとした
理由があるときに限って行なうべきです。UNIX 以外のシステムで、実装され
ていない組み込み関数をエミュレートするために使われるのが普通でしょう。

再定義は、モジュールから名前をインポートすることでのみ行なうことができ、
通常の前方宣言は十分ではありません。しかし、subs プラグマ (コンパイラ
ディレクティブ) を使うと、インポート構文で前方宣言されたものと同様に有
効となり、組み込み関数をその名前で再定義することができます:

     use subs 'chdir', 'chroot', 'chmod', 'chown';
     chdir $somewhere;
     sub chdir { ... }

ライブラリモジュールは一般に、デフォルトの @EXPORT リストの一部として 
`open' や `chdir' といった組み込みの名前をエクスポートすべきではありま
せん。これらの名前は、思わぬところの名前空間に侵入して、思わぬように意
味を変えてしまうかも知れないからです。その代わりに、モジュール側で 
@EXPORT_OK に名前を入れておけば、使用する側では暗黙にではなく、明示的
にインポートすることができるようになります。つまり、

     use Module 'open';

とは書くことができ、`open' をインポートして再定義しますが、

     use Module;

とした場合には、再定義の無いデフォルトのインポートが行なわれます。





File: perl-ja.info, Node: 自動ロード, Prev: 組み込み関数の再定義, Up: サブルーティン

自動ロード
==========

もし、未定義のサブルーティンを呼び出した場合には、通常はすぐに、「サブ
ルーティンがない」というコンパイル時の致命的エラーになります。(メソッ
ドとして使われるサブルーティンも同様で、そのクラスのどの基底クラスにも
メソッドが存在しない場合に、エラーとなります。) しかし、`AUTOLOAD' と
いうサブルーティンが、そのパッケージか、もとのサブルーティンが探される
サブルーティンで定義されていれば、その `AUTOLOAD' サブルーティンが、も
とのサブルーティンを呼び出すときに渡すはずだった引数を使って、呼び出さ
れます。もとのサブルーティンの完全な名前は、`AUTOLOAD'ルーティンとして、
同じパッケージの変数 $AUTOLOAD に記録されています。名前は、普通の引数
としては渡されません。というのは、あー、その、だから ...

多くの `AUTOLOAD' ルーティンは、`eval' を用いて、問題のサブルーティン
の定義をロードし、そのサブルーティンを、トレースなしに`AUTOLOAD' ルー
ティンのスタックフレームを消してくれる、特殊な形式の `goto' を使って呼
び出します。(たとえば、標準の`AutoLoader' モジュールを参照してください。)
しかし、改めて定義を行なわずに、`AUTOLOAD' ルーティン自身で、実行され
るはずのルーティンをエミュレートすることも可能です。この形式の良い例と
しては、未定義のサブルーティン呼び出しを UNIX プログラムへの呼び出しと
して扱う、標準の `Shell' モジュールがあげられます。

モジュールが自分自身を、標準の `AutoLoader' モジュールといっしょに使用
するために、自動ロード可能なファイルに分割するのを補助するしくみが用意
されています。拡張モジュールに関するドキュメントを参照してください。





File: perl-ja.info, Node: モジュールについて, Next: リファレンスとデータ構造のネスト, Prev: サブルーティン, Up: Top

モジュールについて
******************

* Menu:

* パッケージ::
* シンボルテーブル::
* パッケージのコンストラクタとデストラクタ::
* クラス::
* モジュール::
* モジュールライブラリ::
* プラグマ的モジュール::
* 標準モジュール::
* 拡張モジュール::





File: perl-ja.info, Node: パッケージ, Next: シンボルテーブル, Prev: モジュールについて, Up: モジュールについて

パッケージ
==========

Perl には、パッケージどうしがお互いの変数を踏みにじることが無いように、
名前空間を別ける機構が用意されています。デフォルトでは、Perl スクリプ
トは `main' と言われるパッケージで、コンパイルを始めます。名前空間を切
り替えるには、`package' 宣言を使います。`package' 宣言のスコープは、そ
の宣言の場所から、囲っているブロックの終わりまでです (`local()' 演算子
と同じスコープです)。`require' 演算子でインクルードされるファイルの、
最初の宣言となるのが普通です。複数の場所で、同一のパッケージに切り替え
ることもできます。この宣言は、ブロックの残りの部分で、コンパイラがどの
シンボルテーブルを使うのかに影響を与えるだけです。他のパッケージの変数
やファイルハンドルは、識別子名の前に、`$Package::Variable' のようにパッ
ケージ名とコロン 2 つで「修飾」することで、参照することができます。パッ
ケージ名が空の場合には、`main' パッケージを参照しているものとみなされ
ます。つまり、`$::sail' は、`$main::sail' と同じです。

(以前はパッケージの区切文字にシングルクォートを使っていましたが、現在
はダブルコロンが使われます。人間が読みやすいからであり、Emacs マクロが
読みやすいからです。また、C++ のプログラマが、何が起こっているかを理解
しやすいということもあります。)

パッケージは、`$OUTER::INNER::var' のように、別のパッケージの中にネス
トすることもできます。しかし、これが名前の検索順序に関るものではありま
せん。すべてのシンボルは、その時点のパッケージにローカルであるか、完全
な形でパッケージ名をつけて、外部のパッケージから導入したものでなければ
なりません。たとえば、パッケージ `OUTER' にいるとすると、`$INNER::var' 
という表現は、`$OUTER::INNER::var' を参照します。パッケージ `INNER' は、
まったく独立したグローバルなパッケージとして扱われます。

英字 (または、下線) で始まる識別子のみが、各々のパッケージのシンボルテー
ブルに蓄えることができます。他のすべてのシンボルは、パッケージ main に
置かれます。さらに、識別子 `STDIN'、`STDOUT'、`STDERR'、`ARGV'、
`ARGVOUT'、`ENV'、`INC'、`SIG' は、組み込みの用法とは異なることに使っ
ても、強制的にパッケージ `main' に置かれます。また、`m'、`s'、`y' とい
うパッケージを作った場合には、パッケージ名で修飾した形で識別子を使うこ
とができない場合があります。それぞれ、パターンマッチ、置換、変換と解釈
されるからです。

(以前は下線で始まる変数は、強制的に `main' パッケージに置かれましたが、
プライベートな変数やメソッドを表わすのに、先頭に下線を使うことができた
方が良いと判断しました。)

`eval()' された文字列は、`eval()' がコンパイルされたパッケージで、コン
パイルされます。(しかし、`$SIG{}' への代入は、指定したシグナルハンドラ
が、パッケージ `main' にあるものとして扱います。シグナルハンドラを別の
パッケージにおきたい場合には、そのシグナルハンドラ名にパッケージ名を付
けてください。)たとえば、Perl ライブラリの `perl5db.pl' を参照してくだ
さい。最初に、デバッグしようとするスクリプトの変数を、デバッガが壊さな
いように、パッケージ `DB' に切り替えます。しかし、多くのポイントで、さ
まざまな式をパッケージ `main' (や、もともと指定してたパッケージ) で評
価するために、一時的にパッケージ `main' に戻るようにしています。*Note 
デバッグ::,を参照してください。





File: perl-ja.info, Node: シンボルテーブル, Next: パッケージのコンストラクタとデストラクタ, Prev: パッケージ, Up: モジュールについて

シンボルテーブル
================

パッケージのシンボルテーブルは、パッケージ名に 2 つのコロンを付けた名
前の連想配列に蓄えられます。つまり、`main' のシンボルテーブルは、
`%main::'、または短く `%::' となります。同様に、先に述べたネストしたパッ
ケージは `%OUTER::INNER::' となります。

連想配列の個々のエントリの value は、*name 記法を使ったときに参照する
ものです。実際、

     local(*main::foo) = *main::bar;
     local($main::{'foo'}) = $main::{'bar'};

は、前者がシンボルテーブルの検索をコンパイル時に行ないますので、より効
率的ですが、同じことを行ないます。

たとえば、これを使って、パッケージ内のすべての変数を出力することができ
ます。

以下は、Perl ライブラリの `dumpvar.pl' です:

     package dumpvar;
     sub main::dumpvar {
         ($package) = @_;
         local(*stab) = eval("*${package}::");
         while (($key,$val) = each(%stab)) {
             local(*entry) = $val;
             if (defined $entry) {
                 print "\$$key = '$entry'\n";
             }
 
             if (defined @entry) {
                 print "\@$key = (\n";
                 foreach $num ($[ .. $#entry) {
                     print "  $num\t'",$entry[$num],"'\n";
                 }
                 print ")\n";
             }
 
             if ($key ne "${package}::" && defined %entry) {
                 print "\%$key = (\n";
                 foreach $key (sort keys(%entry)) {
                     print "  $key\t'",$entry{$key},"'\n";
                 }
                 print ")\n";
             }
         }
     }

このサブルーティンは、パッケージ `dumpvar' でコンパイルされているにも
関らず、サブルーティンの名前が修飾されているため、パッケージ `main' の
中に入れられることになります。

シンボルテーブルエントリへの代入は、別名付け操作になります。つまり、

     *dick = *richard;

は、`richard' という名前でアクセスできる変数、サブルーティン、ファイル
ハンドルを `dick' という名前でもアクセスできるようにします。リファレン
スを使えば、特定の変数だけ、サブルーティンだけ、というように個別に別名
を付けることができます:

     *dick = \$richard;

は、$richard と $dick を同じ変数にしますが、@richard と @dickは別の配
列のままです。難しいですか。





File: perl-ja.info, Node: パッケージのコンストラクタとデストラクタ, Next: クラス, Prev: シンボルテーブル, Up: モジュールについて

パッケージのコンストラクタとデストラクタ
========================================

パッケージのコンストラクタとデストラクタとして機能する、2 つの特別なサ
ブルーティン定義があります。それは、BEGIN ルーティンと END ルーティン
です。このルーティンでは `sub' は省略できます。

BEGIN サブルーティンは、できるだけ早く、つまり、たとえファイルの残りが
解析されていなくても、定義された瞬間に実行されます。ファイル内に複数の 
BEGIN ブロックを置くこともでき、定義された順番に実行されます。BEGIN ブ
ロックは即座に実行されるため、サブルーティンなどの定義を他のファイルか
ら読み込んで、ファイルの残りの部分から見えるようにすることができます。

END サブルーティンは、できるだけ遅く、つまり、たとえ `die()' 関数の結
果であっても、インタプリタが終了するときに実行されます。(しかし、シグ
ナルによって決壊してしまう時には実行されません。(できるものなら、) 自
分でトラップしなければなりません。)ファイル内に複数の END ブロックを置
くこともでき、定義とは逆の順序で実行されます。つまり、ラストインファー
ストアウト (LIFO) ということです。

Perl に `-n' や `-p' スイッチを使ったときには、 BEGIN と END は、縮退
したケースとして、awk と同じように動作します。





File: perl-ja.info, Node: クラス, Next: モジュール, Prev: パッケージのコンストラクタとデストラクタ, Up: モジュールについて

クラス
======

Perl 5 には、特別なクラスのための構文はありませんが、メソッドとして機
能するサブルーティンを持つパッケージは、クラスとして機能することができ
ます。そのようなパッケージでは、他のクラスパッケージの名前を配列 @ISA 
に並べることで、そのクラスからメソッドのいくつかを引き込んでくることが
できます。このことについて詳しくは、*Note オブジェクト::,を参照してく
ださい。





File: perl-ja.info, Node: モジュール, Next: モジュールライブラリ, Prev: クラス, Up: モジュールについて

モジュール
==========

Perl 5 では、パッケージの概念は、モジュールの概念に拡張されました。モ
ジュールは同じ名前のライブラリファイルで定義されたパッケージで、再利用
可能なように設計されたものです。そのモジュールを使用する、任意のパッケー
ジのシンボルテーブルに、自分のシンボルのいくつかをエクスポートする機能
を用意することでこれを行なっているともいえます。あるいは、モジュールは
クラス定義として機能することもでき、明示的にシンボルをエキスポートしな
くても、クラスやそのオブジェクトに対するメソッド呼び出しを通して、暗黙
のうちに意味が通じるようにすることができます。

Perl のモジュールは、

     use Module;

か、あるいは

     use Module LIST;

としてインクルードします。これは、

     BEGIN { require "Module.pm"; import Module; }

か、あるいは

     BEGIN { require "Module.pm"; import Module LIST; }

とするのと、全く同じことです。

Perl のモジュールはすべて `.pm' という拡張子を持ち、`use' は、これをデ
フォルトにしていますので、クォートで括って、"Module.pm"と書く必要はあ
りません。これはまた、新しいモジュールと古い`.pl' ファイルや `.ph' ファ
イルとに差を設けるのにも役立っています。モジュール名は、プラグマとして
働くもの以外は、先頭を大文字にします。「プラグマ」は、コンパイラディレ
クティブであり、「プラグマ的モジュール」(あるいは、古典学者であれば
「プラグマタ」) と呼ぶ人もあります。

`use' 文は、BEGIN ブロックを使っていますので、内容のインポートは、
`use' 文がコンパイルされるとき、ファイルの残りがコンパイルされる前に行
なわれます。それで、モジュールがプラグマとして機能することができ、また、
現在のファイルの残りの部分でリスト演算子として参照することのできるサブ
ルーティンの宣言ができるのです。これは、`use' の代わりに `require' を
使ったのでは、うまく働きません。したがって、名前空間を変更するモジュー
ルを作ろうとしているのであれば、`use' を使い、さもなくば `require' を
使います。そうしないと、以下のような問題が起こります:

     require Cwd;                # Cwd:: を使えるようにする
     $here = Cwd::getcwd();

     use Cwd;                    # Cwd:: から名前をインポート
     $here = getcwd();

     require Cwd;                # Cwd:: を使えるようにするが
     $here = getcwd();           # main::getcwd() がない

Perl のパッケージは、他のパッケージ名の中にネストすることができますか
ら、`::' を含むパッケージ名を使えます。しかし、そのパッケージ名を直接、
ファイル名として使うと、役に立たないものになるか、システムによってはファ
イル名として使えません。そこで、`Text::Soundex' といったモジュール名で
あれば、その定義は、実際には `Text/Soundex.pm' というライブラリファイ
ルに置かれます。

Perl のモジュールは常に `.pm' ファイルを持っていますが、そのモジュール
に対応して、動的にリンクされる実行ファイルや、自動ロードサブルーティン
定義が存在する場合があります。そうなら、それらは、モジュールのユーザに
も完全に透過的に見えます。追加機能をロードする (あるいは、自動ロードの
準備をする) のは`.pm' ファイルの責任となります。`POSIX' モジュールは、
たまたま、動的ロードも自動ロードも行ないますが、使う側は、すべてを使え
るようにするために `use POSIX' と書くことができるだけです。

拡張モジュールの記述に関してさらに詳しくは、*Note 応用プログラムインタ
フェース::,や*Note 拡張を行なうための内部関数::,を参照してください。



モジュールについての注釈
------------------------
C++ や Ada や Modula-17 といった言語で行なわれているような、プライベー
ト部とパブリック部を分けるといったことは、Perl では行なっていません。
Perl は、強制されたプライバシーなどには興味がありせん。招かれたわけで
はないから、リビングに入らない方がよいのであって、ショットガンがあるか
ら入らない方がよいのではありません。

モジュールとそのユーザの間には契約があります。一部は、非成文慣習法的な
ものであり、一部は「成文化」されたものです。慣習契約には、モジュールは
頼まれない限り名前空間を汚さない、ということがあります。モジュールの成
文化契約 (AKA ドキュメント) は、別の規約を作るかもしれません。しかし、
`use RedefineTheWorld' して、世界を再定義することで、結果を甘受するの
です。





File: perl-ja.info, Node: モジュールライブラリ, Next: プラグマ的モジュール, Prev: モジュール, Up: モジュールについて

モジュールライブラリ
====================

Perl の配布には、多くのモジュールが含まれています。これらについては、
以下に記述しており、すべて `.pm' で終わるようになっています。ライブラ
リディレクトリには、 `.pl' や `.ph' で終わるファイルがあることも発見す
るかもしれません。これらの古いライブラリが提供されていますので、これを
使う古いプログラムも実行できます。h2ph で作られた `.ph' ファイルは、
h2xs で作られる拡張モジュールとなるかもしれません。(いくつかの `.ph' 
の値は既に、POSIX モジュールで使用できるかもしれません。)配布の中の 
pl2pm ファイルは、変換の手助けになるかもしれませんが、機械的な処理でし
かないので、「何でもこい」というものではありません。




File: perl-ja.info, Node: プラグマ的モジュール, Next: 標準モジュール, Prev: モジュールライブラリ, Up: モジュールライブラリ

プラグマ的モジュール
--------------------

これらは、プラグマのようにして動作し、プログラムのコンパイルに影響を与
えるもので、通常 `use' や `no' といっしょに使ったときに正常に動作しま
す。ローカルなスコープが存在しますから、内側の BLOCK で

     no integer;
     no strict 'refs';

として、撤回すれば、その BLOCK の最後までが影響されます。

以下のプログラムが定義され (て、独自のドキュメントを持っ) ています。

integer
     double の代わりに整数で演算を行なう Perl プラグマ

less
     コンパイラからのリソースを少なく要求するプラグマ

sigtrap
     不慮のシグナルで、スタックのバックとレースを許可する Perl プラグ
     マ

strict
     安全でない構文を制限する Perl プラグマ

subs
     sub 名を、あらかじめ定義する Perl プラグマ





File: perl-ja.info, Node: 標準モジュール, Next: 拡張モジュール, Prev: プラグマ的モジュール, Up: モジュールライブラリ

標準モジュール
--------------

以下のもっジュールはすべて、`Exporter' モジュールを使用しているので、
名前空間の汚染に関してうまいやり方で動作することが、期待されます。詳し
くは、各々のドキュメントを参照してください。

Abbrev
     リストから省略形一覧を作成する

AnyDBM_File
     複数の DBM ファイルを扱う枠組みを与える

AutoLoader
     要求時にのみ関数をロードする

AutoSplit
     自動ロードのためにパッケージを分割する

Basename
     ファイル記述から、ファイル名とパス名を解析する

Benchmark
     コードの実行時ベンチマークを行なう

Carp
     (呼び元の観点からの) エラーの `warn' と `die'

CheckTree
     トリー上で多くのファイルテストチェックを行なう

Collate
     その時点の locale にしたがって、8-bit スカラデータを比較する

Config
     Perl の `config' オプションをアクセスする

Cwd
     カレントディレクトリのパス名を取得する

DynaLoader
     C ライブラリを Perl のコードに動的ロードする

English
     醜い記号のような変数名の代わりに、うまい英語 (あるいは awk) の名
     前を使う

Env
     環境変数をインポートする Perl モジュール

Exporter
     名前空間操作を制御するモジュール

Fcntl
     C の `fcntl.h' 定義をロードする

FileHandle
     ファイルハンドルに対し、オブジェクトメソッドを提供する

Find
     ファイルトリーのトラバースする

Finddepth
     ディレクトリ構造を、深度優先でトラバースする

Getopt
     getopt(3) 処理の基本的なものと拡張されたもの

MakeMaker
     Perl 拡張モジュールの `Makefile' を生成する

Open2
     読み書き両用のプロセスをオープンする

Open3
     読み書き、エラー処理のためのプロセスをオープンする

POSIX
     IEEE 1003.1 名前空間への Perl インタフェース

Ping
     ホストの起動状態を確認する

Socket
     C の `socket.h' 定義をロードする





File: perl-ja.info, Node: 拡張モジュール, Prev: 標準モジュール, Up: モジュールライブラリ

拡張モジュール
--------------

拡張モジュールは、C (あるいは、Perl と C の混成) で書かれ、それが必要
になることがあれば、動的にロードされるものです。サポートされている拡張
モジュールには `Socket' モジュール、`Fcntl' モジュール、`POSIX' モジュー
ルが含まれます。

以下は、一般的な C の拡張モジュールで、Perl 5.0 のリリース時に利用可能
ですが、大きさの問題や、変更が多いなどの理由や、単純に適切なテストや、
Perl がベータテストされた多くの環境での構築の時間がとれなかったために 
(少なくとも完全には) バンドルされていません。現状や場所を尋ねてランダ
ムに投稿する前に、archie(1L) や Perl FAQ、Meta-FAQ、WWW page、あるいは
作者自身に頼って、探すことをお勧めします。出力以降に、以下の名前やアド
レスが変わっていないという保証はありませんし、事実変わっています。

Curses
     William Setzer <William_Setzer@ncsu.edu> が書いたもので、標準の配
     布には含まれませんが、この拡張モジュールは、多くのシステムに移植
     されています。お近くの Perl アーカイブサイトか、

          ftp://ftp.ncsu.edu/pub/math/wsetzer/cursperl5??.tar.gz

     から FTP してください。これは、現在アルファテスト中ですので、名前
     や ftp の場所は変わるかもしれません。

DBI
     <Tim.Bunce@ig.co.uk> が書いたポータブルなデータベースインタフェー
     スです。これは、perl4 になされた、多くのデータベースを扱うための
     移植に置き変わるものです。DBperl 拡張の正規のアーカイブは、
     `ftp.demon.co.uk:/pub/perl/db' です。このアーカイブには、rdb、
     shql といった non-SQL システムはもとより、Ingres、Oracle、Sybase、
     Informix、Unify、Postgres、Interbase のための perl4 の移植が含ま
     れています。

DB_File
     DBM との組み合わせで最も速く、制限が最も少ない、この拡張モジュー
     ルは、ハッシュに `tie()' するために、一般的なバークレイ DB を使い
     ます。これには、標準的に配布される man page や動的ロード拡張モジュー
     ルが含まれていますが、バークレイのコードは、自分で入手する必要が
     あります。どこにあるかについては、DB_File manapge を参照してくだ
     さい。

Sx
     この拡張モジュールは、Perl GUI プログラミングのための Athena と 
     Xlib のフロントエンドとなるもので、Dominic Giampaolo
     <dbg@sgi.com> が書いたものを Frederic Chauveau <fmc@pasteur.fr> 
     が Sx のために書き直しました。これは、

          ftp.pasteur.fr:/pub/Perl/Sx.tar.gz

     から FTP することができます。

Tk
     この拡張モジュールは、広く使われている tcl/tk X11 パッケージと組
     み合わせる、オブジェクト指向のPerl5 です。しかし、これを使うため
     に TCL の知識はいりません。これは、Malcolm Beattie
     <mbeattie@sable.ox.ac.uk> が書いたもので、archie (1L) などのツー
     ルを使っても、どこにあるかがわからなければ、上にあげた Malcolm の
     マシンの `/private/Tk-october.tar.gz' から入手することができます。





File: perl-ja.info, Node: リファレンスとデータ構造のネスト, Next: オブジェクト, Prev: モジュールについて, Up: Top

リファレンスとデータ構造のネスト
********************************

* Menu:

* ハードリファレンス::
* ハードリファレンスの作成::
* ハードリファレンスの参照::
* シンボリックリファレンス::
* さらに学ぶために::





File: perl-ja.info, Node: ハードリファレンス, Next: ハードリファレンスの作成, Prev: リファレンスとデータ構造のネスト, Up: リファレンスとデータ構造のネスト

ハードリファレンス
==================

Perl 4 では、複雑なデータ構造を表現するのは難しいことでした。すべての
リファレンスはシンボリックでなければならず、シンボルテーブルのエントリ
ではなく、特定の変数を参照したいような場合にも大変だったからです。Perl
5 は、変数へのシンボリックリファレンスを使い易くしただけではなく、どん
なデータにも「ハード」リファレンスが行なえるようにしました。任意のスカ
ラがハードリファレンスを保持することができます。スカラは、配列やハッシュ
の一部でもありますから、配列の配列、ハッシュの配列、配列のハッシュ、関
数のハッシュの配列といったものが簡単に作れるようになりました。

ハードリファレンスは賢く、実際に参照されている数を管理していて、その数
が 0 になれば、自動的に解放を行ないます。そのものがオブジェクトである
ときには、デストラクタが動作します。オブジェクトについてより詳しくは、
*Note オブジェクト::,を参照してください。(ある意味では、Perl のすべて
がオブジェクトですが、通常、クラスパッケージ内で公に `bless' されてい
るものへのリファレンスに対して、この用語を用います。)

ファイルシステム上でのシンボリックリンクが、単にファイルの名前を持って
いるだけであるのと同様に、シンボリックリファレンスは、変数の名前を保持
します。`*glob' の記法は、シンボリックリファレンスの 1 種です。ハード
リファレンスは、ファイルシステム上のハードリンクに似ており、名前によら
ず、基本となる同一のオブジェクトに到達する方法を与えるものです。

Perl では、「ハード」リファレンスは簡単に使えます。これを覆すような原
則は、1 つだけです。Perl は、暗黙の参照や被参照を行ないません。スカラ
がリファレンスを保持しているときも、必ずスカラとして動作します。明示的
に被参照を指示しない限り、そのスカラが魔法のように配列やハッシュとなる
ことはないのです。





File: perl-ja.info, Node: ハードリファレンスの作成, Next: ハードリファレンスの参照, Prev: ハードリファレンス, Up: リファレンスとデータ構造のネスト

ハードリファレンスの作成
------------------------

リファレンスを作成する方法は、いくつかあります。

  1. 変数、サブルーティン、値にバックスラッシュ演算子を使うことによる。
     (これは C での & (アドレス) 演算子に似た働きをします。)既にシンボ
     ルテーブルには変数へのリファレンスが存在していますから、この方法
     は別のリファレンスを作るものであることに注意してください。しかし、
     シンボルテーブルのリファレンスがなくなったとしても、バックスラッ
     シュが返したリファレンスが存在することになります。例をいくつかあ
     げます:

          $scalarref = \$foo;
          $arrayref  = \@ARGV
          $hashref   = \%ENV;
          $coderef   = \&handler;

  2. 名前の無い配列へのリファレンスは、大括弧を使って作ることができま
     す:

          $arrayref = [1, 2, ['a', 'b', 'c']];

     ここでは、『「名前の無い 3 個の要素を持つ配列」を最後の要素として
     持つ 3 個要素の名前の無い配列』へのリファレンスを作っています。
     (あとで述べる多次元構文を使って、これをアクセスすることができます。
     たとえば、上記のようにした後では、`$arrayref->[2][1]' が "b" とな
     ります。)

  3. 名前の無いハッシュへのリファレンスは、中括弧を使って作ることがで
     きます:

          $hashref = {
              'Adam'  => 'Eve',
              'Clyde' => 'Bonnie',
          };

     名無しのハッシュと配列のコンストラクタは、複雑な構造を作るために、
     自由に組み合わせることができます。後述する多次元構文は、そのよう
     なものに対しても使うことができます。上記の value はリテラルですが、
     変数や式であってもかまいません。Perl での代入演算は、(たとえ、
     `local()' や `my()' の中でも) コンパイル時の宣言文ではなく、実行
     文ですからです。

     中括弧は、BLOCK を始め他のことにも使われますから、開き中括弧が 
     BLOCK の開始でないことを Perl に教えるために、文の最初の中括弧の
     前に `+' や `return' をつけて、曖昧さをなくすようにする必要がある
     場合があります。この時折の余分な仕事は、中括弧の使用に関する経済
     的、記憶的価値があると思われます。

     たとえば、新しいハッシュを作って、それへのリファレンスを返す関数
     が欲しければ、以下のような選択肢があります:

          sub hashem {        { @_ } }   # ちょっと間違い
          sub hashem {       +{ @_ } }   # ok
          sub hashem { return { @_ } }   # ok


  4. 名前の無いサブルーティンのへのリファレンスは、サブルーティン名の
     無い `sub' を使って作ることができます:

          $coderef = sub { print "Boink!\n" };

     セミコロンがあることに注意してください。内部のコードが即座に実行
     されるのではないという事実を除いて、`sub{}' は、宣言というよりも
     むしろ、`do{}' や `eval{}' のような演算子です。(しかし、
     `eval("...")' の中でなければ、何回その行を実行しようとも 
     `$coderef' は、同一の無名サブルーティンを参照することになります。)

     こういったことを気にする方のため、現在のインプリメントでは、
     `local()' 変数の浅い結び付きとなっています。`my()' 変数はアクセス
     できません。これは、真のクロージャを疎外するものとなります。しか
     し、(コンパイル時ではなく、) 実行時の `eval()' を使えば、これに対
     応することができます:

          {
              my $x = time;
              $coderef = eval "sub { \$x }";
          }

     通常は、(`sub {}' だけをつかったり、`eval {}' をも使う場合にも) 
     新しい `sub' はグローバルな `$x' をアクセスすることができるだけで
     す。しかし、実行時に `eval()' を使っているので、呼ばれるごとに、
     新しいサブルーティンリファレンスを作り出すだけではなく、グローバ
     ルな変数の代わりに、プログラム上で自分より前に出てくる `my()' 変
     数をアクセスすることが許されます。一般には、アクセスされる `$x' 
     は、新しい `sub' が作られるごとに、違うものとなります。このしくみ
     では、変数は、動的な深い結び付きとなります。(クロージャや、深い結
     び付き、浅い結び付きというものが何かを知らなくても、あまり悩まな
     いでください。)

  5. リファレンスは、コンストラクタと呼ばれる特別なサブルーティンが返
     すようにしていることが多くなっています。Perlのオブジェクトは、自
     分がどのパッケージと関係を持っているかを知っているものへのリファ
     レンスでしかありません。コンストラクタは、その関係付けをどのよう
     に行なうかを知っているという意味で、特別なサブルーティンにすぎま
     せん。単なるリファレンスとしてスタートし、オブジェクトといわれて
     いる間でも通常のリファレンスであることに変わりはありません。コン
     ストラクタは、慣習的に `new()' と名前を付けますが、そうしなければ
     ならないものではありません:

          $objref = new Doggie (Tail => 'short', Ears => 'long');


  6. 適切な型のリファレンスは、そういったリファレンスが存在するかのよ
     うな文脈で被参照すると、実際に存在するようになります。被参照につ
     いてはまだ話していないので、例を示すことができませんが。

リファレンスの作り方はこれだけです。ここまでくると、どこかリファレンス
のかなたへ行ってしまったデータを取り戻すために、どうやってリファレンス
を使うかを知りたいことでしょう。基本的な方法がいくつかあります。





File: perl-ja.info, Node: ハードリファレンスの参照, Next: シンボリックリファレンス, Prev: ハードリファレンスの作成, Up: リファレンスとデータ構造のネスト

ハードリファレンスの参照
------------------------

  1. 変数名やサブルーティン名の一部として識別子を置くところでは、適切
     な型のリファレンスを持った単純スカラ変数で、その識別子を置き換え
     ることができます:

          $bar = $$scalarref;
          push(@$arrayref, $filename);
          $$arrayref[0] = "January";
          $$hashref{"KEY"} = "VALUE";
          &$coderef(1,2,3);

     `$arrayref[0]' や `$hashref{"KEY"}' という形で被参照しているので
     はないことが大切です。スカラ変数の被参照は、いかなる key の検索よ
     りも「前に」行なわれます。単純スカラ変数より込み入ったものはすべ
     て、以下の 2 番か 3 番の方法が採られます。しかしながら、「単純ス
     カラ」には、この 1番目の方法を再帰的に使っている識別子も含まれま
     す。したがって、

          $refrefref = \\\"howdy";
          print $$$$refrefref;

     は、"howdy" と出力します。

  2. 変数名やサブルーティン名の一部として識別子を置くところでは、適切
     な型のリファレンスを返す BLOCK を伴う識別子で置き換えることができ
     ます。言い換えると、先の例は以下のように書くことができます:

          $bar = ${$scalarref};
          push({$arrayref}, $filename);
          ${$arrayref}[0] = "January";
          ${$hashref}{"KEY"} = "VALUE";
          &{$coderef}(1,2,3);

     確かに、この場合には中括弧を付けるのは、莫迦げたことかもしれませ
     んが、BLOCK には任意の式、特に添字を付けた式を入れることができま
     す:

          &{ $dispatch{$index} }(1,2,3);      # 正しいルーティ
                                              # ンの呼び出し

     単純な `$$x' の場合に中括弧が省略できるので、シンボルの被参照を適
     当な演算子のように受け取って、その優先順位はどのくらいかと悩む人
     があります。しかし、もし演算子であれば、中括弧の代わりに、普通の
     括弧が使えることでしょう。そうではありません。以下の違いを考えて
     みてください。CASE 0 は、CASE 1 を短くしたものであり、CASE 2 では
     ありません:

          $$hashref{"KEY"}   = "VALUE";       # CASE 0
          ${$hashref}{"KEY"} = "VALUE";       # CASE 1
          ${$hashref{"KEY"}} = "VALUE";       # CASE 2
          ${$hashref->{"KEY"}} = "VALUE";     # CASE 3

     CASE 2 もまた、間違えやすいもので、`%hashref' という変数をアクセ
     スするものです。`$hashref' を仲介して、それが指すことになっている
     ハッシュを被参照しているいるものでは、ありません。それは、CASE 3 
     です。

  3. 配列の個々の要素を使う場合が増えると、2 番の方法を使うのが、煩わ
     しくなってきます。構文上の打開策として、上記の2 行は、

          $arrayref->[0] = "January";
          $hashref->{"KEY} = "VALUE";

     のように書くことができます。

     矢印の左側は、以前の被参照を含めて、リファレンスを返す任意の式が
     書けます。(`$array[$x]' は、`$array->[$x]' と同じではありません。)

          $array[$x]->{"foo"}->[0] = "January";

     これが、先の左辺値コンテキストで用いると、リファレンスが存在する
     ようになる、というケースの 1 つです。この文以前には、`$array[$x]' 
     は未定義かもしれません。そうならば、自動的にハッシュリファレンス
     と定義されて、`{"foo"}' が検索できるようになります。同じように、
     `$array[$x]->{"foo"}'が配列リファレンスで定義され、`[0]' を探すこ
     とができます。

     もう一つ。矢印は、括弧付きの添字の「間」では、省略することができ
     ますので、上の例は、

          $array[$x]{"foo"}[0] = "January";

     と書くことができます。通常の配列だけを使うように限定すれば、ちょ
     うど C の多次元配列のように使うことができます:

          $score[$x][$y][$z] += 42;

     ああ、そうだ、実際には全く C の配列と同じという訳ではありません。
     C では、必要に応じて配列を大きくするなどということはできません。
     Perl では、それができます。

  4. リファレンスが、オブジェクトに対するものである場合には、参照され
     るものをアクセスするためのメソッドがあるはずで、オブジェクトのメ
     ソッドを定義するクラスパッケージ内でなければ、そのメソッドを使う
     ようにした方が良いでしょう。言い換えると、良識をもって、特別正当
     な理由がない限り、オブジェクトのカプセル化を反古にしてはいけない
     ということです。Perl は、カプセル化を強要したりはしません。私達は、
     全体主義者ではありません。ただ、なにがしかの基本的な節度を期待し
     ています。

`ref()' 演算子が、リファレンスがどういった型のものを指しているかを、調
べるために使うことができます。*Note 組み込み関数::,を参照してください。

`bless()' 演算子は、リファレンスをオブジェクトクラスとして機能するパッ
ケージと組み合わせるために使うことができます。*Note オブジェクト::,を
参照してください。

被参照構文では、常に目的とするリファレンスの「型」を示すことができます
ので、型グロブをリファレンスと同じように被参照することができます。つま
り、`${*foo}' と `${\$foo}' は、どちらも同じスカラ変数を示すことになり
ます。

次の例に示すのは、文字列にサブルーティン呼び出しを埋め込む仕掛けです:

     print "My sub returned ${\mysub(1,2,3)}\n";

ダブルクォート文字列中に `${...}' が見つかると、ブロックとして評価され
ます。ブロックでは、`mysub(1,2,3)' の呼び出しを実行し、その結果に対す
るリファレンスがとられます。つまり、ブロック全体では、スカラへのリファ
レンスを返すこととなり、`${...}'  で被参照された後、ダブルクォート文字
列の中に、はり込まれることになります。




File: perl-ja.info, Node: シンボリックリファレンス, Next: さらに学ぶために, Prev: ハードリファレンスの参照, Up: リファレンスとデータ構造のネスト

シンボリックリファレンス
========================

リファレンスは、もし未定義であれば、必要に応じて存在するようになると言
いましたが、もしリファレンスとして使われた値が、既に定義されていたとき
には、どのようになるのか示していませんでした。このような場合にリファレ
ンスとして使ったなら、それは、シンボリックリファレンスとして扱われます。
つまり、スカラの値は、無名 (であるかもしれない) 値への直接のリンクでは
なく、変数の「名前」として扱われます。

そのように働くと思われていることが多いものです。それでそう動きます。

     $name = "foo";
     $$name = 1;               # $foo を設定
     ${$name} = 2;             # $foo を設定
     ${$name x 2} = 3;         # $foofoo を設定
     $name->[0] = 4;           # $foo[0] を設定
     @$name = ();              # @foo をクリア
     &$name();                 # &foo() を呼び出す(Perl 4 同様)
     $pack = "THAT";
     ${"${pack}::$name"} = 5;  # eval なしで $THAT::foo を設定

これは、非常に強力で、多少危険でもあります。(最大限の注意をはらって) 
ハードリファレンスを使おうとした場合にも、誤ってシンボリックリファレン
スを使ってしまうような場合があるからです。これを防止するには、

     use strict 'refs';

と書いて、囲っているブロック内の残りの部分では、ハードリファレンスのみ
が許されるようにすることができます。内側のブロックでは、

     no strict 'refs';

と書いて、打ち消すこともできます。

シンボリックリファレンスでは、パッケージ変数だけを見ることができます。
(`my()' で宣言した) 静的なローカル変数は、シンボルテーブルにありません
ので、シンボリックリファレンスでは参照することができません。たとえば:

     local($value) = 10;
     $ref = \$value;
     {
         my $value = 20;
         print $$ref;
     }

これは、20 ではなく、10 と出力します。`local()' は、パッケージで「グロー
バルな」、パッケージ変数に影響するものです。




File: perl-ja.info, Node: さらに学ぶために, Prev: シンボリックリファレンス, Up: リファレンスとデータ構造のネスト

さらに学ぶために
================

明らかなドキュメントを除くと、ソースコードが多くのことを教えてくれます。
多少不自然な、リファレンスの使用例は、Perl のソースディレクトリの 
`t/op/ref.t' レグレッションテストにもあります。





File: perl-ja.info, Node: オブジェクト, Next: オブジェクト指向の仕組みと例, Prev: リファレンスとデータ構造のネスト, Up: Top

オブジェクト
************

まず最初に、Perl でのリファレンスが何かを理解する必要があります。その
ため、*Note リファレンスとデータ構造のネスト::,を参照してください。

ここに、安心材料としてとても簡潔な定義を 3 つ示します。

  1. オブジェクトとは、単に自分が属するクラスを知っているリファレンス
     のことです。

  2. クラスとは、単にオブジェクトリファレンスを扱うためのメソッドを提
     供するパッケージのことです。

  3. メソッドとは、オブジェクトリファレンス (あるいは、静的メソッドに
     は、パッケージ名) を最初の引数として期待するサブルーティンのこと
     です。

ここでは、これらのポイントを掘り下げていきます。

* Menu:

* オブジェクトは単にリファレンスである::
* クラスとは単にパッケージである::
* メソッドとは単にサブルーティンである::
* メソッド呼び出し::
* デストラクタ::
* まとめ::





File: perl-ja.info, Node: オブジェクトは単にリファレンスである, Next: クラスとは単にパッケージである, Prev: オブジェクト, Up: オブジェクト

オブジェクトは単にリファレンスである
====================================

C++ とは違って、Perl ではコンストラクタのために、特別な構文を用意して
いません。コンストラクタは単に、あるクラス内に `bless' されたリファレ
ンスを返すサブルーティンで、一般にそのクラスは、該当サブルーティンが定
義されているクラスです。典型的なクラスの例を示します:

     package Critter;
     sub new { bless {} }

`{}' は、key/value ペアを 1 つも含まず、名前の無いハッシュへのリファレ
ンスを作ります。`bless()' がそのリファレンスを受け取って、そのリファレ
ンスが参照するオブジェクトに対し、現在のパッケージが `Critter' である
ことを告げ、そのリファレンスを返します。これは、参照されたオブジェクト
自身が `bless' されたことを知っているため、簡単にしたもので、以下のよ
うにそのリファレンスを直接返することができあます:

     sub new {
         my $self = {};
         bless $self;
         return $self;
     }

実際には、コンストラクタによる構築の一部として、クラス内のメソッドを呼
ぶような、より込み入ったコンストラクタで、このような構成を目にすること
が多くなります。

     sub new {
         my $self = {}
         bless $self;
         $self->initialize();
         $self;
     }

クラスパッケージ内では、メソッドは、そのリファレンスを通常のリファレン
スとして扱います。クラスパッケージの外では、そのリファレンスは一般に、
そのクラスのメソッドを通してのみアクセスできる、直接参照できない値とし
て扱われます。

コンストラクタは、その時点で別のクラスに属していて参照されているオブジェ
クトを、再度 `bless' することができますが、その場合には、新しいクラス
が、最後の後片付けに全責任を持ちます。以前に行なわれた `bless' は忘れ
去られ、オブジェクトは、その時点では、1 つのクラスにしか属することがで
きません。(ですが、もちろん多くのクラスからメソッドを継承することは、
自由です。)

明確化事項: Perl オブジェクトは、`bless' されます。単なるリファレンス
は、されません。オブジェクトは、自分が属しているパッケージがどれである
かを知っています。リファレンスは、知りません。`bless()' 関数は、オブジェ
クトを探すために、単にリファレンスを用います。以下の例を見てみましょう:

     $a = {};
     $b = $a;
     bless $a, BLAH;
     print "\$b is a ", ref($b), "\n";

このプログラムは、`$b' が `BLAH' であると報告してくれます。つまり、明
らかに `bless()' は、オブジェクトに対して働くのであって、リファレンス
に働くものではありません。





File: perl-ja.info, Node: クラスとは単にパッケージである, Next: メソッドとは単にサブルーティンである, Prev: オブジェクトは単にリファレンスである, Up: オブジェクト

クラスとは単にパッケージである
==============================

C++ などとは違って、Perl ではクラス定義のための特別な構文を用意してい
ません。メソッドの定義を入れることによって、パッケージをクラスとして使
用します。

各々のパッケージには、@ISA という特別な配列があり、現在のパッケージで
メソッドが見つからなかった場合に、どこを探すかということが書いてありま
す。Perl では、これによって継承を実現しています。配列 @ISA の各要素は、
たまたまクラスである、他のパッケージの名前になっています。クラスは、
@ISA に現われる順序で、見つからなかったメソッドを (深度優先) 検索しま
す。@ISA を通じてアクセスできるクラスをカレントクラスの基底クラスとい
います。

必要なメソッドが、基底クラスの中に見つかれば、効率化のために、現在のク
ラスの中にキャッシュされます。@ISA を変更したり、新しいサブルーティン
を定義すると、そのキャッシュを無効にし、再び Perl に検索させるようにし
ます。

メソッドが見つからず、`AUTOLOAD' ルーティンが見つかれば、見つからなかっ
たメソッドの代わりに、それが呼び出されます。

メソッドも `AUTOLOAD' ルーティンも @ISA に見つからなければ、最後の手段
として、`UNIVERSAL' というクラスで、メソッド (あるいは`AUTOLOAD' ルー
ティン) を探します。これでもダメならば、最終的に諦めて、エラーを出すこ
とになります。

Perl のクラスは、メソッドの継承だけを行ないます。データの継承は、クラ
ス自身に任されます。全般的にこのことは、Perlでは問題とはなりません。多
くのクラスは、自分のオブジェクトの属性を、名無しのハッシュを使ってモデ
ル化するからです。そのハッシュは、そのオブジェクトと何らかの関係を持と
うとする、さまざまなクラスによって切り分けられるために、自分自身の小規
模な名前空間として働きます。





File: perl-ja.info, Node: メソッドとは単にサブルーティンである, Next: メソッド呼び出し, Prev: クラスとは単にパッケージである, Up: オブジェクト

メソッドとは単にサブルーティンである
====================================

C++ などとは違って、Perl ではメソッド定義のための特別な構文を用意して
いません。(だたし、メソッド呼び出しのためには、少しばかり構文を用意し
ています。これについては後程。)メソッドでは、最初の引数がオブジェクト
か、自分が呼び出されたパッケージである必要があります。メソッドには、2 
つの種類があり、C++ での最も近い 2 つのメソッドの種類に準じて、静的メ
ソッドと仮想メソッドと呼びます。

静的メソッドは、最初の引数としてクラス名を期待します。これは、全体とし
てのクラスに対する機能を果たすもので、クラスに属する個々のオブジェクト
に対するものではありません。コンストラクタは、典型的な静的メソッドです。
多くの静的メソッドは、その第一引数を単に無視してしまいます。既にどのパッ
ケージにいるのかは、分かっていますし、どのパッケージを介して起動された
かは、関係がないからです。(静的メソッドは、通常の仮想メソッドと同じよ
うに、継承トリーをたどっていますから、これらのパッケージが等しいとは限
りません。) この他に、静的メソッドを使う典型例としては、名前によるオブ
ジェクトの検索があげられます:

     sub find {
         my ($class, $name) = @_;
         $objtable{$name};
     }

仮想メソッドは、最初の引数としてオブジェクトリファレンスを期待します。
最初の引数を `shift' して、`self' や `this' という変数にいれ、通常のリ
ファレンスとして使うことがよく行なわれます。

     sub display {
         my $self = shift;
         my @keys = @_ ? @_ : sort keys %$self;
         foreach $key (@keys) {
             print "\t$key => $self->{$key}\n";
         }
     }





File: perl-ja.info, Node: メソッド呼び出し, Next: デストラクタ, Prev: メソッドとは単にサブルーティンである, Up: オブジェクト

メソッド呼び出し
================

メソッドを呼び出す方法には 2 つあり、その1つは既になじみの深いものです
し、もう1つは見たことのある格好をしています。Perl 4 は、既に

     print STDERR "help!!!\n";

としたときに使われる、「間接オブジェクト」構文を持っていました。

この同じ構文が、静的メソッドにも仮想メソッドにも使われます。先に定義し
た2つのメソッド、オブジェクトリファレンスを検索するための静的メソッド、
その属性を出力するための仮想メソッドを使ってみましょう。

     $fred = find Critter "Fred";
     display $fred 'Height', 'Weight';

これらは、間接オブジェクトのところに BLOCK を使って、1 つの文に組み合
わせることができます:

     display {find Critter "Fred"} 'Height', 'Weight';

C++ ファンのために、同じことをする `->' を使った構文も用意してあります。
引数がある場合には、括弧が必要です。

     $fred = Critter->find("Fred");
     $fred->display('Height', 'Weight');

あるいは、1 文で、

     Critter->find("Fred")->display('Height', 'Weight');

ある構文が読みやすいと感じることがあり、別の構文の方が読みやすいと感じ
ることもあります。間接オブジェクトの構文は、混乱させるようなものではあ
りませんが、通常のリスト演算子としての、同様の曖昧さも持っています。間
接オブジェクトのメソッド呼び出しは、リスト演算子と同じ規則を使って解釈
されます: 「関数のように見えれば、それは関数です。」(2つの並んだ単語が
関数名のように見えると考えれば、です。C++ のプログラマは、特に最初の単
語が `new' のときに、規則的にそのように考えるようです。)つまり、

     new Critter ('Barney', 1.5, 70)

という括弧は、その後に何が来ようとも、メソッドに対するすべての引数を囲っ
ているものとして扱われます。

     new Critter ('Bam' x 2), 1.4, 45

と書くのは、

     Critter->new('Bam' x 2), 1.4, 45

と同じことで、目的とは違うでしょう。

どのクラスのメソッドを使うかを指定したい場合もあります。その場合には、
通常のサブルーティン呼び出しとして、メソッドを呼び出すことができます。
必須の最初の引数は、明示的に渡さなければなりません:

     $fred =  MyCritter::find("Critter", "Fred");
     MyCritter::display($fred, 'Height', 'Weight');

しかしながら、この場合には継承を行ないません。単に Perl がメソッドの検
索を開始する特定のパッケージを指定したいだけならば、メソッド名にパッケー
ジ名を付けて、通常のメソッド呼び出しを使ってください:

     $fred = Critter->MyCritter::find("Fred");
     $fred->MyCritter::display('Height', 'Weight');




File: perl-ja.info, Node: デストラクタ, Next: まとめ, Prev: メソッド呼び出し, Up: オブジェクト

デストラクタ
============

オブジェクトに対する最終的な参照がなくなると、オブジェクトは自動的に、
削除されます。(これは、グローバル変数にリファレンスを入れている場合に
は、`exit' した後になるかもしれません。)オブジェクトがなくなる直前に制
御をもらいたい場合には、クラス内で、`DESTROY' メソッドを定義することが
できます。これは、適切なときに自動的に呼び出されますから、その中で独自
の後片付けを行なうことができます。

Perl では、ネストした削除を行ないません。コンストラクタで、基底クラス
の一つからリファレンスを再 `bless' したような場合には、`DESTORY' のな
かで、必要な基底クラスの `DESTROY' を呼び出す必要があるかもしれません。
しかし、これは再 `bless' されたオブジェクトにだけあてはまります。現在
のオブジェクトに含まれているだけのオブジェクトリファレンスは、その現在
のオブジェクトが解放されるときに、自動的に解放され、削除されます。




File: perl-ja.info, Node: まとめ, Prev: デストラクタ, Up: オブジェクト

まとめ
======

これで、ほとんどすべてです。さて、それでは、すぐにも出かけて、オブジェ
クト指向設計の方法論に関する本を仕入れて、今から半年くらいは、それに頭
を打ちつけ続けることが必要でしょう。

その他のオブジェクトのしくみ、わな、助言について、*Note オブジェクト指
向の仕組みと例::,もチェックしておいてください。





File: perl-ja.info, Node: オブジェクト指向の仕組みと例, Next: デバッグ, Prev: オブジェクト, Up: Top

オブジェクト指向の仕組みと例
****************************

これから示す技とヒントは、インスタンス変数の利用やオブジェクトとクラス
の関係といったことについての、好奇心をそそることを目指しています。これ
を読む方は、オブジェクト指向の定義と方法論に関する適切な本も、読んだ方
がよいでしょう。このドキュメントは、Perl 5 のオブジェクト指向機能の総
括的なガイドを目指すものでもなければ、スタイルガイドとして作られている
わけでもありません。

Perl のモットーは、ここでも生きています: 「やり方は1通りではない。」

* Menu:

* インスタンス変数::
* スカラインスタンス変数::
* インスタンス変数継承::
* オブジェクトの関係::
* スーパークラスのメソッドのオーバライド::
* SDBM を伴う関係の使用::
* コード再利用の考慮::
* クラスコンテキストとオブジェクト::





File: perl-ja.info, Node: インスタンス変数, Next: スカラインスタンス変数, Prev: オブジェクト指向の仕組みと例, Up: オブジェクト指向の仕組みと例

インスタンス変数
================

無名の配列や無名のハッシュには、インスタンス変数を入れておくことができ
ます。名前付きパラメータの例もいっしょに示しておきます。

     package Foo;

     sub new {
             my $type = shift;
             my %params = @_;
             my $self = {};
             $self->{'High'} = $params{'High'};
             $self->{'Low'}  = $params{'Low'};
             bless $self;
     }

     package Bar;

     sub new {
             my $type = shift;
             my %params = @_;
             my $self = [];
             $self->[0] = $params{'Left'};
             $self->[1] = $params{'Right'};
             bless $self;
     }

     package main;

     $a = new Foo ( 'High' => 42, 'Low' => 11 );
     print "High=$a->{'High'}\n";
     print "Low=$a->{'Low'}\n";

     $b = new Bar ( 'Left' => 78, 'Right' => 40 );
     print "Left=$b->[0]\n";
     print "Right=$b->[1]\n";





File: perl-ja.info, Node: スカラインスタンス変数, Next: インスタンス変数継承, Prev: インスタンス変数, Up: オブジェクト指向の仕組みと例

スカラインスタンス変数
======================

無名のスカラは、1 つのインスタンス変数が必要とされるときにだけ、使うこ
とができます。

     package Foo;

     sub new {
             my $type = shift;
             my $self;
             $self = shift;
             bless \$self;
     }

     package main;

     $a = new Foo 42;
     print "a=$$a\n";





File: perl-ja.info, Node: インスタンス変数継承, Next: オブジェクトの関係, Prev: スカラインスタンス変数, Up: オブジェクト指向の仕組みと例

インスタンス変数継承
====================

この例では、新しいクラスで、取り込むためのスーパークラスから、インスタ
ンスを継承する方法を示します。この継承を行なうには、コンストラクタ内で
新しいオブジェクトに対して、スーパークラスのコンストラクタを呼び出して
継承部分の初期化を行なった後、自分自身のインスタンス変数の追加を行ない
ます。

     package Bar;

     sub new {
             my $self = {};
             $self->{'buz'} = 42;
             bless $self;
     }

     package Foo;
     @ISA = qw( Bar );

     sub new {
             my $self = new Bar;
             $self->{'biz'} = 11;
             bless $self;
     }

     package main;

     $a = new Foo;
     print "buz = ", $a->{'buz'}, "\n";
     print "biz = ", $a->{'biz'}, "\n";





File: perl-ja.info, Node: オブジェクトの関係, Next: スーパークラスのメソッドのオーバライド, Prev: インスタンス変数継承, Up: オブジェクト指向の仕組みと例

オブジェクトの関係
==================

以下の例では、オブジェクト間の「包含」および「使用」といわれる関係をイ
ンプリメントする方法を示します。

     package Bar;

     sub new {
             my $self = {};
             $self->{'buz'} = 42;
             bless $self;
     }

     package Foo;

     sub new {
             my $self = {};
             $self->{'Bar'} = new Bar ();
             $self->{'biz'} = 11;
             bless $self;
     }

     package main;

     $a = new Foo;
     print "buz = ", $a->{'Bar'}->{'buz'}, "\n";
     print "biz = ", $a->{'biz'}, "\n";





File: perl-ja.info, Node: スーパークラスのメソッドのオーバライド, Next: SDBM を伴う関係の使用, Prev: オブジェクトの関係, Up: オブジェクト指向の仕組みと例

スーパークラスのメソッドのオーバライド
======================================

以下の例は、スーパークラスのメソッドをオーバライドし、オーバライドされ
た後でそのメソッドを呼び出す方法を示します。`Foo::Inherit' クラスを使っ
て、オーバライドされたスーパークラスのメソッドが、実際には、どこで定義
されているか知らなくても、そのメソッドを呼び出せるようにしています。

     package Buz;
     sub goo { print "here's the goo\n" }

     package Bar; @ISA = qw( Buz );
     sub google { print "google here\n" }

     package Baz;
     sub mumble { print "mumbling\n" }

     package Foo;
     @ISA = qw( Bar Baz );
     @Foo::Inherit::ISA = @ISA;  # オーバライドされたメソッドのアクセス

     sub new { bless [] }
     sub grr { print "grumble\n" }
     sub goo {
             my $self = shift;
             $self->Foo::Inherit::goo();
     }
     sub mumble {
             my $self = shift;
             $self->Foo::Inherit::mumble();
     }
     sub google {
             my $self = shift;
             $self->Foo::Inherit::google();
     }

     package main;

     $foo = new Foo;
     $foo->mumble;
     $foo->grr;
     $foo->goo;
     $foo->google;





File: perl-ja.info, Node: SDBM を伴う関係の使用, Next: コード再利用の考慮, Prev: スーパークラスのメソッドのオーバライド, Up: オブジェクト指向の仕組みと例

SDBM を伴う関係の使用
=====================

この例は、`SDBM' クラスのためのインタフェースを示します。これは、
`SDBM' クラスと新しいクラス `Mydbm' との間の「使用」関係を作ります。

     use SDBM_File;
     use POSIX;

     package Mydbm;

     sub TIEHASH {
         my $self = shift;
         my $ref  = SDBM_File->new(@_);
         bless {'dbm' => $ref};
     }
     sub FETCH {
         my $self = shift;
         my $ref  = $self->{'dbm'};
         $ref->FETCH(@_);
     }
     sub STORE {
         my $self = shift;
         if (defined $_[0]){
             my $ref = $self->{'dbm'};
             $ref->STORE(@_);
         } else {
             die "Cannot STORE an undefined key in Mydbm\n";
         }
     }

     package main;

     tie %foo, Mydbm, "Sdbm", O_RDWR|O_CREAT, 0640;
     $foo{'bar'} = 123;
     print "foo-bar = $foo{'bar'}\n";

     tie %bar, Mydbm, "Sdbm2", O_RDWR|O_CREAT, 0640;
     $bar{'Cathy'} = 456;
     print "bar-Cathy = $bar{'Cathy'}\n";





File: perl-ja.info, Node: コード再利用の考慮, Next: クラスコンテキストとオブジェクト, Prev: SDBM を伴う関係の使用, Up: オブジェクト指向の仕組みと例

コード再利用の考慮
==================

オブジェクト指向言語の 1 つの強みは、古いコードが新しいコードを使うこ
とが簡単にできるということです。次の例では、まずどのようなことがコード
の再利用を妨げるかを示して、それから、どのように再利用を推し進めるかを
示します。

最初の例は、「プライベートな」メソッド `BAZ()' をアクセスするために、
メソッドを呼び出すのにパッケージ名をすべて付けているクラスを示します。
次の例で、この `BAZ()' をオーバライドすることができないことを示します。

     package FOO;

     sub new { bless {} }
     sub bar {
             my $self = shift;
             $self->FOO::private::BAZ;
     }

     package FOO::private;

     sub BAZ {
             print "in BAZ\n";
     }

     package main;

     $a = FOO->new;
     $a->bar;

さて、`BAZ()' をオーバライドしてみましょう。`FOO::bar()' が 
`GOOP::BAZ()' を呼ぶようにしたいのですが、`FOO::bar()' では、明示的に 
`FOO::private::BAZ()' を呼んでいるため、これができません。

     package FOO;

     sub new { bless {} }
     sub bar {
             my $self = shift;
             $self->FOO::private::BAZ;
     }

     package FOO::private;

     sub BAZ {
             print "in BAZ\n";
     }

     package GOOP;
     @ISA = qw( FOO );
     sub new { bless {} }

     sub BAZ {
             print "in GOOP::BAZ\n";
     }

     package main;

     $a = GOOP->new;
     $a->bar;

再利用可能なコードを作るためには、クラス `FOO::private' の階層をなくし
て、クラス `FOO' を修正しなければなりません。次の例で、メソッド 
`FOO::BAZ()' の代わりに `GOOP::BAZ()' を呼べるようにする再利用可能なク
ラス `FOO' を示します。

     package FOO;

     sub new { bless {} }
     sub bar {
             my $self = shift;
             $self->BAZ;
     }

     sub BAZ {
             print "in BAZ\n";
     }

     package GOOP;
     @ISA = qw( FOO );

     sub new { bless {} }
     sub BAZ {
             print "in GOOP::BAZ\n";
     }

     package main;

     $a = GOOP->new;
     $a->bar;





File: perl-ja.info, Node: クラスコンテキストとオブジェクト, Prev: コード再利用の考慮, Up: オブジェクト指向の仕組みと例

クラスコンテキストとオブジェクト
================================

パッケージとクラスのコンテキストの問題を解決するために、オブジェクトを
使います。メソッドが必要とするものはすべて、オブジェクトを通じて利用す
るか、メソッドへの引数として渡すようにしなければなりません。

クラスには、メソッドが使用する静的なデータやグローバルなデータを用意す
ることがあります。サブクラスで、このデータを新しいデータでオーバライド
したいこともあるでしょう。このようなときに、サブクラスでは新しいデータ
を探す方法を知ることができません。

この問題は、メソッドのコンテキストを定義するために、オブジェクトを使う
ことで解決することができます。データへのリファレンスを探すために、メソッ
ドにオブジェクトを覗かせます。別解として、メソッドに追いかけさせ (「こ
れは、私のクラスのものか、それともサブクラスのものなのか。いったい、ど
のサブクラスのものか。」)るものですが、不便で、遺物のようなものにしか
ならないでしょう。メソッドに対して、オブジェクトにデータがどこにあるの
かを言わせればよいでしょう。

     package Bar;

     %fizzle = ( 'Password' => 'XYZZY' );

     sub new {
             my $self = {};
             $self->{'fizzle'} = \%fizzle;
             bless $self;
     }

     sub enter {
             my $self = shift;

             # %Bar::fizzle を使うべきか、%Foo::fizzle を
             # 使うべきかを考えてはいけません。オブジェ
             # クトの方でもう分かっていますから、単に尋く
             # だけです。
             #
             my $fizzle = $self->{'fizzle'};

             print "The word is ", $fizzle->{'Password'}, "\n";
     }

     package Foo;
     @ISA = qw( Bar );

     %fizzle = ( 'Password' => 'Rumple' );

     sub new {
             my $self = Bar->new;
             $self->{'fizzle'} = \%fizzle;
             bless $self;
     }

     package main;

     $a = Bar->new;
     $b = Foo->new;
     $a->enter;
     $b->enter;





File: perl-ja.info, Node: デバッグ, Next: 診断メッセージ, Prev: オブジェクト指向の仕組みと例, Up: Top

デバッグ
********

まず最初に、一言「もう `-w' スイッチはお使いになりましたか。」

Perl を `-d' スイッチを付けて起動すれば、スクリプトはデバッガ上で実行
されることになります。しかし、Perl デバッガは C での環境の様に独立した
プログラムではありません。その代わりに、`-d' フラグによって、コンパイ
ラがインタプリタに渡す擬似コードにソース情報を埋め込むようにしています。
(これは、ソースがデバッガ上で動作できるためには、正常にコンパイルでき
ないといけないということです。)それからインタプリタが起動され、デバッ
ガ自身を含む Perl ライブラリをロードします。プログラムは、最初の実行文
の直前で停止し (ただし、以下を参照)、以下に示す、いずれかのコマンドが
入力されるのを待ちます: *Note デバッガコマンド一覧::,

* Menu:

* デバッガコマンド一覧::
* カスタマイズ::
* デバッガのバグ::





File: perl-ja.info, Node: デバッガコマンド一覧, Next: カスタマイズ, Prev: デバッグ, Up: デバッグ

コマンド一覧
============

h
     ヘルプメッセージの表示。

T
     スタックトレース。サブルーティン内で @_ 引数におかしなことをして
     いる場合には、スタックのバックトレースで元の値が示されるとは限り
     ません。

s
     シングルステップ実行。別の実行文の先頭に到達するまで実行します。

n
     ネクスト。次の実行文の先頭に到達するまで、サブルーティンにまたがっ
     て実行します。

f
     フィニッシュ。現在のサブルーティンを終えるまで実行します。

c
     コンティニュー。次のブレイクポイントに到達するまで実行します。

c line
     指定行までのコンティニュー。1度きりのブレイクポイントを指定した行
     に設定する。

`<CR>'
     最後の `n' または `s' をリピートする。

l min+incr
     min から incr+1 行をリスト表示する。min を省略すると、最後に実行
     したリスト表示の終了か所から開始します。incr を省略すると前回の 
     incr が使われます。

l min-max
     指定した範囲をリスト表示する。

l line
     指定行をリスト表示する。

l
     次の1ウィンドウをリスト表示する。

-
     前の1ウィンドウをリスト表示する。

w line
     指定行付近のウィンドウ (数行以上のコード) をリスト表示する。

l subname
     サブルーティンのリスト表示。長いサブルーティンの場合には最初の部
     分だけが表示されます。続きを表示する場合には、`l' を使用してくだ
     さい。

/pattern/
     ソースコード上で、pattern を用いて正規表現による検索を行う。最後
     の / はなくてもかまいません。

?pattern?
     ソースコード上で、pattern を用いて正規表現による逆方向検索を行う。
     最後の ? はなくてもかまいません。

L
     ブレイクポイントまたはアクションをもつ行をリストアップする。

S
     すべてのサブルーティン名をリストアップする。

t
     トレースモードの on/off を切り替える (トグル)。

b line [ condition ]
     ブレイクポイントを設定する。line を省略するとまさに実行しようとし
     ている行に、ブレイクポイントを設定します。condition が指定される
     と、その文にさしかかる度に評価され、condition が真となったときに
     だけブレイクポイントが働きます。ブレイクポイントは、実行可能な文
     で始まる行にだけ、設定できます。condition には `if' を使いません:

          b 237 $x > 30
          b 33 /pattern/i

b subname [ condition ]
     サブルーティンの最初の実行可能文にブレイクポイントを設定します。

d line
     ブレイクポイントの削除。line が省略されると、まさに実行しようとし
     ている行のブレイクポイントを削除します。

D
     すべてのブレイクポイントの削除。

a line command
     line にアクションを設定する。複数行の command は、バックスラッシュ
     と改行で書くことができます。command は Perl コードであって、他の
     デバッガコマンドではありません。

A
     すべての行のアクションを削除します。

< command
     デバッガがプロンプトを出す直前に、毎回実行するアクションを設定し
     ます。複数行の command は、バックスラッシュと改行で書くことができ
     ます。

> command
     スクリプトの実行に戻るコマンドを入力した時に、デバッガがプロンプ
     トを出した後で、毎回実行するアクションを設定します。複数行の 
     command は、バックスラッシュと改行で書くことができます。

V package [ symbols ]
     package (デフォルトは `main') 内のすべて (または、一部) の変数 
     (variable) をデータプリティプリンタを使って表示する (ハッシュは何
     が何か解るように、key と value を表示し、コントロール文字は表示で
     きる形にします)。以下に示すように、symbol は名前だけを示し、($ な
     どの) 型識別子を付けないようにしてください:

          V DB filename line

X [ symbols ]
     `V' コマンドと同じだが、現在のパッケージについて、表示する。

! number
     デバッグコマンドを再実行する。number が省略されると、直前のコマン
     ドを実行する。

! -number
     指定数値分前のコマンドを実行する。

H -number
     最近の指定数値分のコマンドを表示する。2文字以上のコマンドのみが表
     示されます。number が省略されると、全てを表示します。

q
^D
     クイット。(`quit' はこの目的には使えません。)

command
     command を Perl の文として実行します。セミコロンはなくてもかまい
     ません。

p expr
     `print DB::OUT expr' と同じ。STDOUT がどこにリダイレクトされてい
     ても、ファイルハンドル `DB::OUT'は、`/dev/tty' に対してオープンさ
     れています。

デバッガが認識できないコマンドを入力すると、Perl のコードとして、直接 
`eval' されます。先頭にスペースを入れると、デバッガは、デバッガコマン
ドと認識しません。

コンパイル時に実行されるコマンド (BEGIN ブロック内のコードやuse 文) が
あれば、それらはデバッガによって止めることができません (`require' は可
能)。しかし、以下のような文を自分でコードに含めれば、デバッガに制御を
渡すことができます。この文は、デバッガを起動していないときには、何もし
ません:

     $DB::single = 1;





File: perl-ja.info, Node: カスタマイズ, Next: デバッガのバグ, Prev: デバッガコマンド一覧, Up: デバッグ

カスタマイズ
============

デバッガを変更したい場合には、`perl5db.pl' を Perl ライブラリから別の
名前にコピーし、必要に応じて修正してください。また、環境変数 PERL5DB 
には、以下のように設定する必要があるでしょう:

     BEGIN { require "myperl5db.pl" }

初期化コードを入れたファイル `.perldb' を設定することでも、いくらかの
カスタマイズができます。たとえば、以下のようなエイリアスが行えます (特
に最後のものは、多くの人が使うでしょう):

     $DB::alias{'len'} = 's/^len(.*)/p length($1)/';
     $DB::alias{'stop'} = 's/^stop (at|in)/b/';
     $DB::alias{'.'} = 's/^\./p '
                     . '"\$DB::sub(\$DB::filename:\$DB::line):\t"'
                     . ',\$DB::dbline[\$DB::line]/' ;





File: perl-ja.info, Node: デバッガのバグ, Prev: カスタマイズ, Up: デバッグ

デバッガのバグ
==============

プログラムで `exit()' や `die()' を行なう場合には、デバッガも終わりま
す。

1度終了して、再起動する以外に、デバッガを再実行する組み込みのしくみは
用意されていません。以下のようなエイリアスを行なうことができます:

     $DB::alias{'rerun'} = 'exec "perl -d $DB::filename"';

しかし、設定中のブレイクポイント情報は失われますし、正しいパスでない可
能性がある、といったことに注意しなくてはなりません。





File: perl-ja.info, Node: 診断メッセージ, Next: フォーマット文, Prev: デバッグ, Up: Top

診断メッセージ
**************

これらのメッセージは以下のように分類されます (重要度が増す順に並べてあ
ります):

   (W) 警告 (オプショナル)
   (D) A deprecation (オプショナル)
   (S) 重い警告 (必須)
   (F) 致命的エラー (トラップ可能)
   (P) 起こるはずのない内部エラー (トラップ可能)
   (X) 重大致命的エラー (トラップ不可能)

オプショナルな警告は、`-w' スイッチを使うことで現れます。トラップ可能
なエラーは、`eval' 演算子を使うことで、トラップすることができます。
*Note 組み込み関数::,の `eval' の項を参照してください。

いくつかのメッセージは、汎用的なものです。可変の部分は、ちょうど 
printf のフォーマットのように %s で表わしています。%s! で始まるメッセー
ジもいくつかありますので、注意が必要です。"%-?@ といったシンボルは、英
字より前に並べられ、[ と \ は、後に並べられています。

"my" variable %s can't be in a package
     (F) 字句スコープの変数は、パッケージ内に置かれませんので、頭にパッ
     ケージ名を付けて宣言することは、無意味です。パッケージ変数をロー
     カル化したい場合には、`local()' を使ってください。

"no" not allowed in expression
     (F) `no' キーワードは、コンパイル時に認識され、実行されるもので、
     意味のある値を返しません。*Note モジュール::,を参照してください。

"use" not allowed in expression
     (F) `use' キーワードは、コンパイル時に認識され、実行されるもので、
     意味のある値を返しません。*Note モジュール::,を参照してください。

% may only be used in unpack
     (F) チェックサムを指定して `pack' を行なうことはできません。チェッ
     クサム処理では、情報が失われ、どうしようもなくなるからです。*Note 
     組み込み関数::,の `unpack' の項を参照してください。

%s (...) interpreted as function
     (W) リスト演算子の直後に括弧を置くと、括弧内にあるリスト演算子引
     数を持つ関数になる、という規則が適用されました。*Note 演算子と優
     先順位::,の「*Note 項とリスト演算子 (左方向)::,」の節を参照してく
     ださい。

%s argument is not a HASH element
     (F) `delete()' や `exists()' の引数は、

          $foo{$bar}
          $ref->[12]->{"susie"}

     のようなハッシュの要素でなければなりません。

%s did not return a true value
     (F) `require' (や `use') されたファイルは、正常にコンパイルされ、
     初期化コードを正しく実行したことを示すために、真を返さなければな
     りません。こういったファイルは、"1;" で終わるようにするのが習慣で
     すが、真となる値であれば、何でもかまいません。`組み込み関数'の 
     `require' の項を参照してください。

%s found where operator expected
     (S) Perl の字句解析部は、次に項が来るか、演算子が来るかを知ってい
     ます。次に演算子が来ると思っているときに、項であるとわかるものが
     現れると、この警告が出ることになります。通常、演算子かセミコロン
     のような区切り文字が省略されたことをしめします。

%s had compilation errors.
     (F) `perl -c' が失敗したときの最終まとめメッセージです。

%s has too many errors.
     (F) 構文解析部が、プログラム中に 10 個のエラーを見つけたため、そ
     れ以上の解析を諦めました。それ以上のメッセージは、おそらく意味が
     ないでしょう。

%s matches null string many times
     (W) 指定したパターンは、もし、正規表現エンジンがチェックを行なっ
     ていなければ、無限ループに陥るものです。*Note 正規表現::,を参照し
     てください。

%s never introduced
     (S) 問題のシンボルは、宣言されましたが、使われる前にスコープから
     外れてしまいました。

%s syntax OK
     (F) `perl -c' が成功したときの最終まとめメッセージです。

-P not allowed for setuid/setgid script
     (F) C プリプロセッサがスクリプトをオープンするときには、名前でオー
     プンしなければいけませんが、これは、安全性を損なう競合条件をもた
     らします。

-T and -B not implemented on filehandles
     (F) Perl が、お使いの `stdio' のことをよく知らないとき、ファイル
     ハンドルの `stdio' バッファを覗くことはできません。代わりにファイ
     ル名を使わなければなりません。

?+* follows nothing in regexp
     (F) 正規表現を、数量子で始めてしまいました。その文字自体を表現し
     たいのであれば、バックスラッシュを付けてください。*Note 正規表現::,
     を参照してください。

@ outside of string
     (F) `unpack' される文字列の外に絶対位置指定している、テンプレート
     を指定しました。*Note 組み込み関数::,の `pack' の項を参照してくだ
     さい。

accept() on closed fd
     (W) クローズされたソケットに `accept' を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたのではありませ
     んか。*Note 組み込み関数::,の `accept' の項を参照してください。

Allocation too large: %lx
     (F) MS-DOS マシンでは、64K を越えるメモリアロケートをおこなえませ
     ん。

Arg too short for msgsnd
     (F) `msgsnd()' に渡す文字列は、少なくとも sizeof(long) の長さが必
     要です。

Args must match #! line
     (F) setuid エミュレータでは、Perl を起動したときの引数と、#! の行
     で指定された引数はマッチすることが要求されます。

Argument "%s" isn't numeric
     (W) ここに示した文字列は、数値が必要な演算子の引数として、与えら
     れました。運がよければ、このメッセージによって、どの演算子が問題
     となったかがわかります。

Array @%s missing the @ in argument %d of %s()
     (D) 本当に古い Perl では、場所によっては、配列名の @ を省略できま
     した。この省略は、止めてください。

assertion botched: %s
     (P) Perl に付属の malloc ルーティンが内部エラーを起こした。

Assertion failed: file "%s"
     (P) 一般的なアサーションが失敗しました。問題の file を調べる必要
     があります。

Assignment to both a list and a scalar
     (F) 条件演算子へ代入を行なう場合には、2 つめの引数と、3つめの引数
     は、ともにスカラか、ともにリストでなければなりません。そうでない
     と、Perl は右辺のコンテキストを決めることができません。

Attempt to free non-arena SV: 0x%lx
     (P) すべての `SV' オブジェクトは、`exit' 時にガーベジコレクション
     が行なわれるアリーナに割り当てるようになっています。ある `SV' が、
     そういったアリーナに入っていないことが、見つかりました。

Attempt to free temp prematurely
     (W) 消滅する値は、`free_tmps()' ルーティンで解放されるようになっ
     ています。このメッセージは、`free_tmps()' ルーティンの前に何もの
     かが、`SV' を解放しようとしていることを示していて、これは、
     `free_tmps()' が解放しようとしたときには、どこからも参照されてい
     ないスカラを解放することになるということです。

Attempt to free unreferenced glob pointers
     (P) シンボルのエイリアスについて、参照カウントの値がおかしな状態
     になった。

Attempt to free unreferenced scalar
     (W) Perl がスカラの参照カウントをデクリメントしようとして、0 にな
     るかを見たところ、既に 0 になっていることがわかりました。これは、
     既に解放されているべきものであり、実際は、おそらく、解放されたも
     のでしょう。これは、`SvREFCNT_dec()' が必要以上に呼ばれたか、
     `SvREFCNT_inc()' が必要なときに呼ばれなかったか、`SV' が消滅すべ
     きで無いときに消滅してしまったか、メモリ異常になったことが考えら
     れます。

Bad arg length for %s, is %d, should be %d
     (F) `msgctl()'、`semctl()'、`shmctl()' のいずれかに、間違ったサイ
     ズのバッファを渡してしまいました。C の言い方で書くと、正しいサイ
     ズはそれぞれ、`sizeof(struct msqid_ds *)'、`sizeof(struct
     semid_ds *)'、`sizeof(struct shmid_ds *)' です。

Bad associative array
     (P) 内部ハッシュルーティンで、ヌル `HV' ポインタを渡されたものが
     あった。

Bad filehandle: %s
     (F) ファイルハンドルが必要なものに、シンボルを渡しましたが、その
     シンボルは、それに伴うファイルハンドルがありません。おそらく、
     `open()' を忘れたか、別のパッケージで `open()'したかでしょう。

Bad free() ignored
     (S) まず、`malloc()' されていないものに対して、内部ルーティンが 
     `free()' を呼びました。

Bad name after %s::
     (F) パッケージプレフィクスでシンボル名を書き始めましたが、そのシ
     ンボルが終了しませんでした。特に、クォートの外で、変数展開はでき
     ませんから、

          $var = 'myvar';
          $sym = mypack::$var;

     は、

          $var = 'myvar';
          $sym = "mypack::$var";

     と同じではありません。

Bad symbol for array
     (P) シンボルテーブルエントリではないものに、配列エントリを登録す
     るような内部要求があがった。

Bad symbol for filehandle
     (P) シンボルテーブルエントリではないものに、ファイルハンドルエン
     トリを登録するような内部要求があがった。

Bad symbol for hash
     (P) シンボルテーブルエントリではないものに、ハッシュエントリを登
     録するような内部要求があがった。

BEGIN failed--compilation aborted
     (F) BEGIN サブルーティンの実行中にトラップ不可能な例外が発生しま
     した。コンパイルは、即座に停止し、インタプリタは中止します。

bind() on closed fd
     (W) クローズされたソケットに `bind' を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたのではありませ
     んか。*Note 組み込み関数::,の `bind' の項を参照してください。

Callback called exit
     (F) 外部パッケージから `perl_call_sv()' で起動されたサブルーティ
     ンが `exit' を呼んで終了しました。

Can't "last" outside a block
     (F) 現在のブロックから脱出するために、`last' 文を実行しましたが、
     残念なことにブロックの中ではありませんでした。`if' や `else' のブ
     ロックは、「ループ風」ブロックではないので、勘違いしないでくださ
     い。ただし、中括弧を二重にすれば、内側の中括弧が、1 度だけループ
     するブロックとみなされますから、同じ効果が得られます。*Note 組み
     込み関数::, の `last' の項を参照してください。

Can't "next" outside a block
     (F) 現在のブロックの繰り返しを進めるために、`next' 文を実行しまし
     たが、ブロックの中ではありませんでした。`if' や `else' のブロック
     は、「ループ風」ブロックではないので、勘違いしないでください。た
     だし、中括弧を二重にすれば、内側の中括弧が、1 度だけループするブ
     ロックとみなされますから、同じ効果が得られます。*Note 組み込み関
     数::,の `next' の項を参照してください。

Can't "redo" outside a block
     (F) 現在のブロックの繰り返しをもう一度行なうために、`redo' 文を実
     行しましたが、ブロックの中ではありませんでした。`if' や `else' の
     ブロックは、「ループ風」ブロックではないので、勘違いしないでくだ
     さい。ただし、中括弧を二重にすれば、内側の中括弧が、1 度だけルー
     プするブロックとみなされますから、同じ効果が得られます。*Note 組
     み込み関数::,の `redo' の項を参照してください。

Can't bless non-reference value
     (F) ハードリファレンスのみが bless できます。これによって、Perl 
     はオブジェクトのカプセル化を「強制」します。*Note オブジェクト::,
     を参照してください。

Can't break at that line
     (S) デバッガで実行中に出力される警告で、指定された行番号は、停止
     可能な実行文の場所ではないことを示しています。

Can't call method "%s" in empty package "%s"
     (F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケー
     ジを正しく示していますが、そのパッケージには、何も定義されておら
     ず、メソッドだけになっています。*Note オブジェクト::,を参照してく
     ださい。

Can't call method "%s" on unblessed reference
     (F) メソッド呼び出しは、自分が呼び出されたパッケージがどれである
     かを知る必要があります。普通は、渡したオブジェクトリファレンスか
     らその情報を受け取りますが、この場合にはオブジェクトリファレンス
     が渡されませんでした。リファレンスは、`bless' されて始めて、オブ
     ジェクトリファレンスとなります。*Note オブジェクト::,を参照してく
     ださい。

Can't call method "%s" without a package or object reference
     (F) メソッド呼び出しの構文を用いましたが、オブジェクトリファレン
     ス、もしくはパッケージ名が書かれるべき場所に、オブジェクトリファ
     レンスもパッケージ名も返さない式が書かれています。(おそらく、何も
     書いてないかもしれません。)以下のようなものは、エラーとなります:

          $BADREF = undef;
          process $BADREF 1,2,3;
          $BADREF->process(1,2,3);

Can't chdir to %s
     (F) `perl -x/foo/bar' のようにして起動したが、`/foo/bar' に
     `chdir' することができません。おそらく、存在しないのでは、ないで
     しょうか。

Can't coerce %s to integer in %s
     (F) ある種の `SV'、特に本物のシンボルテーブルエントリ (型グロブ) 
     は、1つの型に留めておくことができません。したがって、

          *foo += 1;

     とすることはできません。

          $foo = *foo;
          $foo += 1;

     とすることはできますが、`$foo' にはもはやグロブは残っていません。

Can't coerce %s to number in %s
     (F) ある種の `SV'、特に本物のシンボルテーブルエントリ (型グロブ) 
     は、1つの型に留めておくことができません。

Can't coerce %s to string in %s
     (F) ある種の `SV'、特に本物のシンボルテーブルエントリ (型グロブ) 
     は、1 つの型に留めておくことができません。

Can't create pipe mailbox
     (F) VMS 特有のエラーです。

Can't declare %s in my
     (F) スカラ変数、配列変数、ハッシュ変数だけが、字句スコープの変数
     として宣言できます。これらは、名前として通常の識別子を持たなけれ
     ばなりません。

Can't do inplace edit on %s: %s
     (S) 表示された理由により、新しいファイルの生成に失敗しました。

Can't do inplace edit without backup
     (F) 削除した (が、まだオープンされている) ファイルを読もうとする
     とおかしくなる MS-DOS のようなシステムで実行しています。`-i.bak' 
     のようにバックアップを指定してください。

Can't do inplace edit: %s > 14 characters
     (S) そのファイルのバックアップ名を作ると、ファイル名の長さの制限
     をオーバしてしまいます。

Can't do inplace edit: %s is not a regular file
     (S) `/dev' や FIFO のような、特殊ファイルに対して、`-i' スイッチ
     を使おうとしました。そのファイルは、無視されました。

Can't do setegid!
     (P) suidperl の setuid エミュレータで何らかの理由により、
     `setegid()' 呼び出しが失敗しました。

Can't do seteuid!
     (P) suidperl の setuid エミュレータが何らかの理由によって失敗しま
     した。

Can't do setuid
     (F) このエラーは、通常、普通の perl が setuid エミュレーションの
     ために suidperl を実行しようとしましたが、実行できなかったことを
     意味します。特に UNIX マシンの`/usr/local/bin' などでは、perl の
     実行ファイルが、perl5.000 という名前のときには、同じディレクトリ
     で sperl5.000 という形式の名前を探します。もし、ファイルが存在し
     ていれば、実行パーミッションをチェックしてください。許可されてい
     ないようであれば、システム管理者の方に、わけを尋ねてみてください。

Can't do waitpid with flags
     (F) このマシンには、`waitpid()' も `wait4()' もありませんので、フ
     ラグの無い `waitpid()' のみがエミュレート可能です。

Can't do {n,m} with n > m
     (F) 最小値は最大値以下でなければなりません。もし、本当に正規表現
     が0回繰り返したものにマッチさせたいなら、単に {0} としてください。
     *Note 正規表現::,を参照してください。

Can't emulate -%s on #! line
     (F) #! 行にその時点で意味をなさないスイッチが指定されました。たと
     えば、#! 行に `-x' をおいても意味がありません。

Can't exec "%s": %s
     (W) 提示した理由によって、`system()' や `exec()' やパイプオープン
     呼び出しの指定されたプログラムが実行できませんでした。考えられる
     理由には: ファイルのパーミッションが間違っている、ファイルが 
     $ENV{PATH} の中にない、問題の実行ファイルがこのマシン用ではない、
     スクリプトの #! 行が同じような理由で実行できないインタプリタを指
     している、というようなものがあります。(あるいは、このシステムで、
     #! がサポートされていなません。)

Can't exec %s
     (F) #! 行に書かれた内容にしたがって、Perl は示されたプログラムを
     実行しようとしました。そうしたくないのであれば、#! 行のどこかに、
     "perl" と書いておいてください。

Can't execute %s
     (F) `-S' スイッチを使いましたが、実行するスクリプトが PATH の中に
     見つかりませんでした。少なくとも、正しいパーミッションではないと
     思われます。

Can't find label %s
     (F) どこにも見つからないラベルへ `goto' を行なおうとしました。
     *Note 組み込み関数::,の `goto' の項を参照してください。

Can't find string terminator %s anywhere before EOF
     (F) Perl の文字列は、複数行に渡ることができます。このメッセージは、
     文字列を終わる区切り文字が見つからなかったことを意味します。括弧
     類の区切り文字では、ネストを数えるので、

          print q(The character '(' starts a side comment.)

     では、最後の括弧が無いと言われます。

Can't fork
     (F) パイプラインをオープンしようとして、`fork' を行なおうとして、
     致命的エラーが発生しました。

Can't get pipe mailbox device name
     (F) VMS 特有のエラーです。

Can't get SYSGEN parameter value for MAXBUF
     (F) VMS 特有のエラーです。

Can't goto subroutine outside a subroutine
     (F) 結構マジカルな "goto subroutine" の呼び出しは、あるサブルーティ
     ン呼び出しを別のもので置き換えるだけです。反物の状態から作り上げ
     ることはできません。一般に、これを行なうのは、AUTOLOAD ルーティン
     から抜け出すときだけにしておくべきです。*Note 組み込み関数::,の 
     `goto' の項を参照してください。

Can't locate %s in @INC
     (F) ファイルを `do' (または、`require'、`use') するように指示され
     ましたが、@INC で示されるライブラリの中に見つかりませんでした。お
     そらく、追加ライブラリの場所を示すために、PERL5LIB 環境変数を指定
     する必要があるか、スクリプトの中で @INC にライブラリ名を追加する
     必要があります。ファイル名のスペルミスの可能性もあります。*Note 
     組み込み関数::, の `require' の項を参照してください。

Can't locate object method "%s" via package "%s"
     (F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケー
     ジを正しく示していますが、そのパッケージにも、基底クラスにも、該
     当のメソッドが定義されていません。*Note オブジェクト::,を参照して
     ください。

Can't locate package %s for @%s::ISA
     (W) 配列 @ISA に別のパッケージ名が記されていますが、存在していな
     いようです。

Can't mktemp()
     (F) `-e' スイッチを処理しようとして、何らかの理由により、mktemp() 
     ルーティンがうまく行きませんでした。/tmp パーティションがいっぱい
     か、壊れている可能性があります。

Can't modify %s in %s
     (F) 指定されたものは、代入、インクリメントなど、変更が許されてい
     ません。

Can't modify non-existent substring
     (P) substr() への代入を行なう内部ルーティンに NULL が渡されました。

Can't msgrcv to readonly var
     (F) msgrcv で使用する変数は、受信バッファとして使用しますので、変
     更可能なものでなければなりません。

Can't open %s: %s
     (S) 置き換え編集で、表示した理由によって、元のファイルがオープン
     できませんでした。通常、これはそのファイルのリード権が無いときに
     起こります。

Can't open bidirectional pipe
     (W) サポートされていない `open(CMD, "|cmd|")' を行なおうとしまし
     た。これを行なうためには、Perl ライブラリの`open2.pl' のようない
     くつかのモジュールを使うことができます。別の方法として、パイプさ
     れたものを ">" を使っていったんファイルに出力し、あとで別のファイ
     ルハンドルで読み込みを行なうことも考えられます。

Can't open perl script "%s": %s
     (F) 指定したスクリプトが、表示した理由によってオープンできません
     でした。

Can't rename %s to %s: %s, skipping file
     (S) `-i' スイッチで行なわれた rename が何らかの理由によって、うま
     く行きませんでした。ディレクトリに書き込み権がないことも考えられ
     ます。

Can't reswap uid and euid
     (P) suidperl の setuid エミュレータで何らかの理由により、
     setreuid() 呼び出しが失敗しました。

Can't return outside a subroutine
     (F) `return' 文が、`return' で抜けるべきサブルーティンがない、
     "main" コードで実行されました。{サブルーティン}を参照してください。

Can't stat script "%s"
     (P) 何らかの理由で、例え既にオープンしていたとしても、`fstat()' 
     が行なえません。困ったもんだ。

Can't swap uid and euid
     (P) suidperl の setuid エミュレータで何らかの理由により、
     setreuid() 呼び出しが失敗しました。

Can't take log of %g
     (F) 対数は、正の実数に対してのみ定義されています。

Can't take sqrt of %g
     (F) 通常の実数では、負数の平方根をとることはできません。しかし、
     本当にその計算を行ないたいのであれば、`Complex' パッケージが Perl 
     に用意されています。

Can't undef active subroutine
     (F) 実行中のルーティンを未定義にすることはできません。しかし、実
     行中に再定義することはでき、古いルーティンを実行中に、再定義した
     サブルーティンを `undef' することさえできます。Go figure。

Can't unshift
     (F) Perl のメインスタックのように、`unshift' することのできない
     「実在しない」配列に対して、`unshift' を行なおうとしました。

Can't upgrade that kind of scalar
     (P) 内部の sv_upgrade ルーティンは、`SV' に「メンバ」を加えて、よ
     り特別な種類の `SV' にします。しかし、上位のいくつかの `SV' 型は、
     特殊化され過ぎて、内部変換することができません。このメッセージは、
     そのような変更を行なおうとしたことを示しています。

Can't upgrade to undef
     (P) 未定義 `SV' は、upgrade の仕組みにおいて、階層構造の最下位に
     位置するものです。`undef' への upgrade は、sv_upgrade を呼ぶコー
     ドのエラーを示します。

Can't use %s as left arg of an implicit ->
     (F) コンパイラが、配列リファレンスへの添え字として、大括弧で括っ
     た式を解釈しようとしました。大括弧の左が、アロー (->) で終わって
     いない式であったり、添え字付けされた式になっています。複数の添え
     字を持つ、添え字付けされた式だけが、間のアローを省略できます。

Can't use %s for loop variable
     (F) 単純スカラ変数だけが、`foreach' のループ変数として使用するこ
     とができます。

Can't use %s ref as %s ref
     (F) リファレンス型を混同しています。必要な型のリファレンスを被参
     照しなければなりません。必要ならば、リファレンスの型を調べるのに、
     `ref()' 関数を使うことができます。

Can't use a string as %s ref while "strict refs" in use
     (F) `strict refs' では、ハードリファレンスだけが許されます。シン
     ボリックリファレンスは、許されていません。*Note リファレンスとデー
     タ構造のネスト::,を参照してください。

Can't use an undefined value as %s reference
     (F) ハードリファレンスやシンボリックリファレンスとして使用する値
     は、定義済みの値でなければなりません。潜伏中のエラーを引きずり出
     す助けとなります。

Can't use delimiter brackets within expression
     (F) ${name} という用法は、文字列で識別子の曖昧さを取り除くための
     もので、通常のコードの中では使えません。

Can't use global %s in "my"
     (F) マジカル変数を、字句スコープ変数として宣言しようとしました。
     これが許されていないのは、マジック変数は1か所だけにおくことができ
     る (つまりグローバル変数) からであり、マジカル変数に見えながら、
     そうでないものがプログラム中に現われると混乱の元となるためです。

Can't write to temp file for -e: %s
     (F) `-e' スイッチを処理しようとして、何らかの理由により、書き込み
     ルーティンがうまく行きませんでした。`/tmp' パーティションがいっぱ
     いか、壊れている可能性があります。

Can't x= to readonly value
     (F) 定数値 (未定義値であることが多い) を、自らを書き換えることを
     意味する、代入演算子で繰り返しを行なおうとしました。テンポラリ変
     数に値を移してから、繰り返すと良いでしょう。

Cannot open temporary file
     (F) `-e' スイッチを処理しようとして、何らかの理由により、ファイル
     生成ルーティンがうまく行きませんでした。`/tmp' パーティションがいっ
     ぱいか、壊れている可能性があります。

chmod: mode argument is missing initial 0
     (W) 初心者の方は、

          chmod 777, $filename

     というふうに、777 が 01411 に等しい 10 進数であることに気付かない
     で使うことがあります。Perl では、8 進数の定数は、C と同じように、
     先頭に 0 を付けて表わします。

Close on unopened file <%s>
     (W) オープンされていないファイルハンドルをクローズしようとしまし
     た。

connect() on closed fd
     (W) クローズされたソケットに `connent' を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたたのではありま
     せんか。*Note 組み込み関数::,の `connect' の項を参照してください。

Corrupt malloc ptr 0x%lx at 0x%lx
     (P) Perl に付属の malloc ルーティンが内部エラーを起こした。

corrupted regexp pointers
     (P) 正規表現コンパイラが渡したもので、正規表現エンジンが処理でき
     なくなった。

corrupted regexp program
     (P) 正規表現エンジンが、有効なマジックナンバーを持たないregexp プ
     ログラムを渡しました。

Deep recursion on subroutine "%s"
     (W) このサブルーティンは、(直接、間接に) 自分自身の呼び出しを、
     `return' より100回多く行ないました。変わったベンチマークプログラ
     ムを書いているのでなければ、無限再帰の可能性があります。ベンチマー
     クを書いている場合には、別のことを示しています。

Did you mean $ instead of %?
     (W) `$hash{$key}' のつもりで `%hash{$key}' と書いたと思われます。

Don't know how to handle magic of type '%s'
     (P) マジック変数の内部処理がおかしくなっています。

do_study: out of memory
     (P) これは、本来 safemalloc() で、引っ掛かるはずのものです。

Duplicate free() ignored
     (S) 既に解放されているものに対して、内部ルーティンが、`free()' を
     行なおうとしました。

END failed--cleanup aborted
     (F) END サブルーティンを実行中に、トラップできない例外が発生しま
     した。インタプリタは、即座に実行を中止します。

Execution of %s aborted due to compilation errors.
     (F) Perl のコンパイルが失敗したときの、最後のまとめメッセージです。

Exiting eval via %s
     (W) `goto' やループ制御文など、おかしな方法で `eval' を抜けました。

Exiting subroutine via %s
     (W) `goto' やループ制御文など、おかしな方法でサブルーティンを抜け
     ました。

Exiting substitution via %s
     (W) `return' や `goto' やループ制御文など、おかしな方法で置換を抜
     けました。

Fatal $PUTMSG error: %d
     (F) VMS 特有のエラーです。

fcntl is not implemented
     (F) このマシんでは、fcntl() がインプリメントされていないように見
     えます。PDP-11 か何かでしょうか。

Filehandle %s never opened
     (W) 初期化していないファイルハンドルに対して、I/O 操作を行なおう
     としました。`open()' や `socket()'、`FileHandle' パッケージのコン
     ストラクタを呼び出す必要があります。

Filehandle %s opened only for input
     (W) リードオンリーのファイルハンドルに対して、書込みを行なおうと
     しました。読み書き両用ファイルハンドルにしたいのであれば、"<" を
     付けたり、何も付けなかったりするのではなく、"+<" や "+>" や "+>>" 
     を付けて `open' する必要があります。ライトオンリーであれば、">" 
     や ">>" を使ってください。*Note 組み込み関数::,の `open' の項を参
     照してください。

Filehandle only opened for input
     (W) リードオンリーのファイルハンドルに対して、書込みを行なおうと
     しました。読み書き両用ファイルハンドルにしたいのであれば、"<" を
     付けたり、何も付けなかったりするのではなく、"+<" や "+>" や "+>>" 
     を付けて `open' する必要があります。ライトオンリーであれば、">" 
     や ">>" を使ってください。*Note 組み込み関数::,の `open' の項を参
     照してください。

Final $ should be \$ or $name
     (F) 文字列の最後の $ が、リテラルのドル記号なのか、変数名を入れよ
     うとして忘れたのかを、はっきりさせなければなりません。バックスラッ
     シュを付けるか、名前を入れてください。

Final @ should be \@ or @name
     (F) 文字列の最後の @ が、リテラルのアットマークなのか、変数名を入
     れようとして忘れたのかを、はっきりさせなければなりません。バック
     スラッシュを付けるか、名前を入れてください。

Format %s redefined
     (W) フォーマットを再定義しました。この警告を止めるには、

          {
              local $^W = 0;
              eval "format NAME =...";
          }

     としてください。

Format not terminated
     (F) フォーマットは、単独のドットだけからなる行で終わらなければな
     りません。そのような行が見つからないまま、スクリプトの最後に行き
     当たってしまいました。

Found = in conditional, should be ==
     (W) おそらく、

          if ($foo == 123)

     とすべきところを

          if ($foo = 123)

     としています (あるいは似たようなこと)。

gdbm store returned %d, errno %d, key "%s"
     (S) `GDBM_File' 拡張モジュールが、値の設定に失敗したという警告で
     す。

gethostent not implemented
     (F) C ライブラリに gethostent() がインプリメントされていないよう
     です。おそらく、インプリメントすると Internet 上のすべてのホスト
     名を返さなければいけないと思っているのでしょう。

get{sock,peer}name() on closed fd
     (W) クローズされたソケットに、`get{sock,peer}name()' を行なおうと
     しました。`socket()' の呼び出し時に、返却値のチェックを忘れたので
     はありませんか。

Glob not terminated
     (F) 項が必要とされるところで、開き山括弧が見つけたため、対応する
     閉じ山括弧を探しましたが、見つかりませんでした。可能性としては、
     必要な括弧を省いてしまい、本当は、「小なり記号」を表したかった場
     合が考えられます。

Global symbol "%s" requires explicit package name
     (F) `use strict vars' が指定されていますので、すべての変数は、
     (`my' を使った) 字句スコープの変数か、グローバル変数がどのパッケー
     ジのものかを ("::" を使って)、明示的に修飾しなくてはなりません。

goto must have label
     (F) `next' や `last' とは違って、`goto' には必ず、飛び先を指定し
     なくてはなりません。*Note 組み込み関数::,の `goto' の項を参照して
     ください。

Had to create %s unexpectedly
     (S) あるルーティンが、既に存在しているはずのシンボルを、シンボル
     テーブルで探しましたが、何らかの理由で存在せず、コアダンプを避け
     るために、緊急に生成しました。

Hash %%s missing the % in argument %d of %s()
     (D) 古い Perl では、ハッシュ名の % を省略できる場所がありました。
     省略はしないようにしてください。

Identifier "%s::%s" used only once: possible typo
     (W) タイプミスは、多くの場合に、その識別子が1度しか現れないことで
     発覚します。何か理由があって、その識別子を1度しか使っていないので
     あれば、単にどこかでその識別子を書いておくだけでこのメッセージは
     止められます。

Illegal division by zero
     (F) ゼロで割り算をしようとしました。ロジックの誤りか、意味の無い
     入力を防ぐために、条件を付けることが必要かのどちらかでしょう。

Illegal modulus zero
     (F) 余りを求めるのに、ゼロで割り算をしようとしました。これは、ほ
     とんどの数体系で受け入れられません。

Illegal octal digit
     (F) 8進数で8か9を使いました。

Insecure dependency in %s
     (F) 何か汚染チェックの機構が、望ましくないと判断することを行なお
     うとしました。setuid や setgid を実行したときや、明示的に `-T' で
     指定したときに、汚染チェック機構が働きます。汚染チェック機構は、
     信頼がおけないと仮定されるユーザが直接、間接を問わず、指定したデー
     タに印を付けます。そのようなデータを「危険な」操作に用いると、こ
     のエラーが発生します。詳しくは、*Note セキュリティ::,を参照してく
     ださい。

Insecure directory in %s
     (F) $ENV{PATH} の中に、誰にでも書き込みができるディレクトリが含ま
     れているとき、`system()'、`exec()'、パイプのオープンを行なうこと
     はできません。*Note セキュリティ::,を参照してください。

Insecure PATH
     (F) $ENV{PATH} の中に、ユーザが指定した (あるいはその可能性がある) 
     データから作られたものが含まれるとき、`system()'、`exec()'、パイ
     プのオープンを行なうことはできません。スクリプト内で、信頼できる
     データに基づいて、パスに既知の値を設定しなければなりません。*Note 
     セキュリティ::,を参照してください。

internal disaster in regexp
     (P) 正規表現解析部に何か悪いことが起こりました。

internal urp in regexp at /%s/
     (P) 正規表現解析部に何か間違ったことが起こりました。

invalid [] range in regexp
     (F) 文字クラスに指定した範囲の最小値が、最大値よりも大きくなって
     います。*Note 正規表現::,を参照してください。

ioctl is not implemented
     (F) C をサポートしているマシンではおかしなことだと思いますが、こ
     のマシンでは ioctl() がインプリメントされていないようです。

junk on end of regexp
     (P) 正規表現の構文解析ができなくなった。

Label not found for "last %s"
     (F) 脱出するループを指定しましたが、その名前のループの中にいませ
     ん、たとえ、呼び出された場所がそうであっても、今はそうではありま
     せん。*Note 組み込み関数::,の `last' の項を参照してください。

Label not found for "next %s"
     (F) 次の繰り返しを行なうループを指定しましたが、その名前のループ
     の中にいません。たとえ、呼び出された場所がそうであっても、今はそ
     うではありません。*Note 組み込み関数::, の `next' の項を参照して
     ください。

Label not found for "redo %s"
     (F) 繰り返しの再実行を行なうループを指定しましたが、その名前のルー
     プの中にいません。たとえ、呼び出された場所がそうであっても、今は
     そうではありません。*Note 組み込み関数::,の `redo' の項を参照して
     ください。

listen() on closed fd
     (W) クローズされたソケットに listen を行なおうとしました。
     `socket()' の呼び出し時に、返却値のチェックを忘れたのではありませ
     んか。*Note 組み込み関数::,の `listen' の項を参照してください。

Literal @%s now requires backslash
     (F) Perl は、配列を展開したいのか、リテラルの @ を使いたいのかを
     推察するようにしていました。これは、実行時に文字列が最初に使われ
     たときに、行なわれました。現在、文字列はコンパイル時に解析され、
     曖昧な @ は、リテラルであることを示すためにバックスラッシュを付け
     るか、プログラム内で (字面の上で) 文字列よりも前に、宣言 (あるい
     は、使用)することによって、配列であることを示さなければなりません。
     (そのうちに、バックスラッシュのない @ は、単純に配列と解釈するよ
     うになります。)

Method for operation %s not found in package %s during blessing
     (F) 多重定義テーブルで、有効なメソッドを指していないエントリを指
     定しようとしました。*Note 多重定義::,を参照してください。

Might be a runaway multi-line %s string starting on line %d
     (S) ようやく現在行になって、文字列やパターンの終わりが見つかった
     ことから、先のエラーが、文字列やパターンのデリミタが、見つからな
     かったことで起ったかもしれないことを、補足的に示しています。

Misplaced _ in number
     (W) 十進数定数で下線が、3桁ごとでありませんでした。

Missing $ on loop variable
     (F) csh を使いすぎた症状が現れているようです。Perl では、変数は常
     に $ を付けて表わされます。その時によって違う、シェルとは違ってい
     ます。

Missing comma after first argument to %s function
     (F) ある種の関数では、引数リストの前に、ファイルハンドルや「間接
     オブジェクト」をおくことができますが、この関数は、そういったもの
     ではありません。

Missing right bracket
     (F) 字句解析部が、閉じ中括弧よりも開き中括弧を多く発見しました。
     一般的な規則として、最後に修正した場所の近くに間違いがあるといえ
     ます。

Missing semicolon on previous line?
     (S) このメッセージは、"%s found where operator expected" というメッ
     セージに伴って出される経験的な想像によるものです。このメッセージ
     が出たからといって、機械的に前の行にセミコロンを付けることはしな
     いでください。

Modification of a read-only value attempted
     (F) 直接、間接に関らず、定数値を変更しようとしました。もちろん、
     コンパイラが発見できる、"2 = 1" などといったことをしたわけではあ
     りません。しかし、同じことは、

          sub mod { $_[0] = 1 }
          mod(2);

     としても起こります。`substr()' で、文字列の終わりよりも後ろに代入
     を行なうことでも起こります。

Modification of non-creatable array value attempted, subscript %d
     (F) 配列値を存在するようにしようとしました。おそらく、インデクス
     が負数で、配列の終わりから逆に数えたとしても、おかしな位置を指し
     ているようです。

Modification of non-creatable hash value attempted, subscript "%s"
     (F) ハッシュ値を存在するようにしようとしましたが、何か特別な理由
     で、できませんでした。

Module name must be constant
     (F) `use' の最初の引数としてモジュール名を示すのに許されているの
     は、裸の単語だけです。

msg%s not implemented
     (F) このシステムでは、System V メッセージ IPC は使えません。

Multidimensional syntax %s not supported
     (W) 多次元配列は、$foo[1,2,3] のようには書けません。これは、C の
     ように $foo[1][2][3] のように書きます。

Negative length
     (F) ゼロより短い長さのバッファで、読み込み、書き込み、送信、受信
     を行なおうとしました。どのようなことがしたいのか判断できません。

nested *?+ in regexp
     (F) 括弧を挟まないで、数量子を数量子で修飾することはできません。つまり、
     ** や +* や ?* といったものは、正しくありません。

     しかし、最短一致数量子の *?、+?、?? は、ネストした数量子のように
     見えますが、そうではありません。*Note 正規表現::,を参照してくださ
     い。

No #! line
     (F) setuid エミュレータでは、たとえマシンがサポートしていなくても、
     完全な形の #! 行がスクリプトに書かれていなければなりません。

No %s allowed while running setuid
     (F) ある種の操作は、setuid や setgid スクリプトにとって、やってみ
     ることはできても、とても安全なものとは考えられないものです。一般
     に言って、安全ではなくても、安全にしうる、別の方法があるはずです。
     *Note セキュリティ::, を参照してください。

No -e allowed in setuid scripts
     (F) setuid スクリプトは、ユーザによって指定することはできません。

No comma allowed after %s
     (F) ファイルハンドルや「間接オブジェクト」を伴うリスト演算子では、
     それらとそれ以降の引数の間にコンマを入れることはできません。その
     ようにした場合には、引数の一つとなってしまいます。

No DB::DB routine defined
     (F) 現在実行中のコードは、`-d' スイッチを付けてコンパイルされまし
     たが、何らかの理由により、perl5db.pl (あるいは、その複製) が各実
     行文の頭で呼び出すルーティンを定義していません。そのファイルは自
     動的に `require' されるものであり、正しく解釈できなければ、
     `require' が失敗するはずですので、これはとても有り得ない状態です。

No dbm on this machine
     (P) これは、内部エラーとして扱われます。Perl に `SDBM'が付いてく
     るので、どのマシンでも dbm が使えるはずだからです。*Note
     SDBM_File::,を参照してください。

No DBsub routine
     (F) 現在実行中のコードは、`-d' スイッチを付けてコンパイルされまし
     たが、何らかの理由により、`perl5db.pl' (あるいは、その複製) が各
     サブルーティン呼び出しの頭で呼び出す `DB::sub' ルーティンを定義し
     ていませんでした。

No Perl script found in input
     (F) `perl -x' を呼び出しましたが、そのファイルに #! で始まり、
     "perl" という語を含む行が見つかりませんでした。

No setregid available
     (F) Configure が、システム上に setregid() のような関数を見つけら
     れませんでした。

No setreuid available
     (F) Configure が、システム上に setreuid() のような関数を見つけら
     れませんでした。

No space allowed after -I
     (F) `-I' の引数は、`-I' の直後にスペースを空けないで書く必要があ
     ります。

No such signal: SIG%s
     (W) %SIG の添え字として認識できないシグナル名を指定しました。お使
     いのシステムで使用可能なシグナル名を調べるには、シェル上で `kill
     -l' などとしてください。

Not a CODE reference
     (F) Perl がコード値 (サブルーティン) へのリファレンスを評価しよう
     としましたが、別のものへのリファレンスでした。実際にどんな種類の
     リファレンスかを調べるには、`ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,も参照してください。

Not a format reference
     (F) どのように無名のフォーマットへのリファレンスを生成したのかは
     わかりませんが、このメッセージは、それが指定されて、存在しなかっ
     たことを示します。

Not a GLOB reference
     (F) Perl が「型グロブ」(これは、*foo のようなシンボルテーブルエン
     トリです) へのリファレンスを評価しようとしましたが、別のものへの
     リファレンスでした。実際にどんな種類のリファレンスかを調べるには、
     `ref()' 関数を使うことができます。*Note リファレンスとデータ構造
     のネスト::,を参照してください。

Not a HASH reference
     (F) Perl がハッシュ値へのリファレンスを評価しようとしましたが、別
     のものへのリファレンスでした。実際にどんな種類のリファレンスかを
     調べるには、`ref()' 関数を使うことができます。*Note リファレンス
     とデータ構造のネスト::,を参照してください。

Not a perl script
     (F) setuid エミュレータでは、たとえマシンがサポートしていなくても、
     完全な形の #! 行がスクリプトに書かれていなければなりません。この
     行で指定されるのは、perl でなければなりません。

Not a SCALAR reference
     (F) Perl がスカラ値へのリファレンスを評価しようとしましたが、別の
     ものへのリファレンスでした。実際にどんな種類のリファレンスかを調
     べるには、`ref()' 関数を使うことができます。*Note リファレンスと
     データ構造のネスト::,を参照してください。

Not a subroutine reference
     (F) Perl がコード値 (サブルーティン) へのリファレンスを評価しよう
     としましたが、別のものへのリファレンスでした。実際にどんな種類の
     リファレンスかを調べるには、`ref()' 関数を使うことができます。
     *Note リファレンスとデータ構造のネスト::,も参照してください。

Not a subroutine reference in %OVERLOAD
     (F) 多重定義テーブルで、有効なサブルーティンを指していないエント
     リを指定しようとしました。*Note 多重定義::,を参照してください。

Not an ARRAY reference
     (F) Perl が配列値へのリファレンスを評価しようとしましたが、別のも
     のへのリファレンスでした。実際にどんな種類のリファレンスかを調べ
     るには、`ref()' 関数を使うことができます。*Note リファレンスとデー
     タ構造のネスト::,を参照してください。

Not enough arguments for %s
     (F) この関数は、指定したよりも多くの引数を必要とします。

Not enough format arguments
     (W) 指定したフォーマットに、次の行で指定したより多くのピクチャフィー
     ルドがあります。*Note フォーマット文::,を参照してください。

Null filename used
     (F) 特に、多くのマシンでカレントディレクトリを意味するため、空の
     ファイル名は `require' できません。*Note 組み込み関数::,の 
     `require' の項を参照してください。

NULL OP IN RUN
     (P) 内部ルーティンで、ヌル opcode ポインタで run() を呼んだものが
     あります。

Null realloc
     (P) realloc NULL を行なおうとしました。

NULL regexp argument
     (P) 内部パターンマッチルーティンが、大当たりです。

NULL regexp parameter
     (P) 内部パターンマッチルーティンが、狂っています。

Odd number of elements in hash list
     (S) ハッシュリストへの要素の数が奇数でした。ハッシュリストは、
     key/value のペアで与えられますから、これは奇妙なことです。

oops: oopsAV
     (S) 文法がおかしくなったことを示す内部警告です。

oops: oopsHV
     (S) 文法がおかしくなったことを示す内部警告です。

Operation `%s' %s: no method found,
     (F) 多重定義テーブルで、もはや有効なメソッドを指していないエント
     リを使おうとしました。*Note 多重定義::,を参照してください。

Out of memory for yacc stack
     (F) yacc パーサーが解析を続けるために、スタックを広げようとしまし
     たが、`realloc()' が仮想やその他のメモリを確保できませんでした。

Out of memory!
     (X) 要求を満たすだけの、十分な残メモリ (または、仮想メモリ) が取
     得できないことを示す、0 を `malloc()' 関数が返しました。

page overflow
     (W) `write()' の 1 度の呼び出しで、1 ページに収まるより多くの行が
     できました。*Note フォーマット文::,を参照してください。

panic: ck_grep
     (P) `grep' をコンパイルしようとして、内部の一貫性チェックに引っ掛
     かりました。

panic: ck_split
     (P) `split' をコンパイルしようとして、内部の一貫性チェックに引っ
     掛かりました。

panic: corrupt saved stack index
     (P) セーブスタックにある以上のローカル化した値を元に戻す要求があ
     りました。

panic: die %s
     (P) `eval' コンテキストへコンテキストスタックをポップしたあと、
     `eval' コンテキストでないことがわかりました。

panic: do_match
     (P) 内部の pp_match() ルーティンが、無効な省略可能データを付けて
     呼ばれました。

panic: do_split
     (P) `split' の準備中に何かまずいことが起こってしまいました。

panic: do_subst
     (P) 内部の pp_subst() ルーティンが、無効な省略可能データを付けて
     呼ばれました。

panic: do_trans
     (P) 内部の pp_trans() ルーティンが、無効な省略可能データを付けて
     呼ばれました。

panic: goto
     (P) 指定したラベルを伴うコンテキストへコンテキストスタックをポッ
     プしたあと、どのように `goto' するかがわかっているコンテキストで
     ないことがわかりました。

panic: INTERPCASEMOD
     (P) 大文字小文字修飾子のところで、字句解析部がおかしな状態に陥り
     ました。

panic: INTERPCONCAT
     (P) 中括弧を伴う文字列を解析中に、字句解析部がおかしな状態に陥り
     ました。

panic: last
     (P) block コンテキストへコンテキストスタックをポップしたあと、
     block コンテキストでないことがわかりました。

panic: leave_scope clearsv
     (P) 書き込み可能な字句スコープ変数が、どういうわけか、スコープ内
     でリードオンリーになりました。

panic: leave_scope inconsistency
     (P) おそらく、セーブスタックの同期がとれていません。少なくとも、
     トップに不正な enum がありました。

panic: malloc
     (P) malloc に負のバイト数で要求が行なわれました。

panic: mapstart
     (P) コンパイラが、map() 関数に関しておかしくなりました。

panic: null array
     (P) 内部配列ルーティンで、ヌル `AV' ポインタを渡されたものがあっ
     た。

panic: pad_alloc
     (P) コンパイラが、一時領域や字句形式を割り当て、解放しているスク
     ラッチパッドについて混乱しました。

panic: pad_free curpad
     (P) コンパイラが、一時領域や字句形式を割り当て、解放しているスク
     ラッチパッドについて混乱しました。

panic: pad_free po
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pad_reset curpad
     (P) コンパイラが、一時領域や字句形式を割り当て、解放しているスク
     ラッチパッドについて混乱しました。

panic: pad_sv po
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pad_swipe curpad
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pad_swipe po
     (P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

panic: pp_iter
     (P) `foreach' の繰返し子が、ループ文脈以外のところで呼ばれました。

panic: realloc
     (P) 何か、realloc に負のバイト数を要求したものがあります。

panic: restartop
     (P) 内部ルーティンから `goto' (または、同じようなもの) が要求され
     ましたが、飛び先が与えれていません。

panic: return
     (P) サブルーティンコンテキストや `eval' コンテキストへ、コンテキ
     ストスタックをポップしたあと、サブルーティンコンテキストや `eval' 
     コンテキストでないことがわかりました。

panic: scan_num
     (P) scan_num() が、何か数字でないものに対して呼ばれました。

panic: sv_insert
     (P) sv_insert() ルーティンが、存在する以上の文字列を削除するよう
     に指示されました。

panic: top_env
     (P) コンパイラが、`goto' など妙なことを行なおうとしました。

panic: yylex
     (P) 大文字小文字修飾子を処理中に、字句解析部がおかしな状態に陥り
     ました。

Parens missing around "%s" list
     (W) おそらく、

          my ($foo, $bar) = @_;

     のようにすべきところで、

          my $foo, $bar = @_;

     のように書いてしまいました。`my' や `local' は、コンマよりも強く
     結合することを忘れないでください。

Perl %3.3f required--this is only version %s, stopped
     (F) 問題のモジュールは、現在実行中の Perl よりも最近のバージョン
     の機能を使っています。ところで、どのくらいアップグレードしていな
     いのですか。*Note 組み込み関数::,の `require' の項を参照してくだ
     さい。

Permission denied
     (F) suidperl の setuid エミュレータは、実行者が安全とは言えないと
     判断しました。

POSIX getpgrp can't take an argument
     (F) お使いの C コンパイラは、引数に pid をとる BSD バージョンの 
     `getpgrp()' と違って、引数をとらない POSIX のものを使っています。

Possible memory corruption: %s overflowed 3rd argument
     (F) `ioctl()' や `fcntl()' が、Perl が求めていた以上のものを返し
     てきました。Perl は、適量のバッファサイズを見積もりますが、念のた
     めにバッファの最後に目印を付けています。この目印が壊されたため、
     Perl はメモリの破壊が起こったと判断しました。*Note 組み込み関数::,
     の `ioctl' の項を参照してください。

Precedence problem: open %s should be open(%s)
     (S) 古い変則的な構文

          open FOO || die;

     は現在は、Perl 5 の文法の厳しい正規化の結果、単項演算子かリスト演
     算子と解釈されますので、

          open(FOO || die);

     という風に誤った解釈がなされます。(古い `open' は、単項演算子とリ
     スト演算子の中間のようなものでした。)ファイルハンドルの前後を括弧
     で囲むか、"||" 演算子の代わりに`or' 演算子を使わなくてはなりませ
     ん。

print on closed filehandle %s
     (W) `print' を行なおうとしたファイルハンドルは、既にクローズされ
     ています。ロジックの流れをチェックしてください。

printf on closed filehandle %s
     (W) `printf' を行なおうとしたファイルハンドルは、既にクローズされ
     ています。ロジックの流れをチェックしてください。

Probable precedence problem on %s
     (W) コンパイラが、条件を期待するところで、裸の単語を見つけました。
     これは、多くの場合、|| や && が前の構文の最後の引数の一部として解
     釈されたときに発生します。たとえば、

          open FOO || die;

     のような場合です。

Read on closed filehandle <%s>
     (W) 読み込みを行なおうとしたファイルハンドルは、既にクローズされ
     ています。ロジックの流れをチェックしてください。

Reallocation too large: %lx
     (F) MS-DOS マシンでは、64K を越えるメモリを割り当てることはできま
     せん。

Recompile perl with -DDEBUGGING to use -D switch
     (F) Perl のコンパイル時に、適切な出力ルーティンが組み込まれていな
     ければ、`-D' スイッチを使うことはできません。これは、多少のオーバ
     ヘッドがかかるもので、それが現在使っている Perl に組み込んでない
     理由でしょう。

Recursive inheritance detected
     (F) 100 レベル以上の継承が行なわれました。おそらく、継承階層の中
     で、予想外のループになっている部分があるものと思われます。

Reference miscount in sv_replace()
     (W) 内部の `sv_replace()' 関数が、参照数が1でない、新規の `SV' を
     扱いました。

regexp memory corruption
     (P) 正規表現コンパイラが渡したもので、正規表現エンジンが処理でき
     なくなった。

regexp out of space
     (P) `safemalloc()' が見つけるはずなので、「起こるはずのないエラー」
     です。

regexp too big
     (F) 現在の正規表現のインプリメンテーションでは、文字列のアドレス
     のオフセットを表わすのに short を使っています。このメッセージは、
     正規表現を編集したときに、32767 を越えてしまったことを表していま
     す。通常、このように正規表現が巨大化してしまうときには、文を分け
     た、より良い方法があるはずです。*Note 正規表現::,を参照してくださ
     い。

Reversed %s= operator
     (W) 代入演算子を逆順に書いています。等号の後に単項演算子が続くと
     きに、曖昧になるのを避けるため、代入演算子では、等号 = が、最後に
     こないといけません。

Runaway format
     (F) 定義したフォーマットに、空になるまで繰り返す ~~ が含まれてい
     ましたが、一度に 200 行以上となり、199 行目と200 行目が全く同じに
     なりました。(スカラ変数には) @ の代わりに ^ を用いるか、(配列変数
     には) `shift' か `pop' を行なうかして、引数が自動的になくなるよう
     になっていないといけませんが、そうなっていないようです。*Note 組
     み込み関数::,を参照してください。

Scalar value @%s[%s] better written as $%s[%s]
     (W) 配列の一つの要素を選ぶのに、(@ で示される) 配列スライスを用い
     ました。一般には、($ で示される) スカラ値を使った方が良いと思われ
     ます。違いは、$foo[&bar] とした場合、代入の対象としたときにも、添
     字を評価するときにも、常にスカラとして振る舞うのに対し、
     @foo[&bar] の場合には、代入の対象としてもリストとして振る舞い、添
     字にもリストコンテキストを与えることになります。これは、1 つの添
     字だけを期待するときには、おかしなこととなるでしょう。

Script is not setuid/setgid in suidperl
     (F) 妙なことに、setuid ビット、もしくは setgid ビットが立っていな
     いスクリプトに対して、suidperl プログラムが起動されました。これは
     意味がありません。

Search pattern not terminated
     (F) `//' もしくは `m{}' 構文の最後の区切り文字が見つかりませんで
     した。括弧類の区切り文字では、ネストを数えることを忘れないでくだ
     さい。

seek() on unopened file
     (W) オープンされていないファイルハンドルか、既にクローズされたファ
     イルハンドルに対して、`seek()' 関数を使おうとしました。

select not implemented
     (F) このマシンでは、`select()' システムコールはインプリメントされ
     ていません。

sem%s not implemented
     (F) このシステムでは、System V セマフォ IPC は使えません。

semi-panic: attempt to dup freed string
     (S) 既に解放と印を付けたスカラを複製するために、内部の 
     `newSVsv()' ルーティンが呼ばれました。

Semicolon seems to be missing
     (W) この付近の構文エラーは、おそらくセミコロンか、コンマなどの演
     算子がなかったために起こったものと考えられます。

Send on closed socket
     (W) 送信を行なおうとしたソケットは、既にクローズされています。ロ
     ジックの流れをチェックしてください。

Sequence (?#... not terminated
     (F) 正規表現コメントは、閉じ括弧で終わらなければなりません。括弧
     を含めることは許されません。*Note 正規表現::,を参照してください。

Sequence (?%s...) not implemented
     (F) 使おうとした正規表現の拡張は、予約された文字ですが、まだイン
     プリメントされていません。*Note 正規表現::,を参照してください。

Sequence (?%s...) not recognized
     (F) お使いになった正規表現の拡張は、意味をなしません。*Note 正規
     表現::,を参照してください。

setegid() not implemented
     (F) `$)' へ代入を行なおうとしましたが、この OS では、`setegid()' 
     システムコール (または、同等のもの) がサポートされていません。少
     なくとも Configure では、そう判断されました。

seteuid() not implemented
     (F) `$>' へ代入を行なおうとしましたが、この OS では、`seteuid()' 
     システムコール (または、同等のもの) がサポートされていません。少
     なくとも Configure では、そう判断されました。

setrgid() not implemented
     (F) `$(' へ代入を行なおうとしましたが、この OS では、`setrgid()' 
     システムコール (または、同等のもの) がサポートされていません。少
     なくとも Configure では、そう判断されました。

setruid() not implemented
     (F) $< へ代入を行なおうとしましたが、この OS では、setruid() シス
     テムコール (または、同等のもの) がサポートされていません。少なく
     とも Configure では、そう判断されました。

Setuid/gid script is writable by world
     (F) setuid エミュレータは、誰もが書き込みができるようになっている
     スクリプトは実行しません。誰かが既に書き換えたかも知れないからで
     す。

shm%s not implemented
     (F) このシステムでは、System V 共有メモリ IPC は使えません。

shutdown() on closed fd
     (W) クローズされたソケットに shutdown を行なおうとしました。多少、
     無駄のように思われます。

SIG%s handler "%s" not defined.
     (W) %SIG 内で指定したシグナルハンドラが、存在しません。間違ったパッ
     ケージで、設定を行なっているのかもしれません。

sort is now a reserved word
     (F) もはや、誰もお目にかかることのない、旧世代のエラーメッセージ
     です。ただ、`sort' がキーワードとなる前には、これをファイルハンド
     ルとして使う方がいました。

Sort subroutine didn't return a numeric value
     (F) `sort' の比較ルーティンは、必ず数値を返さなければなりません。
     `<=>' や `cmp' を使わなかったか、正しく使わなかったものと思います。
     *Note 組み込み関数::,の `sort' の項を参照してください。

Sort subroutine didn't return single value
     (F) `sort' の比較サブルーティンは、要素が 1 個以外のリスト値を返
     すことはできません。*Note 組み込み関数::,の `sort' の項を参照して
     ください。

Split loop
     (P) `split' が無限ループに陥りました。(明らかに、`split' は、入力
     文字数以上にはできないはずですが、そうなってしまいました。) *Note 
     組み込み関数::,の `split' の項を参照してください。

Stat on unopened file <%s>
     (W) オープンされていないファイルハンドルか、既にクローズされたファ
     イルハンドルに対して、`stat()' 関数 (か、同様なファイルテスト) を
     使おうとしました。

Statement unlikely to be reached
     (W) `exec()' の後に、die() 以外の実行文があります。失敗したとき以
     外は、`exec()' から `return' することはありませんから、ほとんどの
     場合には誤りでしょう。`return' してくる`system()' に置き換える必
     要があるかもしれません。この警告を止めるには、ブロック内に 
     `exec()' だけを記述してください。

Subroutine %s redefined
     (W) サブルーティンを再定義しました。この警告を止めるには、

          {
              local $^W = 0;
              eval "sub name { ... }";
          }

     としてください。

Substitution loop
     (P) 置換が無限ループに陥りました。(明らかに、置換は入力文字数以上
     には起こらないはずですが、それが起こってしまいました。)*Note 演算
     子と優先順位::, の「クォートとクォートのような演算子」の節の置換
     に関する記述を参照してください。

Substitution pattern not terminated
     (F) `s///' もしくは `s{}{}' 構文の真ん中の区切り文字が見つかりま
     せんでした。括弧類の区切り文字では、ネストを数えることを忘れない
     でください。

Substitution replacement not terminated
     (F) `s///' もしくは `s{}{}' 構文の最後の区切り文字が見つかりませ
     んでした。括弧類の区切り文字では、ネストを数えることを忘れないで
     ください。

substr outside of string
     (W) 文字列の外を指す `substr()' を参照しようとしました。つまり、
     オフセットの絶対値が、文字列の長さより大きくなっています。*Note 
     組み込み関数::,の `substr' の項を参照してください。

suidperl is no longer needed since...
     (F) お使いの Perl は、-DSETUID_SCRIPTS_ARE_SECURE_NOW を指定して
     コンパイルされていますが、setuid エミュレータが、実行されてしまい
     ました。

syntax error
     (F) おそらく、構文エラーが起こっています。よくある原因としては、

        * キーワードのスペルミス。
        * セミコロンを忘れた。
        * コンマを忘れた。
        * 開き括弧、閉じ括弧を忘れた。
        * 開き中括弧、閉じ中括弧を忘れた。
        * クォートの閉じ忘れ。

     が考えられます。多くの場合、構文エラーと一緒に、別のエラーメッセー
     ジが出て、情報を与えてくれます。(`-w' を付けることが、助けになる
     こともあります。)エラーメッセージ自身には、何行目まで行って、諦め
     たのかということも含まれています。Perl はでたらめな入力を理解する
     のが得意なので、実際のエラーはもう少し前に在ることもあります。と
     きには、行番号が全く役に立たないこともあり、はまってしまったなら、
     エラーのきっかけが何かを見つける唯一の手段は、プログラムを寸断し
     て、エラーがなくなるまで、`perl -c' を繰り返すしかありません。頭
     の体操 20 問だと思ってください。

System V IPC is not implemented on this machine
     (F) 何か、名前が "sem"、"shm"、"msg" で始まる関数を実行しようとし
     ました。*Note 組み込み関数::,の `semctl' などの項を参照してくださ
     い。

Syswrite on closed filehandle
     (W) 書き込みを行なおうとしたファイルハンドルは、既にクローズされ
     ています。ロジックの流れをチェックしてください。

tell() on unopened file
     (W) オープンされていないファイルハンドルか、既にクローズされたファ
     イルハンドルに対して、`tell()' 関数を使おうとしました。

Test on unopened file <%s>
     (W) オープンされていないファイルハンドルに対して、ファイルテスト
     演算子を実行しようとしました。ロジックをチェックしてください。
     *Note 組み込み関数::, の `-X' の節を参照してください。

That use of $[ is unsupported
     (F) 現在、$[ への代入は、厳しく制限され、コンパイラディレクティブ
     と解釈されます。使えるのは、

          $[ = 0;
          $[ = 1;
          ...
          local $[ = 0;
          local $[ = 1;
          ...

     の一つだけです。これは、一つのモジュールで、他のモジュールが意図
     しないような、配列のベースを変更する問題を回避するためのものです。
     *Note 定義済み変数::,の $[ の節を参照してください。

The %s function is unimplemented
     (F) この関数は、Configure の調査によると、このアーキテクチャでは、
     インプリメントされていないようです。

The crypt() function is unimplemented due to excessive paranoia.
     (F) Configure は、マシン上で `crypt()' 関数を見つけられませんでし
     た。おそらく、ベンダからの供給がなかったからで、おそらく、ベンダ
     はアメリカ政府がそれを秘密だとしていると思っているか、少なくとも
     思っているというふりをしているのでしょう。私を引き合いに出したと
     ころで、それは否定されることでしょう。

The stat preceding -l _ wasn't an lstat
     (F) 過去の `stat' がシンボリックリンクを通り過ぎた、実際のファイ
     ルの情報を取って、`stat' バッファに入れているときに、シンボリック
     タイプの `stat' をカレント `stat' バッファに対して行なっても意味
     がありません。実際のファイル名を使ってください。

times not implemented
     (F) お使いの C ライブラリでは、`times()' を行わないようです。UNIX 
     ではない環境でしょうか。

Too few args to syscall
     (F) `syscall()' には、最低限でも呼び出すシステムコールを示す、引
     数が一つ必要です。

Too many args to syscall
     (F) Perl では、`syscall()' に最大 14 までしか、引数を渡すことがで
     きません。

Too many arguments for %s
     (F) 関数が要求する以上の引数を指定しました。

trailing \ in regexp
     (F) 正規表現が、バックスラッシュを付けていないバックスラッシュで
     終了しました。バックスラッシュを付けてください。*Note 正規表現::,
     を参照してください。

Translation pattern not terminated
     (F) `tr///' もしくは `tr[][]' 構文の真ん中の区切り文字が見つかり
     ませんでした。

Translation replacement not terminated
     (F) `tr///' もしくは `tr[][]' 構文の最後の区切り文字が見つかりま
     せんでした。

truncate not implemented
     (F) このマシンでは、Configure が知りうる、ファイルの切り詰めの機
     能がインプリメントされていません。

Type of arg %d to %s must be %s (not %s)
     (F) この関数は、その位置に決まった型の引数を必要とします。配列は、
     @NAME もしくは @{EXPR} でなくてはならず、ハッシュは、%NAME もしく
     は %{EXPR} でなければなりません。暗黙の被参照は許されませんので、
     明示的な被参照として、{EXPR} 形式を使ってください。*Note リファレ
     ンスとデータ構造のネスト::, を参照してください。

umask: argument is missing initial 0
     (W) `umask 222' は正しくありません。Perl の 8 進数リテラルは、C 
     と同じように 0 で始まりますから、 0222 とすべきです。

Unbalanced context: %d more PUSHes than POPs
     (W) いくつの実行コンテキストに入って、出たかということの内部矛盾
     が `exit' コードで発見されました。

Unbalanced saves: %d more saves than restores
     (W) いくつの値が、一時的にローカル化されたかということの内部矛盾
     が `exit' コードで発見されました。

Unbalanced scopes: %d more ENTERs than LEAVEs
     (W) いくつのブロックにに入って、出たかということの内部矛盾が 
     `exit' コードで発見されました。

Unbalanced tmps: %d more allocs than frees
     (W) いくつの揮発性スカラの割り当てを行ない、解放したかということ
     の内部矛盾が `exit' コードで発見されました。

Undefined format "%s" called
     (F) このフォーマットは存在しないように見えます。おそらく、別のパッ
     ケージに存在するのではないでしょうか。*Note フォーマット文::,を参
     照してください。

Undefined sort subroutine "%s" called
     (F) 指定された `sort' の比較ルーティンは存在していないように思わ
     れます。おそらく、別のパッケージに存在するのではないでしょうか。
     *Note 組み込み関数::,の `sort' の項を参照してください。

Undefined subroutine &%s called
     (F) 指定されたサブルーティンが定義されていません。定義されていた
     としても、既に未定義になっています。

Undefined subroutine called
     (F) 呼びだそうとしている無名のサブルーティンは、定義されていませ
     ん。定義されていたとしても、既に未定義になっています。

Undefined subroutine in sort
     (F) 指定された `sort' の比較ルーティンは宣言されましたが、定義さ
     れていないようです。*Note 組み込み関数::,の `sort' の項を参照して
     ください。

unexec of %s into %s failed!
     (F) unexec() ルーティンが何らかの理由によって失敗しました。最初に
     インストールしたであろう、サイトの FSF 代表者にたずねてみてくださ
     い。

Unknown BYTEORDER
     (F) このバイト順序を入れ替える関数がありません。

unmatched () in regexp
     (F) 正規表現の中では、バックスラッシュを付けていない括弧は、必ず
     対応していなければなりません。vi をお使えであれば、% を使って対応
     する括弧を探すことができます。*Note 正規表現::,を参照してください。

Unmatched right bracket
     (F) 字句解析部が開き中括弧よりも多くの閉じ中括弧を見つけました。
     開き中括弧のもれと思われます。一般的な規則として、最後に修正した
     場所の付近に、忘れた中括弧 (であるはずのもの) があることでしょう。

unmatched [] in regexp
     (F) 文字クラスの前後の大括弧は、対応していないといけません。文字
     クラスの中に閉じ大括弧を入れたいのであれば、バックスラッシュを付
     けるか、文字クラスの最初に置いてください。*Note 正規表現::,を参照
     してください。

Unquoted string "%s" may clash with future reserved word
     (W) いつの日にか、予約語とかち合うかもしれない、裸の単語を使用し
     ています。そのような単語は、クォートするか、大文字を入れるか、ア
     ンダーバー (_) をいれるかしてください。その裸の単語は、サブルーティ
     ンとして宣言することも可能です。

Unrecognized character \%03o ignored
     (S) 入力にゴミの文字が見つかり、無視しました。EBCDICマシーンの制
     御文字だとかの場合のためのメッセージです。

Unrecognized signal name "%s"
     (F) `kill()' 関数に、認識できないシグナル名を指定しました。お使い
     のシステムで使用可能なシグナル名を調べるには、シェル上で `kill
     -l' などとしてください。

Unrecognized switch: -%s
     (F) Perl に間違ったオプションを指定しました。これを行なってはいけ
     ません。(指定したつもりがないのであれば、#! 行に間違ったオプショ
     ンがスイッチが指定されていないかをチェックしてください。)

Unsuccessful %s on filename containing newline
     (W) あるファイル名に対して、ファイル操作を行ないましたが、失敗し
     ました。「おそらく」ファイル名に改行文字がついていたからで、「お
     そらく」`chop()' や `chomp()' するのを忘れたのでしょう。*Note 組
     み込み関数::,の `chop' の項を参照してください。

Unsupported directory function "%s" called
     (F) このマシンでは、`opendir()' や `readdir()' がサポートされてい
     ません。

Unsupported function %s
     (F) このマシンでは、表示した関数はインプリメントされていません。
     少なくとも、Configure はそう判断しました。

Unsupported socket function "%s" called
     (F) このマシンでは、バークレイのソケット機構がサポートされていな
     いか、少なくとも Configure がそう判断しました。

Unterminated <> operator
     (F) 項が必要とされるところで、開き山括弧が見つけたため、対応する
     閉じ山括弧を探しましたが、見つかりませんでした。可能性としては、
     必要な括弧を省いてしまい、本当は、「小なり記号」を表したかった場
     合が考えられます。

Use of $# is deprecated
     (D) これは、貧相な awk の機能をエミュレートしようとするものでした。
     代わりに、明示的に `printf()' や `sprintf()' を使ってください。

Use of $* is deprecated
     (D) この変数は、自分のスクリプトでも、たまたま呼んだ先のサブルー
     ティンでも、複数行のパターンマッチを有効にしてしまいます。$* の離
     れたところに与える危険な影響を避けてこれを行なうために、新しい 
     `//m' 修飾子と `//s' 修飾子を使ってください。

Use of %s is deprecated
     (D) 示した構文は、もはや使うことが推奨されません。一般にはもっと
     良い方法があるからであり、また古い方法は、悪い副作用があるからで
     す。

Use of implicit split to @_ is deprecated
     (D) サブルーティンの引数を壊すとコンパイラに多大な労力をかけるこ
     とになるので、`split()' の結果は明示的に配列 (やリスト) に代入を
     行なうようにしてください。

Use of uninitialized value
     (W) 未定義値を、あたかも既に定義されているかのように使用しました。
     これは、"" か 0 と解釈されますが、間違いの可能性があります。この
     警告を止めるには、変数に初期値を代入してください。

Useless use of %s in void context
     (W) ブロックの値を返さない文や、スカラのコンマ演算子の左側のよう
     に返却値の無い文脈で、副作用のないことを行ないました。多くは、み
     なさんの間違いを指摘するものではなく、Perl がみなさんの意向を汲み
     取った解釈ができないことで起こります。たとえば、みなさんが C の優
     先順位を Pythonの優先順位と混同して、

          ($one, $two) = (1, 2);

     とするべきところで、

          $one, $two = 1, 2;

     とすれば、このエラーとなります。

Warning: unable to close filehandle %s properly.
     (S) `open()' によって暗黙のうちに行なわれる `close()' が、
     `close()' のエラーとなりました。通常、ファイルシステムがいっぱい
     であることを示します。

Warning: Use of "%s" without parens is ambiguous
     (S) 単項演算子の後に、何か項にも単項演算子にも解釈できる、二項演
     算子のようなものが置かれました。たとえば、`rand'関数がデフォルト
     の引数として、1.0 をとることを知っていれば、

          rand + 5;

     と書いて、

          rand() + 5;

     と同じことと思うかもしれませんが、実際には、

          rand(+5);

     の意味になります。したがって、思うように解釈させるには、括弧が必
     要になります。

Write on closed filehandle
     (W) 書き込みを行なおうとしたファイルハンドルは、既にクローズされ
     ています。ロジックの流れをチェックしてください。

X outside of string
     (F) `unpack' している文字列の先頭より前の相対位置を示している 
     `pack' テンプレートを指定しました。*Note 組み込み関数::,の `pack' 
     の項を参照してください。

x outside of string
     (F) `unpack' している文字列の最後より後の相対位置を示している 
     `pack' テンプレートを指定しました。*Note 組み込み関数::,の `pack' 
     の項を参照してください。

Xsub "%s" called in sort
     (F) ソートの比較ルーティンとして、外部サブルーティンを使用するこ
     とは、まだサポートされていません。

Xsub called in sort
     (F) ソートの比較ルーティンとして、外部サブルーティンを使用するこ
     とは、まだサポートされていません。

You can't use -l on a filehandle
     (F) ファイルはオープンされたファイルを表わすものであり、ファイル
     をオープンしたときには、探しているシンボリックリンクは、既に通り
     過ぎた後です。代わりにファイル名を使ってください。

YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!
(このカーネルでは、SET-ID スクリプトが禁止されていません!)
     (F) そして、そうすることはできないでしょう。カーネルのソースはお
     持ちではないでしょうし、ベンダも欲しいものを提供してはくれないで
     しょうから。もっとも良いのは、スクリプトに setuid C ラッパーを被
     せるために、eg ディレクトリの wrapsuid スクリプトを使ってみること
     です。

You need to quote "%s"
     (W) シグナルハンドラ名に、裸の単語を代入しました。残念ながら、そ
     のサブルーティンは既に宣言されていて、Perl 5では、おそらく思惑と
     は違って、代入の実行時にサブルーティンの呼び出しが起こります。(も
     し、本当にそうしたいのであれば、サブルーティン名に & を付けてくだ
     さい。)

[gs]etsockopt() on closed fd
     (W) クローズされたソケットに `getsockopt' または `setsockopt' を
     行なおうとしました。`socket()' の呼び出し時に、返却値のチェックを
     忘れたのではありませんか。*Note 組み込み関数::,の `getsockopt' の
     項を参照してください。

\1 better written as $1
     (W) パターンの外では、後方参照は変数の形で存在します。後方参照の
     利用は、置換の右側の部分で扱われますが、スタイル的には、他の Perl 
     プログラマが期待し、9個以上の後方参照があるときにもうまく動作する、
     変数形式を使う方が良いでしょう。




File: perl-ja.info, Node: フォーマット文, Next: プロセス間通信, Prev: 診断メッセージ, Up: Top

フォーマット文
**************

Perl は、単純なレポートやチャートを作成するお手伝いができます。これを
簡単にするために、Perl では、印字された時にどのように見えるかに近い形
で、コードの中で出力ページをレイアウトできます。Perl はまた、1ページに
何行入るか、現在何ページめか、いつページヘッダを出力するかといったこと
のめんどうをみてくれます。使用されるキーワードは FORTRAN から持ってき
たもので、宣言に `format' 文を用い、実行に `write()' を使います。*Note 
組み込み関数::,で `formline' と `write' の項を参照してください。幸い、
レイアウトは BASIC の PRINT USING 文のようなものより読みやすいものです。
安上がりな nroff(1) と考えてください。

フォーマットは、パッケージやサブルーティンと同じく、実行文ではなく、宣
言文ですから、プログラムのどこにおいてもかまいません。(しかしながら、
普通は1か所にまとめておいた方が良いでしょう。)フォーマットは Perl の他
の「型」とは別に名前空間がとられます。このことは、`Foo' という名前の関
数を持っているとき、それは、`Foo' という名前のフォーマットを持っている
のとは違うということです。しかし、あるファイルハンドルに対して付随する
フォーマットのデフォルトの名前は、そのファイルハンドルの名前と同じもの
です。つまり、STDOUT に対するデフォルトのデフォルトのフォーマットは 
`STDOUT' であり、ファイルハンドル TEMP に対するデフォルトのフォーマッ
ト名は `TEMP' だということです。これらは同じように見えますが、違うもの
です。

出力レコードのフォーマットは以下のように宣言します:

     format NAME =
     FORMLIST
     .

NAME を指定しないと、`STDOUT' というフォーマットが定義されます。
FORMLIST は行の並びからなり、それぞれの行は次の 3 つのどれかになります:

  1. コメント。行頭に # を置くとその行はコメントとして扱われます。

  2. ピクチャ行。出力する行のフォーマットを 1 行単位で示します。

  3. 引数行。先行するピクチャ行に埋め込む値を示します。

ピクチャ行は、ある種のフィールドが、その行に値を埋め込むのに使われる他
は、まったく見た目の通りに印字されます。ピクチャ行の各々のフィールドは、
"@" や "^" で始まるようになっています。ピクチャ行では、いかなる形でも
変数の展開は行なわれません。"@" フィールド (配列の "@" と混同しないこ
と) は、通常のフィードで、"^" フィールドが複数行に渡るテキストのブロッ
クを作るために使われます。フィールドの長さは、"@" や "^" のあとに "<" 
や ">" や "|" を必要な数だけ並べることで表わし、それぞれ、左づめ、右づ
め、センタリングを表わします。もし、値がフィールドをはみだす場合には、
切り捨てられてしまいます。

右づめの別の形式として、数値フィールドを示す、"#" (と "." も可) を使うこ
ともできます。この方法で、小数点の位置を揃えることができます。こういった
フィールドに与えられる値に改行が含まれていると、その改行までのテキストが
印字されます。もう1つ "@*" というフィールドを使うと、値の切捨てを行なわ
ずに、複数行にわたって印字するために使用するようにできます。このフィール
ドを使う場合には、同じ行に別のフィールドを指定できません。

各フィールドへの値は、次の行に、ピクチャフィールドと同じ順番で指定しま
す。値を示す式は、コンマで区切られている必要があります。式はすべて、そ
の行が評価される前に、リストコンテキストで評価されますので、1つのリス
ト式が複数のリスト要素を作るようにもできます。式は、中括弧で括って、複
数行にすることもできます。もし、そのようにするときは、最初の行の最初の
トークンを、開き中括弧にしなければなりません。

"@" ではなく、"^" で始まるピクチャフィールドは、特別な扱いを受けます。
"#" を使ったフィールドでは、値が未定義の場合に、空白となります。他のタ
イプのフィールドでは、"^" はある種の充填モードになります。値として指定
できるものは、任意の式ではなく、テキスト文字列が入ったスカラ変数名でな
ければなりません。Perl はそのフィールドに入るだけのテキストを詰め込ん
で、変数内の文字列の先頭から、その分を切り落とします。次にその変数が参
照されるときには、残りの部分のテキストが印字できることになります。(そ
うです、このことは変数自身が `write()' の実行中に変更され、もとには戻
らないということです。)普通は、テキストを矩形に表示するように、フィー
ルドを縦に積むような形で使われます。一番最後のフィールドを "..." とい
う文字列で終わらせておくと、表示するテキストがその最後のフィールドにも
収まりきらなかったときに、そのまま "..." が出力されます。`$:' (English 
モジュール使用時は `$FORMAT_LINE_BREAK_CHARACTERS')という変数に文字列
を設定すると、出力する文字列の中に、この変数内に設定した文字列中の 1 
字が見つかったときに改行するようになります。

"^" フィールドを使うと可変長のレコードが作れます。フォーマットされるテ
キストが短ければ、行のどこかに "~" をおくことで空行の出力をサプレスす
ることができます。出力時には、"~" は空白に変換されます。"~" を2つ並べ
て書くと、すべてのフィールドに入れられる値が尽きてしまうまで、そのピク
チャ行と引数行を繰り返して使用します。(もし、"@" タイプのフィールドを
使うならば、与える式は永久に同じ値を出すことの無いようにしないといけま
せん。)

ページ先頭フォーマットの処理はデフォルトでは、現在のファイルハンドル名
に `_TOP' をつなげた名前のフォーマットで行なわれます。これは、各々のペー
ジの先頭で使われます。*Note 組み込み関数::,の `write()' の項を参照して
ください。

例:
     # /etc/passwd ファイルについてのレポート
     format STDOUT_TOP =
                             Passwd File
     Name                Login    Office   Uid   Gid Home
     ------------------------------------------------------------------
     .
     format STDOUT =
     @<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<
     $name,              $login,  $office,$uid,$gid, $home
     .

     # バグ報告書からのレポート
     format STDOUT_TOP =
                             Bug Reports
     @<<<<<<<<<<<<<<<<<<<<<<<     @|||         @>>>>>>>>>>>>>>>>>>>>>>>
     $system,                      $%,         $date
     ------------------------------------------------------------------
     .
     format STDOUT =
     Subject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              $subject
     Index: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            $index,                       $description
     Priority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
               $priority,        $date,   $description
     From: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           $from,                         $description
     Assigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                  $programmer,            $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
                                          $description
     .

同じ出力チャネルに `print()' と `write()' を混ぜて使うことも可能ですが、
`$-' (`$FORMAT_LINES_LEFT') を自分で調整する必要があります。

* Menu:

* フォーマット変数::
* フッタ::
* 内部のフォーマット動作へのアクセス::





File: perl-ja.info, Node: フォーマット変数, Next: フッタ, Prev: フォーマット文, Up: フォーマット文

フォーマット変数
================

その時点でのフォーマット名は、変数 `$~' (`$FORMAT_NAME') に入れられて
おり、ページ先頭フォーマットは、`$^' (`$FORMAT_TOP_NAME')に入れられて
います。ページ番号は、`$%' (`$FORMAT_PAGE_NUMBER')に、ページあたりの行
数は `$=' (`$FORMAT_LINES_PER_PAGE') に入っています。そのファイルハン
ドルに対して出力を自動フラッシュするか否かは、`$|'
(`$OUTPUT_AUTOFLUSH') に入れられています。(先頭ページ以外の) ページの
先頭の前に出力する文字列は、`$^L' (`$FORMAT_FORMFEED') に蓄えられます。
これらの変数は、ファイルハンドルごとに設定されますので、特定のファイル
ハンドルのものを変更するには `select()' する必要があります:

     select((select(OUTF),
             $~ = "My_Other_Format",
             $^ = "My_Top_Format"
            )[0]);

汚いですか？でも、普通のイディオムなので、見つけたときには驚かないでく
ださい。少なくとも以前のファイルハンドルを保持するのに一時変数を使うこ
とができます。(読みやすいばかりでなく、デバッガでステップ実行するとき
に式の途中で、中間的な状態を用意できることになりますから、一般にはこち
らの方がずっと良いでしょう):

     $ofh = select(OUTF);
     $~ = "My_Other_Format";
     $^ = "My_Top_Format";
     select($ofh);

`English' モジュールを使えば、変数名を読むことさえできます:

     use English;
     $ofh = select(OUTF);
     $FORMAT_NAME     = "My_Other_Format";
     $FORMAT_TOP_NAME = "My_Top_Format";
     select($ofh);

しかし、意味不明の `select()' がまだ残っています。`FileHandle' モジュー
ルを使ってください。小文字のメソッドを使って、特殊変数をアクセスするこ
とができるようになります:

     use FileHandle;
     format_name     OUTF "My_Other_Format";
     format_top_name OUTF "My_Top_Format";

ずっと良いでしょう !



NOTES
-----

引数行には、( ^ フィールドに対してではなく、@ フィールドに対して) 任意
の式が許容されますから、もっと込み入った処理には、`sprintf()' や独自の
関数などに任せることもできます。たとえば:

     format Ident =
         @<<<<<<<<<<<<<<<
         &commify($n)
     .

実際に @ や ^ をフィールドに表示するには、以下のようにします:

     format Ident =
     I have an @ here.
             "@"
     .

テキスト全体をセンタリングするには、このようになります:

     format Ident =
     @|||||||||||||||||||||||||||||||||||||||||||||||
             "Some text line"
     .

「どんな幅であっても、右端に寄せるようにしたい。」というような要望に答
える方法は組み込まれていません。表示する場所を必ず指定する必要がありま
す。窮余の策としては、現在のカラム数に基づいて、その場でフォーマットを
作って、`eval()' することができます:

     $format  = "format STDOUT = \n";
              . '^' . '<' x $cols . "\n";
              . '$entry' . "\n";
              . "\t^" . "<" x ($cols-8) . "~~\n";
              . '$entry' . "\n";
              . ".\n";
     print $format if $Debugging;
     eval $format;
     die $@ if $@;

これは、以下のようなフォーマット文を生成します:

     format STDOUT =
     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     $entry
             ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
     $entry
     .

fmt(1) のようなプログラム:

     format =
     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~
     $_
     .

     $/ = ";
     while (<>) {
         s/\s*\n\s*/ /g;
         write;
     }





File: perl-ja.info, Node: フッタ, Next: 内部のフォーマット動作へのアクセス, Prev: フォーマット変数, Up: フォーマット文

フッタ
======

`$FORMAT_TOP_NAME' には、その時点のページ先頭フォーマット（ヘッダフォー
マット）の名前が納められていますが、フッタに対して自動的に同じことをす
るための、対応する機構は用意されていません。フォーマットを評価するまで
は、どのくらいの大きさになるのかがわからないことも、大きな問題と言えま
す。これは、Todo のリストに入っています。

1 つの方法をあげておきます: 固定サイズのフッタであれば、`write()' を行
なう前ごとに `$FORMAT_LINES_LEFT' をチェックして、必要なときにフッタを 
`print' することで、フッタを付けることができます。

もう 1 つ別の方法です: `open(MESELF, "|-")' を使って、自分自身にパイプ
を `open' し (*Note 組み込み関数::,の `open()' の項を参照してください)、
常に STDOUT の代わりに MESELF に `write()' するようにします。チャイル
ドプロセス側では、STDIN からの入力をフォーマットし直して、好きな形にヘッ
ダやフッタを整えるようにします。簡単とは言えませんが、実行は可能です。





File: perl-ja.info, Node: 内部のフォーマット動作へのアクセス, Prev: フッタ, Up: フォーマット文

内部のフォーマット動作へのアクセス
==================================

フォーマット機構に対する低レベルのアクセスのため、`formline()' を使い、
`$^A' (`$ACCUMULATOR') を直接アクセスすることができます。

たとえば、

     $str = formline <<'END', 1,2,3;
     @<<<  @|||  @>>>
     END

     print "Wow, I just stored `$^A' in the accumulator!\n";

もしくは、`printf()' に対する `sprintf()' のような `write()' に対する
サブルーティン `swrite()' を作るため:

     use English;
     use Carp;
     sub swrite {
         croak "usage: swrite PICTURE ARGS" unless @ARG;
         local($ACCUMULATOR);
         formline(@ARG);
         return $ACCUMULATOR;
     }
     $string = swrite(<<'END', 1, 2, 3);
     Check me out
     @<<<  @|||  @>>>
     END
     print $string;

のようにします。


WARNING
-------

`format' の実行中には、グローバルな変数と `local()' で宣言された動的ス
コープの変数だけが見えます。`my()' で宣言された字句スコープの変数は、
`format' と同じスコープにあるとはみなされず、使用することができません。




File: perl-ja.info, Node: プロセス間通信, Next: セキュリティ, Prev: フォーマット文, Up: Top

プロセス間通信
**************

Perl の IPC 機能は、バークレイのソケット機構の上に構築されています。ソ
ケットが無い場合には、この節は無視してください。呼び出す関数の名前は対
応するシステムコールの名前と同一ですが、2 つの理由により引数は異なる傾
向にあります。まず、Perl のファイルハンドルは C のファイルディスクリプ
タと異なる動作をすること。もう一つは、Perl は常に文字列の長さを知って
いるので、長さの情報を改めて渡す必要がないことです。

* Menu:

* クライアント/サーバ通信::
* SysV IPC::





File: perl-ja.info, Node: クライアント/サーバ通信, Next: SysV IPC, Prev: プロセス間通信, Up: プロセス間通信

クライアント/サーバ通信
=======================

TCP クライアントの例を示します。

     ($them,$port) = @ARGV;
     $port = 2345 unless $port;
     $them = 'localhost' unless $them;

     $SIG{'INT'} = 'dokill';
     sub dokill { kill 9,$child if $child; }

     use Socket;

     $sockaddr = 'S n a4 x8';
     chop($hostname = `hostname`);

     ($name, $aliases, $proto) = getprotobyname('tcp');
     ($name, $aliases, $port) = getservbyname($port, 'tcp')
         unless $port =~ /^\d+$/;
     ($name, $aliases, $type, $len, $thisaddr) =
                     gethostbyname($hostname);
     ($name, $aliases, $type, $len, $thataddr) = gethostbyname($them);

     $this = pack($sockaddr, &AF_INET, 0, $thisaddr);
     $that = pack($sockaddr, &AF_INET, $port, $thataddr);

     socket(S, &PF_INET, &SOCK_STREAM, $proto) || die "socket: $!";
     bind(S, $this) || die "bind: $!";
     connect(S, $that) || die "connect: $!";

     select(S); $| = 1; select(stdout);

     if ($child = fork) {
         while (<>) {
             print S;
         }
         sleep 3;
         do dokill();
     }
     else {
         while (<S>) {
             print;
         }
     }

そしてサーバです:

     ($port) = @ARGV;
     $port = 2345 unless $port;

     use Socket;

     $sockaddr = 'S n a4 x8';

     ($name, $aliases, $proto) = getprotobyname('tcp');
     ($name, $aliases, $port) = getservbyname($port, 'tcp')
         unless $port =~ /^\d+$/;

     $this = pack($sockaddr, &AF_INET, $port, "\0\0\0\0");

     select(NS); $| = 1; select(stdout);

     socket(S, &PF_INET, &SOCK_STREAM, $proto) || die "socket: $!";
     bind(S, $this) || die "bind: $!";
     listen(S, 5) || die "connect: $!";

     select(S); $| = 1; select(stdout);

     for (;;) {
         print "Listening again\n";
         ($addr = accept(NS,S)) || die $!;
         print "accept ok\n";

         ($af,$port,$inetaddr) = unpack($sockaddr,$addr);
         @inetaddr = unpack('C4',$inetaddr);
         print "$af $port @inetaddr\n";

         while (<NS>) {
             print;
             print NS;
         }
     }





File: perl-ja.info, Node: SysV IPC, Prev: クライアント/サーバ通信, Up: プロセス間通信

SysV IPC
========

共有メモリ使用状況を示す例です:

     $IPC_PRIVATE = 0;
     $IPC_RMID = 0;
     $size = 2000;
     $key = shmget($IPC_PRIVATE, $size , 0777 );
     die if !defined($key);

     $message = "Message #1";
     shmwrite($key, $message, 0, 60 ) || die "$!";
     shmread($key,$buff,0,60) || die "$!";

     print $buff,"\n";

     print "deleting $key\n";
     shmctl($key ,$IPC_RMID, 0) || die "$!";

セマフォの例です:

     $IPC_KEY = 1234;
     $IPC_RMID = 0;
     $IPC_CREATE = 0001000;
     $key = semget($IPC_KEY, $nsems , 0666 | $IPC_CREATE );
     die if !defined($key);
     print "$key\n";

このコードを独立したファイルに納めて、少なくとも一つのプロセスで実行す
るようにします。このファイルを `take' とします。(訳注: 意味が通じない
ので想像を含めています。)

     # セマフォの生成

     $IPC_KEY = 1234;
     $key = semget($IPC_KEY,  0 , 0 );
     die if !defined($key);

     $semnum = 0;
     $semflag = 0;

     # セマフォの「取得」'take'
     # セマフォが 0 になるのを待つ
     $semop = 0;
     $opstring1 = pack("sss", $semnum, $semop, $semflag);

     # セマフォのカウントをインクリメント
     $semop = 1;
     $opstring2 = pack("sss", $semnum, $semop,  $semflag);
     $opstring = $opstring1 . $opstring2;

     semop($key,$opstring) || die "$!";

このコードを独立したファイルに納めて、少なくとも一つのプロセスで実行す
るようにします。このファイルを `give' とします。(訳注: 意味が通じない
ので想像を含めています。)

     # セマフォの「提供」'give'
     # これを元のプロセスで実行すると、続くプロセスが、引き継
     # ぎます。

     $IPC_KEY = 1234;
     $key = semget($IPC_KEY, 0, 0);
     die if !defined($key);

     $semnum = 0;
     $semflag = 0;

     # セマフォのカウントをデクリメント
     $semop = -1;
     $opstring = pack("sss", $semnum, $semop, $semflag);

     semop($key,$opstring) || die "$!";




File: perl-ja.info, Node: セキュリティ, Next: 不注意によるわな, Prev: プロセス間通信, Up: Top

セキュリティ
************

Perl は安全な setuid スクリプトや setgid スクリプトを書くことが簡単に
できるように設計されています。シェルはスクリプト内の各々の行に対して置
換を何回も行ないますが、Perl は見えない「内部動作」を少なくした、より
伝統的な評価機構を使っています。さらに、この言語では、より多くの組み込
み機能を備えており、目的達成のために、外部の (そして、信頼のおけない可
能性のある) プログラムに頼らなければならないことが、少なくなっています。

多くの OS で、スクリプトのような柔軟なシステムに対して、特別な権限を与
えることによる明らかな問題以前に、setuid スクリプトは、スタート時点か
ら本質的に安全ではありません。これは、特にシステム上にシンボリックリン
クがある場合には、カーネルが何を実行するのかを調べるためにファイルをオー
プンしてから、setuid インタプリタが変更を行なって、そのファイルを解釈
するために再オープンするまでに、何かが変更される可能性があるからです。

幸いにも、カーネルの「機能」は、禁止することができる場合があります。不
幸にも、禁止する方法は2通りあります。一つは、システムが setuid ビット
が設定されているスクリプトを扱えないようにするもので、こちらは余り役に
立つことがありません。もう一つは、単にスクリプトに付いた setuid ビット
を無視するというものです。もし、後者であれば、Perl スクリプトに付けた、
意味のなくなった setuid/setgid ビットを Perl が見つけたときに、setuid 
と setgid の機構をエミュレートすることができます。これは、必要なときに
自動的に呼ばれる、suidperl という特別な実行ファイルによって行なわれま
す。

しかし、カーネルの setuid スクリプトの機能が禁止されていなければ、Perl 
は、この setuid スクリプトが安全ではないと警告を発します。カーネルの 
setuid スクリプトの機能を禁止するか、スクリプトに C ラッパーを被せる必
要があります。どのようにこれを行なうかについては、Perl 配布キットの eg 
ディレクトリの wrapsuid プログラムを参照してください。

setuid スクリプトが、この本質的な非安全性のバグから免れているシステムも
存在します。たとえば、Solaris の最近のリリースでは大丈夫なようです。この
ようなシステムでは、カーネルがインタプリタへオープンする setuid スクリプ
トの名前を渡すとき、そのものを表わすパス名を渡すのではなく、代わりに 
/dev/fd/3を渡します。これは、既にスクリプトに対してオープンされた特殊ファ
イルですから、横取りをするような悪意を持った競合条件を避けることになりま
す。こういったシステムでは、Perl をコンパイルするときに 
-DSETUID_SCRIPTS_ARE_SECURE_NOW をつけておくとよいでしょう。Perl を作る 
Configure プログラムは、自分でこれを見つけようとします。

Perl が setuid スクリプトを実行するとき、明らかな罠に填ったりしないよ
うに、特別な予防策がとられます。(いくつかの点で、Perl スクリプトは同じ
ことをする C プログラムよりも安全であるといえます。)すべてのコマンドラ
インの引数、環境変数、入力は、「汚染」マークが付けられ、サブシェルを起
動するコマンドや、ファイルやディレクトリやプロセスに修正を加えるコマン
ドには、直接的にも間接的にも使用できないようになっています。汚染マーク
が付けられた値を含んだ式で、設定を行なった変数もすべて、(たとえ、論理
的に汚染された値が、その変数に影響を与えることが不可能であっても) 汚染
されたことになります。たとえば:

     $foo = shift;               # $foo は汚染された
     $bar = $foo,'bar';          # $bar も汚染された
     $xxx = <>;                  # 汚染された
     $path = $ENV{'PATH'};       # 汚染されたが、以下も参照
     $abc = 'abc';               # 汚染されていない

     system "echo $foo";         # 安全ではない
     system "/bin/echo", $foo;   # 安全 (sh を使いません)
     system "echo $bar";         # 安全ではない
     system "echo $abc";         # PATH が設定されるまでは、
                                 # 安全ではない

     $ENV{'PATH'} = '/bin:/usr/bin';
     $ENV{'IFS'} = " if $ENV{'IFS'} ne ";

     $path = $ENV{'PATH'};       # 汚染されていない
     system "echo $abc";         # これで安全 !

     open(FOO,"$foo");           # OK
     open(FOO,">$foo");          # OK ではない

     open(FOO,"echo $foo|");     # OK ではありませんが ...
     open(FOO,"-|") || exec 'echo', $foo;        # OK

     $zzz = `echo $foo`;         # 安全ではなく、zzz は汚染

     unlink $abc,$foo;           # 安全ではない
     umask $foo;                 # 安全ではない

     exec "echo $foo";           # 安全ではない
     exec "echo", $foo;          # 安全 (sh を使いません)
     exec "sh", '-c', $foo;      # 安全と解釈されてしまいます

汚染状況は、スカラ値ごとに管理されますから、配列要素の一部の要素だけが
汚染され、他は大丈夫ということもあります。

もし、何か安全とはいえないことをしようとしたならば、"Insecure
dependency" とか "Insecure PATH" といった致命的エラーになります。それ
でも、安全でないシステムコールや `exec' を書くことができることに注意し
なくてはなりませんが、実行するためには、上記の最後の例のように、明示的
に行なうことが必要になっています。サブパターンを参照することでも、この
汚染チェックの仕組みの裏をかくことができます。`$1', `$2' といった部分
文字列を使うときには、Perl は、使っているみなさん自身が、パターンを書
く時点で、自分で何をしているのかが分かっているものと、仮定するのです:

     $ARGV[0] =~ /^-P(\w+)$/;
     $printer = $1;              # 汚染されません

これは、`\w+' がシェルのメタ文字にマッチしませんから、かなり安全です。
`/.+/' は安全とはいえないものですが、Perl はそれをチェックしてくれませ
んから、パターンの内容にも注意しないといけません。これは、(`$>' を 
`$<' に合わせないのであれば) ファイル名を与えて、そのファイルに何か操
作を行ないたい場合に、汚染のマークを取り除く「唯一」の手段でもあります。

"Insecure PATH" というメッセージには、`$ENV{'PATH'}' に既知の値を設定
し、パスの中のディレクトリは、一般の権限では書き込みができないようになっ
ていることが必要です。よく言われる文句には、実行ファイルのパス名をフル
パスで書いても、このメッセージが出るというものがあります。しかし Perl 
は、その実行ファイルが PATH に依存して別のプログラムを実行しないと判断
することはできないのです。

汚染された値を使うことには関与しない操作で、問題が起こることもあります。
ユーザが指定したファイル名を扱うときには、ファイルテストを賢く利用して
ください。可能ならば、`open' などは、`$> = $<' を設定してから行なって
ください。(グループ ID の方も忘れないでください。) Perl は、汚染された
ファイル名を読み込みのために `open' することは咎めませんので、出力に気
を付けてください。汚染チェックの仕組みは、setuid の過ちを防ぐことを目
的としているのであって、何も考えなくてもよいということではありません。




File: perl-ja.info, Node: 不注意によるわな, Next: スタイルガイド, Prev: セキュリティ, Up: Top

不注意によるわな
================

もっとも大きなわなは、`-w' スイッチを忘れることです。*Note 実行とオプ
ション::,を参照してください。プログラムで

     use strict;

と指定した上で、実行できるようにしておけば、突然の事故を未然に防いでく
れますが、その場限りのプログラムにはめんどうすぎる要求でしょう。

* Menu:

* Awk のわな::
* C のわな::
* Sed のわな::
* Shell のわな::
* Perl のわな::
* Perl4 のわな::

訳注: 原文には、Accustomed awk users、Cerebral C Programmers、Seasoned
sed programmers、Sharp shell programmers、Practicing Perl Programmers、
Penitent perl 4 Programmers といった言葉の遊びがみられますが、力及ばず
訳出できませんでした。





File: perl-ja.info, Node: Awk のわな, Next: C のわな, Prev: 不注意によるわな, Up: 不注意によるわな

Awk のわな
==========

Awk になれた方は、以下のようなことに、特に注意してください:

   * `English' モジュールを

          use English;

     としてロードすれば、awk でのようにして特殊変数を (`$RS' のように) 
     参照することができます。詳しくは、*Note 定義済み変数::,を参照して
     ください。

   * Perl では、(ブロックの最後を除いて) すべての単純実行文にセミコロ
     ンが必要です。改行が実行文の区切り文字とはみなされません。

   * `if' や `while' には、中括弧が必須です。

   * Perl では、変数は "$" や "@" で始まります。

   * 配列のインデクスは0からです。`substr()' や `index()' での文字列中
     の位置も同様です。

   * 配列のインデクスを、数値にするか文字列にするかを決めなくてはなり
     ません。

   * 連想配列の値は、単に参照するだけでは存在することになりません。

   * 文字列比較を行なうのか、数値比較を行なうのかを決めなければなりま
     せん。

   * 入力を読み込むだけでは、`split' は行なわれません。自分で`split' 
     を行なって、明示的に配列に入れる必要があります。また、`split()' 
     演算子は、引数が違います。

   * 現在行は通常、`$0' ではなく、`$_' に入れられています。一般に、行
     末の改行文字は削除されていません。(`$0' は、実行されているプログ
     ラムの名前です。)*Note 定義済み変数::,を参照してください。

   * `$<数字>' は、フィールドを参照するものではありません。これは、最
     後のパターンマッチで、マッチした部分文字列を参照するものです。

   * `$,' や `$\' を設定しない限り、`print()' 文はフィールドセパレータ
     やレコードセパレータを付与しません。`English' モジュールを使えば、
     `$OFS' や `$ORS' を設定することができます。

   * ファイルへ `print' するときには、前もって `open' しなければなりな
     せん。

   * 範囲演算子はコンマではなく `..' です。コンマ演算子は、C と同じよ
     うに動作します。

   * マッチの拘束演算子は、"~" ではなく、`=~' です。(`~' はC と同じよ
     うに1の補数をとる演算子です。)

   * 指数演算子は、"^" ではなく、`**' です。`^' は C と同じく XOR 演算
     子です。(awk が基本的に C と互換性がないことにお気付きかもしれま
     せんね。)

   * 連結演算子は、空文字列ではなく、`.' です。(空文字列を使うと、
     `/par/ /pat/' が解析できなくなります。3番目のスラッシュが除算演算
     子と解釈されるからです。Perl の字句解析部は、`/', `?', `>' のよう
     な演算子に対し、多少文脈依存となっています。実際、`.' 自身も、数
     値の開始になることもあります。

   * キーワード `next'、`exit'、`continue' の働きが異なります。

   * 以下の変数の働きが異なります:

          Awk       Perl
          ARGC      $#ARGV or scalar @ARGV
          ARGV[0]   $0
          FILENAME  $ARGV
          FNR       $. - something
          FS        (whatever you like)
          NF        $#Fld, or some such
          NR        $.
          OFMT      $#
          OFS       $,
          ORS       $\
          RLENGTH   length($&)
          RS        $/
          RSTART    length($`)
          SUBSEP    $;

   * `$RS' にパターンを設定することはできず、文字列だけです。

   * 疑わしいときには、awk の構文を a2p に通して、出力されたものを見て
     みましょう。





File: perl-ja.info, Node: C のわな, Next: Sed のわな, Prev: Awk のわな, Up: 不注意によるわな

C のわな
========

知的な C プログラマは、以下のことに注意すべきです:

   * `if' や `while' には、中括弧が必要です。

   * "else if" ではなく、`elsif' を使わなくてはなりません。

   * C のキーワード "break" と "continue" に相当するものは、Perlでは、
     それぞれ `last' と `next' になっています。C とは違って、これらは 
     `do { } while' 構造では使えません。

   * switch 文はありません。(しかし、大急ぎで作ることも簡単です。)

   * Perl では、変数は "$" や "@" で始めます。

   * `printf()' では、フィールド長を展開する "*" フォーマットはインプ
     リメントされていませんが、ダブルクォート文字列のフォーマット内で
     変数を展開すれば、同じことができます。

   * コメントは "/*" ではなく、"#" で開始します。

   * 任意のもののアドレスを得ることはできません。Perl 5 における同様の
     演算子はバックスラッシュですが、これはリファレンスを生成するもの
     です。

   * ARGV は大文字で書かなければなりません。

   * `link()', `unlink()', `rename()' といったシステムコールは、成功時
     に (0 ではなく)、0 以外を返します。

   * シグナルハンドラは、数字ではなくシグナル名を扱います。使用できる
     シグナル名は、`kill -l' として確かめてください。





File: perl-ja.info, Node: Sed のわな, Next: Shell のわな, Prev: C のわな, Up: 不注意によるわな

Sed のわな
==========

熟練した sed プログラマは、以下のことに注意すべきです:

   * 置換文字列中の後方参照では "\" ではなく、"$" を使います。

   * パターンマッチのメタ文字 "(", ")", "|" は、前にバックスラッシュを
     置いてエスケープする必要はありません。

   * 範囲演算子は、コンマではなく "..." です。




File: perl-ja.info, Node: Shell のわな, Next: Perl のわな, Prev: Sed のわな, Up: 不注意によるわな

Shell のわな
============

鋭いシェルのプログラマは、以下のことに注意すべきです:

   * バッククォート演算子は、コマンド内にシングルクォートがあっても変
     数の展開を行ないます。

   * バッククォート演算子は、csh とは異なり、返された値を変換しません。

   * シェル (特に csh) は、コマンドラインごとに、何段階もの置換を行な
     います。Perl はダブルクォート、バッククォート、山括弧、検索パター
     ンといった特定の構造でだけ置換を行ないます。

   * シェルは、一時に少しづつ解釈を行ないます。Perl は、実行前にプログ
     ラム全体をコンパイルします (コンパイル時に実行される BEGIN ブロッ
     クを除く)。

   * 引数は、$1, $2 などではなく、@ARGV から得られます。

   * 環境変数は、自動的には独立したスカラ変数として利用できるようにな
     りません。(訳注: `Env' モジュールが使用できます。)




File: perl-ja.info, Node: Perl のわな, Next: Perl4 のわな, Prev: Shell のわな, Up: 不注意によるわな

Perl のわな
===========

実践的な Perl プログラマは、以下のことに注意すべきです:

   * 多くの演算子が、スカラコンテキストとリストコンテキストとでは、動
     作が異なることを忘れないでください。詳しくは、*Note データ構造::,
     を参照してください。

   * 裸の単語、特に全てが小文字のものは、できる限り使わないでください。
     見た目だけでは、その「裸の単語」が関数なのか、文字列なのかが判断
     できません。文字列にはクォートを、関数呼び出しには括弧を付ければ、
     迷うこともないでしょう。

   * どの組み込み関数が (`chop()' や `chdir()' のような) 単項演算子で、
     どれが (`print()' や `unlink()' のような) リスト演算子かは、単に
     眺めるだけではわかりません。(ユーザ定義のサブルーティンは、リスト
     演算子にすることができますが、単項演算子にはなりません。) *Note 
     演算子と優先順位::,を参照してください。

   * いくつかの関数が `$_' や `@ARGV' などをデフォルトにしていますが、
     同じことを期待する他の関数がデフォルトになっていないことを覚える
     のに、辛いタイピングが必要でしょう。(have a hard time の "time" 
     と "type" をかけているのは、どう訳そう(^^;)

   * `=~' が必要なところで `=' を使わない事を忘れないようにしてくださ
     い。この 2 つの構文はかなり違います:

          $x =  /foo/;
          $x =~ /foo/;

   * `do {}' 構造は本物のループではないので、ループ制御を行なえません。
     (訳注: 原文はそう言っていない気もするが。)

   * ローカル変数は、`my()' で済むところでは、これで済ませること (使え
     ない場所については、*Note フォーマット文::,を参照してください)。
     `local()' を使えば、グローバル変数に対するローカルな値を与えます
     が、動的スコープの不慮の副作用の可能性は、そのままです。





File: perl-ja.info, Node: Perl4 のわな, Prev: Perl のわな, Up: 不注意によるわな

Perl4 のわな
============

悔い改めた Perl 4 のプログラマは、以下に示すリリース 4 とリリース 5 の
間の互換性のない修正点に注意すべきです:

   * ダブルクォートタイプの文字列で、@ は必ず配列を展開します。@ を展
     開しないようにするように、バックスラッシュを使わなければならない
     プログラムもあるでしょう。

   * Perl にとって文字列のように見えていた裸の単語は、それ以前に、その
     名前のサブルーティンが定義されていれば、サブルーティンコールと解
     釈されるようになりました。たとえば:

          sub SeeYa { die "Hasta la vista, baby!" }
          $SIG{QUIT} = SeeYa;

     Perl 4 では、シグナルハンドラを設定しますが、Perl 5 では、実際に
     関数を呼び出し、その結果を設定します `!-w' スイッチを使えば、この
     ようなものを探してくれます。

   * "_" で始まるシンボルは、$_ 自身 (と @_ など) を除いて、`main' パッ
     ケージに存在しなくてもよくなりました。

   * `s'$lhs'$rhs'' では、どちら側でも展開を行なわなくなりました。以前
     は、`$rhs' は展開しませんでしたが、`$lhs' は展開しました。

   * `splice()' の 2 番目の引数と 3 番目の引数が (本に書いてあったよう
     に) リストコンテキストではなく、スカラコンテキストで評価されるよ
     うになりました。

   * 優先順位によって意味エラーが起こります:

          shift @list + 20;
          $n = keys %map + 20;

     これらがうまく行けば、以下がうまく行きません:

          sleep $dormancy + 20;

   * `open FOO || die' は、もはや正しくありません。ファイルハンドルの
     前後に括弧が必要です。一時的にサポートされていましたので、このよ
     うな構文を使うと致命的ではない (がサプレスできない) 警告が出ます。
     (訳注: `or' 演算子を使用することができます。)

   * フォーマット文の引数リストの要素は、リストコンテキストで評価され
     るようになりました。このことにより、リスト値を展開できるようにな
     りました。

   * 最適化によってなくなるブロック内に `goto' することはできません。
     ちぇっ。

   * 空白を変数名やクォート構文の区切り文字に使うことは、もはや構文的
     に正しくなくなりました。ちぇっ、ちぇっ。

   * 関数 `caller()' は呼び元がないとき、スカラコンテキストで偽を返す
     ようになりました。これにより、ライブラリファイルは、自分が 
     `require' されたものかを判断できます。

   * `m//g' は状態を正規表現の方にではなく、検索文字列の方に括りつけま
     す。

   * `sort' のサブルーティン名として、`reverse' というものは、許されな
     くなりました。

   * taintperl は、もはや独立した実行ファイルとして存在しません。自動
     的に汚染チェックが on にならないときのために、`-T' スイッチが用意
     されています。

   * ダブルクォート文字列が、エスケープされていない $ や @ で終了する
     ことがなくなりました。

   * 古い `while/if BLOCK BLOCK' の構文は、もはやサポートされていませ
     ん。

   * 配列に負の添え字を与えると、配列の終わりから数えるようになりまし
     た。

   * コンマ演算子をスカラコンテキストで使うと、引数にもスカラコンテキ
     ストが適用されることを保証するようになりました。

   * `**' 演算子は、単項のマイナスよりも強く結合するようになりました。
     このように動作するように、ドキュメントに書かれていましたが、そう
     なっていませんでした。

   * `$#array' を小さく設定すると、それ以降の配列の要素を捨てます。

   * `delete()' は `tie' された配列の古い値を返すことが保証されません。
     この機能は、いくつかのモジュールにとってインプリメントがめんどう
     だからです。

   * 異なるエラーメッセージがあります。

   * いくつかのバグが、迂闊にも修正されているかもしれません。




File: perl-ja.info, Node: スタイルガイド, Next: 応用プログラムインタフェース, Prev: 不注意によるわな, Up: Top

スタイルガイド
**************

もちろん、人それぞれにフォーマットの好みがありますが、読みやすく、理解
しやすく、保守しやすいプログラムにするための一般的なガイドラインも存在
します。

コードレイアウトの美学に関して、唯一 Larry が強く気にかけることは、複
数行に渡る BLOCK の閉じ中括弧の位置を、その構文を開始するキーワードと
カラム位置を揃えるということです。この他には、それ程に強くはない好みと
して:

   * 4カラムのインデント。

   * 開き中括弧は、できるだけキーワードと同じ行におくようにする。さも
     なくば、キーワードとカラムを揃える。

   * 複数行ブロックの中括弧の前は空ける。

   * 1行の BLOCK は中括弧も含めて1行にしてよい。

   * セミコロンの前には空白を入れない。

   * 「短い」1行の BLOCK では、セミコロンを省く。

   * ほとんどの演算子の両側には空白を入れる。

   * (大括弧の中の) 「複雑な」添字の両側には空白を入れる。

   * 動作内容の異なる、かたまりごとに空行を入れる。

   * `else' は行替えする。

   * 関数名と開き括弧の間に空白を入れない。

   * コンマのあとには空白を入れる。

   * 長い行は (`and' と `or' 以外の) 演算子のあとで改行する。

   * その行内でマッチする最後の括弧の後にスペースを入れる。

   * 対応する項目は、カラムを揃えて縦に整列する。

   * 明瞭さの妨げにならない範囲で、余分な句読点などは省く。

Larry はこれらのことに対して彼なりの理由を持っていますが、他の人が同じ
ように考えなくても文句をいう筋合いのものではありません。

もう少し本質的なスタイルの問題も考えておくべきでしょう:

   * 何らかの方法で書けるからといって、その方法でやらなくてはならない
     ことはありません。Perl は何でもいくつかの方法でできるように設計さ
     れていますので、もっとも読みやすいものを選ぶとよいでしょう。たと
     えば、

          open(FOO,$foo) || die "Can't open $foo: $!";

     という方が

          die "Can't open $foo: $!" unless open(FOO,$foo);

     のように、文の重要なポイントを修飾子に隠してしまうよりも良いでしょ
     う。また、

          print "Starting analysis\n" if $verbose;

     の方が

          $verbose && print "Starting analysis\n";

     よりも良いでしょう。使う人が `-v' と入力したかどうかを判定するの
     がポイントではないからです。

     同様に、演算子にデフォルトの値が用意されているからといって、それ
     を利用しなければならないというものではありません。デフォルトは、
     怠け者のシステムプログラマが「一時的な」プログラムを書くためにあ
     るのです。プログラムを読みやすくしたいと思うならば、ちゃんと引数
     を与えるようにしてください。

     さらには、多くの場所で括弧を省くことができますが、これは決して省
     かなければならないということではありません:

          return print reverse sort num values %array;
          return print(reverse(sort num (values(%array))));

     疑わしいときには括弧を付けるべきです。少なくとも、viで % キーを使っ
     て、跳ねまわることができます。

     特に疑わしい場合でなくても、みなさんの後を引き継いでコードのメン
     テをする人のことを考えてあげてください。間違ったところに括弧を付
     けてしまうかも知れません。

   * ループの最初や最後で抜けられるように、妙に莫迦げた細工をしないこ
     と。Perl では、`last' 演算子を用意しているので、ループの途中で抜
     けることができるのです。目立つように、少しばかり突き出して置けば
     よいのです:

          LINE:
              for (;;) {
                  statements;
                last LINE if $foo;
                  next LINE if /^#/;
                  statements;
              }

   * ループラベルを付けるのを恐れてはいけません。多重のループからの脱
     出するためでもありますが、読みやすくするためでもあるのです。上の
     例を参照してください。

   * 移植性のため、すべてのマシンでインプリメントされていない機能を使
     う場合には、 `eval' の中で使ってみて調べてください。その機能がイ
     ンプリメントされているバージョンやパッチレベルがわかるのであれば、 
     $] (English モジュールを使っているときには $PERL_VERSION ) を調べ
     て、実装されているかを見ることができます。 `Config' モジュールで 
     Perl をインストールした時に、 Configure プログラムで決定された値
     を引き出すことができます。

   * 意味のある識別子名を使ってください。何を意味しているのかがわから
     なくなれば、きっと問題になるでしょう。

   * ごちゃごちゃした正規表現には、 `/x' 修飾子を使って、空白を入れ、
     なるべく見やすくするようにしましょう。正規表現の中にスラッシュや
     バックスラッシュを使っている時には、区切文字にスラッシュを使うの
     は避けましょう。

   * リスト演算子に括弧を付けなければならなくなるのを避け、 `&&' や 
     `||' といった記号的な演算子の頻度を下げるために " `and' "や "
     `or' " という新しい演算子を使ってください。過剰な `&' や括弧を避
     けるために、サブルーティンは関数やリスト演算子として使いましょう。

   * 何回も `print()' 文を繰り返すよりは、ヒアドキュメントを使ってくだ
     さい。

   * 対応するものは縦に並べましょう。特に 1 行に収まらないくらい長い場
     合には。

          $IDX = $ST_MTIME;
          $IDX = $ST_ATIME       if $opt_u;
          $IDX = $ST_CTIME       if $opt_c;
          $IDX = $ST_SIZE        if $opt_s;

          mkdir $tmpdir, 0700 or die "can't mkdir $tmpdir: $!";
          chdir($tmpdir)      or die "can't chdir $tmpdir: $!";
          mkdir 'tmp',   0777 or die "can't mkdir $tmpdir/tmp: $!";

   * 変換を行なうときに並べることでわかりやすくなるならば、並べましょ
     う。

          tr [abc]
             [xyz];

   * 再利用性を考えましょう。同じようなことをまたしなくてはならないか
     もしれないときに、一時凌ぎのスクリプトに頭を悩ませることはないで
     しょう。コードを一般化することを考えてください。モジュールやオブ
     ジェクトクラスを書くことを考えてください。 `use strict' や `-w' 
     を有効にして、コードの不明瞭な部分が無いようにしてください。コー
     ドを減らすことを考えてください。全体の見方を変えることも考えてく
     ださい。さらに ... やめましょう。

   * 一貫性をもって。

   * 良識をもって。




File: perl-ja.info, Node: 応用プログラムインタフェース, Next: 拡張を行なうための内部関数, Prev: C からの呼び出し法, Up: Top

応用プログラムインタフェース
****************************

XS は、Perl と Perl といっしょに使おうとする C ライブラリの間の拡張イ
ンタフェースを作るための言語です。XS インタフェースは、Perl とリンクす
ることのできる、新しいライブラリを作るためのライブラリと組み合わせて使
われます。XSUB は、XS 言語内の関数で、Perl アプリケーションインタフェー
スの中核を成すものです。

XS コンパイラは、xsubpp と呼ばれています。このコンパイラは、実際には C 
の関数を装って XSUB に Perl の値を操作させるために必要な構造を埋め込み、
Perl に XSUB をアクセスさせるために必要なグルー関数を作ります。コンパ
イラは、C 関数の引数や変数を Perl の値にマッピングする方法を決めるため
に、 `typemap' を使用します。デフォルトの `typemap' では、多くの一般的
な C の型を扱っています。新たにリンクされるライブラリのための、特殊な
構造体や型を扱うときには、補助的な `typemap' を作らなければなりません。

以下の多くの例では、Perl と ONC+RPC 結合ライブラリ関数のインタフェース
の作成に焦点をおいています。特に、 `rpcb_gettime()' 関数が、XS 言語の
多くの機能を示すために用いられています。この関数は、2 つの引数をとりま
す。一つめの引数が入力用で、ふたつめの引数が出力用です。この関数はまた、
ステータス値を返します。

      bool_t rpcb_gettime(const char *host, time_t *timep);

C からは、以下のような形でこの関数が呼ばれます。

     #include <rpc/rpc.h>
     bool_t status;
     time_t timep;
     status = rpcb_gettime( "localhost", &timep );

この関数と Perl の間で直接変換を行なうための XSUB を作れば、次のような
コードで、Perl からその XSUB が使われます。変数 $STATUS と変数 $TIMEP 
に、この関数の出力が得られます。

     use RPC;
     $status = rpcb_gettime( "localhost", $timep );

以下に示す XS ファイルは、 `rpcb_gettime()' 関数へのインタフェースの一
例となる XS サブルーティン (XSUB のこと) を示しています。この XSUB が 
C と Perl の間の直接変換を行ない、Perlからのインタフェースも確保します。
XSUB は上に示したような使い方で、Perl から起動されます。XS ファイルで
はいつも、最初に `EXTERN.h' 、 `perl.h' 、 `XSUB.h' のための 3 つの 
`#include' 文を指定しないといけません。この方法や他の方法の拡張は、後
述します。

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"
     #include <rpc/rpc.h>

     MODULE = RPC  PACKAGE = RPC

     bool_t
     rpcb_gettime(host,timep)
          char *  host
          time_t  &timep
          OUTPUT:
          timep

XSUB を使うものを含めて、どんな Perl への拡張も、ブートストラップのよ
うに起動時に、その拡張を Perl に組み込む Perl モジュールを用意するよう
になっています。このモジュールが、拡張機能や変数を Perl プログラムにエ
クスポートし、拡張のためのXSUB を Perl に組み込みます。以下のモジュー
ルは、このドキュメントのほとんどの例で使われ、前に示したように Perl か
ら`use' コマンドで使われるはずです。Perl モジュールについては、このド
キュメント内でも、もう少し詳しく触れます。

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );

     bootstrap RPC;
     1;

このドキュメントを通じて、さまざまな `rpcb_gettime()' XSUB へのインタ
フェースを研究しています。XSUB は、場合によって、順番や数の異なる引数
をとるようになっています。どの場合にも、XSUB は、Perl と実際の C の 
`rpcb_gettime()' 関数の間を取り持つもので、XSUB が実際の 
`rpcb_gettime()' 関数を常に正しい引数で呼ぶことを保証しなければなりま
せん。この抽象化された仲介によって、プログラマは、C 関数にいっそう 
Perl 風なインタフェースを用意することができるようになっているのです。

* Menu:

* XSUB 解剖学::
* 引数スタック::
* RETVAL 変数::
* MODULE キーワード::
* PACKAGE キーワード::
* PREFIX キーワード::
* OUTPUT キーワード::
* CODE キーワード::
* PPCODE キーワード::
* NO_INIT キーワード::
* BOOT キーワード::
* CLEANUP キーワード::
* 関数引数の初期化::
* デフォルト引数値::
* 可変長引数リスト::
* Undef 値や空リストを返す::
* コメントや C プリプロセッサディレクティブを使用する::
* XS を C++ で使用する::
* Perl 変数::
* インタフェースの戦略::
* Perl モジュール::
* Perl のオブジェクトと C の構造体::
* C のヘッダファイルと Perl::
* 新しい拡張モジュールの作成::
* Typemap::
* XS の使用例::


AUTHOR
======
Dean Roehrich <roehrich@cray.com> September 27, 1994





File: perl-ja.info, Node: XSUB 解剖学, Next: 引数スタック, Prev: 応用プログラムインタフェース, Up: 応用プログラムインタフェース

XSUB 解剖学
===========

以下の XSUB では、Perl プログラムから `sin()' という C のライブラリ関
数をアクセスできるようにしています。この XSUB は、一つの引数をとり、一
つの値を返す C の関数を模倣します。

     double
     sin(x)
       double<tab>x

コンパイラは、引数の名前と型の間に 1 つのタブがあることを期待しており、
型の前には空白は、あっても無くてもかまいません。C のポインタを使うとき
には、上記の `rpcb_gettime()' 関数で示したように、間接指定演算子 `*' 
は、型の一部と考えるべきであり、アドレス演算子 `&' は、変数の一部と考
えるべきです。C の型に関する修飾子と単項演算子の扱いについては、 *Note
typemap::, の節も参照してください。

関数の引数リストでは、開き括弧の後や、閉じ括弧の前に空白を入れてはなり
ません。

     誤った表記                     正しい表記

     double                         double
     sin( x )                       sin(x)
       double  x                      double  x

関数名と関数型は、行を改めて書かなくてはなりません。

     誤った表記                     正しい表記

     double sin(x)                    double
       double  x                      sin(x)
                                        double  x





File: perl-ja.info, Node: 引数スタック, Next: RETVAL 変数, Prev: XSUB 解剖学, Up: 応用プログラムインタフェース

引数スタック
============

引数スタックは、XSUB への引数として渡される値や XSUB からの返却値を蓄
えるために使用します。実際には、すべての Perl の関数が、スタック上の自
分の範囲を決めて、同時にこのスタックに値を蓄えています。このドキュメン
トでは、アクティブな関数に属するスタック上の最初の範囲を、その関数に対
して位置0 というようにして参照するようにします。

`x' をスタック上のその XSUB の部分の位置を示すものとするとき、XSUB は、
自分のスタック引数を `ST(x)' というマクロで参照できます。その関数の位
置 `0' は、XSUB には、 `ST(0)' という形で伝えられることになります。
XSUB への引数と XSUB からの返却値は、いつも `ST(0)' の位置から置かれる
ことになっています。多くの簡単なケースでは、xsubpp コンパイラは、 
`typemap' に入れる埋め込みプログラムで、引数スタックを扱うために必要な
コードを生成します。より複雑なケースでは、プログラマがそのコードを用意
しなくてはなりません。





File: perl-ja.info, Node: RETVAL 変数, Next: MODULE キーワード, Prev: 引数スタック, Up: 応用プログラムインタフェース

RETVAL 変数
===========

RETVAL 変数は、常に C のライブラリ関数の関数型にマッチするマジック変数
です。xsubpp コンパイラは、XSUB ごとに、この変数を用意し、デフォルトで
は、呼び出される C のライブラリ関数の返却値を保持するためにこの変数を
使用します。簡単なケースでは、RETVAL の値は、Perl が XSUB の返却値とし
て受け取れるように、引数スタックの `ST(0)' に置かれます。

XSUB の関数型を `void' とした場合には、この関数に対して、コンパイラは 
RETVAL 変数を用意しません。 `PPCODE:' ディレクティブを使うときには、
RETVAL 変数は必要ありません。





File: perl-ja.info, Node: MODULE キーワード, Next: PACKAGE キーワード, Prev: RETVAL 変数, Up: 応用プログラムインタフェース

MODULE キーワード
=================

MODULE キーワードは、XS コードを開始し、定義される関数のパッケージを示
すために使われます。最初の `MODULE' キーワードの前のテキストはすべて、
C のコードとみなされ、透過的に出力に渡されます。すべての XS モジュール
には、XSUB をフックして、Perl に渡すために使われる `bootstrap' 関数を
用意します。この`bootstrap' 関数のパッケージ名は、XS ソースファイル中
で最後の`MODULE' 文の値にマッチします。MODULE の値は、一つの XS ファイ
ルの中では一定にしておくべきですが、そうしておかなければならないと決め
られているものではありません。

以下の例は、XS コードを開始し、すべての関数を RPC というパッケージに置
くようにするものです。

     MODULE = RPC





File: perl-ja.info, Node: PACKAGE キーワード, Next: PREFIX キーワード, Prev: MODULE キーワード, Up: 応用プログラムインタフェース

PACKAGE キーワード
==================

XS ソースファイル内で関数を、複数のパッケージに分けなければならないと
き、 `PACKAGE' キーワードが使われます。このキーワードが使われるときに
は、 `MODULE' キーワードとともに用い、その直後に置かなければなりません。

     MODULE = RPC  PACKAGE = RPC

     [ パッケージ RPC の XS コード ]

     MODULE = RPC  PACKAGE = RPCB

     [ パッケージ RPCB の XS コード ]

     MODULE = RPC  PACKAGE = RPC

     [ パッケージ RPC の XS コード ]

このキーワードは省略可能であり、冗長な情報となることもありますが、いつ
も使用するようにした方が良いでしょう。このキーワードを使うことによって、
XSUB が目的のパッケージに入れられることを保証するのです。





File: perl-ja.info, Node: PREFIX キーワード, Next: OUTPUT キーワード, Prev: PACKAGE キーワード, Up: 応用プログラムインタフェース

PREFIX キーワード
=================

`PREFIX' キーワードは、Perl の関数名から取り除くプリフィクスを指定する
ものです。C の関数が `rcpb_gettime()' で、 PRIFIX の値が `rcpb_' であ
れば、この関数は、Perl からは `gettime()' というように見えます。

このキーワードが使われるときには、 `PACKAGE' キーワードのあとに置きま
す。 `PACKAGE' が使われなければ、 `MODULE' キーワードのあとに置きます。

     MODULE = RPC  PREFIX = rpc_

     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_





File: perl-ja.info, Node: OUTPUT キーワード, Next: CODE キーワード, Prev: PREFIX キーワード, Up: 応用プログラムインタフェース

OUTPUT: キーワード
==================

`OUTPUT:' キーワードは、XSUB の終了時に、(新しい値が Perl から見えるよ
うに) 特定の関数引数を更新しなければならないか、特定の値を呼び出しもと
の Perl 関数に返さなければならないことを示します。上記の `sin()' 関数
のような簡単な関数では、 RETVAL 変数が、自動的に出力値として使われます。
より複雑な関数では、xsubpp コンパイラがどの変数が出力変数であるかを判
断するために助けが必要となります。

このキーワードは、通常 `CODE:' キーワードを補足するために使います。 
`CODE:' キーワードが存在するとき、 RETVAL 変数が、出力変数として認識さ
れることはなくなります。 `OUTPUT:' キーワードを使用すると、コンパイラ
に RETVAL を実際に出力変数として使うことを指示することになります。

`OUTPUT:' キーワードは、関数の引数が出力変数であることを示すためにも使
われます。これは、その引数が関数内で変更されているときに、更新結果を 
Perl から見えるようにするために必要となることがあります。関数引数を 
RETVAL 変数といっしょに `OUTPUT:' の下に並べる場合には、 RETVAL 変数は
最後に置かないといけません。

     bool_t rpcb_gettime(host,timep) char * host time_t &timep OUTPUT:
timep `OUTPUT:' キーワードはまた、出力引数を `typemap' ではなく、マッ
チするコードに対応させるためにも使います。

     bool_t
     rpcb_gettime(host,timep)
          char *  host
          time_t  &timep
          OUTPUT:
          timep<tab>sv_setnv(ST(1), (double)timep);





File: perl-ja.info, Node: CODE キーワード, Next: PPCODE キーワード, Prev: OUTPUT キーワード, Up: 応用プログラムインタフェース

CODE: キーワード
================

このキーワードは、C の関数に対して特別な扱いを要求する、比較的複雑な 
XSUB で使われます。 RETVAL 変数も使えますが、`OUTPUT:' キーワードの下
に指定して、実際に値を返すことを示さなければなりません。

次の XSUB は、引数に特別な扱いが要求される C 関数のためのものです。
Perl 側の用法をまず示します。

     $status = rpcb_gettime( "localhost", $timep );

XSUB は以下の通りです。

     bool_t rpcb_gettime(host,timep)
           char *  host
           time_t  timep
           CODE:
                RETVAL = rpcb_gettime( host, &timep );
           OUTPUT:
           timep
           RETVAL

ここに示す多くの例で、 `CODE:' ブロック (と他のブロック) が、中括弧 (
`{} と `'' ) で囲まれます。これによって、 `CODE:' ブロックを複雑な 
INPUT typemap から保護し、結果の C のコードが正しいものとなることを保
証してくれます。





File: perl-ja.info, Node: PPCODE キーワード, Next: NO_INIT キーワード, Prev: CODE キーワード, Up: 応用プログラムインタフェース

PPCODE: キーワード
==================

`PPCODE:' キーワードは、 `CODE:' キーワードの別形式で、XSUB の返却値を
扱うために、引数スタックを制御するコードを用意していることを xsubpp コ
ンパイラに伝えるものです。単独の値よりも、値のリストを XSUB から返した
いこともあるでしょう。こういった場合には、 `PPCODE:' を使って、明示的
に値のリストをスタックにプッシュしなければなりません。 `PPCODE:' キー
ワードと `CODE:' キーワードは、同一の XSUB 内で同時に用いることはあり
ません。

次の XSUB では、C の `rpcb_gettime()' 関数を呼び、この関数からの二つの
出力値 `timep' と `status' を、一つのリストにして Perlに返しています。

     void rpcb_gettime(host)
          char *  host
          PPCODE:
          {
          time_t  timep;
          bool_t  status;
          status = rpcb_gettime( host, &timep );
          EXTEND(sp, 2);
          PUSHs(sv_2mortal(newSVnv(status)));
          PUSHs(sv_2mortal(newSVnv(timep)));
          }

実際に `rpcb_gettime()' を呼ぶためのコードと、返却値を正しく引数スタッ
ク上に置くためのコードを、用意しておかねばなりません。

この関数の型を `void' とすることで、 RETVAL 変数が必要ないか、使われな
いものであり、作る必要がないものであることを、xsubpp コンパイラに伝え
ることになります。関数型 `void' は、ほとんどの場合、 `PPCODE:' ディレ
クティブといっしょに使われるはずです。

引数スタック上に二つの返却値の場所を確保するために、 `EXTEND()' マクロ
を使っています。 `PPCODE:' ディレクティブの指定によって、xsubpp コンパ
イラが、sp というスタックポインタを作り、それが`EXTEND()' マクロ内で 
`this' ポインタとして使われます。その後、`PUSHs()' マクロで値を順にス
タックに積みます。

これで、以下のようにして、Perl から `rpcb_gettime()' 関数を呼ぶことが
できるようになりました。

     ($status, $timep) = rpcb_gettime("localhost");





File: perl-ja.info, Node: NO_INIT キーワード, Next: BOOT キーワード, Prev: PPCODE キーワード, Up: 応用プログラムインタフェース

NO_INIT キーワード
==================

`NO_INIT' キーワードは、ある関数引数が、出力値としてだけ使われることを
示すために用います。xsubpp コンパイラは、通常、引数スタックからすべて
の関数引数の値を読み取り、その関数のエントリ上の C 変数へ、代入を行な
うコードを生成します。 `NO_INIT' が指定されるとコンパイラは、ある引数
が入力ではなく、出力に使われ、関数が終了する前に処理されることを認識し
ます。

次の例では、 `rpcb_gettime()' 関数のバリエーションを示します。この関数
では、変数 TIMEP を出力のみの変数として使用していて、初期状態の値には
関与しません。

     bool_t
     rpcb_gettime(host,timep)
          char *  host
          time_t  &timep = NO_INIT
          OUTPUT:
          timep





File: perl-ja.info, Node: BOOT キーワード, Next: CLEANUP キーワード, Prev: NO_INIT キーワード, Up: 応用プログラムインタフェース

BOOT: キーワード
================

`BOOT:' キーワードは、拡張モジュールの `bootstrap' 関数にコードを追加
するために使用します。 `bootstrap' 関数は、xsubpp コンパイラによって作
られ、普通は Perl に任意の XSUB を登録するために必要な実行文が納められ
ています。 `BOOT:' キーワードを使うと、 `bootstrap' 関数にさらにの実行
文を付け加えるように xsubppコンパイラに伝えることができます。

このキーワードは、最初の `MODULE' キーワード以降であれば、どこでも使う
ことができ、行内に単独で使用します。このキーワード以降、最初の空行まで
が、コードを記述したブロックとなります。

     BOOT:
     # bootstrap 関数の実行時に、
     # 以下のメッセージが表示されます。
     printf("Hello from the bootstrap!\n");





File: perl-ja.info, Node: CLEANUP キーワード, Next: 関数引数の初期化, Prev: BOOT: キーワード, Up: 応用プログラムインタフェース

CLEANUP: キーワード
===================

このキーワードは、XSUB が終了する前に、特別な後処理を必要とする場合に
使われます。 `CLEANUP:' キーワードを使用する場合には、XSUB 内の、どの 
`CODE:' ブロック、 `PPCODE:' ブロック、 `OUTPUT:' セクションよりも後に
なければなりません。 `CLEANUP:' ブロックとして記述されるコードは、XSUB 
内の最後の実行文として、追加されます。





File: perl-ja.info, Node: 関数引数の初期化, Next: デフォルト引数値, Prev: CLEANUP キーワード, Up: 応用プログラムインタフェース

関数引数の初期化
================

関数の引数は、通常、引数スタックからの値で初期化されます。typemap には、
Perl の値を C の引数に変換するために使われる、コードを入れています。し
かし、プログラマの方で、 `typemap' をオーバライドして、別の初期化コー
ドを与えることができます。

次のコードでは、関数引数の初期化コードの与え方を示します。初期化コード
は、出力に加えられる前に、コンパイラによって評価されるので、ダブルクォー
トのようなものを文字どおりに解釈させたいときには、バックスラッシュで保
護しなければなりません。

     bool_t
     rpcb_gettime(host,timep)
          char *  host = (char *)SvPV(ST(0),na);
          time_t  &timep = 0;
          OUTPUT:
          timep

これは、引数のデフォルト値を指定するために、使うべきものではありません。
これは通常、関数引数を使用する前に、別のライブラリ関数で処理しなければ
ならないときに使います。デフォルト引数については、次の節で扱います。





File: perl-ja.info, Node: デフォルト引数値, Next: 可変長引数リスト, Prev: 関数引数の初期化, Up: 応用プログラムインタフェース

デフォルト引数値
================

関数の引数に対するデフォルト値は、引数リスト内に代入文を置くことで、指
定することができます。デフォルト値としては、数値か文字列を指定すること
ができます。デフォルトは、引数リストの右側の引数から順にしか指定できま
せん。

`rpcb_gettime()' に対する XSUB にデフォルトの HOST 値を持てるようにす
るには、XSUB への引数を並べ替えるとよいでしょう。その XSUB が、本当の 
`rpcb_gettime()' 関数を正しい引数順序で呼ぶことになります。Perl から、
この XSUB を呼ぶときには、次のどちらの形式でも使えることになります。

     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );

XSUB は次のようなものになるでしょう。 `CODE:' ブロックが、本当の 
`rpcb_gettime()' 関数を、正しい順序の引数で呼び出すために使われます。

     bool_t
     rpcb_gettime(timep,host="localhost")
          char *  host
          time_t  timep = NO_INIT
          CODE:
               RETVAL = rpcb_gettime( host, &timep );
          OUTPUT:
          timep
          RETVAL





File: perl-ja.info, Node: 可変長引数リスト, Next: Undef 値や空リストを返す, Prev: デフォルト引数値, Up: 応用プログラムインタフェース

可変長引数リスト
================

引数リストに省略記号 `(...)' を指定することで、XSUB は可変長の引数リス
トを持てるようになります。省略記号のこの使い方は、ANSI C のものと同様
です。xsubpp コンパイラが、すべてのXSUB に用意している変数 items を調
べることで、XSUB に渡された引数の数を知ることができます。この仕組みを
使って、大きさのわからない引数のリストを受け取る XSUB を作ることができ
ます。

`rpcb_gettime()' XSUB の host 引数は省略できますから、XSUB が可変個数
の引数をとれることを示すために、省略記号を使うことができます。Perl は、
この XSUB を次のどちらかの形式で呼び出すことができます。

     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );

省略記号を持つ XS コードです。

     bool_t
     rpcb_gettime(timep, ...)
          time_t  timep = NO_INIT
          CODE:
          {
          char *host = "localhost";

          if( items > 1 )
               host = (char *)SvPV(ST(1), na);
          RETVAL = rpcb_gettime( host, &timep );
          }
          OUTPUT:
          timep
          RETVAL





File: perl-ja.info, Node: Undef 値や空リストを返す, Next: コメントや C プリプロセッサディレクティブを使用する, Prev: 可変長引数リスト, Up: 応用プログラムインタフェース

Undef 値や空リストを返す
========================

関数の異常を示すために、状態変数を別に用意するよりも、単に`undef' 値や
空リストを返したい場合があります。 `rpcb_gettime()' 関数を、そのような
場合にあてはめてみましょう。この関数がうまくいったときには、時刻を返し、
問題があったときには、 `undef' 値を返すようにしてみましょう。次の Perl 
コードでは、 $TIMEP の値が `u' か有効な時刻のどちらかになることになり
ます。

$timep = rpcb_gettime( "localhost" );

次の XSUB では、関数型に `void' を用いて、RETVAL 変数を作らないように
し、 `CODE:' ブロックを使って、必要なコードはすべて用意していることを
コンパイラに示しています。 `sv_newmortal()' の呼び出しで返却値を 
`undef' で初期化し、これをデフォルトの返却値としています。

     void
     rpcb_gettime(host)
          char *  host
          CODE:
          {
          time_t  timep;
          bool_t x;
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep);
          }

次の例では必要となったときに、明示的に `undef' 値を返却値として設定す
る方法を示します。

     void
     rpcb_gettime(host)
          char *  host
          CODE:
          {
          time_t  timep;
          bool_t x;
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) ){
               sv_setnv( ST(0), (double)timep);
          }
          else{
               ST(0) = &sv_undef;
          }
          }

空リストを返すには、 `PPCODE:' ブロックを使ったうえで、スタック上に返
却値を積まないでおきます。

     void
     rpcb_gettime(host)
          char *  host
          PPCODE:
          {
          time_t  timep;
          if( rpcb_gettime( host, &timep ) )
               PUSHs(sv_2mortal(newSVnv(timep)));
          else{
          /* スタックに何も積まないので、 */
          /* 暗黙のうちに空リストが返される。 */
          }
          }





File: perl-ja.info, Node: コメントや C プリプロセッサディレクティブを使用する, Next: XS を C++ で使用する, Prev: Undef 値や空リストを返す, Up: 応用プログラムインタフェース

コメントや C プリプロセッサディレクティブを使用する
===================================================

`CODE:' ブロック、 `PPCODE:' ブロック、 `BOOT:' セクション、 
`CLEANUP:' ブロック内では、コメントや C プリプロセッサディレクティブを
記述することができます。コンパイラは、プリプロセッサディレクティブには
触れずに渡し、コメント行を削除します。行の最初に `#' を置くことで、
XSUB にコメントを入れることができます。コメントが、C のプリプロセッサ
ディレクティブに見えることの無いように注意し、そのように解釈されないよ
うにすべきです。





File: perl-ja.info, Node: XS を C++ で使用する, Next: Perl 変数, Prev: Undef 値や空リストを返す, Up: 応用プログラムインタフェース

XS を C++ で使用する
====================

関数が、C++ のメソッドとして定義されているときには、その最初の引数はオ
ブジェクトポインタとみなされます。オブジェクトポインタは、 THIS という
変数に入れられることになります。対象となるオブジェクトは、C++ の 
`new()' 関数で生成され、Perl の`sv_setptrobj()' マクロで `bless' され
たものです。Perl によるオブジェクトの `bless' は、`T_PTROBJ typemap' 
で扱うことができます。

メソッドが `static' で定義されているときには、その C++ の関数を 
`class::method()' という構文で呼び出すことになります。メソッドが 
`static' でないならば、その関数を `THIS->method()' という構文で呼び出
します。





File: perl-ja.info, Node: Perl 変数, Next: インタフェースの戦略, Prev: XS を C++ で使用する, Up: 応用プログラムインタフェース

Perl 変数
=========

これから、XSUB でどのように Perl の変数 `$host' をアクセスするかを示し
ます。 `perl_get_sv()' という関数が、内部的に `SV' (スカラ変数) といわ
れている変数へのポインタを得るために使用されます。変数の名前には、パッ
ケージ名 RPC が付け加えられますので、 `perl_get_sv()' で $host がどの
パッケージにあるかがわかります。パッケージ名がないときには、 
`perl_get_sv()' では、パッケージ `main' で変数を探すことになります。そ
れから、`SV' の内容への `char*' ポインタを取得するため、マクロ 
`SvPVX()' を使って `SV' の被参照を行ないます。

     void
     rpcb_gettime()
          PPCODE:
          {
          char *host;
          SV *hostsv;
          time_t timep;

          hostsv = perl_get_sv( "RPC::host", FALSE );
          if( hostsv != NULL ){
               host = SvPVX( hostsv );
               if( rpcb_gettime( host, &timep ) )
                    PUSHs(sv_2mortal(newSVnv(timep)));
          }
          }

この XSUB を呼ぶためには、次のような Perl コードを使います。

     $RPC::host = "localhost";
     $timep = rpcb_gettime();

上記の例では、`SV' に C の `char*' が入っていましたが、Perl のスカラ変
数には、数値やリファレンスも入れることができます。`SV' に C の `int' 
が入っているときには、`SV' の被参照にマクロ `SvIVX()' を使い、C の 
`double' が入っているときには、 `SvNVX()' を使います。

`SV' が Perl のリファレンスのときには、`SV' の被参照にマクロ`SvRV()' 
が使えます。結果は実際の Perl の変数を指す別の `SV'となります。これは、 
`SvPVX()' 、 `SvNVX()' 、 `SvIVX()' で被参照することができます。次の 
XSUB では、 `SvRV()' を使っています。

     void rpcb_gettime()
          PPCODE:
          {
          char *host;
          SV *rv;
          SV *hostsv;
          time_t timep;

          rv = perl_get_sv( "RPC::host", FALSE );
          if( rv != NULL ){
               hostsv = SvRV( rv );
               host = SvPVX( hostsv );
               if( rpcb_gettime( host, &timep ) )
                    PUSHs(sv_2mortal(newSVnv(timep)));
          }
          }

次の Perl コードは、 `$MY::host' へのリファレンスとなる、変数
$RPC::HOST を生成します。変数 $MY::HOST には、使用するホスト名が入って
います。

     $MY::host = "localhost";
     $RPC::host = \$MY::host;
     $timep = rpcb_gettime();

`perl_get_sv()' の第 2 引数は、上の例に示したように、通常は`FALSE' に
します。この引数を `TRUE' とすると、変数が存在しないときに、生成するよ
うになります。空の `SV' かも知れないものを扱うために段階を踏むのでなけ
れば、 `TRUE' は使用すべきではありません。

XSUB では、Per の配列値、ハッシュ値、コード値をアクセスするために、 
`perl_get_av()' 、 `perl_get_hv()' 、 `perl_get_cv()' を使うことができ
ます。





File: perl-ja.info, Node: インタフェースの戦略, Next: Perl モジュール, Prev: Perl 変数, Up: 応用プログラムインタフェース

インタフェースの戦略
====================

Perl と C ライブラリの間のインタフェースを設計する段階では、ほとんどの
場合、C から XS への直訳で十分です。そのインタフェースは、多くは C 風
のものとなり、特に C の関数が引数を変更するようなときには、直感的とは
いえないものとなります。もっと Perl 風なインタフェースを作りたい場合に
は、インタフェースが、どちら寄りに傾くかを左右するような部分を特定する
のに、以下のような戦略をとると良いでしょう。

引数を変更する C 関数を見つけること。こういった関数の XSUB は、Perl へ
リストを返すようにし、失敗時には `undef' や空リストを返すようにするこ
とができるでしょう。

C と XSUB の関数のみで使用される値を見つけなさい。Perl 側でその値の中
身に触れる必要がないのであれば、その値を C からPerl へ変換する必要もあ
りません。

C の関数の引数リストと返却値から、ポインタを探しなさい。ポインタによっ
ては、XS で変数名に単項演算子 `&' を付けて扱うことができますし、型名に 
`*' 演算子を使わなければならないものもあります。一般に、 `&' 演算子で
処理する方が簡単です。

C の関数で使われる構造体を特定しなさい。多くの場合、そのような構造体が 
`bless' されたオブジェクトとして Perl から扱えるように、`T_PTROBJ
typemap' をこの構造体に使うとよいでしょう。





File: perl-ja.info, Node: Perl モジュール, Next: Perl のオブジェクトと C の構造体, Prev: インタフェースの戦略, Up: 応用プログラムインタフェース

Perl モジュール
===============

Perl モジュールは、XS コードから作られた拡張ライブラリと、Perl インタ
プリタとの間をつなぐ役割を果たします。このモジュールを使って、Perl に
拡張ライブラリの内容を知らせるのです。モジュールの名前とパッケージは、
ライブラリの名前に合わせた方がよいでしょう。

以下は、あるONC+RPC 結合ライブラリ関数を拡張する Perl モジュールです。

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime rpcb_getmaps rpcb_getaddr
                     rpcb_rmtcall rpcb_set rpcb_unset );

     bootstrap RPC;
     1;

@EXPORT リスト内にある関数が、RPC 拡張に含まれています。RPC モジュール
は、Exporter モジュールを使って、これらの関数名がモジュール外の Perl 
プログラムからも見えるようにしています。DynaLoader モジュールによって、
RPC モジュールは、拡張ライブラリをブートストラップできるようにします。
この拡張機能を実際にロードし、関数を使えるようにするために、

     use RPC;

という Perl の実行文を使います。`DynaLoader' についてより詳しくは、
Perl のソースディレクトリの `ext/DynaLoader' にあるドキュメントを見て
ください。





File: perl-ja.info, Node: Perl のオブジェクトと C の構造体, Next: C のヘッダファイルと Perl, Prev: Perl モジュール, Up: 応用プログラムインタフェース

Perl のオブジェクトと C の構造体
================================

C の構造体を扱うときには、XS の型に `T_PTROBJ' か `T_PRTREF' を選択す
る必要があります。どちらの型も複雑なオブジェクトへのポインタを扱うよう
に設計されています。T_PTRREF 型では、Perl のオブジェクトが `bless' さ
れていなくてもよいが、T_PTROBJ 型では、オブジェクトが `bless' されてい
なければなりません。T_PTROBJ を使うことで、XSUB は Perl オブジェクトが
期待する型であることを確認するようになりますから、型チェックを行なうこ
とができます。

次の XS コードでは、 `getnetconfigent()' 関数を ONC TIRPC といっしょに
使っています。 `getnetconfigent()' 関数は、C の構造体へのポインタを返
すもので、以下のプロトタイプで示されるものです。この例では、C のポイン
タを Perl のリファレンスにする方法を示すことにします。Perl は、このリ
ファレンスを bless されたオブジェクトへのポインタとみなして、このオブ
ジェクトに対してデストラクタを起動しようとします。デストラクタは、
`getnetconfigent()' が使ったメモリを解放するために、XS ソース内で記述
しす。XS でのデストラクタは、DESTROY で終わる名前を持つ XSUB 関数を記
述することで作ることができます。XS デストラクタは、別の XSUB が 
`malloc' したメモリを、 `free' するために使うことができます。

     struct netconfig *getnetconfigent(const char *netid);

`struct netconfig' のために `typedef' を行なっています。Perlのオブジェ
クトは、C での型の名前に `Ptr' というタグを付けたものにマッチする名前
のクラスで `bless' され、その名前は、Perl のパッケージ名として使われる
ときには、空白を入れません。デストラクタは、そのオブジェクトの属するク
ラスに対応するクラスに置かれ、Perl 側では `DESTROY' という名前で参照さ
れますので、`PREFIX' キーワードを使用して関数名の先頭部分をみないよう
にします。

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     Netconfig *
     getnetconfigent(netid)
          char *  netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *  netconf
          CODE:
          printf("Now in NetconfigPtr::DESTROY\n");
          free( netconf );

この例には、次のような `typemap' のエントリが必要になります。拡張に際
して、新しい `typemap' を設けるときには、 *Note typemap::, の節の情報
も参考にしてください。

     TYPEMAP
     Netconfig *  T_PTROBJ

今回の例は、

     use RPC;
     $netconf = getnetconfigent("udp");

という Perl の文で使用されます。

Perl は $NETCONF で参照されるオブジェクトを消去するとき、そのオブジェ
クトを用意された XSUB DESTROY 関数に送ります。Perl では、このオブジェ
クトが C の構造体であって、Perl のオブジェクトではないと知るすべがあり
ませんし、関与もしません。この意味で、 `getnetconfigent()' XSUB で作ら
れたオブジェクトと、普通の Perl のサブルーティンで作られたオブジェクト
の区別はありません。





File: perl-ja.info, Node: C のヘッダファイルと Perl, Next: 新しい拡張モジュールの作成, Prev: Perl のオブジェクトと C の構造体, Up: 応用プログラムインタフェース

C のヘッダファイルと Perl
=========================

h2xs コンパイラは、 `/usr/include' の C のヘッダファイルを Perlの拡張
モジュールに変換するために設計されています。このコンパイラは、Perl ソー
スの ext ディレクトリの下に、ディレクトリを作り、ここに `Mekefile' 、
Perl モジュール、XS ソースファイル、`MANIFEST' ファイルを入れます。

次のコマンドは、 `<rpcsvc/rusers.h>' ヘッダから、Rusers という拡張モ
ジュールを作ります。

     h2xs rpcsvc/rusers

Rusers 拡張モジュールがコンパイルされ、インストールされると、C のヘッ
ダにあった `#define' 文を Perl から参照するために、このモジュールを使
うことができます。

     use Rusers;
     print "RPC program number for rusers service: ";
     print &RUSERSPROG, "\n";





File: perl-ja.info, Node: 新しい拡張モジュールの作成, Next: Typemap, Prev: C のヘッダファイルと Perl, Up: 応用プログラムインタフェース

新しい拡張モジュールの作成
==========================

h2xs コンパイラは、テンプレートのソースファイルと `Mekefile' を生成で
きます。多くの拡張モジュールで、このテンプレートを叩き台として使うこと
ができます。以下の例では、このドキュメントの RPC 関数を含む拡張モジュー
ルを生成するために、どのように h2xs を使うのかを示します。

この拡張モジュールでは、自動ロード関数を使用しておらず、定数の定義もし
ていませんから、 `-A' オプションを h2xs に付けています。Perl のソース
ディレクトリで実行すると、h2xs コンパイラは、 `ext/RPC' ディレクトリを
作成し、 `RPC.xs' 、 `RPC.pm' 、 `Makefile.PL' 、`MANIFEST' というファ
イルをそこに置きます。RPC 関数の XS コードは、 `RPC.xs' ファイルに付け
加えます。 `RPC.pm' の `@EXPORT' リストは、 `RPC.xs' から、その関数を
インクルードするように更新しておきます。

     h2xs -An RPC

動的ローディングを行なう拡張モジュールのコンパイルには、

     make dynamic

というコマンドを `ext/RPC' ディレクトリで実行します。拡張モジュールを 
Perl のバイナリに静的にリンクする場合には、Perlのソースディレクトリの 
`makefile' ( `Makefile' ではなく、 `makefile' を使います) を編集して、 
`ext/RPC/RPC.a' を STATIC_EXT 変数に追加します。この変更を行なう前に、
Perl を作ってないといけません。 `makefile' を更新したあとで、

     make

というコマンドを、Perl のソースディレクトリで実行します。

拡張モジュールを追加するために、Perl の Configure スクリプトを使うこと
もできます。この場合、Perl を作成する前に、Configure の実行に先立って、
拡張モジュールを Perl のソースディレクトリの ext ディレクトリに置いて
おく必要があります。Configure を実行するときに、他の拡張モジュール共々、
この拡張モジュールが ext ディレクトリで発見されると、作成される拡張モ
ジュールのリストに加えられます。make が実行されると、この拡張モジュー
ルも、他の拡張モジュールといっしょに、組み込まれることになります。

Configure は、拡張モジュールが、そのディレクトリ名と一致するXS ソース
ファイルを用意しているときに、その存在を認識します。Configure は、Perl 
ソースディレクトリの `MANIFEST' にあげられている、すべての `.SH' ファ
イルを抽出した後で、拡張モジュールのディレクトリにも `MANIFEST' ファイ
ルがあると、そのファイルでも `.SH' ファイルを探して抽出します。その後、
Perl のソースディレクトリの `Makefile' が、拡張モジュールのディレクト
リ名に一致する XS ファイルを見つけると、そのディレクトリで make を実行
します。





File: perl-ja.info, Node: Typemap, Next: XS の使用例, Prev: 新しい拡張モジュールの作成, Up: 応用プログラムインタフェース

Typemap
=======

`typemap' は、xsubpp コンパイラが、C の関数の引数や値を Perlの値にマッ
ピングするために使用する、コードを集めたものです。`typemap' ファイルは、 
`TYPEMAP'、`INPUT'、`OUTPUT' というラベルを付けた、3 つのセクションに
分けることができます。`INPUT' セクションは、Perl の値を、特定の型の C 
の変数に変換する方法を、コンパイラに伝えるものです。 `OUTPUT' セクショ
ンは、特定の型のC の値から、Perl が認識できる値に変換する方法をコンパ
イラに伝えます。 `TYPEMAP' セクションでは、与えられた C の型を Perlの
値にマッピングするために、どの `INPUT' コードと `OUTPUT' コードを使用
するかを、コンパイラに教えます。 `typemap' のどのセクションも、
`TYPEMAP'、`INPUT'、`OUTPUT' のいずれかのキーワードで始まることになり
ます。

Perl のソースディレクトリの `ext' ディレクトリにあるデフォルトの 
`typemap' には、Perl の拡張モジュールで使用することができる便利な型を
たくさん入れてあります。拡張モジュールによっては、自分のディレクトリに、
追加の `typemap' を定義して置いているものもあります。そのような追加の 
`typemap' は、デフォルトの`typemap' の `INPUT' と `OUTPUT' のマッピン
グを参照することができます。xsubpp コンパイラでは、デフォルトの 
`typemap' のマッピングが、拡張モジュールの `typemap' でオーバライドす
ることが許されています。

独自の `typemap' を必要とする拡張モジュールでは、ほとんどの場合、 
`typemap' ファイルの `TYPEMAP' セクションだけが必要になります。 
`getnetconfigent()' の例で示した独自 `typemap' は、拡張モジュールの 
`typemap' の使用例としては、典型的なものかもしれません。この `typemap' 
は、C の構造体と T_PTROBJ typemap を等しいものとして扱うために使われて
ます。 `getnetconfigent()' で使った `typemap' を再掲します。C の型は、
XS の型とタブで区切られ、C の単項演算子 `*' は、C の型名の一部とみなさ
れます。

     TYPEMAP
     Netconfig *<tab>T_PTROBJ





File: perl-ja.info, Node: XS の使用例, Prev: Typemap, Up: 応用プログラムインタフェース

XS の使用例
===========


ファイル `RPC.xs' : いくつかの ONC+ RPC 結合ライブラリ関数へのインタフェース
----------------------------------------------------------------------------

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"

     #include <rpc/rpc.h>

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     void
     rpcb_gettime(host="localhost")
          char *  host
          CODE:
          {
          time_t  timep;
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep );
          }

     Netconfig *
     getnetconfigent(netid="udp")
          char *  netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *  netconf
          CODE:
          printf("NetconfigPtr::DESTROY\n");
          free( netconf );




ファイル `typemap' : `RPC.xs' のための独自 typemap。
----------------------------------------------------

     TYPEMAP
     Netconfig *  T_PTROBJ




ファイル `RPC.pm' : RPC 拡張のための Perl モジュール。
------------------------------------------------------

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);

     bootstrap RPC;
     1;




ファイル `rpctest.pl' : RPC 拡張のための Perl テストプログラム。
----------------------------------------------------------------

     use RPC;

     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print "time = $a\n";
     print "netconf = $netconf\n";

     $netconf = getnetconfigent("tcp");
     $a = rpcb_gettime("poplar");
     print "time = $a\n";
     print "netconf = $netconf\n";




File: perl-ja.info, Node: 拡張を行なうための内部関数, Next: C からの呼び出し法, Prev: 応用プログラムインタフェース, Up: Top

拡張を行なうための内部関数
**************************

このドキュメントでは Perl の実行ファイルの内部関数をいくつか記述してい
ます。完璧なものではありませんし、間違いも多いと思います。疑問点やコメ
ントは後に示す著者に行なってください。

* Menu:

* データ型::
* IV とは::
* SV の操作::
* プライベート値とバブリック値::
* AV を使う::
* HV を使う::
* 内部関数でリファレンスを使う::
* XSUB と引数スタック::
* 揮発性::
* 新しい変数の生成::
* スタッシュとオブジェクト::
* マジック::
* 二重に型をもつ SV::
* C プログラムから Perl ルーティンを呼び出す::
* Memory Allocation::


AUTHOR
======

Jeff Okamoto <okamoto@corp.hp.com>

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, and Neil
Bowers.


DATE
====
Version 12: 1994/10/16




File: perl-ja.info, Node: データ型, Next: IV とは, Prev: 拡張を行なうための内部関数, Up: 拡張を行なうための内部関数

データ型
========

Perl では、主となる 3 つのデータ型を扱うために 3 つの `typedef' を行なっ
ています:

   SV スカラ値
   AV 配列値
   HV ハッシュ値

それぞれの `typedef' には様々なデータ型を操作するための特別なルーティ
ンが用意されています。





File: perl-ja.info, Node: IV とは, Next: SV の操作, Prev: データ型, Up: 拡張を行なうための内部関数

IV とは
=======

Perl では、整数でもポインタでも十分に入れることのできる、特別な 
`typedef IV' を使います。

Perl ではまた、常に 32 bit の整数となる特別な `typedef I32' も使用しま
す。





File: perl-ja.info, Node: SV の操作, Next: プライベート値とバブリック値, Prev: IV とは, Up: 拡張を行なうための内部関数

SV の操作
=========

SV は、1 つのコマンドで生成し、値をロードすることができます。ロードで
きる値の型には、整数 (IV)、倍精度 (NV)、文字列 (PV)、その他のスカラ 
(SV) があります。

これらを行なう、4 つのルーティンは:

     SV*  newSViv(IV);
     SV*  newSVnv(double);
     SV*  newSVpv(char*, int);
     SV*  newSVsv(SV*);

です。「既に存在する」スカラの値を変更するために 5 つのルーティンがあ
ります:

     void  sv_setiv(SV*, IV);
     void  sv_setnv(SV*, double);
     void  sv_setpvn(SV*, char*, int)
     void  sv_setpv(SV*, char*);
     void  sv_setsv(SV*, SV*);

`sv_setpvn' を使って、代入される文字列の長さを指定することもできますし、 
`sv_setpv' を使って Perl に長さを算出させることもできます。ただし、
sv_setpv は、文字列の長さを `NUL' 文字で終了することに依存する 
`strlen' を使って算出することに注意しなくてはなりません。

SV が指し示す実際の値をアクセスするには、実際のスカラの型を強制的に IV 
や倍精度や文字列にする、

     SvIV(SV*)
     SvNV(SV*)
     SvPV(SV*, STRLEN len)

というマクロを使うことができます。

`SvPV' マクロでは、返される文字列の長さは、変数 LEN に納められます (こ
れはマクロですので、 `&len' としないでください)。もし、データの長さを
気にしないのであれば、グローバル変数 na を使ってください。ただし、Perl 
では `NUL' を含む文字列も、 `NUL' で終端しない文字列も許されるというこ
とを忘れないでください。

単にスカラ値が真かどうかを知りたいだけならば、

     SvTRUE(SV*)

を使うことができます。

Perl では、SV にもっとメモリを割り当てて欲しいときには、自動的に文字列
を大きくしてくれますが、まだメモリを割り当てないといけないかを判断して
くれる、

     SvGROW(SV*, STRLEN newlen)

というマクロが使えます。もし必要なら、このマクロが sv_grow を呼びます。 
`SvGROW' は SV に割り当てたメモリを増やすだけで、減らすことはできませ
ん。

手元にある SV の Perl から見た、データの種類を知りたいときには、その 
SV の型チェックに、

     SvIOK(SV*)
     SvNOK(SV*)
     SvPOK(SV*)

というマクロを使うことができます。

SV に納められた文字列の、現在長を取得したり設定したりするには、以下の
マクロが使います。

     SvCUR(SV*)
     SvCUR_set(SV*, I32 val)

ただし、これらは `SvPOK()' が真のときだけ有効です。

もし、スカラ変数の名前がわかるならば、その SV へのポインタは、

     SV*  perl_get_sv("varname", FALSE);

を使って得られます。その変数が存在しなければ、 `NULL' が返されます。

その変数 (あるいは、他の任意の SV) が、実際に定義されているかを知りた
いならば、

     SvOK(SV*)

を呼び出してください。

スカラの `undef' 値は、 `sv_undef' という SV インスタンスに納められて
います。そのアドレスは、 `SV*' が必要とされるところで使用することがで
きます。

ブール値の真と偽を表わす、 `sv_yes' と `sv_no' という値もあります。
`sv_undef' と同様に、これらのアドレスも `SV*' が必要なところで、使うこ
とができます。

`(SV *0)' が `&sv_undef' が同じであると考えて、だまされてはいけません。
次のようなコードを見てください:

     SV* sv = (SV*) 0;
     if (I-am-to-return-a-real-value) {
             sv = sv_2mortal(newSViv(42));
     }
     sv_setsv(ST(0), sv);

このコードは、実値を返さなければならないときには、(値として42 を持つ) 
新しい SV を返そうとし、さもなくば `undef' を返そうとします。ですが、
どこかの行でヌルポインタを返して、セグメントバイオレーションが起こるか、
何かおかしな結果になってしまいます。最初の行の `0' を `&sv_undef' に変
えれば、すべてが旨くいきます。

生成した SV を解放するためには、 `SvREFCNT_dec(SV*)' を呼びます。普通
は、この呼び出しは必要ありません。「 *Note 揮発性::, 」の章を参照して
ください。





File: perl-ja.info, Node: プライベート値とバブリック値, Next: AV を使う, Prev: SV の操作, Up: 拡張を行なうための内部関数

プライベート値とバブリック値
============================

自分で持っていれるスカラの型を決定する通常の方法は、マクロ `Sv[INP]OK' 
を使うのでした。スカラは数値にも文字列にもなり得ますから、普通、これら
のマクロはいつも真を返し、`Sv[INV]V' マクロを呼ぶことで、文字列から整
数/倍精度、整数/倍精度から文字列への変換を行ないます。

もし、本当に SV にあるのが整数か、倍精度か、文字列ポインタかを知りたい
のであれば、代わりに、

     SvIOKp(SV*)
     SvNOKp(SV*)
     SvPOKp(SV*)

というマクロを使うことができます。これらは、実際に SV に入っているもの
が整数か、倍精度か、文字列ポインタかを教えてくれます。

しかし、一般には、 `Sv[INP]V' マクロを使うだけにした方が良いでしょう。




File: perl-ja.info, Node: AV を使う, Next: HV を使う, Prev: プライベート値とバブリック値, Up: 拡張を行なうための内部関数

AV を使う
=========

AV を生成して、値を設定するのには、2 つの方法があります。最初の方法は、
単に空の AV を作るものです:

     AV*  newAV();

ふたつめの方法は、AV を生成した上で、初期値として SV の値を入れます:

     AV*  av_make(I32 num, SV **ptr);

ふたつめの引数は、num 個の `SV*' の配列を指しています。

いったん、AV が生成されると、AV に対して、

     void  av_push(AV*, SV*);
     SV*   av_pop(AV*);
     SV*   av_shift(AV*);
     void  av_unshift(AV*, I32 num);

といった操作が行えます。これらは、 `av_unshift' を除いては、お馴染みの
演算でしょう。 `av_unshift' は、配列の先頭に、num 個の `undef' 値の要
素を付け加えます。その後で、(あとで述べる) `av_store' を使って、新しい
要素に値を代入しなければなりません。他にもいくつか関数があります:

     I32 av_len(AV*); /* 配列の大きさを返す */
     SV** av_fetch(AV*, I32 key, I32 lval);
            /* オフセットが key の位置から値を取り出すが、lval
               がゼロでないとき、値を lval に設定するようだ */
     SV** av_store(AV*, I32 key, SV* val);
            /* オフセットが key の位置に val を設定する */
     void av_clear(AV*);
            /* すべての要素をクリアするが、配列は残す */
     void av_undef(AV*);
            /* 全要素を除去し、配列を未定義にする */

配列変数の名前がわかるのであれば、

     AV*  perl_get_av("varname", FALSE);

を使えば、AV へのポインタが得られます。その変数が存在しなければ、NULL 
を返します。





File: perl-ja.info, Node: HV を使う, Next: 内部関数でリファレンスを使う, Prev: AV を使う, Up: 拡張を行なうための内部関数

HV を使う
=========

HV を生成するには、

     HV* newHV();

というルーティンを使います。いったん、HV が生成されると、HV に対して、

     SV** hv_store(HV*, char* key, U32 klen, SV* val, U32 hash);
     SV** hv_fetch(HV*, char* key, U32 klen, I32 lval);

という操作が行えます。引数 klen は、渡される key の長さです。引数 val 
は、設定されるスカラへの SV ポインタを入れ、hash は、あらかじめ計算し
たハッシュ値 (hv_store に計算させる場合には、ゼロ) です。引数 lval で、
このフェッチ操作が、実はストア操作の一部であるかを示します。

`hv_store' や `hv_fetch' は、SV** を返すもので、SV* ではないことに注意
してください。スカラ値をアクセスするには、まず返却値を被参照する必要が
あります。しかし、その前に返却値が NULLでないことを確認すべきです。

ハッシュテーブルのエントリが存在するかをチェックし、削除する関数があり
ます。

     bool hv_exists(HV*, char* key, U32 klen);
     SV* hv_delete(HV*, char* key, U32 klen);

そして、その他の諸々の関数:

     void hv_clear(HV*);
           /* ハッシュテーブルのすべてのエントリをクリアする */
     void hv_undef(HV*);
           /* ハッシュテーブルを未定義にする */

     I32 hv_iterinit(HV*);
           /* ハッシュテーブルを走査する開始点を準備する */

     HE* hv_iternext(HV*);
           /* 次のエントリを取り出し、key と value が入った
              構造体へのポインタを返す */
     char* hv_iterkey(HE* entry, I32* retlen);
           /* HE 構造体から key を取り出し、また、key 文字
              列の長さを返す */
     SV* hv_iterval(HV*, HE* entry);
           /* HE 構造体の value への SV ポインタを返す */

ハッシュ変数の名前がわかるのであれば、

     HV* perl_get_hv("varname", FALSE);

を使うことで、HV へのポインタが得られます。その変数が存在しなければ、
NULL を返します。

(興味ある方のために、) ハッシュのアルゴリズムは、

     i = klen;
     hash = 0;
     s = key;
     while (i--)
     hash = hash * 33 + *s++;

となっています。





File: perl-ja.info, Node: 内部関数でリファレンスを使う, Next: XSUB と引数スタック, Prev: HV を使う, Up: 拡張を行なうための内部関数

リファレンス
============

リファレンスは、(リファレンスを含む) 他のスカラ型を指す、特別なスカラ
型です。AV や HV をスカラとして扱うには、単に AVや HV を SV にキャスト
するだけのことです。

リファレンスを生成するには、

     SV* newRV((SV*) pointer);

というコマンドを使います。いったん、リファレンスができると、適切な 
`typedef (AV, AV, HV)' へのキャストを用いて、

     SvRV(SV*)

というマクロが使うことができ、返された SV* を AV* か HV* にキャストし
て、適切なルーティンを呼ぶことになります。

リファレンスを被参照した後も、まだリファレンスであるかを調べるには、

     SvROK(SV*)

というマクロが使えます。





File: perl-ja.info, Node: XSUB と引数スタック, Next: 揮発性, Prev: 内部関数でリファレンスを使う, Up: 拡張を行なうための内部関数

XSUB と引数スタック
===================

XSUB の仕組みは、Perl プログラムが C のサブルーティンをアクセスするた
めの単純な方法です。XSUB には、Perl プログラムからの引数を入れるスタッ
クと、Perl のデータ構造を C の同等なものにマッピングする方法を用意して
います。

スタック引数は、ST(n) というマクロでアクセスできます。これは、n 番目の
スタック引数を返すものです。引数 0 は、Perl のサブルーティン呼び出しで
渡された、最初の引数です。これらの引数は SV* で、SV* が使われるところ
であれば、どこでも使うことができます。

ほとんどの場合には、C ルーティンからの出力は、RETVAL とOUTPUT: ディレ
クティブを使って扱うことができます。しかし、引数スタックのスペースがす
べての返却値を扱うのに、十分でなくなる場合があります。例としては、引数
をとらないで、ローカルなタイムゾーンと、夏時間の省略形の二つの返却値を
返す、POSIX tzname() の呼び出しがあります。

このような状況を扱うためには、PPCODE: ディレクティブを使い、

     EXTEND(sp, num);

というマクロを使ってスタックを拡張します。ここで、sp はスタックポイン
タで、num はスタックを拡張すべき要素の数です。

スタック上に場所を確保したならば、IV、倍精度、文字列、SV ポインタをプッ
シュする、

     PUSHi(IV)
     PUSHn(double)
     PUSHp(char*, I32)
     PUSHs(SV*)

というマクロを使って、値をスタックへプッシュします。

これで、tzname をよぶ Perl プログラムでは、二つの値は、

     ($standard_abbrev, $summer_abbrev) = POSIX::tzname;

というように代入できます。スタックに値を積む、別の (おそらく、より簡単
な) 方法は、

     XPUSHi(IV)
     XPUSHn(double)
     XPUSHp(char*, I32)
     XPUSHs(SV*)

というマクロを使うものです。こちらのマクロは、必要ならば、自動的にスタッ
クを調整してくれます。





File: perl-ja.info, Node: 揮発性, Next: 新しい変数の生成, Prev: XSUB と引数スタック, Up: 拡張を行なうための内部関数

揮発性
======

Perl では、値は通常「不揮発な」ものです。つまり、(Perl の undef 呼び出
しや、Perl 自身で他のルーティンを通じて) 明示的に解放しない限り、解放
されることはありません。

先の tzname の例では、文字列であるところの、二つの新しい SV を引数スタッ
クに積むために、生成する必要がありました。しかし、これらは最終的にはス
カラ変数を保持する SV にコピーされますから、新しい SV に永久に固執する
ものではありません。

「揮発性」の SV (あるいは、AV や HV) は、普通の「不揮発性」の SV、AV、
HV と全く同じように動作しますが、「現在の文脈」でしか有効ではないもの
です。Perl インタプリタが現在の文脈を離れると、揮発性の SV、AV、HV は
自動的に解放されます。一般に「現在の文脈」というのは、Perl の一つの実
行文を表わします。

揮発性の変数を生成するには、

     SV* sv_newmortal()
     SV* sv_2mortal(SV*)
     SV* sv_mortalcopy(SV*)

という関数を使います。最初のものは揮発性の SV を生成し、ふたつめは、既
にある SV を揮発性の SV に変換します。三つめは、既に存在する SV の揮発
性のコピーを生成します。

揮発性のルーティンは、単に SV のためだけではありません。AVや HV も、
sv_2mortal や sv_mortalcopy ルーティンに、アドレスを (SV* にキャストし
て) 渡すことで、揮発性にすることができます。






File: perl-ja.info, Node: 新しい変数の生成, Next: スタッシュとオブジェクト, Prev: 揮発性, Up: 拡張を行なうための内部関数

新しい変数の生成
================

Perl スクリプトからアクセスできる、新しい Perl の変数を生成するには、
変数の型に応じて、

     SV* perl_get_sv("varname", TRUE);
     AV* perl_get_av("varname", TRUE);
     HV* perl_get_hv("varname", TRUE);

というルーティンを使用します。二番目の引数としては TRUE を使います。新
しい変数は、データの型に合ったルーティンを使って、設定することができま
す。





File: perl-ja.info, Node: スタッシュとオブジェクト, Next: マジック, Prev: 新しい変数の生成, Up: 拡張を行なうための内部関数

スタッシュとオブジェクト
========================

スタッシュとは、パッケージ内にある、すべての異なるオブジェクトが入って
いるハッシュテーブル (連想配列) のことです。ハッシュテーブルの個々の 
key は、(同じ名前のすべての異なる型のオブジェクトで共有される) シンボ
ル名で、ハッシュテーブルの個々の value は、(グローバル値のための) GV 
と呼ばれます。GV には、

   スカラ値
   配列値
   ハッシュ値
   ファイルハンドル
   ディレクトリハンドル
   フォーマット
   サブルーティン

を含む (これらに限りませんが)、その名前の様々なオブジェクトへのリファ
レンスが次々に入ることになります。

Perl は、(グローバル変数のための) GV 構造体に様々なスタッシュを入れま
すが、それらは、HV 構造体で表されます。

特定のパッケージの HV ポインタの入手には、

     HV* gv_stashpv(char* name, I32 create)
     HV* gv_stashsv(SV*, I32 create)

という関数を使います。最初の関数が、リテラル文字列をとり、二番目が SV 
に入れた文字列を使います。

`gv_stash*v' が使う name は、シンボルテーブルを手に入れようとするパッ
ケージの名前です。デフォルトのパッケージは、`main' というものです。多
重にネストしたパッケージであれば、Perl での場合と同様に、:: で区切って 
gv_stash*v に名前を渡すのが正しい方法です。

もし、`bless' されたリファレンスである SV があれば、

     HV* SvSTASH(SvRV(SV*));

を使っても、スタッシュポインタを探すことができ、パッケージ名自身は、

     char* HvNAME(HV* stash);

で得られます。

Perl スクリプトへ `bless' された値を返す必要があれば、

     SV* sv_bless(SV*, HV* stash)

という関数が使えます。最初の引数 SV* は、リファレンス、二番目の引数が
スタッシュです。返された SV* は、他の SV と同様に使うことができます。





File: perl-ja.info, Node: マジック, Next: 二重に型をもつ SV, Prev: スタッシュとオブジェクト, Up: 拡張を行なうための内部関数

マジック
========

[執筆中]





File: perl-ja.info, Node: 二重に型をもつ SV, Next: C プログラムから Perl ルーティンを呼び出す, Prev: マジック, Up: 拡張を行なうための内部関数

二重に型をもつ SV
=================

スカラ変数は、通常、整数、倍精度、ポインタ、リファレンスのいずれか 1 
つの型をとります。Perl は、実際のデータに対して、蓄積されている型から、
要求されている型へ、自動的に変換を行ないます。

ある種のスカラ変数は、複数の型のスカラデータを持つようになっています。
たとえば、変数 `$!' は、`errno' の数値としての値と、`sys_errlist[]' か
ら取り出した同値な文字列を持っています。

SV に複数のデータ値を入れるようにするには、2 つのことをしなくてはなり
ません。スカラ型を別に追加するために、`sv_set*v'ルーティンを使用するこ
と。それから、フラグを設定して Perlに複数のデータを持っていることを知
らせることです。フラグを設定するための 4 つのマクロは:

     SvIOK_on
     SvNOK_on
     SvPOK_on
     SvROK_on

です。使用するマクロは、最初にどの `sv_set*v' ルーティンを呼ぶのかに関
わってきます。これは、 `sv_set*v' ルーティンはすべて、特定のデータ型の
ビットだけを設定し、他をクリアしてしまうからです。

たとえば、"dberror" という新しい Perl 変数を作って、エラー値を数値とメッ
セージ文字列で持つようにするには、以下のように書きます:

     extern int  dberror;
     extern char *dberror_list;

     SV* sv = perl_get_sv("dberror", TRUE);
     sv_setiv(sv, (IV) dberror);
     sv_setpv(sv, dberror_list[dberror]);
     SvIOK_on(sv);

もし、 `sv_setiv' と `sv_setpv' の順序が逆であれば、 `SvIOK_on' マクロ
の代わりに、 `SvPOK_on' マクロを呼ばなければなりません。





File: perl-ja.info, Node: C プログラムから Perl ルーティンを呼び出す, Next: Memory Allocation, Prev: 二重に型をもつ SV, Up: 拡張を行なうための内部関数

C プログラムから Perl ルーティンを呼び出す
==========================================

C プログラムから、Perl サブルーティンを呼び出すために使用することので
きるルーティンが 4 つあります。その 4 つは:

     I32  perl_call_sv(SV*, I32);
     I32  perl_call_pv(char*, I32);
     I32  perl_call_method(char*, I32);
     I32  perl_call_argv(char*, I32, register char**);

です。最もよく使われるはずのものは、 `perl_call_sv ' です。引数 SV* に
は、呼び出される Perl サブルーティンの名前か、そのサブルーティンへのリ
ファレンスを含むものです。2 番目の引数は、Perl サブルーティンが返す値
があれば、それがどんなものかを該当ルーティンに知らせます。

4 つのルーティンはいずれも、サブルーティンが Perl スタック上に返した引
数の数を返します。

これら 4 つのルーティンを使うときには、プログラマが Perl スタックを操
作しなくてはなりません。以下のマクロと関数が用意されています:

     dSP
     PUSHMARK()
     PUTBACK
     SPAGAIN
     ENTER
     SAVETMPS
     FREETMPS
     LEAVE
     XPUSH*()

詳しくは *Note C からの呼び出し法::, を参照してください。





File: perl-ja.info, Node: Memory Allocation, Prev: C プログラムから Perl ルーティンを呼び出す, Up: 拡張を行なうための内部関数

Memory Allocation
=================

[執筆中]




File: perl-ja.info, Node: C からの呼び出し法, Next: 多重定義, Prev: 拡張を行なうための内部関数, Up: Top

C からの呼び出し法
******************

WARNING: このドキュメントは、現在まだ作成中です。不正確な点が、たくさ
んあることは確実ですので、とうぶんは、注意して読むようにしてください。

このドキュメントの目的は、「コールバック」の書き方、すなわち、どのよう
に C から Perl を呼び出すかを示すことです。中心となるのは、Perl によっ
て実行される、ほんのわずかの C のコードから Perl を呼び戻すインタフェー
ス、つまり、`main' プログラムは Perl スクリプトで、そこから C で書いた
コードを起動し、その C のコードが何かを行なうときに、特定のイベントに
よって、Perl sub を実行するということが、いつでもできるようにしておく
ことが必要でしょう。

必要に応じて、例を示すようにしてあります

   * アプリケーションの C API へのインタフェース XSUB を作成しました。

     アプリケーションでかなり一般的な機能として、なにか面倒が起こった
     ときに、呼ぶことのできる C の関数を定義することができるようにする
     ことがあげられます。やりたいことは、代わりに Perl sub を呼ぶとい
     うことです。

   * どこでコールバックが使われるかの古典的な例は、X Window System の
     ようなイベントドリブンなプログラムに見られます。この場合、登録内
     容は、マウスのボタンが押されたような、特定のイベントが発生したと
     きに呼ばれるように機能します。

記述したテクニックは、Perl プログラムを C プログラムに埋め込むときにも
適用することができますが、これは、このドキュメントの本来の目的ではあり
ません。C に埋め込む Perl に関する詳細は、 perlembed manpage (現在執筆
中) を参照してください。

このドキュメントの残りの部分に進む前に、以下の 2 つのドキュメントを読
んでおいた方が良いでしょう。- *Note 応用プログラムインタフェース::,と
*Note 拡張を行なうための内部関数::,です。

内容は、例を用いて、やさしく説明しています。しかし、まず、とにかく定義
をいくつかしておきましょう。

* Menu:

* 呼び出しの定義::
* フラグ値::
* 呼び出しの例::
* コンテキスト情報を蓄える方策::
* 別のスタック操作::



SEE ALSO
========
*Note 応用プログラムインタフェース::,、*Note 拡張を行なうための内部関
数::,、perlembed manpage


AUTHOR
======
Paul Marquess <pmarquess@bfsec.bt.co.uk>

ドキュメントの作成に協力してくれた、次の方々に感謝します。

Jeff Okamoto, Tim Bunce.


DATE
====
Version 0.4, 17th October 1994





File: perl-ja.info, Node: 呼び出しの定義, Next: フラグ値, Prev: C からの呼び出し法, Up: C からの呼び出し法

呼び出しの定義
==============

Perl では、Perl sub を呼ぶことを許している C の関数がたくさんあります。
それは、

     I32 perl_call_sv(SV* sv, I32 flags) ;
     I32 perl_call_pv(char *subname, I32 flags) ;
     I32 perl_call_method(char *methname, I32 flags) ;
     I32 perl_call_argv(char *subname, I32 flags, register char **argv) ;

中心となる関数は、 `perl_call_sv' です。他の関数は、自分のやりたいこと
に合わせて、 `perl_call_sv' を利用します。 `perl_call_sv' は、2 つの引
数をとり、最初の引数は、 `SV*' です。これによって、呼び出される Perl
sub を C の文字列 (まず、SV に変換されています) か、sub へのリファレン
スで指定することができます。例 7 では、自ら `perl_call_sv' を利用する
方法を示します。2 番目のパラメータ `flags' は、汎用のオプションコマン
ドです。このパラメータは、すべての `perl_call_*' 関数に共通です。詳し
くは、次の節で述べます。

関数 `perl_call_pv' は、ほぼ `perl_call_sv' と同じですが、最初の引数と
して呼び出したい Perl sub を示す C の `char *' を指定します。例:
`perl_call_pv("fred", 0)'

関数 `perl_call_method' は、最初の引数に、 `bless' された、クラスへの
リファレンスを指定しなければなりません。そのリファレンスを使って検索し、
該当クラスから `methname' を呼び出します。*Note 例 9. perl_call_method 
を使う::, を参照。

`perl_call_argv' は、 `subname' パラメータで指定された Perl sub を呼び
出します。これはまた、通常の `flags' パラメータも指定します。最後のパ
ラメータ `argv' には、Perl sub に渡される C の文字列のリストを指定しま
す。 *Note 例 8. perl_call_argv を使う::, を参照してください。

すべての関数は、数を返します。これは、Perl sub がスタック上に置いた、
返却物の数を示します。

一般論として、これらの関数からの返却値は「常に」チェックしてください。
Perl sub から特定の数が返って来ることを期待している場合にも、誰かがな
にか期待以外のことをしないとは限りません。「そんなの聞いていない」とは
言わないでください。





File: perl-ja.info, Node: フラグ値, Next: 呼び出しの例, Prev: 呼び出しの定義, Up: C からの呼び出し法

フラグ値
========

すべての perl_call_* 関数のパラメータ flags は、以下に定義するシンボル
を「論理和」で組み合わせて用います。

G_SCALAR
     Perl sub をスカラコンテキストで呼び出します。

     Perl sub が実際に何を返そうとも、スカラのみが必要と解釈されます。
     Perl sub がスカラを返したときには、 `perl_call_*' 関数の返却値は、 
     `1' か `0' になります。 `1' ならば、Perl subが実際に返した値は、
     スタックのトップにあります。 `0' ならば、 `sub' で `die' を呼んだ
     か、 `G_DISCARD' フラグを設定したことを示します。Perl sub がリス
     トを返すときにも、 `perl_call_*' 関数は、 `0' か `1' を返します。 
     `1' であれば、リストの要素の数がスタックのトップに置かれます。実
     際のリストの値には、アクセスできなくなります。

     `G_SCALAR' は、すべての関数で、デフォルトで設定されているフラグで
     す。

G_ARRAY
     Perl sub をリストコンテキストで呼び出します。

     `perl_call_*' 関数からの返却値は、積まれた配列がスタックを何要素
     使ったかを示します。

G_DISCARD
     Perl sub からの返却値が必要ないときには、このフラグを設定すること
     で、Perl が自動的に廃棄してくれます。このフラグは、 `G_SCALAR' や 
     `G_ARRAY' よりも優先されます。

     このフラグを設定しなかった場合には、一時的な値を明示的に自分で処
     分する必要があるかもしれません。詳細は、*Note 例 3. スカラを返す::,
     を参照してください。

G_NOARGS
     Perl sub に対して、何の引数も渡さないときには、このフラグを設定す
     ることで、時間を少し稼ぐことができます。これは、Perl sub に対して、
     新しく `@_' を生成しないという効果があります。

     言うまでもないことですが、このフラグが指定された場合にも、呼び出
     された Perl sub からは、上位の Perl sub の `@_' をアクセスするこ
     とができます。この機能は、以下のような perl コードで確かめること
     ができます。

          sub fred
            { print "@_\n"  }

          sub joe
            { &fred }

          &joe(1,2,3) ;

     とすると

          1 2 3

     と表示します。 `joe' に属している配列 `@_' を `fred' からアクセス
     したのです。

G_EVAL
     呼び出す Perl sub が、 `die' を呼んだり、実際に `exit' するなど、
     通常ではない終了の仕方をすることがあり、そのようなイベントを捕捉
     したいようなときに、このフラグを設定します。 `sub' の呼び出しを 
     `eval {}' で囲ったような状態にする働きがあります。

     `perl_call_*' 関数から制御が戻ったときには、通常 Perl スクリプト
     で行なうように、変数 $@ をチェックする必要があります。チェックの
     仕方については、*Note 例 6. G_EVAL を使う::,を参照してください。





File: perl-ja.info, Node: 呼び出しの例, Next: 例 1. パラメータなし、返却値なし, Prev: フラグ値, Up: C からの呼び出し法

呼び出しの例
============

定義の話は十分でしょうから、いくつか例を示します。

Perl では、Perl スタックをアクセスする手助けのためのマクロをたくさん用
意しています。Perl の内部ルーティンとのインタフェースには、常にこれら
のマクロを使うようにすべきでしょう。将来 Perl に施される変更に対しても、
これを使うことで、コードの方への影響が少なくなるはずです。

もう一つ余計なことを言っておくと、最初のいくつかの例では、
`perl_call_pv' 関数だけを使っています。これは、単にみなさんがこの話題
に入り込みやすいようにと考えただけのことです。`perl_call_pv' と 
`perl_call_sv' のどちらも使える場合、私は常に`perl_call_sv ' を使いま
す。

これらの例のコードは、`perlcall.tar' というファイルに納められています。
(いったん、このドキュメントが落ち着いたら、すべての例のコードをファイ
ルに入れるようにします。)

* Menu:

* 例 1. パラメータなし、返却値なし::
* 例 2. パラメータを渡す::
* 例 3. スカラを返す::
* 例 4. リスト値を返す::
* 例 5. Perl から引数リストを介してデータを返す::
* 例 6. G_EVAL を使う::
* 例 7. perl_call_sv を使う::
* 例 8. perl_call_argv を使う::
* 例 9. perl_call_method を使う::





File: perl-ja.info, Node: 例 1. パラメータなし、返却値なし, Next: 例 2. パラメータを渡す, Prev: 呼び出しの例, Up: C からの呼び出し法

例 1: パラメータなし、返却値なし
--------------------------------

最初の明快な例は、プロセスの `UID' を出力するために、Perl subの 
`PrintUID' を呼びます。

     sub PrintUID
     {
         print "UID is $<\n" ;
     }

と、これを呼ぶ C 側です

     void
     call_PrintUID()
     {
         dSP ;

         PUSHMARK(sp) ;
         perl_call_pv("PrintUID", G_DISCARD|G_NOARGS) ;
     }

単純でしょう。

この例についていくつか注意点をあげておきましょう。

  1. `PrintUID' に引数を渡しませんので、 `G_NOARGS' を指定できます。

  2. 今のところ、 `dSP' と `PUSHMARK(sp)' は無視してください。これにつ
     いては、次の例でお話します。

  3. `PrintUID' から返されるものは、特に必要ありませんので、
     `G_DISCARD' を指定しています。 `PrintUID' が何か値を返すように変
     更されても、 `G_DISCARD' を指定しておくと、 `perl_ call_pv' から
     制御が戻るときに、その値が捨てられることになります。

  4. `G_DISCARD' を指定しましたので、 `perl_call_sv' からの返却値をチェッ
     クする必要はありません。常に `0' となります。

  5. `perl_call_pv' が使われていますから、Perl sub は C の文字列として
     表現されています。





File: perl-ja.info, Node: 例 2. パラメータを渡す, Next: 例 3. スカラを返す, Prev: 例 1. パラメータなし、返却値なし, Up: C からの呼び出し法

例 2: パラメータを渡す
----------------------

さて、今度はもう少し込み入った例です。今回は、2 つの引数として、文字列 
`($a)' と整数 `($n)' をとる Perl sub を呼び出してみましょう。 ``sub'' 
では、簡単に、文字列の最初の $N 文字を出力します。

Perl sub は以下のようなものです:

     sub LeftString
     {
         my($s, $n) = @_ ;
         print substr($s, 0, $n), "\n" ;
     }

`LeftString' を呼ぶための C の関数は、以下のようです:

     static void
     call_LeftString(a, b)
     char * a ;
     int b ;
     {
         dSP ;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSVpv(a, 0)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         perl_call_pv("LeftString", G_DISCARD);
     }

C の関数 `call_LeftString' の注意点を示します。

  1. 今回指定しているフラグは、G_DISCARD のみです。今回、Perl sub に 2 
     つのパラメータを渡しますので、G_NOARGS は指定していません。

  2. パラメータは、Perl スタックを使って Perl sub に渡されます。これが、
     dSP で始め、PUTBACK 行で終わるコードの目的です。

  3. Perl スタックに何かをおこうとする場合には、どこにおけばよいかを知
     る必要があります。これが、マクロ dSP の目的で、Perl スタックポイ
     ンタのローカルなコピーを宣言し、初期化します。

     この例で使う、他のすべてのマクロは、このマクロの使用を前提にして
     います。

     Perl sub を直接 XSUB 関数から呼ぶときには、明示的に dSPマクロを使
     う必要はありません。自動的に宣言されます。

  4. スタック上に積まれるパラメータはすべて、 `PUSHMARK' マクロと 
     `PUTBACK' マクロで囲まなければなりません。この 2 つのマクロは、こ
     の文脈では、自動的にプッシュした引数の数を数えるために使われます。
     それで、Perl が sub に対して @_ 配列を作るときには、その大きさが
     わかるという仕組みになっているのです。

     `PUSHMARK' マクロは、Perl に対して、内的にその時点のスタックポイ
     ンタに注目するように伝えます。(*Note 例 1. パラメータなし、返却値
     なし::,の場合のように) 引数を渡さない場合であっても、 
     `perl_call_*' 関数を呼ぶ場合には、その前に `PUSHMARK' マクロを呼
     ばなくてはなりません。Perl からすると、引数がないことを知る必要が
     あるのです。

     少し先へ飛んで、 `PUTBACK' マクロは、グローバルなスタックポインタ
     を、先に作ったローカルなものに合わせます。これを行わないと、どこ
     に引数を置いたか、 `perl_call_pv' が判断することができません。こ
     こまで、すべてのスタックポインタの操作は、ローカルなものに対して
     行なってきたのであって、グローバルなものは触っていなかったのです。

  5. 元に戻って、次に `XPUSH' を引数分呼んでいます。ここで、実際に引数
     がスタックに積まれます。今回の場合、文字列と整数を積んでいます。

     `XPUSH' マクロがどのように動作するのかについて詳しくは、*Note 拡
     張を行なうための内部関数::,の「*Note XSUB と引数スタック::,」の項
     を参照してください。

  6. ここまでで、 `LeftString' を `perl_call_pv' 関数を介して呼ぶこと
     ができます。





File: perl-ja.info, Node: 例 3. スカラを返す, Next: 例 4. リスト値を返す, Prev: 例 2. パラメータを渡す, Up: C からの呼び出し法

例 3: スカラを返す
------------------

さて、Perl sub からの返却値を扱う例を見てみましょう。

ここにあげる Perl sub は、2 つの整数引数をとって、単にその和を返す 
`Adder' というものです。

     sub Adder
     {
         my($a, $b) = @_ ;
         $a + $b ;
     }

`Adder' からの返却値を扱う必要がありますので、C 関数側は今回、多少複雑
になります。

     static void
     call_Adder(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;

         ENTER ;
         SAVETMPS;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSViv(a)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         count = perl_call_pv("Adder", G_SCALAR);

         SPAGAIN ;

         if (count != 1)
             croak("Big trouble\n") ;

         printf ("The sum of %d and %d is %d\n", a, b, POPi) ;

         PUTBACK ;
         FREETMPS ;
         LEAVE ;
     }


注意点は、

  1. 今回は、フラグとして `G_SCALAR' だけを使用しています。これは、 @_ 
     配列が作られ、 `Adder' からの返された値は、 `perl_call_pv' の呼び
     出し後も存在することを表わします。

  2. `Adder' から返されるものに意味がありますから、 `G_DISCARD' を指定
     することはできません。つまり、自分で Perl スタックをきちんと整理
     して、一時的な値も廃棄する必要があります。これが、関数の最初で、

          ENTER ;
          SAVETMPS ;

     として、最後に

          FREETMPS ;
          LEAVE ;

     としていることの目的です。 `ENTER'/ `SAVETMPS' のペアが、使用する
     一時的な領域を作ります。逆にいうと、自分で廃棄できるものは、これ
     らを呼び出した後に作ったものに限定されるということです。

     `FREETMPS' / `LEAVE' のペアは、Perl sub が返した値を捨て、生成し
     た `SV' について、解放直前の情報をダンプします。コードの最初に 
     `ENTER' / `SAVETMPS ' をおくことで、それ以上の開放情報が壊される
     のを防ぎます。

  3. `SPAGAIN' マクロの目的は、ローカルなスタックポインタをリフレッシュ
     することです。 `perl_call_pv' の呼び出しの間に再配置された Perl 
     スタックへメモリ配置を行なうことができますから、これが必要になり
     ます。

     コードの中で Perl スタックポインタを利用する場合には、
     `perl_call_*' 関数や他の Perl の内部関数を利用するときには必ず、 
     `SPAGAIN' を使ってローカルなポインタをリフレッシュしなくてはなり
     ません。

  4. `Adder' から返されるのは、単一の値のみのはずですが、いずれにして
     も `perl_call_pv' からの返却値をチェックするのが良いでしょう。

     単一の値を期待するのは、一つであることを知っていることとは違いま
     す。誰かが `Adder' を改造して、リストを返すようにし、その可能性を
     チェックしていなかったときに、この操作を行なってしまうと、Perl ス
     タックの状態は、矛盾したものになってしまいます。こんなことは、誰
     も望みはしないでしょう。

  5. スタックから、返却値をポップするのに、ここでは `POPi' マクロを使
     用しています。ここでは整数が必要であったため、`POPi' を使用したの
     です。

     返された値の型に応じて、以下の `POP' マクロを使用することができま
     す。

          POPs    SV
          POPp    ポインタ
          POPn    倍精度
          POPi    整数
          POPl    long 整数


  6. 最後の `PUTBACK' は、関数を抜ける前に、Perl スタックを矛盾の無い
     状態にしておくために使用しています。これは、`POPi' でスタックから
     返却値を取り出したときに、ローカルなスタックポインタのみを更新す
     るため、必要となります。先の例で説明したように `PUTBACK' は、グロー
     バルなスタックポインタをローカルなスタックポインタの値にあわせる
     ように設定します。




File: perl-ja.info, Node: 例 4. リスト値を返す, Next: 例 5. Perl から引数リストを介してデータを返す, Prev: 例 3. スカラを返す, Up: C からの呼び出し法

例 4: リスト値を返す
--------------------

さて、今度は、先の例を改造して、2 つの引数の和と差の両方を返すようにし
てみましょう。

Perl sub は

     sub AddSubtract
     {
        my($a, $b) = @_ ;
        ($a+$b, $a-$b) ;
     }

のようになり、C 関数は

     static void
     call_AddSubtract(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;

         ENTER ;
         SAVETMPS;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSViv(a)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         count = perl_call_pv("AddSubtract", G_ARRAY);

         SPAGAIN ;

         if (count != 2)
             croak("Big trouble\n") ;

         printf ("%d - %d = %d\n", a, b, POPi) ;
         printf ("%d + %d = %d\n", a, b, POPi) ;

         PUTBACK ;
         FREETMPS ;
         LEAVE ;
     }

となります。

注意点

  1. リストコンテキストが必要なため、 `G_ARRAY' を使用します。

  2. スタックから 2 つの値を取り出すため、今回 2 つの `POPi' を使って
     いることは、驚くに値しないでしょう。それよりも、注目すべきは、ス
     タックから取り出したときに逆順となることです。reverse order.





File: perl-ja.info, Node: 例 5. Perl から引数リストを介してデータを返す, Next: 例 6. G_EVAL を使う, Prev: 例 4. リスト値を返す, Up: C からの呼び出し法

例 5: Perl から引数リストを介してデータを返す
---------------------------------------------

引数リストを使って直接値を返すことも可能です。ただし、これが実際に望ま
しい方法であるか、否かについては、まったく別の問題です。

以下の Perl sub `Inc' は、2 つの引数をとり、それぞれをインクリメントし
ます。

     sub Inc
     {
         ++ $_[0] ;
         ++ $_[1] ;
     }

そして、これを呼び出す C 関数です。

     static void
     call_Inc(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;
         SV * sva ;
         SV * svb ;

         ENTER ;
         SAVETMPS;

         sva = sv_2mortal(newSViv(a)) ;
         svb = sv_2mortal(newSViv(b)) ;

         PUSHMARK(sp) ;
         XPUSHs(sva);
         XPUSHs(svb);
         PUTBACK ;

         count = perl_call_pv("Inc", G_DISCARD);

         if (count != 0)
             croak ("call_Inc : expected 0 return "
                       "value from 'Inc', got %d\n", count) ;

         printf ("%d + 1 = %d\n", a, SvIV(sva)) ;
         printf ("%d + 1 = %d\n", b, SvIV(svb)) ;

         FREETMPS ;
         LEAVE ;
     }

`perl_call_pv' からリターンした後で、スタック上にプッシュされた 2 つの
パラメータにアクセスするために、これらのアドレスを記録しておく必要があ
ります。このため 2 つの変数 SVA と SVB を使っています。

これらの値を保持する Perl スタックのエリアは、 `perl_call_pv' から制御
が戻るときまでに、何ものかによって破壊されていることが十分に有り得るか
ら、こういった操作が必要になるのです。





File: perl-ja.info, Node: 例 6. G_EVAL を使う, Next: 例 7. perl_call_sv を使う, Prev: 例 5. Perl から引数リストを介してデータを返す, Up: C からの呼び出し法

例 6: G_EVAL を使う
-------------------

今度は `G_EVAL' を使う例です。以下は、2 つの引数の差を計算する Perl
sub です。結果が負になると、sub は `die' を呼びます。

     sub Subtract
     {
         my ($a, $b) = @_ ;
         die "death can be fatal\n" if $a < $b ;

         $a - $b ;
     }

これを呼ぶ C の方は、

     static void
     call_Subtract(a, b)
     int a ;
     int b ;
     {
         dSP ;
         int count ;
         SV * sv ;

         ENTER ;
         SAVETMPS;

         PUSHMARK(sp) ;
         XPUSHs(sv_2mortal(newSViv(a)));
         XPUSHs(sv_2mortal(newSViv(b)));
         PUTBACK ;

         count = perl_call_pv("Subtract", G_EVAL|G_SCALAR);

         /* Check the eval first */
         sv = GvSV(gv_fetchpv("@", TRUE, SVt_PV));
         if (SvTRUE(sv))
             printf ("Uh oh - %s\n", SvPV(sv, na)) ;

         SPAGAIN ;

         if (count != 1)
             croak ("call_Subtract : expected 1 return "
                       "value from 'Subtract', got %d\n", count) ;

         printf ("%d - %d = %d\n", a, b, POPi) ;

         PUTBACK ;
         FREETMPS ;
         LEAVE ;

     }

となります。CALL_SUBTRACT が

     call_Subtract(4, 5)

のように呼ばれると、以下のように表示されます。

     Uh oh - death can be fatal 注意点

  1. `die' を捉えるために、 `G_EVAL' フラグを使用しました。このフラグ
     を使用しないと、プログラムは途中終了してしまいます。

  2. C 関数の中の

          sv = GvSV(gv_fetchpv("@", TRUE, SVt_PV));
          if (SvTRUE(sv))
              printf ("Uh oh - %s\n", SvPVx(sv, na)) ;

     という部分は、Perl の書くところの

          print "Uh oh - $@\n" if $@ ;

     と同じことになります。




File: perl-ja.info, Node: 例 7. perl_call_sv を使う, Next: 例 8. perl_call_argv を使う, Prev: 例 6. G_EVAL を使う, Up: C からの呼び出し法

例 7: perl_call_sv を使う
-------------------------

これまでの例では、Perl sub の名前を C から呼ばれるように扱ってきました。
ですが、ときには Perl スクリプトの中から、Perl sub の名前を指定するこ
とができないと、困ることがあります。

     sub fred
     {
         print "Hello there\n" ;
     }

     CallSub("fred") ;

のような Perl コードを考えてみましょう。 `CallSub' を定義する`XSUB' の
一部は、

     void
     CallSub(name)
             char *  name
             CODE:
             PUSHMARK(sp) ;
             perl_call_pv(name, G_DISCARD|G_NOARGS) ;

のようになります。今のところは、これで良いのかもしれません。問題は、
Perl sub が文字列でしか表現できないということです。Perl 4 では、これで
十分なのですが、Perl 5 では sub へのリファレンスや無名の sub が許され
ています。そういった場合に、`perl_call_sv' が役に立つのです。

次の `CallSub' のコードは、先のものと同一ですが、引数 NAME を`SV*' で
定義し、 `perl_call_pv' の代わりに `perl_call_sv' を使っています。

     void
     CallSub(name)
             SV*     name
             CODE:
             PUSHMARK(sp) ;
             perl_call_sv(name, G_DISCARD|G_NOARGS) ;

`fred' を呼ぶのに `SV' を使っていますから、Perl 側では、

     CallSub("fred") ;
     Callsub(\&fred) ;
     $ref = \&fred ;
     CallSub($ref) ;
     CallSub( sub { print "Hello there\n" } ) ;

といった記法が、すべて可能になります。ご覧のように、perl_ call_sv を使
えば、Perl sub をかなり柔軟に指定することができるようになります。





File: perl-ja.info, Node: 例 8. perl_call_argv を使う, Next: 例 9. perl_call_method を使う, Prev: 例 7. perl_call_sv を使う, Up: C からの呼び出し法

例 8: perl_call_argv を使う
---------------------------

次にあげるのは、渡された引数を表示する Perl sub です。

     sub PrintList
     {
         my(@list) = @_ ;

         foreach (@list) { print "$_\n" }
     }

そして、 `PrintList' を呼ぶ `perl_call_argv' の例です。

     call_PrintList
     {
         dSP ;
         char * words[] = {"alpha", "beta", "gamma", "delta", NULL } ;

         perl_call_argv("PrintList", words, G_DISCARD) ;
     }

注目したいのは、この場合には、 `PUSHMARK' を呼ぶ必要がないということで
す。 `perl_call_argv' 側で自動的に行なうからです。





File: perl-ja.info, Node: 例 9. perl_call_method を使う, Next: コンテキスト情報を蓄える方策, Prev: 例 8. perl_call_argv を使う, Up: C からの呼び出し法

例 9: perl_call_method を使う
-----------------------------

[この節は執筆中]

以下のような Perl コードを考えてみましょう。

     {
       package Mine ;

       sub new     { bless [@_] }
       sub Display { print $_[0][1], "\n" }
     }

     $a = new Mine ('red', 'green', 'blue') ;
     call_Display($a, 'Display') ;

メソッド `Display' は、単にリストの最初の要素を出力するものです。そし
て、 `call_Display' の `XSUB' インプリメンテーションです。

     void
     call_Display(ref, method)
         SV *    ref
         char *  method
         CODE:
         PUSHMARK(sp);
         XPUSHs(ref);
         PUTBACK;

         perl_call_method(method, G_DISCARD) ;





File: perl-ja.info, Node: コンテキスト情報を蓄える方策, Next: 別のスタック操作, Prev: 呼び出しの例, Up: C からの呼び出し法

コンテキスト情報を蓄える方策
============================

[この節は執筆中]

コールバックを設計するときに克服すべき、陥りやすい問題の一つは、C のコー
ルバック関数と Perl の同等のものの間での対応を覚えておく方法を見つける
ことです。

以下の例を考えてください。....





File: perl-ja.info, Node: 別のスタック操作, Prev: コンテキスト情報を蓄える方策, Up: C からの呼び出し法

別のスタック操作
================

[この節は執筆中]

Perl sub から返された値をアクセスするために、POP* マクロだけを使ってき
ましたが、これらのマクロを使わずに、直接スタックを読むこともできます。

以下のコードは ....




File: perl-ja.info, Node: 多重定義, Next: 書籍の情報, Prev: C からの呼び出し法, Up: Top

多重定義
********

     package SomeThing;

     %OVERLOAD = (
         '+' => \&myadd,
         '-' => \&mysub,
         # etc
     );
     ...

     package main;
     $a = new SomeThing 57;
     $b=5+$a;

* Menu:

* 多重定義関数の宣言::
* 二項演算子の呼び出し方::
* 単項演算子の呼び出し方::
* 多重定義可能な演算子::
* %OVERLOAD の特殊 key::
* マジック自動生成::
* 多重定義の警告::
* 多重定義の実装::
* 多重定義の診断::
* 多重定義のバグ::


警告
====
演算子の多重定義は、軽くは考えられない問題です。詳細なインプリメンテー
ションも、構文も、内容も 100% Larry Wall が支持しているものではありま
せん。したがって、これらは、将来のいつの時点かに変更される可能性もあり
ます。


AUTHOR
======
Ilya Zakharevich <ilya@math.mps.ohio-state.edu>.





File: perl-ja.info, Node: 多重定義関数の宣言, Next: 二項演算子の呼び出し方, Prev: 多重定義, Up: 多重定義

多重定義関数の宣言
==================

     package Number;
     %OVERLOAD = (
         "+" => \&add,
         "*=" => "muas"
     );

では、加法の関数 `Number::add()' と「クラス」Number (あるいは、基底ク
ラスの 1 つ) の中の乗法の代入形式 `*=' のメソッド `muas' を宣言してい
ます。このハッシュの value としては、 `&{ ... }' の中で使用できるもの
がすべてを指定できますから、サブルーティン名、サブルーティンへのリファ
レンス、無名のサブルーティンといったものがすべて使えます。

`$a+$b' を実行するときに、$A がパッケージ `Number' 内に `bless' された
オブジェクトへのリファレンスである場合か、$A がそのようなマスマジカル
な加法を用意しているパッケージのオブジェクトでなくても、 `$b' が 
Number へのリファレンスである場合に、サブルーティン `$OVERLOAD{"+"}' 
が呼び出されます。これは、 `$a+=7' とか `$a++' といった、シチュエーショ
ンでも呼ばれます。「*Note マジック自動生成::,」の節を参照してください。
(「マスマジカル」という言葉は、*Note 多重定義::, されたマスマティカル
演算子によって起動されるメソッドを指しています。)





File: perl-ja.info, Node: 二項演算子の呼び出し方, Next: 単項演算子の呼び出し方, Prev: 多重定義関数の宣言, Up: 多重定義

二項演算子の呼び出し方
======================

`%OVERLOAD' の value の関数は、3 つ (唯一特別な場合があって、その時は4
つ(「*Note 最後の楽園::,」の節を参照))の引数で呼び出されます。対応する
演算子が、 二項演算子であれば、最初の 2 つの引数は、その演算子の 2 つ
の引数です。しかしながら、通常のオブジェクトメソッドの呼び出し法の規則
によって、最初の引数は、常にそのパッケージのオブジェクトでなければなり
ませんので、`7+$a' のような場合には、引数の順序の入れ替えが行なわれま
す。これは、加法のメソッドのインプリメンテーションについては、おそらく
問題にはならないものですが、減法のメソッドにとっては、引数を入替えるか
否かは、非常に重大な問題です。サブルーティン側では、この引数の入れ替え
についての情報を3つめの引数を調べることで、確かめることができます。こ
の引数は、3種類の値をとります:

偽
     引数の順序は、現在の演算子でのものと同じである。

真
     引数は、逆になっている。

undef
     現在の演算子は、( `$a+=7' のような) 代入形式のものであるが、普通
     の関数が、代わりに呼ばれる。この付加的な情報は、何らかの最適化を
     行なうときに、使用することができる。





File: perl-ja.info, Node: 単項演算子の呼び出し方, Next: 多重定義可能な演算子, Prev: 二項演算子の呼び出し方, Up: 多重定義

単項演算子の呼び出し方
======================

単項演算子は、2 番目の引数が未定義値の二項演算子であると考えられます。
つまり、 `$OVERLOAD{"++"}' は、 `$a++' が実行されるときに、 `($a,
undef , ")' という引数で呼び出されます。





File: perl-ja.info, Node: 多重定義可能な演算子, Next: %OVERLOAD の特殊 key, Prev: 単項演算子の呼び出し方, Up: 多重定義

多重定義可能な演算子
====================

ハッシュ `%OVERLOAD' では、以下の key が認識されます:

   * <算術演算子>

     `+', `+=', `-', `-=', `*', `*=', `/', `/=', `%', `%=', `**',
     `**=', `<<', `<<=', `>>', `>>=', `x', `x=', ` .', `.=',

     これらの演算子について、代入形式のものが存在しないときには、代わ
     りに非代入形式のものが呼ばれます。演算子 `+', `-', `+=', `-=' に
     対するメソッドは、インクリメント演算子やデクリメント演算子を自動
     生成するために呼ばれることがあります。演算子 `-' は、単項のマイナ
     スや `abs' のメソッドがないときに自動生成するために使われます。

   * <比較演算子>

     `<', `<=', `>', `>=', `==', `!=', `<=>', `lt', `le', `gt', `ge',
     `eq', `ne', `cmp',

     ある演算子が無い場合にも、対応する「スペースシップ」形式が使える
     ならば、代わりに使うことができます。配列のソートのときには、
     `%OVERLAOD' のもとの `cmp' を使って値を比較します。

   * <ビット演算子>

     `&', `^', `|', `neg', `!', `~',

     `neg' は、単項のマイナスを表わします。`neg' のメソッドが指定され
     ていないときには、引き算のメソッドを使って、自動生成されます。

   * <インクリメントとデクリメント>

     `++', `--',

     未定義であれば、足し算と引き算のメソッドが代わりに使われます。こ
     れらの演算子は、プリフィクスとしても、ポストフィクスとしても使わ
     れます。

   * <超越関数>

     `atan2', `cos', `sin', `exp', `abs', `log', `sqrt',

     `abs' がないときには、`<' か `<=>' のメソッドを、単項のマイナスか
     引き算のメソッドと組み合わせて、自動生成されます。

   * ブール変換、文字列変換、数値変換

     `bool', `""', `0+',

     これらの中で定義していないものがあっても、残りが一つでも定義して
     あれば、それを代わりに使うことができます。`bool' は、( `while' の
     ような) フロー制御演算子や、三項演算子 `?:' で使われます。これら
     の関数は、任意の Perl値を返すことができます。この値に対応する演算
     子も多重定義されている場合には、その演算子がその時の値を使って、
     再度呼び出されることになります。

   * <特殊 key>

     `nomethod', `fallback', `=',

     「*Note %OVERLOAD の特殊 key::,」の章を参照してください。

見つからなかったメソッドが、いつ自動生成されるかという点についての説明
は、 *Note Fallback::,を参照してください。





File: perl-ja.info, Node: %OVERLOAD の特殊 key, Next: マジック自動生成, Prev: 多重定義可能な演算子, Up: 多重定義

`%OVERLOAD' の特殊 key
======================

ここまでに説明してきたものの他に、3 つの key が Perl に認識されます。

* Menu:

* 最後の楽園::
* Fallback::
* コピーコンストラクタ::





File: perl-ja.info, Node: 最後の楽園, Next: Fallback, Prev: %OVERLOAD の特殊 key, Up: %OVERLOAD の特殊 key

最後の楽園
----------

`$OVERLOAD{"nomethod"}' は、4つのパラメータを持つ関数へのリファレンス
です。これが定義されていれば、多重定義の仕組みで、何らかの演算子に対す
るメソッドを見つけることができなかったときに、呼び出されます。この関数
の最初の3つの引数は、本来、呼ばれるはずだったメソッドに対する引数と一
致し、4番目の引数は、見つからなかったメソッドに対応する `%OVERLOAD' の 
key となります。いくつかのメソッドが試されている場合には、最後のものが
使われます。たとえば、 `1-$a' であれば、

     &{ $Pack::OVERLOAD{"nomethod"} }($a,1,1,"-").

とするのと同じかもしれません。

何らかの演算子が見つからず、`$OVERLOAD{"nomethod"}' もない場合には、(
`$OVERLOAD{"fallback"}' が真でない限り、) `die()' による例外が発生しま
す。




File: perl-ja.info, Node: Fallback, Next: コピーコンストラクタ, Prev: 最後の楽園, Up: %OVERLOAD の特殊 key

Fallback
--------

`$OVERLOAD{"fallback"}' は、特定の演算子に対するメソッドが見つからない
場合の動作を規定します。 `$OVERLOAD{"fallback"}' の value によって、3
つの場合があります:

   * 未定義

     Perl は、代替のメソッドを使うことを試みます(「*Note マジック自動
     生成::,」の節を参照してください)。それもダメならば、 
     `$OVERLOAD{"nomethod"}' を呼び出そうとします。これも無い場合には、
     例外が発生することになります。

   * 「真」

     未定義の場合と同じですが、例外を発生させません。この場合、黙って、
     もし `%OVERLOAD' がなかったときに、行なってであろう動作に戻される
     ことになります。

   * 定義済みだが「偽」

     マジック自動生成は行ないません。Perl は、まず 
     `$OVERLOAD{"nomethod"}' の実行を試みて、これがなければ、例外を発
     生させます。





File: perl-ja.info, Node: コピーコンストラクタ, Prev: Fallback, Up: %OVERLOAD の特殊 key

コピーコンストラクタ
--------------------

`$OVERLOAD{"="}' は、3 引数の関数へのリファレンスです。すなわち、見か
け上は普通の `%OVERLOAD' の `value' と同じです。このサブルーティンの特
殊な点は、(他の多くのメソッドが期待されているように) `bless' された、
パッケージへのリファレンスを返す必要がありませんが、被参照した引数の新
しいコピーをかえします(ただし、*Note 多重定義のバグ::, をみてください)。
この演算は、

     $a=$b;
     $a++;

のような、他のリファレンスとオブジェクトを共有するリファレンスに対して、
ミューテーターを使うときに呼び出されます。これを、 `$a' を変更し、 
`$b' を変更しないようにするために、 `$$a' の新しいコピーを作り、このオ
ブジェクトへのリファレンスが `$a' に代入されます。この操作は、`$a++' 
の実行中に (すなわち、その前に`$$a' が `$$b' に一致します)、 `++' が 
`$OPERATOR{'++'}' か `$OPERATOR{'+='}' で表現されているときにだけ行な
われます。この演算子が、`+' を使って、

     $a=$b;
     $a=$a+1;

のように表現されていれば、 `$$a' も `$$b' も、左辺値として現われること
はありません。

コピーコンストラクタが、いくつかのミューテーターの実行中に必要となって、
`$OPERATOR{'='}' が見つからないときには、そのパッケージのオブジェクト
が単なるスカラであれば、文字列コピーとして自動生成されます。





File: perl-ja.info, Node: マジック自動生成, Next: 多重定義の警告, Prev: %OVERLOAD の特殊 key, Up: 多重定義

マジック自動生成
================

演算子に対するメソッドが見つからず、 `$OVERLOAD{"fallback"}' が「真」
か「未定義」であれば、Perl は、定義されている演算子をもとに、見つから
なかった演算子の代わりのメソッドを自動生成しようと試みます。以下の演算
子に対して、自動生成代替メソッドが行なえます:

算術演算子の代入形式
     `$OVERLOAD{"+="}' が定義されていないとき、`$a=+$b' は、 
     `$OVERLOAD{"+"}' メソッドを使うことができます。

変換演算子
     文字列、数値、ブール値変換は、すべてが定義されてはいないとき、互
     いに別のもので計算されます。

インクリメントとデクリメント
     演算 `++$a' は、 `$a+=1' か `$a+1' で、演算 `$a--' は、`$a-=1' か 
     $a-1 で表現することができます。

`abs($a)'
     `abs($a)' は、 `$a<0' と ` `-$a' ' (または `0-$a' ) で表現できま
     す。

単項のマイナス
     単項のマイナスは、引き算を使って表現できます。

連結
     連結は、文字列変換を使って表現できます。

比較演算子
     比較演算は、それぞれに対応するスペースシップ演算 ( `<=>' か `cmp'
     ) を用いて表現することができます: `<', `>', `<=', `>=', `==',
     `!=' は、 `<=>' を使う`lt', `gt', `le', `ge', `eq', `ne' は、 
     `cmp' を使う

コピー演算
     コピー演算は被参照した値が、 リファレンスではないスカラであれば、
     その値への代入という形で表現できます。





File: perl-ja.info, Node: 多重定義の警告, Next: 多重定義の実装, Prev: マジック自動生成, Up: 多重定義

多重定義の警告
==============

比較演算子に対する制限は、たとえば、`cmp' が `bless' されたリファレン
スを返さなければならないとしても、自動生成された関数`lt' は、`cmp' の
結果の数値に基づく標準の論理値だけを作り出します。特に、この場合には、
(ときには別の変換で表わされた)数値変換が使えないといけません。

同様に、 `.=' 演算子や `x=' 演算子も、文字列変換による代替が起これば、
マスマジカルな性質がなくなります。

マスマジカルなオブジェクトを `chop()' すると、まず文字列になり、マスマ
ジカルな部分はなくなります。同じことは、他の演算でも起こります。





File: perl-ja.info, Node: 多重定義の実装, Next: 多重定義の診断, Prev: 多重定義の警告, Up: 多重定義

多重定義の実装
==============

すべての演算のためのメソッドのテーブルは、該当パッケージのシンボルテー
ブルに対するマジックとしてキャッシュされます。これは、 `bless' を行な
うときにのみ、 `%OVERLOAD' と `@ISA' の変更を再チェックします。つまり、
動的に変更したいならば、テーブルを更新するために、意味の無い `bless' 
を行なう必要があります。

(すべての SV 風のものは、マジックキューを持っており、マジックがキュー
のエントリになっています。これによって、1 つの変数が、同時に複数のマジッ
クの形式に関ることができるのです。たとえば、環境変数は普段、`%ENV' マ
ジックと「汚染」マジックの2 つの形式を一度に持っています。)

オブジェクトが `%OVERLOAD' を持つパッケージに属するならば、そのオブジェ
クトには、特別なフラグが用意されます。つまり、多重定義されていない算術
演算を行なうときの、スピードに対する影響は、このフラグのチェックのみで
す。

実際、 `%OVERLOAD' がアクセスされない間は、多重定義可能な演算に対する
オーバヘッドはほとんど無く、ほとんどのプログラムで、認識できるようなパ
フォーマスの低下はないはずです。 `%OVERLOAD' がアクセスされ、その時の
演算が多重定義可能なものであったときにも、対象の引数が `%OVERLOAD' を
持ったパッケージに属していない場合には、オーバヘッドの最小限にする最大
限の努力が為されました。疑わしいときには、 `%OVERLOAD' がある場合と無
い場合で、スピードのテストをしてください。これまでのところ、Perl が最
適化を指定してコンパイル場合には、顕著なスピードの低下の報告はあがって
いません。

`%OVERLOAD' が存在しないときには、データの大きさには影響しません。

`$a=$b' のようなコピーは、表層的なものです。しかし、 `$b++' のように、 
`$b' (または、 `$a' ) が参照するオブジェクトへの代入を意味する演算の前
に、1 層深度のコピーが行なわれます。この動作は、自分でコピーコンストラ
クタを定義することによって変更することができます (「コピーコンストラク
タ」の項を参照してください)。

明示的にサポートされていないメソッドに対する引数は、定数であることが期
待されます (が、強制はされません)。





File: perl-ja.info, Node: 多重定義の診断, Next: 多重定義のバグ, Prev: 多重定義の実装, Up: 多重定義

多重定義の診断
==============

Perl を `-Do' スイッチか同等のものを使って起動すると、多重定義が、診断
メッセージを誘発します。





File: perl-ja.info, Node: 多重定義のバグ, Prev: 多重定義の診断, Up: 多重定義

多重定義のバグ
==============

多重定義に使用されるため、Perl では、連想配列 {%OVERLOAD} は、パッケー
ジごとに特別な意味を持つことになります。

コピーコンストラクタは、配列へのリファレンスを伴う多重定義演算をより単
純にするように、特別に設計されていますが、動作するときには、現在はこの
事には役に立ちません。(Perl 内部の視点からすると) サブルーティンは、ス
カラを返すのと同じようには、配列を返すことができないからです。コピーコ
ンストラクタのためのインタフェースが変更されることを期待します。

出荷時、 `%OVERLOAD' は `@ISAsel' によって継承されていません。これに対
するパッチが、作者(author)から得られます。このドキュメントは混乱してい
ます。




File: perl-ja.info, Node: 書籍の情報, Prev: 多重定義, Up: Top

書籍の情報
**********

Perl の書籍は、O'Reilly & Associates, 1-800-998-9938 へ注文して入手で
きます。通常および海外からは 1-707-829-0515 です。O'Reilly の注文票を
お持ちであれば、1-707-829-0104 への FAX も可能です。"Programming Perl" 
は、Perl (version 4 なんですが) のほとんどすべてをカバーするリファレン
スであり、 "Learning Perl" は、この言語のもっとも使われる部分をカバー
するチュートリアルです。(訳注: 通常でない、アメリカの 1-800- で始まる
番号は、0120- のフリーダイヤルのようなサービスです。)

Programming Perl (キャメルブック):
     ISBN 0-937175-64-1 (英語) ISBN 4-89052-384-7 (日本語)

Learning Perl (リャマブック):
     ISBN 1-56592-042-2 (英語)

(訳注: 日本語版はソフトバンクから発売されています。また、サイエンス社、
アスキーより

Perl の国へようこそ:
     ISBN 4-7819-0697-4

Perl 書法:
     ISBN 4-7561-0281-6

入門 Perl:
     ISBN 4-7561-0292-1

が出ています。)





File: perl-ja.info, Node: Function Index, Next: Variable Index, Prev: Copying, Up: Top

Function Index
**************


* Menu:

* ...:                          範囲演算子.             18.
* ||:                           論理和と排他論理和.     4.
* &&:                           論理積.                 4.
* !:                            論理否定.               4.
* ,:                            コンマ演算子.           4.
* ^=:                           代入演算子.             4.
* %=:                           代入演算子.             4.
* .=:                           代入演算子.             4.
* ||=:                          代入演算子.             4.
* >>=:                          代入演算子.             4.
* |=:                           代入演算子.             4.
* /=:                           代入演算子.             4.
* -=:                           代入演算子.             4.
* &&=:                          代入演算子.             4.
* <<=:                          代入演算子.             4.
* &=:                           代入演算子.             4.
* *=:                           代入演算子.             4.
* +=:                           代入演算子.             4.
* **=:                          代入演算子.             4.
* =:                            代入演算子.             4.
* ?::                           条件演算子.             4.
* ..:                           範囲演算子.             4.
* <=>:                          等価演算子.             4.
* !=:                           等価演算子.             4.
* ==:                           等価演算子.             4.
* >=:                           比較演算子.             4.
* <=:                           比較演算子.             4.
* >:                            比較演算子.             4.
* <:                            比較演算子.             4.
* >>:                           シフト演算子.           4.
* <<:                           シフト演算子.           4.
* .:                            加法演算子.             4.
* -:                            加法演算子.             4.
* +:                            加法演算子.             4.
* %:                            乗法演算子.             4.
* /:                            乗法演算子.             4.
* *:                            乗法演算子.             4.
* !~:                           拘束演算子.             4.
* =~:                           拘束演算子.             4.
* \:                            単項演算子.             4.
* +:                            単項演算子.             4.
* ~:                            単項演算子.             4.
* -:                            単項演算子.             4.
* !:                            単項演算子.             4.
* **:                           指数演算子.             4.
* --:                           インクリメントとデクリメント.  4.
* ++:                           インクリメントとデクリメント.  4.
* ->:                           アロー演算子.           4.
* &:                            ビットごとの AND.       4.
* ||:                           C スタイルの論理和.     4.
* &&:                           C スタイルの論理積.     4.
* ^:                            ビットごとの OR と XOR.  4.
* |:                            ビットごとの OR と XOR.  4.
* ?PATTERN?:                    クォートとクォートのような演算子.  57.
* /PATTERN/gimosx:              クォートとクォートのような演算子.  71.
* 'STRING':                     クォートとクォートのような演算子.  167.
* "STRING":                     クォートとクォートのような演算子.  179.
* -X:                           ファイル操作関数.       10.
* -X:                           ファイル操作関数.       8.
* -X:                           ファイル操作関数.       9.
* abs:                          数学関数.               8.
* accept:                       ネットワーク操作関数.   8.
* alarm:                        システム操作関数.       8.
* and:                          論理積.                 4.
* and:                          C スタイルの論理和.     4.
* atan2:                        数学関数.               12.
* autoflush:                    定義済み変数.           155.
* bind:                         ネットワーク操作関数.   14.
* binmode:                      入出力関数.             8.
* bless:                        サブルーティン、パッケージ、モジュール.  8.
* bless:                        サブルーティン、パッケージ、モジュール.  9.
* caller:                       サブルーティン、パッケージ、モジュール.  18.
* caller:                       サブルーティン、パッケージ、モジュール.  19.
* chdir:                        システム操作関数.       23.
* chmod:                        ファイル操作関数.       109.
* chomp:                        文字列関数.             10.
* chomp:                        文字列関数.             8.
* chomp:                        文字列関数.             9.
* chop:                         文字列関数.             35.
* chop:                         文字列関数.             36.
* chop:                         文字列関数.             37.
* chown:                        ファイル操作関数.       118.
* chr:                          変換関数.               8.
* chroot:                       システム操作関数.       29.
* close:                        入出力関数.             17.
* closedir:                     ディレクトリ読み出し関数.  8.
* cmp:                          等価演算子.             4.
* connect:                      ネットワーク操作関数.   21.
* continue:                     複合実行文.             15.
* cos:                          数学関数.               16.
* crypt:                        文字列関数.             58.
* dbmclose:                     入出力関数.             39.
* dbmopen:                      入出力関数.             45.
* defined:                      その他の関数.           8.
* delete:                       配列関数とリスト関数.   8.
* die:                          システム操作関数.       35.
* do:                           サブルーティン、パッケージ、モジュール.  34.
* do:                           サブルーティン、パッケージ、モジュール.  39.
* do:                           サブルーティン、パッケージ、モジュール.  46.
* dump:                         その他の関数.           35.
* each:                         配列関数とリスト関数.   29.
* endgrent:                     システム操作関数.       189.
* endhostent:                   システム操作関数.       190.
* endnetent:                    システム操作関数.       191.
* endprotoent:                  システム操作関数.       192.
* endpwent:                     システム操作関数.       188.
* endservent:                   システム操作関数.       193.
* eof:                          入出力関数.             76.
* eof:                          入出力関数.             77.
* eq:                           等価演算子.             4.
* eval:                         文字列関数.             85.
* eval:                         文字列関数.             86.
* exec:                         システム操作関数.       65.
* exists:                       配列関数とリスト関数.   49.
* exit:                         システム操作関数.       95.
* exp:                          数学関数.               21.
* fcntl:                        入出力関数.             111.
* fileno:                       入出力関数.             125.
* flock:                        入出力関数.             131.
* for:                          複合実行文.             15.
* foreach:                      複合実行文.             15.
* fork:                         システム操作関数.       108.
* format_formfeed:              定義済み変数.           286.
* format_line_break_characters: 定義済み変数.           278.
* format_lines_left:            定義済み変数.           256.
* format_lines_per_page:        定義済み変数.           248.
* format_name:                  定義済み変数.           263.
* format_page_number:           定義済み変数.           241.
* format_top_name:              定義済み変数.           270.
* formline:                     入出力関数.             165.
* ge:                           比較演算子.             4.
* getc:                         入出力関数.             180.
* getc:                         入出力関数.             181.
* getgrent:                     システム操作関数.       177.
* getgrgid:                     システム操作関数.       170.
* getgrnam:                     システム操作関数.       165.
* gethostbyaddr:                システム操作関数.       172.
* gethostbyname:                システム操作関数.       166.
* gethostent:                   システム操作関数.       178.
* getlogin:                     システム操作関数.       138.
* getnetbyaddr:                 システム操作関数.       173.
* getnetbyname:                 システム操作関数.       167.
* getnetent:                    システム操作関数.       179.
* getpeername:                  ネットワーク操作関数.   28.
* getpgrp:                      システム操作関数.       145.
* getpgrp:                      システム操作関数.       146.
* getppid:                      システム操作関数.       153.
* getpriority:                  システム操作関数.       157.
* getprotobyname:               システム操作関数.       168.
* getprotobynumber:             システム操作関数.       174.
* getprotoent:                  システム操作関数.       180.
* getpwent:                     システム操作関数.       176.
* getpwnam:                     システム操作関数.       164.
* getpwuid:                     システム操作関数.       169.
* getservbyname:                システム操作関数.       171.
* getservbyport:                システム操作関数.       175.
* getservent:                   システム操作関数.       181.
* getsockname:                  ネットワーク操作関数.   38.
* getsockopt:                   ネットワーク操作関数.   48.
* glob:                         システム操作関数.       233.
* gmtime:                       変換関数.               13.
* goto:                         流れ制御.               8.
* goto:                         流れ制御.               9.
* grep:                         配列関数とリスト関数.   66.
* grep:                         配列関数とリスト関数.   67.
* gt:                           比較演算子.             4.
* hex:                          変換関数.               26.
* if:                           複合実行文.             15.
* if:                           単純実行文.             17.
* import:                       サブルーティン、パッケージ、モジュール.  69.
* (?imsx):                      正規表現の書き方.       210.
* index:                        検索・置換関数.         8.
* index:                        検索・置換関数.         9.
* input_line_number:            定義済み変数.           123.
* input_record_separator:       定義済み変数.           136.
* int:                          数学関数.               26.
* ioctl:                        入出力関数.             187.
* join:                         配列関数とリスト関数.   86.
* keys:                         配列関数とリスト関数.   95.
* kill:                         システム操作関数.       238.
* last:                         流れ制御.               30.
* last:                         流れ制御.               31.
* lc:                           文字列関数.             141.
* lcfirst:                      文字列関数.             146.
* le:                           比較演算子.             4.
* length:                       文字列関数.             151.
* link:                         ファイル操作関数.       140.
* listen:                       ネットワーク操作関数.   53.
* local:                        その他の関数.           65.
* localtime:                    変換関数.               32.
* log:                          数学関数.               30.
* lstat:                        ファイル操作関数.       145.
* lstat:                        ファイル操作関数.       146.
* lt:                           比較演算子.             4.
* m//:                          検索・置換関数.         17.
* m/PATTERN/gimosx:             クォートとクォートのような演算子.  71.
* map:                          配列関数とリスト関数.   115.
* map:                          配列関数とリスト関数.   116.
* mkdir:                        ファイル操作関数.       153.
* msgctl:                       SystemV IPC 関数.       8.
* msgget:                       SystemV IPC 関数.       15.
* msgrcv:                       SystemV IPC 関数.       20.
* msgsnd:                       SystemV IPC 関数.       28.
* my:                           その他の関数.           132.
* ne:                           等価演算子.             4.
* next:                         流れ制御.               43.
* next:                         流れ制御.               44.
* no:                           サブルーティン、パッケージ、モジュール.  77.
* not:                          論理否定.               4.
* not:                          単項演算子.             4.
* oct:                          変換関数.               53.
* open:                         入出力関数.             235.
* open:                         入出力関数.             236.
* opendir:                      ディレクトリ読み出し関数.  12.
* or:                           論理和と排他論理和.     4.
* or:                           C スタイルの論理和.     4.
* ord:                          変換関数.               63.
* output_field_separator:       定義済み変数.           167.
* output_record_separator:      定義済み変数.           178.
* pack:                         変換関数.               68.
* pipe:                         入出力関数.             359.
* pop:                          配列関数とリスト関数.   139.
* pos:                          検索・置換関数.         21.
* print:                        入出力関数.             368.
* print:                        入出力関数.             369.
* print:                        入出力関数.             370.
* printf:                       入出力関数.             389.
* printf:                       入出力関数.             390.
* push:                         配列関数とリスト関数.   149.
* q/STRING/:                    文字列関数.             156.
* q/STRING/:                    クォートとクォートのような演算子.  167.
* qq/STRING/:                   文字列関数.             157.
* qq/STRING/:                   クォートとクォートのような演算子.  179.
* quotemeta:                    文字列関数.             163.
* qw/STRING/:                   文字列関数.             159.
* qw/STRING/:                   クォートとクォートのような演算子.  202.
* qx/STRING/:                   文字列関数.             158.
* rand:                         数学関数.               35.
* rand:                         数学関数.               36.
* read:                         入出力関数.             395.
* read:                         入出力関数.             396.
* readdir:                      ディレクトリ読み出し関数.  19.
* readlink:                     ファイル操作関数.       159.
* recv:                         ネットワーク操作関数.   59.
* redo:                         流れ制御.               58.
* redo:                         流れ制御.               59.
* ref:                          その他の関数.           205.
* (?:regexp):                   正規表現の書き方.       173.
* (?=regexp):                   正規表現の書き方.       186.
* (?!regexp):                   正規表現の書き方.       191.
* rename:                       ファイル操作関数.       166.
* require:                      サブルーティン、パッケージ、モジュール.  81.
* require:                      サブルーティン、パッケージ、モジュール.  82.
* reset:                        検索・置換関数.         26.
* reset:                        検索・置換関数.         27.
* return:                       サブルーティン、パッケージ、モジュール.  126.
* reverse:                      配列関数とリスト関数.   161.
* rewinddir:                    ディレクトリ読み出し関数.  27.
* rindex:                       検索・置換関数.         47.
* rindex:                       検索・置換関数.         48.
* rmdir:                        ファイル操作関数.       171.
* s///:                         検索・置換関数.         54.
* s/PATTERN/REPLACEMENT/egimosx: クォートとクォートのような演算子.  218.
* scalar:                       配列関数とリスト関数.   169.
* seek:                         入出力関数.             406.
* seekdir:                      ディレクトリ読み出し関数.  32.
* select:                       入出力関数.             417.
* select:                       入出力関数.             418.
* select:                       入出力関数.             451.
* semctl:                       SystemV IPC 関数.       35.
* semget:                       SystemV IPC 関数.       43.
* semop:                        SystemV IPC 関数.       48.
* send:                         ネットワーク操作関数.   68.
* send:                         ネットワーク操作関数.   69.
* setgrent:                     システム操作関数.       183.
* sethostent:                   システム操作関数.       184.
* setnetent:                    システム操作関数.       185.
* setpgrp:                      システム操作関数.       254.
* setpriority:                  システム操作関数.       260.
* setprotoent:                  システム操作関数.       186.
* setpwent:                     システム操作関数.       182.
* setservent:                   システム操作関数.       187.
* setsockopt:                   ネットワーク操作関数.   76.
* shift:                        配列関数とリスト関数.   174.
* shift:                        配列関数とリスト関数.   175.
* shmctl:                       SystemV IPC 関数.       63.
* shmget:                       SystemV IPC 関数.       70.
* shmread:                      SystemV IPC 関数.       75.
* shmwrite:                     SystemV IPC 関数.       76.
* shutdown:                     ネットワーク操作関数.   82.
* sin:                          数学関数.               50.
* sleep:                        システム操作関数.       266.
* sleep:                        システム操作関数.       267.
* socket:                       ネットワーク操作関数.   87.
* socketpair:                   ネットワーク操作関数.   95.
* sort:                         配列関数とリスト関数.   185.
* sort:                         配列関数とリスト関数.   186.
* sort:                         配列関数とリスト関数.   187.
* splice:                       配列関数とリスト関数.   238.
* splice:                       配列関数とリスト関数.   239.
* splice:                       配列関数とリスト関数.   240.
* split:                        配列関数とリスト関数.   268.
* split:                        配列関数とリスト関数.   269.
* split:                        配列関数とリスト関数.   270.
* split:                        配列関数とリスト関数.   271.
* sprintf:                      入出力関数.             498.
* sqrt:                         数学関数.               55.
* srand:                        数学関数.               59.
* stat:                         ファイル操作関数.       177.
* stat:                         ファイル操作関数.       178.
* study:                        検索・置換関数.         59.
* study:                        検索・置換関数.         60.
* substr:                       文字列関数.             169.
* substr:                       文字列関数.             170.
* symlink:                      ファイル操作関数.       200.
* syscall:                      システム操作関数.       279.
* sysread:                      入出力関数.             504.
* sysread:                      入出力関数.             505.
* system:                       システム操作関数.       297.
* syswrite:                     入出力関数.             515.
* syswrite:                     入出力関数.             516.
* tell:                         入出力関数.             526.
* tell:                         入出力関数.             527.
* telldir:                      ディレクトリ読み出し関数.  38.
* (?#text):                     正規表現の書き方.       169.
* tie:                          サブルーティン、パッケージ、モジュール.  132.
* time:                         数学関数.               68.
* times:                        システム操作関数.       306.
* tr///:                        検索・置換関数.         117.
* tr/SEARCHLIST/REPLACEMENTLIST/cds: クォートとクォートのような演算子.  312.
* truncate:                     ファイル操作関数.       209.
* truncate:                     ファイル操作関数.       210.
* uc:                           文字列関数.             182.
* ucfirst:                      文字列関数.             187.
* umask:                        システム操作関数.       313.
* umask:                        システム操作関数.       314.
* undef:                        その他の関数.           232.
* undef:                        その他の関数.           233.
* unless:                       単純実行文.             17.
* unlink:                       ファイル操作関数.       216.
* unpack:                       変換関数.               165.
* unshift:                      配列関数とリスト関数.   341.
* untie:                        サブルーティン、パッケージ、モジュール.  182.
* until:                        単純実行文.             17.
* use:                          サブルーティン、パッケージ、モジュール.  186.
* use:                          サブルーティン、パッケージ、モジュール.  187.
* utime:                        ファイル操作関数.       231.
* values:                       配列関数とリスト関数.   352.
* vec:                          変換関数.               201.
* wait:                         システム操作関数.       319.
* waitpid:                      システム操作関数.       325.
* wantarray:                    その他の関数.           250.
* warn:                         システム操作関数.       343.
* while:                        複合実行文.             15.
* while:                        単純実行文.             17.
* write:                        入出力関数.             533.
* write:                        入出力関数.             534.
* write:                        入出力関数.             535.
* x=:                           代入演算子.             4.
* x:                            乗法演算子.             4.
* xor:                          論理和と排他論理和.     4.
* y///:                         検索・置換関数.         121.
* y/SEARCHLIST/REPLACEMENTLIST/cds: クォートとクォートのような演算子.  312.



File: perl-ja.info, Node: Variable Index, Next: Concept Index, Prev: Function Index, Up: Top

Variable Index
**************


* Menu:

* $0:                           定義済み変数.           390.
* $+:                           定義済み変数.           100.
* $*:                           定義済み変数.           111.
* $.:                           定義済み変数.           126.
* $/:                           定義済み変数.           139.
* $|:                           定義済み変数.           157.
* $,:                           定義済み変数.           170.
* $\:                           定義済み変数.           181.
* $":                           定義済み変数.           192.
* $;:                           定義済み変数.           200.
* $#:                           定義済み変数.           230.
* $%:                           定義済み変数.           243.
* $=:                           定義済み変数.           250.
* $-:                           定義済み変数.           258.
* $~:                           定義済み変数.           265.
* $^:                           定義済み変数.           272.
* $::                           定義済み変数.           280.
* $?:                           定義済み変数.           305.
* $!:                           定義済み変数.           316.
* $                           定義済み変数.           328.
* $$:                           定義済み変数.           337.
* $<:                           定義済み変数.           344.
* $>:                           定義済み変数.           351.
* $(:                           定義済み変数.           364.
* $):                           定義済み変数.           375.
* $[:                           定義済み変数.           397.
* $]:                           定義済み変数.           409.
* $_:                           定義済み変数.           46.
* $&:                           定義済み変数.           72.
* $`:                           定義済み変数.           79.
* $':                           定義済み変数.           87.
* $^A:                          定義済み変数.           294.
* $ACCUMULATOR:                 定義済み変数.           293.
* $ARG:                         定義済み変数.           45.
* $ARGV:                        定義済み変数.           474.
* @ARGV:                        定義済み変数.           478.
* $BASETIME:                    定義済み変数.           455.
* $CHILD_ERROR:                 定義済み変数.           304.
* $^D:                          定義済み変数.           428.
* $DEBUGGING:                   定義済み変数.           427.
* $EFFECTIVE_GROUP_ID:          定義済み変数.           373.
* $EFFECTIVE_USER_ID:           定義済み変数.           349.
* $EGID:                        定義済み変数.           374.
* $ENV{expr}:                   定義済み変数.           501.
* $ERRNO:                       定義済み変数.           315.
* $EUID:                        定義済み変数.           350.
* $EVAL_ERROR:                  定義済み変数.           327.
* $EXECUTABLE_NAME:             定義済み変数.           468.
* $^F:                          定義済み変数.           433.
* $FORMAT_FORMFEED:             定義済み変数.           287.
* $FORMAT_LINE_BREAK_CHARACTERS: 定義済み変数.          279.
* $FORMAT_LINES_LEFT:           定義済み変数.           257.
* $FORMAT_LINES_PER_PAGE:       定義済み変数.           249.
* $FORMAT_NAME:                 定義済み変数.           264.
* $FORMAT_PAGE_NUMBER:          定義済み変数.           242.
* $FORMAT_TOP_NAME:             定義済み変数.           271.
* $GID:                         定義済み変数.           363.
* $^I:                          定義済み変数.           444.
* @INC:                         定義済み変数.           485.
* %INC:                         定義済み変数.           493.
* $INPLACE_EDIT:                定義済み変数.           443.
* $INPUT_LINE_NUMBER:           定義済み変数.           124.
* $INPUT_RECORD_SEPARATOR:      定義済み変数.           137.
* $^L:                          定義済み変数.           288.
* $LAST_PAREN_MATCH:            定義済み変数.           99.
* $LIST_SEPARATOR:              定義済み変数.           191.
* $MATCH:                       定義済み変数.           71.
* $MULTILINE_MATCHING:          定義済み変数.           110.
* $NR:                          定義済み変数.           125.
* $OFMT:                        定義済み変数.           229.
* $OFS:                         定義済み変数.           169.
* $ORS:                         定義済み変数.           180.
* $OS_ERROR:                    定義済み変数.           314.
* $OUTPUT_AUTOFLUSH:            定義済み変数.           156.
* $OUTPUT_FIELD_SEPARATOR:      定義済み変数.           168.
* $OUTPUT_RECORD_SEPARATOR:     定義済み変数.           179.
* $^P:                          定義済み変数.           450.
* $PERL_VERSION:                定義済み変数.           408.
* $PERLDB:                      定義済み変数.           449.
* $PID:                         定義済み変数.           336.
* $POSTMATCH:                   定義済み変数.           86.
* $PREMATCH:                    定義済み変数.           78.
* $PROCESS_ID:                  定義済み変数.           335.
* $PROGRAM_NAME:                定義済み変数.           389.
* $REAL_GROUP_ID:               定義済み変数.           362.
* $REAL_USER_ID:                定義済み変数.           342.
* $RS:                          定義済み変数.           138.
* $SIG{expr}:                   定義済み変数.           506.
* $SUBSCRIPT_SEPARATOR:         定義済み変数.           198.
* $SUBSEP:                      定義済み変数.           199.
* $SYSTEM_FD_MAX:               定義済み変数.           432.
* $^T:                          定義済み変数.           456.
* $UID:                         定義済み変数.           343.
* $^W:                          定義済み変数.           463.
* $WARNING:                     定義済み変数.           462.
* $^X:                          定義済み変数.           469.
* $<digit>:                     定義済み変数.           64.

@node Concept Index,  , Variable Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp

@summarycontents
@contents
