Info file: standards-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `standards-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


START-INFO-DIR-ENTRY
* Standards: (standards-ja).     GNUコーディング・スタンダード
END-INFO-DIR-ENTRY



GNU Coding Standards Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997,
1998 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.




File: standards-ja.info, Node: Top, Next: Preface, Prev: (dir), Up: (dir)

Version
*******

Last updated November 18, 1998.

* Menu:

* Preface::                     GNUコーディング・スタンダードについて
* Legal Issues::                フリーソフトウェアを自由に保つ
* Design Advice::               一般的なプログラムのデザイン
* Program Behavior::            全てのプログラムの振る舞い
* Writing C::                   Cの一番良い使い方
* Documentation::               プログラムの文書化
* Managing Releases::           リリースの過程



File: standards-ja.info, Node: Preface, Next: Legal Issues, Prev: Top, Up: Top

GNUコーディング・スタンダードについて
*************************************

GNUコーディング・スタンダードはRichard Stallmanと他のGNU Projectのボラ
ンティア達によって書かれた。彼らの目的はGNUシステムをきれいで、一貫性
のある、インストールの容易なシステムにすることである。この文書は、移植
性に優れ、頑丈で、信頼性あるプログラムを書くためのガイドとして読むこと
もできる。Cで書かれたプログラムに焦点を当てるが、規則や原理の多くは他
のプログラミング言語の場合でも有効である。規則は、ある方法で書く理由を
しばしば記述してある。

この文書に対する訂正や助言は<gnu@gnu.org>に送ってほしい (1) (*Note
Preface-Footnotes::)。 助言をする場合、そのための新たな用語を入れてい
ただきたい。我々の時間は限られているからだ。我々は`standards.texi'か
`make-stds.texi'ファイルに対する、context diffを好むが、もしそれらのファ
イルを持っていないなら、いずれにせよメールしてほしい。

GNUコーディング・スタンダードのこのリリースは、最近ではNovember 18,
1998に更新された。


File: standards-ja.info  Node: Preface-Footnotes, Up: Preface

(1) 訳注: この日本語訳は奥地秀則が行っている。日本語訳に対する訂正や助
言は<okuji@kuicr.kyoto-u.ac.jp>に送ってほしい。



File: standards-ja.info, Node: Legal Issues, Next: Design Advice, Prev: Preface, Up: Top

フリーソフトウェアを自由に保つ
******************************

この節では、GNUソフトウェアを邪魔されないように保つための方法について
議論している。

* Menu:

* Reading Non-Free Code::       独占的プログラムの参照
* Contributions::               貢献の受け取り



File: standards-ja.info, Node: Reading Non-Free Code, Next: Contributions, Prev: Legal Issues, Up: Legal Issues

独占的プログラムの参照
======================

どんなところでも、GNUに関する作業のためや、作業中に、Unixのソースコー
ドを参照してはいけない！ (他の独占的プログラムについても。)

もしUnixプログラムの内部の曖昧な記憶を持っているなら、このことは、その
イミテーションを書くことができない、とは言っていないが、そのイミテーショ
ンを内部的に違った行で構成するようにしなさい。なぜなら、こうすることで、
Unixバージョンの細部とあなたの結果とを、無関係で似ていないものにする傾
向があるからだ。

例えば、Unixユーティリティは普通、メモリ使用量を最小化するように最適化
されている。もしあなたが代わりにスピードを追い求めれば、あなたのプログ
ラムはかなり異なるものになるだろう。stdioを使わずに、入力ファイル全体
をコアに置き、それを検査してよい。Unixプログラムより最近に見付かった、
より賢いアルゴリズムを使いなさい。一時ファイルの利用を省きなさい。二度
やらず一回のパスでやりなさい (我々はこれをアセンブラで行った)。

あるいは、逆に、スピードではなく単純さを強めなさい。アプリケーションに
よっては、今日のコンピュータのスピードでは、より単純なアルゴリズムが適
切である。

あるいは一般性を求めなさい。例えば、Unixプログラムはよく静的なテーブル
や固定長の文字列を使っているが、それは制限を課していることになる。代わ
りに動的な確保を行いなさい。あなたのプログラムを入力ファイルのNULや他
の変な文字を扱えるようにしなさい。拡張性のためにプログラミング言語を加
え、その言語でプログラムの一部を記述しなさい。

あるいは、プログラムのいくらかを独立して利用できるライブラリにしなさい。
あるいは、いつメモリを解放するか正確にトラッキングせずに、簡単なガーベー
ジ・コレクタを使うか、obstacksのような新しいGNUの機能を利用しなさい。




File: standards-ja.info, Node: Contributions, Prev: Reading Non-Free Code, Up: Legal Issues

貢献の受け取り
==============

もしあなたが作業しているプログラムが、Free Software Foundationによる著
作権を持っているなら、誰か他の人がそのプログラムに加えるコードを送って
きたとき、我々はそれを使うのに法的な文書を必要とする。ちょうど、我々が
初めにあなたに文書に署名するよう頼むときのように。プログラムに明解でな
い寄与をする人は、我々がそのプログラムにはっきりした所有権を付けるため
に、*誰でもみな*何らかの類いの法的な文書に署名しなければならない。中心
となった作者だけでは十分ではないのだ。

だから、他の人からの貢献を加える前に、我々に訊いてほしい。そうすると、
我々はその文書を手に入れられるよう計らうことができる。そして、その貢献
を実際に使う前に、署名された文書を受け取ったことをあなたに伝えるまで待
ちなさい。

これはプログラムをリリースする前と後の両方に当てはまる。もしバグを潰す
ための差分を受け取り、それが顕著な変更を行うなら、我々はその変更のため
の法的な文書を必要とする。

これはコメントや解説ファイルにも当てはまる。著作権法のため、コメントと
コードは単なるテキストである。著作権はあらゆる種類のテキストに適用され
るので、我々は全ての種類に対して法的な文書を必要とする。

法的な文書を請求するのが面倒だということは知っている。それは我々にとっ
ても面倒なことなのだ。しかし、もしあなたが待たなければ、不利な立場に向
かっていることになる。例えば、その貢献者が雇った人間が著作権放棄の文書
に署名したがらなかったとしたら？あなたはそのコードを再び取り除かなくて
はならないかもしれない！

あちこちの数行の変更には対しては、文書を必要としない。それらは著作権の
目的からは重要でないからだ。また、もし受け取った提案が発想であって、使
用する本当のコードでないなら、文書を必要としない。例えば、誰かがある実
装を送ったが、あなたが同じ発想の異なる実装を書いたなら、文書を受け取る
必要はない。

まさしく最悪なのは、他の貢献者を我々に伝えるのを忘れた場合だ。我々は、
結果として、いつか法廷で非常に決まり悪い思いをするかもしれない。

我々はプログラムの管理者にもっと詳細な情報を持っている。もし、GNUのた
めのプログラムを(リリースされているかどうかに拘らず)実際に管理する段階
に達したら、コピーを請求していただきたい。



File: standards-ja.info, Node: Design Advice, Next: Program Behavior, Prev: Legal Issues, Up: Top

一般的なプログラムのデザイン
****************************

この節では、プログラムを設計するときに気を付けるべき話題をいくつか議論
する。

* Menu:

* Compatibility::               他の実装との互換性
* Using Extensions::            標準的でない機能の使用
* ANSI C::                      ANSI Cの機能の使用
* Source Language::             C以外の言語の使用



File: standards-ja.info, Node: Compatibility, Next: Using Extensions, Prev: Design Advice, Up: Design Advice

他の実装との互換性
==================

ときには例外もあるが、GNU用のユーティリティプログラムやライブラリは、
バークレーUnixの上位互換であるべきで、ANSI Cがその振る舞いを規定してい
るなら、ANSI Cの上位互換に、POSIXがその振る舞いを規定していれば、POSIX
の上位互換であるべきだ。

もしこれらの標準が矛盾していたら、それぞれに対し互換モードを提供すると
便利だ。

ANSI CやPOSIXはたくさんの拡張を禁じている。拡張をどんな風に行っても構
わない、そうして、それを使わないための、`--ansi'とか`--posix'とか
`--compatible'オプションを含めなさい。しかしながら、その拡張が実際のプ
ログラムやスクリプトをおかしくする、十分な可能性があるなら、それは本当
のところ上位互換ではない。そのインターフェースを再設計してみなさい。

多くのGNUプログラムは、環境変数`POSIXLY_CORRECT'が定義されていると(例
え、それは空の値と定義されていても)、POSIXと抵触する拡張を行わない。適
切であれば、あなたのプログラムをこの変数を認識するようにしてください。

ある機能が(プログラムやコマンド・ファイルではなく)ユーザだけに使われ、
かつ、それがUnixでは貧弱なものなら、それをまるで違った、もっと良いもの
に完全に置き換えてしまってよい。(例えば、`vi'はEmacsと置き換えられてい
る。) しかし互換機能も提供するのが良い。(フリーな`vi'クローンがあるの
で、我々はそれを提供する。)

バークレーUnixにはない、便利な機能の追加は歓迎である。



File: standards-ja.info, Node: Using Extensions, Next: ANSI C, Prev: Compatibility, Up: Design Advice

標準的でない機能の使用
======================

すでに存在する、たくさんのGNUの機能は、相当するUnixの機能以上の便利な
拡張を数多くサポートしている。あなたのプログラムを実装する中でそれらの
拡張を使用するかどうかは難しい問題だ。

一方、その拡張を使用することで、より美しいプログラムを作ることができる。
他方、他のGNUツールが手に入らなかったら、人々はそのプログラムを構築で
きないだろう。このために、そのプログラムはより少ないマシンでしか動かな
くなるだろう。

いくつかの拡張によって、代わりのものも提供するのが容易であるかもしれな
い。例えば、"キーワード" `INLINE'を定義し、コンパイラによって、
`inline'か中身のないマクロに展開させることができる。

一般的に言って、おそらく、拡張を使わずに平易に書けるならそれらを使わな
いのが最善で、大きく改善されるなら拡張を使うのが最善だ。

この規則の例外は、非常にたくさんのシステムで走る、(Emacsのような)大き
くて完成されているプログラムだ。そのようなプログラムでは、GNUの拡張の
使用によって、上手く行かなくなってしまうだろう。

別の例外は、コンパイル過程の一部として使われるプログラムだ。GNUコンパ
イル環境の機能を立ち上げるために、他のコンパイラによってコンパイルされ
なければならないものはどんなものでも。もしこれらがGNUコンパイラを必要
としていると、すでにインストール済みでない限り、それらをコンパイルする
ことは誰にもできない。これは良くないだろう。



File: standards-ja.info, Node: ANSI C, Next: Source Language, Prev: Using Extensions, Up: Design Advice

ANSI CとANSI以前のC
===================

決してANSI Cの "trigraph" 機能 (1) (*Note ANSI C-Footnotes::)を使って
はならない。

ANSI Cは、今ではもうANSI Cの機能を使う(それゆえnon-ANSI コンパイラでは
動かない)新しいプログラムを書いていいぐらい広まっている。そして、もし
プログラムがすでにANSI Cで書かれているなら、それをnon-ANSIコンパイラを
サポートするよう変換する必要はない。

しかしながら、ほとんどのプログラムではnon-ANSIコンパイラをサポートする
のは容易だから、プログラムを書くときにはそうするよう心掛けてもよいだろ
う。ANSIプロトタイプ形式での関数定義、

     int
     foo (int x, int y)
     ...

を書く代わりに、このようなANSI以前の形式で定義を書きなさい。

     int
     foo (x, y)
          int x, y;
     ...

そして、引数のプロトタイプを特定するのに、別に宣言しなさい。

     int foo (int, int);

いずれにせよ、その関数を呼ぶ全てのファイルでANSI Cプロトタイプの恩恵を
得るためには、あるヘッダファイル内でそのような宣言を必要とする。そして、
それを一度書いてしまえば、ANSI以前の形式で関数定義を書くことによって失
うものは何もない。

もしあなたがnon-ANSI Cを知らないなら、それを勉強する必要はない。ANSI C
で書けばいい。


File: standards-ja.info  Node: ANSI C-Footnotes, Up: ANSI C

(1) 訳注: 何それ？



File: standards-ja.info, Node: Source Language, Prev: ANSI C, Up: Design Advice

C以外の言語の使用
=================

C以外の言語の使用は標準的でない機能を使うようなものだ。ユーザは問題を
引き起こすだろう。例えGCCが他の言語をサポートしていても、ユーザは、あ
なたのプログラムの構築するために、その他の言語のコンパイラをインストー
ルしなければならないことを不便に感じるかもしれない。例えば、あなたのプ
ログラムをC++で書いたら、人々はあなたのプログラムをコンパイルするため
にC++コンパイラをインストールしなければならないだろう。このように、Cで
書く方が良いのだ。しかし他の言語を使う欠点がない状況が3つある。

   * その言語用のインタープリタをあなたのプログラムが含んでいるなら、
     他の言語を使っていい。

     例えば、あなたのプログラムがGUILEとリンクしているなら、そのプログ
     ラムの一部をSchemeやGUILEがサポートする他の言語で書いても良い。

   * その言語と一緒に使われることを特に意図しているツールでは、他の言
     語を使って良い。

     そのツールを構築したい人々は、その他の言語をいずれにせよインストー
     ルしている人々だけだろうから、これで構わないのだ。

   * もしそのアプリケーションが狭い集団に対して関心があるなら、おそら
     くそのアプリケーションのインストールが不便かどうかなど重要ではな
     い。

CはC++や他のコンパイル用言語以上の利点を持っている。より多くの人々がC 
を知っている。だから、プログラムがCで書かれていると、それを読んだり変
更したりするのが、より多くの人々にとって容易だろう。



File: standards-ja.info, Node: Program Behavior, Next: Writing C, Prev: Design Advice, Up: Top

全てのプログラムの振る舞い
**************************

この節では、頑丈なソフトウェアの書き方を記述する。また、エラーメッセー
ジや、コマンドラインのインターフェース、ライブラリの挙動の、汎用的な標
準についても記述する。

* Menu:

* Semantics::                   頑丈なプログラムの作成
* Libraries::                   ライブラリの挙動
* Errors::                      エラーメッセージの書式
* User Interfaces::             コマンドラインのインターフェースの標準
* Option Table::                長いオプションの表
* Memory Usage::                メモリの必要性をいつ、いかに注意するか



File: standards-ja.info, Node: Semantics, Next: Libraries, Prev: Program Behavior, Up: Program Behavior

頑丈なプログラムの作成
======================

動的に全てのデータ構造を確保することによって、ファイル名、行、ファイル、
シンボルを含む、*いかなる*データ構造の長さや数についても、勝手な制限を
避けなさい。ほとんどのUnixユーティリティでは、"長い行は黙って切り詰め
る"。これはGNUユーティリティでは許容できない。

ファイルを読むユーティリティはNUL文字や、*0177以上のコードを持つ文字を
含む*あらゆる他の印字できない文字も、落とすべきではない。唯一意味のあ
る例外は、そういった文字を扱えない、ある種のプリンタへのインターフェー
スを特別に意図したユーティリティだろう。可能な限りいつでも、UTF-8やそ
の他のエンコーディングを使って、多バイト文字を表すバイト列を適切に扱え
るようにしなさい。

エラーを無視したいと思っているのでなければ、あらゆるシステムコールのエ
ラーを確認しなさい。失敗したシステムコールから発生する*あらゆる* エラー
メッセージに、もしあればファイルの名前とそのユーティリティの名前だけで
なく、(`perror'や同等のものから得られる)システムエラー文字列を含めなさ
い。単なる"cannot open foo.c"や"stat failed"は十分でない。

`malloc'や`realloc'のすべての呼び出しを、ゼロを返したかどうか確認しな
さい。例えそのブロックをもっと小さくしようとしていても、`realloc'の確
認をしなさい。2の階乗にブロックサイズを丸めるシステムでは、`realloc'は
もっと小さい領域を要求する場合に異なるブロックを得ることがある。

Unixでは、`realloc'がゼロを返す場合、記憶領域を破壊してしまう。GNU
`realloc'はこのバグを持たない。失敗すると、元のブロックは変更されない。
そのバグは直っているとみなしても構わない。もしあなたのプログラムをUnix
上で走らせたくて、こういう損失を避けたいなら、GNU `malloc' を使うこと
ができる。

`free'は解放されたブロックの中身を変えてしまうと考えなければならない。
そのブロックの値を取り出したかったら、必ず`free'を呼ぶ前に取り出さなく
てはならない。

もし`malloc'が対話的でないプログラムで失敗したら、それを致命的なエラー
にしなさい。対話的なプログラム(ユーザからコマンドを呼んでくるもの)では、
そのコマンドを中止して、コマンド読み込みループから返るのがより良い。こ
うすると、そのユーザは仮想メモリを解放するために他のプロセスを殺して、
再びそのコマンドを試すことができる。

もし引数の文法が上手く行かなくなるわけでないなら、引数の解読に
`getopt_long'を使いなさい。

静的な記憶領域がプログラムの実行中に書き込まれるためであるとき、それを
初期化するための、明示的なCのコードを使いなさい。変更されないデータに
対する、Cの初期化付き宣言を残しておきなさい。

(ファイルディレクトリや、utmp、カーネルメモリの配置のような)Unixのデー
タ構造を見えにくくする、低水準のインターフェースを避けるよう努めなさい。
これらは互換性を失いがちだからだ。もしあるディレクトリの全ファイルを見
付ける必要があるなら、`readdir'や他の高水準のインターフェースを使いな
さい。これらはGNUによって互換性を持ってサポートされるだろう。

好ましいシグナルハンドリングの機能はBSD流の`signal'とPOSIX `sigaction'
関数である。別にあるUSGの`signal'は劣った設計だ。

今日では、POSIXシグナル関数の使用がプログラムを移植しやすくする一番簡
単な方法かもしれない。`signal'を使うと、GNU libc version 1 を使う
GNU/Linuxシステム上でBSDの振る舞いを得るために、`signal.h' ではなく
`bsd/signal.h'をincludeすべきだ。`signal'がUSGの振る舞いしか持たないシ
ステムをサポートするか、あるいは、それらを諦めてしまうかはあなた次第だ。

"あり得ない"状態を検出するエラーチェックでは、単に中止しなさい。メッセー
ジを出力する意味は普通ない。これらのチェックはバグの存在を示している。
そのバグを直したい人なら誰でも、そのソースコードを読み、デバッガを走ら
せないといけないだろう。だから、そのソースにコメントでその問題を説明し
なさい。関係のあるデータは変数の中で、それはデバッガで検査するのは容易
だろう。だから、それらをどこか他の位置に移す意味はない。

プログラムの終了状態として、エラーのカウントを使ってはならない。*これ
は上手く行かない*。なぜなら、終了状態の値は(0から255までの) 8ビットに
制限されているからだ。そのプログラムが一回走る間に256のエラーが起きる
かもしれない。もし終了状態として256を返そうとすると、親プロセスはその
状態として0を見ることになり、そのプログラムが成功したかのように見える
だろう。

もし一時ファイルを作るなら、`TMPDIR'環境変数を確認しなさい。この変数が
定義されていれば、`/tmp'ではなく、指定されたディレクトリを使いなさい。



File: standards-ja.info, Node: Libraries, Next: Errors, Prev: Semantics, Up: Program Behavior

ライブラリの挙動
================

ライブラリ関数を再入可能にするよう努力しなさい。それらが動的な記憶領域
の確保を必要とするなら、少なくとも`malloc'自体は別として、再入不能を避
けるよう努力しなさい。

名前がぶつかるのを避けるために、ライブラリ用の名前付けの取り決めがある。

二文字以上の長さで、そのライブラリ用の接頭辞を決めなさい。外部に見せる
関数と変数の名前すべてに、この接頭辞を付けるべきだ。さらに、どの特定の
ライブラリ・メンバーでも、これらのうち一つだけが入っているべきだ。これ
は通常それぞれを別のソースファイルに置くことを意味する。

二つの外部シンボルが常に一緒に使われ、片方を使ってもう片方を使わないよ
うな意味のあるプログラムがあり得ないようなときには、例外となる。それら
は両方とも同じファイルに入れられる。

ユーザにエントリ・ポイントとして記述されない外部シンボルは、`_'で始ま
る名前を持つべきだ。それらはまた、他のライブラリと衝突するのを防ぐため
に、そのライブラリのために選ばれた接頭辞を含むべきだ。これらは、好むな
ら、ユーザのエントリ・ポイントと同じファイルの中に含めても良い。

静的な関数や変数は好きなように使って良く、どんな名前付け規則にも当ては
まらなくていい。



File: standards-ja.info, Node: Errors, Next: User Interfaces, Prev: Libraries, Up: Program Behavior

エラーメッセージの書式
======================

コンパイラからのエラーメッセージは次のようであるべきだ。

     SOURCE-FILE-NAME:LINENO: MESSAGE

適切なソースファイルがあるときには、他の対話的でないプログラムからのエ
ラーメッセージは次のようであるべきだ。

     PROGRAM:SOURCE-FILE-NAME:LINENO: MESSAGE

関連のあるソースファイルがないときには、次のようだ。

     PROGRAM: MESSAGE

@noindent

対話的なプログラム(端末からコマンドを読んでいるもの)では、エラーメッセー
ジにプログラム名を含めない方が良い。どのプログラムが走っているかを示す
場所は、プロンプトか、スクリーンのレイアウトだ。(同じプログラムが端末
以外のソースから入力を受け取って走るとき、それは対話的ではなく、対話的
でない形式を使ってエラーメッセージを出力するのが一番良いだろう。)

文字列MESSAGEは、プログラム名やファイル名に続くときには、大文字で始め
るべきではない。また、ピリオドで終わるべきではない。

対話的なプログラムからのエラーメッセージや使い方のメッセージのような他
のメッセージは大文字で始めるべきだ。しかしピリオドで終わるべきではない。



File: standards-ja.info, Node: User Interfaces, Next: Option Table, Prev: Errors, Up: Program Behavior

コマンドラインのインターフェースの標準
======================================

ユーティリティの挙動をそれを起動した名前に依存させないでください。ある
ユーティリティに別の名前をリンクすることは、ときどき有用で、そのことで
何をやるのかを換えるべきでない。

代わりに、動作時のオプションか、コンパイルするときのスィッチか、両方を
別の挙動を選択するために使いなさい。

同様に、プログラムの挙動をそれが使う出力デバイスの種類に依存しないよう
にしてください。デバイス独立はシステム設計の重要な原理だ。単に誰かがと
きどきオプションを打ち込むのを省略することに妥協してはならない。(端末
を使うときのエラーメッセージの文法を変化させるのは構わない。なぜなら、
それは人々が依存していない別な問題だからだ。)

もし出力が端末に向かうときある挙動が最も有用で、出力がファイルかパイプ
なら他の挙動が最も有用なら、端末への出力で有用な挙動をデフォルトにして、
他の挙動のオプションを持つのが通常一番良い。

互換性のために、出力デバイスの種類に依存するプログラムを必要とする。も
し`ls'や`sh'が、あらゆるユーザが期待する方法で働かなかったら、それはひ
どいだろう。これらの場合のうちいくつかでは、出力デバイスの種類に依存し
ない、より好ましい別バージョンを我々は補う。例えば、`ls'にとても似てい
るが、デフォルトの出力形式が常に複数欄形式である、`dir'プログラムを提
供する。

プログラムのコマンドライン・オプションをPOSIXのガイドラインに従わせる
のは良い考えだ。これを行う一番簡単な方法は、それらを解析するのに
`getopt'を使うことだ。`getopt'のGNUバージョンは、特別な引数`--'が使わ
れなければ、通常オプションが引数のどこにあっても良いことに注意しなさい。
これはPOSIXが規定していることではない。GNUの拡張だ。

一文字のUnix形式オプションと等価な長い名前のオプションを定義してくださ
い。我々はこの方法でGNUをよりユーザに親しみやすいものにしたいと思って
いる。これはGNUの関数`getopt_log'を使えば簡単だ。

長い名前のオプションの利点の一つはどのプログラムでも一貫したものにでき
るからだ。例えば、ユーザは"verbose"オプションを持つどのGNUプログラムも
それが正確に`--verbose'と綴られると期待することができるべきだ。この不
変性を成すために、あなたのプログラムのオプション名を選ぶとき、共通の長
いオプション名の表を見なさい (*Note Option Table::)。

普通の引数として与えられるファイル名が入力ファイルだけにするのは普通良
い考えだ。どんな出力ファイルでも(願わくは`-o'や`--output'のような)オプ
ションによって指定されるだろう。互換性のために普通の引数として出力ファ
イル名を許す場合でも、それを指定する他の方法としてオプションを与えてみ
なさい。これはGNUユーティリティの一貫性を増し、そしてユーザが覚えるべ
き独自性を減らすであろう。

あらゆるプログラムは次の二つの標準的なオプションをサポートすべきだ。
`--version'と`--help'だ。

`--version'
     このオプションはそのプログラムに、その名前、バージョン、出所と法
     的な状態に関する情報を、すべて標準出力に出させ、そして成功状態で
     終了させるべきだ。他のオプションや引数はこれが現れたら無視される
     べきで、そのプログラムはその通常の機能を行うべきではない。

     最初の行をプログラムが解析しやすくする。そのバージョン・ナンバー
     を最後のスペースの後に始める。加えて、このプログラムの正しい名前
     を次の形式で含める。

          GNU Emacs 19.30

     プログラム名は固定文字列であるべきだ。それを`argv[0]'から計算して
     は*いけない*。その考えは、そのファイル名ではなく、そのプログラム
     の標準的、あるいは、正統な名前を表明することである。コマンドを
     `PATH'から見付けることで、正確なファイル名を見付け出す他の方法が
     あるのだ。

     もしプログラムが大きいパッケージの補助的な部分なら、次のようにそ
     のプログラム名を括弧の中で記述しなさい。

          emacsserver (GNU Emacs) 19.30

     もしそのパッケージがこのプログラムのバージョン・ナンバーとは違う
     バージョン・ナンバーを持っているなら、閉じ括弧の直前にそのパッケー
     ジのバージョン・ナンバーを記述して良い。

     もしこのプログラムを含むパッケージとは別に配布されるライブラリの
     バージョン・ナンバーを記述*したい*のなら、記述したいそれぞれのラ
     イブラリ毎に行を追加して、バージョン情報を出力することで、そうし
     て良い。それらの行に最初の行と同じ形式を使いなさい。

     そのプログラムが使うライブラリ全てを、"単に完全であるためだけに"
     記述しないでください。--そうすると、たくさんの役に立たない乱雑さ
     を生み出してしまうだろう。あなたがデバッグをするのに非常に重要で
     あると実際に見出した場合にだけ、ライブラリのバージョン・ナンバー
     を記述してください。

     バージョン・ナンバーの行の後の、次の行は著作権通知であるべきだ。
     二つ以上の著作権通知が必要なら、それぞれ別の行に入れなさい。

     次は、そのプログラムがフリーソフトウェアであり、ユーザは自由に複
     製したり、ある条件でそれを改変して良いという、簡単な記述が続くべ
     きだ。もしそのプログラムがGNU GPLによって保護されているなら、ここ
     でそう言いなさい。また、法に認められる範囲に対し、無保証であるこ
     とを書きなさい。

     名誉を与える方法として、そのプログラムの主要な作者の名簿を出力し
     て終わらせて構わない。

     これらの規則に従う出力の例を示そう。

          GNU Emacs 19.34.5
          Copyright (C) 1996 Free Software Foundation, Inc.
          GNU Emacs comes with NO WARRANTY,
          to the extent permitted by law.
          You may redistribute copies of GNU Emacs
          under the terms of the GNU General Public License.
          For more information about these matters,
          see the files named COPYING.

     これをあなたのプログラムに一致させるべきだ。当然、適切な年、著作
     権者、プログラムの名前、そして、配布条件の言及を入れ、必要に応じ
     て残りの言葉遣いを換えるべきだ。

     この著作権通知は変更がなされた一番最近の年を記述するだけでいい。--
     以前のバージョンの変更に対して年を列挙する必要はない。もし不便な
     ら、プログラムの名前をこの通知の中で記述しなくて良い。最初の行に
     現れているから。

`--help'
     このオプションはそのプログラムをどのように起動するかを、標準出力
     上に、簡単な解説を出力し、成功終了すべきだ。他のオプションや引数
     はこれが現れたら無視すべきで、そのプログラムはその通常の機能を行
     うべきではない。

     `--help'オプションの出力の最後の辺りで、バグ報告をどこにメールす
     るかを表す行があるべきだ。こういう書式を持つ。

          Report bugs to MAILING-ADDRESS.



File: standards-ja.info, Node: Option Table, Next: Memory Usage, Prev: User Interfaces, Up: Program Behavior

長いオプションの表
==================

GNUプログラムによって使われる長いオプションの表をここで示す。きっと不
完全ではあるが、新しいプログラムが互換性を持ちたいであろうオプションを
すべて列挙するつもりだ。もしこの表にまだない名前を使うなら、それらの表
と、それらの意味を<gnu@gnu.org>に送ってください。我々がこの表を更新で
きるので (1) (*Note Option Table-Footnotes::)。


`after-date'
     `-N' in `tar'.

`all'
     `-a' in `du', `ls', `nm', `stty', `uname', and `unexpand'.

`all-text'
     `-a' in `diff'.

`almost-all'
     `-A' in `ls'.

`append'
     `-a' in `etags', `tee', `time'; `-r' in `tar'.

`archive'
     `-a' in `cp'.

`archive-name'
     `-n' in `shar'.

`arglength'
     `-l' in `m4'.

`ascii'
     `-a' in `diff'.

`assign'
     `-v' in `gawk'.

`assume-new'
     `-W' in Make.

`assume-old'
     `-o' in Make.

`auto-check'
     `-a' in `recode'.

`auto-pager'
     `-a' in `wdiff'.

`auto-reference'
     `-A' in `ptx'.

`avoid-wraps'
     `-n' in `wdiff'.

`background'
     For server programs, run in the background.

`backward-search'
     `-B' in `ctags'.

`basename'
     `-f' in `shar'.

`batch'
     Used in GDB.

`baud'
     Used in GDB.

`before'
     `-b' in `tac'.

`binary'
     `-b' in `cpio' and `diff'.

`bits-per-code'
     `-b' in `shar'.

`block-size'
     Used in `cpio' and `tar'.

`blocks'
     `-b' in `head' and `tail'.

`break-file'
     `-b' in `ptx'.

`brief'
     Used in various programs to make output shorter.

`bytes'
     `-c' in `head', `split', and `tail'.

`c++'
     `-C' in `etags'.

`catenate'
     `-A' in `tar'.

`cd'
     Used in various programs to specify the directory to use.

`changes'
     `-c' in `chgrp' and `chown'.

`classify'
     `-F' in `ls'.

`colons'
     `-c' in `recode'.

`command'
     `-c' in `su'; `-x' in GDB.

`compare'
     `-d' in `tar'.

`compat'
     Used in `gawk'.

`compress'
     `-Z' in `tar' and `shar'.

`concatenate'
     `-A' in `tar'.

`confirmation'
     `-w' in `tar'.

`context'
     Used in `diff'.

`copyleft'
     `-W copyleft' in `gawk'.

`copyright'
     `-C' in `ptx', `recode', and `wdiff'; `-W copyright' in `gawk'.

`core'
     Used in GDB.

`count'
     `-q' in `who'.

`count-links'
     `-l' in `du'.

`create'
     Used in `tar' and `cpio'.

`cut-mark'
     `-c' in `shar'.

`cxref'
     `-x' in `ctags'.

`date'
     `-d' in `touch'.

`debug'
     `-d' in Make and `m4'; `-t' in Bison.

`define'
     `-D' in `m4'.

`defines'
     `-d' in Bison and `ctags'.

`delete'
     `-D' in `tar'.

`dereference'
     `-L' in `chgrp', `chown', `cpio', `du', `ls', and `tar'.

`dereference-args'
     `-D' in `du'.

`diacritics'
     `-d' in `recode'.

`dictionary-order'
     `-d' in `look'.

`diff'
     `-d' in `tar'.

`digits'
     `-n' in `csplit'.

`directory'
     Specify the directory to use, in various programs.  In `ls', it
     means to show directories themselves rather than their contents.
     In `rm' and `ln', it means to not treat links to directories
     specially.

`discard-all'
     `-x' in `strip'.

`discard-locals'
     `-X' in `strip'.

`dry-run'
     `-n' in Make.

`ed'
     `-e' in `diff'.

`elide-empty-files'
     `-z' in `csplit'.

`end-delete'
     `-x' in `wdiff'.

`end-insert'
     `-z' in `wdiff'.

`entire-new-file'
     `-N' in `diff'.

`environment-overrides'
     `-e' in Make.

`eof'
     `-e' in `xargs'.

`epoch'
     Used in GDB.

`error-limit'
     Used in `makeinfo'.

`error-output'
     `-o' in `m4'.

`escape'
     `-b' in `ls'.

`exclude-from'
     `-X' in `tar'.

`exec'
     Used in GDB.

`exit'
     `-x' in `xargs'.

`exit-0'
     `-e' in `unshar'.

`expand-tabs'
     `-t' in `diff'.

`expression'
     `-e' in `sed'.

`extern-only'
     `-g' in `nm'.

`extract'
     `-i' in `cpio'; `-x' in `tar'.

`faces'
     `-f' in `finger'.

`fast'
     `-f' in `su'.

`fatal-warnings'
     `-E' in `m4'.

`file'
     `-f' in `info', `gawk', Make, `mt', and `tar'; `-n' in `sed';
     `-r' in `touch'.

`field-separator'
     `-F' in `gawk'.

`file-prefix'
     `-b' in Bison.

`file-type'
     `-F' in `ls'.

`files-from'
     `-T' in `tar'.

`fill-column'
     Used in `makeinfo'.

`flag-truncation'
     `-F' in `ptx'.

`fixed-output-files'
     `-y' in Bison.

`follow'
     `-f' in `tail'.

`footnote-style'
     Used in `makeinfo'.

`force'
     `-f' in `cp', `ln', `mv', and `rm'.

`force-prefix'
     `-F' in `shar'.

`foreground'
     For server programs, run in the foreground; in other words, don't
     do anything special to run the server in the background.

`format'
     Used in `ls', `time', and `ptx'.

`freeze-state'
     `-F' in `m4'.

`fullname'
     Used in GDB.

`gap-size'
     `-g' in `ptx'.

`get'
     `-x' in `tar'.

`graphic'
     `-i' in `ul'.

`graphics'
     `-g' in `recode'.

`group'
     `-g' in `install'.

`gzip'
     `-z' in `tar' and `shar'.

`hashsize'
     `-H' in `m4'.

`header'
     `-h' in `objdump' and `recode'

`heading'
     `-H' in `who'.

`help'
     Used to ask for brief usage information.

`here-delimiter'
     `-d' in `shar'.

`hide-control-chars'
     `-q' in `ls'.

`idle'
     `-u' in `who'.

`ifdef'
     `-D' in `diff'.

`ignore'
     `-I' in `ls'; `-x' in `recode'.

`ignore-all-space'
     `-w' in `diff'.

`ignore-backups'
     `-B' in `ls'.

`ignore-blank-lines'
     `-B' in `diff'.

`ignore-case'
     `-f' in `look' and `ptx'; `-i' in `diff' and `wdiff'.

`ignore-errors'
     `-i' in Make.

`ignore-file'
     `-i' in `ptx'.

`ignore-indentation'
     `-I' in `etags'.

`ignore-init-file'
     `-f' in Oleo.

`ignore-interrupts'
     `-i' in `tee'.

`ignore-matching-lines'
     `-I' in `diff'.

`ignore-space-change'
     `-b' in `diff'.

`ignore-zeros'
     `-i' in `tar'.

`include'
     `-i' in `etags'; `-I' in `m4'.

`include-dir'
     `-I' in Make.

`incremental'
     `-G' in `tar'.

`info'
     `-i', `-l', and `-m' in Finger.

`initial'
     `-i' in `expand'.

`initial-tab'
     `-T' in `diff'.

`inode'
     `-i' in `ls'.

`interactive'
     `-i' in `cp', `ln', `mv', `rm'; `-e' in `m4'; `-p' in `xargs';
     `-w' in `tar'.

`intermix-type'
     `-p' in `shar'.

`jobs'
     `-j' in Make.

`just-print'
     `-n' in Make.

`keep-going'
     `-k' in Make.

`keep-files'
     `-k' in `csplit'.

`kilobytes'
     `-k' in `du' and `ls'.

`language'
     `-l' in `etags'.

`less-mode'
     `-l' in `wdiff'.

`level-for-gzip'
     `-g' in `shar'.

`line-bytes'
     `-C' in `split'.

`lines'
     Used in `split', `head', and `tail'.

`link'
     `-l' in `cpio'.

`lint'
`lint-old'
     Used in `gawk'.

`list'
     `-t' in `cpio'; `-l' in `recode'.

`list'
     `-t' in `tar'.

`literal'
     `-N' in `ls'.

`load-average'
     `-l' in Make.

`login'
     Used in `su'.

`machine'
     No listing of which programs already use this; someone should
     check to see if any actually do, and tell <gnu@gnu.org>.

`macro-name'
     `-M' in `ptx'.

`mail'
     `-m' in `hello' and `uname'.

`make-directories'
     `-d' in `cpio'.

`makefile'
     `-f' in Make.

`mapped'
     Used in GDB.

`max-args'
     `-n' in `xargs'.

`max-chars'
     `-n' in `xargs'.

`max-lines'
     `-l' in `xargs'.

`max-load'
     `-l' in Make.

`max-procs'
     `-P' in `xargs'.

`mesg'
     `-T' in `who'.

`message'
     `-T' in `who'.

`minimal'
     `-d' in `diff'.

`mixed-uuencode'
     `-M' in `shar'.

`mode'
     `-m' in `install', `mkdir', and `mkfifo'.

`modification-time'
     `-m' in `tar'.

`multi-volume'
     `-M' in `tar'.

`name-prefix'
     `-a' in Bison.

`nesting-limit'
     `-L' in `m4'.

`net-headers'
     `-a' in `shar'.

`new-file'
     `-W' in Make.

`no-builtin-rules'
     `-r' in Make.

`no-character-count'
     `-w' in `shar'.

`no-check-existing'
     `-x' in `shar'.

`no-common'
     `-3' in `wdiff'.

`no-create'
     `-c' in `touch'.

`no-defines'
     `-D' in `etags'.

`no-deleted'
     `-1' in `wdiff'.

`no-dereference'
     `-d' in `cp'.

`no-inserted'
     `-2' in `wdiff'.

`no-keep-going'
     `-S' in Make.

`no-lines'
     `-l' in Bison.

`no-piping'
     `-P' in `shar'.

`no-prof'
     `-e' in `gprof'.

`no-regex'
     `-R' in `etags'.

`no-sort'
     `-p' in `nm'.

`no-split'
     Used in `makeinfo'.

`no-static'
     `-a' in `gprof'.

`no-time'
     `-E' in `gprof'.

`no-timestamp'
     `-m' in `shar'.

`no-validate'
     Used in `makeinfo'.

`no-wait'
     Used in `emacsclient'.

`no-warn'
     Used in various programs to inhibit warnings.

`node'
     `-n' in `info'.

`nodename'
     `-n' in `uname'.

`nonmatching'
     `-f' in `cpio'.

`nstuff'
     `-n' in `objdump'.

`null'
     `-0' in `xargs'.

`number'
     `-n' in `cat'.

`number-nonblank'
     `-b' in `cat'.

`numeric-sort'
     `-n' in `nm'.

`numeric-uid-gid'
     `-n' in `cpio' and `ls'.

`nx'
     Used in GDB.

`old-archive'
     `-o' in `tar'.

`old-file'
     `-o' in Make.

`one-file-system'
     `-l' in `tar', `cp', and `du'.

`only-file'
     `-o' in `ptx'.

`only-prof'
     `-f' in `gprof'.

`only-time'
     `-F' in `gprof'.

`output'
     In various programs, specify the output file name.

`output-prefix'
     `-o' in `shar'.

`override'
     `-o' in `rm'.

`overwrite'
     `-c' in `unshar'.

`owner'
     `-o' in `install'.

`paginate'
     `-l' in `diff'.

`paragraph-indent'
     Used in `makeinfo'.

`parents'
     `-p' in `mkdir' and `rmdir'.

`pass-all'
     `-p' in `ul'.

`pass-through'
     `-p' in `cpio'.

`port'
     `-P' in `finger'.

`portability'
     `-c' in `cpio' and `tar'.

`posix'
     Used in `gawk'.

`prefix-builtins'
     `-P' in `m4'.

`prefix'
     `-f' in `csplit'.

`preserve'
     Used in `tar' and `cp'.

`preserve-environment'
     `-p' in `su'.

`preserve-modification-time'
     `-m' in `cpio'.

`preserve-order'
     `-s' in `tar'.

`preserve-permissions'
     `-p' in `tar'.

`print'
     `-l' in `diff'.

`print-chars'
     `-L' in `cmp'.

`print-data-base'
     `-p' in Make.

`print-directory'
     `-w' in Make.

`print-file-name'
     `-o' in `nm'.

`print-symdefs'
     `-s' in `nm'.

`printer'
     `-p' in `wdiff'.

`prompt'
     `-p' in `ed'.

`query-user'
     `-X' in `shar'.

`question'
     `-q' in Make.

`quiet'
     Used in many programs to inhibit the usual output.  *Note:* every
     program accepting `--quiet' should accept `--silent' as a
     synonym.

`quiet-unshar'
     `-Q' in `shar'

`quote-name'
     `-Q' in `ls'.

`rcs'
     `-n' in `diff'.

`re-interval'
     Used in `gawk'.

`read-full-blocks'
     `-B' in `tar'.

`readnow'
     Used in GDB.

`recon'
     `-n' in Make.

`record-number'
     `-R' in `tar'.

`recursive'
     Used in `chgrp', `chown', `cp', `ls', `diff', and `rm'.

`reference-limit'
     Used in `makeinfo'.

`references'
     `-r' in `ptx'.

`regex'
     `-r' in `tac' and `etags'.

`release'
     `-r' in `uname'.

`reload-state'
     `-R' in `m4'.

`relocation'
     `-r' in `objdump'.

`rename'
     `-r' in `cpio'.

`replace'
     `-i' in `xargs'.

`report-identical-files'
     `-s' in `diff'.

`reset-access-time'
     `-a' in `cpio'.

`reverse'
     `-r' in `ls' and `nm'.

`reversed-ed'
     `-f' in `diff'.

`right-side-defs'
     `-R' in `ptx'.

`same-order'
     `-s' in `tar'.

`same-permissions'
     `-p' in `tar'.

`save'
     `-g' in `stty'.

`se'
     Used in GDB.

`sentence-regexp'
     `-S' in `ptx'.

`separate-dirs'
     `-S' in `du'.

`separator'
     `-s' in `tac'.

`sequence'
     Used by `recode' to chose files or pipes for sequencing passes.

`shell'
     `-s' in `su'.

`show-all'
     `-A' in `cat'.

`show-c-function'
     `-p' in `diff'.

`show-ends'
     `-E' in `cat'.

`show-function-line'
     `-F' in `diff'.

`show-tabs'
     `-T' in `cat'.

`silent'
     Used in many programs to inhibit the usual output.  *Note:* every
     program accepting `--silent' should accept `--quiet' as a
     synonym.

`size'
     `-s' in `ls'.

`socket'
     Specify a file descriptor for a network server to use for its
     socket, instead of opening and binding a new socket.  This
     provides a way to run, in a nonpriveledged process, a server that
     normally needs a reserved port number.

`sort'
     Used in `ls'.

`source'
     `-W source' in `gawk'.

`sparse'
     `-S' in `tar'.

`speed-large-files'
     `-H' in `diff'.

`split-at'
     `-E' in `unshar'.

`split-size-limit'
     `-L' in `shar'.

`squeeze-blank'
     `-s' in `cat'.

`start-delete'
     `-w' in `wdiff'.

`start-insert'
     `-y' in `wdiff'.

`starting-file'
     Used in `tar' and `diff' to specify which file within a directory
     to start processing with.

`statistics'
     `-s' in `wdiff'.

`stdin-file-list'
     `-S' in `shar'.

`stop'
     `-S' in Make.

`strict'
     `-s' in `recode'.

`strip'
     `-s' in `install'.

`strip-all'
     `-s' in `strip'.

`strip-debug'
     `-S' in `strip'.

`submitter'
     `-s' in `shar'.

`suffix'
     `-S' in `cp', `ln', `mv'.

`suffix-format'
     `-b' in `csplit'.

`sum'
     `-s' in `gprof'.

`summarize'
     `-s' in `du'.

`symbolic'
     `-s' in `ln'.

`symbols'
     Used in GDB and `objdump'.

`synclines'
     `-s' in `m4'.

`sysname'
     `-s' in `uname'.

`tabs'
     `-t' in `expand' and `unexpand'.

`tabsize'
     `-T' in `ls'.

`terminal'
     `-T' in `tput' and `ul'.  `-t' in `wdiff'.

`text'
     `-a' in `diff'.

`text-files'
     `-T' in `shar'.

`time'
     Used in `ls' and `touch'.

`to-stdout'
     `-O' in `tar'.

`total'
     `-c' in `du'.

`touch'
     `-t' in Make, `ranlib', and `recode'.

`trace'
     `-t' in `m4'.

`traditional'
     `-t' in `hello'; `-W traditional' in `gawk'; `-G' in `ed', `m4',
     and `ptx'.

`tty'
     Used in GDB.

`typedefs'
     `-t' in `ctags'.

`typedefs-and-c++'
     `-T' in `ctags'.

`typeset-mode'
     `-t' in `ptx'.

`uncompress'
     `-z' in `tar'.

`unconditional'
     `-u' in `cpio'.

`undefine'
     `-U' in `m4'.

`undefined-only'
     `-u' in `nm'.

`update'
     `-u' in `cp', `ctags', `mv', `tar'.

`usage'
     Used in `gawk'; same as `--help'.

`uuencode'
     `-B' in `shar'.

`vanilla-operation'
     `-V' in `shar'.

`verbose'
     Print more information about progress.  Many programs support
     this.

`verify'
     `-W' in `tar'.

`version'
     Print the version number.

`version-control'
     `-V' in `cp', `ln', `mv'.

`vgrind'
     `-v' in `ctags'.

`volume'
     `-V' in `tar'.

`what-if'
     `-W' in Make.

`whole-size-limit'
     `-l' in `shar'.

`width'
     `-w' in `ls' and `ptx'.

`word-regexp'
     `-W' in `ptx'.

`writable'
     `-T' in `who'.

`zeros'
     `-z' in `gprof'.


File: standards-ja.info  Node: Option Table-Footnotes, Up: Option Table

(1) 訳注: ここには訳するほど難解な事はないはずなので、原文のまま。



File: standards-ja.info, Node: Memory Usage, Prev: Option Table, Up: Program Behavior

メモリの使用
============

概して、たった数メガしかメモリを使わないなら、メモリの使用を減らす努力
を行うことに悩まないように。例えば、数メガ以上のファイルを扱うことが他
の事情で実際的でなかったら、それらを処理するのに入力ファイル全体をコア
に読み込むことは理に適っている。

しかしながら、普通に非常に大きいファイルを扱うことのある、`cat'や
`tail'のようなプログラムにとって、それが処理できるファイルの大きさを人
為的に制限する手法の使用は避けることが重要だ。もしプログラムが行毎に働
き、ユーザが提供する任意の入力ファイルが与えられるならば、一行だけをメ
モリに保持するべきだ。なぜなら、これは大して難しくなく、全て一度にコア
に入るよりも大きいファイルを扱えることをユーザが望むだろうからだ。

もしあなたのプログラムが複雑なデータ構造を作るなら、単にコアにそれを作っ
て、もし`malloc'がゼロを返したら致命的なエラーにしてしまいなさい。



File: standards-ja.info, Node: Writing C, Next: Documentation, Prev: Program Behavior, Up: Top

Cの一番良い使い方
*****************

この節では、GNUソフトウェアを書くときの一番良いC言語の使い方について助
言を与える。

* Menu:

* Formatting::                  あなたのソースコードの書式
* Comments::                    あなたの仕事のコメント
* Syntactic Conventions::       Cの構成のきれいな利用
* Names::                       変数と関数の名前付け
* System Portability::          異なるオペレーティング・システム間の移植性
* CPU Portability::             様々なCPUの種類のサポート
* System Functions::            "標準"ライブラリ関数の移植性
* Internationalization::        国際化の手法
* Mmap::                        `mmap'の安全な使い方



File: standards-ja.info, Node: Formatting, Next: Comments, Prev: Writing C, Up: Writing C

あなたのソースコードの書式
==========================

C関数の本体を開始する開き大括弧をゼロ列目に置き、他の開き大括弧や開き
丸括弧や開き角括弧をゼロ列目に置かないようにするのは重要だ。いくつかの
ツールは、C関数の始まりを探すのに、ゼロ列目の開き大括弧を捜す。これら
のツールはそういう風にフォーマットされていないコードでは上手く動かない
だろう。

関数定義で、関数の名前がゼロ列目で始まっていることも重要だ。人々はこれ
のおかげで関数定義を探すのが楽になり、あるツールがそれらを認識するのも
楽になるかもしれない。こうして、適切な書式は次のようになる。

     static char *
     concat (s1, s2)        /* Name starts in column zero here */
          char *s1, *s2;
     {                     /* Open brace in column zero here */
       ...
     }

あるいは、もしANSI Cを使いたいなら、次のように定義をフォーマットする。

     static char *
     concat (char *s1, char *s2)
     {
       ...
     }

ANSI Cでは、もし引数が上手く一行に収まらないなら、次のようにそれを分け
る。

     int
     lots_of_args (int an_integer, long a_long, short a_short,
                   double a_double, float a_float)
     ...

関数の本体では、次のようにフォーマットされたコードを好んでいる。

     if (x < foo (y, z))
       haha = bar[4] + 5;
     else
       {
         while (z)
           {
             haha += foo (z, z);
             z--;
           }
         return ++x + bar ();
       }

我々は開き丸括弧の前とコンマの後にスペースがあるとプログラムを読むのが
より簡単であることを見出している。とりわけコンマの後は。

式を複数行に分けるとき、演算子の後ではなく、それの前で分ける。こうする
のが正しいやり方だ。

     if (foo_this_is_long && bar > win (x, y, z)
         && remaining_condition)

字下げが同じところで、異なる優先度の二つの演算子を持たないようにしなさ
い。例えば、こう書いてはいけない。

     mode = (inmode[j] == VOIDmode
             || GET_MODE_SIZE (outmode[j]) > GET_MODE_SIZE (inmode[j])
            ? outmode[j] : inmode[j]);

代わりに、字下げが入れ子を表すよう、余分な丸括弧を使う。

     mode = ((inmode[j] == VOIDmode
              || (GET_MODE_SIZE (outmode[j]) > GET_MODE_SIZE (inmode[j])))
             ? outmode[j] : inmode[j]);

Emacsがそのコードを適切に字下げするよう、余分な丸括弧を入れなさい。例
えば、次の字下げは手でやるといい感じだが、Emacsは台なしにしてしまう。

     v = rup->ru_utime.tv_sec*1000 + rup->ru_utime.tv_usec/1000
         + rup->ru_stime.tv_sec*1000 + rup->ru_stime.tv_usec/1000;

でも開き括弧一組を加えると問題は解決する。

     v = (rup->ru_utime.tv_sec*1000 + rup->ru_utime.tv_usec/1000
          + rup->ru_stime.tv_sec*1000 + rup->ru_stime.tv_usec/1000);

do-while文は次のようにフォーマットする。

     do
       {
         a = foo (a);
       }
     while (a > 0);

フォームフィード文字 (control-L) を使って、プログラムを(関数の中ではな
く) 論理的な位置でページに分割してほしい。ページがどれぐらいの長さかな
んて問題じゃない。印刷されるページに合わせなくていいのだから。フォーム
フィードは行の中にそれ自身だけを置くべきだ。




File: standards-ja.info, Node: Comments, Next: Syntactic Conventions, Prev: Formatting, Up: Writing C

あなたの仕事のコメント
======================

どんなプログラムでもそれが何なのか簡単に表すコメントで始まるべきだ。例:
`fmt - filter for simple filling of text'.

英語は全ての国のほとんど全てのプログラマが読むことのできる唯一の言語な
ので、GNUプログラムでは英語でコメントを書いてほしい。もしあなたが英語
を上手く書けないなら、出来るだけ上手く英語でコメントを書き、他の人々に
それらを書き直すのを手伝ってくれるよう頼んでください。もし英語でコメン
トを書くことができないなら、一緒に仕事してくれる誰かを探して、あなたの
コメントを英語に翻訳してもらってください。

それぞれの関数に、その関数が何をやり、どういう引数を受け取り、引数のあ
り得る値が何を意味し、そして何に使われるのかを表すコメントを書いてくだ
さい。もしCの型が習慣的なやり型で使われるなら、Cの引数宣言の意味をくど
くどと複製する必要はない。もしその利用が(実際には文字列の最初ではなく、
二文字目のアドレスである`char *'型の引数のような)標準的でないものだっ
たら、あるいは、(改行を含む文字列は動作保証されない、というような)期待
される方法では働かない値があり得るなら、そう書くのを忘れないようにしな
さい。

また、もしあるなら、返り値の意味を説明しなさい。

Emacsのセンテンス・コマンド(sentence command)が働くように、コメントの
行の最後の後に二つのスペースを置いてください。また、完全な文を書き、最
初の単語を大文字で書いてください。もし小文字の識別子が文の最初に来たら、
それを大文字で書いてはいけない! 綴りを変えると違う識別子になる。もし小
文字で文を始めるのが好きじゃないなら、文を違うように書きなさい(例えば、
"The identifier lower-case is ...")。

関数の上のコメントは、引数の値について言うときにその引数の名前を使えば、
ずっとはっきりする。変数名それ自体は小文字であるべきだが、変数そのもの
ではなく、その値について言っているときには大文字で書きなさい。従って、
"an inode"よりも、"the inode number NODE_NUM"である。

普通コメントに関数の名前を再び言うことに意味はない。なぜなら、読者は自
分でそれを見ることができるからだ。関数自身がスクリーンの一番下からはみ
出てしまうぐらいコメントが長いときは例外かもしれない。

静的な変数それぞれにも、次のようにコメントがあるべきだ。

     /* Nonzero means truncate lines in the display;
        zero means continue them.  */
     int truncate_lines;

すべての`#endif'に、入れ子になっていない(たった数行の)短い条件分岐の場
合を除いて、コメントを付けるべきだ。そのコメントには、*その意味を含め
て*、終了する条件分岐の状態を記すべきだ。`#else'はその条件と続くコード
の*意味*を記述するコメントを持つべきだ。例えば、

     #ifdef foo
       ...
     #else /* not foo */
       ...
     #endif /* not foo */
     #ifdef foo
       ...
     #endif /* foo */

しかし、対照的に、`#ifndef'では次のようなコメントを書く。

     #ifndef foo
       ...
     #else /* foo */
       ...
     #endif /* foo */
     #ifndef foo
       ...
     #endif /* not foo */



File: standards-ja.info, Node: Syntactic Conventions, Next: Names, Prev: Comments, Up: Writing C

Cの構成のきれいな利用
=====================

関数への全ての引数を明示的に宣言してください。それらが単に`int'だから
という理由で省いていけない。

外部関数とソースファイルの後ろに現れる関数の宣言は、ファイルの先頭の近
く一箇所か、ヘッダファイルの中に書くべきだ。関数の中に`extern'宣言を置
いてはいけない。

以前、一つの関数内で繰り返し繰り返し異なる値のために(`tem'のような名前
で)同じ局所変数を使うのが普通のやり方だった。こうする代わりに、別の目
的毎に別の局所変数を宣言し、意味のある名前を付ける方がより良い。これで
プログラムがより理解しやすくなるだけでなく、良いコンパイラの最適化を促
進するのである。また、局所変数の宣言をそれぞれ、それを全て使用する一番
小さい領域に入れることができる。こうすると、プログラムがさらにきれいに
なるのだ。

大域識別子を隠す局所変数や引数を使ってはならない。

複数行に及ぶ一つの宣言で複数の変数を宣言してはいけない。代わりに、それ
ぞれ行で新しく宣言を始めなさい。例えば、こうする代わりに、

     int    foo,
            bar;

こう書くか、

     int foo, bar;

あるいは、こうする。

     int foo;
     int bar;

(もしそれらが大域変数なら、いずれにせよその前にコメントを付けるべきだ。)

他の`if'文に入れ子になる`if'-`else'文があるとき、必ずその`if'-`else'の
周りに大括弧を付ける。従って、次のように決して書いてはならない。

     if (foo)
       if (bar)
         win ();
       else
         lose ();

常に次のようにする。

     if (foo)
       {
         if (bar)
           win ();
         else
           lose ();
       }

もし`else'文の中に入れ子になる`if'文があれば、次のように、`then'部分を
その前の`then'部分のように字下げして一行に`else if'を書くか、

     if (foo)
       ...
     else if (bar)
       ...

あるいは、次のように大括弧の中に入れ子の`if'を書く。

     if (foo)
       ...
     else
       {
         if (bar)
           ...
       }

同じ宣言で、構造体のタグや変数、typedefを一緒に宣言してはならない。代
わりに、構造体のタグを別に宣言して、それから変数やtypedefを宣言する。

`if'条件文内で代入しないようにしなさい。例えば、こう書いてはいけない。

     if ((foo = (char *) malloc (sizeof *foo)) == 0)
       fatal ("virtual memory exhausted");

代わりに、こう書く。

     foo = (char *) malloc (sizeof *foo);
     if (foo == 0)
       fatal ("virtual memory exhausted");

`lint'をおとなしくするのに、プログラムを見苦しくしてはならない。`void'
へのキャストを入れないでください。キャストなしのゼロは、可変引数の関数
を呼ぶときを除くと、ヌル・ポインタ定数として全く結構である。



File: standards-ja.info, Node: Names, Next: System Portability, Prev: Syntactic Conventions, Up: Writing C

変数と関数の名前付け
====================

プログラムの大域的な変数や関数の名前はコメントのように働く。だから、簡
潔な名前を選ばないように。--代わりに、その変数や関数の意味について役に
立つ情報を与える名前を探しなさい。GNUプログラムでは、名前は他のコメン
トと同様英語であるべきである。

局所変数の名前はもっと短くていい。なぜなら、それらは一つの文脈の中でだ
け使われ、そこでは(たぶん)コメントがそれらの目的を説明している。

ある名前の単語を分けるのに、Emacsの単語コマンドがその中で使えるように、
アンダースコアを使ってください。小文字にしておきなさい。大文字をマクロ
や`enum'定数や一定の取り決めに従う接頭辞のために取っておきなさい。

例えば、`ignore_space_change_flag'のような名前を使うべきだ。
`iCantReadThis'のような名前を使ってはいけない。

コマンドラインのオプションが指定されたかどうかを示す変数は、オプション
の文字ではなく、オプションの意味にちなんだ名前を付けるべきだ。コメント
がオプションの正確な意味とその文字の両方を記述すべきだ。例えば、

     /* Ignore changes in horizontal whitespace (-b).  */
     int ignore_space_change_flag;

一定の整数値に名前を定義したいとき、`#define'よりも`enum'を使いなさい。
GDBは列挙定数について知っている。

古いSystem Vシステムで不必要な問題を引き起こさないよう、14文字以下のファ
イル名を使いなさい。これを試験するのに`doschk'というプログラムを使うこ
とができる。`doschk'はまた、MS-DOSファイルシステムにファイルが置かれた
としたら、名前が衝突する可能性を試験する。--注意してもしなくても構わな
いものだ。



File: standards-ja.info, Node: System Portability, Next: CPU Portability, Prev: Names, Up: Writing C

システム間の移植性
==================

Unixの世界では、"移植性"は異なるUnixバージョンに移植することを言ってい
る。GNUプログラムにとって、この種の移植性は望ましいが、最も重要ではな
い。

GNUソフトウェアの主要な目的は、GNUカーネルの上で走り、GNU Cコンパイラ
でコンパイルされ、様々なCPU上で動くことだ。異なるCPU上のGNUシステム間
の多様性の量と種類は、今日のLinuxに基づくGNUシステムやBSDシステム間の
多様性と比較できる程度であろう。だから、絶対に必要な移植性の種類はかな
り限られている。

しかしたくさんのユーザがGNUソフトウェアをGNUでないUnixやUnix-likeシス
テムで走らせている。だから、さまざまなUnix-likeシステムをサポートする
ことが望ましい。最も重要ではないけれど。

ほとんどのUnix-likeシステムへの移植性を得る一番簡単な方法はAutoconfを
使うことだ。あなたのプログラムがAutoconfが提供できる以上にホスト・プラッ
トホームに関する情報を知る必要があることはあまりない。単にそういう情報
を必要とするプログラムの大部分はすでに書かれているから。

準内部的データベース(例えば、ディレクトリ)のフォーマットを使わないよう
にしなさい。もっと高水準の方法(`readdir')があるときは。

MSDOS、Windows、Macintosh、VMS、MVSのような、Unixに似てないシステムに
ついて言うと、それらをサポートするのは普通しない方がいいぐらい大変な仕
事だ。

計画されているGNUカーネルはまだ出来てないが、GNU Cライブラリのマニュア
ルを見ることで、それが提供するであろう機能がどれなのか分かる。GNUカー
ネルはMachに基づいているから、Machの機能も利用できるだろう。しかしなが
ら、Machの機能を使用すると、おそらくあなたのプログラムを今日デバッグす
る困難に見舞われるだろう (1) (*Note System Portability-Footnotes::)。



File: standards-ja.info  Node: System Portability-Footnotes, Up: System Portability

(1) 訳注: 今日デバッグするってどういうこと？ 原文: However, if you use
Mach features, you'll probably have trouble debugging your program
today.



File: standards-ja.info, Node: CPU Portability, Next: System Functions, Prev: System Portability, Up: Writing C

CPU間の移植性
=============
GNUシステムでさえ、CPUタイプ間の違いのせいで異なってしまうだろう。--- 
例えば、バイト順序や境界の必要性の違いなどだ。こういう違うを扱うことは
絶対に不可欠だ。しかし、`int'が32ビットより小さい可能性を扱うために努
力してはいけない。GNUでは16ビットのマシンはサポートしない。

`int'オブジェクトのアドレスがまたその一番下のバイトのアドレスであると
みなしてはいけない。これはビッグ・エンディアンのマシンでは誤りだ。だか
ら、次の間違いをしてはいけない。

     int c;
     ...
     while ((c = getchar()) != EOF)
       write(file_descriptor, &c, 1);

関数を呼ぶとき、さまざまな型のポインタ間やポインタと整数間での違いを心
配する必要はない。ほとんどのマシンでは、いずれにせよ違いはない。違いの
あるわずかなマシンについて言うと、それらの全てがANSI Cをサポートしてい
るので、それらのシステム上でそのコードが動くように、(ANSI Cでだけ使わ
れるように条件付けされた)プロトタイプを使うことができる。

ある場合には、整数とポインタの引数を無差別に同じ関数へ渡し、いかなるシ
ステムでもプロトタイプを使わないでも構わない。例えば、多くのGNUプログ
ラムは`printf'やその類いに引数をどんどん渡すエラー報告関数を持っている。

     error (s, a1, a2, a3)
          char *s;
          int a1, a2, a3;
     {
       fprintf (stderr, "error: ");
       fprintf (stderr, s, a1, a2, a3);
     }

実際、これは全てのマシンで動作し、他の"正しい"やり方よりずっと単純だ。
そのような関数に対してプロトタイプを使うことを*しない*ように。

しかしながら、本当に必要としているのでないなら、ポインタを整数にキャス
トしないようにしなさい。これらの仮定は実に移植性を減らしており、ほとん
どのプログラムでは簡単に避けられる。ポインタから整数にキャストすること
が不可欠な --アドレスだけでなく型情報をあるワードに収めるLispインター
プリタ、のような-- 場合には、そうして構わないが、異なるワードサイズを
扱う明示的な準備をしなくてはならないだろう。



File: standards-ja.info, Node: System Functions, Next: Internationalization, Prev: CPU Portability, Up: Writing C

システム関数の呼び出し
======================

Cの実装は十分に違う。ANSI Cは非互換性を減らすが、無くなりはしない。そ
の一方では、多くのユーザがGNUソフトウェアをANSI以前のコンパイラでコン
パイルしたがる。この章では、移植性を不必要に失くさないよう、標準Cライ
ブラリ関数をどれぐらいたくさん、あるいは、少なく使うか、推奨する方法を
見せる。

   * `sprintf'の値を使ってはいけない。あるシステムでは書かれた文字の数
     を返し、すべてのシステムでそうだというわけではない。

   * `main'は`int'型を返すと宣言するべきだ。それは`exit'を呼ぶか、整数
     状態コードを返すことによって終了するべきだ。決して未定義の値を返
     すことができないようにしなさい。

   * システム関数を明示的に宣言してはならない。

     あるシステムでは、システム関数の宣言はほとんどが間違っている。衝
     突を最小化するために、システム関数を宣言するのをシステムのヘッダ
     ファイルに任せなさい。もしヘッダが関数を宣言しなければ、宣言せず
     に置いておきなさい。

     関数を宣言せずに使うのはきれいじゃないように見えるかもしれないが、
     実際にはこれが本当に起こるシステム上の、ほとんどのシステムライブ
     ラリ関数に対して上手く働く。対照的に、現実の宣言は頻繁に現実の衝
     突を引き起こしている。

   * もしシステム関数を宣言しなければならないなら、引数の型を指定して
     はいけない。ANSIプロトタイプではなく、古い形式の宣言を使いなさい。
     関数を特定すればするほど、衝突しがちになる。

   * 特に、無条件に`malloc'や`realloc'を宣言してはいけない。

     ほとんどのGNUプログラムは、慣習的に`xmalloc'や`xrealloc'と名付け
     られる関数の中で、たった一回だけそれらを使用する。これらの関数は
     それぞれ`malloc'や`realloc'を呼び、結果を確認する。

     `xmalloc'や`xrealloc'はあなたのプログラムで定義されるので、型の衝
     突の危険性なしに他のファイルにそれらを宣言できる。

     ほとんどのシステム上で、`int'はポインタと同じ長さだ。それゆえ、
     `malloc'や`realloc'の呼び出しは上手く動く。数少ない例外的なシステ
     ム(ほとんどは64ビット・マシン)では、`malloc'や`realloc'の*条件付
     き*宣言を使うか、これらの宣言をそれらのシステムに特化した設定ファ
     イルに置くことができる。

   * 文字列関数は特別な扱いが必要だ。いくつかのUnixシステムは
     `string.h' というヘッダファイルを持っている。他では`strings.h'を
     持っている。どっちのファイル名も可搬性がない。できることは二つあ
     る。どっちのファイルをインクルードするかAutoconfで見付け出すか、
     どっちもインクルードしないかだ。

   * 文字列のファイルをどっちもインクルードしないなら、普通の方法では
     ヘッダファイルから文字列関数の宣言を得ることができない。

     このことは、あなたが思うよりも問題を起こさない。多くのシステムが
     まだサポートしていないので、いずれにせよ、新しいANSI文字列関数は
     避けるべきだ。使って良い文字列関数は次の通りだ。

          strcpy   strncpy   strcat   strncat
          strlen   strcmp    strncmp
          strchr   strrchr

     複製や連結の関数は、それらの値を使わない限り、宣言なしで上手く働
     く。宣言なしにそれらの値を使うと、ポインタの大きさが`int'の大きさ
     と違うシステムや、おそらく他の場合に失敗する。それらの値を使うの
     を避けるのはささいなことだから、そうしなさい。

     比較の関数や`strlen'は、ほとんどのシステムで、おそらくGNUソフトウェ
     アが動くすべてのシステムで、宣言なしに上手く働く。少数のシステム
     で*条件付きで*それらを宣言することが必要だと気付くかもしれない。

     検索関数は`char *'を返すと宣言されなければならない。幸運にも、そ
     れらが返すデータ型には多様性がない。しかしそれらの名前には多様性
     がある。あるシステムでは、それらの関数に`index'と`rindex'という名
     前を付けている。他のシステムでは、`strchr'と`strrchr'という名前を
     使う。あるシステムは両方の名前をサポートするが、どっちも全てのシ
     ステムで働くわけではない。

     片方の組の名前を取り出し、プログラム中でそれを使うべきだ。(今日で
     は、新しいプログラムには`strchr'と`strrchr'を選ぶのがより良い。そ
     れらは標準のANSI名だから。) それらの名前を両方とも`char *'を返す
     関数として宣言しなさい。それらの名前をサポートしないシステムでは、
     他方の組のことばをマクロとして定義しなさい。例えば、`strchr'と
     `strrchr'の名前を通して使いたいなら、ファイルの始め(あるいはヘッ
     ダに)次のように書いておく。

          #ifndef HAVE_STRCHR
          #define strchr index
          #endif
          #ifndef HAVE_STRRCHR
          #define strrchr rindex
          #endif

          char *strchr ();
          char *strrchr ();

ここでは、`HAVE_STRCHR'と`HAVE_STRRCHR'が対応する関数が存在するシステ
ムでは定義されるマクロだとみなしている。それらを適切に定義する一つのや
り方はAutoconfを使うことだ。



File: standards-ja.info, Node: Internationalization, Next: Mmap, Prev: System Functions, Up: Writing C

国際化
======

GNUはあるプログラムのメッセージを様々な言語に翻訳するのを容易にするGNU
gettextと呼ばれるライブラリを持っている。あらゆるプログラムでこのライ
ブラリを使うべきだ。メッセージがプログラムに現れるとき、それらに英語を
使いなさい。そして、それらを他の言語に翻訳するための方法をgettextで提
供しなさい。

GNU gettextの使用は翻訳が必要かもしれない、それぞれの文字列の周りに
`gettext'マクロの呼び出しを付けることを含む --次のように。

     printf (gettext ("Processing file `%s'..."));

こうすると、GNU gettextが文字列`"Processing file `%s'..."'を翻訳された
バージョンで置き換えられる。

一度プログラムがgettextを使うことになったら、翻訳が必要な新しい文字列
を加えるとき、`gettext'への呼び出しを書く地点を作ってください。

あるパッケージでのGNU gettextの使用は、そのパッケージに対して"テキスト
領域名"を指定することを含む。テキスト領域名はこのパッケージの翻訳を他
のパッケージの翻訳と分離するのに使われる。通常、テキスト領域名はパッケー
ジの名前と同じであるべきだ --例えば、GNU file utilityのために
`fileutils'が使われる。

gettextが上手く働くようにするために、単語や文の構造に仮定を設けるコー
ドを書かないようにしなさい。文の正確なテキストがデータによって変わるの
ようにしたいとき、条件付けられた単語や句を単一の文脈構成に押し込むより
も、それぞれ完全な文を含む二つ以上の文字列定数を使いなさい。

これがやるべきではないものの例だ。

     printf ("%d file%s processed", nfiles,
             nfiles != 1 ? "s" : "");

この例の問題は複数形が`s'を加えることで行われると仮定していることだ。
もし書式文字列にgettextを適用するなら、次のように、メッセージが異なる
単語を使うことができるが、

     printf (gettext ("%d file%s processed"), nfiles,
             nfiles != 1 ? "s" : "");

複数形が`s'を使うようになお強制されている。これがより良い方法だ。

     printf ((nfiles != 1 ? "%d files processed"
              : "%d file processed"),
             nfiles);

このやり方で、二つの文字列それぞれに独立してgettextを適用できる。

     printf ((nfiles != 1 ? gettext ("%d files processed")
              : gettext ("%d file processed")),
             nfiles);

こうすると、"file"という単語の複数形を作る、いかなる方法でも実現でき、
"processed"に対して、単語が一致しないといけない言語を扱うこともできる。

同じような問題は次のコードで文脈の構造の水準で現れる。

     printf ("#  Implicit rule search has%s been done.\n",
             f->tried_implicit ? "" : " not");

このコードに`gettext'呼び出しを与えても、すべての言語で正しい結果を得
られるわけではない。なぜなら、いくつかの言語で否定は文中に一つよりもた
くさんの場所で単語を加える必要があるからだ。対照的に、`gettext'呼び出
しの追加は、もしそのコードが次のように始まるなら、簡単に行える。

     printf (f->tried_implicit
             ? "#  Implicit rule search has been done.\n",
             : "#  Implicit rule search has not been done.\n");



File: standards-ja.info, Node: Mmap, Prev: Internationalization, Up: Writing C

Mmap
====

`mmap'がすべてのファイルに働くとも、すべてのファイルで失敗するとも、み
なしてはいけない。一部のファイルでは上手く行き、他では駄目かもしれない。

`mmap'を使う適切な方法は、使いたい特定のファイルで試してみることだ。
---そして、もし`mmap'が働かなかったら、`read'や`write'を
使う他の方法で作業することに頼りなさい。

この用心が必要である理由はGNUカーネル(HURD)はユーザが拡張可能なファイ
ルシステムを提供することで、そこではたくさんの異なる種類の"普通のファ
イル" があり得る。それらの多くは`mmap'をサポートするが、いくつかはしな
い。プログラムをすべてのそういうファイルを扱えるようにすることは重要だ。



File: standards-ja.info, Node: Documentation, Next: Managing Releases, Prev: Writing C, Up: Top

プログラムの文書化
******************

* Menu:

* GNU Manuals::                 適切なマニュアルの執筆
* Manual Structure Details::    特定の構造の慣習
* NEWS File::                   NEWSファイル補足マニュアル
* Change Logs::                 変更の記録
* Man Pages::                   manページは二番目だ。
* Reading other Manuals::       どれほど他のマニュアルから学ぶことができるか。



File: standards-ja.info, Node: GNU Manuals, Next: Manual Structure Details, Prev: Documentation, Up: Documentation

GNUマニュアル
=============

GNUシステムの一部を文書にする好ましい方法はTexinfo整形言語でマニュアル
を書くことだ。Texinfoのマニュアルを、ハードコピーか、`info'やEmacsの
Infoサブシステム(`C-h i')を使って利用できるオンラインのバージョンで見
なさい。

プログラマはしばしば、彼らが知っている実装の構造に従う文書を構成するの
が最も自然だと感じる。しかしこの構造はそのプログラムの使い方を説明する
には必ずしも良いとは言えない。それはユーザには関係がなく、ユーザを混乱
させるかもしれない。

段落の文から別々のマニュアルに論題を分類することまで、あらゆる水準で、
文書を構成する正しい方法は、それを読むときにユーザが心に抱くであろう概
念や疑問に従う。ときどきこの考えの構造は文書化されるソフトウェアの実装
の構造と一致する。--でもしばしばそれらは異なる。しばしば良い文書を執筆
するために学ぶ一番重要な部分は、実装のように文書を構成していて、もっと
良い別の構成について考えるときに気付くことを学ぶことだ。

例えば、GNUシステムのそれぞれのプログラムはおそらく一つのマニュアルに
記述されるべきだ。しかしこれはそれぞれのプログラムがそれ自身のマニュア
ルに文書化されるべきであることを意味していない。このことはユーザが理解
するのを助ける構造よりもむしろ、その実装の構造に従っているだろう。

代わりに、それぞれのマニュアルは密接な*論題*を包含するべきだ。例えば、
`diff'のマニュアルと`diff3'のマニュアルの代わりに、`cmp'だけでなく、こ
れらのプログラム両方も包含する、"ファイルの比較" のマニュアルが一つあ
る。それらのプログラムを一緒に文書にすることで、全体の主題をよりすっき
りさせることができる。

プログラムを論じるマニュアルはそのプログラムのコマンドライン・オプショ
ン全てとそのコマンド全てを記述すべきだ。それはそれらの使用例を与えるべ
きだ。しかしマニュアルを機能の列挙として構成してはならない。代わりに、
副題によって、論理的に構成しなさい。プログラムが行う仕事について考える
ときにユーザが尋ねるであろう質問を提出しなさい。

概して、GNUマニュアルは指導書と参考書の両方に役に立つべきだ。それは
Info によりそれぞれの論題に対する便利な手段のために、そして(付録は別と
して)通読するために作り上げられるべきだ。GNUマニュアルは始めから通して
読む初心者への良い紹介を行うべきで、ハッカーが欲しがる詳細のすべてを与
えるべきでもある。

そのことは最初に思われるほど難しくない。それぞれの章をその論題の論理的
な分類として整理しなさい。しかしその節を整頓して、それらのテキストを執
筆しなさい。その章を通読することが意味を為すように。その著書を章に構成
するときや、節を段落に構成するとき、同様にしなさい。その標語は、*それ
ぞれの地点で、先行するテキストによって上げられた最も基本的で最も重要な
話題を提出しなさい*、だ。

必要なら、マニュアルの最初に、純粋に指導的で、主題の基礎を包含する、余
分な章を入れなさい。これらは初心者がマニュアルの残りを理解するための枠
組みを提供する。Bisonのマニュアルはこれの使い方の良い例を提供する。

GNUの文書を書き方の手本としてUnixのmanページを使ってはいけない。それら
のほとんどは簡潔で、構成が悪く、根底にある概念について不適切な説明を与
えている。(もちろん例外はある。) またUnixのmanページはGNUマニュアルで
使用するものとは異なる、特有の構成を使用する。

Unixの文書で使われる"pathname"という用語を使わないでください。代わりに
"file name"(二語)を使いなさい。"path"という用語は検索パスに対してのみ
使用し、それはファイル名のリストだ。

コンピュータ・プログラムへの間違った入力を表すのに、"illegal"という用
語を使わないでください。このためには"invalid"を使い、"illegal"という用
語は違法のために確保してください。



File: standards-ja.info, Node: Manual Structure Details, Next: NEWS File, Prev: GNU Manuals, Up: Documentation

マニュアルの構造の詳細
======================

マニュアルの表紙は、そのマニュアルで記述されるプログラムやパッケージの
バージョンを述べるべきだ。マニュアルの一番上の節もまたこの情報を含むべ
きだ。もしマニュアルがプログラムより頻繁に、あるいは、無関係に変更され
ているなら、それらの場所の両方で、そのマニュアルのバージョン・ナンバー
を記述しなさい。

そのマニュアルで記述されるそれぞれのプログラムは、`PROGRAM Invocation'
とか`Invoking PROGRAM'と名付けられた節を持つべきだ。この節は(もしあれ
ば、その副節と共に)そのプログラムのコマンドラインの引数とそれの走らせ
方(人々がmanページで探し求める情報の類い)を記すべきだ。そのプログラム
が使う、すべてのオプションと引数のテンプレートを含む`@example'で始めな
さい。

あるいは、項目の名前が上の様式の一つに合う表に項目を書きなさい。これは、
その節の本当の名前とは関係なしに、この目的のための節として、項目が指し
示す節を識別する (1) (*Note Manual Structure Details-Footnotes::)。


プログラム名を指定し、そのマニュアルのこれの部分だけを素早く読むための
自動的な機能があるだろう。

もし一つのマニュアルがいくつかのプログラムを記述するなら、それぞれのプ
ログラムを記述する節を持つべきだ。


File: standards-ja.info  Node: Manual Structure Details-Footnotes, Up: Manual Structure Details

(1) 訳注: 自分でも何書いてるのか意味不明。訂正乞う。原文:
Alternatively, put a menu item in some menu whose item name fits one
of the above patterns.  This identifies the node which that item
points to as the node for this purpose, regardless of the node's
actual name.



File: standards-ja.info, Node: NEWS File, Next: Change Logs, Prev: Manual Structure Details, Up: Documentation

NEWSファイル
============

マニュアルに加えて、パッケージは言及するに値するユーザに見える変更の一
覧を含む`NEWS'と名付けられたファイルを持つべきだ。新しいリリース毎に、
そのファイルの前に項目を加え、それらが属するバージョンを同定しなさい。
古い項目を捨てないように。新しい項目の後へ、そのファイルの中に残してお
きなさい。こうして、以前のどのバージョンからアップグレードするユーザで
も何が新しいのかを見ることができる。

もし`NEWS'ファイルが非常に長くなれば、古い項目をいくらか`ONEWS'という
名前のファイルに移し、ユーザがそのファイルを参照するために最後に覚え書
きを書いておきなさい。



File: standards-ja.info, Node: Change Logs, Next: Man Pages, Prev: NEWS File, Up: Documentation

変更履歴
========

変更履歴にプログラムのソースファイルに行われた変更を全て記述し続けなさ
い。これの目的は将来バグを発見する人々がそのバグを入れた変更が分かるよ
うにすることだ。しばしば新しいバグは最近何が変わったのかを見ることで発
見され得る。さらに重要なことに、変更履歴は矛盾する概念がいかに起きそれ
らが誰に起因するのかということについての履歴を与えてくれるので、プログ
ラムの異なる部分間での概念的な矛盾を失くすことに役立つことができるのだ。

* Menu:

* Change Log Concepts::         
* Style of Change Logs::        
* Simple Changes::              
* Conditional Changes::         



File: standards-ja.info, Node: Change Log Concepts, Next: Style of Change Logs, Prev: Change Logs, Up: Change Logs

変更履歴の概念
--------------

変更履歴を、もっと前のバージョンが現在のバージョンとどう違うかを説明す
る、概念な"復元一覧表"として考えることができる。人々は現在のバージョン
を見ることができる。彼らは何がその中にあるのかを言うのに変更履歴を必要
としない。変更履歴から欲しいものはもっと前のバージョンがどう違ったのか
に関する、すっきりした説明だ。

変更履歴ファイルは通常`ChangeLog'と呼ばれ、ディレクトリ全体を包含する。
それぞれのディレクトリはそれ自身の変更履歴を持って良いし、あるディレク
トリはその親ディレクトリの変更履歴を使って良い。--それはあなたに任され
る。

他のやり方は変更履歴をRCSやCVSのようなバージョン管理システムで記録する
ことだ。これは自動的に`ChangeLog'ファイルに変換される。

変更の目的全部やそれらが一緒にどう働くのかを記述する必要性はない。もし
変更が説明を必要とすると考えるなら、おそらくその通りだ。それを説明して
ください。--しかしコードのコメントに説明を入れてください。そこは人々が
そのコードを見るときはいつでも見るところだろう。例えば、関数を加えると
き、"New function"は変更履歴には十分だ。なぜなら、それが何をするのか説
明するために、関数定義の前にコメントがあるはずだからだ。

しかしながら、ときどき変更の組の全体の目的を記述する一行を書くのが有用
だ。

`ChangeLog'に項目を加える一番簡単な方法はEmacsのコマンド、`M-x
add-change-log-entry'を使うことだ。項目はアスタリスク、変更されたファ
イルの名前、そして変更された関数、変数、それ以外のものの名前を丸括弧の
中に含むべきだ。その後にコロンを付ける。そしてその関数や変数に行った変
更を記述しなさい。



File: standards-ja.info, Node: Style of Change Logs, Next: Simple Changes, Prev: Change Log Concepts, Up: Change Logs

変更履歴の形式
--------------

ここに変更履歴の項目の例をいくつか挙げる。

     * register.el (insert-register): Return nil.
     (jump-to-register): Likewise.

     * sort.el (sort-subr): Return nil.

     * tex-mode.el (tex-bibtex-file, tex-file, tex-region):
     Restart the tex shell if process is gone or stopped.
     (tex-shell-running): New function.

     * expr.c (store_one_arg): Round size up for move_block_to_reg.
     (expand_call): Round up when emitting USE insns.
     * stmt.c (assign_parms): Round size up for move_block_from_reg.

変更された関数や変数を略さずに名前を付けることが重要だ。関数や変数の名
前を略していけない。そして、それらをくっ付けてはいけない。その後の管理
者はしばしばある関数に属する変更履歴の項目を全部見付けるのに、関数名で
検索するだろう。もしその名前を略していると、彼らは検索するときそれを見
付けられないだろう。

例えば、ある人々は`* register.el ({insert,jump-to}-register)'と書くこ
とで、関数名の集まりを略する傾向がある。これは良くない考えだ。
`jump-to-register'や`insert-register'の検索はその項目を見付けないだろ
うから。

無関係な変更履歴の項目を空行で分けなさい。二つの項目が一緒に働き、同じ
変更部分を表しているとき、それらの間に空行を入れてはいけない。そして、
続いている項目が同じファイルにあるとき、そのファイル名とアスタリスクを
省いて良い。



File: standards-ja.info, Node: Simple Changes, Next: Conditional Changes, Prev: Style of Change Logs, Up: Change Logs

単純な変更
----------

ある単純な類いの変更は変更履歴にやたら詳細に記す必要はない。

単純なやり方で関数の呼び出し順序を変更し、その関数の呼び出し元を全て変
更するとき、変更した呼び出し元全てに個々の項目を作る必要はない。単に呼
ばれる関数の項目に"All callers changed"と書きなさい。

     * keyboard.c (Fcommand_execute): New arg SPECIAL.
     All callers changed.

コメントや解説の文字列だけを変更するとき、関数に言及せずに、そのファイ
ルの項目を書けば十分だ。単なる"Doc fixes"だけで変更履歴には十分だ。

解説ファイルのための変更履歴の項目は作る必要はない。これは解説は直すの
が困難であるバグに影響しないからだ。解説は正確に設計されたやり方で相互
作用するに違いない部分から成り立っているわけではない。誤りを正すために、
間違った経過の履歴を知る必要はない。その解説が言っていることと、そのプ
ログラムが実際に働く方法を比較すれば十分だ。



File: standards-ja.info, Node: Conditional Changes, Prev: Simple Changes, Up: Change Logs

条件文の履歴
------------

Cのプログラムはしばしばコンパイル時の`#if'条件文を含む。たくさんの変更
は条件文だ。ときどき条件文に全体的に含まれている新しい定義を加える。変
更履歴にその変更が適用されるのがどれか条件を示すことは非常に役に立つ。

条件付きの変更を示す我々の慣習は条件の名前の周りに角括弧を使うことだ。

ここで、条件付きだが、それに付随する関数や実体の名前を持たない変更を記
述する、簡単な例を挙げる。

     * xterm.c [SOLARIS2]: Include string.h.

ここで全部条件付きである新しい定義を記述する項目を挙げる。
`FRAME_WINDOW_P'というマクロに対するこの新しい定義は`HAVE_X_WINDOWS'が
定義されているときだけ使われる。

     * frame.h [HAVE_X_WINDOWS] (FRAME_WINDOW_P): Macro defined.

ここに、全体として定義は無条件だが、変更自体は`#ifdef HAVE_LIBNCURSES'
条件に含まれる、`init_display'という関数内での変更に対する項目を挙げる。

     * dispnew.c (init_display) [HAVE_LIBNCURSES]: If X, call tgetent.

ここであるマクロが定義され*ない*ときだけ影響を持つ変更の項目を挙げる。

     (gethostname) [!HAVE_SOCKETS]: Replace with winsock version.



File: standards-ja.info, Node: Man Pages, Next: Reading other Manuals, Prev: Change Logs, Up: Documentation

manページ
=========

GNUプロジェクトでは、manページは副次的だ。あらゆるGNUプログラムがmanペー
ジを持つことは必要でないか期待されていない。しかし一部は持っている。あ
なたのプログラムにmanページを含めるかどうかはあなたの選択である。

この決定をするとき、manページをサポートするにはそのプログラムが変更さ
れる時毎に継続的な努力が必要であることを考えなさい。そのmanページに費
す時間はもっと有用な作業から奪われる時間なのだ。

ほとんど変更しない簡単なプログラムでは、manページの更新はちょっとした
作業かもしれない。そして、もし持っていれば、manページを含めない理由は
ほとんどない。

多量に変更する大きなプログラムでは、manページの更新は相当な重荷かもし
れない。もしユーザがmanページを寄付すると申し出たら、この贈り物は受け
取るのに高くつくと考えるかもしれない。同じ人がそれを維持する全責任を負
うと合意しなければ、そのmanページを拒否することがより良いかもしれない。--
完全にそれから手を洗えるように。もしこの有志が後にその作業をするのをや
めたら、自分でそれを取り上げなければならないと感じてはいけない。誰か他
の人がそのmanページを更新すると合意するまで、配布物からそれを引込める
のがより良いかもしれない。

プログラムをほんの少ししか変更しないとき、manページは更新せずに役に立
つ状態に保たれるぐらい不一致は少ないと感じるかもしれない。そうなら、そ
れを維持しておらず、Texinfoマニュアルがもっと信頼できることを説明する
目に付く覚え書きをmanページの最初の方に書いておきなさい。その覚え書き
はTexinfo 文書を呼び出す方法を表すべきだ。



File: standards-ja.info, Node: Reading other Manuals, Prev: Man Pages, Up: Documentation

他のマニュアルを読む
====================

あなたが解説しているプログラムを記述する、自由でない書籍や解説ファイル
があるかもしれない。

単に新しい代数の教科書の著者が代数に関する他の本を読むことができるよう
に、これらの文書を参考文献として使って構わない。どのノンフィクションの
書籍の大部分も事実から出来ていて、この場合、あるプログラムがどう動くか
についての事実で、これらの事実はその主題で書いているすべての人にとって
必ず同じである。しかし、すでにある自由でない解説文から、あなたの概要の
構成、言葉遣い、表や例を複製しないように気を付けなさい。自由な解説文か
ら複製することは構わないかもしれない。個々の場合についてFSFに確認して
ください。



File: standards-ja.info, Node: Managing Releases, Prev: Documentation, Up: Top

リリースの過程
**************

リリースを行うことは、単にあなたのソースファイルをtarファイルに束ねて
FTP に置くだけ以上のことである。あなたのソフトウェアを様々なシステムで
走るように設定できるように作り上げるべきだ。あなたのMakefileは以下で述
べるGNU 標準に従うべきだし、あなたのディレクトリ設計も以下で記述される
GNU標準に従うべきだ。そうすることで、あなたのパッケージを全てのGNUソフ
トウェアのより大きな骨組みに組み込むことが簡単になる。

* Menu:

* Configuration::               設定がいかに働くべきか
* Makefile Conventions::	Makefileの取り決め
* Releases::                    リリースを行う



File: standards-ja.info, Node: Configuration, Next: Releases, Prev: Managing Releases, Up: Managing Releases

設定がいかに働くべきか
======================

各GNU配布物は`configure'という名前のシェル・スクリプトと一緒に配られる
べきだ。このスクリプトにはそのプログラムをコンパイルしたいマシンやシス
テムの種類を表す引数を与えられる。

`configure'スクリプトはコンパイルに効果を与えられるように設定オプショ
ンを記録しなければならない。

これを行う一つの方法は、`config.h'のような標準的な名前から、選んだシス
テム用の適切な設定ファイルにリンクすることだ。これによって、人々はまず
設定しないとプログラムを構築できなくなるだろう。

`configure'が設定できる他の方法はMakefileを編集することだ。こうするな
ら、配布物は`Makefile'と名付けらたファイルを含むべきでは*ない*。代わり
に、編集に使われる入力を含む`Makefile.in'というファイルを入れるべきだ。
またもう一度、これはまず設定をしてないとプログラムを構築できないように
なるようにする。

もし`configure'が`Makefile'に書き込むなら、`Makefile'は、`configure'が
再び走り、最後に行ったのと同じ設定を作り上げる、`Makefile'と名付けられ
たターゲットを持つべきだ。`configure'が読むファイルは`Makefile'の依存
関係として列挙されているべきだ。

`configure'スクリプトからの出力であるファイルはすべて、それらが
`configure'を使って自動的に生成されたことを説明するコメントを先頭に持っ
ているべきだ。これによって、ユーザはそれらを手動で編集しようと考えなく
なるだろう。

`configure'スクリプトは、プログラムが最後に設定されたときに指定された
設定オプションを記述する、`config.status'という名前のファイルを書くべ
きである。このファイルはもし走ると同じ設定を再生成するシェル・スクリプ
トであるべきだ。

`configure'スクリプトは、(もし現在のディレクトリでなければ)ソースが見
付かるディレクトリを指定するための`--srcdir=DIRNAME'という形式にオプショ
ンを受け取るべきだ。こうすると、プログラムを別ディレクトリで構築するこ
とが可能なり、実際のソース・ディレクトリは変更されないようにできる。

もしユーザが`--srcdir'を指定しなければ、`configure'はソースが見付かる
かどうか見るのに、`.'と`..'の両方を確認するべきだ。もしこれらの場所の
一つでソースが見付かったら、そこからソースを使うべきだ。そうでなければ、
ソースが見付けられないと報告し、ゼロでない状態で終了するべきだ。

普通`--srcdir'をサポートする簡単な方法はMakefileの`VPATH'の定義を編集
することによる。これを可能にするために、`configure'はMakefileに正確に
指定されたディレクトリの値を持つ`srcdir'という名前の変数を加えることが
できる。

`configure'スクリプトはまたそのプログラムを構築するシステムの種類を指
定する引数を受け取るべきである。この引数は次のようであるべきだ。

     CPU-COMPANY-SYSTEM

例えば、Sun 3は`m68k-sun-sunos4.1'だ。

`configure'スクリプトは、マシンを表す方法として、全てのもっともらしい
他の方法を解読できる必要がある。だから、`sun3-sunos4.1'は正しい別名だ
ろう。多くのプログラムでは、`vax-dec-ultrix'は`vax-dec-bsd'の別名だろ
う。単にUltrixとBSDの違いはほとんど気付かない程度だからだが、少数のプ
ログラムはそれらを区別する必要があるかもしれない。

サブルーチンとして使える、システムの種類を有効にし別名を正規化する、
`config.sub'と呼ばれるシェル・スクリプトがある。

他のオプションで、そのマシンにあるソフトウェアやハードウェアをもっと詳
細に指定して良いし、パッケージの付加的な部分を入れたり、外したりして良
い。

`--enable-FEATURE[=PARAMETER]'
     FEATUREと呼ばれる付加的なユーザ水準の機能を構築しインストールする
     よう、パッケージを設定する。これで、ユーザはどの付加的な機能を入
     れるか選択することができる。付加的なPARAMETERに`no'を与えれば、も
     しデフォルトでは構築されるなら、FEATUREを除くべきだ。

     どの`--enable'オプションも*決して*ある機能を他と置き換えるべきで
     はない。どの`--enable'オプションも決してある有用な挙動を他の有用
     な挙動の代わりにするべきではない。`--enable'の唯一の適切な使用は
     そのプログラムの一部を構築するか除くかの質問に対してだけだ。

`--with-PACKAGE'
     パッケージPACKAGEがインストールされるだろうから、このパッケージが
     PACKAGEと一緒に働くように設定する。


     PACKAGEの可能な値には、`gnu-as'(あるいは`gas')、`gnu-ld'、
     `gnu-libc'、`gdb'、`x'、そして、`x-toolkit'がある。

     `--with'オプションをあるファイルを見付けるためにファイル名を指定
     するのに使ってはいけない。こういう使い方は`--with'オプションの目
     的から外れている。

`--nfp'
     ターゲット・マシンは浮動小数点プロセッサを持っていない。

`--gas'
     ターゲット・マシンのアセンブラはGAS、つまり、GNUアセンブラである。
     これはもはや使われていない。ユーザは代わりに`--with-gnu-as'を使う
     べきだ。

`--x'
     ターゲット・マシンはX Window Systemをインストールしている。これは
     もはや使われていない。ユーザは代わりに`--with-x'を使うべきだ。

全ての`configure'スクリプトはこれらの"詳細な"オプションをすべて受け入
れるべきだ。それらが手もとの特定のパッケージに違いを作るかどうかにかか
わらず。特に、それらは`--with-'や`--enable-'で始まるどんなオプションで
も受け入れるべきだ。これはユーザがオプション一組で一度にGNUソース・ツ
リー全体を設定できるするためだ。

`--with-'や`--enable-'の部類が狭いことに気付くだろう。それらはあなたが
考えるようなオプションの類いに役目を果たさ*ない*。このことは計画的なの
だ。我々はGNUソフトウェアで可能な設定オプションを制限したいのだ。我々
はGNUプログラムに特異な設定オプションを持たせたくない。

コンパイルの過程の一部を行うパッケージはクロス・コンパイルをサポートす
るかもしれない。そういう場合、そのプログラムのホストとターゲットのマシ
ンは異なるかもしれない。`configure'スクリプトは通常指定されたシステム
の種類がホストとターゲットの両方だとして扱うべきだ。こうして、それが走
るのと同じ種類のマシンで動くプログラムを作り出す。

クロス・コンパイラ、クロス・アセンブラ、あるいはあなたが持つどんなもの
でも、構築する方法は、`configure'を走らせるときに`--host=HOSTTYPE'とい
うオプションを指定する。これはターゲット・システムの種類を変えないでホ
スト・システムを指定する。HOSTTYPE の文法は上で述べたのと同じである 
(1) (*Note Configuration-Footnotes::)。

クロス・コンパイラを開始するには、それが走るホスト以外のマシンでコンパ
イルすることが必要である。コンパイルされるパッケージは、あなたがそれら
をコンパイルするシステムがホストとは異なる場合、設定を指定するために、
`--build=HOSTTYPE'という設定オプションを受け取る (2) (*Note
Configuration-Footnotes::)。

クロス作業は意味がないプログラムは、`--host'オプションを受け取る必要は
ない。なぜなら、クロス作業のためにオペレーティング・システム全体を設定
することは意味のあることではないからだ。

プログラムの中には自動的に自分自身を設定する方法を持っているものがある。
あなたのプログラムがこうするように作られていると、あなたの`configure'
スクリプトはその引数のほとんどを無視して良い。



File: standards-ja.info  Node: Configuration-Footnotes, Up: Configuration

(1) 訳注: 嘘八百。この場合、`--target=HOSTTYPE'を指定する。
逆にホストの方を変えるとターゲットも変わる。詳しくはAutoconfのマニュア
ルを見よ。

(2) 訳注: 原文のitはいまいち何を意味しているのか分からないが、内容から
推測するに多分クロス・コンパイルされるパッケージかと思う。



File: standards-ja.info, Node: Makefile Conventions

Makefileの取り決め
==================

この節では、GNUプログラムのMakefileを執筆するための慣例について記述す
る。

* Menu:

* Makefile Basics::		Makefileの一般的な慣例
* Utilities in Makefiles::	Makefileのユーティリティ
* Command Variables::		コマンド指定の変数
* Directory Variables::		インストール命令の変数
* Standard Targets::		ユーザ用の標準的なターゲット
* Install Command Categories::  `インストール'規則のコマンドの三つの部類:
                                  normal、pre-install、そしてpost-install。



File: standards-ja.info, Node: Makefile Basics

Makefileの一般的な慣例
----------------------

あらゆるMakefileは次の行を含むべきだ。

     SHELL = /bin/sh

`SHELL'変数が環境から受け継がれるようなシステム上での問題を避けるため
に。(これはGNU `make'では問題には決してならない。)

異なる`make'プログラムは互換性のない接尾辞のリストと暗黙の規則を持ち、
これはときどき混乱やおかしな挙動を生み出す。だから特定のMakefileで必要
とする接尾辞だけを使用するのに、明示的に接尾辞のリストを設定するのは良
い考えだ。

     .SUFFIXES:
     .SUFFIXES: .c .o

最初の行は接尾辞のリストを処分し、二番目はこのMakefileで暗黙の規則の対
象になるかもしれない接尾辞すべてを導入する。

`.'がコマンド実行のパスに入っていると仮定してはいけない。makeの間にあ
なたのパッケージの一部であるプログラムを走らせる必要があるとき、そのプ
ログラムがmakeの一部として構築されるなら`./'を使い、もしファイルがソー
ス・コードの変更されない部分なら、`$(srcdir)/'を使うようにしてください。
これらの接頭辞の一つを使わないと、現在の検索パスが使われる。

`./'("構築ディレクトリ")と`$(srcdir)/'("ソース・ディレクトリ")の区別は、
ユーザは`configure'に`--srcdir'オプションを使って別のディレクトリで構
築することができるので、重要である。次の書式の規則は構築ディレクトリが
ソース・ディレクトリではないとき失敗する。`foo.man'と`sedscript'はソー
ス・ディレクトリの中にあるからだ。

     foo.1 : foo.man sedscript
             sed -e sedscript foo.man > foo.1

@noindent

GNU `make'を使うとき、ソースファイルを見付けるのに`VPATH'を頼りにする
ことは、単一の依存関係ファイルがある場合には上手く行くだろう。`make'の
自動変数`$<'は、ソースファイルがどこにあっても、それを表すから。
(`make'のたくさんのバージョンは暗黙的規則でだけ`$<' を設定する。)

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o

このようなMakefileのターゲットは代わりに次のように書かれるべきだ。

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@

`VPATH'が正しく働くようにするために。ターゲットが複数の依存関係を持つ
とき、明示的な`$(srcdir)'を使うことがその規則を上手く働かせる一番簡単
な方法だ。例えば、`foo.1'に対するターゲットは次のように書かれてるのが
一番良い。

     foo.1 : foo.man sedscript
             sed -e $(srcdir)/sedscript $(srcdir)/foo.man > $@

GNUの配布物は普通ソースファイルではない、いくつかのファイルを含む。--
例えば、InfoファイルやAutoconf、Automake、BisonやFlexからの出力だ。こ
れらのファイルは通常ソース・ディレクトリに現れるので、それらは構築ディ
レクトリではなく、常にソース・ディレクトリに現れるべきだ。だからそれら
を更新するMakefileの規則はソース・ディレクトリに更新されたファイルを置
くべきだ。

しかしながら、もしファイルが配布物に現れないなら、Makefileはソース・ディ
レクトリにそれを置くべきではない。なぜなら、普通の環境でプログラムを構
築することで、どんな方法でもソース・ディレクトリを変更するべきではない
からだ。

構築とインストールのターゲットを少なくとも(そしてそれらのサブターゲッ
ト全てが)並列`make'で正しく働くように試みなさい。



File: standards-ja.info, Node: Utilities in Makefiles

Makefileのユーティリティ
------------------------

Makefileのコマンド(そして`configure'のようなシェル・スクリプト)を、
`csh'ではなく、`sh'で走るように書きなさい。`ksh'や`bash'の特別な機能を
一切使ってはいけない。

`configure'スクリプトと構築とインストールのためのMakefileの規則は次の
ものを除いて、どんなユーティリティも直接使うべきではない。


     cat cmp cp diff echo egrep expr false grep install-info
     ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true

圧縮プログラムの`gzip'は`dist'規則で使って良い。

これらのプログラムに対して、一般的にサポートされているオプションを守り
なさい。例えば、あったら便利な、`mkdir -p'はほとんどのシステムでサポー
トしていないので使ってはいけない。

少数のシステムではサポートしていないので、makefileではシンボリック・リ
ンクを作らないようにするのは良い考えだ。

構築とインストールのためのMakefileの規則はまたコンパイラや関連したプロ
グラムを使っていいが、ユーザが代わりのものと換えられるように`make'変数
を通して使うべきだ。我々が言っているプログラムをここでいくつか挙げる。

     ar bison cc flex install ld ldconfig lex
     make makeinfo ranlib texi2dvi yacc

これらのプログラムを走らせるのに次の`make'変数を使いなさい。

     $(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
     $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)

`ranlib'や`ldconfig'を使うとき、システムが当のプログラムを持っていなく
ても悪いことが何も起きないようにするべきだ。そのコマンドからのエラーを
無視するように調整し、そのコマンドの前にユーザにこのコマンドの失敗が問
題ではないことを伝えるメッセージを出力しなさい。(Autoconfの
`AC_PROG_RANLIB'マクロはこれを助けることができる。)

もしシンボリック・リンクを使うなら、シンボリック・リンクを持たないシス
テム用に別手段を実装するべきだ。

Make変数を通して使って良い別のユーティリティには次のものがある。

     chgrp chmod chown mknod

他のユーティリティを使うことは、あなたがそれらのユーティリティが存在す
ると知っている特定のシステムのためだけに、Makefileの一部(やスクリプト)
が意図されているなら使って良い。



File: standards-ja.info, Node: Command Variables

コマンド指定の変数
------------------

Makefileはあるコマンドやオプションなどを上書きするために変数を提供する
べきだ。

とりわけ、ほとんどのユーティリティ・プログラムを変数を通して走らせるべ
きだ。だから、もしBisonを使うなら、`BISON'と名付けられた、そのデフォル
トの値が`BISON = bison'と設定されている変数を持ち、Bisonを使う必要があ
るときにはいつでも`$(BISON)'を使ってそれを参照しなさい。

`ln'、`rm'、`mv'などなどのようなファイル管理ユーティリティはこのやり方
の変数を通した参照をする必要はない。ユーザはそれらを他のプログラムと置
き換える必要がないので。

それぞれのプログラム名変数は、プログラムにオプションを与えるのに使われ
るオプション変数と一緒に使われるべきだ。オプション変数の名前を得るのに
プログラム名変数の名前に`FLAGS'を付け加えなさい。--例えば、
`BISONFLAGS'のように。(Cコンパイラに対する`CFLAGS'、yaccに対する
`YFLAGS'、lexに対する`LFLAGS'の名前はこの規則には例外的だが、我々はそ
れらは標準的なのでそうしておく。) プリプロセッサを走らせるどのコンパイ
ルのコマンドでも`CPPFLAGS'を使い、`ld'の直接的な使用だけではなく、リン
クを行うどのコンパイルのコマンドでも`LDFLAGS'を使いなさい。

もしあるファイルの適切なコンパイルに使われ*なければならない*Cコンパイ
ラのオプションがあれば、`CFLAGS'にそれらを入れてはいけない。ユーザは
`CFLAGS'を自分で自由に指定できると期待する。代わりに、`CFLAGS'とは独立
に必要なオプションをCコンパイラに渡すように調整しなさい。次のように、
それらを明示的にコンパイルのコマンドに書くか、暗黙の規則を定義すること
によって。

     CFLAGS = -g
     ALL_CFLAGS = -I. $(CFLAGS)
     .c.o:
             $(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $<

`-g'オプションを`CFLAGS'に入れなさい。なぜなら、それは適切なコンパイル
には*必要*ではないからだ。それを単に推奨されるデフォルトであると考える
ことができる。もしパッケージがデフォルトでGCCでコンパイルされるように
設定されているなら、`CFLAGS'のデフォルトの値に`-O'も入れてもいい。

ユーザが他を上書きするのに`CFLAGS'を使うことができるので、`CFLAGS'をコ
ンパイルのコマンドの最後、コンパイラのオプションを含む他の変数の後に置
きなさい。

`CFLAGS'は、コンパイルを行うのとリンクを行う両方の、Cコンパイラのあら
ゆる起動で使われるべきだ。

あらゆるMakefileは`INSTALL'という変数を定義するべきで、それはファイル
をシステムにインストールするための基本的なコマンドである。

あらゆるMakefileはまた`INSTALL_PROGRAM'と`INSTALL_DATA'という変数を定
義するべきだ。(これらは各々デフォルトは`$(INSTALL)'であるべきだ。) そ
して、これらの変数を実際のインストールのコマンドとして、それぞれ実行ファ
イルと実行ファイルでないものに対して使うべきだ。これらの変数は次のよう
に使いなさい。

     $(INSTALL_PROGRAM) foo $(bindir)/foo
     $(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a

インストールのコマンドの二番目の引数として、ディレクトリ名ではなく、常
にファイル名を使いなさい。インストールされるそれぞれのファイルに対して、
別々のコマンドを使いなさい。



File: standards-ja.info, Node: Directory Variables

インストール命令の変数
----------------------

インストール命令は常に変数によって名前が付けられているべきだ。だから、
標準的でない場所にインストールするのは簡単である。これらの変数の標準的
な名前は以下で述べる。それらは標準的なファイルシステムの構造に基いてい
る。それに似たものがSVR4、4.4BSD、Linux、Ultrix v4や他の現代的なオペレー
ティング・システムで使われている。

これらの二つの変数はインストールのためのルートを設定する。他のインストー
ル命令はすべてこれら二つのうちの一つのサブディレクトリであるべきで、こ
れら二つのディレクトリへ直接インストールされるものがあるべきではない。

`prefix'
     以下で列挙する変数のデフォルトの値を作るのに使われる接頭辞。
     `prefix'のデフォルトの値は`/usr/local'であるべきだ。完全なGNU シ
     ステムを構築するとき、接頭辞は空で、`/usr'は`/'へのシンボリック・
     リンクになるだろう。(もしAutoconfを使っているなら、それを
     `@prefix@'と書きなさい。)

`exec_prefix'
     以下で列挙する変数の一部のデフォルトの値を作るのに使われる接頭辞。
     `exec_prefix'のデフォルトの値は`$(prefix)'であるべきだ。(もし
     Autoconfを使っているなら、それを`@exec_prefix@'と書きなさい。)

     一般的に、`$(exec_prefix)'は(実行ファイルやサブルーチン・ライブラ
     リのような)マシンに特定のファイルを含むディレクトリに対して使われ
     るが、`$(prefix)'は他のディレクトリに対して直接使われる。

実行プログラムは以下のディレクトリの一つにインストールされる。

`bindir'
     ユーザが走らせることができる実行プログラムをインストールするため
     のディレクトリ。これは普通`/usr/local/bin'であるべきだが、それを
     `$(exec_prefix)/bin'と書きなさい。(もしAutoconfを使っているなら、
     それを`@bindir@'と書きなさい。)

`sbindir'
     シェルから走らせることができるが、普通はシステム管理者にだけ有用
     な実行プログラムをインストールするためのディレクトリ。これは通常
     `/usr/local/sbin'であるべきだが、それを`$(exec_prefix)/sbin'と書
     きなさい。(もしAutoconfを使っているなら、それを`@sbindir@'と書き
     なさい。)

`libexecdir'
     ユーザよりも他のプログラムに実行されるための実行プログラムをイン
     ストールするためのディレクトリ。このディレクトリは通常
     `/usr/local/libexec' であるべきだが、それを
     `$(exec_prefix)/libexec'と書きなさい。(もしAutoconfを使っているな
     ら、それを`@libexecdir@'と書きなさい。)

実行中にプログラムによって使われるデータ・ファイルは二つの方法の部類に
分けられる。

   * 一部のファイルは普通プログラムによって変更される。他のものは普通
     絶対に変更されない(ユーザはこれらのうち一部を編集するかもしれない
     けど)。

   * 一部のファイルはアーキテクチャに依存しておらず、あるサイトの全て
     のマシンに共有されうる。一部はアーキテクチャ依存で、同じ種類のマ
     シンやオペレーティング・システムによってのみ共有されうる。他のも
     のは二つのマシン間で決して共有できないかもしれない。

これは6つの異なる可能性をもたらす。しかしながら、我々は、オブジェクト・
ファイルやライブラリは別にして、アーキテクチャ依存のファイルの使用をや
めさせたい。他のデータ・ファイルをアーキテクチャ非依存にすることはずっ
ときれいで、普通は困難ではない。

それゆえ、ここにMakefileがディレクトリを指定するのに使うべき変数を挙げ
る。

`datadir'
     読み込みだけのアーキテクチャに依存しないデータ・ファイルをインス
     トールするためのディレクトリ。これは通常`/usr/local/share'である
     べきだが、それを`$(prefix)/share'と書きなさい。(もしAutoconfを使っ
     ているなら、それを`@datadir@'と書きなさい。) 特別な例外として、以
     下の`$(infodir)'と`$(includedir)'を見なさい。

`sysconfdir'
     一つのマシンに属する読み込みだけのデータ・ファイル--つまり、ホス
     トを設定するためのファイル、をインストールするためのディレクトリ。
     メイラーやネットワークの設定ファイル、`/etc/passwd'などはここに属
     する。このディレクトリの全てのファイルは普通のASCIIテキスト・ファ
     イルであるべきだ。このディレクトリは普通`/usr/local/etc'だが、そ
     れを`$(prefix)/etc' と書きなさい。(もしAutoconfを使っているなら、
     それを`@sysconfdir@' と書きなさい。)

     このディレクトリに実行ファイルをインストールしてはいけない(それら
     おそらく`$(libexecdir)'か`$(sbindir)'に属する)。また、普通の方針
     で使っているときに変更するファイルはインストールしてはいけない(シ
     ステムの設定を変更するための目的のプログラムは除く)。それらはおそ
     らく`$(localstatedir)'に属する。

`sharedstatedir'
     アーキテクチャに依存しない、プログラムが走る間に変更するデータ・
     ファイルをインストールするためのディレクトリ。これは普通
     `/usr/local/com'であるべきだが、それを`$(prefix)/com'と書きなさい。
     (もしAutoconfを使っているなら、それを`@sharedstatedir@'と書きなさ
     い。)

`localstatedir'
     プログラムが走る間に変更し、特定のマシンに属しているデータ・ファ
     イルをインストールするためのディレクトリ。ユーザは、パッケージの
     操作を設定するために、このディレクトリにあるファイルを変更する必
     要が決してあるべきではない。そのような設定情報は`$(datadir)'や
     `$(sysconfdir)'に入る別のファイルに置きなさい。`$(localstatedir)'
     は通常`/usr/local/var'であるべきだが、それを`$(prefix)/var'と書き
     なさい。(もしAutoconfを使っているなら、それを`@localstatedir@'と
     書きなさい。)

`libdir'
     オブジェクト・ファイルやオブジェクト・コードのライブラリのための
     ディレクトリ。ここに実行ファイルをインストールしてはいけない。そ
     れらはおそらく代わりに`$(libexecdir)'に入るべきだ。`libdir'の値は
     普通`/usr/local/lib'だが、それを`$(exec_prefix)/lib'と書きなさい。
     (もしAutoconfを使っているなら、それを`@libdir@'と書きなさい。)

`infodir'
     このパッケージのInfoファイルをインストールするためのディレクトリ。
     デフォルトでは、それは`/usr/local/info'であるべきだが、それは
     `$(prefix)/info'と書かれるべきだ。(もしAutoconfを使っているなら、
     それを`@infodir@'と書きなさい。)

`lispdir'
     このパッケージのどんなEmacs Lispファイルでもインストールためのディ
     レクトリ。デフォルトでは、それは
     `/usr/local/share/emacs/site-lisp'であるべきだが、それは
     `$(prefix)/share/emacs/site-lisp'と書かれるべきだ。

     もしAutoconfを使っているなら、デフォルトを`@lispdir@'と書きなさい。
     `@lispdir@'が働くようにするために、`configure.in'ファイルに以下の
     行が必要である。

          lispdir='${datadir}/emacs/site-lisp'
          AC_SUBST(lispdir)

`includedir'
     Cの`#include'プリプロセッサ命令でユーザ・プログラムによってインク
     ルードされるヘッダ・ファイルをインストールするためのディレクトリ。
     これは通常`/usr/local/include'であるべきだが、それを
     `$(prefix)/include' と書きなさい。(もしAutoconfを使っているなら、
     それを`@includedir@' と書きなさい。)

     GCC以外のほとんどのコンパイラは`/usr/local/include'ディレクトリの
     ヘッダ・ファイルを探さない。だからこの方法でヘッダ・ファイルをイ
     ンストールすることはGCCにだけ役に立つ。一部のライブラリはGCCで働
     くことだけを本当に意図しているので、これは時には問題ではない。し
     かし一部のライブラリは他のコンパイラと働くことを意図している。そ
     れらはヘッダ・ファイルを二つの場所、`includedir'に指定されるとこ
     ろと`oldincludedir'に指定されるところにインストールするべきだ。

`oldincludedir'
     GCC以外のコンパイラで使われるための`#include'ヘッダ・ファイルをイ
     ンストールするためのディレクトリ。これは通常`/usr/include'である
     べきだ。(もしAutoconfを使っているなら、それを`@oldincludedir@'と
     書くことができる。)

     Makefileのコマンドは`oldincludedir'の値が空かどうか確認すべきだ。
     もしそうなら、それを使おうとするべきではない。ヘッダ・ファイルの
     二番目のインストールを取りやめるべきだ。

     パッケージはこのディレクトリにすでにあるヘッダを、そのヘッダが同
     じパッケージに由来しているのでないなら、置き換えるべきではない。
     だから、もしあなたのFooパッケージがヘッダ・ファイルの`foo.h'を提
     供するなら、もし、(1)`foo.h'がないか、(2)すでにある`foo.h'がFooパッ
     ケージ由来か、のどちらかなら、`oldincludedir'ディレクトリにそのヘッ
     ダ・ファイルをインストールするべきだ。

     `foo.h'がFooパッケージ由来かどうかを見分けるために、そのファイル
     に魔法の文字列--コメントの一部--を置き、その文字列を`grep'しなさ
     い。

Unix形式のmanページは次のうちの一つにインストールされる。

`mandir'
     このパッケージの(あれば)manページをインストールするための一番上の
     ディレクトリ。それは普通`/usr/local/man'だろう。しかしそれを
     `$(prefix)/man'と書くべきだ。(もしAutoconfを使っているなら、それ
     を`@mandir@'と書きなさい。)

`man1dir'
     セクション1のmanページをインストールするためのディレクトリ。それ
     を`$(mandir)/man1'と書きなさい。
`man2dir'
     セクション2のmanページをインストールするためのディレクトリ。それ
     を`$(mandir)/man2'と書きなさい。
`...'

     *どんなGNUソフトウェアの主要な解説書もmanページにしてはならない。
     代わりにTexinfoでマニュアルを書きなさい。manページは単にUnix上で
     GNUソフトウェアを走らせる人々のためだけで、それは副次的なアプリケー
     ションだけだ。*

`manext'
     インストールされるmanページのファイル名拡張子。これは適切な数字が
     続くピリオドを含むべきだ。それは普通`.1'であるべきだ。

`man1ext'
     セクション1にインストールされるmanページのためのファイル名拡張子。
`man2ext'
     セクション2にインストールされるmanページのためのファイル名拡張子。
`...'
     もしパッケージがマニュアルの2以上にmanページをインストールする必
     要があるなら、これらの名前を`manext'の代わりに使いなさい。

そして最後に、以下の変数を設定するべきだ。

`srcdir'
     コンパイルされるソースのディレクトリ。この変数の値は通常
     `configure' シェル・スクリプトによって挿入される。(もしAutoconfを
     使っているなら、`srcdir = @srcdir@'を使いなさい。)

例。

     # Common prefix for installation directories.
     # NOTE: This directory must exist when you start the install.
     prefix = /usr/local
     exec_prefix = $(prefix)
     # Where to put the executable for the command `gcc'.
     bindir = $(exec_prefix)/bin
     # Where to put the directories used by the compiler.
     libexecdir = $(exec_prefix)/libexec
     # Where to put the Info files.
     infodir = $(prefix)/info

もしあなたのプログラムが標準的なユーザ指定のディレクトリに、非常にたく
さんのファイルをインストールするなら、このプログラムに特定のサブディレ
クトリにそれらをまとめると有用かもしれない。もしこうするなら、これらの
サブディレクトリを作るための`install'規則を書くべきだ。

上に挙げたどの変数の値にも、ユーザがサブディレクトリの名前を含めると期
待してはいけない。インストール・ディレクトリのための変数名の一組を持つ
という考えは、ユーザがいくつかの異なるGNUパッケージに正確に同じ値を指
定できるようにすることである。これを有用なものとするために、あらゆるパッ
ケージはユーザがそうするときに賢く働くように設計されなければならない。



File: standards-ja.info, Node: Standard Targets

ユーザ用の標準的なターゲット
----------------------------

全てのGNUプログラムはそれらのMakefileに以下のターゲットを持つべきだ。

`all'
     プログラム全体をコンパイルする。これはデフォルトのターゲットであ
     るべきだ。このターゲットはどの解説ファイルも再構築しなくて良い。
     Infoファイルは通常配布物の中に含まれるべきで、DVIファイルは明示的
     に要求されたときにのみ作られるべきだ。

     デフォルトでは、Makeの規則は`-g'付きでコンパイルしリンクするべき
     だ。こうして実行プログラムはデバッグのシンボルを持つ。無力なこと
     を気にしないユーザは、彼らが望むなら、その実行ファイルを後でstrip
     することができる。

`install'
     プログラムをコンパイルし、実行ファイル、ライブラリなどを、それら
     が実際に使われるべきファイル名に複製する。もしプログラムが適切に
     インストールされたことを確かめるための簡単な試験があるなら、この
     ターゲットはその試験を走らせるべきだ。

     実行ファイルをインストールするときにstripしてはいけない。向こう見
     ずなユーザはそうするために`install-strip'ターゲットを使うことがで
     きる。

     もし可能なら、`make all'が終わっていたら、そのプログラムが構築さ
     れたディレクトリのどんなものも変更しないように`install'ターゲット
     の規則を書きなさい。これはあるユーザ名でプログラムを構築し、他の
     ユーザ名でそれをインストールするのに便利である。

     そのコマンドはファイルがインストールされるディレクトリを、もしま
     だなかったら、全て作成するべきである。これは必要とされるサブディ
     レクトリ全てだけでなく、変数`prefix'や`exec_prefix'の値で指定され
     るディレクトリも含む。これを行う一つの方法は以下で述べるような
     `installdirs'ターゲットを使うことによる。

     manページをインストールためのどんなコマンドの前にも、`make'がどん
     なエラーも無視するように、`-'を使いなさい。これはUnixのmanページ
     解説システムがインストールされてないシステムの場合である。

     Infoファイルをインストールする方法は、それらを`$(INSTALL_DATA)'
     (*Note Command Variables::)で`$(infodir)'に複製することで、もしあ
     れば、`install-info'プログラムを走らせる。`install-info'は与えら
     れたInfoファイルのメニュー項目を加えたり更新したりするためにInfo
     の`dir'ファイルを編集するプログラムである。それはTexinfoパッケー
     ジの一部だ。ここでInfoファイルをインストールする見本の規則を挙げ
     る。

          $(infodir)/foo.info: foo.info
                  $(POST_INSTALL)
          # There may be a newer info file in . than in srcdir.
                  -if test -f foo.info; then d=.; \
                   else d=$(srcdir); fi; \
                  $(INSTALL_DATA) $$d/foo.info $@; \
          # Run install-info only if it exists.
          # Use `if' instead of just prepending `-' to the
          # line so we notice real errors from install-info.
          # We use `$(SHELL) -c' because some shells do not
          # fail gracefully when there is an unknown command.
                  if $(SHELL) -c 'install-info --version' \
                     >/dev/null 2>&1; then \
                    install-info --dir-file=$(infodir)/dir \
                                 $(infodir)/foo.info; \
                  else true; fi

     `install'ターゲットを書くとき、三つの部類に全てのコマンドを分類し
     なければならない。普通のものと、"pre-installation"コマンドと
     "post-installation"コマンドだ。*Note Install Command Categories::。

`uninstall'
     インストールされたファイル---`install'ターゲットが作る複製--を全
     て削除する。

     この規則はコンパイルが行われたディレクトリを変更せず、ファイルが
     インストールされるディレクトリだけを変更するべきだ。

     アンインストールのコマンドはインストールのコマンドと同様、三つの
     部類に分けられる。*Note Install Command Categories::。

`install-strip'
     `install'に似ているが、実行ファイルをインストールする間にそれらを
     stripする。多くの場合、このターゲットの定義は非常に単純で良い。

          install-strip:
                  $(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \
                          install

     通常我々は、あなたがそのプログラムにバグがないと確信しているので
     ないなら、実行ファイルをstripすることを推奨しない。しかしながら、
     バグがある場合用にstripしていない実行ファイルを別のところに保存し
     て、実際の実行用にstrip された実行ファイルをインストールすること
     は理に適っていることもあり得る。

`clean'

     現在のディレクトリから、普通プログラムを構築することによって作ら
     れた全てのファイルを削除する。設定を記録するファイルは削除しては
     いけない。また、構築によって作ることができても、配布物から手に入
     るので普通は作らないファイルは残しておきなさい。

     もし配布物の一部でないなら、`.dvi'ファイルは削除しなさい。

`distclean'
     現在のディレクトリから、プログラムを設定したり、構築することによっ
     て作られた全てのファイルを削除する。もしソースを展開し、他のファ
     イルを作らずにプログラムを構築しているなら、`make distclean'は配
     布物にあったファイルだけを残すべきである。

`mostlyclean'
     `clean'に似ているが、人々が通常再びコンパイルしたいとは思わない、
     少数のファイルは削除してなくて良い。例えば、GCCの`mostlyclean'ター
     ゲットは`libgcc.a'を削除しない。なぜなら、それを再びコンパイルす
     ることは滅多に必要でなく、長い時間がかかるからだ。

`maintainer-clean'
     現在のディレクトリから、このMakefileで復元され得る、ほとんど全て
     を削除する。これは典型的には`distclean'によって削除される全てのも
     のと、さらに、Bisonによって生み出されたCのソース・ファイル、タグ
     の表、Infoファイルなどなどを含む。

     "ほとんど全て"と言う理由は、コマンド`make maintainer-clean'を走ら
     せることで、例え`configure'はMakefileの規則を使って再生できたとし
     ても、`configure'を削除するべきでないということだ。もっと一般的に、
     `make maintainer-clean'は`configure'を走らせるために、そしてプロ
     グラムを構築し始めるために存在する必要があるどんなものも削除する
     べきではない。これが唯一の例外だ。`maintainer-clean'は再構築され
     る得る他のものは全て削除するべきだ。

     `maintainer-clean'ターゲットは、普通のユーザではなく、そのパッケー
     ジの管理者によって使われることが意図されている。`make
     maintainer-clean'が削除するファイルの一部を復元するために、特別な
     ツールを必要とするかもしれない。これらのファイルは普通配布物に含
     められるので、それらが簡単に復元することは気にしない。もし全配布
     物を再び展開する必要があることを見出しても、我々を非難してはいけ
     ない。

     ユーザがこれに気付くのを助けるために、特別な`maintainer-clean'ター
     ゲットのためのコマンドはこれら二つで始まるべきだ。

          @echo 'This command is intended for maintainers to use; it'
          @echo 'deletes files that may need special tools to rebuild.'

`TAGS'
     このプログラムのタグ表を更新する。

`info'
     必要とされるどのInfoファイルでも生成する。規則を書く最善の方法は
     次のようだ。

          info: foo.info

          foo.info: foo.texi chap1.texi chap2.texi
                  $(MAKEINFO) $(srcdir)/foo.texi

     Makefileに`MAKEINFO'という変数を定義してなければならない。それは
     `makeinfo'プログラムを走らせるべきで、それはTexinfo配布物の一部で
     ある。

     普通、GNU配布物はInfoファイルと一緒に手に入り、このことはInfoファ
     イルがソース・ディレクトリにあることを意味する。それゆえ、infoファ
     イルのためのMakeの規則はソース・ディレクトリでそれを更新するべき
     だ。ユーザがそのパッケージを構築するとき、普通のMakeはInfoファイ
     ルを更新しないだろう。なぜなら、それらはすでに最新だろうから。

`dvi'
     Texinfo解説書全てのDVIファイルを生成する。例えば、

          dvi: foo.dvi

          foo.dvi: foo.texi chap1.texi chap2.texi
                  $(TEXI2DVI) $(srcdir)/foo.texi

     Makefileに`TEXI2DVI'という変数を定義してなければならない。それは
     `texi2dvi'というプログラムを走らせるべきで、それはTexinfo配布物の
     一部である。 (1) (*Note Standard Targets-Footnotes::) あるいは、
     単に依存関係だけを書き、GNU `make'がそのコマンドを提供できるよう
     にしなさい。

`dist'
     このプログラムの配布用tarファイルを作成する。tarファイルは、その
     tarファイルの中のファイル名が配布されるパッケージの名前のサブディ
     レクトリ名で始まるように作り上げられるべきだ。この名前はバージョ
     ン・ナンバーを含んで良い。

     例えば、GCCのバージョン1.40の配布用tarファイルは`gcc-1.40'と名付
     けられたサブディレクトリに展開する。

     これを行う一番簡単な方法は適切に名付けられたサブディレクトリを作
     り、`ln'か`cp'でそれに適当なファイルをインストールし、そのサブディ
     レクトリに`tar'することである。

     そのtarファイルを`gzip'で圧縮しなさい。例えば、GCCのバージョン
     1.40 の実際の配布ファイルは`gcc-1.40.tar.gz'と名付けられている。

     配布物にあるソースではないファイル全てを配布物中で最新にしておく
     ために、`dist'ターゲットは明示的にそれらに依存すべきだ。*Note
     Making Releases: Releases.

`check'
     (もしあれば)自己診断を行う。ユーザはその試験を走らせる前にプログ
     ラムを構築しなければならないが、そのプログラムをインストールする
     必要はない。そのプログラムが構築されているがインストールされてい
     ないときに働くように自己診断を書くべきである。

以下のターゲットは、それらが有用であるプログラムに対して、慣習的な名前
を提案している。

`installcheck'
     (もしあれば)インストールの診断を行う。ユーザはその試験を走らせる
     前にそのプログラムを構築しインストールしなければならない。
     `$(bindir)'が検索パスにあると仮定するべきではない。

`installdirs'
     ファイルがインストールされるディレクトリとそれらの親ディレクトリ
     を作成するために、`installdirs'という名前のターゲットを加えると役
     に立つ。このために便利である`mkinstalldirs'と名付けられたスクリプ
     トがある。それはTexinfoパッケージの中で見付けることができる。この
     ような規則を使うことができる。

          # Make sure all installation directories (e.g. $(bindir))
          # actually exist by making them if necessary.
          installdirs: mkinstalldirs
                  $(srcdir)/mkinstalldirs $(bindir) $(datadir) \
                                          $(libdir) $(infodir) \
                                          $(mandir)

     この規則はコンパイルがなされるディレクトリを変更するべきではない。
     インストール用のディレクトリを作成する以外に何もするべきではない。


File: standards-ja.info  Node: Standard Targets-Footnotes, Up: Standard Targets

(1) `texi2dvi'は整形の実際の作業を行うためにTeX を使用す
る。TeXはTexinfoと一緒配布されていない。



File: standards-ja.info, Node: Install Command Categories

インストールのコマンドの部類
----------------------------

`install'ターゲットを書くとき、三つの部類にそのコマンド全てを分類しな
ければならない。普通のものと、"pre-installation"コマンドと、
"post-installation"コマンドに。

普通のコマンドは適切な場所にファイルを移動し、それらのモードを設定する。
それらはどんなファイルも、完全にそれらが属するパッケージから手に入るも
のを除いて、変化させないのが良い。

pre-installationとpost-installationのコマンドは他のファイルを変えても
良い。特に、それらは大域的な設定ファイルやデータベースを編集して良い。

pre-installationコマンドは典型的には普通のコマンドの前に実行され、
post-installationコマンドは典型的には普通のコマンドの後に走らされる。

post-installationコマンドの最も普通の利用は`install-info'を走らせるこ
とである。これは普通のコマンドでは行われ得ない。それは、完全には、そし
てインストールされるパッケージだけからは手に入らないファイル(Infoディ
レクトリ)を変化させる。それはパッケージのInfoファイルをインストールす
る普通のコマンドの後に行われる必要があるのでpost-installationコマンド
である。

ほとんどのプログラムはpre-installationコマンドを必要としないが、我々は
それが必要とされる場合にだけその機能を持つ。

`install'規則のコマンドをこれら三つの部類に分類するために、それらの中
に"部類行"を挿入しなさい。部類行は次のコマンドの部類を指定する。

部類行はタブと特別なMake変数への参照に加えて、最後に付加的なコメントか
ら成る。それぞれの部類に対して一つ、使うことができる三つの変数がある。
変数名は部類を指定する。部類行は、これら三つのMake変数は普通未定義(そ
して、それらをmakefileで定義する*べきではない*)ので、普通の実行では何
も行わない。

ここで、それぞれそれが何を意味するのか説明するコメントと共に、その三つ
のあり得る部類行を挙げる。

             $(PRE_INSTALL)     # Pre-install commands follow.
             $(POST_INSTALL)    # Post-install commands follow.
             $(NORMAL_INSTALL)  # Normal commands follow.

もし`install'規則の始めに部類行を使わないなら、全てのコマンドは、最初
の部類行まで普通のものと分類される。もしどの部類行も使わないなら、全て
のコマンドは普通のものと分類される。

これらは`uninstall'のための部類行である。

             $(PRE_UNINSTALL)     # Pre-uninstall commands follow.
             $(POST_UNINSTALL)    # Post-uninstall commands follow.
             $(NORMAL_UNINSTALL)  # Normal commands follow.

典型的には、pre-uninstallコマンドはInfoディレクトリから項目を削除する
ために使われるだろう。

もし`install'や`uninstall'ターゲットがインストールのサブルーチンとして
振る舞う依存関係を持つなら、*それぞれの*依存関係のコマンドを部類行で始
めるべきで、主要なターゲットのコマンドも部類行で始めるべきだ。こうして、
それぞれのコマンドが、依存関係のそれが実際に走るかどうかに関係なく、正
しい部類に位置するように保証できる。

pre-installationとpost-installationのコマンドはこれら以外のプログラム
を走らせるべきではない。

     [ basename bash cat chgrp chmod chown cmp cp dd diff echo
     egrep expand expr false fgrep find getopt grep gunzip gzip
     hostname install install-info kill ldconfig ln ls md5sum
     mkdir mkfifo mknod mv printenv pwd rm rmdir sed sort tee
     test touch true uname xargs yes

この方法でコマンドを区別する理由はバイナリ・パッケージを作るためである。
典型的にはバイナリ・パッケージは全ての実行ファイルとインストールされる
必要がある他のファイルを含み、それらをインストールする、それ自身の方法
を持つ--だから、それは普通のインストールのコマンドを走らせる必要がない。
しかし、バイナリ・パッケージをインストールすることはpre-installationと
post-installationのコマンドを走らせることを必要とする。

バイナリ・パッケージを構築するためのプログラムはpre-installationと
post-installationのコマンドを抜粋することによって働く。ここで
pre-installationコマンドを抜粋する一つの方法を示す。

     make -n install -o all \
           PRE_INSTALL=pre-install \
           POST_INSTALL=post-install \
           NORMAL_INSTALL=normal-install \
       | gawk -f pre-install.awk

ここで`pre-install.awk'というファイルは次のものを含む。

     $0 ~ /^\t[ \t]*(normal_install|post_install)[ \t]*$/ {on = 0}
     on {print $0}
     $0 ~ /^\t[ \t]*pre_install[ \t]*$/ {on = 1}

pre-installationコマンドの結果生じるファイルはバイナリ・パッケージをイ
ンストールすることの一部として、シェル・スクリプトとして実行される。



File: standards-ja.info, Node: Releases, Prev: Configuration, Up: Managing Releases

リリースを行う
==============

`Foo version 69.96'の配布物を`foo-69.96.tar.gz'という名前でgzipされた
tarファイルにまとめなさい。それは`foo-69.96'という名前のサブディレクト
リに展開されるべきだ。

そのプログラムの構築やインストールは配布物に含まれるどのファイルも決し
て変更するべきではない。これは、どんな方法でもプログラムの一部を作るファ
イルは全て、"ソースファイル"と"ソースでないファイル"に分類されていなけ
ればならないことを意味する。ソースファイルは人間によって書かれ、自動的
には決して変更されない。ソースでないファイルはMakefileの管理の下に、プ
ログラムによってソースファイルから生成される。

配布物は、パッケージの名前とそれが何をするのか一般的な記述を与える、
`README'という名前のファイルを含むべきだ。また、もしあるなら、パッケー
ジの一番上にあるサブディレクトリそれぞれの目的を説明するのも良い。
`README'ファイルはパッケージのバージョン・ナンバーを記述するか、それが
見付かるパッケージ内の場所を参照するべきだ。

`README'ファイルは`INSTALL'というファイルを参照すべきだ。それはインス
トールのやり方の説明を含むべきだ。

`README'ファイルはまた著作物の条件を含むファイルを参照するべきだ。もし
使われていれば、GNU GPLは`COPYING'と呼ばれるファイルにあるべきだ。もし
GNU LGPLが使われているなら、それは`COPYING.LIB'と呼ばれるファイルにあ
るべきだ。

当然ソースファイルは全部配布物になければならない。ソースでないファイル
を配布物に入れても構わない。もしそれらが最新状態でマシンに依存しておら
ず、配布物は通常それらを変更することがあり得ないのなら。我々は普通
Bison、`lex'、TeX、そして`makeinfo'によって生成されたソースでないファ
イルを含めている。これは、ユーザがインストールしたいパッケージではどれ
でもインストールできるので、我々の配布物間での不必要な依存関係を避ける
のに役立っている。

プログラムを構築したりインストールすることによって実際に変更されるかも
しれないソースでないファイルは、*絶対に*配布物に入れるべきではない。だ
からもしソースでないファイルを配布するなら、新しい配布物を作るとき、そ
れらを常に最新にしておきなさい。

配布物が展開するディレクトリは(どのサブディレクトリも)全て誰でも書き込
み可能にしておきなさい(8進数モードの777)。これは、tarアーカイブのファ
イルの所有者と許可を保存する、`tar'の古いバージョンがそのユーザが特権
的でない場合でも全てのファイルを展開できるようにするためだ。

配布物の全てのファイルは誰でも読み込み可能にしておきなさい。

配布物の中にファイル名が14文字より長いものがないようにしておきなさい。
同様に、そのプログラムを構築することによって出来るファイルはどれも14文
字より長い名前を持たないようにするべきだ。これの理由は一部のシステムは
POSIX標準の馬鹿げた解釈に固執し、過去にやっていたように長い名前を切り
詰めるよりも開くことを拒んでいるからだ。

配布物それ自体にシンボリック・リンクを含めてはいけない。tarファイルが
シンボリック・リンクを含むなら、人々はシンボリック・リンクをサポートし
ないシステム上ではそれを展開することさえできない。また、異なるディレク
トリで一つのファイルに複数の名前を使ってはいけない。なぜなら、あるファ
イルシステムはこれを扱えないし、このことは配布物を展開できなくするから
だ。

全てのファイル名がMS-DOS上で重ならないようにしてみなさい。MS-DOSでの名
前は8文字以下から成り立ち、付加的にピリオドと3文字以下の文字がくっつく。
MS-DOSは余分な文字をピリオドの前と後両方で切り詰めるだろう。だから、
`foobarhacker.c'と`foobarhacker.o'は曖昧でない。それらは`foobarha.c'と
`foobarha.o'に切り詰められ、それらは区別できる。

あなたの配布物に`*.texinfo'や`*.texi'ファイルの出力を試験するのに使っ
た`texinfo.tex'のコピーを入れなさい。

同様に、もしあなたのプログラムがregex、getopt、obstack、あるいは
termcap のような小さなGNUソフトウェア・パッケージを使うなら、配布物に
それらを含めなさい。それらを省くと、その配布ファイルはちょっと小さくな
るが、他のファイルをどうやって手に入れるか分からないユーザにいくらか不
便になるという犠牲を払うことになる。



Tag table:
Node: Top1033
Node: Preface1489
Node: Legal Issues2290
Node: Reading Non-Free Code2571
Node: Contributions3544
Node: Design Advice4695
Node: Compatibility5066
Node: Using Extensions5909
Node: ANSI C6710
Node: Source Language7613
Node: Program Behavior8433
Node: Semantics8944
Node: Libraries11334
Node: Errors12005
Node: User Interfaces12702
Node: Option Table16400
Node: Memory Usage30957
Node: Writing C31488
Node: Formatting32083
Node: Comments34383
Node: Syntactic Conventions36191
Node: Names37906
Node: System Portability38871
Node: CPU Portability40104
Node: System Functions41319
Node: Internationalization44236
Node: Mmap46234
Node: Documentation46659
Node: GNU Manuals47071
Node: Manual Structure Details48981
Node: NEWS File50082
Node: Change Logs50514
Node: Change Log Concepts50989
Node: Style of Change Logs51916
Node: Simple Changes52983
Node: Conditional Changes53594
Node: Man Pages54391
Node: Reading other Manuals55269
Node: Managing Releases55703
Node: Configuration56164
Node: Makefile Conventions60315
Node: Makefile Basics60773
Node: Utilities in Makefiles62654
Node: Command Variables64023
Node: Directory Variables65763
Node: Standard Targets72619
Node: Install Command Categories79716
Node: Releases82644

End tag table
